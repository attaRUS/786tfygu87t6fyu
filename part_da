g.outputs.committer }}")
          fi
        command: >-
          bazel
          run
          "${BAZEL_RUN_ARGS[@]}"
          @envoy_repo//:release
          "${BAZEL_ARGS[@]}"
    - run: |
        VERSION=$(cat VERSION.txt)
        echo "version=v${VERSION}" >> $GITHUB_OUTPUT
      name: Release version
      id: release
    - name: Create a PR
      uses: envoyproxy/toolshed/gh-actions/github/pr@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      with:
        base: ${{ github.ref_name }}
        commit: false
        append-commit-message: true
        body: |
          Created by Envoy publish bot for @${{ github.actor }}
          ${{ ! inputs.summary && ':warning: Created without changelog summary, this will need to be updated before publishing' || '' }}
        branch: release/create/${{ steps.checkout.outputs.branch-name }}
        diff-upload: release-${{ steps.checkout.outputs.branch-name }}
        diff-show: true
        dry-run: ${{ ! inputs.pr }}
        wip: ${{ ! inputs.summary || inputs.wip }}
        title: >-
          [${{ (! inputs.summary || inputs.wip) && 'WIP/' || '' }}release/${{ steps.checkout.outputs.branch-name }}]
          repo: Release ${{ steps.release.outputs.version }}
        GITHUB_TOKEN: ${{ steps.appauth.outputs.token }}

  sync_version_histories:
    runs-on: ubuntu-22.04
    if: github.event_name == 'workflow_dispatch' && inputs.task == 'sync-version-histories'
    name: Sync version histories
    steps:
    - id: appauth
      name: App auth
      uses: envoyproxy/toolshed/gh-actions/appauth@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      with:
        app_id: ${{ secrets.ENVOY_CI_PUBLISH_APP_ID }}
        key: ${{ secrets.ENVOY_CI_PUBLISH_APP_KEY }}

    - id: checkout
      name: Checkout Envoy repository
      uses: envoyproxy/toolshed/gh-actions/github/checkout@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      with:
        committer-name: ${{ env.COMMITTER_NAME }}
        committer-email: ${{ env.COMMITTER_EMAIL }}
    - uses: envoyproxy/toolshed/gh-actions/github/run@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      name: Sync version histories
      with:
        command: >-
          bazel
          run
          --config=ci @envoy_repo//:sync
          --
          --signoff="${{ env.COMMITTER_NAME }} <${{ env.COMMITTER_EMAIL }}>"
    - name: Create a PR
      uses: envoyproxy/toolshed/gh-actions/github/pr@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      with:
        append-commit-message: true
        base: ${{ github.ref_name }}
        commit: false
        body: |
          Created by Envoy publish bot for @${{ github.actor }}
        branch: release/sync/${{ steps.checkout.outputs.branch-name }}
        diff-upload: version-histories-${{ steps.checkout.outputs.branch-name }}
        diff-show: true
        dry-run: ${{ ! inputs.pr }}
        GITHUB_TOKEN: ${{ steps.appauth.outputs.token }}
        title: >-
          ${{ steps.checkout.outputs.branch-name != 'main' && '[${{ steps.checkout.outputs.branch-name }}]' || '' }}
          repo: Sync version histories

  ## Triggered actions

  # On release to `main`:
  # - fork the branch to a release branch
  # - add an initial dev commit
  # - remove anything unwanted
  # - push branch
  create_release_branch:
    runs-on: ubuntu-22.04
    if: github.event_name == 'release' && endsWith(github.ref, '.0')
    name: Create release branch
    steps:
    - id: appauth
      name: App auth
      uses: envoyproxy/toolshed/gh-actions/appauth@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      with:
        app_id: ${{ secrets.ENVOY_CI_PUBLISH_APP_ID }}
        key: ${{ secrets.ENVOY_CI_PUBLISH_APP_KEY }}

    - name: Checkout repository
      uses: envoyproxy/toolshed/gh-actions/github/checkout@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      with:
        committer-name: ${{ env.COMMITTER_NAME }}
        committer-email: ${{ env.COMMITTER_EMAIL }}
        token: ${{ steps.appauth.outputs.token }}
    - name: Create release branch
      run: |
        version="$(cut -d- -f1 < VERSION.txt | cut -d. -f-2)"
        release_branch="release/v${version}"
        commit_sha="$(git rev-parse HEAD)"
        echo "Creating ${release_branch} from ${commit_sha}"
        git checkout -b "$release_branch"
        bazel run @envoy_repo//:dev -- --patch
        git rm -rf .github/workflows/mobile*yml
        git commit . -m "repo: Remove mobile ci for release branch"
        git log
        git push origin "$release_branch"
name: Command

# NB: **ALL** commands should be permissionless and only use an app token or relevant secrets
#   specific to their requirements!
permissions:
  contents: read

on:
  issue_comment:
    types:
    - created

env:
  CI_DEBUG: ${{ vars.CI_DEBUG }}


jobs:
  # For speed and _security_ only a single command (first matching) will be parsed/run from a comment
  command:
    name: Parse and run command
    runs-on: ubuntu-22.04
    if: >-
      ${{
         github.event.issue.pull_request
         && (vars.ENVOY_CI
             || github.repository == 'envoyproxy/envoy')
         && github.actor != 'repokitteh-read-only[bot]'
         && github.actor != 'dependabot[bot]'
      }}
    steps:
    - uses: envoyproxy/toolshed/gh-actions/github/command@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      name: Parse command from comment
      id: command
      with:
        text: ${{ github.event.comment.body }}
        matching: >-
          ^/(retest)

    # /retest
    - uses: envoyproxy/toolshed/gh-actions/appauth@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      if: ${{ steps.command.outputs.command == 'retest' }}
      id: appauth-retest
      name: Appauth (retest)
      with:
        key: ${{ secrets.ENVOY_CI_APP_KEY }}
        app_id: ${{ secrets.ENVOY_CI_APP_ID }}
    - uses: envoyproxy/toolshed/gh-actions/retest@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      if: ${{ steps.command.outputs.command == 'retest' }}
      name: Retest
      with:
        token: ${{ steps.appauth-retest.outputs.token }}
        azp_org: cncf
        azp_token: ${{ secrets.AZP_TOKEN }}
        comment-id: ${{ github.event.comment.id }}
        pr-url: ${{ github.event.issue.pull_request.url }}
        args: ${{ steps.command.outputs.args }}
        app-owner: ci-envoy
name: Precheck/deps

permissions:
  contents: read

on:
  workflow_call:
    inputs:
      dependency-review:
        type: boolean
        default: false
      request:
        type: string
        required: true
      trusted:
        type: boolean
        required: true

concurrency:
  group: ${{ github.head_ref || github.run_id }}-${{ github.workflow }}-publish
  cancel-in-progress: true


jobs:
  prechecks:
    permissions:
      contents: read
      packages: read
    uses: ./.github/workflows/_run.yml
    name: ${{ matrix.target }}
    with:
      bazel-extra: '--config=rbe-envoy-engflow'
      cache-build-image: ${{ fromJSON(inputs.request).request.build-image.default }}
      request: ${{ inputs.request }}
      error-match: |
        ERROR
        error:
        Error:
      rbe: ${{ matrix.rbe }}
      target: ${{ matrix.target }}
      trusted: ${{ inputs.trusted }}
    strategy:
      matrix:
        include:
        - target: deps
          rbe: false

  dependency-review:
    runs-on: ubuntu-22.04
    if: ${{ inputs.dependency-review }}
    steps:
    - name: Checkout Repository
      uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11  # v4.1.1
      with:
        ref: ${{ fromJSON(inputs.request).request.sha }}
        persist-credentials: false
    - name: Dependency Review
      uses: actions/dependency-review-action@4901385134134e04cec5fbe5ddfe3b2c5bd5d976  # v4.0.0
## CI configuration

CI is configured in .github/config.yml.

The configuration is per-branch and in this way different branches can have a different
runtime configuration.

In a pull request only 2 things are read from the config.yml submitted in the request:

- version
- build image

As these can change the way the CI runs they are allowed to change. No other configuration
is read from the pull request itself.

### Checks

Which checks should run against a commit or PR is configured under the `checks` key.

The names of these checks should match any checks that are set to required for the repo,
and if a check is required this should be set in the config to ensure the check is marked
as skipped if the related runs are skipped.

### Runs

This controls which workflows run, and where necessary which jobs in the workflows.

This paths can be configured with glob matches to match changed files.

Paths are always matched for PRs.

For push requests the config can be set to:

- always (default): Always runs
- paths: Runs when paths match
- never: Doesnt run on pushes

## CI requests

### All CI is requested

Whether triggered by push event or a pull_request all CI should be viewed as "requested".

This is very important as it means we can treat incoming triggers in much the same way
as we might handle an incoming web request.

Much like a web request, CI requests may be "trusted" or "untrusted" and as a consequence
have more or less capability or access.

Again, much like web requests, CI requests cannot be assumed to be safe.

Any incoming data - critically data over which a user has the capability to change should
be treated in the same way that user data is handled in a web request.

Failure to do this opens our CI up to many of the same attacks you might expect in a web scenario
- mostly injection attacks of various sorts.

### Requests are always made _from_ the triggering branch

The only CI workflow that is required/used on any branch other than `main` is `request.yml`.

This file contains any custom configurations required by the branch - for example, build images.

The request workflow on any branch always delegates to the `_request.yml` on `main`.

The `_request.yml` workflow contains all required configuration for handling an incoming request.

All other CI listens for the request workflow to run, and then runs with the requested/parsed data.

### CI is always run _in_ the context of main

Other than updating configurations in any given `request.yml` - no CI workflows are parsed
anywhere other than in the context of `main`.

This means that **all** changes must be made to the `main` workflows for _any_ branch _and_ for PRs.

Like branch CI, PRs also run in the context of `main` - making changes to these files in a PR will have
no effect until/unless they are landed on the `main` branch.

### Lifecycle of a CI request

#### Incoming request:

Requests can be triggered by a  `push` to `main` or a release branch or from a
`pull_request_target` to those branches.

The `request.yml` file handles this and *must* live on every branch.

This wf then calls the reusable `_request.yml` workflow, typically on `main`, but
branches can pin this if required.

#### Request is handled by `_request.yml` workflow:

This workflow initially reads the `.github/config.yml` from the target branch.

It uses this to decide which CI and which checks need to be run, and collects information
about the CI request.

This can be configured on a per-branch basis, by editing the file on the branch.

This also holds the authoritative build image information.

Users can request a CI run in a PR with custom build images by editing the config.yml file
on the relevant branch. CI will allow this but flag the change.

Likewise the version is checked at this stage, and CI flags if it has changed.

No other CI vars should be editable by users in a PR.

#### CI check runs *on main* listen for incoming requests and run if required:

These checks *always* run on `main` but with the repo checked out for the branch or the PR.

If branches require custom CI this can be added in the relevant file *on main* with
a condition to only trigger for relevant target branch.

#### Checks are completed at the end of each CI run:

Currently this reports only on the overall outcome of the CI run and updates the check.

We can add eg Slack reporting here to notify on failed `main` runs.

#### Retesting

PR CI can be retested by issuing `/retest` on the PR.

This finds the checks related to the latest request and restarts them if they are
failed or cancelled.

Links on the request page link to the original checks, but the checks themselves will
offer a `reload` button to refresh to the latest version.

## Branch CI

All CI is run on `main` - branch CI included.

The CI will checkout the correct commits and run the CI at that point.

This means that the CI on `main` should always be able to run the current supported branches.

There are possible workaround for custom branch CI but the better path is to ensure legacy support
in current `main` or backport any required changes.

## CI caching

Currently only x86 Docker images are cached.

Github has a hard per-repo limit of 10GB cache for CI which is LRU cycled when exceeded.

This should just be enough to store x86 and arm Docker images for most of our release branches
but will not leave anything to spare.

We can probably set up a bucket cache for bazel and other caching but this will need to be
done separately for un/trusted CI.

### Cache mutex

Due to shortcomings in Github's concurrency algorithm we are using a mutex lock that
is currently stored in the (private) https://github.com/envoyproxy/ci-mutex repository.

The lock allows CI jobs to wait while the cache is being primed rather than all jobs attempting
to prime the cache simultaneously.

## Development, testing and CI

Any Github workflows that use the repository context (`pull_request_target`, `workflow_run`, etc)
**are not tested in Pull Requests**

This means that changes to CI must be tested/verified in the (private) staging repository.

### CI enabling vars

The CI workflows and actions are receptive to certain environment variables being set.

`ENVOY_CI`: this allows CI to run in non-`envoyproxy/envoy` repos
`ENVOY_MOBILE_CI`: this allows mobile CI to be run in non-`envoyproxy/envoy` repos
`ENVOY_MACOS_CI`: this allows macOS CI to be run in non-`envoyproxy/envoy` repos
`ENVOY_WINDOWS_CI`: this allows Windows CI to be run in non-`envoyproxy/envoy` repos

With these flags activated the CI runs will respect the normal conditions for running.

### CI override vars

The CI workflows will also trigger for specific run settings.

For example:

`ENVOY_CI_RUN_MOBILE_ANDROID` would trigger the android CI irrespective of files changed, etc.

These correspond to the run names as configured in config.yml - for example:

`ENVOY_CI_RUN_BUILD_MACOS` would ensure the `build-macos` run is triggered.

### Debugging CI

Setting `CI_DEBUG` will provide a large amount of runtime information.

Generally this does not want to be set in a production context.
name: mobile_traffic_director

permissions:
  contents: read

on:
  # Disabled scheduled runs until https://github.com/envoyproxy/envoy/issues/31416 is resolved.
  # schedule:
  # - cron: '0 0 * * *'
  # Allows manual triggering in the UI. Makes it easier to test.
  workflow_dispatch:

concurrency:
  group: ${{ github.head_ref || github.run_id }}-github.workflow
  cancel-in-progress: true

jobs:
  cc_test:
    if: >-
      ${{
          github.repository == 'envoyproxy/envoy'
          && (github.event.schedule
              || !contains(github.actor, '[bot]'))
      }}
    name: cc_test
    permissions:
      contents: read
      packages: read
    runs-on: ubuntu-20.04
    timeout-minutes: 120
    steps:
    - name: Checkout repository
      uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11  # v4.1.1
    - name: Add safe directory
      run: git config --global --add safe.directory /__w/envoy/envoy
    - name: 'Run GcpTrafficDirectorIntegrationTest'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GCP_TEST_PROJECT_PROD_API_KEY: ${{ secrets.GCP_TEST_PROJECT_PROD_API_KEY }}
        # TODO(abeyad): remove this key once we're fully switched over to using the
        # prod consumer mesh shard.
        GCP_TEST_PROJECT_API_KEY: ${{ secrets.GCP_TEST_PROJECT_API_KEY }}
        ENVOY_IP_TEST_VERSIONS: v4only
      run: |
        cd mobile
        ./bazelw run \
            --config=mobile-remote-ci \
            --config=ci \
            //test/non_hermetic:gcp_traffic_director_integration_test
name: Mobile/Android build

permissions:
  contents: read

on:
  workflow_run:
    workflows:
    - Request
    types:
    - completed

concurrency:
  group: ${{ github.head_ref || github.run_id }}-${{ github.workflow }}
  cancel-in-progress: true


jobs:
  load:
    secrets:
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      lock-app-key: ${{ secrets.ENVOY_CI_MUTEX_APP_KEY }}
      lock-app-id: ${{ secrets.ENVOY_CI_MUTEX_APP_ID }}
    permissions:
      actions: read
      contents: read
      packages: read
      pull-requests: read
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    uses: ./.github/workflows/_load.yml
    with:
      check-name: mobile-android

  build:
    permissions:
      contents: read
      packages: read
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-android }}
    needs: load
    name: Build envoy.aar distributable
    uses: ./.github/workflows/_mobile_container_ci.yml
    with:
      args: >-
        build
        --config=mobile-remote-release-clang-android
        //:android_dist
      container: ${{ fromJSON(needs.load.outputs.build-image).mobile }}
      diskspace-hack: true
      request: ${{ needs.load.outputs.request }}
      timeout-minutes: 90
      target: build

  kotlin-hello-world:
    permissions:
      contents: read
      packages: read
    name: kotlin-hello-world
    uses: ./.github/workflows/_run.yml
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-android }}
    needs:
    - load
    - build
    with:
      command: ./bazelw
      container-command:
      # Return to using:
      #   ./bazelw mobile-install --fat_apk_cpu=x86_64 --start_app //examples/kotlin/hello_world:hello_envoy_kt
      # When https://github.com/envoyproxy/envoy-mobile/issues/853 is fixed.
      args: >-
        build
        --config=mobile-remote-release-clang-android
        //examples/kotlin/hello_world:hello_envoy_kt
      request: ${{ needs.load.outputs.request }}
      target: kotlin-hello-world
      runs-on: envoy-x64-small
      steps-pre: |
        - uses: envoyproxy/toolshed/gh-actions/envoy/android/pre@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      steps-post: |
        - uses: envoyproxy/toolshed/gh-actions/envoy/android/post@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
          with:
            apk: bazel-bin/examples/kotlin/hello_world/hello_envoy_kt.apk
            app: io.envoyproxy.envoymobile.helloenvoykotlin/.MainActivity
            status: 200
      timeout-minutes: 50
      trusted: ${{ fromJSON(needs.load.outputs.trusted) }}
      working-directory: mobile

  apps:
    permissions:
      contents: read
      packages: read
    name: Android apps
    uses: ./.github/workflows/_run.yml
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-android-all }}
    needs:
    - load
    - build
    with:
      command: ./bazelw
      container-command:
      args: ${{ matrix.args }}
      request: ${{ needs.load.outputs.request }}
      target: ${{ matrix.target }}
      runs-on: envoy-x64-small
      steps-pre: |
        - uses: envoyproxy/toolshed/gh-actions/envoy/android/pre@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      steps-post: ${{ matrix.steps-post }}
      timeout-minutes: 50
      trusted: ${{ fromJSON(needs.load.outputs.trusted) }}
      working-directory: mobile
    strategy:
      fail-fast: false
      matrix:
        include:
        - name: java-hello-world
          steps-post: |
            - uses: envoyproxy/toolshed/gh-actions/envoy/android/post@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
              with:
                apk: bazel-bin/examples/java/hello_world/hello_envoy.apk
                app: io.envoyproxy.envoymobile.helloenvoy/.MainActivity
                status: 301
          target: java-hello-world
          args: >-
            build
            --config=mobile-remote-release-clang-android
            //examples/java/hello_world:hello_envoy
        - name: kotlin-baseline-app
          # Return to using:
          #   ./bazelw mobile-install --fat_apk_cpu=x86_64 --start_app //examples/kotlin/hello_world:hello_envoy_kt
          # When https://github.com/envoyproxy/envoy-mobile/issues/853 is fixed.
          args: >-
            build
            --config=mobile-remote-release-clang-android
            //test/kotlin/apps/baseline:hello_envoy_kt
          steps-post: |
            - uses: envoyproxy/toolshed/gh-actions/envoy/android/post@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
              with:
                apk: bazel-bin/test/kotlin/apps/baseline/hello_envoy_kt.apk
                app: io.envoyproxy.envoymobile.helloenvoybaselinetest/.MainActivity
                status: 301
          target: kotlin-baseline-app
        - name: kotlin-experimental-app
          # Return to using:
          #   ./bazelw mobile-install --fat_apk_cpu=x86_64 --start_app //examples/kotlin/hello_world:hello_envoy_kt
          # When https://github.com/envoyproxy/envoy-mobile/issues/853 is fixed.
          args: >-
            build
            --config=mobile-remote-release-clang-android
            //test/kotlin/apps/experimental:hello_envoy_kt
          steps-post: |
            - uses: envoyproxy/toolshed/gh-actions/envoy/android/post@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
              with:
                apk: bazel-bin/test/kotlin/apps/experimental/hello_envoy_kt.apk
                app: io.envoyproxy.envoymobile.helloenvoyexperimentaltest/.MainActivity
                status: 200
          target: kotlin-experimental-app

  request:
    secrets:
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
    permissions:
      actions: read
      contents: read
      pull-requests: read
    if: >-
      ${{ always()
          && github.event.workflow_run.conclusion == 'success'
          && fromJSON(needs.load.outputs.request).run.mobile-android }}
    needs:
    - load
    - build
    - kotlin-hello-world
    - apps
    uses: ./.github/workflows/_finish.yml
    with:
      needs: ${{ toJSON(needs) }}
name: Mobile/Coverage

permissions:
  contents: read

on:
  workflow_run:
    workflows:
    - Request
    types:
    - completed

concurrency:
  group: ${{ github.head_ref || github.run_id }}-${{ github.workflow }}
  cancel-in-progress: true


jobs:
  load:
    secrets:
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      lock-app-key: ${{ secrets.ENVOY_CI_MUTEX_APP_KEY }}
      lock-app-id: ${{ secrets.ENVOY_CI_MUTEX_APP_ID }}
    permissions:
      actions: read
      contents: read
      packages: read
      pull-requests: read
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    uses: ./.github/workflows/_load.yml
    with:
      check-name: mobile-coverage

  coverage:
    permissions:
      contents: read
      packages: read
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-coverage }}
    needs: load
    name: Running mobile coverage
    uses: ./.github/workflows/_mobile_container_ci.yml
    with:
      args: >-
        //test/common/...
        //test/cc/...
      command: ../test/run_envoy_bazel_coverage.sh
      request: ${{ needs.load.outputs.request }}
      source:
        export COVERAGE_THRESHOLD=76
        export BAZEL_BUILD_OPTION_LIST=--config=mobile-remote-ci-linux-coverage
      steps-post: |
        - name: Package coverage
          shell: bash
          run: |
            cd mobile
            tar -czf coverage.tar.gz generated/coverage
      target: mobile-coverage
      timeout-minutes: 120
      upload-name: coverage.tar.gz
      upload-path: mobile/coverage.tar.gz

  request:
    secrets:
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
    permissions:
      actions: read
      contents: read
    if: >-
      ${{ always()
          && github.event.workflow_run.conclusion == 'success'
          && fromJSON(needs.load.outputs.request).run.mobile-coverage }}
    needs:
    - load
    - coverage
    uses: ./.github/workflows/_finish.yml
    with:
      needs: ${{ toJSON(needs) }}
yq
name: Mobile/Core

permissions:
  contents: read

on:
  workflow_run:
    workflows:
    - Request
    types:
    - completed

concurrency:
  group: ${{ github.head_ref || github.run_id }}-${{ github.workflow }}
  cancel-in-progress: true


jobs:
  load:
    secrets:
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      lock-app-key: ${{ secrets.ENVOY_CI_MUTEX_APP_KEY }}
      lock-app-id: ${{ secrets.ENVOY_CI_MUTEX_APP_ID }}
    permissions:
      actions: read
      contents: read
      packages: read
      pull-requests: read
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    uses: ./.github/workflows/_load.yml
    with:
      check-name: mobile-core

  unit-tests:
    permissions:
      contents: read
      packages: read
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-core }}
    needs: load
    uses: ./.github/workflows/_mobile_container_ci.yml
    with:
      args: >-
        test
        --config=mobile-remote-ci-core
        //test/common/...
      request: ${{ needs.load.outputs.request }}
      target: unit-tests
      timeout-minutes: 120

  request:
    secrets:
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
    permissions:
      actions: read
      contents: read
    if: >-
      ${{ always()
          && github.event.workflow_run.conclusion == 'success'
          && fromJSON(needs.load.outputs.request).run.mobile-core }}
    needs:
    - load
    - unit-tests
    uses: ./.github/workflows/_finish.yml
    with:
      needs: ${{ toJSON(needs) }}
name: Mobile/Perf

permissions:
  contents: read

on:
  workflow_run:
    workflows:
    - Request
    types:
    - completed

concurrency:
  group: ${{ github.head_ref || github.run_id }}-${{ github.workflow }}
  cancel-in-progress: true


jobs:
  load:
    secrets:
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      lock-app-key: ${{ secrets.ENVOY_CI_MUTEX_APP_KEY }}
      lock-app-id: ${{ secrets.ENVOY_CI_MUTEX_APP_ID }}
    permissions:
      actions: read
      contents: read
      packages: read
      pull-requests: read
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    uses: ./.github/workflows/_load.yml
    with:
      check-name: mobile-perf

  build:
    permissions:
      contents: read
      packages: read
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-perf }}
    needs: load
    name: Build test binaries
    uses: ./.github/workflows/_mobile_container_ci.yml
    with:
      args: ${{ matrix.args }}
      command: ./bazelw
      ref: ${{ matrix.ref }}
      request: ${{ needs.load.outputs.request }}
      source: ${{ matrix.source }}
      container-output: |
        "bazel-bin/test/performance/test_binary_size": test_binary_size/${{ matrix.target }}
      target: ${{ matrix.target }}
      upload-name: ${{ matrix.target }}
      upload-path: /tmp/container-output/test_binary_size
      timeout-minutes: 90
    strategy:
      matrix:
        include:
        - name: Current size
          args: >-
            build
            --config=mobile-remote-release-clang
            //test/performance:test_binary_size
          # Ensure files don't leak back into the main binary
          source: >-
            rm
            source/common/listener_manager/listener_manager_impl.h
            source/server/overload_manager_impl.cc
            source/common/network/listen_socket_impl.h
            source/common/network/tcp_listener_impl.h
            source/server/guarddog_impl.h
            source/server/watchdog_impl.h
            source/server/options_impl.cc
          target: size-current
        - name: Main size
          args: >-
            build
            --config=mobile-remote-release-clang
            //test/performance:test_binary_size
          ref: main
          target: size-main

  compare:
    permissions:
      contents: read
      packages: read
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-perf }}
    needs:
    - load
    - build
    name: size_compare
    uses: ./.github/workflows/_mobile_container_ci.yml
    with:
      args: >-
        ../dist/main.zip
        ../dist/current.zip
      command: ./ci/test_size_regression.sh
      downloads: |
        size-current: dist/sizecurrent
        size-main: dist/sizemain
      request: ${{ needs.load.outputs.request }}
      runs-on: ubuntu-22.04
      source: |
        strip -s -o dist/main.stripped dist/sizemain/size-main
        strip -s -o dist/current.stripped dist/sizecurrent/size-current
        zip -9 dist/main.zip dist/main.stripped
        zip -9 dist/current.zip dist/current.stripped
      target: size-compare
      timeout-minutes: 30

  request:
    secrets:
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
    permissions:
      actions: read
      contents: read
      pull-requests: read
    if: >-
      ${{ always()
          && github.event.workflow_run.conclusion == 'success'
          && fromJSON(needs.load.outputs.request).run.mobile-perf }}
    needs:
    - load
    - build
    - compare
    uses: ./.github/workflows/_finish.yml
    with:
      needs: ${{ toJSON(needs) }}
name: Mobile/CC

permissions:
  contents: read

on:
  workflow_run:
    workflows:
    - Request
    types:
    - completed

concurrency:
  group: ${{ github.head_ref || github.run_id }}-${{ github.workflow }}
  cancel-in-progress: true


jobs:
  load:
    secrets:
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      lock-app-key: ${{ secrets.ENVOY_CI_MUTEX_APP_KEY }}
      lock-app-id: ${{ secrets.ENVOY_CI_MUTEX_APP_ID }}
    permissions:
      actions: read
      contents: read
      packages: read
      pull-requests: read
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    uses: ./.github/workflows/_load.yml
    with:
      check-name: mobile-cc

  cc-tests:
    permissions:
      contents: read
      packages: read
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-cc }}
    needs: load
    name: cc-tests
    uses: ./.github/workflows/_mobile_container_ci.yml
    with:
      args: >-
        test
        --config=mobile-remote-ci-cc
        //test/cc/...
      request: ${{ needs.load.outputs.request }}
      target: cc-tests
      timeout-minutes: 120

  request:
    secrets:
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
    permissions:
      actions: read
      contents: read
    if: >-
      ${{ always()
          && github.event.workflow_run.conclusion == 'success'
          && fromJSON(needs.load.outputs.request).run.mobile-cc }}
    needs:
    - load
    - cc-tests
    uses: ./.github/workflows/_finish.yml
    with:
      needs: ${{ toJSON(needs) }}
name: Mobile/Release validation

permissions:
  contents: read

on:
  workflow_run:
    workflows:
    - Request
    types:
    - completed

concurrency:
  group: ${{ github.head_ref || github.run_id }}-${{ github.workflow }}
  cancel-in-progress: true


jobs:
  load:
    secrets:
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      lock-app-key: ${{ secrets.ENVOY_CI_MUTEX_APP_KEY }}
      lock-app-id: ${{ secrets.ENVOY_CI_MUTEX_APP_ID }}
    permissions:
      actions: read
      contents: read
      packages: read
      pull-requests: read
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    uses: ./.github/workflows/_load.yml
    with:
      cache-docker: false
      check-name: mobile-release-validation

  validate-swiftpm-example:
    permissions:
      contents: read
      packages: read
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-release-validation }}
    needs: load
    uses: ./.github/workflows/_run.yml
    name: Build xframework
    with:
      args: >-
        build
        --config=mobile-remote-ci-macos-ios
        //:ios_xcframework
      command: ./bazelw
      container-command:
      request: ${{ needs.load.outputs.request }}
      runs-on: macos-12
      source: |
        # TODO(fredyw): A workaround since mobile/WORKSPACE always requires Android SDK to be available
        # and the GitHub Action runner image no longer includes Android SDK 30:
        # https://github.com/actions/runner-images/issues/8952
        ./ci/mac_ci_setup.sh --android
      # Ignore errors: Bad CRC when unzipping large files: https://bbs.archlinux.org/viewtopic.php?id=153011
      steps-post: |
        - run: |
            unzip mobile/bazel-bin/library/swift/Envoy.xcframework.zip \
                  -d mobile/examples/swift/swiftpm/Packages \
                || :
          shell: bash
          name: Unzip xcframework
        - run: |
            xcodebuild -project mobile/examples/swift/swiftpm/EnvoySwiftPMExample.xcodeproj \
                       -scheme EnvoySwiftPMExample \
                       -destination platform="iOS Simulator,name=iPhone 14 Pro Max,OS=16.1"
          shell: bash
          name: Build app
        # TODO(jpsim): Run app and inspect logs to validate
      target: validate-swiftpm-example
      timeout-minutes: 120
      trusted: ${{ fromJSON(needs.load.outputs.trusted) }}
      working-directory: mobile

  request:
    secrets:
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
    permissions:
      actions: read
      contents: read
      pull-requests: read
    if: >-
      ${{ always()
          && github.event.workflow_run.conclusion == 'success'
          && fromJSON(needs.load.outputs.request).run.mobile-release-validation }}
    needs:
    - load
    - validate-swiftpm-example
    uses: ./.github/workflows/_finish.yml
    with:
      needs: ${{ toJSON(needs) }}
name: Envoy CI

permissions:
  contents: read

on:
  workflow_call:
    secrets:
      app-id:
      app-key:
      rbe-key:
      ssh-key:
      ssh-key-extra:
    inputs:
      args:
        type: string
      bazel-extra:
        type: string
      bazel-rbe-jobs:
        type: number
        default: 75
      cache-build-image:
        type: string
      catch-errors:
        type: boolean
        default: false
      checkout-extra:
        type: string
      container-command:
        type: string
        default: ./ci/run_envoy_docker.sh
      container-output:
        type: string
        default:
      command:
        type: string
        default: ./ci/do_ci.sh
      diskspace-hack:
        type: boolean
        default: false
      diskspace-hack-paths:
        type: string
        default:
      downloads:
        type: string
      entrypoint:
        type: string
        default:
      error-match:
        type: string
        default: |
          ERROR
          error:
          Error:
      notice-match:
        type: string
        default: |
          NOTICE
          Streaming build results
      output-path:
        type: string
        default:
      rbe:
        type: boolean
        default: true
      repo-fetch-depth:
        type: number
        default: 1
      report-pre:
        type: string
        default: |
          - run: |
              echo "disk space at beginning of build:"
              df -h
            shell: bash
      report-post:
        type: string
        default: |
          - run: |
              echo "disk space at end of build:"
              df -h
            shell: bash
      request:
        type: string
        required: true
      runs-on:
        type: string
        default:
      skip:
        type: boolean
        default: false
      source:
        type: string
      summary-post:
        type: string
        default: |
          - uses: envoyproxy/toolshed/gh-actions/envoy/run/summary@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
            with:
              context: %{{ inputs.context }}
      steps-pre:
        type: string
      steps-pre-name:
        type: string
      steps-post:
        type: string
        default: |
          - run: |
              du -ch "%{{ inputs.temp-dir || runner.temp }}" | grep -E "[0-9]{2,}M|[0-9]G" || :
            shell: bash
      steps-post-name:
        type: string
      target:
        type: string
        required: true
      temp-dir:
        type: string
      timeout-minutes:
        type: number
      trusted:
        type: boolean
        required: true
      upload-name:
        type: string
      upload-path:
        type: string
      warning-match:
        type: string
        default: |
          WARNING
          warning:
          Warning:
      working-directory:
        type: string
        default: .

concurrency:
  group: >-
    ${{ github.actor != 'trigger-release-envoy[bot]'
        && github.head_ref
        || github.run_id
    }}-${{ github.workflow }}-${{ inputs.target }}
  cancel-in-progress: true

env:
  CI_DEBUG: ${{ vars.CI_DEBUG }}


jobs:
  ci:
    permissions:
      contents: read
      packages: read
    if: ${{ ! inputs.skip }}
    runs-on: ${{ inputs.runs-on || fromJSON(inputs.request).config.ci.agent-ubuntu }}
    name: ${{ inputs.command }} ${{ inputs.target }}
    timeout-minutes: ${{ inputs.timeout-minutes }}
    steps:
    - uses: envoyproxy/toolshed/gh-actions/jq@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      id: started
      name: Create timestamp
      with:
        options: -r
        filter: |
          now
    # This controls which input vars are exposed to the run action (and related steps)
    - uses: envoyproxy/toolshed/gh-actions/jq@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      name: Context
      id: context
      with:
        print-result: ${{ fromJSON(env.CI_DEBUG || 'false') && true || false }}
        input: ${{ inputs.request }}
        filter: |
          .
          | (.check // {name: "${{ github.workflow }}"}) as $check
          | .config as $config
          | if "${{ inputs.runs-on }}" != "" then
              "${{ inputs.runs-on }}"
            else .config.ci["agent-ubuntu"] end
          | . as $runsOn
          | {"target": "${{ inputs.target }}",
             "catch-errors": ${{ inputs.catch-errors }},
             "runs-on": $runsOn,
             "job-started": ${{ steps.started.outputs.value }}}
          | . * {$config, $check}
    - if: ${{ inputs.cache-build-image }}
      name: Restore Docker cache ${{ inputs.cache-build-image && format('({0})', inputs.cache-build-image) || '' }}
      uses: envoyproxy/toolshed/gh-actions/docker/cache/restore@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      with:
        image_tag: ${{ inputs.cache-build-image }}

    - uses: envoyproxy/toolshed/gh-actions/appauth@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      id: appauth
      name: Appauth
      if: ${{ inputs.trusted }}
      with:
        app_id: ${{ secrets.app-id }}
        key: ${{ secrets.app-key }}
        # You cant use a secret as a condition so this always runs even if the app id/key are empty
        # - the workaround is to allow the token to be passed through.
        token: ${{ github.token }}
        token-ok: true
    - uses: envoyproxy/toolshed/gh-actions/github/checkout@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      id: checkout
      name: Checkout Envoy repository
      with:
        branch: ${{ fromJSON(inputs.request).request.target-branch }}
        config: |
          fetch-depth: ${{ inputs.repo-fetch-depth }}
          # WARNING: This allows untrusted code to run!!!
          #  If this is set to run untrusted code, then anything before or after in the job should be regarded as
          #  compromisable.
          ref: ${{ inputs.trusted && fromJSON(inputs.request).request.sha || fromJSON(inputs.request).request.ref }}
        fetch-merge-commit: false
        pr: ${{ fromJSON(inputs.request).request.pr }}
        ssh-key: ${{ inputs.trusted && inputs.ssh-key || '' }}
        token: ${{ inputs.trusted && steps.appauth.outputs.token || github.token }}

    # This is currently only use by mobile-docs and can be removed once they are updated to the newer website
    - uses: envoyproxy/toolshed/gh-actions/github/checkout@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      id: checkout-extra
      name: Checkout extra repository (for publishing)
      if: ${{ inputs.checkout-extra }}
      with:
        config: ${{ inputs.checkout-extra }}
        ssh-key: ${{ inputs.trusted && inputs.ssh-key-extra || '' }}

    - uses: envoyproxy/toolshed/gh-actions/github/run@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      name: Run CI ${{ inputs.command }} ${{ inputs.target }}
      with:
        args: ${{ inputs.args != '--' && inputs.args || inputs.target }}
        catch-errors: ${{ inputs.catch-errors }}
        command: ${{ inputs.command }}
        container-command: ${{ env.CONTAINER_COMMAND || inputs.container-command }}
        container-output: ${{ inputs.container-output }}
        context: ${{ steps.context.outputs.value }}
        diskspace-hack: ${{ inputs.diskspace-hack }}
        diskspace-hack-paths: ${{ inputs.diskspace-hack-paths }}
        downloads: ${{ inputs.downloads }}
        entrypoint: ${{ inputs.entrypoint }}
        error-match: ${{ inputs.error-match }}
        notice-match: ${{ inputs.notice-match }}
        output-path: ${{ inputs.output-path }}
        report-pre: ${{ inputs.report-pre }}
        report-post: ${{ inputs.report-post }}
        source: ${{ inputs.source }}
        steps-pre: ${{ inputs.steps-pre }}
        steps-pre-name: ${{ inputs.steps-pre-name }}
        steps-post: ${{ inputs.steps-post }}
        steps-post-name: ${{ inputs.steps-post-name }}
        summary-post: ${{ inputs.summary-post }}
        upload-name: ${{ inputs.upload-name }}
        upload-path: ${{ inputs.upload-path }}
        warning-match: ${{ inputs.warning-match }}
        working-directory: ${{ inputs.working-directory }}
      env:
        GITHUB_TOKEN: ${{ inputs.trusted && steps.appauth.outputs.token || github.token }}
        ENVOY_DOCKER_BUILD_DIR: ${{ runner.temp }}
        ENVOY_RBE: ${{ inputs.rbe != 'false' && 1 || '' }}
        RBE_KEY: ${{ secrets.rbe-key }}
        BAZEL_BUILD_EXTRA_OPTIONS: >-
          --config=remote-ci
          ${{ inputs.bazel-extra }}
          ${{ inputs.rbe != 'false' && format('--jobs={0}', inputs.bazel-rbe-jobs) || '' }}
        BAZEL_FAKE_SCM_REVISION: ${{ github.event_name == 'pull_request' && 'e3b4a6e9570da15ac1caffdded17a8bebdc7dfc9' || '' }}
        CI_TARGET_BRANCH: ${{ fromJSON(inputs.request).request.target-branch }}
name: Request/load

permissions:
  contents: read

on:
  workflow_call:
    secrets:
      app-id:
        required: true
      app-key:
        required: true
      lock-app-id:
        required: true
      lock-app-key:
        required: true

    inputs:
      agent-ubuntu:
        type: string
        default: ubuntu-22.04
      cache-docker:
        type: boolean
        default: true
      check-name:
        type: string
        required: true
      check-title:
        type: string
        default:
      head-sha:
        type: string
        default:
      run-id:
        type: string
        default: ${{ github.event.workflow_run.id }}
      template-request-summary:
        type: string
        default: |
          ## \($linkedTitle)

          \($summary)

          \($extra)

    outputs:
      build-image:
        value: ${{ jobs.request.outputs.build-image }}
      build-image-mobile:
        value: ${{ jobs.request.outputs.build-image-mobile }}
      check-id:
        value: ${{ jobs.request.outputs.check-id }}
      check-name:
        value: ${{ inputs.check-name }}
      request:
        value: ${{ jobs.request.outputs.request }}
      run-id:
        value: ${{ inputs.run-id }}
      trusted:
        value: ${{ jobs.request.outputs.trusted }}

concurrency:
  group: |
    ${{ github.actor != 'trigger-release-envoy[bot]'
        && github.head_ref
        || github.run_id
    }}-${{ github.workflow }}-env
  cancel-in-progress: true

env:
  CI_DEBUG: ${{ vars.CI_DEBUG && true || false }}


jobs:
  request:
    if: ${{ github.repository == 'envoyproxy/envoy' || vars.ENVOY_CI }}
    runs-on: ubuntu-22.04
    permissions:
      actions: read
      contents: read
      pull-requests: read
    outputs:
      build-image: ${{ toJSON(fromJSON(steps.request-output.outputs.value).request.build-image) }}
      build-image-mobile: ${{ fromJSON(steps.request-output.outputs.value).request.build-image-mobile }}
      check-id: ${{ fromJSON(steps.request-output.outputs.value).check.check-id }}
      request: ${{ steps.request-output.outputs.value }}
      trusted: ${{ fromJSON(steps.request-output.outputs.value).request.trusted }}
      skip: ${{ fromJSON(steps.request-output.outputs.value).check.action != 'RUN' }}
    steps:
    # Load env data
    # Handle any failure in triggering job
    # Remove any `checks` we dont care about
    # Prepare a check request
    - uses: envoyproxy/toolshed/gh-actions/github/env/load@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      name: Load env
      id: data
      with:
        run-id: ${{ inputs.run-id }}
        check-name: ${{ inputs.check-name }}
        head-sha: ${{ inputs.head-sha }}
      env:
        GH_TOKEN: ${{ github.token }}

    #  Update the check
    - uses: envoyproxy/toolshed/gh-actions/appauth@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      name: Appauth
      id: appauth
      with:
        app_id: ${{ secrets.app-id }}
        key: ${{ secrets.app-key }}
    - uses: envoyproxy/toolshed/gh-actions/github/checks@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      name: Update check
      if: ${{ fromJSON(steps.data.outputs.data).data.check.action == 'RUN' }}
      with:
        action: update
        checks: ${{ toJSON(fromJSON(steps.data.outputs.data).checks) }}
        token: ${{ steps.appauth.outputs.token }}

    - uses: envoyproxy/toolshed/gh-actions/jq@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      name: Print request summary
      with:
        input: |
          action: ${{ fromJSON(steps.data.outputs.data).data.check.action }}
          summary: ${{ toJSON(fromJSON(steps.data.outputs.data).data.summary) }}
        input-format: yaml
        output-path: GITHUB_STEP_SUMMARY
        options: -r
        filter: |
          .action as $action
          | .summary as $summary
          | if ($action != "RUN") then
              "### ${{ github.workflow }} was skipped"
            else "" end
          | . as $extra
          | $summary["linked-title"] as $linkedTitle
          | $summary.summary as $summary
          | "${{ inputs.template-request-summary }}"

    - uses: envoyproxy/toolshed/gh-actions/jq@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      id: request-output
      name: Load request
      with:
        input: |
          check: ${{ toJSON(fromJSON(steps.data.outputs.data).data.check) }}
          config: ${{ toJSON(fromJSON(steps.data.outputs.data).data.config) }}
          request: ${{ toJSON(fromJSON(steps.data.outputs.data).data.request) }}
          run: ${{ toJSON(fromJSON(steps.data.outputs.data).data.run) }}
          summary_title: ${{ fromJSON(steps.data.outputs.data).data.summary.title }}
        input-format: yaml
        filter: |
          .
          | .summary = {title: .summary_title}
          | del(.request.message, .summary_title)
        print-result: ${{ fromJSON(env.CI_DEBUG || 'false') && true || false }}

  cache:
    secrets:
      app-id: ${{ secrets.lock-app-id }}
      app-key: ${{ secrets.lock-app-key }}
    uses: ./.github/workflows/_cache.yml
    needs: request
    if: ${{ inputs.cache-docker && ! fromJSON(needs.request.outputs.skip) }}
    with:
      request: ${{ toJSON(needs.request.outputs) }}
      image-tag: ${{ fromJSON(needs.request.outputs.build-image).default }}
name: 'Sync downstream'

permissions:
  contents: read

on:
  push:
    branches:
    - main
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

jobs:
  sync:
    runs-on: ubuntu-22.04
    if: >-
      ${{
          github.repository == 'envoyproxy/envoy'
          && (github.event.push
              || !contains(github.actor, '[bot]'))
      }}
    strategy:
      fail-fast: false
      matrix:
        downstream:
        - go-control-plane
        - envoy-filter-example
        - data-plane-api
        - mobile-website
    steps:
    - uses: envoyproxy/toolshed/gh-actions/appauth@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      id: appauth
      with:
        app_id: ${{ secrets.ENVOY_CI_SYNC_APP_ID }}
        key: ${{ secrets.ENVOY_CI_SYNC_APP_KEY }}
    - uses: envoyproxy/toolshed/gh-actions/dispatch@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      with:
        repository: "envoyproxy/${{ matrix.downstream }}"
        ref: main
        token: ${{ steps.appauth.outputs.token }}
        workflow: envoy-sync.yaml
name: Mobile/TSAN

permissions:
  contents: read

on:
  workflow_run:
    workflows:
    - Request
    types:
    - completed

concurrency:
  group: ${{ github.head_ref || github.run_id }}-${{ github.workflow }}
  cancel-in-progress: true


jobs:
  load:
    secrets:
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      lock-app-key: ${{ secrets.ENVOY_CI_MUTEX_APP_KEY }}
      lock-app-id: ${{ secrets.ENVOY_CI_MUTEX_APP_ID }}
    permissions:
      actions: read
      contents: read
      packages: read
      pull-requests: read
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    uses: ./.github/workflows/_load.yml
    with:
      check-name: mobile-tsan
      run-id: ${{ github.event.workflow_run.id }}

  tsan:
    permissions:
      contents: read
      packages: read
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-tsan }}
    needs: load
    name: tsan
    uses: ./.github/workflows/_mobile_container_ci.yml
    with:
      args: >-
        test
        --config=mobile-remote-ci-linux-tsan
        //test/common/...
        //test/cc/...
      request: ${{ needs.load.outputs.request }}
      target: tsan
      timeout-minutes: 90

  request:
    secrets:
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
    permissions:
      actions: read
      contents: read
    if: >-
      ${{ always()
          && github.event.workflow_run.conclusion == 'success'
          && fromJSON(needs.load.outputs.request).run.mobile-tsan }}
    needs:
    - load
    - tsan
    uses: ./.github/workflows/_finish.yml
    with:
      needs: ${{ toJSON(needs) }}
name: Mobile/Format

permissions:
  contents: read

on:
  workflow_run:
    workflows:
    - Request
    types:
    - completed

concurrency:
  group: ${{ github.head_ref || github.run_id }}-${{ github.workflow }}
  cancel-in-progress: true


jobs:
  load:
    secrets:
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      lock-app-key: ${{ secrets.ENVOY_CI_MUTEX_APP_KEY }}
      lock-app-id: ${{ secrets.ENVOY_CI_MUTEX_APP_ID }}
    permissions:
      actions: read
      contents: read
      packages: read
      pull-requests: read
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    uses: ./.github/workflows/_load.yml
    with:
      check-name: mobile-format

  container:
    permissions:
      contents: read
      packages: read
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-format }}
    needs: load
    uses: ./.github/workflows/_mobile_container_ci.yml
    with:
      args: ${{ matrix.args }}
      command: ${{ matrix.command }}
      container: ${{ matrix.container }}
      request: ${{ needs.load.outputs.request }}
      target: ${{ matrix.target }}
      timeout-minutes: ${{ matrix.timeout-minutes }}
    strategy:
      fail-fast: false
      matrix:
        include:
        - name: Format all
          args: check
          command: ./tools/check_format.sh
          target: format-all
          timeout-minutes: 45
        - name: Swift lint
          args: >-
            lint
            --strict
          command: swiftlint
          container: >-
            ghcr.io/realm/swiftlint:0.50.3
          target: swift-lint
          timeout-minutes: 45

  request:
    secrets:
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
    permissions:
      actions: read
      contents: read
      pull-requests: read
    if: >-
      ${{ always()
          && github.event.workflow_run.conclusion == 'success'
          && fromJSON(needs.load.outputs.request).run.mobile-format }}
    needs:
    - load
    - container
    uses: ./.github/workflows/_finish.yml
    with:
      needs: ${{ toJSON(needs) }}
name: Mobile/Android tests

permissions:
  contents: read

on:
  workflow_run:
    workflows:
    - Request
    types:
    - completed

concurrency:
  group: ${{ github.head_ref || github.run_id }}-${{ github.workflow }}
  cancel-in-progress: true


jobs:
  load:
    secrets:
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      lock-app-key: ${{ secrets.ENVOY_CI_MUTEX_APP_KEY }}
      lock-app-id: ${{ secrets.ENVOY_CI_MUTEX_APP_ID }}
    permissions:
      actions: read
      contents: read
      packages: read
      pull-requests: read
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    uses: ./.github/workflows/_load.yml
    with:
      check-name: mobile-android-tests

  linux:
    permissions:
      contents: read
      packages: read
    name: Android linux tests
    uses: ./.github/workflows/_mobile_container_ci.yml
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-android-tests }}
    needs: load
    with:
      args: ${{ matrix.args }}
      container: ${{ fromJSON(needs.load.outputs.build-image).mobile }}
      diskspace-hack: true
      request: ${{ needs.load.outputs.request }}
      target: ${{ matrix.target }}
      timeout-minutes: 90
    strategy:
      fail-fast: false
      matrix:
        include:
        - name: java
          target: java_tests_linux
          args: >-
            test
            --config=mobile-remote-ci-android
            //test/java/...
        - name: kotlin
          target: kotlin_tests_linux
          args: >-
            test
            --config=mobile-remote-ci-android
            //test/kotlin/...

  request:
    secrets:
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
    permissions:
      actions: read
      contents: read
      pull-requests: read
    if: >-
      ${{ always()
          && github.event.workflow_run.conclusion == 'success'
          && fromJSON(needs.load.outputs.request).run.mobile-android-tests }}
    needs:
    - load
    - linux
    uses: ./.github/workflows/_finish.yml
    with:
      needs: ${{ toJSON(needs) }}
name: Mobile/Docs

permissions:
  contents: read

on:
  workflow_run:
    workflows:
    - Request
    types:
    - completed

concurrency:
  group: ${{ github.head_ref || github.run_id }}-${{ github.workflow }}
  cancel-in-progress: true


jobs:
  load:
    secrets:
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      lock-app-key: ${{ secrets.ENVOY_CI_MUTEX_APP_KEY }}
      lock-app-id: ${{ secrets.ENVOY_CI_MUTEX_APP_ID }}
    permissions:
      actions: read
      contents: read
      packages: read
      pull-requests: read
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    uses: ./.github/workflows/_load.yml
    with:
      check-name: mobile-docs

  docs:
    secrets:
      ssh-key-extra: ${{ needs.load.outputs.trusted  && secrets.ENVOY_MOBILE_WEBSITE_DEPLOY_KEY || '' }}
    permissions:
      contents: read
      packages: read
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-docs }}
    needs: load
    uses: ./.github/workflows/_run.yml
    with:
      args: >-
        --
      command: ./docs/build.sh
      request: ${{ needs.load.outputs.request }}
      target: mobile-docs
      cache-build-image: ${{ fromJSON(needs.load.outputs.build-image).build-image }}
      checkout-extra: |
        repository: envoy-mobile/envoy-mobile.github.io
        path: mobile-docs
        fetch-depth: 0
        branch: master
      source: |
        echo "ENVOY_DOCKER_SOURCE_DIR=/source/mobile" >> $GITHUB_ENV
        # Path relative to ./mobile directory
        echo "MOBILE_DOCS_CHECKOUT_DIR=../mobile-docs" >> $GITHUB_ENV
      steps-post: |
        - name: Publish docs
          shell: bash
          run: |
            ./ci/run_envoy_docker.sh docs/publish.sh
        # This step needs to be done outside the container to access ssh creds
        - name: Push changes
          # && github.repository == 'envoyproxy/envoy'
          if: ${{ needs.load.outputs.trusted }}
          shell: bash
          run: |
            git -C mobile-docs status
            exit 0
            git -C mobile-docs push origin master
      timeout-minutes: 20
      trusted: ${{ fromJSON(needs.load.outputs.trusted) }}
      upload-name: docs
      upload-path: mobile/generated/docs

  request:
    secrets:
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
    permissions:
      actions: read
      contents: read
      pull-requests: read
    if: >-
      ${{ always()
          && github.event.workflow_run.conclusion == 'success'
          && fromJSON(needs.load.outputs.request).run.mobile-docs }}
    needs:
    - load
    - docs
    uses: ./.github/workflows/_finish.yml
    with:
      needs: ${{ toJSON(needs) }}
name: Publish

permissions:
  contents: read

# The matrices in this config can be combined once the calling workflow has shifted
# to a `pull_request`/`commit` pattern (ie not `workflow_dispatch`)
#
# For now pre/post submit is split between `publish_ci`/`publish`, the latter running
# only for "trusted" runs and having access to secrets/permissions

on:
  workflow_call:
    secrets:
      ENVOY_CI_SYNC_APP_ID:
      ENVOY_CI_SYNC_APP_KEY:
      ENVOY_CI_PUBLISH_APP_ID:
      ENVOY_CI_PUBLISH_APP_KEY:
    inputs:
      request:
        type: string
        required: true
      trusted:
        type: boolean
        required: true

concurrency:
  group: >-
    ${{ github.actor != 'trigger-release-envoy[bot]'
        && github.event.inputs.head_ref
        || github.run_id
    }}-${{ github.event.workflow.id }}-publish
  cancel-in-progress: true


jobs:
  publish:
    secrets:
      app-id: ${{ inputs.trusted && secrets.ENVOY_CI_PUBLISH_APP_ID || '' }}
      app-key: ${{ inputs.trusted && secrets.ENVOY_CI_PUBLISH_APP_KEY || '' }}
    permissions:
      contents: read
      packages: read
    name: ${{ matrix.name || matrix.target }}
    uses: ./.github/workflows/_run.yml
    with:
      target: ${{ matrix.target }}
      rbe: false
      cache-build-image: ${{ fromJSON(inputs.request).request.build-image.default }}
      source: ${{ matrix.source }}
      request: ${{ inputs.request }}
      steps-pre: ${{ matrix.steps-pre }}
      trusted: ${{ inputs.trusted }}
    strategy:
      fail-fast: false
      matrix:
        include:
        - target: publish
          name: github
          source: |
            export ENVOY_COMMIT=${{ fromJSON(inputs.request).request.sha }}
            export ENVOY_REPO=${{ github.repository }}
            export ENVOY_PUBLISH_DRY_RUN=${{ (fromJSON(inputs.request).request.version.dev || ! inputs.trusted) && 1 || '' }}
          steps-pre: |
            - id: url
              uses: envoyproxy/toolshed/gh-actions/jq@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
              with:
                options: -Rr
                input: >-
                  ${{ inputs.trusted
                      && fromJSON(inputs.request).request.sha
                      || fromJSON(inputs.request).request.ref }}
                filter: |
                  .[:7] as $sha
                  | "release/release.signed.tar.zst" as $path
                  | if ${{ inputs.trusted }} then
                      "envoy-postsubmit"
                    else
                      "envoy-pr"
                    end
                  | . as $bucket
                  | "https://storage.googleapis.com/\($bucket)/\($sha)/\($path)"
            - uses: envoyproxy/toolshed/gh-actions/fetch@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
              with:
                url: %{{ steps.url.outputs.value }}
                path: %{{ runner.temp }}/release.signed

  publish_docs:
    # For normal commits to Envoy main this will trigger an update in the website repo,
    # which will update its envoy dep shas, and rebuild the website for the latest docs
    #
    # For commits that create a release, it instead triggers an update in the archive repo,
    # which builds a static version of the docs for the release and commits it to the archive.
    # In turn the archive repo triggers an update in the website so the new release docs are
    # included in the published site
    if: ${{ inputs.trusted && github.repository == 'envoyproxy/envoy' }}
    runs-on: ubuntu-22.04
    needs:
    - publish
    steps:
    - uses: envoyproxy/toolshed/gh-actions/appauth@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      id: appauth
      with:
        app_id: ${{ secrets.ENVOY_CI_SYNC_APP_ID }}
        key: ${{ secrets.ENVOY_CI_SYNC_APP_KEY }}
    - uses: envoyproxy/toolshed/gh-actions/dispatch@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      with:
        ref: main
        repository: ${{ fromJSON(inputs.request).request.version.dev && 'envoyproxy/envoy-website' || 'envoyproxy/archive' }}
        token: ${{ steps.appauth.outputs.token }}
        workflow: envoy-sync.yaml
        inputs: |
          commit_sha: ${{ fromJSON(inputs.request).request.version.dev && github.sha || '' }}
# Envoy Github workflows

## Trusted workflows

Github workflows that are **not** triggered by a `pull_request` generally run with
the repository context/permissions.

In various ways, these workflows can be triggered as the result of a `pull_request`
and/or be made to run untrusted code (ie PR code).

This can be useful, but carries significant risks.

In particular this can effect:

- `pull_request_target`
- `workflow_run`
- `workflow_dispatch`

Do not use these trigger events unless they are required.

## Restrict global permissions and secrets in trusted workflows

If a job requires specific permissions, these should be added on per-job basis.

Global permissions should be set as follows:

```yaml
permissions:
  contents: read
```

Likewise, any secrets that a job requires should be set per-job.

## Restrict access to `workflow_dispatch`

It is important to restrict who can trigger these types of workflow.

Do not allow any bots or app users to do so, unless this is specifically required.

For example, you could add a `job` condition to prevent any bots from triggering the workflow:

```yaml
    if: >-
      ${{
          github.repository == 'envoyproxy/envoy'
          && (github.event.schedule
              || !contains(github.actor, '[bot]'))
      }}
```

## Trusted/untrusted CI jobs

If a trusted workflow is used to run untrusted code, then the entire job that runs this code
should be treated as untrusted.

In this case, it is **essential** to ensure:

- no write permissions in the untrusted job
- no secrets in the untrusted job
name: Workflow start
# This workflow is only required for externally triggered jobs that need to manually
# set the check status for a commit/PR

permissions:
  contents: read

on:
  workflow_call:
    secrets:
      app-id:
        required: true
      app-key:
        required: true
    inputs:
      details-url:
        type: string
        default: >-
          https://github.com/envoyproxy/envoy/tree/main/.github/workflows
      env:
        type: string
        required: true
      run-summary:
        type: string
        default: >-
          The check will start once any required jobs have completed and a VM becomes available
      run-title:
        type: string
        default: >-
          Waiting for check ...
      skipped-summary:
        type: string
        default: >-
          This check was not triggered in this CI run
      skipped-title:
        type: string
        default: >-
          Check was skipped
      template-run-text:
        type: string
        default: |
          ## \($icon) Check run pending

          ## Details of the check run will be provided here once it has started.

          ### Check started by


env:
  CI_DEBUG: ${{ (vars.CI_DEBUG || vars.RUNNER_DEBUG) && true || false }}


jobs:
  start:
    runs-on: ubuntu-22.04
    steps:
    - uses: envoyproxy/toolshed/gh-actions/jq@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      id: check-config
      name: Prepare check data
      with:
        print-result: ${{ fromJSON(env.CI_DEBUG || 'false') && true || false }}
        input: ${{ inputs.env }}
        filter: |
          . as $env
          | .config.envoy.icon as $icon
          | {}
          | .["head_sha"] = $env.request.sha
          | .details_url = "${{ inputs.details-url }}"
          | {run: ., skipped: ., request: $env.summary.summary}
          | .run.output.title = "${{ inputs.run-title }}"
          | .run.output.summary = "${{ inputs.run-summary }}"
          | .run.output.text = "${{ inputs.template-run-text }}"
          | .run.status = "queued"
          | .skipped.status = "completed"
          | .skipped.conclusion = "skipped"
          | .skipped.output.title = "${{ inputs.skipped-title }}"
          | .skipped.output.summary = "${{ inputs.skipped-summary }}"
          | .skipped.output.text = ""

    - uses: envoyproxy/toolshed/gh-actions/appauth@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      name: Appauth
      id: appauth
      with:
        app_id: ${{ secrets.app-id }}
        key: ${{ secrets.app-key }}
    - uses: envoyproxy/toolshed/gh-actions/github/checks@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      name: Start checks
      id: checks
      with:
        checks: ${{ toJSON(fromJSON(inputs.env).checks) }}
        config: ${{ steps.check-config.outputs.value }}
        text-extra: |
          ## ${{ fromJSON(inputs.env).summary.linked-title }}

          ${{ fromJSON(inputs.env).summary.summary }}
        token: ${{ steps.appauth.outputs.token }}
    - uses: envoyproxy/toolshed/gh-actions/json/table@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      name: Summary
      with:
        collapse-open: true
        json: |
          {"checks": ${{ steps.checks.outputs.checks }},
           "config": ${{ toJSON(fromJSON(inputs.env).checks) }}}
        filter: |
          .checks
        heading: >-
          ${{ fromJSON(inputs.env).config.envoy.icon }} Checks
        mutate-cells: |
          .cell as $cell
          | .row as $row
          | .table as $table
          | $cell
          | if ($row | index($cell) == 0) then
              $table.data.config[$cell].name
            elif ($table.data.config[$row[0]].action != "SKIP") then
              "[started](http://github.com/${{ github.repository }}/runs/\($cell))"
            else "skipped" end
        output-path: GITHUB_STEP_SUMMARY
        title: Checks started/skipped

    - uses: envoyproxy/toolshed/gh-actions/github/env/save@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      name: Save env
      id: data
      with:
        env: ${{ inputs.env }}
        env-filter: |
          ${{ steps.checks.outputs.checks }} as $checksStarted
          | .checks
          |= with_entries(
               if $checksStarted[.key] != "skipped" then
                 .value["check-id"] = $checksStarted[.key]
               else . end)
on:
  pull_request:
  workflow_dispatch:
  schedule:
  - cron: '0 5 * * 1,2,3,4,5'

permissions:
  contents: read  # to fetch code (actions/checkout)

jobs:
  pr_notifier:
    permissions:
      contents: read  # to fetch code (actions/checkout)
      statuses: read  # for pr_notifier.py
      pull-requests: read  # for pr_notifier.py
    name: PR Notifier
    runs-on: ubuntu-22.04
    if: >-
      ${{
          github.repository == 'envoyproxy/envoy'
          && (github.event.schedule
              || !contains(github.actor, '[bot]'))
      }}
    steps:
    - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11  # v4.1.1
    - name: Notify about PRs
      run: |
        ARGS=()
        if [[ "${{ github.event_name }}" == 'pull_request' ]]; then
            ARGS+=(--dry_run)
        fi
        bazel run //tools/repo:notify -- "${ARGS[@]}"
      env:
        SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
name: CodeQL/daily

permissions:
  contents: read

on:
  schedule:
  - cron: '0 12 * * 4'

concurrency:
  group: ${{ github.head_ref-github.workflow || github.run_id }}
  cancel-in-progress: true


jobs:
  CodeQL-Build:

    permissions:
      security-events: write  # for github/codeql-action/analyze to upload SARIF results
      pull-requests: read
    strategy:
      fail-fast: false

    # CodeQL runs on ubuntu-20.04
    runs-on: ubuntu-20.04
    if: github.repository == 'envoyproxy/envoy'

    steps:
    - name: Checkout repository
      uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11  # v4.1.1

    # Initializes the CodeQL tools for scanning.
    - name: Initialize CodeQL
      uses: github/codeql-action/init@cdcdbb579706841c47f7063dda365e292e5cad7a  # codeql-bundle-v2.13.4
      # Override language selection by uncommenting this and choosing your languages
      with:
        languages: cpp

    - name: Install deps
      shell: bash
      run: |
       sudo apt-get update --error-on=any
       sudo apt-get install --yes libtool cmake automake autoconf make ninja-build curl unzip virtualenv openjdk-11-jdk build-essential libc++1
       # Note: the llvm/clang version should match the version specifed in:
       #  - bazel/repository_locations.bzl
       #  - .github/workflows/codeql-push.yml
       #  - https://github.com/envoyproxy/envoy-build-tools/blob/main/build_container/build_container_ubuntu.sh#L84
       mkdir -p bin/clang14
       cd bin/clang14
       wget https://github.com/llvm/llvm-project/releases/download/llvmorg-14.0.0/clang+llvm-14.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz
       tar -xf clang+llvm-14.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz --strip-components 1
       export PATH=bin/clang14/bin:$PATH

    - name: Build
      run: |
       bazel/setup_clang.sh bin/clang14
       bazelisk shutdown
       bazelisk build -c fastbuild --spawn_strategy=local --discard_analysis_cache --nouse_action_cache --config clang --config libc++ //source/common/http/...

    - name: Clean Artifacts
      run: |
        git clean -xdf

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@cdcdbb579706841c47f7063dda365e292e5cad7a  # codeql-bundle-v2.13.4
name: Request/load

permissions:
  contents: read

on:
  workflow_call:
    secrets:
      lock-app-id:
        required: true
      lock-app-key:
        required: true

    inputs:
      branch-name:
        type: string
        default: main
      cache-docker:
        type: boolean
        default: true
      config-file:
        type: string
        default: ./.github/config.yml
      event-name:
        type: string
        default: ${{ github.workflow }}
      event-type:
        type: string
        default: ${{ github.event_name == 'workflow_dispatch' && 'dispatch' || 'scheduled' }}
      trusted:
        type: boolean
        default: true

    outputs:
      build-image:
        value: ${{ jobs.request.outputs.build-image }}
      build-image-mobile:
        value: ${{ jobs.request.outputs.build-image-mobile }}
      request:
        value: ${{ jobs.request.outputs.request }}
      trusted:
        value: ${{ jobs.request.outputs.trusted }}

concurrency:
  group: |
    ${{ github.actor != 'trigger-release-envoy[bot]'
        && github.head_ref
        || github.run_id
    }}-${{ github.workflow }}-env
  cancel-in-progress: true

env:
  CI_DEBUG: ${{ vars.CI_DEBUG && true || false }}


jobs:
  request:
    if: ${{ github.repository == 'envoyproxy/envoy' || vars.ENVOY_CI }}
    runs-on: ubuntu-22.04
    outputs:
      build-image: ${{ toJSON(fromJSON(steps.env.outputs.data).request.build-image) }}
      build-image-mobile: ${{ fromJSON(steps.env.outputs.data).request.build-image-mobile }}
      request: ${{ steps.env.outputs.data }}
      trusted: true
    steps:
    - uses: envoyproxy/toolshed/gh-actions/jq@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      id: started
      name: Create timestamp
      with:
        options: -r
        filter: |
          now
    - uses: envoyproxy/toolshed/gh-actions/github/checkout@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      id: checkout
      name: Checkout Envoy repository
    - name: Generate environment variables
      uses: envoyproxy/toolshed/gh-actions/envoy/ci/env@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      id: env
      with:
        branch-name: ${{ inputs.branch-name }}
        config-file: ${{ inputs.config-file }}
        started: ${{ steps.started.outputs.value }}
        token: ${{ secrets.GITHUB_TOKEN }}
        vars: ${{ toJSON(vars) }}
        trusted: ${{ inputs.trusted }}

    - name: Request summary
      id: summary
      uses: envoyproxy/toolshed/gh-actions/github/env/summary@2b4b266dbf6e410f2e8a05abf0dcd8ad13e6ecac  # actions-v0.2.23
      with:
        actor: ${{ toJSON(fromJSON(steps.env.outputs.data).request.actor) }}
        base-sha: ${{ fromJSON(steps.env.outputs.data).request.base-sha }}
        event-name: ${{ inputs.event-name }}
        event-type: ${{ inputs.event-type }}
        link: ${{ format('https://github.com/{0}/actions/runs/{1}', github.repository, github.run_id) }}
        output-path: GITHUB_STEP_SUMMARY
        data: ${{ steps.env.outputs.data }}
        tables: ${{ toJSON(fromJSON(steps.env.outputs.data).config.tables) }}
        icon: ${{ fromJSON(steps.env.outputs.data).config.envoy.icon }}
        message: ${{ fromJSON(steps.env.outputs.data).request.message }}
        ref: ${{ fromJSON(steps.env.outputs.data).request.ref }}
        sha: ${{ fromJSON(steps.env.outputs.data).request.sha }}
        target-branch: ${{ fromJSON(steps.env.outputs.data).request.target-branch }}

  cache:
    secrets:
      app-id: ${{ secrets.lock-app-id }}
      app-key: ${{ secrets.lock-app-key }}
    uses: ./.github/workflows/_cache.yml
    needs: request
    if: ${{ inputs.cache-docker }}
    with:
      request: ${{ toJSON(needs.request.outputs) }}
      image-tag: ${{ fromJSON(needs.request.outputs.build-image).default }}
name: Mobile/Compile time options

permissions:
  contents: read

on:
  workflow_run:
    workflows:
    - Request
    types:
    - completed

concurrency:
  group: ${{ github.head_ref || github.run_id }}-${{ github.workflow }}
  cancel-in-progress: true


jobs:
  load:
    secrets:
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      lock-app-key: ${{ secrets.ENVOY_CI_MUTEX_APP_KEY }}
      lock-app-id: ${{ secrets.ENVOY_CI_MUTEX_APP_ID }}
    permissions:
      actions: read
      contents: read
      packages: read
      pull-requests: read
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    uses: ./.github/workflows/_load.yml
    with:
      check-name: mobile-compile-time-options

  cc:
    permissions:
      contents: read
      packages: read
    uses: ./.github/workflows/_mobile_container_ci.yml
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-compile-time-cc }}
    needs: load
    with:
      args: ${{ matrix.args }}
      command: ./bazelw
      entrypoint: ${{ matrix.entrypoint }}
      request: ${{ needs.load.outputs.request }}
      target: ${{ matrix.target }}
      timeout-minutes: 120
    strategy:
      fail-fast: false
      matrix:
        include:
        - name: Running C++ test with YAML disabled
          target: cc-test-no-yaml
          args: >-
            build
            --config=mobile-remote-ci-cc-no-yaml
            //test/common/integration:client_integration_test
        - name: Running C++ build with exceptions disabled
          target: cc-no-build-exceptions
          args: >-
            build
            --config=mobile-remote-ci-cc-no-exceptions
            //test/performance:test_binary_size //library/cc/...
        - name: Running C++ test
          target: cc-test
          args: >-
            test
            --config=mobile-remote-ci-cc-test
          entrypoint: |
            #!/bin/bash -e
            export PATH=/opt/llvm/bin:$PATH
            cd /source/mobile
            EXTRA_ARGS=$(bazel query //test/cc/... + //test/common/... except //test/common/integration:client_integration_test)
            exec "$@" $EXTRA_ARGS

  build:
    permissions:
      contents: read
      packages: read
    uses: ./.github/workflows/_run.yml
    if: ${{ fromJSON(needs.load.outputs.request).run.mobile-compile-time-options }}
    needs: load
    with:
      args: ${{ matrix.args }}
      command: ./bazelw
      container-command:
      request: ${{ needs.load.outputs.request }}
      runs-on: macos-12
      source: ${{ matrix.source }}
      steps-pre: ${{ matrix.steps-pre }}
      target: ${{ matrix.target || matrix.name }}
      trusted: ${{ fromJSON(needs.load.outputs.trusted) }}
      timeout-minutes: 120
      working-directory: mobile
    strategy:
      fail-fast: false
      matrix:
        include:
        - name: swift-build
          args: >-
            build
            --config=mobile-remote-ci-macos-swift
            //library/swift:ios_framework
          source: |
            # TODO(fredyw): A workaround since mobile/WORKSPACE requires Android SDK to be available
            # and the GitHub Action runner image no longer includes Android SDK 30:
            # https://github.com/actions/runner-images/issues/8952
            ./ci/mac_ci_setup.sh --android
            ./bazelw shutdown

  request:
    secrets:
      app-id: ${{ secrets.ENVOY_CI_APP_ID }}
      app-key: ${{ secrets.ENVOY_CI_APP_KEY }}
    permissions:
      actions: read
      contents: read
      pull-requests: read
    if: >-
      ${{ always()
          && github.event.workflow_run.conclusion == 'success'
          && (fromJSON(needs.load.outputs.request).run.mobile-compile-time-options
              || fromJSON(needs.load.outputs.request).run.mobile-compile-time-cc) }}
    needs:
    - load
    - cc
    - build
    uses: ./.github/workflows/_finish.yml
    with:
      needs: ${{ toJSON(needs) }}
name: Scorecard supply-chain security
on:
  branch_protection_rule:
  schedule:
  - cron: '33 13 * * 5'
  push:
    branches:
    - "main"

permissions:
  contents: read


jobs:
  analysis:
    name: Scorecard analysis
    runs-on: ubuntu-22.04
    permissions:
      security-events: write
      id-token: write

    steps:
    - name: "Checkout code"
      uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11  # v4.1.1
      with:
        persist-credentials: false

    - name: "Run analysis"
      uses: ossf/scorecard-action@0864cf19026789058feabb7e87baa5f140aac736  # v2.3.1
      with:
        results_file: results.sarif
        results_format: sarif
        publish_results: true

    - name: "Upload artifact"
      uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8  # v3.1.0
      with:
        name: SARIF file
        path: results.sarif
        retention-days: 5

    - name: "Upload to code-scanning"
      uses: github/codeql-action/upload-sarif@012739e5082ff0c22ca6d6ab32e07c36df03c4a4  # v3.22.12
      with:
        sarif_file: results.sarif
agent-ubuntu: ubuntu-22.04
build-image:
  # Authoritative configuration for build image/s
  repo: envoyproxy/envoy-build-ubuntu
  sha: d736c58f06f36848e7966752cc7e01519cc1b5101a178d5c6634807e8ac3deab
  mobile-sha: 13674edd989ada8b94257f410e38e5e8e4c6a0a9c2fdf8bda9261047a7f843e4
  # this is authoritative, but is not currently used in github ci
  gcr-sha: 0434d2f6a65895a00f8936fba83b7ff14d21e149dc15c9ac25a31a6fa018234f
  tag: 0ca52447572ee105a4730da5e76fe47c9c5a7c64

config:
  envoy:
    icon: >-
      [![](https://avatars.githubusercontent.com/u/30125649?s=24&v=4)](#)

checks:
  # Checks: this configures which _checks_ will be activated or skipped
  #
  # The configured _names_ need to match the checks configured for the repo
  #
  # Any check that is marked as `required` but is not triggered by the run
  # config above in a given CI run is marked as `skipped`
  #
  # For example if macos is marked as `required: true` but then has a path
  # selection that means its doesnt run the check will be `skipped` and pass
  macos:
    name: Envoy/macOS
    required: true
    on-run:
    - build-macos
  mobile-android:
    name: Mobile/Android
    required: true
    on-run:
    - mobile-android
  mobile-android-tests:
    name: Mobile/Android tests
    required: true
    on-run:
    - mobile-android-tests
  mobile-asan:
    name: Mobile/ASAN
    required: true
    on-run:
    - mobile-asan
  mobile-cc:
    name: Mobile/CC
    required: true
    on-run:
    - mobile-cc
  mobile-compile-time-options:
    name: Mobile/Compile time options
    on-run:
    - mobile-compile-time-cc
    - mobile-compile-time-options
  mobile-core:
    name: Mobile/Core
    required: true
    on-run:
    - mobile-core
  mobile-coverage:
    name: Mobile/Coverage
    required: true
    on-run:
    - mobile-coverage
  mobile-docs:
    name: Mobile/Docs
    on-run:
    - mobile-docs
  mobile-format:
    name: Mobile/Format
    required: true
    on-run:
    - mobile-format
  mobile-ios:
    name: Mobile/iOS
    required: true
    cache:
    on-run:
    - mobile-ios
  mobile-ios-tests:
    name: Mobile/iOS tests
    required: true
    on-run:
    - mobile-ios-tests
  mobile-perf:
    name: Mobile/Perf
    required: true
    on-run:
    - mobile-perf
  mobile-release-validation:
    name: Mobile/Release validation
    required: true
    on-run:
    - mobile-release-validation
  mobile-tsan:
    name: Mobile/TSAN
    required: true
    on-run:
    - mobile-tsan
  prechecks:
    name: Envoy/Prechecks
    on-run:
    - precheck-deps
    required: true
    # yamllint disable rule:line-length
    advice:
      general: |
        ### Ensuring your commits are signed off

        You can set up DCO using Envoy's git hooks.

        ### Git hooks

        To set this up, do the following:

          ```console
          $ ./support/bootstrap
          ```

          If you only want the DCO check you can do the following to disable the
          other hooks

          ```console
          $ echo NO_VERIFY=1 > .env
          ```
      deps: |
        ### Advice on updating dependencies

        General information about Envoy's depdendencies [can be found here](https://github.com/envoyproxy/envoy/blob/main/DEPENDENCY_POLICY.md)
      format: |
        ### Advice on correct formatting

        Envoy ensures a minimum standard for all files in the repository.

        You are strongly advised to heed the following CI notice:

          ```console
            Please fix your editor to ensure:

              - no trailing whitespace
              - no preceding mixed tabs/spaces
              - all files end with a newline
          ```
    # yamllint enable rule:line-length
  publish:
    name: >-
      Envoy/Publish and verify
    on-run:
    - publish
    - verify
    required: true
  windows:
    name: Envoy/Windows
    required: true
    on-run:
    - build-windows

run:
  build-windows:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - api/**/*
    - bazel/**/*
    - ci/**/*
    - configs/**/*
    - contrib/**/*
    - envoy/**/*
    - source/**/*
    - test/**/*
  build-macos:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - api/**/*
    - bazel/**/*
    - ci/**/*
    - configs/**/*
    - contrib/**/*
    - envoy/**/*
    - source/**/*
    - test/**/*
  mobile-android:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
  mobile-android-all:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
    push: never
  mobile-android-tests:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
  mobile-asan:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
  mobile-cc:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
  mobile-compile-time-cc:
    paths:
    - "**/*"
  mobile-compile-time-options:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
  mobile-coverage:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
  mobile-core:
    paths:
    - "**/*"
  mobile-format:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
  mobile-ios:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
  mobile-ios-all:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
    push: never
  mobile-ios-tests:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
  mobile-perf:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
  mobile-release-validation:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
  mobile-tsan:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - bazel/external/quiche.BUILD
    - bazel/repository_locations.bzl
    - mobile/**/*
    - tools/code_format/check_format.py
  precheck-deps:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - .github/dependabot.yml
    - bazel/BUILD
    - tools/dependency/*
    - "**/*.bzl"
    - "**/requirements.txt"
    - "**/go.mod"
    - "**/Dockerfile*"
  publish:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - api/**/*
    - bazel/**/*
    - ci/**/*
    - contrib/**/*
    - envoy/**/*
    - examples/**/*
    - source/**/*
    - tools/**/*
    - VERSION.txt
  verify:
    paths:
    - .bazelrc
    - .bazelversion
    - .github/config.yml
    - api/**/*
    - bazel/**/*
    - ci/**/*
    - contrib/**/*
    - envoy/**/*
    - examples/**/*
    - source/**/*
    - tools/**/*
    - VERSION.txt
    push: paths

tables:
  env:
    collapse: true
    title: Environment
    table-title: Request variables
    filter: |
      .request
      | del(.["build-image" as $prefix | keys[] | select(startswith($prefix))])
      | del(.["version" as $prefix | keys[] | select(startswith($prefix))])
      | .actor  = "<img src=\"\(.actor.icon)\" alt=\"\(.actor.name)\" width=\"18\" height=\"18\">  @\(.actor.name)"
  build-image:
    collapse: true
    title: Build image
    table-title: Container image/s (as used in this CI run)
    filter: |
      "https://hub.docker.com/r/envoyproxy/envoy-build-ubuntu/tags?page=1&name=" as $dockerLink
      | .request["build-image"]
      | del(.changed)
      | with_entries(
          .value as $v
          | ($v | split(":") | .[1] | split("@") | .[0]) as $tag
          | .value = "[\($v | split("@") | .[0])](\($dockerLink)\($tag))")
  build-image-current:
    collapse: true
    title: Build image (current)
    table-title: Current or previous container image
    filter: |
      "https://hub.docker.com/r/envoyproxy/envoy-build-ubuntu/tags?page=1&name=" as $dockerLink
      | if .request["build-image"].changed then
          .request["build-image-current"]
          | with_entries(
              .value as $v
              | ($v | split(":") | .[1] | split("@") | .[0]) as $tag
              | .value = "[\($v | split("@") | .[0])](\($dockerLink)\($tag))")
        else {} end
  version:
    collapse: true
    title: Version
    table-title: Envoy version (as used in this CI run)
    filter: |
      .request.version
      | del(.changed)
  version-current:
    collapse: true
    title: Version (current)
    table-title: Current or previous version
    filter: |
      if .request.version.changed then
        .request["version-current"]
      else
        {}
      end
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: enhancement,triage
assignees: ''

---

*Title*: *One line description*

*Description*:
>Describe the desired behavior, what scenario it enables and how it
would be used.

[optional *Relevant Links*:]
>Any extra documentation required to understand the issue.
blank_issues_enabled: false
contact_links:
- name: "Crash bug"
  url: https://github.com/envoyproxy/envoy/security/policy
  about: "Please file any crash bug (including asserts in debug builds) with envoy-security@googlegroups.com."
---
name: Test flake
about: Track a flaky test or other CI failure
title: ''
labels: 'area/test flakes'
assignees: ''

---
---
name: Other
about: Questions, design proposals, tech debt, etc.
title: ''
labels: triage
assignees: ''

---

**If you are reporting *any* crash or *any* potential security issue, *do not*
open an issue in this repo. Please report the issue via emailing
envoy-security@googlegroups.com where the issue will be triaged appropriately.**

*Title*: *One line description*

*Description*:
>Describe the issue.

[optional *Relevant Links*:]
>Any extra documentation required to understand the issue.
---
name: Non-{crash,security} bug
about: Bugs which are not crashes (including asserts in debug builds), DoS or other security issue
title: ''
labels: bug,triage
assignees: ''

---

**If you are reporting *any* crash or *any* potential security issue, *do not*
open an issue in this repo. Please report the issue via emailing
envoy-security@googlegroups.com where the issue will be triaged appropriately.**

*Title*: *One line description*

*Description*:
>What issue is being seen? Describe what should be happening instead of
the bug, for example: Envoy should not crash, the expected value isn't
returned, etc.

*Repro steps*:
> Include sample requests, environment, etc. All data and inputs
required to reproduce the bug.

>**Note**: The [Envoy_collect tool](https://github.com/envoyproxy/envoy/blob/main/tools/envoy_collect/README.md)
gathers a tarball with debug logs, config and the following admin
endpoints: /stats, /clusters and /server_info. Please note if there are
privacy concerns, sanitize the data prior to sharing the tarball/pasting.

*Admin and Stats Output*:
>Include the admin output for the following endpoints: /stats,
/clusters, /routes, /server_info. For more information, refer to the
[admin endpoint documentation.](https://www.envoyproxy.io/docs/envoy/latest/operations/admin)

>**Note**: If there are privacy concerns, sanitize the data prior to
sharing.

*Config*:
>Include the config used to configure Envoy.

*Logs*:
>Include the access logs and the Envoy logs.

>**Note**: If there are privacy concerns, sanitize the data prior to
sharing.

*Call Stack*:
> If the Envoy binary is crashing, a call stack is **required**.
Please refer to the [Bazel Stack trace documentation](https://github.com/envoyproxy/envoy/tree/main/bazel#stack-trace-symbol-resolution).
version: 2
updates:

# We currently have CI to make sure that all python `requirements.txt` files
# are listed here, and only existing `requirements.txt` files are listed here.
#
# Until https://github.com/envoyproxy/envoy/issues/26163 is resolved `Dockerfiles`,
# and `go.mod` files need to be kept in sync manually.
#
# Please ensure any new ones are added here, and any that are removed are removed here also.

- package-ecosystem: "pip"
  directory: "/examples/grpc-bridge/client"
  groups:
    examples-grpc-bridge:
      patterns:
      - "*"
  schedule:
    interval: "daily"
    time: "06:00"

- package-ecosystem: "pip"
  directory: "/examples/cache"
  groups:
    examples-cache:
      patterns:
      - "*"
  schedule:
    interval: "daily"
    time: "06:00"

- package-ecosystem: "pip"
  directory: "/examples/shared/python/aiohttp"
  groups:
    examples-shared-python:
      patterns:
      - "*"
  schedule:
    interval: "daily"
    time: "06:00"

- package-ecosystem: "pip"
  directory: "/examples/shared/python/postgres"
  groups:
    examples-postgres:
      patterns:
      - "*"
  schedule:
    interval: "daily"
    time: "06:00"

- package-ecosystem: "pip"
  directory: "/tools/base"
  open-pull-requests-limit: 20
  schedule:
    interval: "daily"
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/.devcontainer"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/ci"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/ext_authz"
  groups:
    examples-ext-authz:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/fault-injection"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/golang-network"
  groups:
    examples-golang-network:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/grpc-bridge"
  groups:
    examples-grpc-bridge:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/kafka"
  groups:
    examples-kafka:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/local_ratelimit"
  groups:
    examples-local-ratelimit:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/mysql"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/opentelemetry"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/redis"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/shared/build"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/shared/echo"
  schedule:
    interval: daily
    time: "06:00"

# TODO(phlax): just use above
- package-ecosystem: "docker"
  directory: "/examples/shared/echo2"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/shared/golang"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/shared/jaeger"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/shared/node"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/shared/postgres"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/shared/python"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/shared/websocket"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/skywalking"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/udp"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "docker"
  directory: "/examples/zipkin"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "github-actions"
  directory: "/"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/contrib/golang/filters/http/test/test_data/basic"
  groups:
    contrib-golang:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/contrib/golang/filters/http/test/test_data/dummy"
  groups:
    contrib-golang:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/contrib/golang/filters/http/test/test_data/echo"
  groups:
    contrib-golang:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/contrib/golang/filters/http/test/test_data/metric"
  groups:
    contrib-golang:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/contrib/golang/filters/http/test/test_data/passthrough"
  groups:
    contrib-golang:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/contrib/golang/filters/http/test/test_data/access_log"
  groups:
    contrib-golang:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/contrib/golang/filters/http/test/test_data/action"
  groups:
    contrib-golang:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/contrib/golang/filters/http/test/test_data/buffer"
  groups:
    contrib-golang:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/contrib/golang/filters/http/test/test_data/routeconfig"
  groups:
    contrib-golang:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/contrib/golang/filters/http/test/test_data/property"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/contrib/golang/filters/network/test/test_data"
  groups:
    contrib-golang:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/contrib/golang/router/cluster_specifier/test/test_data/simple"
  groups:
    contrib-golang:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/examples/ext_authz/auth/grpc-service"
  groups:
    examples-ext-authz:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/examples/load-reporting-service"
  groups:
    examples-load-reporting:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/examples/grpc-bridge/server"
  groups:
    examples-grpc-bridge:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/examples/golang-http/simple"
  groups:
    examples-golang-http:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "gomod"
  directory: "/examples/golang-network/simple"
  groups:
    examples-golang-network:
      patterns:
      - "*"
  schedule:
    interval: daily
    time: "06:00"

- package-ecosystem: "npm"
  directory: "/examples/single-page-app/ui"
  schedule:
    interval: daily
    time: "06:00"
/generated_api_shadow/envoy/** linguist-generated=true
/generated_api_shadow/bazel/** linguist-generated=true
*.svg binary
/test/extensions/transport_sockets/tls/test_data/aes_128_key binary
/test/extensions/transport_sockets/tls/test_data/ticket_key_* binary
/test/**/*_corpus/* linguist-generated=true
requirements.txt binary
package.lock binary
yarn.lock binary
- hosts: all
  become: yes
  roles:
  - role: config-gcc
    gcc_version: 7
  - role: config-bazel
    bazel_version: 0.28.1
  tasks:
  - name: Build envoy
    shell:
      cmd: |
        apt update
        apt-get update
        apt-get install -y \
             libtool \
             cmake \
             automake \
             autoconf \
             make \
             ninja-build \
             curl \
             unzip \
             virtualenv

        bazel build //source/exe:envoy-static | tee $LOGS_PATH//bazel.txt

        cp -r ./bazel-bin $RESULTS_PATH
      chdir: '{{ zuul.project.src_dir }}'
      executable: /bin/bash
    environment: '{{ global_env }}'
"""Tool to convert Envoy tap trace format to PCAP.

Uses od and text2pcap (part of Wireshark) utilities to translate the Envoy
tap trace proto format to a PCAP file suitable for consuming in Wireshark
and other tools in the PCAP ecosystem. The TCP stream in the output PCAP is
synthesized based on the known IP/port/timestamps that Envoy produces in its
tap files; it is not a literal wire tap.

Usage:

bazel run @envoy_api//tools:tap2pcap <tap .pb/.pb_text> <pcap path>

Known issues:
- IPv6 PCAP generation has malformed TCP packets. This appears to be a text2pcap
issue.

TODO(htuch):
- Figure out IPv6 PCAP issue above, or file a bug once the root cause is clear.
"""
from __future__ import print_function

import datetime
import io
import socket
import subprocess as sp
import sys
import time

from google.protobuf import text_format

from envoy.data.tap.v2alpha import wrapper_pb2


def dump_event(direction, timestamp, data):
    dump = io.StringIO()
    dump.write('%s\n' % direction)
    # Adjust to local timezone
    adjusted_dt = timestamp.ToDatetime() - datetime.timedelta(seconds=time.altzone)
    dump.write('%s\n' % adjusted_dt)
    od = sp.Popen(['od', '-Ax', '-tx1', '-v'], stdout=sp.PIPE, stdin=sp.PIPE, stderr=sp.PIPE)
    packet_dump = od.communicate(data)[0]
    dump.write(packet_dump.decode())
    return dump.getvalue()


def tap2pcap(tap_path, pcap_path):
    wrapper = wrapper_pb2.TraceWrapper()
    if tap_path.endswith('.pb_text'):
        with open(tap_path, 'r') as f:
            text_format.Merge(f.read(), wrapper)
    else:
        with open(tap_path, 'rb') as f:
            wrapper.ParseFromString(f.read())

    trace = wrapper.socket_buffered_trace
    local_address = trace.connection.local_address.socket_address.address
    local_port = trace.connection.local_address.socket_address.port_value
    remote_address = trace.connection.remote_address.socket_address.address
    remote_port = trace.connection.remote_address.socket_address.port_value

    dumps = []
    for event in trace.events:
        if event.HasField('read'):
            dumps.append(dump_event('I', event.timestamp, event.read.data.as_bytes))
        elif event.HasField('write'):
            dumps.append(dump_event('O', event.timestamp, event.write.data.as_bytes))

    ipv6 = False
    try:
        socket.inet_pton(socket.AF_INET6, local_address)
        ipv6 = True
    except socket.error:
        pass

    text2pcap_args = [
        'text2pcap', '-D', '-t', '%Y-%m-%d %H:%M:%S.', '-6' if ipv6 else '-4',
        '%s,%s' % (remote_address, local_address), '-T',
        '%d,%d' % (remote_port, local_port), '-', pcap_path
    ]
    text2pcap = sp.Popen(text2pcap_args, stdout=sp.PIPE, stdin=sp.PIPE)
    text2pcap.communicate('\n'.join(dumps).encode())


if __name__ == '__main__':
    if len(sys.argv) != 3:
        print('Usage: %s <tap .pb/.pb_text> <pcap path>' % sys.argv[0])
        sys.exit(1)
    tap2pcap(sys.argv[1], sys.argv[2])
"""Tests for tap2pcap."""
from __future__ import print_function

import os
import subprocess as sp
import sys

# Workaround for https://github.com/bazelbuild/rules_python/issues/1221
sys.path += [os.path.dirname(__file__)]

import tap2pcap

# Validate that the tapped trace when run through tap2cap | tshark matches
# a golden output file for the tshark dump. Since we run tap2pcap in a
# subshell with a limited environment, the inferred time zone should be UTC.
if __name__ == '__main__':
    srcdir = os.path.join(os.getenv('TEST_SRCDIR'), 'envoy_api')
    tap_path = os.path.join(srcdir, 'tools/data/tap2pcap_h2_ipv4.pb_text')
    expected_path = os.path.join(srcdir, 'tools/data/tap2pcap_h2_ipv4.txt')
    pcap_path = os.path.join(os.getenv('TEST_TMPDIR'), 'generated.pcap')

    tap2pcap.tap2pcap(tap_path, pcap_path)
    actual_output = sp.check_output(
        ['tshark', '-r', pcap_path, '-d', 'tcp.port==10000,http2', '-P'])
    with open(expected_path, 'rb') as f:
        expected_output = f.read()
    if actual_output != expected_output:
        print('Mismatch')
        print('Expected: %s' % expected_output)
        print('Actual: %s' % actual_output)
        sys.exit(1)
load("@rules_python//python:defs.bzl", "py_binary", "py_test")

licenses(["notice"])  # Apache 2

py_binary(
    name = "tap2pcap",
    srcs = ["tap2pcap.py"],
    licenses = ["notice"],  # Apache 2
    visibility = ["//visibility:public"],
    deps = ["//envoy/data/tap/v2alpha:pkg_py_proto"],
)

py_test(
    name = "tap2pcap_test",
    srcs = ["tap2pcap_test.py"],
    data = [
        "data/tap2pcap_h2_ipv4.pb_text",
        "data/tap2pcap_h2_ipv4.txt",
    ],
    # Don't run this by default, since we don't want to force local dependency on Wireshark/tshark,
    # will explicitly invoke in CI.
    tags = ["manual"],
    visibility = ["//visibility:public"],
    deps = [":tap2pcap"],
)

py_binary(
    name = "generate_listeners",
    srcs = ["generate_listeners.py"],
    licenses = ["notice"],  # Apache 2
    visibility = ["//visibility:public"],
    deps = [
        "//envoy/api/v2:pkg_py_proto",
        "//envoy/config/filter/network/http_connection_manager/v2:pkg_py_proto",
    ],
)

py_test(
    name = "generate_listeners_test",
    srcs = ["generate_listeners_test.py"],
    data = [
        "//examples/service_envoy:http_connection_manager.pb",
        "//examples/service_envoy:listeners.pb",
    ],
    visibility = ["//visibility:public"],
    deps = [":generate_listeners"],
)
"""Tests for generate_listeners."""

import os
import sys

# Workaround for https://github.com/bazelbuild/rules_python/issues/1221
sys.path += [os.path.dirname(__file__)]

import generate_listeners

if __name__ == "__main__":
    srcdir = os.path.join(os.getenv("TEST_SRCDIR"), 'envoy_api')
    generate_listeners.generate_listeners(
        os.path.join(srcdir, "examples/service_envoy/listeners.pb"), "/dev/stdout", "/dev/stdout",
        iter([os.path.join(srcdir, "examples/service_envoy/http_connection_manager.pb")]))
socket_buffered_trace {
  connection {
    local_address {
      socket_address {
        address: "127.0.0.1"
        port_value: 10000
      }
    }
    remote_address {
      socket_address {
        address: "127.0.0.1"
        port_value: 53288
      }
    }
  }
  events {
    timestamp {
      seconds: 1525207293
      nanos: 216737962
    }
    read {
      data: {
        as_bytes: "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n\000\000\022\004\000\000\000\000\000\000\003\000\000\000d\000\004@\000\000\000\000\002\000\000\000\000\000\000\004\010\000\000\000\000\000?\377\000\001\000\000\036\001\005\000\000\000\001\202\204\206A\212\240\344\035\023\235\t\270\020\000\000z\210%\266P\303\253\266\362\340S\003*/*"
      }
    }
  }
  events {
    timestamp {
      seconds: 1525207293
      nanos: 230450657
    }
    write {
      data: {
        as_bytes: "\000\000\006\004\000\000\000\000\000\000\004\020\000\000\000\000\000\000\004\001\000\000\000\000\000\000\004\010\000\000\000\000\000\017\377\000\001"
      }
    }
  }
  events {
    timestamp {
      seconds: 1525207293
      nanos: 230558250
    }
    read {
      data: {
        as_bytes: "\000\000\000\004\001\000\000\000\000"
      }
    }
  }
  events {
    timestamp {
      seconds: 1525207293
      nanos: 345386933
    }
    write {
      data: {
        as_bytes: "\000\025\223\001\004\000\000\000\001\210@\217\362\264\307<\324\025d\025\0101\352X\325J\177\211\3056\316p\232l\371!\301\000\216\362\264\307<\324\025b\371\254\266\032\222\324\237\377\277 \023n6\357\320\200\027]o\350@\013\300s\350@\013\302\177\351\326\302\333\241\372u\2612\363\237Ae\260\205\327>\202\313b\003\301\372\013-\211\226\333\372\013-\211\226\335\372\013-\211\267\033\372\013-\211\366[\372\013-\211\367\001\364\026[d\017\271\364\026[d/=\364\026[dL\271\364\026[e\221;\364\026[e\267\031\372\013-\262\353N\375\005\226\331x\014\375\005\226\331x\r}\005\226\331x \372\013-\262\360^\372\013-\262\373\200\372\013-\262\373\354\375\005\226\332\003\356}\005\226\332\013\216\375\005\226\332\013\316\375\005\226\332\020\232\372\013-\264&\203\364\026[hN\273\364\026[i\220;\364\026[i\226\231\372\013-\264\350\003\364\026[i\326\335\372\013-\264\360[\372\013-\264\363m}\005\226\332|-\375\005\226\332}\347~\202\313m\201\227~\202\313m\210\"\372\013-\266\'\032\372\013-\266\'\303\364\026[m\246\335\372\013-\266\330]\372\013-\266\333\356\375\005\226\333m\367\376\202\313m\270\340\276\202\313m\272\340~\202\313m\272\350~\202\313m\272\363?Ae\266\335y\377\240\262\333o8\017\240\262\333o\211\237\240\262\333\200\020>\202\313n\000L\375\005\226\334\003N}\005\226\334\003\257\375\005\226\334\010^\372\013-\270\027\201\364\026[p/\013\350,\266\340\234o\350,\266\343 o\350,\266\343L\271\364\026[q\246\201\364\026[q\300\207\350,\266\343\201o\350,\266\343\201w\350,\266\343\201\177\350,\266\343\216\003\350,\266\343\217\273\364\026[q\3215\364\026[q\326\235\372\013-\270\353\257\375\005\226\334u\367>\202\313n<\333?Ae\267\036u\377\240\262\333\217\200?Ae\267\037i\377\240\262\333\240e\317\240\262\333\240x_Ae\267B\313\337Ae\267B\320\276\202\313n\205\307\276\202\313n\205\347>\202\313n\210\017\375\005\226\335\020_\372\013-\272\313m\375\005\226\335h\017\375\005\226\335h!\372\013-\272\320\203\364\026[u\247\237\372\013-\272\343\301\372\013-\272\363-}\005\226\335|.\375\005\226\335}\227~\202\313n\276\343?Ae\267_}\237\240\262\333\300q\257\240\262\333\300t?Ae\267\200\353?Ae\267\200\370~\202\313o\004\017}\005\226\336\010C\364\026[x!s\350,\266\360\204\357\320Ym\3416\037\240\262\333\302}\237\240\262\333\314\205\377\240\262\333\314\272\377\320Ym\346\200\017\240\262\333\315\005\257\240\262\333\315\010?Ae\267\232\023\177Ae\267\234\020~\202\313o8\313\337Ae\267\234h_Ae\267\234}\377\240\262\333\317>\017\240\262\333\317\205\377\240\262\333\340\013\377Ae\267\300\313\337Ae\267\304\360\276\204\330\002&\335\372h\002e\240\277\364\320\004\373\301o\351\2402\020\201\377\246\200\310B\343_M\001\226\231d?M\001\226\236h\037M\001\227\237}\237\246\200\320\002\313\177M\001\246B\370>\232\003L\264\370\276\232\003M\274\320~\232\003N\270\360\276\232\003O2\323\277M\001\261:\340~\232\003m\262\343\177M\001\267\032p\037M\001\267\202\323\337M\001\267\336u\317\246\200\340\237y\277\246\200\343\254\270\327\323@q\346\337\027\323@q\360>\317\323@q\360>\337\323@q\367\031k\351\2408\373\214\271\364\320\034}\347\034\372h\016\204\016\203\351\240:\026\\\007\323@t.\274/\246\200\353o\005\317\246\200\353\217\274\347\323@u\360\t\357\246\200\353\342\003\237M\001\327\334m\317\246\200\353\3568\037\246\200\353\3568\377\323@x\014\211\257\246\200\360\033\013\337M\001\3406&\276\232\003\301\003/}4\007\204 \277\364\320\036d-;\364\320\036e\366\301\364\320\036i\240\263\364\320\036i\2417\364\320\036i\320\273\364\320\036m\327\201\364\320\036q\367]\372h\017>\026\305\364\320\037\000\202/\246\200\370\031\010>\232\003\355\276\020}4\007\334\023\315\3754\007\334\023\316}4\007\334y\306~\232\003\356>\323\337M\001\367B\333?M\001\367Zq\377\246\200\373\257\210_M\001\367_\023\377M\001\367\202\320>\232\003\3574\340>\232\003\3578\373\377M\001\367\235\020~\232\003\357:\'\276\232\010\000!9\364\320@\021\004?M\004\014\205\366~\232\010\031i\340\3754\0204\363b\372h m\226\\\372h m\247\303\364\320@\343-;\364\320@\343\2179\364\320@\343\317\203\351\240\201\326\302\337\323A\003\255\262\017\246\202\007_\013_M\004\017<\006\376\232\010\036y\227~\232\010\037d.}4\020>\323\340\372h!\013\340k\351\240\204/\266\337\323A\010_p?M\004-4\343\277M\004-6\353_M\004-6\373\277M\004-\211\340\3754\020\266\320A\364\320B\333\217\273\364\320B\343 o\351\240\205\306@\357\323A\013\241p?M\004.\205\320\3754\020\272\330Y\372h!u\360\265\364\320B\360\037\027\323A\013\315\264\367\323A\013\340d_M\004/\201\226\276\232\010_\003.}4\020\276\006\201\364\320B\370\035k\351\240\205\366\331g\351\240\205\366\336k\351\240\210\014\262/\246\202 6\373?M\004@q\300}4\021\004.\263\364\320D\020\272\337\323A\020Zi\277\246\202 \264\373?M\004Al/}4\021\005\307\334\372h\"\020\236\027\323A\023.4\037\246\202&\204\323\177M\004M2\370~\232\010\232}\340\3754\0216\323\257}4\0216\363.\3754\0216\373\242\372h\"p@\007\323A\023\202\023\337M\004N:\333_M\004N\201\347>\232\010\235\023L\3754\021:\310\032\372h\"u\2207\364\320D\353A{\351\240\211\326\302\337\323A\023\301\013\277M\004O\010-}4\021< \271\364\320D\363-\265\364\320D\363@\027\323A\023\315\272\017\246\202\'\233y\317\246\202\'\333\020>\232\010\237q\226~\232\010\237u\367>\232\013 \020\232\372h,\201\227\234\372h,\201\267\001\364\320Y\003n?\364\320Y\010B\327\323Ad.2/\246\202\310]e\337\246\202\310^e\257\246\202\310\200\320~\232\013\"\013\355\3754\026D\320^\372h,\211\246\205\364\320Y\023o9\364\320Y\023\217\275\364\320Y\023\317\275\364\320Yd.\013\351\240\262\313-\277\364\320Ye\240\275\364\320Ye\247\003\364\320Ye\260?\364\320Ye\306\\\372h,\262\343/}4\026Yy\266\276\232\013-2\343?M\005\226\232\023\337M\005\226\233q\237\246\202\313`\023\177M\005\226\300\363\337M\005\226\304\323\377M\005\226\332m\337\246\202\313m8\037\246\202\313m\272\347\323Ae\300>/\246\202\313\201e\277\246\202\313\201m\277\246\202\313\201|_M\005\227Z\013\177M\005\227Zq\257\246\202\313\255\205\237\246\202\313\255\276\357\323Ae\327D\357\323Ae\346\233o\351\240\262\363\341k\351\240\262\363\357\007\351\240\262\373L\271\364\320Z\000\002/\246\202\320\000&~\232\013@\003@\372h-\000M3\364\320Z\003\216\267\364\320Z\003\240k\351\240\264\007Yg\351\240\264\007\333\177\351\240\264\0204\377\323Ah,\262/\246\202\320Yi\317\246\202\320Ze\337\246\202\320[\020~\232\013Am\326\376\232\013Am\347\276\232\013Aq\346~\232\013At\016\3754\026\202\370[\372h-\005\366\331\372h-\t\221=\364\320Z\023\314\265\364\320Z\023\340w\351\240\264\310@\317\323Ai\220\205\237\246\202\323\"u\357\246\202\323,\274\337\323Ai\226\200\377\323Ai\227\033g\351\240\264\313\256\275\364\320Ze\327\205\364\320Ze\327\231\372h-2\370\005\364\320Ze\367\035\372h-4&Y\372h-4\310\233\372h-4\330\235\372h-4\333L\3754\026\232p\002\372h-4\340_\372h-4\353B\372h-6\020?\364\320Zm\247\003\364\320Zm\247\233\372h-6\330\005\364\320Zm\327E\364\320Zm\346\\\372h-8\007^\372h-8\007\201\364\320Zp-9\364\320Zp/3\364\320Zq\246\201\364\320Zq\246\205\364\320Zq\247]\372h-8\343!\372h-8\343\316\3754\026\234}\366\376\232\013N\201\267~\232\013N\264\373\337M\005\247_\000>\232\013N\276!}4\026\236\000]\372h-<\007\003\364\320Zx\016;\364\320ZxL\207\351\240\264\360\234{\351\240\264\363 k\351\240\264\363\"s\351\240\264\363\"{\351\240\264\363\"\177\351\240\264\363,\213\351\240\264\363O\275\364\320Zy\261\003\351\240\264\363b\027\323Ai\346\335g\351\240\264\363\255=\364\320Zy\347Y\372h-<\373b\372h->\000\273\364\320Z|\r\275\364\320Z|L\277\364\320Z}\226\303\364\320Z}\266\331\372h->\333\340\372h->\333\341\372h->\333\355\3754\026\237m\367\276\232\013O\270\'\376\232\013O\270\363?M\005\247\336\003\377M\005\247\336\013?M\005\247\336d\037M\005\247\337\013?M\005\260\000.\3754\026\300\006C\364\320[\000\037\007\323Al\r\005\257\246\202\330\032l?M\005\260<\007>\232\013`x.}4\026\302\'\034\372h-\204O\267\364\320[\010\237\177\351\240\266\026_\017\323Al.<\357\323Al.\266/\246\202\330]m\357\246\202\330^m\317\246\202\330^q\277\246\202\330^u\277\246\202\330_\013\377M\005\261\001\247\376\232\013b\013N\3754\026\304\333`\372h-\211\327\201\364\320[\023\341o\351\240\266\'\302\357\323AlO\266\017\246\202\333 i\377\246\202\333 q\357\246\202\333\"\000~\232\013l\210B\372h-\262\'^\372h-\262\313B\372h-\262\320\205\364\320[e\2605\364\320[e\301=\364\320[e\306\332\372h-\262\350\\\372h-\262\373b\372h-\262\373n\3754\026\332\000\201\364\320[h\016\213\351\240\266\320\036\017\323Am\246@\367\323Am\246[k\351\240\266\323\355\277\364\320[l,\277\364\320[l/\265\364\320[m\260\267\364\320[m\267\035\372h-\266\333\217\3754\026\333q\366\376\232\013m\272!}4\026\333u\220}4\026\333u\320}4\026\334\003O}4\026\334\003\356\3754\026\334\010\032\372h-\270\0207\364\320[p w\351\240\266\340Yw\351\240\266\340^\017\323Am\3014\327\323Am\306\202\337\323Am\307\033s\351\240\266\343\240k\351\240\266\343\240s\351\240\266\343\257\003\351\240\266\343\3173\364\320[t\016\207\351\240\266\350Y\177\351\240\266\353-\013\351\240\266\353-\203\351\240\266\353/\007\351\240\266\353/3\364\320[u\2405\364\320[u\306\336\372h-\272\350Z\372h-\272\353\201\372h-\272\353\356}4\026\335u\367\376\232\013n\274\000\3754\026\335y\227~\232\013n\274\363\277M\005\267_\023\377M\005\267\200\313\177M\005\267\200\343_M\005\267\202\373?M\005\267\231\003\177M\005\267\231\003\377M\005\267\234m\337\246\202\333\316\211\257\246\202\333\3176\327\323Am\347\304\017\246\202\333\355\272\017\246\202\333\356\t\277\246\202\333\3564/\246\202\333\356>\317\323Am\367]\007\323Am\367]g\351\240\266\373\256\273\364\320[}\360\013\351\240\266\373\355\007\351\240\266\373\356\273\364\320\\\000[\177\351\240\270\001\010\037M\005\3002\027>\232\013\200h\017}4\027\000\320_\372h.\001\2413\364\320\\\003N3\364\320\\\003O\213\351\240\270\007\304\317\323Ap\017\211\277\246\202\340\037i\317\246\202\340\037y\357\246\202\340@\007~\232\013\201\013\316\3754\027\002\313o}4\027\002\320Y\372h.\005\247\203\364\320\\\013O7\364\320\\\013O?\364\320\\\013a\027\323Ap-\211\317\246\202\340[i\357\246\202\340[|_M\005\300\266\373\177M\005\300\272\373_M\005\300\274\353\237M\005\300\276\027\276\232\013\201}\240\3754\027\004\006\331\372h.\010\017\003\351\240\270 \270/\246\202\340\204\'>\232\013\202\020\236\372h.\t\226C\364\320\\\023A\007\323ApM6\317\323ApM\204_M\005\3018 \3754\027\004\343\201\372h.\t\307\234\372h.2\007\034\372h.2\007\035\372h.2\026\237\372h.2 \013\351\240\270\313-9\364\320\\e\226\236\372h.2\313`\372h.2\313\357\3754\027\031l\017}4\027\031}\247\276\232\013\2152\313\337M\005\306\231q\377\246\202\343M:\017\246\202\343M<\037\246\202\343N\211\357\246\202\343N\270\327\323Aq\247\336\017\323Aq\247\337k\351\240\270\330\002\347\323Aq\2604\037\246\202\343`l?M\005\306\302\350~\232\013\215\210\r}4\027\033\023/}4\027\033\023`\372h.6\310\001\364\320\\m\220\263\364\320\\m\221?\364\320\\m\227\305\364\320\\m\247_\372h.6\330\037\372h.6\340\003\364\320\\m\3003\364\320\\m\300\277\364\320\\m\326\305\364\320\\m\327\205\364\320\\m\340?\364\320\\m\347Y\372h.6\363\255\3754\027\033y\327\276\232\013\215\276\006\376\232\013\215\276\007\276\232\013\216\000N\3754\027\034\020\034\372h.8\'\337\372h.8\333\315}4\027\034q\346\276\232\013\216:\373\337M\005\307\036d_M\005\307B\027\276\232\013\216\205\226~\232\013\216\205\240\3754\027\035\013L\3754\027\035\013M\3754\027\035\013\355}4\027\035\023-}4\027\035\023\357\3754\027\035e\326~\232\013\216\262\373?M\005\307Y}\277\246\202\343\255\005\257\246\202\343\255\205\257\246\202\343\256\266\367\323Aq\327\204\327\323Aq\327\231g\351\240\270\353\315\013\351\240\270\360\032w\351\240\270\360\032{\351\240\270\360\033\007\323Aq\3408\017\246\202\343\301y\277\246\202\343\301|?M\005\307\231}\237\246\202\343\315\205\277\246\202\343\315\266\037\246\202\343\315\266/\246\202\343\315\274/\246\202\343\316\201\257\246\202\343\342h\037M\005\307\304\353\277M\005\307\304\363_M\005\307\333}\357\246\202\343\356\001\337\246\202\343\356\270\367\323Aq\367\234o\351\240\270\373\354\273\364\320\\}\366^\372h.\200\r?\364\320]\000\034\177\351\240\272\000\264\017\246\202\350\002\333\277M\005\3204\323?M\005\320<\340~\232\013\240y\327\376\232\013\240|M\3754\027@\373\254\3758\330D\343\355}8\330D\360\001\364\343ad\r\267\364\343ae\267\301\364\343ae\301\007\351\346@\006\202\317\323\314\200\r<\327\323\314\200\r>\327\323\314\200\r>\357\323\314\200\r\270\347\320@ \000\0173\364\020\010\001}\267>\202\001\000@|\037A\000\200 \266\317\320@ \010M\013\350 \020\004\310\034\372\010\004\0012\310>\202\001\000M4\337\320@ \t\246\335\372\010\004\0016\313\237A\000\200&\332g\350 \020\004\333\217\375\004\002\000\233u\317\240\200@\023n\275\364\020\010\002p@\372\010\004\0018\'\276\202\001\000N2\357\320@ \t\306_\372\010\004\0018\333\177A\000\200\'\034w\350 \020\004\343\256\375\004\002\000\234u\357\240\262\330\000\000\273\364\026\336\003\256\270\327\320\\\020\000\026\\\372\013\202\000\002\353\337Ap@\000\204\357\320_\000\000\'\236\372\013\340\000\032\023?A|\000\003Bw\350/\200\001}\367\376\202\370\000&\332{\350/\200\002y\340}\005\360\001\226D\037\240\276\0002\310\231\372\013\340\003,\211\277\240\276\0002\310\234\372\013\340\003,\211\357\240\276\0002\310\237\372\013\340\003,\262\017\240\276\0002\320\035\372\013\340\003-\001\357\240\276\0002\320\037\372\013\340\003L\201\377\240\276\0004\330\\\372\013\340\003M\205\337\240\276\0004\330^\372\013\340\003M\205\377\240\276\0004\330\201\364\027\300\006\233\020~\202\370\000\323\317\213\350/\200\r>\000\375\005\360\001\261\001\277\240\276\0006 9\364\027\300\006\304\026\276\202\370\000\330\202\337\320_\000\033\020]\372\013\340\003b\013\337A|\000lA\177\350/\200\r\270\343\177A|\000m\307E\364\027\300\006\335e\317\240\276\0006\353M}4\026B\350[oa\226\337i~\224\000T\320?J\010\001yA\002\343A\270\313*b\321\277d\002-1X\215\256\303w\032K\364\245#\362\260\346,\000_\226I|\245\211\323M\037j\022q\330\202\246\014\233\265,\363\315\276\260\177@\230\362\264\307<\324\025i\245*\321\214\235KT\213X^\326\225\tX\325J\177\224)\244\202)/\237\225\203\361\203\261\223\026\301\372\232\274M_\361@\224\362\264\307<\324\025i\274!h\315P\354\364\267r\330\203\036\257\207\013\355\005\246\\m\357@\003p3p\257\275\256\017\347|\346B\206B\225\035*\rMl\353R\263\320bz\376\024\334R\2512\344;\025\263\\\345\242\265%=\212R{\n\241\252\224\353\377?@\236\362\264\307<\324\025i\245*\304\266\313\013RV\260\275\255*\022\261\016\204\255-\207\245i\274#\204\013K\264\017@\217\362\264\307<\324\025i\006\221\255\334\266 \307\253\207\013\355>\333\302m\277v\204-]\317\353@\217\362\264\307<\324\025j\212\232OR\324\0162\321\240b:\220\307k\030\214\366L\307k\030\216\24417\204-]\207\221\211\274 +\240\266w+\016\274\017@\214\362\267\224!j\354:JD\230\365\177\212\017\332\224\236B\301\035\007\'_@\213\362\264\266\016\222\254z\322c\324\217\211\335\016\214\032\266\344\305\223O@\223\362\264\307<\324\025i\245*\326\027\265\245BVM\203!\177\303\031)\350\027\2564\323?]\254\242\240\267q\367\231k\351\210\352C\035\254b3\3313\035\254b:\220\304\336\020\265v\036F&\360\200\256\202\331\334\254:\360>\273YEAn\343\3572\327\320\311O@\275q\246\231@\217\362\264\307<\324\025i\221Dk \266w1\013\003web\017(\300\016\270\262\303\266\001\000/,\006\326\000V\020>\324/\232\315aQ\006\371\355\372Q\220\255\240~\226\020\002\362\202\005\306\203q\226T\305\243\177\332\225\2153\300\307\332\222\036\221\232\250\027\230\347\232\202\256C\323\017(\377\'\323\222\374\001\023\360\037\036L\272\274\305D\276\254\237/\237yd\333\370\224\003\036\275\035w\352\247N\276\306j\251\346\240\277\226\001\313\315\343[\266I\315E\355\274\031\330W,\246\350*\375\351\230\217\342\277\336\034ZC\2435\323BO\323\311\023fK\306\316\314m;\0179\331\313\223\006\216\267\253\353\217e\373\037\305\2012\343\272/\034)\333]\267r\375\250_5\232\302\242\016E\223\351FB\266\242%a\000/( \\h7\031eLZ7\375\251X\323<\014}\251!\351\031\252\201y\216y\250*\344=?jcJk\325U\036\277@\215\362\264\307<\324\025h\306N\245\252D\177\320b:\220\307k\030\214\366L\307k\030\216\24417\204-]\207\221\211\274 +\240\266w+\016\274\017\256\326QP[\270\373\314\265\364\304u!\216\3261\031\354\231\216\3261\035Hbo\010Z\273\017#\023x@W\232R\260\363\237C%=\002\365\306\232g@\222\362\264\307<\324\025i\016\205\220[;\230\205Y6\014\205\207\244f\252\344\347\244\277@\214\362\264\307<\324\025d\026\316\346!\177\207\361\343\307\324\347\244\277@\234\362\264\307<\324\025i\245*\326\025\025\236\244\025b\036B\255!R3P\205\223`\310_\250\260\250\254\365 \261\020\362\026$\0251G\352(\306N\245\252O\253\n\212\317R\013\021\017!bAS\024~\242\214d\352Z\244@\236\362\264\307<\324\025i\245*\326\025\025\236\244\025h\317\'\245\223`\352D\247\262\221\244\307\251\037\215\232\332\275\232\272\313\'\321\'\266\256\245\223@\222\362\264\307<\324\025dNZ(\224\310\235d$i\265\037\207\275\010&\273\202\037_@\205\035\tY\035\311\354\237\264\037\315\306\232g\371\373R\221\300&\337\020\000\017\265;Zb@\330Y\003-2\317\332\235\2551 l,\201\226\231\027\332\235\2551 l,\201\226\231\017\332\235\2551 l,\201\226Y\177\355N\326\230\2206\026@\313,\267\365\332\323\022\017\346\343M3\374\375\251H\340\023o\210\000\007\332\235\340\376Zg\351\241}4\037\246_\372e\277\347@\223\362\264\307<\324\025i\245*\310-\235\314B\254\233\006B\377\207\361\343\307\324\347\244\277R\203\250\365\027{\213\204\204-i[\005D<\206\252o@\225\362\261j\356\177K[Z\023aGJ\310-\235\314B\254\223R_\202\010Z"
      }
    }
  }
  events {
    timestamp {
      seconds: 1525207293
      nanos: 346744029
    }
    write {
      data: {
        as_bytes: "\000\035V\000\000\000\000\000\001<!doctype html><html itemscope=\"\" itemtype=\"http://schema.org/WebPage\" lang=\"en\"><head><meta content=\"Search the world\'s information, including webpages, images, videos and more. Google has many special features to help you find exactly what you\'re looking for.\" name=\"description\"><meta content=\"noodp\" name=\"robots\"><meta content=\"text/html; charset=UTF-8\" http-equiv=\"Content-Type\"><meta content=\"/images/branding/googleg/1x/googleg_standard_color_128dp.png\" itemprop=\"image\"><title>Google</title><script nonce=\"rLBCtD6iWuWYX1UPQlCXOA==\">(function(){window.google={kEI:\'_dDoWrawEqit_QaygpG4Dw\',kEXPI:\'0,1352960,787,57,473,638,542,205,99,1018,74,366,892,289,221,398,19,2341024,210,165,52,23,329303,1294,12383,2349,2506,23435,9256,16115,316,453,7,792,7,9186,1402,5281,1100,3335,2,2,1624,515,2466,2196,363,554,332,332,2102,113,2201,1525,150,1516,224,843,1372,133,130,3322,658,208,919,444,131,1116,2,582,352,24,287,64,310,296,1056,402,368,58,2,1,3,190,495,612,284,104,789,1113,1149,154,730,1615,2,153,8,318,49,7,1,2,137,412,50,636,8,537,770,67,196,722,51,77,450,188,517,21,543,452,221,62,2,840,1,283,158,440,390,143,283,230,22,25,10,341,87,124,149,30,27,64,2,3,30,119,272,935,139,41,344,75,9,206,2,343,189,658,44,484,170,111,91,721,112,6029110,1873,672,9,41,8797610,135,4,1572,549,332,441,2,2,1,2,1,1,77,1,1,900,207,1,1,1,1,1,371,9,304,1,8,1,2,1,1,446,7,64,8,22311411\',authuser:0,kscs:\'c9c918f0__dDoWrawEqit_QaygpG4Dw\',u:\'c9c918f0\',kGL:\'US\'};google.kHL=\'en\';})();google.time=function(){return(new Date).getTime()};(function(){google.lc=[];google.li=0;google.getEI=function(a){for(var b;a&&(!a.getAttribute||!(b=a.getAttribute(\"eid\")));)a=a.parentNode;return b||google.kEI};google.getLEI=function(a){for(var b=null;a&&(!a.getAttribute||!(b=a.getAttribute(\"leid\")));)a=a.parentNode;return b};google.https=function(){return\"https:\"==window.location.protocol};google.ml=function(){return null};google.wl=function(a,b){try{google.ml(Error(a),!1,b)}catch(d){}};google.log=function(a,b,d,c,g){if(a=google.logUrl(a,b,d,c,g)){b=new Image;var e=google.lc,f=google.li;e[f]=b;b.onerror=b.onload=b.onabort=function(){delete e[f]};google.vel&&google.vel.lu&&google.vel.lu(a);b.src=a;google.li=f+1}};google.logUrl=function(a,b,d,c,g){var e=\"\",f=google.ls||\"\";d||-1!=b.search(\"&ei=\")||(e=\"&ei=\"+google.getEI(c),-1==b.search(\"&lei=\")&&(c=google.getLEI(c))&&(e+=\"&lei=\"+c));c=\"\";!d&&google.cshid&&-1==b.search(\"&cshid=\")&&(c=\"&cshid=\"+google.cshid);a=d||\"/\"+(g||\"gen_204\")+\"?atyp=i&ct=\"+a+\"&cad=\"+b+e+f+\"&zx=\"+google.time()+c;/^http:/i.test(a)&&google.https()&&(google.ml(Error(\"a\"),!1,{src:a,glmm:1}),a=\"\");return a};}).call(this);(function(){google.y={};google.x=function(a,b){if(a)var c=a.id;else{do c=Math.random();while(google.y[c])}google.y[c]=[a,b];return!1};google.lm=[];google.plm=function(a){google.lm.push.apply(google.lm,a)};google.lq=[];google.load=function(a,b,c){google.lq.push([[a],b,c])};google.loadAll=function(a,b){google.lq.push([a,b])};}).call(this);google.f={};var a=window.location,b=a.href.indexOf(\"#\");if(0<=b){var c=a.href.substring(b+1);/(^|&)q=/.test(c)&&-1==c.indexOf(\"#\")&&a.replace(\"/search?\"+c.replace(/(^|&)fp=[^&]*/g,\"\")+\"&cad=h\")};</script><style>#gbar,#guser{font-size:13px;padding-top:1px !important;}#gbar{height:22px}#guser{padding-bottom:7px !important;text-align:right}.gbh,.gbd{border-top:1px solid #c9d7f1;font-size:1px}.gbh{height:0;position:absolute;top:24px;width:100%}@media all{.gb1{height:22px;margin-right:.5em;vertical-align:top}#gbar{float:left}}a.gb1,a.gb4{text-decoration:underline !important}a.gb1,a.gb4{color:#00c !important}.gbi .gb4{color:#dd8e27 !important}.gbf .gb4{color:#900 !important}\n</style><style>body,td,a,p,.h{font-family:arial,sans-serif}body{margin:0;overflow-y:scroll}#gog{padding:3px 8px 0}td{line-height:.8em}.gac_m td{line-height:17px}form{margin-bottom:20px}.h{color:#36c}.q{color:#00c}.ts td{padding:0}.ts{border-collapse:collapse}em{font-weight:bold;font-style:normal}.lst{height:25px;width:496px}.gsfi,.lst{font:18px arial,sans-serif}.gsfs{font:17px arial,sans-serif}.ds{display:inline-box;display:inline-block;margin:3px 0 4px;margin-left:4px}input{font-family:inherit}a.gb1,a.gb2,a.gb3,a.gb4{color:#11c !important}body{background:#fff;color:black}a{color:#11c;text-decoration:none}a:hover,a:active{text-decoration:underline}.fl a{color:#36c}a:visited{color:#551a8b}a.gb1,a.gb4{text-decoration:underline}a.gb3:hover{text-decoration:none}#ghead a.gb2:hover{color:#fff !important}.sblc{padding-top:5px}.sblc a{display:block;margin:2px 0;margin-left:13px;font-size:11px}.lsbb{background:#eee;border:solid 1px;border-color:#ccc #999 #999 #ccc;height:30px}.lsbb{display:block}.ftl,#fll a{display:inline-block;margin:0 12px}.lsb{background:url(/images/nav_logo229.png) 0 -261px repeat-x;border:none;color:#000;cursor:pointer;height:30px;margin:0;outline:0;font:15px arial,sans-serif;vertical-align:top}.lsb:active{background:#ccc}.lst:focus{outline:none}</style><script nonce=\"rLBCtD6iWuWYX1UPQlCXOA==\"></script><link href=\"/images/branding/product/ico/googleg_lodp.ico\" rel=\"shortcut icon\"></head><body bgcolor=\"#fff\"><script nonce=\"rLBCtD6iWuWYX1UPQlCXOA==\">(function(){var src=\'/images/nav_logo229.png\';var iesg=false;document.body.onload = function(){window.n && window.n();if (document.images){new Image().src=src;}\nif (!iesg){document.f&&document.f.q.focus();document.gbqf&&document.gbqf.q.focus();}\n}\n})();</script><div id=\"mngb\"> <div id=gbar><nobr><b class=gb1>Search</b> <a class=gb1 href=\"https://www.google.com/imghp?hl=en&tab=wi\">Images</a> <a class=gb1 href=\"https://maps.google.com/maps?hl=en&tab=wl\">Maps</a> <a class=gb1 href=\"https://play.google.com/?hl=en&tab=w8\">Play</a> <a class=gb1 href=\"https://www.youtube.com/?gl=US&tab=w1\">YouTube</a> <a class=gb1 href=\"https://news.google.com/nwshp?hl=en&tab=wn\">News</a> <a class=gb1 href=\"https://mail.google.com/mail/?tab=wm\">Gmail</a> <a class=gb1 href=\"https://drive.google.com/?tab=wo\">Drive</a> <a class=gb1 style=\"text-decoration:none\" href=\"https://www.google.com/intl/en/options/\"><u>More</u> &raquo;</a></nobr></div><div id=guser width=100%><nobr><span id=gbn class=gbi></span><span id=gbf class=gbf></span><span id=gbe></span><a href=\"http://www.google.com/history/optout?hl=en\" class=gb4>Web History</a> | <a  href=\"/preferences?hl=en\" class=gb4>Settings</a> | <a target=_top id=gb_70 href=\"https://accounts.google.com/ServiceLogin?hl=en&passive=true&continue=https://www.google.com/\" class=gb4>Sign in</a></nobr></div><div class=gbh style=left:0></div><div class=gbh style=right:0></div> </div><center><br clear=\"all\" id=\"lgpd\"><div id=\"lga\"><img alt=\"Google\" height=\"92\" src=\"/images/branding/googlelogo/1x/googlelogo_white_background_color_272x92dp.png\" style=\"padding:28px 0 14px\" width=\"272\" id=\"hplogo\" onload=\"window.lol&&lol()\"><br><br></div><form action=\"/search\" name=\"f\"><table cellpadding=\"0\" cellspacing=\"0\"><tr valign=\"top\"><td width=\"25%\">&nbsp;</td><td align=\"center\" nowrap=\"\"><input name=\"ie\" value=\"ISO-8859-1\" type=\"hidden\"><input value=\"en\" name=\"hl\" type=\"hidden\"><input name=\"source\" type=\"hidden\" value=\"hp\"><input name=\"biw\" type=\"hidden\"><input name=\"bih\" type=\"hidden\"><div class=\"ds\" style=\"height:32px;margin:4px 0\"><input style=\"color:#000;margin:0;padding:5px 8px 0 6px;vertical-align:top\" autocomplete=\"off\" class=\"lst\" value=\"\" title=\"Google Search\" maxlength=\"2048\" name=\"q\" size=\"57\"></div><br style=\"line-height:0\"><span class=\"ds\"><span class=\"lsbb\"><input class=\"lsb\" value=\"Google Search\" name=\"btnG\" type=\"submit\"></span></span><span class="
      }
    }
  }
  events {
    timestamp {
      seconds: 1525207293
      nanos: 347782371
    }
    write {
      data: {
        as_bytes: "\000\014\010\000\000\000\000\000\001\"ds\"><span class=\"lsbb\"><input class=\"lsb\" value=\"I\'m Feeling Lucky\" name=\"btnI\" onclick=\"if(this.form.q.value)this.checked=1; else top.location=\'/doodles/\'\" type=\"submit\"></span></span></td><td class=\"fl sblc\" align=\"left\" nowrap=\"\" width=\"25%\"><a href=\"/advanced_search?hl=en&amp;authuser=0\">Advanced search</a><a href=\"/language_tools?hl=en&amp;authuser=0\">Language tools</a></td></tr></table><input id=\"gbv\" name=\"gbv\" type=\"hidden\" value=\"1\"></form><div id=\"gac_scont\"></div><div style=\"font-size:83%;min-height:3.5em\"><br></div><span id=\"footer\"><div style=\"font-size:10pt\"><div style=\"margin:19px auto;text-align:center\" id=\"fll\"><a href=\"/intl/en/ads/\">Advertising\240Programs</a><a href=\"/services/\">Business Solutions</a><a href=\"https://plus.google.com/116899029375914044550\" rel=\"publisher\">+Google</a><a href=\"/intl/en/about.html\">About Google</a></div></div><p style=\"color:#767676;font-size:8pt\">&copy; 2018 - <a href=\"/intl/en/policies/privacy/\">Privacy</a> - <a href=\"/intl/en/policies/terms/\">Terms</a></p></span></center><script nonce=\"rLBCtD6iWuWYX1UPQlCXOA==\">(function(){window.google.cdo={height:0,width:0};(function(){var a=window.innerWidth,b=window.innerHeight;if(!a||!b){var c=window.document,d=\"CSS1Compat\"==c.compatMode?c.documentElement:c.body;a=d.clientWidth;b=d.clientHeight}a&&b&&(a!=google.cdo.width||b!=google.cdo.height)&&google.log(\"\",\"\",\"/client_204?&atyp=i&biw=\"+a+\"&bih=\"+b+\"&ei=\"+google.kEI);}).call(this);})();</script><div id=\"xjsd\"></div><div id=\"xjsi\"><script nonce=\"rLBCtD6iWuWYX1UPQlCXOA==\">(function(){function c(b){window.setTimeout(function(){var a=document.createElement(\"script\");a.src=b;google.timers&&google.timers.load.t&&google.tick(\"load\",{gen204:\"xjsls\",clearcut:31});document.getElementById(\"xjsd\").appendChild(a)},0)}google.dljp=function(b,a){google.xjsu=b;c(a)};google.dlj=c;}).call(this);if(!google.xjs){window._=window._||{};window._DumpException=window._._DumpException=function(e){throw e};window._F_installCss=window._._F_installCss=function(c){};google.dljp(\'/xjs/_/js/k\\x3dxjs.hp.en_US.hJpRN-HQS74.O/m\\x3dsb_he,d/am\\x3dVDA2/rt\\x3dj/d\\x3d1/rs\\x3dACT90oGoOpEv-zlKjP7tm3pX-9wBDPuVdQ\',\'/xjs/_/js/k\\x3dxjs.hp.en_US.hJpRN-HQS74.O/m\\x3dsb_he,d/am\\x3dVDA2/rt\\x3dj/d\\x3d1/rs\\x3dACT90oGoOpEv-zlKjP7tm3pX-9wBDPuVdQ\');google.xjs=1;}google.pmc={\"sb_he\":{\"agen\":true,\"cgen\":true,\"client\":\"heirloom-hp\",\"dh\":true,\"dhqt\":true,\"ds\":\"\",\"ffql\":\"en\",\"fl\":true,\"host\":\"google.com\",\"isbh\":28,\"jsonp\":true,\"msgs\":{\"cibl\":\"Clear Search\",\"dym\":\"Did you mean:\",\"lcky\":\"I\\u0026#39;m Feeling Lucky\",\"lml\":\"Learn more\",\"oskt\":\"Input tools\",\"psrc\":\"This search was removed from your \\u003Ca href=\\\"/history\\\"\\u003EWeb History\\u003C/a\\u003E\",\"psrl\":\"Remove\",\"sbit\":\"Search by image\",\"srch\":\"Google Search\"},\"nds\":true,\"ovr\":{},\"pq\":\"\",\"refpd\":true,\"rfs\":[],\"sbpl\":24,\"sbpr\":24,\"scd\":10,\"sce\":5,\"stok\":\"3mJuW88WexlwJgN3WXmg_mhSAvs\"},\"d\":{},\"ZI/YVQ\":{},\"U5B21g\":{},\"DPBNMg\":{},\"YFCs/g\":{}};google.x(null,function(){});(function(){var r=[];google.plm(r);})();(function(){var ctx=[]\n;google.jsc && google.jsc.x(ctx);})();</script></div></body></html>\000\000\000\000\001\000\000\000\001"
      }
    }
  }
}
    1   0.000000    127.0.0.1  127.0.0.1    HTTP2 157 Magic, SETTINGS[0], WINDOW_UPDATE[0], HEADERS[1]: GET /
    2   0.013713    127.0.0.1  127.0.0.1    HTTP2 91 SETTINGS[0], SETTINGS[0], WINDOW_UPDATE[0]
    3   0.013821    127.0.0.1  127.0.0.1    HTTP2 63 SETTINGS[0]
    4   0.128649    127.0.0.1  127.0.0.1    HTTP2 5586 HEADERS[1]: 200 OK
    5   0.130007    127.0.0.1  127.0.0.1    HTTP2 7573 DATA[1]
    6   0.131045    127.0.0.1  127.0.0.1    HTTP2 3152 DATA[1], DATA[1] (text/html)
# Map from listeners proto, with holes where filter config fragments should go, and
# a list of filter config fragment protos, to a final listeners.pb with the
# config fragments converted to the opaque Struct representation.

import sys

# Some evil hack to deal with the fact that Bazel puts both google/api and
# google/protobuf roots in the sys.path, and Python gets confused, e.g. it
# thinks that there is no api package if it encounters the google/protobuf root
# in sys.path first.
from pkgutil import extend_path
import google

google.__path__ = extend_path(google.__path__, google.__name__)

from google.protobuf import json_format
from google.protobuf import struct_pb2
from google.protobuf import text_format

from envoy.api.v2 import lds_pb2
from envoy.config.filter.network.http_connection_manager.v2 import http_connection_manager_pb2


# Convert an arbitrary proto object to its Struct proto representation.
def proto_to_struct(proto):
    json_rep = json_format.MessageToJson(proto)
    parsed_msg = struct_pb2.Struct()
    json_format.Parse(json_rep, parsed_msg)
    return parsed_msg


# Parse a proto from the filesystem.
def parse_proto(path, filter_name):
    # We only know about some filter config protos ahead of time.
    KNOWN_FILTERS = {
        'http_connection_manager': lambda: http_connection_manager_pb2.HttpConnectionManager()
    }
    filter_config = KNOWN_FILTERS[filter_name]()
    with open(path, 'r') as f:
        text_format.Merge(f.read(), filter_config)
    return filter_config


def generate_listeners(listeners_pb_path, output_pb_path, output_json_path, fragments):
    listener = lds_pb2.Listener()
    with open(listeners_pb_path, 'r') as f:
        text_format.Merge(f.read(), listener)

    for filter_chain in listener.filter_chains:
        for f in filter_chain.filters:
            f.config.CopyFrom(proto_to_struct(parse_proto(next(fragments), f.name)))

    with open(output_pb_path, 'w') as f:
        f.write(str(listener))

    with open(output_json_path, 'w') as f:
        f.write(json_format.MessageToJson(listener))


if __name__ == '__main__':
    if len(sys.argv) < 4:
        print(
            'Usage: %s <path to listeners.pb> <output listeners.pb> <output '
            'listeners.json> <filter config fragment paths>') % sys.argv[0]
        sys.exit(1)

    generate_listeners(sys.argv[1], sys.argv[2], sys.argv[3], iter(sys.argv[4:]))
version: v1
deps:
- buf.build/googleapis/googleapis:62f35d8aed1149c291d606d958a7ce32
- buf.build/opencensus/opencensus
- buf.build/prometheus/client-model
- buf.build/opentelemetry/opentelemetry
- buf.build/gogo/protobuf
- buf.build/cncf/xds
- buf.build/envoyproxy/protoc-gen-validate
breaking:
  ignore_unstable_packages: true
  use:
  - FIELD_SAME_ONEOF
  - FIELD_SAME_JSON_NAME
  - FIELD_SAME_NAME
  - FIELD_SAME_TYPE
  - FIELD_SAME_LABEL
  - FILE_SAME_PACKAGE
  - FIELD_NO_DELETE_UNLESS_NUMBER_RESERVED
  - FIELD_NO_DELETE_UNLESS_NAME_RESERVED
lint:
  use:
  - IMPORT_USED
  ignore_only:
    IMPORT_USED:
    - envoy/api/v2/listener.proto
    - envoy/config/bootstrap/v2/bootstrap.proto
// NOLINT(namespace-envoy)
#include <cstdlib>
#include <iostream>

// We don't use all the headers in the test below, but including them anyway as
// a cheap way to get some C++ compiler sanity checking.
#include "envoy/config/cluster/v3/cluster.pb.validate.h"
#include "envoy/config/endpoint/v3/endpoint.pb.validate.h"
#include "envoy/config/listener/v3/listener.pb.validate.h"
#include "envoy/config/route/v3/route.pb.validate.h"
#include "envoy/config/core/v3/protocol.pb.validate.h"
#include "envoy/config/accesslog/v3/accesslog.pb.validate.h"
#include "envoy/extensions/compression/gzip/decompressor/v3/gzip.pb.validate.h"
#include "envoy/extensions/filters/http/buffer/v3/buffer.pb.validate.h"
#include "envoy/extensions/filters/http/fault/v3/fault.pb.validate.h"
#include "envoy/extensions/filters/http/grpc_json_transcoder/v3/transcoder.pb.validate.h"
#include "envoy/extensions/filters/http/header_to_metadata/v3/header_to_metadata.pb.validate.h"
#include "envoy/extensions/filters/http/health_check/v3/health_check.pb.validate.h"
#include "envoy/extensions/filters/http/ip_tagging/v3/ip_tagging.pb.validate.h"
#include "envoy/extensions/filters/http/lua/v3/lua.pb.validate.h"
#include "envoy/extensions/filters/http/router/v3/router.pb.validate.h"
#include "envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.validate.h"
#include "envoy/extensions/filters/network/mongo_proxy/v3/mongo_proxy.pb.validate.h"
#include "envoy/extensions/filters/network/redis_proxy/v3/redis_proxy.pb.validate.h"
#include "envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.pb.validate.h"
#include "envoy/extensions/health_checkers/redis/v3/redis.pb.validate.h"
#include "envoy/config/bootstrap/v3/bootstrap.pb.validate.h"

#include "google/protobuf/text_format.h"

template <class Proto> struct TestCase {
  void run() {
    std::string err;
    if (Validate(invalid_message, &err)) {
      std::cerr << "Unexpected successful validation of invalid message: "
                << invalid_message.DebugString() << std::endl;
      exit(EXIT_FAILURE);
    }
    if (!Validate(valid_message, &err)) {
      std::cerr << "Unexpected failed validation of valid message: " << valid_message.DebugString()
                << ", " << err << std::endl;
      exit(EXIT_FAILURE);
    }
  }

  Proto& invalid_message;
  Proto& valid_message;
};

// Basic protoc-gen-validate C++ validation header inclusion and Validate calls
// from data plane API.
int main(int /*argc*/, char* /*argv*/[]) {
  envoy::config::bootstrap::v3::Bootstrap invalid_bootstrap;
  invalid_bootstrap.mutable_static_resources()->add_clusters();
  // This is a baseline test of the validation features we care about. It's
  // probably not worth adding in every filter and field that we want to valid
  // in the API upfront, but as regressions occur, this is the place to add the
  // specific case.
  const std::string valid_bootstrap_text = R"EOF(
  node {}
  cluster_manager {}
  admin {
    access_log_path: "/dev/null"
    address { pipe { path: "/" } }
  }
  )EOF";
  envoy::config::bootstrap::v3::Bootstrap valid_bootstrap;
  if (!google::protobuf::TextFormat::ParseFromString(valid_bootstrap_text, &valid_bootstrap)) {
    std::cerr << "Unable to parse text proto: " << valid_bootstrap_text << std::endl;
    exit(EXIT_FAILURE);
  }
  TestCase<envoy::config::bootstrap::v3::Bootstrap>{invalid_bootstrap, valid_bootstrap}.run();

  exit(EXIT_SUCCESS);
}
load("@envoy_api//bazel:api_build_system.bzl", "api_cc_test")

licenses(["notice"])  # Apache 2

api_cc_test(
    name = "pgv_test",
    srcs = ["pgv_test.cc"],
    # Workaround for https://github.com/bazelbuild/bazel/issues/13819
    linkstatic = True,
    deps = [
        "@envoy_api//envoy/config/accesslog/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/listener/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/compression/gzip/decompressor/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/http/buffer/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/http/fault/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/http/grpc_json_transcoder/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/http/gzip/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/http/header_to_metadata/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/http/health_check/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/http/ip_tagging/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/http/lua/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/http/router/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/network/mongo_proxy/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/network/redis_proxy/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/health_checkers/redis/v3:pkg_cc_proto",
        "@envoy_api//envoy/service/listener/v3:pkg_cc_proto",
    ],
)
package go_build_test

import (
	"testing"

	_ "github.com/envoyproxy/go-control-plane/envoy/api/v2"
	_ "github.com/envoyproxy/go-control-plane/envoy/api/v2/auth"
	_ "github.com/envoyproxy/go-control-plane/envoy/service/accesslog/v2"
	_ "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v2"
	_ "github.com/envoyproxy/go-control-plane/envoy/service/metrics/v2"
	_ "github.com/envoyproxy/go-control-plane/envoy/service/ratelimit/v2"
)

func TestNoop(t *testing.T) {
	// Noop test that verifies the successful importation of Envoy V2 API protos
}
// NOLINT(namespace-envoy)
#include <cstdlib>
#include <iostream>

#include "google/protobuf/descriptor.h"

// Basic C++ build/link validation for the v2 xDS APIs.
int main(int argc, char* argv[]) {
  const auto methods = {
      "envoy.api.v2.ClusterDiscoveryService.FetchClusters",
      "envoy.api.v2.ClusterDiscoveryService.StreamClusters",
      "envoy.api.v2.EndpointDiscoveryService.FetchEndpoints",
      "envoy.api.v2.EndpointDiscoveryService.StreamEndpoints",
      "envoy.api.v2.ListenerDiscoveryService.FetchListeners",
      "envoy.api.v2.ListenerDiscoveryService.StreamListeners",
      "envoy.api.v2.RouteDiscoveryService.FetchRoutes",
      "envoy.api.v2.RouteDiscoveryService.StreamRoutes",
      "envoy.service.discovery.v2.AggregatedDiscoveryService.StreamAggregatedResources",
      "envoy.service.discovery.v2.HealthDiscoveryService.FetchHealthCheck",
      "envoy.service.discovery.v2.HealthDiscoveryService.StreamHealthCheck",
      "envoy.service.discovery.v2.RuntimeDiscoveryService.FetchRuntime",
      "envoy.service.discovery.v2.RuntimeDiscoveryService.StreamRuntime",
      "envoy.service.accesslog.v2.AccessLogService.StreamAccessLogs",
      "envoy.service.metrics.v2.MetricsService.StreamMetrics",
      "envoy.service.ratelimit.v2.RateLimitService.ShouldRateLimit",
      "udpa.service.orca.v1.OpenRcaService.StreamCoreMetrics",
  };

  for (const auto& method : methods) {
    if (google::protobuf::DescriptorPool::generated_pool()->FindMethodByName(method) == nullptr) {
      std::cout << "Unable to find method descriptor for " << method << std::endl;
      exit(EXIT_FAILURE);
    }
  }

  exit(EXIT_SUCCESS);
}
load("@envoy_api//bazel:api_build_system.bzl", "api_cc_test", "api_go_test")

licenses(["notice"])  # Apache 2

api_cc_test(
    name = "build_test",
    srcs = ["build_test.cc"],
    # Workaround for https://github.com/bazelbuild/bazel/issues/13819
    linkstatic = True,
    deps = [
        "//envoy/api/v2:pkg_cc_proto",
        "//envoy/service/accesslog/v2:pkg_cc_proto",
        "//envoy/service/discovery/v2:pkg_cc_proto",
        "//envoy/service/metrics/v2:pkg_cc_proto",
        "//envoy/service/ratelimit/v2:pkg_cc_proto",
        "@com_github_cncf_xds//udpa/service/orca/v1:pkg_cc_proto",
    ],
)

api_go_test(
    name = "go_build_test",
    size = "small",
    srcs = ["go_build_test.go"],
    importpath = "go_build_test",
    deps = [
        "//envoy/api/v2:pkg_go_proto",
        "//envoy/api/v2/auth:pkg_go_proto",
        "//envoy/service/accesslog/v2:pkg_go_proto",
        "//envoy/service/discovery/v2:pkg_go_proto",
        "//envoy/service/metrics/v2:pkg_go_proto",
        "//envoy/service/ratelimit/v2:pkg_go_proto",
    ],
)
# API versioning guidelines

The Envoy project and [xDS working group](https://github.com/cncf/xds) take API stability and
versioning seriously. Providing stable APIs is a necessary step in ensuring API adoption and success
of the ecosystem. Below we articulate the API versioning guidelines that aim to deliver this
stability.

# API semantic versioning

The Envoy APIs consist of a family of packages, e.g. `envoy.admin.v3alpha`,
`envoy.service.trace.v3`. Each package is independently versioned with a protobuf semantic
versioning scheme based on https://cloud.google.com/apis/design/versioning.

The major version for a package is captured in its name (and directory structure). E.g. version 3
of the tracing API package is named `envoy.service.trace.v3` and its constituent protos are located
in `api/envoy/service/trace/v3`. Every protobuf must live directly in a versioned package namespace,
we do not allow subpackages such as `envoy.service.trace.v3.somethingelse`.

In everyday discussion and GitHub labels, we refer to the `v2`, `v3`, `vN`, `...` APIs. This has a
specific technical meaning. Any given message in the Envoy API, e.g. the `Bootstrap` at
`envoy.config.bootstrap.v3.Bootstrap`, will transitively reference a number of packages in the Envoy
API. These may be at `vN`, `v(N-1)`, etc. The Envoy API is technically a DAG of versioned package
namespaces. When we talk about the `vN xDS API`, we really refer to the `N` of the root
configuration resources (e.g. bootstrap, xDS resources such as `Cluster`). The
v3 API bootstrap configuration is `envoy.config.bootstrap.v3.Bootstrap`.

# Backwards compatibility

In general, within a package's major API version, we do not allow any breaking changes. The guiding
principle is that neither the wire format nor protobuf compiler generated language bindings should
experience a backward compatible break on a change. Specifically:

* Fields should not be renumbered or have their types changed. This is standard proto development
  procedure.

* Renaming of fields or package namespaces for a proto must not occur. This is inherently dangerous,
  since:
  * Field renames break wire compatibility. This is stricter than standard proto development
    procedure in the sense that it does not break binary wire format. However, it **does** break
    loading of YAML/JSON into protos as well as text protos. Since we consider YAML/JSON to be first
    class inputs, we must not change field names.

  * For service definitions, the gRPC endpoint URL is inferred from package namespace, so this will
    break client/server communication.

  * For a message embedded in an `Any` object, the type URL, which the package namespace is a part
    of, may be used by Envoy or other API consuming code. Currently, this applies to the top-level
    resources embedded in `DiscoveryResponse` objects, e.g. `Cluster`, `Listener`, etc.

  * Consuming code will break and require source code changes to match the API changes.

* Some other changes are considered breaking for Envoy APIs that are usually considered safe in
  terms of protobuf wire compatibility:
  * Upgrading a singleton field to a repeated, e.g. `uint32 foo = 1;` to `repeated uint32 foo = 1`.
    This changes the JSON wire representation and hence is considered a breaking change.

  * Wrapping an existing field with `oneof`. This has no protobuf or JSON/YAML wire implications,
    but is disruptive to various consuming stubs in languages such as Go, creating unnecessary
    churn.

  * Increasing the strictness of
    [protoc-gen-validate](https://github.com/bufbuild/protoc-gen-validate) annotations. Exceptions
    may be granted for scenarios in which these stricter conditions model behavior already implied
    structurally or by documentation.

An exception to the above policy exists for:
* Changes made within 14 days of the introduction of a new API field or message, provided the new field
or message has not been included in an Envoy release.
* API versions tagged `vNalpha`. Within an alpha major version, arbitrary breaking changes are allowed.
* Any proto with a `(udpa.annotations.file_status).work_in_progress`,
  `(xds.annotations.v3.file_status).work_in_progress`
  `(xds.annotations.v3.message_status).work_in_progress`, or
  `(xds.annotations.v3.field_status).work_in_progress` option annotation.

Note that changes to default values for wrapped types, e.g. `google.protobuf.UInt32Value` are not
governed by the above policy. Any management server requiring stability across Envoy API or
implementations within a major version should set explicit values for these fields.

# API lifecycle

At one point, the Envoy project planned for regular major version updates to the xDS API in order to
remove technical debt. At this point we recognize that Envoy and the larger xDS ecosystem (gRPC,
etc.) is too widely used to make version bumps realistic. As such, for practical purposes, the v3
API is the final major version of the API and will be supported forever. Deprecations will still
occur as an end-user indication that there is a preferred way to configure a particular feature, but
no field will ever be removed nor will Envoy ever remove the implementation for any deprecated
field.

**NOTE**: Client implementations are free to output additional warnings about field usage beyond
deprecation, if for example, the continued use of the field is deemed a substantial
security risk. Individual client versions are also free to stop supporting fields if they want to,
though Envoy Proxy (as an xDS client) commits to never doing so.

# New API features

The Envoy APIs can be [safely extended](https://cloud.google.com/apis/design/compatibility) with new
packages, messages, enums, fields and enum values, while maintaining [backwards
compatibility](#backwards-compatibility). Additions to the API for a given package should normally
only be made to the *current stable major version*. The rationale for this policy is that:
* The feature is immediately available to Envoy users who consume the current stable major version.
  This would not be the case if the feature was placed in `vNalpha`.
* `vNalpha` can be mechanically generated from `vN` without requiring developers to maintain the new
  feature in both locations.
* We encourage Envoy users to move to the current stable major version from the previous one to
  consume new functionality.

# Client features

Not all clients will support all fields and features in a given major API version. In general, it is
preferable to use Protobuf semantics to support this, for example:
* Ignoring a field's contents is sufficient to indicate that the support is missing in a client.
* Setting both deprecated and the new method for expressing a field if support for a range of
  clients is desired (where this does not involve huge overhead or gymnastics).

This approach does not always work, for example:
* A route matcher conjunct condition should not be ignored just because the client is missing the
  ability to implement the match; this might result in route policy bypass.
* A client may expect the server to provide a response in a certain format or encoding, for example
  a JSON encoded `Struct`-in-`Any` representation of opaque extension configuration.

For this purpose, we have [client
features](https://www.envoyproxy.io/docs/envoy/latest/api/client_features).

syntax = "proto3";

package envoy.config.transport_socket.tap.v2alpha;

import "envoy/api/v2/core/base.proto";
import "envoy/config/common/tap/v2alpha/common.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.transport_socket.tap.v2alpha";
option java_outer_classname = "TapProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/transport_socket/tap/v2alpha";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.transport_sockets.tap.v3";
option (udpa.annotations.file_status).work_in_progress = true;
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Tap]
// [#extension: envoy.transport_sockets.tap]

// Configuration for tap transport socket. This wraps another transport socket, providing the
// ability to interpose and record in plain text any traffic that is surfaced to Envoy.
message Tap {
  // Common configuration for the tap transport socket.
  common.tap.v2alpha.CommonExtensionConfig common_config = 1
      [(validate.rules).message = {required: true}];

  // The underlying transport socket being wrapped.
  api.v2.core.TransportSocket transport_socket = 2 [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "//envoy/config/common/tap/v2alpha:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.transport_socket.alts.v2alpha;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.transport_socket.alts.v2alpha";
option java_outer_classname = "AltsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/transport_socket/alts/v2alpha";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.transport_sockets.alts.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: ALTS]
// [#extension: envoy.transport_sockets.alts]

// Configuration for ALTS transport socket. This provides Google's ALTS protocol to Envoy.
// https://cloud.google.com/security/encryption-in-transit/application-layer-transport-security/
message Alts {
  // The location of a handshaker service, this is usually 169.254.169.254:8080
  // on GCE.
  string handshaker_service = 1 [(validate.rules).string = {min_bytes: 1}];

  // The acceptable service accounts from peer, peers not in the list will be rejected in the
  // handshake validation step. If empty, no validation will be performed.
  repeated string peer_service_accounts = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.transport_socket.raw_buffer.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.transport_socket.raw_buffer.v2";
option java_outer_classname = "RawBufferProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/transport_socket/raw_buffer/v2;raw_bufferv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.transport_sockets.raw_buffer.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Raw Buffer]
// [#extension: envoy.transport_sockets.raw_buffer]

// Configuration for raw buffer transport socket.
message RawBuffer {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.metrics.v2;

import "envoy/api/v2/core/address.proto";
import "envoy/type/matcher/string.proto";

import "google/protobuf/any.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.metrics.v2";
option java_outer_classname = "StatsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/metrics/v2;metricsv2";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Stats]
// Statistics :ref:`architecture overview <arch_overview_statistics>`.

// Configuration for pluggable stats sinks.
message StatsSink {
  // The name of the stats sink to instantiate. The name must match a supported
  // stats sink. The built-in stats sinks are:
  //
  // * :ref:`envoy.stat_sinks.statsd <envoy_api_msg_config.metrics.v2.StatsdSink>`
  // * :ref:`envoy.stat_sinks.dog_statsd <envoy_api_msg_config.metrics.v2.DogStatsdSink>`
  // * :ref:`envoy.stat_sinks.metrics_service <envoy_api_msg_config.metrics.v2.MetricsServiceConfig>`
  // * :ref:`envoy.stat_sinks.hystrix <envoy_api_msg_config.metrics.v2.HystrixSink>`
  //
  // Sinks optionally support tagged/multiple dimensional metrics.
  string name = 1;

  // Stats sink specific configuration which depends on the sink being instantiated. See
  // :ref:`StatsdSink <envoy_api_msg_config.metrics.v2.StatsdSink>` for an example.
  oneof config_type {
    google.protobuf.Struct config = 2 [deprecated = true];

    google.protobuf.Any typed_config = 3;
  }
}

// Statistics configuration such as tagging.
message StatsConfig {
  // Each stat name is iteratively processed through these tag specifiers.
  // When a tag is matched, the first capture group is removed from the name so
  // later :ref:`TagSpecifiers <envoy_api_msg_config.metrics.v2.TagSpecifier>` cannot match that
  // same portion of the match.
  repeated TagSpecifier stats_tags = 1;

  // Use all default tag regexes specified in Envoy. These can be combined with
  // custom tags specified in :ref:`stats_tags
  // <envoy_api_field_config.metrics.v2.StatsConfig.stats_tags>`. They will be processed before
  // the custom tags.
  //
  // .. note::
  //
  //   If any default tags are specified twice, the config will be considered
  //   invalid.
  //
  // See :repo:`well_known_names.h <source/common/config/well_known_names.h>` for a list of the
  // default tags in Envoy.
  //
  // If not provided, the value is assumed to be true.
  google.protobuf.BoolValue use_all_default_tags = 2;

  // Inclusion/exclusion matcher for stat name creation. If not provided, all stats are instantiated
  // as normal. Preventing the instantiation of certain families of stats can improve memory
  // performance for Envoys running especially large configs.
  //
  // .. warning::
  //   Excluding stats may affect Envoy's behavior in undocumented ways. See
  //   `issue #8771 <https://github.com/envoyproxy/envoy/issues/8771>`_ for more information.
  //   If any unexpected behavior changes are observed, please open a new issue immediately.
  StatsMatcher stats_matcher = 3;
}

// Configuration for disabling stat instantiation.
message StatsMatcher {
  // The instantiation of stats is unrestricted by default. If the goal is to configure Envoy to
  // instantiate all stats, there is no need to construct a StatsMatcher.
  //
  // However, StatsMatcher can be used to limit the creation of families of stats in order to
  // conserve memory. Stats can either be disabled entirely, or they can be
  // limited by either an exclusion or an inclusion list of :ref:`StringMatcher
  // <envoy_api_msg_type.matcher.StringMatcher>` protos:
  //
  // * If ``reject_all`` is set to ``true``, no stats will be instantiated. If ``reject_all`` is set to
  //   ``false``, all stats will be instantiated.
  //
  // * If an exclusion list is supplied, any stat name matching *any* of the StringMatchers in the
  //   list will not instantiate.
  //
  // * If an inclusion list is supplied, no stats will instantiate, except those matching *any* of
  //   the StringMatchers in the list.
  //
  //
  // A StringMatcher can be used to match against an exact string, a suffix / prefix, or a regex.
  // **NB:** For performance reasons, it is highly recommended to use a prefix- or suffix-based
  // matcher rather than a regex-based matcher.
  //
  // Example 1. Excluding all stats.
  //
  // .. code-block:: json
  //
  //   {
  //     "statsMatcher": {
  //       "rejectAll": "true"
  //     }
  //   }
  //
  // Example 2. Excluding all cluster-specific stats, but not cluster-manager stats:
  //
  // .. code-block:: json
  //
  //   {
  //     "statsMatcher": {
  //       "exclusionList": {
  //         "patterns": [
  //           {
  //             "prefix": "cluster."
  //           }
  //         ]
  //       }
  //     }
  //   }
  //
  // Example 3. Including only manager-related stats:
  //
  // .. code-block:: json
  //
  //   {
  //     "statsMatcher": {
  //       "inclusionList": {
  //         "patterns": [
  //           {
  //             "prefix": "cluster_manager."
  //           },
  //           {
  //             "prefix": "listener_manager."
  //           }
  //         ]
  //       }
  //     }
  //   }
  //

  oneof stats_matcher {
    option (validate.required) = true;

    // If `reject_all` is true, then all stats are disabled. If `reject_all` is false, then all
    // stats are enabled.
    bool reject_all = 1;

    // Exclusive match. All stats are enabled except for those matching one of the supplied
    // StringMatcher protos.
    type.matcher.ListStringMatcher exclusion_list = 2;

    // Inclusive match. No stats are enabled except for those matching one of the supplied
    // StringMatcher protos.
    type.matcher.ListStringMatcher inclusion_list = 3;
  }
}

// Designates a tag name and value pair. The value may be either a fixed value
// or a regex providing the value via capture groups. The specified tag will be
// unconditionally set if a fixed value, otherwise it will only be set if one
// or more capture groups in the regex match.
message TagSpecifier {
  // Attaches an identifier to the tag values to identify the tag being in the
  // sink. Envoy has a set of default names and regexes to extract dynamic
  // portions of existing stats, which can be found in :repo:`well_known_names.h
  // <source/common/config/well_known_names.h>` in the Envoy repository. If a :ref:`tag_name
  // <envoy_api_field_config.metrics.v2.TagSpecifier.tag_name>` is provided in the config and
  // neither :ref:`regex <envoy_api_field_config.metrics.v2.TagSpecifier.regex>` or
  // :ref:`fixed_value <envoy_api_field_config.metrics.v2.TagSpecifier.fixed_value>` were specified,
  // Envoy will attempt to find that name in its set of defaults and use the accompanying regex.
  //
  // .. note::
  //
  //   It is invalid to specify the same tag name twice in a config.
  string tag_name = 1;

  oneof tag_value {
    // Designates a tag to strip from the tag extracted name and provide as a named
    // tag value for all statistics. This will only occur if any part of the name
    // matches the regex provided with one or more capture groups.
    //
    // The first capture group identifies the portion of the name to remove. The
    // second capture group (which will normally be nested inside the first) will
    // designate the value of the tag for the statistic. If no second capture
    // group is provided, the first will also be used to set the value of the tag.
    // All other capture groups will be ignored.
    //
    // Example 1. a stat name ``cluster.foo_cluster.upstream_rq_timeout`` and
    // one tag specifier:
    //
    // .. code-block:: json
    //
    //   {
    //     "tag_name": "envoy.cluster_name",
    //     "regex": "^cluster\\.((.+?)\\.)"
    //   }
    //
    // Note that the regex will remove ``foo_cluster.`` making the tag extracted
    // name ``cluster.upstream_rq_timeout`` and the tag value for
    // ``envoy.cluster_name`` will be ``foo_cluster`` (note: there will be no
    // ``.`` character because of the second capture group).
    //
    // Example 2. a stat name
    // ``http.connection_manager_1.user_agent.ios.downstream_cx_total`` and two
    // tag specifiers:
    //
    // .. code-block:: json
    //
    //   [
    //     {
    //       "tag_name": "envoy.http_user_agent",
    //       "regex": "^http(?=\\.).*?\\.user_agent\\.((.+?)\\.)\\w+?$"
    //     },
    //     {
    //       "tag_name": "envoy.http_conn_manager_prefix",
    //       "regex": "^http\\.((.*?)\\.)"
    //     }
    //   ]
    //
    // The two regexes of the specifiers will be processed in the definition order.
    //
    // The first regex will remove ``ios.``, leaving the tag extracted name
    // ``http.connection_manager_1.user_agent.downstream_cx_total``. The tag
    // ``envoy.http_user_agent`` will be added with tag value ``ios``.
    //
    // The second regex will remove ``connection_manager_1.`` from the tag
    // extracted name produced by the first regex
    // ``http.connection_manager_1.user_agent.downstream_cx_total``, leaving
    // ``http.user_agent.downstream_cx_total`` as the tag extracted name. The tag
    // ``envoy.http_conn_manager_prefix`` will be added with the tag value
    // ``connection_manager_1``.
    string regex = 2 [(validate.rules).string = {max_bytes: 1024}];

    // Specifies a fixed tag value for the ``tag_name``.
    string fixed_value = 3;
  }
}

// Stats configuration proto schema for built-in *envoy.stat_sinks.statsd* sink. This sink does not support
// tagged metrics.
// [#extension: envoy.stat_sinks.statsd]
message StatsdSink {
  oneof statsd_specifier {
    option (validate.required) = true;

    // The UDP address of a running `statsd <https://github.com/etsy/statsd>`_
    // compliant listener. If specified, statistics will be flushed to this
    // address.
    api.v2.core.Address address = 1;

    // The name of a cluster that is running a TCP `statsd
    // <https://github.com/etsy/statsd>`_ compliant listener. If specified,
    // Envoy will connect to this cluster to flush statistics.
    string tcp_cluster_name = 2;
  }

  // Optional custom prefix for StatsdSink. If
  // specified, this will override the default prefix.
  // For example:
  //
  // .. code-block:: json
  //
  //   {
  //     "prefix" : "envoy-prod"
  //   }
  //
  // will change emitted stats to
  //
  // .. code-block:: cpp
  //
  //   envoy-prod.test_counter:1|c
  //   envoy-prod.test_timer:5|ms
  //
  // Note that the default prefix, "envoy", will be used if a prefix is not
  // specified.
  //
  // Stats with default prefix:
  //
  // .. code-block:: cpp
  //
  //   envoy.test_counter:1|c
  //   envoy.test_timer:5|ms
  string prefix = 3;
}

// Stats configuration proto schema for built-in *envoy.stat_sinks.dog_statsd* sink.
// The sink emits stats with `DogStatsD <https://docs.datadoghq.com/guides/dogstatsd/>`_
// compatible tags. Tags are configurable via :ref:`StatsConfig
// <envoy_api_msg_config.metrics.v2.StatsConfig>`.
// [#extension: envoy.stat_sinks.dog_statsd]
message DogStatsdSink {
  reserved 2;

  oneof dog_statsd_specifier {
    option (validate.required) = true;

    // The UDP address of a running DogStatsD compliant listener. If specified,
    // statistics will be flushed to this address.
    api.v2.core.Address address = 1;
  }

  // Optional custom metric name prefix. See :ref:`StatsdSink's prefix field
  // <envoy_api_field_config.metrics.v2.StatsdSink.prefix>` for more details.
  string prefix = 3;
}

// Stats configuration proto schema for built-in *envoy.stat_sinks.hystrix* sink.
// The sink emits stats in `text/event-stream
// <https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events>`_
// formatted stream for use by `Hystrix dashboard
// <https://github.com/Netflix-Skunkworks/hystrix-dashboard/wiki>`_.
//
// Note that only a single HystrixSink should be configured.
//
// Streaming is started through an admin endpoint :http:get:`/hystrix_event_stream`.
// [#extension: envoy.stat_sinks.hystrix]
message HystrixSink {
  // The number of buckets the rolling statistical window is divided into.
  //
  // Each time the sink is flushed, all relevant Envoy statistics are sampled and
  // added to the rolling window (removing the oldest samples in the window
  // in the process). The sink then outputs the aggregate statistics across the
  // current rolling window to the event stream(s).
  //
  // rolling_window(ms) = stats_flush_interval(ms) * num_of_buckets
  //
  // More detailed explanation can be found in `Hystrix wiki
  // <https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring#hystrixrollingnumber>`_.
  int64 num_buckets = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "//envoy/type/matcher:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.metrics.v2;

import "envoy/api/v2/core/grpc_service.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.metrics.v2";
option java_outer_classname = "MetricsServiceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/metrics/v2;metricsv2";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Metrics service]

// Metrics Service is configured as a built-in *envoy.stat_sinks.metrics_service* :ref:`StatsSink
// <envoy_api_msg_config.metrics.v2.StatsSink>`. This opaque configuration will be used to create
// Metrics Service.
// [#extension: envoy.stat_sinks.metrics_service]
message MetricsServiceConfig {
  // The upstream gRPC cluster that hosts the metrics service.
  api.v2.core.GrpcService grpc_service = 1 [(validate.rules).message = {required: true}];
}
syntax = "proto3";

package envoy.config.metrics.v3;

import "envoy/config/core/v3/address.proto";
import "envoy/type/matcher/v3/string.proto";

import "google/protobuf/any.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.metrics.v3";
option java_outer_classname = "StatsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3;metricsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Stats]
// Statistics :ref:`architecture overview <arch_overview_statistics>`.

// Configuration for pluggable stats sinks.
message StatsSink {
  option (udpa.annotations.versioning).previous_message_type = "envoy.config.metrics.v2.StatsSink";

  reserved 2;

  reserved "config";

  // The name of the stats sink to instantiate. The name must match a supported
  // stats sink.
  // See the :ref:`extensions listed in typed_config below <extension_category_envoy.stats_sinks>` for the default list of available stats sink.
  // Sinks optionally support tagged/multiple dimensional metrics.
  string name = 1;

  // Stats sink specific configuration which depends on the sink being instantiated. See
  // :ref:`StatsdSink <envoy_v3_api_msg_config.metrics.v3.StatsdSink>` for an example.
  // [#extension-category: envoy.stats_sinks]
  oneof config_type {
    google.protobuf.Any typed_config = 3;
  }
}

// Statistics configuration such as tagging.
message StatsConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.metrics.v2.StatsConfig";

  // Each stat name is independently processed through these tag specifiers. When a tag is
  // matched, the first capture group is not immediately removed from the name, so later
  // :ref:`TagSpecifiers <envoy_v3_api_msg_config.metrics.v3.TagSpecifier>` can also match that
  // same portion of the match. After all tag matching is complete, a tag-extracted version of
  // the name is produced and is used in stats sinks that represent tags, such as Prometheus.
  repeated TagSpecifier stats_tags = 1;

  // Use all default tag regexes specified in Envoy. These can be combined with
  // custom tags specified in :ref:`stats_tags
  // <envoy_v3_api_field_config.metrics.v3.StatsConfig.stats_tags>`. They will be processed before
  // the custom tags.
  //
  // .. note::
  //
  //   If any default tags are specified twice, the config will be considered
  //   invalid.
  //
  // See :repo:`well_known_names.h <source/common/config/well_known_names.h>` for a list of the
  // default tags in Envoy.
  //
  // If not provided, the value is assumed to be true.
  google.protobuf.BoolValue use_all_default_tags = 2;

  // Inclusion/exclusion matcher for stat name creation. If not provided, all stats are instantiated
  // as normal. Preventing the instantiation of certain families of stats can improve memory
  // performance for Envoys running especially large configs.
  //
  // .. warning::
  //   Excluding stats may affect Envoy's behavior in undocumented ways. See
  //   `issue #8771 <https://github.com/envoyproxy/envoy/issues/8771>`_ for more information.
  //   If any unexpected behavior changes are observed, please open a new issue immediately.
  StatsMatcher stats_matcher = 3;

  // Defines rules for setting the histogram buckets. Rules are evaluated in order, and the first
  // match is applied. If no match is found (or if no rules are set), the following default buckets
  // are used:
  //
  //   .. code-block:: json
  //
  //     [
  //       0.5,
  //       1,
  //       5,
  //       10,
  //       25,
  //       50,
  //       100,
  //       250,
  //       500,
  //       1000,
  //       2500,
  //       5000,
  //       10000,
  //       30000,
  //       60000,
  //       300000,
  //       600000,
  //       1800000,
  //       3600000
  //     ]
  repeated HistogramBucketSettings histogram_bucket_settings = 4;
}

// Configuration for disabling stat instantiation.
message StatsMatcher {
  // The instantiation of stats is unrestricted by default. If the goal is to configure Envoy to
  // instantiate all stats, there is no need to construct a StatsMatcher.
  //
  // However, StatsMatcher can be used to limit the creation of families of stats in order to
  // conserve memory. Stats can either be disabled entirely, or they can be
  // limited by either an exclusion or an inclusion list of :ref:`StringMatcher
  // <envoy_v3_api_msg_type.matcher.v3.StringMatcher>` protos:
  //
  // * If ``reject_all`` is set to ``true``, no stats will be instantiated. If ``reject_all`` is set to
  //   ``false``, all stats will be instantiated.
  //
  // * If an exclusion list is supplied, any stat name matching *any* of the StringMatchers in the
  //   list will not instantiate.
  //
  // * If an inclusion list is supplied, no stats will instantiate, except those matching *any* of
  //   the StringMatchers in the list.
  //
  //
  // A StringMatcher can be used to match against an exact string, a suffix / prefix, or a regex.
  // **NB:** For performance reasons, it is highly recommended to use a prefix- or suffix-based
  // matcher rather than a regex-based matcher.
  //
  // Example 1. Excluding all stats.
  //
  // .. code-block:: json
  //
  //   {
  //     "statsMatcher": {
  //       "rejectAll": "true"
  //     }
  //   }
  //
  // Example 2. Excluding all cluster-specific stats, but not cluster-manager stats:
  //
  // .. code-block:: json
  //
  //   {
  //     "statsMatcher": {
  //       "exclusionList": {
  //         "patterns": [
  //           {
  //             "prefix": "cluster."
  //           }
  //         ]
  //       }
  //     }
  //   }
  //
  // Example 3. Including only manager-related stats:
  //
  // .. code-block:: json
  //
  //   {
  //     "statsMatcher": {
  //       "inclusionList": {
  //         "patterns": [
  //           {
  //             "prefix": "cluster_manager."
  //           },
  //           {
  //             "prefix": "listener_manager."
  //           }
  //         ]
  //       }
  //     }
  //   }
  //

  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.metrics.v2.StatsMatcher";

  oneof stats_matcher {
    option (validate.required) = true;

    // If ``reject_all`` is true, then all stats are disabled. If ``reject_all`` is false, then all
    // stats are enabled.
    bool reject_all = 1;

    // Exclusive match. All stats are enabled except for those matching one of the supplied
    // StringMatcher protos.
    type.matcher.v3.ListStringMatcher exclusion_list = 2;

    // Inclusive match. No stats are enabled except for those matching one of the supplied
    // StringMatcher protos.
    type.matcher.v3.ListStringMatcher inclusion_list = 3;
  }
}

// Designates a tag name and value pair. The value may be either a fixed value
// or a regex providing the value via capture groups. The specified tag will be
// unconditionally set if a fixed value, otherwise it will only be set if one
// or more capture groups in the regex match.
message TagSpecifier {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.metrics.v2.TagSpecifier";

  // Attaches an identifier to the tag values to identify the tag being in the
  // sink. Envoy has a set of default names and regexes to extract dynamic
  // portions of existing stats, which can be found in :repo:`well_known_names.h
  // <source/common/config/well_known_names.h>` in the Envoy repository. If a :ref:`tag_name
  // <envoy_v3_api_field_config.metrics.v3.TagSpecifier.tag_name>` is provided in the config and
  // neither :ref:`regex <envoy_v3_api_field_config.metrics.v3.TagSpecifier.regex>` or
  // :ref:`fixed_value <envoy_v3_api_field_config.metrics.v3.TagSpecifier.fixed_value>` were specified,
  // Envoy will attempt to find that name in its set of defaults and use the accompanying regex.
  //
  // .. note::
  //
  //   A stat name may be spelled in such a way that it matches two different
  //   tag extractors for the same tag name. In that case, all but one of the
  //   tag values will be dropped. It is not specified which tag value will be
  //   retained. The extraction will only occur for one of the extractors, and
  //   only the matched extraction will be removed from the tag name.
  string tag_name = 1;

  oneof tag_value {
    // Designates a tag to strip from the tag extracted name and provide as a named
    // tag value for all statistics. This will only occur if any part of the name
    // matches the regex provided with one or more capture groups.
    //
    // The first capture group identifies the portion of the name to remove. The
    // second capture group (which will normally be nested inside the first) will
    // designate the value of the tag for the statistic. If no second capture
    // group is provided, the first will also be used to set the value of the tag.
    // All other capture groups will be ignored.
    //
    // Example 1. a stat name ``cluster.foo_cluster.upstream_rq_timeout`` and
    // one tag specifier:
    //
    // .. code-block:: json
    //
    //   {
    //     "tag_name": "envoy.cluster_name",
    //     "regex": "^cluster\\.((.+?)\\.)"
    //   }
    //
    // Note that the regex will remove ``foo_cluster.`` making the tag extracted
    // name ``cluster.upstream_rq_timeout`` and the tag value for
    // ``envoy.cluster_name`` will be ``foo_cluster`` (note: there will be no
    // ``.`` character because of the second capture group).
    //
    // Example 2. a stat name
    // ``http.connection_manager_1.user_agent.ios.downstream_cx_total`` and two
    // tag specifiers:
    //
    // .. code-block:: json
    //
    //   [
    //     {
    //       "tag_name": "envoy.http_user_agent",
    //       "regex": "^http(?=\\.).*?\\.user_agent\\.((.+?)\\.)\\w+?$"
    //     },
    //     {
    //       "tag_name": "envoy.http_conn_manager_prefix",
    //       "regex": "^http\\.((.*?)\\.)"
    //     }
    //   ]
    //
    // The two regexes of the specifiers will be processed from the elaborated
    // stat name.
    //
    // The first regex will save ``ios.`` as the tag value for ``envoy.http_user_agent``. It will
    // leave it in the name for potential matching with additional tag specifiers. After all tag
    // specifiers are processed the tags will be removed from the name.
    //
    // The second regex will populate tag ``envoy.http_conn_manager_prefix`` with value
    // ``connection_manager_1.``, based on the original stat name.
    //
    // As a final step, the matched tags are removed, leaving
    // ``http.user_agent.downstream_cx_total`` as the tag extracted name.
    string regex = 2 [(validate.rules).string = {max_bytes: 1024}];

    // Specifies a fixed tag value for the ``tag_name``.
    string fixed_value = 3;
  }
}

// Specifies a matcher for stats and the buckets that matching stats should use.
message HistogramBucketSettings {
  // The stats that this rule applies to. The match is applied to the original stat name
  // before tag-extraction, for example ``cluster.exampleclustername.upstream_cx_length_ms``.
  type.matcher.v3.StringMatcher match = 1 [(validate.rules).message = {required: true}];

  // Each value is the upper bound of a bucket. Each bucket must be greater than 0 and unique.
  // The order of the buckets does not matter.
  repeated double buckets = 2 [(validate.rules).repeated = {
    min_items: 1
    unique: true
    items {double {gt: 0.0}}
  }];
}

// Stats configuration proto schema for built-in ``envoy.stat_sinks.statsd`` sink. This sink does not support
// tagged metrics.
// [#extension: envoy.stat_sinks.statsd]
message StatsdSink {
  option (udpa.annotations.versioning).previous_message_type = "envoy.config.metrics.v2.StatsdSink";

  oneof statsd_specifier {
    option (validate.required) = true;

    // The UDP address of a running `statsd <https://github.com/etsy/statsd>`_
    // compliant listener. If specified, statistics will be flushed to this
    // address.
    core.v3.Address address = 1;

    // The name of a cluster that is running a TCP `statsd
    // <https://github.com/etsy/statsd>`_ compliant listener. If specified,
    // Envoy will connect to this cluster to flush statistics.
    string tcp_cluster_name = 2;
  }

  // Optional custom prefix for StatsdSink. If
  // specified, this will override the default prefix.
  // For example:
  //
  // .. code-block:: json
  //
  //   {
  //     "prefix" : "envoy-prod"
  //   }
  //
  // will change emitted stats to
  //
  // .. code-block:: cpp
  //
  //   envoy-prod.test_counter:1|c
  //   envoy-prod.test_timer:5|ms
  //
  // Note that the default prefix, "envoy", will be used if a prefix is not
  // specified.
  //
  // Stats with default prefix:
  //
  // .. code-block:: cpp
  //
  //   envoy.test_counter:1|c
  //   envoy.test_timer:5|ms
  string prefix = 3;
}

// Stats configuration proto schema for built-in ``envoy.stat_sinks.dog_statsd`` sink.
// The sink emits stats with `DogStatsD <https://docs.datadoghq.com/guides/dogstatsd/>`_
// compatible tags. Tags are configurable via :ref:`StatsConfig
// <envoy_v3_api_msg_config.metrics.v3.StatsConfig>`.
// [#extension: envoy.stat_sinks.dog_statsd]
message DogStatsdSink {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.metrics.v2.DogStatsdSink";

  reserved 2;

  oneof dog_statsd_specifier {
    option (validate.required) = true;

    // The UDP address of a running DogStatsD compliant listener. If specified,
    // statistics will be flushed to this address.
    core.v3.Address address = 1;
  }

  // Optional custom metric name prefix. See :ref:`StatsdSink's prefix field
  // <envoy_v3_api_field_config.metrics.v3.StatsdSink.prefix>` for more details.
  string prefix = 3;

  // Optional max datagram size to use when sending UDP messages. By default Envoy
  // will emit one metric per datagram. By specifying a max-size larger than a single
  // metric, Envoy will emit multiple, new-line separated metrics. The max datagram
  // size should not exceed your network's MTU.
  //
  // Note that this value may not be respected if smaller than a single metric.
  google.protobuf.UInt64Value max_bytes_per_datagram = 4 [(validate.rules).uint64 = {gt: 0}];
}

// Stats configuration proto schema for built-in ``envoy.stat_sinks.hystrix`` sink.
// The sink emits stats in `text/event-stream
// <https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events>`_
// formatted stream for use by `Hystrix dashboard
// <https://github.com/Netflix-Skunkworks/hystrix-dashboard/wiki>`_.
//
// Note that only a single HystrixSink should be configured.
//
// Streaming is started through an admin endpoint :http:get:`/hystrix_event_stream`.
// [#extension: envoy.stat_sinks.hystrix]
message HystrixSink {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.metrics.v2.HystrixSink";

  // The number of buckets the rolling statistical window is divided into.
  //
  // Each time the sink is flushed, all relevant Envoy statistics are sampled and
  // added to the rolling window (removing the oldest samples in the window
  // in the process). The sink then outputs the aggregate statistics across the
  // current rolling window to the event stream(s).
  //
  // ``rolling_window(ms)`` = ``stats_flush_interval(ms)`` * ``num_of_buckets``
  //
  // More detailed explanation can be found in `Hystrix wiki
  // <https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring#hystrixrollingnumber>`_.
  int64 num_buckets = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.metrics.v3;

import "envoy/config/core/v3/config_source.proto";
import "envoy/config/core/v3/grpc_service.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.metrics.v3";
option java_outer_classname = "MetricsServiceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3;metricsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Metrics service]

// HistogramEmitMode is used to configure which metric types should be emitted for histograms.
enum HistogramEmitMode {
  // Emit Histogram and Summary metric types.
  SUMMARY_AND_HISTOGRAM = 0;

  // Emit only Summary metric types.
  SUMMARY = 1;

  // Emit only Histogram metric types.
  HISTOGRAM = 2;
}

// Metrics Service is configured as a built-in ``envoy.stat_sinks.metrics_service`` :ref:`StatsSink
// <envoy_v3_api_msg_config.metrics.v3.StatsSink>`. This opaque configuration will be used to create
// Metrics Service.
//
// Example:
//
// .. code-block:: yaml
//
//     stats_sinks:
//       - name: envoy.stat_sinks.metrics_service
//         typed_config:
//           "@type": type.googleapis.com/envoy.config.metrics.v3.MetricsServiceConfig
//           transport_api_version: V3
//
// [#extension: envoy.stat_sinks.metrics_service]
// [#next-free-field: 6]
message MetricsServiceConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.metrics.v2.MetricsServiceConfig";

  // The upstream gRPC cluster that hosts the metrics service.
  core.v3.GrpcService grpc_service = 1 [(validate.rules).message = {required: true}];

  // API version for metric service transport protocol. This describes the metric service gRPC
  // endpoint and version of messages used on the wire.
  core.v3.ApiVersion transport_api_version = 3 [(validate.rules).enum = {defined_only: true}];

  // If true, counters are reported as the delta between flushing intervals. Otherwise, the current
  // counter value is reported. Defaults to false.
  // Eventually (https://github.com/envoyproxy/envoy/issues/10968) if this value is not set, the
  // sink will take updates from the :ref:`MetricsResponse <envoy_v3_api_msg_service.metrics.v3.StreamMetricsResponse>`.
  google.protobuf.BoolValue report_counters_as_deltas = 2;

  // If true, metrics will have their tags emitted as labels on the metrics objects sent to the MetricsService,
  // and the tag extracted name will be used instead of the full name, which may contain values used by the tag
  // extractor or additional tags added during stats creation.
  bool emit_tags_as_labels = 4;

  // Specify which metrics types to emit for histograms. Defaults to SUMMARY_AND_HISTOGRAM.
  HistogramEmitMode histogram_emit_mode = 5 [(validate.rules).enum = {defined_only: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "//envoy/api/v2/route:pkg",
        "//envoy/type/matcher:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_google_googleapis//google/api/expr/v1alpha1:syntax_proto",
    ],
)
syntax = "proto3";

package envoy.config.rbac.v2;

import "envoy/api/v2/core/address.proto";
import "envoy/api/v2/route/route_components.proto";
import "envoy/type/matcher/metadata.proto";
import "envoy/type/matcher/path.proto";
import "envoy/type/matcher/string.proto";

import "google/api/expr/v1alpha1/syntax.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.rbac.v2";
option java_outer_classname = "RbacProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/rbac/v2;rbacv2";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Role Based Access Control (RBAC)]

// Role Based Access Control (RBAC) provides service-level and method-level access control for a
// service. RBAC policies are additive. The policies are examined in order. A request is allowed
// once a matching policy is found (suppose the `action` is ALLOW).
//
// Here is an example of RBAC configuration. It has two policies:
//
// * Service account "cluster.local/ns/default/sa/admin" has full access to the service, and so
//   does "cluster.local/ns/default/sa/superuser".
//
// * Any user can read ("GET") the service at paths with prefix "/products", so long as the
//   destination port is either 80 or 443.
//
//  .. code-block:: yaml
//
//   action: ALLOW
//   policies:
//     "service-admin":
//       permissions:
//         - any: true
//       principals:
//         - authenticated:
//             principal_name:
//               exact: "cluster.local/ns/default/sa/admin"
//         - authenticated:
//             principal_name:
//               exact: "cluster.local/ns/default/sa/superuser"
//     "product-viewer":
//       permissions:
//           - and_rules:
//               rules:
//                 - header: { name: ":method", exact_match: "GET" }
//                 - url_path:
//                     path: { prefix: "/products" }
//                 - or_rules:
//                     rules:
//                       - destination_port: 80
//                       - destination_port: 443
//       principals:
//         - any: true
//
message RBAC {
  // Should we do safe-list or block-list style access control?
  enum Action {
    // The policies grant access to principals. The rest is denied. This is safe-list style
    // access control. This is the default type.
    ALLOW = 0;

    // The policies deny access to principals. The rest is allowed. This is block-list style
    // access control.
    DENY = 1;
  }

  // The action to take if a policy matches. The request is allowed if and only if:
  //
  //   * `action` is "ALLOWED" and at least one policy matches
  //   * `action` is "DENY" and none of the policies match
  Action action = 1;

  // Maps from policy name to policy. A match occurs when at least one policy matches the request.
  map<string, Policy> policies = 2;
}

// Policy specifies a role and the principals that are assigned/denied the role. A policy matches if
// and only if at least one of its permissions match the action taking place AND at least one of its
// principals match the downstream AND the condition is true if specified.
message Policy {
  // Required. The set of permissions that define a role. Each permission is matched with OR
  // semantics. To match all actions for this policy, a single Permission with the `any` field set
  // to true should be used.
  repeated Permission permissions = 1 [(validate.rules).repeated = {min_items: 1}];

  // Required. The set of principals that are assigned/denied the role based on action. Each
  // principal is matched with OR semantics. To match all downstreams for this policy, a single
  // Principal with the `any` field set to true should be used.
  repeated Principal principals = 2 [(validate.rules).repeated = {min_items: 1}];

  // An optional symbolic expression specifying an access control
  // :ref:`condition <arch_overview_condition>`. The condition is combined
  // with the permissions and the principals as a clause with AND semantics.
  google.api.expr.v1alpha1.Expr condition = 3;
}

// Permission defines an action (or actions) that a principal can take.
// [#next-free-field: 11]
message Permission {
  // Used in the `and_rules` and `or_rules` fields in the `rule` oneof. Depending on the context,
  // each are applied with the associated behavior.
  message Set {
    repeated Permission rules = 1 [(validate.rules).repeated = {min_items: 1}];
  }

  oneof rule {
    option (validate.required) = true;

    // A set of rules that all must match in order to define the action.
    Set and_rules = 1;

    // A set of rules where at least one must match in order to define the action.
    Set or_rules = 2;

    // When any is set, it matches any action.
    bool any = 3 [(validate.rules).bool = {const: true}];

    // A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
    // available for HTTP request.
    // Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
    // field if you want to match the URL path without the query and fragment string.
    api.v2.route.HeaderMatcher header = 4;

    // A URL path on the incoming HTTP request. Only available for HTTP.
    type.matcher.PathMatcher url_path = 10;

    // A CIDR block that describes the destination IP.
    api.v2.core.CidrRange destination_ip = 5;

    // A port number that describes the destination port connecting to.
    uint32 destination_port = 6 [(validate.rules).uint32 = {lte: 65535}];

    // Metadata that describes additional information about the action.
    type.matcher.MetadataMatcher metadata = 7;

    // Negates matching the provided permission. For instance, if the value of `not_rule` would
    // match, this permission would not match. Conversely, if the value of `not_rule` would not
    // match, this permission would match.
    Permission not_rule = 8;

    // The request server from the client's connection request. This is
    // typically TLS SNI.
    //
    // .. attention::
    //
    //   The behavior of this field may be affected by how Envoy is configured
    //   as explained below.
    //
    //   * If the :ref:`TLS Inspector <config_listener_filters_tls_inspector>`
    //     filter is not added, and if a `FilterChainMatch` is not defined for
    //     the :ref:`server name <envoy_api_field_listener.FilterChainMatch.server_names>`,
    //     a TLS connection's requested SNI server name will be treated as if it
    //     wasn't present.
    //
    //   * A :ref:`listener filter <arch_overview_listener_filters>` may
    //     overwrite a connection's requested server name within Envoy.
    //
    // Please refer to :ref:`this FAQ entry <faq_how_to_setup_sni>` to learn to
    // setup SNI.
    type.matcher.StringMatcher requested_server_name = 9;
  }
}

// Principal defines an identity or a group of identities for a downstream subject.
// [#next-free-field: 12]
message Principal {
  // Used in the `and_ids` and `or_ids` fields in the `identifier` oneof. Depending on the context,
  // each are applied with the associated behavior.
  message Set {
    repeated Principal ids = 1 [(validate.rules).repeated = {min_items: 1}];
  }

  // Authentication attributes for a downstream.
  message Authenticated {
    reserved 1;

    // The name of the principal. If set, The URI SAN or DNS SAN in that order is used from the
    // certificate, otherwise the subject field is used. If unset, it applies to any user that is
    // authenticated.
    type.matcher.StringMatcher principal_name = 2;
  }

  oneof identifier {
    option (validate.required) = true;

    // A set of identifiers that all must match in order to define the downstream.
    Set and_ids = 1;

    // A set of identifiers at least one must match in order to define the downstream.
    Set or_ids = 2;

    // When any is set, it matches any downstream.
    bool any = 3 [(validate.rules).bool = {const: true}];

    // Authenticated attributes that identify the downstream.
    Authenticated authenticated = 4;

    // A CIDR block that describes the downstream IP.
    // This address will honor proxy protocol, but will not honor XFF.
    api.v2.core.CidrRange source_ip = 5 [deprecated = true];

    // A CIDR block that describes the downstream remote/origin address.
    // Note: This is always the physical peer even if the
    // :ref:`remote_ip <envoy_api_field_config.rbac.v2.Principal.remote_ip>` is inferred
    // from for example the x-forwarder-for header, proxy protocol, etc.
    api.v2.core.CidrRange direct_remote_ip = 10;

    // A CIDR block that describes the downstream remote/origin address.
    // Note: This may not be the physical peer and could be different from the
    // :ref:`direct_remote_ip <envoy_api_field_config.rbac.v2.Principal.direct_remote_ip>`.
    // E.g, if the remote ip is inferred from for example the x-forwarder-for header,
    // proxy protocol, etc.
    api.v2.core.CidrRange remote_ip = 11;

    // A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
    // available for HTTP request.
    // Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
    // field if you want to match the URL path without the query and fragment string.
    api.v2.route.HeaderMatcher header = 6;

    // A URL path on the incoming HTTP request. Only available for HTTP.
    type.matcher.PathMatcher url_path = 9;

    // Metadata that describes additional information about the principal.
    type.matcher.MetadataMatcher metadata = 7;

    // Negates matching the provided principal. For instance, if the value of `not_id` would match,
    // this principal would not match. Conversely, if the value of `not_id` would not match, this
    // principal would match.
    Principal not_id = 8;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/config/route/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_google_googleapis//google/api/expr/v1alpha1:checked_proto",
        "@com_google_googleapis//google/api/expr/v1alpha1:syntax_proto",
    ],
)
syntax = "proto3";

package envoy.config.rbac.v3;

import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/route/v3/route_components.proto";
import "envoy/type/matcher/v3/filter_state.proto";
import "envoy/type/matcher/v3/metadata.proto";
import "envoy/type/matcher/v3/path.proto";
import "envoy/type/matcher/v3/string.proto";
import "envoy/type/v3/range.proto";

import "google/api/expr/v1alpha1/checked.proto";
import "google/api/expr/v1alpha1/syntax.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.rbac.v3";
option java_outer_classname = "RbacProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/rbac/v3;rbacv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Role Based Access Control (RBAC)]

// Role Based Access Control (RBAC) provides service-level and method-level access control for a
// service. Requests are allowed or denied based on the ``action`` and whether a matching policy is
// found. For instance, if the action is ALLOW and a matching policy is found the request should be
// allowed.
//
// RBAC can also be used to make access logging decisions by communicating with access loggers
// through dynamic metadata. When the action is LOG and at least one policy matches, the
// ``access_log_hint`` value in the shared key namespace 'envoy.common' is set to ``true`` indicating
// the request should be logged.
//
// Here is an example of RBAC configuration. It has two policies:
//
// * Service account ``cluster.local/ns/default/sa/admin`` has full access to the service, and so
//   does "cluster.local/ns/default/sa/superuser".
//
// * Any user can read (``GET``) the service at paths with prefix ``/products``, so long as the
//   destination port is either 80 or 443.
//
//  .. code-block:: yaml
//
//   action: ALLOW
//   policies:
//     "service-admin":
//       permissions:
//         - any: true
//       principals:
//         - authenticated:
//             principal_name:
//               exact: "cluster.local/ns/default/sa/admin"
//         - authenticated:
//             principal_name:
//               exact: "cluster.local/ns/default/sa/superuser"
//     "product-viewer":
//       permissions:
//           - and_rules:
//               rules:
//                 - header:
//                     name: ":method"
//                     string_match:
//                       exact: "GET"
//                 - url_path:
//                     path: { prefix: "/products" }
//                 - or_rules:
//                     rules:
//                       - destination_port: 80
//                       - destination_port: 443
//       principals:
//         - any: true
//
message RBAC {
  option (udpa.annotations.versioning).previous_message_type = "envoy.config.rbac.v2.RBAC";

  // Should we do safe-list or block-list style access control?
  enum Action {
    // The policies grant access to principals. The rest are denied. This is safe-list style
    // access control. This is the default type.
    ALLOW = 0;

    // The policies deny access to principals. The rest are allowed. This is block-list style
    // access control.
    DENY = 1;

    // The policies set the ``access_log_hint`` dynamic metadata key based on if requests match.
    // All requests are allowed.
    LOG = 2;
  }

  message AuditLoggingOptions {
    // Deny and allow here refer to RBAC decisions, not actions.
    enum AuditCondition {
      // Never audit.
      NONE = 0;

      // Audit when RBAC denies the request.
      ON_DENY = 1;

      // Audit when RBAC allows the request.
      ON_ALLOW = 2;

      // Audit whether RBAC allows or denies the request.
      ON_DENY_AND_ALLOW = 3;
    }

    // [#not-implemented-hide:]
    message AuditLoggerConfig {
      // Typed logger configuration.
      //
      // [#extension-category: envoy.rbac.audit_loggers]
      core.v3.TypedExtensionConfig audit_logger = 1;

      // If true, when the logger is not supported, the data plane will not NACK but simply ignore it.
      bool is_optional = 2;
    }

    // Condition for the audit logging to happen.
    // If this condition is met, all the audit loggers configured here will be invoked.
    //
    // [#not-implemented-hide:]
    AuditCondition audit_condition = 1 [(validate.rules).enum = {defined_only: true}];

    // Configurations for RBAC-based authorization audit loggers.
    //
    // [#not-implemented-hide:]
    repeated AuditLoggerConfig logger_configs = 2;
  }

  // The action to take if a policy matches. Every action either allows or denies a request,
  // and can also carry out action-specific operations.
  //
  // Actions:
  //
  //  * ``ALLOW``: Allows the request if and only if there is a policy that matches
  //    the request.
  //  * ``DENY``: Allows the request if and only if there are no policies that
  //    match the request.
  //  * ``LOG``: Allows all requests. If at least one policy matches, the dynamic
  //    metadata key ``access_log_hint`` is set to the value ``true`` under the shared
  //    key namespace ``envoy.common``. If no policies match, it is set to ``false``.
  //    Other actions do not modify this key.
  //
  Action action = 1 [(validate.rules).enum = {defined_only: true}];

  // Maps from policy name to policy. A match occurs when at least one policy matches the request.
  // The policies are evaluated in lexicographic order of the policy name.
  map<string, Policy> policies = 2;

  // Audit logging options that include the condition for audit logging to happen
  // and audit logger configurations.
  //
  // [#not-implemented-hide:]
  AuditLoggingOptions audit_logging_options = 3;
}

// Policy specifies a role and the principals that are assigned/denied the role.
// A policy matches if and only if at least one of its permissions match the
// action taking place AND at least one of its principals match the downstream
// AND the condition is true if specified.
message Policy {
  option (udpa.annotations.versioning).previous_message_type = "envoy.config.rbac.v2.Policy";

  // Required. The set of permissions that define a role. Each permission is
  // matched with OR semantics. To match all actions for this policy, a single
  // Permission with the ``any`` field set to true should be used.
  repeated Permission permissions = 1 [(validate.rules).repeated = {min_items: 1}];

  // Required. The set of principals that are assigned/denied the role based on
  // action. Each principal is matched with OR semantics. To match all
  // downstreams for this policy, a single Principal with the ``any`` field set to
  // true should be used.
  repeated Principal principals = 2 [(validate.rules).repeated = {min_items: 1}];

  // An optional symbolic expression specifying an access control
  // :ref:`condition <arch_overview_condition>`. The condition is combined
  // with the permissions and the principals as a clause with AND semantics.
  // Only be used when checked_condition is not used.
  google.api.expr.v1alpha1.Expr condition = 3
      [(udpa.annotations.field_migrate).oneof_promotion = "expression_specifier"];

  // [#not-implemented-hide:]
  // An optional symbolic expression that has been successfully type checked.
  // Only be used when condition is not used.
  google.api.expr.v1alpha1.CheckedExpr checked_condition = 4
      [(udpa.annotations.field_migrate).oneof_promotion = "expression_specifier"];
}

// Permission defines an action (or actions) that a principal can take.
// [#next-free-field: 13]
message Permission {
  option (udpa.annotations.versioning).previous_message_type = "envoy.config.rbac.v2.Permission";

  // Used in the ``and_rules`` and ``or_rules`` fields in the ``rule`` oneof. Depending on the context,
  // each are applied with the associated behavior.
  message Set {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.rbac.v2.Permission.Set";

    repeated Permission rules = 1 [(validate.rules).repeated = {min_items: 1}];
  }

  oneof rule {
    option (validate.required) = true;

    // A set of rules that all must match in order to define the action.
    Set and_rules = 1;

    // A set of rules where at least one must match in order to define the action.
    Set or_rules = 2;

    // When any is set, it matches any action.
    bool any = 3 [(validate.rules).bool = {const: true}];

    // A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
    // available for HTTP request.
    // Note: the pseudo-header :path includes the query and fragment string. Use the ``url_path``
    // field if you want to match the URL path without the query and fragment string.
    route.v3.HeaderMatcher header = 4;

    // A URL path on the incoming HTTP request. Only available for HTTP.
    type.matcher.v3.PathMatcher url_path = 10;

    // A CIDR block that describes the destination IP.
    core.v3.CidrRange destination_ip = 5;

    // A port number that describes the destination port connecting to.
    uint32 destination_port = 6 [(validate.rules).uint32 = {lte: 65535}];

    // A port number range that describes a range of destination ports connecting to.
    type.v3.Int32Range destination_port_range = 11;

    // Metadata that describes additional information about the action.
    type.matcher.v3.MetadataMatcher metadata = 7;

    // Negates matching the provided permission. For instance, if the value of
    // ``not_rule`` would match, this permission would not match. Conversely, if
    // the value of ``not_rule`` would not match, this permission would match.
    Permission not_rule = 8;

    // The request server from the client's connection request. This is
    // typically TLS SNI.
    //
    // .. attention::
    //
    //   The behavior of this field may be affected by how Envoy is configured
    //   as explained below.
    //
    //   * If the :ref:`TLS Inspector <config_listener_filters_tls_inspector>`
    //     filter is not added, and if a ``FilterChainMatch`` is not defined for
    //     the :ref:`server name
    //     <envoy_v3_api_field_config.listener.v3.FilterChainMatch.server_names>`,
    //     a TLS connection's requested SNI server name will be treated as if it
    //     wasn't present.
    //
    //   * A :ref:`listener filter <arch_overview_listener_filters>` may
    //     overwrite a connection's requested server name within Envoy.
    //
    // Please refer to :ref:`this FAQ entry <faq_how_to_setup_sni>` to learn to
    // setup SNI.
    type.matcher.v3.StringMatcher requested_server_name = 9;

    // Extension for configuring custom matchers for RBAC.
    // [#extension-category: envoy.rbac.matchers]
    core.v3.TypedExtensionConfig matcher = 12;
  }
}

// Principal defines an identity or a group of identities for a downstream
// subject.
// [#next-free-field: 13]
message Principal {
  option (udpa.annotations.versioning).previous_message_type = "envoy.config.rbac.v2.Principal";

  // Used in the ``and_ids`` and ``or_ids`` fields in the ``identifier`` oneof.
  // Depending on the context, each are applied with the associated behavior.
  message Set {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.rbac.v2.Principal.Set";

    repeated Principal ids = 1 [(validate.rules).repeated = {min_items: 1}];
  }

  // Authentication attributes for a downstream.
  message Authenticated {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.rbac.v2.Principal.Authenticated";

    reserved 1;

    // The name of the principal. If set, The URI SAN or DNS SAN in that order
    // is used from the certificate, otherwise the subject field is used. If
    // unset, it applies to any user that is authenticated.
    type.matcher.v3.StringMatcher principal_name = 2;
  }

  oneof identifier {
    option (validate.required) = true;

    // A set of identifiers that all must match in order to define the
    // downstream.
    Set and_ids = 1;

    // A set of identifiers at least one must match in order to define the
    // downstream.
    Set or_ids = 2;

    // When any is set, it matches any downstream.
    bool any = 3 [(validate.rules).bool = {const: true}];

    // Authenticated attributes that identify the downstream.
    Authenticated authenticated = 4;

    // A CIDR block that describes the downstream IP.
    // This address will honor proxy protocol, but will not honor XFF.
    //
    // This field is deprecated; either use :ref:`remote_ip
    // <envoy_v3_api_field_config.rbac.v3.Principal.remote_ip>` for the same
    // behavior, or use
    // :ref:`direct_remote_ip <envoy_v3_api_field_config.rbac.v3.Principal.direct_remote_ip>`.
    core.v3.CidrRange source_ip = 5
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

    // A CIDR block that describes the downstream remote/origin address.
    // Note: This is always the physical peer even if the
    // :ref:`remote_ip <envoy_v3_api_field_config.rbac.v3.Principal.remote_ip>` is
    // inferred from for example the x-forwarder-for header, proxy protocol,
    // etc.
    core.v3.CidrRange direct_remote_ip = 10;

    // A CIDR block that describes the downstream remote/origin address.
    // Note: This may not be the physical peer and could be different from the
    // :ref:`direct_remote_ip
    // <envoy_v3_api_field_config.rbac.v3.Principal.direct_remote_ip>`. E.g, if the
    // remote ip is inferred from for example the x-forwarder-for header, proxy
    // protocol, etc.
    core.v3.CidrRange remote_ip = 11;

    // A header (or pseudo-header such as :path or :method) on the incoming HTTP
    // request. Only available for HTTP request. Note: the pseudo-header :path
    // includes the query and fragment string. Use the ``url_path`` field if you
    // want to match the URL path without the query and fragment string.
    route.v3.HeaderMatcher header = 6;

    // A URL path on the incoming HTTP request. Only available for HTTP.
    type.matcher.v3.PathMatcher url_path = 9;

    // Metadata that describes additional information about the principal.
    type.matcher.v3.MetadataMatcher metadata = 7;

    // Identifies the principal using a filter state object.
    type.matcher.v3.FilterStateMatcher filter_state = 12;

    // Negates matching the provided principal. For instance, if the value of
    // ``not_id`` would match, this principal would not match. Conversely, if the
    // value of ``not_id`` would not match, this principal would match.
    Principal not_id = 8;
  }
}

// Action defines the result of allowance or denial when a request matches the matcher.
message Action {
  // The name indicates the policy name.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // The action to take if the matcher matches. Every action either allows or denies a request,
  // and can also carry out action-specific operations.
  //
  // Actions:
  //
  //  * ``ALLOW``: If the request gets matched on ALLOW, it is permitted.
  //  * ``DENY``: If the request gets matched on DENY, it is not permitted.
  //  * ``LOG``: If the request gets matched on LOG, it is permitted. Besides, the
  //    dynamic metadata key ``access_log_hint`` under the shared key namespace
  //    ``envoy.common`` will be set to the value ``true``.
  //  * If the request cannot get matched, it will fallback to ``DENY``.
  //
  // Log behavior:
  //
  //  If the RBAC matcher contains at least one LOG action, the dynamic
  //  metadata key ``access_log_hint`` will be set based on if the request
  //  get matched on the LOG action.
  //
  RBAC.Action action = 2;
}
syntax = "proto3";

package envoy.config.cluster.dynamic_forward_proxy.v2alpha;

import "envoy/config/common/dynamic_forward_proxy/v2alpha/dns_cache.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.cluster.dynamic_forward_proxy.v2alpha";
option java_outer_classname = "ClusterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/cluster/dynamic_forward_proxy/v2alpha";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.clusters.dynamic_forward_proxy.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Dynamic forward proxy cluster configuration]

// Configuration for the dynamic forward proxy cluster. See the :ref:`architecture overview
// <arch_overview_http_dynamic_forward_proxy>` for more information.
// [#extension: envoy.clusters.dynamic_forward_proxy]
message ClusterConfig {
  // The DNS cache configuration that the cluster will attach to. Note this configuration must
  // match that of associated :ref:`dynamic forward proxy HTTP filter configuration
  // <envoy_api_field_config.filter.http.dynamic_forward_proxy.v2alpha.FilterConfig.dns_cache_config>`.
  common.dynamic_forward_proxy.v2alpha.DnsCacheConfig dns_cache_config = 1
      [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/common/dynamic_forward_proxy/v2alpha:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.cluster.redis;

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.cluster.redis";
option java_outer_classname = "RedisClusterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/cluster/redis";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Redis Cluster Configuration]
// This cluster adds support for `Redis Cluster <https://redis.io/topics/cluster-spec>`_, as part
// of :ref:`Envoy's support for Redis Cluster <arch_overview_redis>`.
//
// Redis Cluster is an extension of Redis which supports sharding and high availability (where a
// shard that loses its primary fails over to a replica, and designates it as the new primary).
// However, as there is no unified frontend or proxy service in front of Redis Cluster, the client
// (in this case Envoy) must locally maintain the state of the Redis Cluster, specifically the
// topology. A random node in the cluster is queried for the topology using the `CLUSTER SLOTS
// command <https://redis.io/commands/cluster-slots>`_. This result is then stored locally, and
// updated at user-configured intervals.
//
// Additionally, if
// :ref:`enable_redirection<envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.enable_redirection>`
// is true, then moved and ask redirection errors from upstream servers will trigger a topology
// refresh when they exceed a user-configured error threshold.
//
// Example:
//
// .. code-block:: yaml
//
//     name: name
//     connect_timeout: 0.25s
//     dns_lookup_family: V4_ONLY
//     hosts:
//     - socket_address:
//       address: foo.bar.com
//       port_value: 22120
//     cluster_type:
//     name: envoy.clusters.redis
//     typed_config:
//       "@type": type.googleapis.com/google.protobuf.Struct
//       value:
//         cluster_refresh_rate: 30s
//         cluster_refresh_timeout: 0.5s
//         redirect_refresh_interval: 10s
//         redirect_refresh_threshold: 10
// [#extension: envoy.clusters.redis]

// [#next-free-field: 7]
message RedisClusterConfig {
  // Interval between successive topology refresh requests. If not set, this defaults to 5s.
  google.protobuf.Duration cluster_refresh_rate = 1 [(validate.rules).duration = {gt {}}];

  // Timeout for topology refresh request. If not set, this defaults to 3s.
  google.protobuf.Duration cluster_refresh_timeout = 2 [(validate.rules).duration = {gt {}}];

  // The minimum interval that must pass after triggering a topology refresh request before a new
  // request can possibly be triggered again. Any errors received during one of these
  // time intervals are ignored. If not set, this defaults to 5s.
  google.protobuf.Duration redirect_refresh_interval = 3;

  // The number of redirection errors that must be received before
  // triggering a topology refresh request. If not set, this defaults to 5.
  // If this is set to 0, topology refresh after redirect is disabled.
  google.protobuf.UInt32Value redirect_refresh_threshold = 4;

  // The number of failures that must be received before triggering a topology refresh request.
  // If not set, this defaults to 0, which disables the topology refresh due to failure.
  uint32 failure_refresh_threshold = 5;

  // The number of hosts became degraded or unhealthy before triggering a topology refresh request.
  // If not set, this defaults to 0, which disables the topology refresh due to degraded or
  // unhealthy host.
  uint32 host_degraded_refresh_threshold = 6;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.cluster.aggregate.v2alpha;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.cluster.aggregate.v2alpha";
option java_outer_classname = "ClusterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/cluster/aggregate/v2alpha";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.clusters.aggregate.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Aggregate cluster configuration]

// Configuration for the aggregate cluster. See the :ref:`architecture overview
// <arch_overview_aggregate_cluster>` for more information.
// [#extension: envoy.clusters.aggregate]
message ClusterConfig {
  // Load balancing clusters in aggregate cluster. Clusters are prioritized based on the order they
  // appear in this list.
  repeated string clusters = 1 [(validate.rules).repeated = {min_items: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.cluster.v3;

import "envoy/config/core/v3/config_source.proto";

import "google/protobuf/any.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.cluster.v3";
option java_outer_classname = "FilterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3;clusterv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Upstream network filters]
// Upstream network filters apply to the connections to the upstream cluster hosts.

message Filter {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.cluster.Filter";

  // The name of the filter configuration.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // Filter specific configuration which depends on the filter being
  // instantiated. See the supported filters for further documentation.
  // Note that Envoy's :ref:`downstream network
  // filters <config_network_filters>` are not valid upstream network filters.
  // Only one of typed_config or config_discovery can be used.
  google.protobuf.Any typed_config = 2;

  // Configuration source specifier for an extension configuration discovery
  // service. In case of a failure and without the default configuration, the
  // listener closes the connections.
  // Only one of typed_config or config_discovery can be used.
  core.v3.ExtensionConfigSource config_discovery = 3;
}
syntax = "proto3";

package envoy.config.cluster.v3;

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.cluster.v3";
option java_outer_classname = "OutlierDetectionProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3;clusterv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Outlier detection]

// See the :ref:`architecture overview <arch_overview_outlier_detection>` for
// more information on outlier detection.
// [#next-free-field: 24]
message OutlierDetection {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.cluster.OutlierDetection";

  // The number of consecutive server-side error responses (for HTTP traffic,
  // 5xx responses; for TCP traffic, connection failures; for Redis, failure to
  // respond PONG; etc.) before a consecutive 5xx ejection occurs. Defaults to 5.
  google.protobuf.UInt32Value consecutive_5xx = 1;

  // The time interval between ejection analysis sweeps. This can result in
  // both new ejections as well as hosts being returned to service. Defaults
  // to 10000ms or 10s.
  google.protobuf.Duration interval = 2 [(validate.rules).duration = {gt {}}];

  // The base time that a host is ejected for. The real time is equal to the
  // base time multiplied by the number of times the host has been ejected and is
  // capped by :ref:`max_ejection_time<envoy_v3_api_field_config.cluster.v3.OutlierDetection.max_ejection_time>`.
  // Defaults to 30000ms or 30s.
  google.protobuf.Duration base_ejection_time = 3 [(validate.rules).duration = {gt {}}];

  // The maximum % of an upstream cluster that can be ejected due to outlier
  // detection. Defaults to 10% but will eject at least one host regardless of the value.
  google.protobuf.UInt32Value max_ejection_percent = 4 [(validate.rules).uint32 = {lte: 100}];

  // The % chance that a host will be actually ejected when an outlier status
  // is detected through consecutive 5xx. This setting can be used to disable
  // ejection or to ramp it up slowly. Defaults to 100.
  google.protobuf.UInt32Value enforcing_consecutive_5xx = 5 [(validate.rules).uint32 = {lte: 100}];

  // The % chance that a host will be actually ejected when an outlier status
  // is detected through success rate statistics. This setting can be used to
  // disable ejection or to ramp it up slowly. Defaults to 100.
  google.protobuf.UInt32Value enforcing_success_rate = 6 [(validate.rules).uint32 = {lte: 100}];

  // The number of hosts in a cluster that must have enough request volume to
  // detect success rate outliers. If the number of hosts is less than this
  // setting, outlier detection via success rate statistics is not performed
  // for any host in the cluster. Defaults to 5.
  google.protobuf.UInt32Value success_rate_minimum_hosts = 7;

  // The minimum number of total requests that must be collected in one
  // interval (as defined by the interval duration above) to include this host
  // in success rate based outlier detection. If the volume is lower than this
  // setting, outlier detection via success rate statistics is not performed
  // for that host. Defaults to 100.
  google.protobuf.UInt32Value success_rate_request_volume = 8;

  // This factor is used to determine the ejection threshold for success rate
  // outlier ejection. The ejection threshold is the difference between the
  // mean success rate, and the product of this factor and the standard
  // deviation of the mean success rate: mean - (stdev *
  // success_rate_stdev_factor). This factor is divided by a thousand to get a
  // double. That is, if the desired factor is 1.9, the runtime value should
  // be 1900. Defaults to 1900.
  google.protobuf.UInt32Value success_rate_stdev_factor = 9;

  // The number of consecutive gateway failures (502, 503, 504 status codes)
  // before a consecutive gateway failure ejection occurs. Defaults to 5.
  google.protobuf.UInt32Value consecutive_gateway_failure = 10;

  // The % chance that a host will be actually ejected when an outlier status
  // is detected through consecutive gateway failures. This setting can be
  // used to disable ejection or to ramp it up slowly. Defaults to 0.
  google.protobuf.UInt32Value enforcing_consecutive_gateway_failure = 11
      [(validate.rules).uint32 = {lte: 100}];

  // Determines whether to distinguish local origin failures from external errors. If set to true
  // the following configuration parameters are taken into account:
  // :ref:`consecutive_local_origin_failure<envoy_v3_api_field_config.cluster.v3.OutlierDetection.consecutive_local_origin_failure>`,
  // :ref:`enforcing_consecutive_local_origin_failure<envoy_v3_api_field_config.cluster.v3.OutlierDetection.enforcing_consecutive_local_origin_failure>`
  // and
  // :ref:`enforcing_local_origin_success_rate<envoy_v3_api_field_config.cluster.v3.OutlierDetection.enforcing_local_origin_success_rate>`.
  // Defaults to false.
  bool split_external_local_origin_errors = 12;

  // The number of consecutive locally originated failures before ejection
  // occurs. Defaults to 5. Parameter takes effect only when
  // :ref:`split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  // is set to true.
  google.protobuf.UInt32Value consecutive_local_origin_failure = 13;

  // The % chance that a host will be actually ejected when an outlier status
  // is detected through consecutive locally originated failures. This setting can be
  // used to disable ejection or to ramp it up slowly. Defaults to 100.
  // Parameter takes effect only when
  // :ref:`split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  // is set to true.
  google.protobuf.UInt32Value enforcing_consecutive_local_origin_failure = 14
      [(validate.rules).uint32 = {lte: 100}];

  // The % chance that a host will be actually ejected when an outlier status
  // is detected through success rate statistics for locally originated errors.
  // This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
  // Parameter takes effect only when
  // :ref:`split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  // is set to true.
  google.protobuf.UInt32Value enforcing_local_origin_success_rate = 15
      [(validate.rules).uint32 = {lte: 100}];

  // The failure percentage to use when determining failure percentage-based outlier detection. If
  // the failure percentage of a given host is greater than or equal to this value, it will be
  // ejected. Defaults to 85.
  google.protobuf.UInt32Value failure_percentage_threshold = 16
      [(validate.rules).uint32 = {lte: 100}];

  // The % chance that a host will be actually ejected when an outlier status is detected through
  // failure percentage statistics. This setting can be used to disable ejection or to ramp it up
  // slowly. Defaults to 0.
  //
  // [#next-major-version: setting this without setting failure_percentage_threshold should be
  // invalid in v4.]
  google.protobuf.UInt32Value enforcing_failure_percentage = 17
      [(validate.rules).uint32 = {lte: 100}];

  // The % chance that a host will be actually ejected when an outlier status is detected through
  // local-origin failure percentage statistics. This setting can be used to disable ejection or to
  // ramp it up slowly. Defaults to 0.
  google.protobuf.UInt32Value enforcing_failure_percentage_local_origin = 18
      [(validate.rules).uint32 = {lte: 100}];

  // The minimum number of hosts in a cluster in order to perform failure percentage-based ejection.
  // If the total number of hosts in the cluster is less than this value, failure percentage-based
  // ejection will not be performed. Defaults to 5.
  google.protobuf.UInt32Value failure_percentage_minimum_hosts = 19;

  // The minimum number of total requests that must be collected in one interval (as defined by the
  // interval duration above) to perform failure percentage-based ejection for this host. If the
  // volume is lower than this setting, failure percentage-based ejection will not be performed for
  // this host. Defaults to 50.
  google.protobuf.UInt32Value failure_percentage_request_volume = 20;

  // The maximum time that a host is ejected for. See :ref:`base_ejection_time<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>`
  // for more information. If not specified, the default value (300000ms or 300s) or
  // :ref:`base_ejection_time<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>` value is applied, whatever is larger.
  google.protobuf.Duration max_ejection_time = 21 [(validate.rules).duration = {gt {}}];

  // The maximum amount of jitter to add to the ejection time, in order to prevent
  // a 'thundering herd' effect where all proxies try to reconnect to host at the same time.
  // See :ref:`max_ejection_time_jitter<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>`
  // Defaults to 0s.
  google.protobuf.Duration max_ejection_time_jitter = 22;

  // If active health checking is enabled and a host is ejected by outlier detection, a successful active health check
  // unejects the host by default and considers it as healthy. Unejection also clears all the outlier detection counters.
  // To change this default behavior set this config to ``false`` where active health checking will not uneject the host.
  // Defaults to true.
  google.protobuf.BoolValue successful_active_health_check_uneject_host = 23;
}
syntax = "proto3";

package envoy.config.cluster.v3;

import "envoy/config/cluster/v3/circuit_breaker.proto";
import "envoy/config/cluster/v3/filter.proto";
import "envoy/config/cluster/v3/outlier_detection.proto";
import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/config_source.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/health_check.proto";
import "envoy/config/core/v3/protocol.proto";
import "envoy/config/core/v3/resolver.proto";
import "envoy/config/endpoint/v3/endpoint.proto";
import "envoy/type/metadata/v3/metadata.proto";
import "envoy/type/v3/percent.proto";

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";

import "xds/core/v3/collection_entry.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/security.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.cluster.v3";
option java_outer_classname = "ClusterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3;clusterv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Cluster configuration]

// Cluster list collections. Entries are ``Cluster`` resources or references.
// [#not-implemented-hide:]
message ClusterCollection {
  xds.core.v3.CollectionEntry entries = 1;
}

// Configuration for a single upstream cluster.
// [#next-free-field: 57]
message Cluster {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.Cluster";

  // Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
  // for an explanation on each type.
  enum DiscoveryType {
    // Refer to the :ref:`static discovery type<arch_overview_service_discovery_types_static>`
    // for an explanation.
    STATIC = 0;

    // Refer to the :ref:`strict DNS discovery
    // type<arch_overview_service_discovery_types_strict_dns>`
    // for an explanation.
    STRICT_DNS = 1;

    // Refer to the :ref:`logical DNS discovery
    // type<arch_overview_service_discovery_types_logical_dns>`
    // for an explanation.
    LOGICAL_DNS = 2;

    // Refer to the :ref:`service discovery type<arch_overview_service_discovery_types_eds>`
    // for an explanation.
    EDS = 3;

    // Refer to the :ref:`original destination discovery
    // type<arch_overview_service_discovery_types_original_destination>`
    // for an explanation.
    ORIGINAL_DST = 4;
  }

  // Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
  // overview section for information on each type.
  enum LbPolicy {
    reserved 4;

    reserved "ORIGINAL_DST_LB";

    // Refer to the :ref:`round robin load balancing
    // policy<arch_overview_load_balancing_types_round_robin>`
    // for an explanation.
    ROUND_ROBIN = 0;

    // Refer to the :ref:`least request load balancing
    // policy<arch_overview_load_balancing_types_least_request>`
    // for an explanation.
    LEAST_REQUEST = 1;

    // Refer to the :ref:`ring hash load balancing
    // policy<arch_overview_load_balancing_types_ring_hash>`
    // for an explanation.
    RING_HASH = 2;

    // Refer to the :ref:`random load balancing
    // policy<arch_overview_load_balancing_types_random>`
    // for an explanation.
    RANDOM = 3;

    // Refer to the :ref:`Maglev load balancing policy<arch_overview_load_balancing_types_maglev>`
    // for an explanation.
    MAGLEV = 5;

    // This load balancer type must be specified if the configured cluster provides a cluster
    // specific load balancer. Consult the configured cluster's documentation for whether to set
    // this option or not.
    CLUSTER_PROVIDED = 6;

    // Use the new :ref:`load_balancing_policy
    // <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field to determine the LB policy.
    // This has been deprecated in favor of using the :ref:`load_balancing_policy
    // <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field without
    // setting any value in :ref:`lb_policy<envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy>`.
    LOAD_BALANCING_POLICY_CONFIG = 7;
  }

  // When V4_ONLY is selected, the DNS resolver will only perform a lookup for
  // addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
  // only perform a lookup for addresses in the IPv6 family. If AUTO is
  // specified, the DNS resolver will first perform a lookup for addresses in
  // the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
  // This is semantically equivalent to a non-existent V6_PREFERRED option.
  // AUTO is a legacy name that is more opaque than
  // necessary and will be deprecated in favor of V6_PREFERRED in a future major version of the API.
  // If V4_PREFERRED is specified, the DNS resolver will first perform a lookup for addresses in the
  // IPv4 family and fallback to a lookup for addresses in the IPv6 family. i.e., the callback
  // target will only get v6 addresses if there were NO v4 addresses to return.
  // If ALL is specified, the DNS resolver will perform a lookup for both IPv4 and IPv6 families,
  // and return all resolved addresses. When this is used, Happy Eyeballs will be enabled for
  // upstream connections. Refer to :ref:`Happy Eyeballs Support <arch_overview_happy_eyeballs>`
  // for more information.
  // For cluster types other than
  // :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
  // :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
  // this setting is
  // ignored.
  // [#next-major-version: deprecate AUTO in favor of a V6_PREFERRED option.]
  enum DnsLookupFamily {
    AUTO = 0;
    V4_ONLY = 1;
    V6_ONLY = 2;
    V4_PREFERRED = 3;
    ALL = 4;
  }

  enum ClusterProtocolSelection {
    // Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
    // If :ref:`http2_protocol_options <envoy_v3_api_field_config.cluster.v3.Cluster.http2_protocol_options>` are
    // present, HTTP2 will be used, otherwise HTTP1.1 will be used.
    USE_CONFIGURED_PROTOCOL = 0;

    // Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
    USE_DOWNSTREAM_PROTOCOL = 1;
  }

  // TransportSocketMatch specifies what transport socket config will be used
  // when the match conditions are satisfied.
  message TransportSocketMatch {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.Cluster.TransportSocketMatch";

    // The name of the match, used in stats generation.
    string name = 1 [(validate.rules).string = {min_len: 1}];

    // Optional endpoint metadata match criteria.
    // The connection to the endpoint with metadata matching what is set in this field
    // will use the transport socket configuration specified here.
    // The endpoint's metadata entry in ``envoy.transport_socket_match`` is used to match
    // against the values specified in this field.
    google.protobuf.Struct match = 2;

    // The configuration of the transport socket.
    // [#extension-category: envoy.transport_sockets.upstream]
    core.v3.TransportSocket transport_socket = 3;
  }

  // Extended cluster type.
  message CustomClusterType {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.Cluster.CustomClusterType";

    // The type of the cluster to instantiate. The name must match a supported cluster type.
    string name = 1 [(validate.rules).string = {min_len: 1}];

    // Cluster specific configuration which depends on the cluster being instantiated.
    // See the supported cluster for further documentation.
    // [#extension-category: envoy.clusters]
    google.protobuf.Any typed_config = 2;
  }

  // Only valid when discovery type is EDS.
  message EdsClusterConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.Cluster.EdsClusterConfig";

    // Configuration for the source of EDS updates for this Cluster.
    core.v3.ConfigSource eds_config = 1;

    // Optional alternative to cluster name to present to EDS. This does not
    // have the same restrictions as cluster name, i.e. it may be arbitrary
    // length. This may be a xdstp:// URL.
    string service_name = 2;
  }

  // Optionally divide the endpoints in this cluster into subsets defined by
  // endpoint metadata and selected by route and weighted cluster metadata.
  // [#next-free-field: 9]
  message LbSubsetConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.Cluster.LbSubsetConfig";

    // If NO_FALLBACK is selected, a result
    // equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
    // any cluster endpoint may be returned (subject to policy, health checks,
    // etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
    // endpoints matching the values from the default_subset field.
    enum LbSubsetFallbackPolicy {
      NO_FALLBACK = 0;
      ANY_ENDPOINT = 1;
      DEFAULT_SUBSET = 2;
    }

    enum LbSubsetMetadataFallbackPolicy {
      // No fallback. Route metadata will be used as-is.
      METADATA_NO_FALLBACK = 0;

      // A special metadata key ``fallback_list`` will be used to provide variants of metadata to try.
      // Value of ``fallback_list`` key has to be a list. Every list element has to be a struct - it will
      // be merged with route metadata, overriding keys that appear in both places.
      // ``fallback_list`` entries will be used in order until a host is found.
      //
      // ``fallback_list`` key itself is removed from metadata before subset load balancing is performed.
      //
      // Example:
      //
      // for metadata:
      //
      // .. code-block:: yaml
      //
      //   version: 1.0
      //   fallback_list:
      //     - version: 2.0
      //       hardware: c64
      //     - hardware: c32
      //     - version: 3.0
      //
      // at first, metadata:
      //
      // .. code-block:: json
      //
      //   {"version": "2.0", "hardware": "c64"}
      //
      // will be used for load balancing. If no host is found, metadata:
      //
      // .. code-block:: json
      //
      //   {"version": "1.0", "hardware": "c32"}
      //
      // is next to try. If it still results in no host, finally metadata:
      //
      // .. code-block:: json
      //
      //   {"version": "3.0"}
      //
      // is used.
      FALLBACK_LIST = 1;
    }

    // Specifications for subsets.
    message LbSubsetSelector {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector";

      // Allows to override top level fallback policy per selector.
      enum LbSubsetSelectorFallbackPolicy {
        // If NOT_DEFINED top level config fallback policy is used instead.
        NOT_DEFINED = 0;

        // If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
        NO_FALLBACK = 1;

        // If ANY_ENDPOINT is selected, any cluster endpoint may be returned
        // (subject to policy, health checks, etc).
        ANY_ENDPOINT = 2;

        // If DEFAULT_SUBSET is selected, load balancing is performed over the
        // endpoints matching the values from the default_subset field.
        DEFAULT_SUBSET = 3;

        // If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
        // keys reduced to
        // :ref:`fallback_keys_subset<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
        // It allows for a fallback to a different, less specific selector if some of the keys of
        // the selector are considered optional.
        KEYS_SUBSET = 4;
      }

      // List of keys to match with the weighted cluster metadata.
      repeated string keys = 1;

      // Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
      // choosing a host, but updating hosts is faster, especially for large numbers of hosts.
      //
      // If a match is found to a host, that host will be used regardless of priority levels.
      //
      // When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in ``keys``
      // will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
      // :ref:`lb_subsets_single_host_per_subset_duplicate<config_cluster_manager_cluster_stats_subset_lb>` indicates how many duplicates are
      // present in the current configuration.
      bool single_host_per_subset = 4;

      // The behavior used when no endpoint subset matches the selected route's
      // metadata.
      LbSubsetSelectorFallbackPolicy fallback_policy = 2
          [(validate.rules).enum = {defined_only: true}];

      // Subset of
      // :ref:`keys<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` used by
      // :ref:`KEYS_SUBSET<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
      // fallback policy.
      // It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
      // For any other fallback policy the parameter is not used and should not be set.
      // Only values also present in
      // :ref:`keys<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` are allowed, but
      // ``fallback_keys_subset`` cannot be equal to ``keys``.
      repeated string fallback_keys_subset = 3;
    }

    // The behavior used when no endpoint subset matches the selected route's
    // metadata. The value defaults to
    // :ref:`NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
    LbSubsetFallbackPolicy fallback_policy = 1 [(validate.rules).enum = {defined_only: true}];

    // Specifies the default subset of endpoints used during fallback if
    // fallback_policy is
    // :ref:`DEFAULT_SUBSET<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
    // Each field in default_subset is
    // compared to the matching LbEndpoint.Metadata under the ``envoy.lb``
    // namespace. It is valid for no hosts to match, in which case the behavior
    // is the same as a fallback_policy of
    // :ref:`NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
    google.protobuf.Struct default_subset = 2;

    // For each entry, LbEndpoint.Metadata's
    // ``envoy.lb`` namespace is traversed and a subset is created for each unique
    // combination of key and value. For example:
    //
    // .. code-block:: json
    //
    //   { "subset_selectors": [
    //       { "keys": [ "version" ] },
    //       { "keys": [ "stage", "hardware_type" ] }
    //   ]}
    //
    // A subset is matched when the metadata from the selected route and
    // weighted cluster contains the same keys and values as the subset's
    // metadata. The same host may appear in multiple subsets.
    repeated LbSubsetSelector subset_selectors = 3;

    // If true, routing to subsets will take into account the localities and locality weights of the
    // endpoints when making the routing decision.
    //
    // There are some potential pitfalls associated with enabling this feature, as the resulting
    // traffic split after applying both a subset match and locality weights might be undesirable.
    //
    // Consider for example a situation in which you have 50/50 split across two localities X/Y
    // which have 100 hosts each without subsetting. If the subset LB results in X having only 1
    // host selected but Y having 100, then a lot more load is being dumped on the single host in X
    // than originally anticipated in the load balancing assignment delivered via EDS.
    bool locality_weight_aware = 4;

    // When used with locality_weight_aware, scales the weight of each locality by the ratio
    // of hosts in the subset vs hosts in the original subset. This aims to even out the load
    // going to an individual locality if said locality is disproportionately affected by the
    // subset predicate.
    bool scale_locality_weight = 5;

    // If true, when a fallback policy is configured and its corresponding subset fails to find
    // a host this will cause any host to be selected instead.
    //
    // This is useful when using the default subset as the fallback policy, given the default
    // subset might become empty. With this option enabled, if that happens the LB will attempt
    // to select a host from the entire cluster.
    bool panic_mode_any = 6;

    // If true, metadata specified for a metadata key will be matched against the corresponding
    // endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
    // and any of the elements in the list matches the criteria.
    bool list_as_any = 7;

    // Fallback mechanism that allows to try different route metadata until a host is found.
    // If load balancing process, including all its mechanisms (like
    // :ref:`fallback_policy<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.fallback_policy>`)
    // fails to select a host, this policy decides if and how the process is repeated using another metadata.
    //
    // The value defaults to
    // :ref:`METADATA_NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK>`.
    LbSubsetMetadataFallbackPolicy metadata_fallback_policy = 8
        [(validate.rules).enum = {defined_only: true}];
  }

  // Configuration for :ref:`slow start mode <arch_overview_load_balancing_slow_start>`.
  message SlowStartConfig {
    // Represents the size of slow start window.
    // If set, the newly created host remains in slow start mode starting from its creation time
    // for the duration of slow start window.
    google.protobuf.Duration slow_start_window = 1;

    // This parameter controls the speed of traffic increase over the slow start window. Defaults to 1.0,
    // so that endpoint would get linearly increasing amount of traffic.
    // When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly.
    // The value of aggression parameter should be greater than 0.0.
    // By tuning the parameter, is possible to achieve polynomial or exponential shape of ramp-up curve.
    //
    // During slow start window, effective weight of an endpoint would be scaled with time factor and aggression:
    // ``new_weight = weight * max(min_weight_percent, time_factor ^ (1 / aggression))``,
    // where ``time_factor=(time_since_start_seconds / slow_start_time_seconds)``.
    //
    // As time progresses, more and more traffic would be sent to endpoint, which is in slow start window.
    // Once host exits slow start, time_factor and aggression no longer affect its weight.
    core.v3.RuntimeDouble aggression = 2;

    // Configures the minimum percentage of origin weight that avoids too small new weight,
    // which may cause endpoints in slow start mode receive no traffic in slow start window.
    // If not specified, the default is 10%.
    type.v3.Percent min_weight_percent = 3;
  }

  // Specific configuration for the RoundRobin load balancing policy.
  message RoundRobinLbConfig {
    // Configuration for slow start mode.
    // If this configuration is not set, slow start will not be not enabled.
    SlowStartConfig slow_start_config = 1;
  }

  // Specific configuration for the LeastRequest load balancing policy.
  message LeastRequestLbConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.Cluster.LeastRequestLbConfig";

    // The number of random healthy hosts from which the host with the fewest active requests will
    // be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
    google.protobuf.UInt32Value choice_count = 1 [(validate.rules).uint32 = {gte: 2}];

    // The following formula is used to calculate the dynamic weights when hosts have different load
    // balancing weights:
    //
    // ``weight = load_balancing_weight / (active_requests + 1)^active_request_bias``
    //
    // The larger the active request bias is, the more aggressively active requests will lower the
    // effective weight when all host weights are not equal.
    //
    // ``active_request_bias`` must be greater than or equal to 0.0.
    //
    // When ``active_request_bias == 0.0`` the Least Request Load Balancer doesn't consider the number
    // of active requests at the time it picks a host and behaves like the Round Robin Load
    // Balancer.
    //
    // When ``active_request_bias > 0.0`` the Least Request Load Balancer scales the load balancing
    // weight by the number of active requests at the time it does a pick.
    //
    // The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
    // host sets changes, e.g., whenever there is a host membership update or a host load balancing
    // weight change.
    //
    // .. note::
    //   This setting only takes effect if all host weights are not equal.
    core.v3.RuntimeDouble active_request_bias = 2;

    // Configuration for slow start mode.
    // If this configuration is not set, slow start will not be not enabled.
    SlowStartConfig slow_start_config = 3;
  }

  // Specific configuration for the :ref:`RingHash<arch_overview_load_balancing_types_ring_hash>`
  // load balancing policy.
  message RingHashLbConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.Cluster.RingHashLbConfig";

    // The hash function used to hash hosts onto the ketama ring.
    enum HashFunction {
      // Use `xxHash <https://github.com/Cyan4973/xxHash>`_, this is the default hash function.
      XX_HASH = 0;

      // Use `MurmurHash2 <https://sites.google.com/site/murmurhash/>`_, this is compatible with
      // std:hash<string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
      // on Linux and not macOS.
      MURMUR_HASH_2 = 1;
    }

    reserved 2;

    // Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
    // provided host) the better the request distribution will reflect the desired weights. Defaults
    // to 1024 entries, and limited to 8M entries. See also
    // :ref:`maximum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size>`.
    google.protobuf.UInt64Value minimum_ring_size = 1 [(validate.rules).uint64 = {lte: 8388608}];

    // The hash function used to hash hosts onto the ketama ring. The value defaults to
    // :ref:`XX_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
    HashFunction hash_function = 3 [(validate.rules).enum = {defined_only: true}];

    // Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
    // to further constrain resource use. See also
    // :ref:`minimum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size>`.
    google.protobuf.UInt64Value maximum_ring_size = 4 [(validate.rules).uint64 = {lte: 8388608}];
  }

  // Specific configuration for the :ref:`Maglev<arch_overview_load_balancing_types_maglev>`
  // load balancing policy.
  message MaglevLbConfig {
    // The table size for Maglev hashing. Maglev aims for "minimal disruption" rather than an absolute guarantee.
    // Minimal disruption means that when the set of upstream hosts change, a connection will likely be sent to the same
    // upstream as it was before. Increasing the table size reduces the amount of disruption.
    // The table size must be prime number limited to 5000011. If it is not specified, the default is 65537.
    google.protobuf.UInt64Value table_size = 1 [(validate.rules).uint64 = {lte: 5000011}];
  }

  // Specific configuration for the
  // :ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`
  // load balancing policy.
  // [#extension: envoy.clusters.original_dst]
  message OriginalDstLbConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.Cluster.OriginalDstLbConfig";

    // When true, a HTTP header can be used to override the original dst address. The default header is
    // :ref:`x-envoy-original-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>`.
    //
    // .. attention::
    //
    //   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
    //   route traffic to arbitrary hosts and/or ports, which may have serious security
    //   consequences.
    //
    // .. note::
    //
    //   If the header appears multiple times only the first value is used.
    bool use_http_header = 1;

    // The http header to override destination address if :ref:`use_http_header <envoy_v3_api_field_config.cluster.v3.Cluster.OriginalDstLbConfig.use_http_header>`.
    // is set to true. If the value is empty, :ref:`x-envoy-original-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>` will be used.
    string http_header_name = 2;

    // The port to override for the original dst address. This port
    // will take precedence over filter state and header override ports
    google.protobuf.UInt32Value upstream_port_override = 3 [(validate.rules).uint32 = {lte: 65535}];

    // The dynamic metadata key to override destination address.
    // First the request metadata is considered, then the connection one.
    type.metadata.v3.MetadataKey metadata_key = 4;
  }

  // Common configuration for all load balancer implementations.
  // [#next-free-field: 9]
  message CommonLbConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.Cluster.CommonLbConfig";

    // Configuration for :ref:`zone aware routing
    // <arch_overview_load_balancing_zone_aware_routing>`.
    message ZoneAwareLbConfig {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig";

      // Configures percentage of requests that will be considered for zone aware routing
      // if zone aware routing is configured. If not specified, the default is 100%.
      // * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
      // * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
      type.v3.Percent routing_enabled = 1;

      // Configures minimum upstream cluster size required for zone aware routing
      // If upstream cluster size is less than specified, zone aware routing is not performed
      // even if zone aware routing is configured. If not specified, the default is 6.
      // * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
      // * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
      google.protobuf.UInt64Value min_cluster_size = 2;

      // If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
      // mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
      // requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
      // failing service.
      bool fail_traffic_on_panic = 3;
    }

    // Configuration for :ref:`locality weighted load balancing
    // <arch_overview_load_balancing_locality_weighted_lb>`
    message LocalityWeightedLbConfig {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig";
    }

    // Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
    message ConsistentHashingLbConfig {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.Cluster.CommonLbConfig.ConsistentHashingLbConfig";

      // If set to ``true``, the cluster will use hostname instead of the resolved
      // address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
      bool use_hostname_for_hashing = 1;

      // Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
      // no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
      // If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
      // Minimum is 100.
      //
      // Applies to both Ring Hash and Maglev load balancers.
      //
      // This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
      // ``hash_balance_factor``, requests to any upstream host are capped at ``hash_balance_factor/100`` times the average number of requests
      // across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
      // is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
      // the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
      // cascading overflow effect when choosing the next host in the ring/table).
      //
      // If weights are specified on the hosts, they are respected.
      //
      // This is an O(N) algorithm, unlike other load balancers. Using a lower ``hash_balance_factor`` results in more hosts
      // being probed, so use a higher value if you require better performance.
      google.protobuf.UInt32Value hash_balance_factor = 2 [(validate.rules).uint32 = {gte: 100}];
    }

    // Configures the :ref:`healthy panic threshold <arch_overview_load_balancing_panic_threshold>`.
    // If not specified, the default is 50%.
    // To disable panic mode, set to 0%.
    //
    // .. note::
    //   The specified percent will be truncated to the nearest 1%.
    type.v3.Percent healthy_panic_threshold = 1;

    oneof locality_config_specifier {
      ZoneAwareLbConfig zone_aware_lb_config = 2;

      LocalityWeightedLbConfig locality_weighted_lb_config = 3;
    }

    // If set, all health check/weight/metadata updates that happen within this duration will be
    // merged and delivered in one shot when the duration expires. The start of the duration is when
    // the first update happens. This is useful for big clusters, with potentially noisy deploys
    // that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
    // or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
    // cluster). Please always keep in mind that the use of sandbox technologies may change this
    // behavior.
    //
    // If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
    // window to 0.
    //
    // Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
    // because merging those updates isn't currently safe. See
    // https://github.com/envoyproxy/envoy/pull/3941.
    google.protobuf.Duration update_merge_window = 4;

    // If set to true, Envoy will :ref:`exclude <arch_overview_load_balancing_excluded>` new hosts
    // when computing load balancing weights until they have been health checked for the first time.
    // This will have no effect unless active health checking is also configured.
    bool ignore_new_hosts_until_first_hc = 5;

    // If set to ``true``, the cluster manager will drain all existing
    // connections to upstream hosts whenever hosts are added or removed from the cluster.
    bool close_connections_on_host_set_change = 6;

    // Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
    ConsistentHashingLbConfig consistent_hashing_lb_config = 7;

    // This controls what hosts are considered valid when using
    // :ref:`host overrides <arch_overview_load_balancing_override_host>`, which is used by some
    // filters to modify the load balancing decision.
    //
    // If this is unset then [UNKNOWN, HEALTHY, DEGRADED] will be applied by default. If this is
    // set with an empty set of statuses then host overrides will be ignored by the load balancing.
    core.v3.HealthStatusSet override_host_status = 8;
  }

  message RefreshRate {
    option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.Cluster.RefreshRate";

    // Specifies the base interval between refreshes. This parameter is required and must be greater
    // than zero and less than
    // :ref:`max_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval>`.
    google.protobuf.Duration base_interval = 1 [(validate.rules).duration = {
      required: true
      gt {nanos: 1000000}
    }];

    // Specifies the maximum interval between refreshes. This parameter is optional, but must be
    // greater than or equal to the
    // :ref:`base_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`  if set. The default
    // is 10 times the :ref:`base_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`.
    google.protobuf.Duration max_interval = 2 [(validate.rules).duration = {gt {nanos: 1000000}}];
  }

  message PreconnectPolicy {
    // Indicates how many streams (rounded up) can be anticipated per-upstream for each
    // incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
    // will only be done if the upstream is healthy and the cluster has traffic.
    //
    // For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
    // established, one for the new incoming stream, and one for a presumed follow-up stream. For
    // HTTP/2, only one connection would be established by default as one connection can
    // serve both the original and presumed follow-up stream.
    //
    // In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
    // active streams, there would be 100 connections in use, and 50 connections preconnected.
    // This might be a useful value for something like short lived single-use connections,
    // for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
    // termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
    // or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
    // reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
    // in case of unexpected disconnects where the connection could not be reused.
    //
    // If this value is not set, or set explicitly to one, Envoy will fetch as many connections
    // as needed to serve streams in flight. This means in steady state if a connection is torn down,
    // a subsequent streams will pay an upstream-rtt latency penalty waiting for a new connection.
    //
    // This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
    // harm latency more than the preconnecting helps.
    google.protobuf.DoubleValue per_upstream_preconnect_ratio = 1
        [(validate.rules).double = {lte: 3.0 gte: 1.0}];

    // Indicates how many streams (rounded up) can be anticipated across a cluster for each
    // stream, useful for low QPS services. This is currently supported for a subset of
    // deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
    // Unlike ``per_upstream_preconnect_ratio`` this preconnects across the upstream instances in a
    // cluster, doing best effort predictions of what upstream would be picked next and
    // pre-establishing a connection.
    //
    // Preconnecting will be limited to one preconnect per configured upstream in the cluster and will
    // only be done if there are healthy upstreams and the cluster has traffic.
    //
    // For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
    // incoming stream, 2 connections will be preconnected - one to the first upstream for this
    // cluster, one to the second on the assumption there will be a follow-up stream.
    //
    // If this value is not set, or set explicitly to one, Envoy will fetch as many connections
    // as needed to serve streams in flight, so during warm up and in steady state if a connection
    // is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
    // connection establishment.
    //
    // If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
    // basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each
    // upstream.
    google.protobuf.DoubleValue predictive_preconnect_ratio = 2
        [(validate.rules).double = {lte: 3.0 gte: 1.0}];
  }

  reserved 12, 15, 7, 11, 35;

  reserved "hosts", "tls_context", "extension_protocol_options";

  // Configuration to use different transport sockets for different endpoints.
  // The entry of ``envoy.transport_socket_match`` in the
  // :ref:`LbEndpoint.Metadata <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>`
  // is used to match against the transport sockets as they appear in the list. The first
  // :ref:`match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` is used.
  // For example, with the following match
  //
  // .. code-block:: yaml
  //
  //  transport_socket_matches:
  //  - name: "enableMTLS"
  //    match:
  //      acceptMTLS: true
  //    transport_socket:
  //      name: envoy.transport_sockets.tls
  //      config: { ... } # tls socket configuration
  //  - name: "defaultToPlaintext"
  //    match: {}
  //    transport_socket:
  //      name: envoy.transport_sockets.raw_buffer
  //
  // Connections to the endpoints whose metadata value under ``envoy.transport_socket_match``
  // having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
  //
  // If a :ref:`socket match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` with empty match
  // criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
  // socket match in case above.
  //
  // If an endpoint metadata's value under ``envoy.transport_socket_match`` does not match any
  // ``TransportSocketMatch``, socket configuration fallbacks to use the ``tls_context`` or
  // ``transport_socket`` specified in this cluster.
  //
  // This field allows gradual and flexible transport socket configuration changes.
  //
  // The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
  // an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
  // "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
  // has "acceptPlaintext": "true" metadata information.
  //
  // Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
  // traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
  // ``TransportSocketMatch`` in this field. Other client Envoys receive CDS without
  // ``transport_socket_match`` set, and still send plain text traffic to the same cluster.
  //
  // This field can be used to specify custom transport socket configurations for health
  // checks by adding matching key/value pairs in a health check's
  // :ref:`transport socket match criteria <envoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>` field.
  //
  // [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
  repeated TransportSocketMatch transport_socket_matches = 43;

  // Supplies the name of the cluster which must be unique across all clusters.
  // The cluster name is used when emitting
  // :ref:`statistics <config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
  // <envoy_v3_api_field_config.cluster.v3.Cluster.alt_stat_name>` is not provided.
  // Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // An optional alternative to the cluster name to be used for observability. This name is used
  // emitting stats for the cluster and access logging the cluster name. This will appear as
  // additional information in configuration dumps of a cluster's current status as
  // :ref:`observability_name <envoy_v3_api_field_admin.v3.ClusterStatus.observability_name>`
  // and as an additional tag "upstream_cluster.name" while tracing. Note: Any ``:`` in the name
  // will be converted to ``_`` when emitting statistics. This should not be confused with
  // :ref:`Router Filter Header <config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
  string alt_stat_name = 28 [(udpa.annotations.field_migrate).rename = "observability_name"];

  oneof cluster_discovery_type {
    // The :ref:`service discovery type <arch_overview_service_discovery_types>`
    // to use for resolving the cluster.
    DiscoveryType type = 2 [(validate.rules).enum = {defined_only: true}];

    // The custom cluster type.
    CustomClusterType cluster_type = 38;
  }

  // Configuration to use for EDS updates for the Cluster.
  EdsClusterConfig eds_cluster_config = 3;

  // The timeout for new network connections to hosts in the cluster.
  // If not set, a default value of 5s will be used.
  google.protobuf.Duration connect_timeout = 4 [(validate.rules).duration = {gt {}}];

  // Soft limit on size of the clusters connections read and write buffers. If
  // unspecified, an implementation defined default is applied (1MiB).
  google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5
      [(udpa.annotations.security).configure_for_untrusted_upstream = true];

  // The :ref:`load balancer type <arch_overview_load_balancing_types>` to use
  // when picking a host in the cluster.
  LbPolicy lb_policy = 6 [(validate.rules).enum = {defined_only: true}];

  // Setting this is required for specifying members of
  // :ref:`STATIC<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC>`,
  // :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
  // or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
  // This field supersedes the ``hosts`` field in the v2 API.
  //
  // .. attention::
  //
  //   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
  //   :ref:`endpoint assignments<envoy_v3_api_msg_config.endpoint.v3.ClusterLoadAssignment>`.
  //
  endpoint.v3.ClusterLoadAssignment load_assignment = 33;

  // Optional :ref:`active health checking <arch_overview_health_checking>`
  // configuration for the cluster. If no
  // configuration is specified no health checking will be done and all cluster
  // members will be considered healthy at all times.
  repeated core.v3.HealthCheck health_checks = 8;

  // Optional maximum requests for a single upstream connection. This parameter
  // is respected by both the HTTP/1.1 and HTTP/2 connection pool
  // implementations. If not specified, there is no limit. Setting this
  // parameter to 1 will effectively disable keep alive.
  //
  // .. attention::
  //   This field has been deprecated in favor of the :ref:`max_requests_per_connection <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_requests_per_connection>` field.
  google.protobuf.UInt32Value max_requests_per_connection = 9
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Optional :ref:`circuit breaking <arch_overview_circuit_break>` for the cluster.
  CircuitBreakers circuit_breakers = 10;

  // HTTP protocol options that are applied only to upstream HTTP connections.
  // These options apply to all HTTP versions.
  // This has been deprecated in favor of
  // :ref:`upstream_http_protocol_options <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
  // in the :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
  // upstream_http_protocol_options can be set via the cluster's
  // :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
  // See :ref:`upstream_http_protocol_options
  // <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
  // for example usage.
  core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 46
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Additional options when handling HTTP requests upstream. These options will be applicable to
  // both HTTP1 and HTTP2 requests.
  // This has been deprecated in favor of
  // :ref:`common_http_protocol_options <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options>`
  // in the :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
  // common_http_protocol_options can be set via the cluster's
  // :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
  // See :ref:`upstream_http_protocol_options
  // <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
  // for example usage.
  core.v3.HttpProtocolOptions common_http_protocol_options = 29
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Additional options when handling HTTP1 requests.
  // This has been deprecated in favor of http_protocol_options fields in the
  // :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
  // http_protocol_options can be set via the cluster's
  // :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
  // See :ref:`upstream_http_protocol_options
  // <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
  // for example usage.
  core.v3.Http1ProtocolOptions http_protocol_options = 13
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Even if default HTTP2 protocol options are desired, this field must be
  // set so that Envoy will assume that the upstream supports HTTP/2 when
  // making new HTTP connection pool connections. Currently, Envoy only
  // supports prior knowledge for upstream connections. Even if TLS is used
  // with ALPN, ``http2_protocol_options`` must be specified. As an aside this allows HTTP/2
  // connections to happen over plain text.
  // This has been deprecated in favor of http2_protocol_options fields in the
  // :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>`
  // message. http2_protocol_options can be set via the cluster's
  // :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
  // See :ref:`upstream_http_protocol_options
  // <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
  // for example usage.
  core.v3.Http2ProtocolOptions http2_protocol_options = 14 [
    deprecated = true,
    (udpa.annotations.security).configure_for_untrusted_upstream = true,
    (envoy.annotations.deprecated_at_minor_version) = "3.0"
  ];

  // The extension_protocol_options field is used to provide extension-specific protocol options
  // for upstream connections. The key should match the extension filter name, such as
  // "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
  // specific options.
  // [#next-major-version: make this a list of typed extensions.]
  map<string, google.protobuf.Any> typed_extension_protocol_options = 36;

  // If the DNS refresh rate is specified and the cluster type is either
  // :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
  // or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
  // this value is used as the clusters DNS refresh
  // rate. The value configured must be at least 1ms. If this setting is not specified, the
  // value defaults to 5000ms. For cluster types other than
  // :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
  // and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
  // this setting is ignored.
  google.protobuf.Duration dns_refresh_rate = 16
      [(validate.rules).duration = {gt {nanos: 1000000}}];

  // If the DNS failure refresh rate is specified and the cluster type is either
  // :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
  // or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
  // this is used as the clusters DNS refresh rate when requests are failing. If this setting is
  // not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
  // other than :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
  // :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` this setting is
  // ignored.
  RefreshRate dns_failure_refresh_rate = 44;

  // Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
  // cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
  // resolution.
  bool respect_dns_ttl = 39;

  // The DNS IP address resolution policy. If this setting is not specified, the
  // value defaults to
  // :ref:`AUTO<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO>`.
  DnsLookupFamily dns_lookup_family = 17 [(validate.rules).enum = {defined_only: true}];

  // If DNS resolvers are specified and the cluster type is either
  // :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
  // or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
  // this value is used to specify the clusters dns resolvers.
  // If this setting is not specified, the value defaults to the default
  // resolver, which uses /etc/resolv.conf for configuration. For cluster types
  // other than
  // :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
  // and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
  // this setting is ignored.
  // This field is deprecated in favor of ``dns_resolution_config``
  // which aggregates all of the DNS resolver configuration in a single message.
  repeated core.v3.Address dns_resolvers = 18
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Always use TCP queries instead of UDP queries for DNS lookups.
  // This field is deprecated in favor of ``dns_resolution_config``
  // which aggregates all of the DNS resolver configuration in a single message.
  bool use_tcp_for_dns_lookups = 45
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // DNS resolution configuration which includes the underlying dns resolver addresses and options.
  // This field is deprecated in favor of
  // :ref:`typed_dns_resolver_config <envoy_v3_api_field_config.cluster.v3.Cluster.typed_dns_resolver_config>`.
  core.v3.DnsResolutionConfig dns_resolution_config = 53
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
  // or any other DNS resolver types and the related parameters.
  // For example, an object of
  // :ref:`CaresDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
  // can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
  // :ref:`dns_resolution_config <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>`
  // configuration.
  // During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
  // when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
  // When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
  // [#extension-category: envoy.network.dns_resolver]
  core.v3.TypedExtensionConfig typed_dns_resolver_config = 55;

  // Optional configuration for having cluster readiness block on warm-up. Currently, only applicable for
  // :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
  // or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
  // or :ref:`Redis Cluster<arch_overview_redis>`.
  // If true, cluster readiness blocks on warm-up. If false, the cluster will complete
  // initialization whether or not warm-up has completed. Defaults to true.
  google.protobuf.BoolValue wait_for_warm_on_init = 54;

  // If specified, outlier detection will be enabled for this upstream cluster.
  // Each of the configuration values can be overridden via
  // :ref:`runtime values <config_cluster_manager_cluster_runtime_outlier_detection>`.
  OutlierDetection outlier_detection = 19;

  // The interval for removing stale hosts from a cluster type
  // :ref:`ORIGINAL_DST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`.
  // Hosts are considered stale if they have not been used
  // as upstream destinations during this interval. New hosts are added
  // to original destination clusters on demand as new connections are
  // redirected to Envoy, causing the number of hosts in the cluster to
  // grow over time. Hosts that are not stale (they are actively used as
  // destinations) are kept in the cluster, which allows connections to
  // them remain open, saving the latency that would otherwise be spent
  // on opening new connections. If this setting is not specified, the
  // value defaults to 5000ms. For cluster types other than
  // :ref:`ORIGINAL_DST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`
  // this setting is ignored.
  google.protobuf.Duration cleanup_interval = 20 [(validate.rules).duration = {gt {}}];

  // Optional configuration used to bind newly established upstream connections.
  // This overrides any bind_config specified in the bootstrap proto.
  // If the address and port are empty, no bind will be performed.
  core.v3.BindConfig upstream_bind_config = 21;

  // Configuration for load balancing subsetting.
  LbSubsetConfig lb_subset_config = 22;

  // Optional configuration for the load balancing algorithm selected by
  // LbPolicy. Currently only
  // :ref:`RING_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.RING_HASH>`,
  // :ref:`MAGLEV<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.MAGLEV>` and
  // :ref:`LEAST_REQUEST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LEAST_REQUEST>`
  // has additional configuration options.
  // Specifying ring_hash_lb_config or maglev_lb_config or least_request_lb_config without setting the corresponding
  // LbPolicy will generate an error at runtime.
  oneof lb_config {
    // Optional configuration for the Ring Hash load balancing policy.
    RingHashLbConfig ring_hash_lb_config = 23;

    // Optional configuration for the Maglev load balancing policy.
    MaglevLbConfig maglev_lb_config = 52;

    // Optional configuration for the Original Destination load balancing policy.
    OriginalDstLbConfig original_dst_lb_config = 34;

    // Optional configuration for the LeastRequest load balancing policy.
    LeastRequestLbConfig least_request_lb_config = 37;

    // Optional configuration for the RoundRobin load balancing policy.
    RoundRobinLbConfig round_robin_lb_config = 56;
  }

  // Common configuration for all load balancer implementations.
  CommonLbConfig common_lb_config = 27;

  // Optional custom transport socket implementation to use for upstream connections.
  // To setup TLS, set a transport socket with name ``envoy.transport_sockets.tls`` and
  // :ref:`UpstreamTlsContexts <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext>` in the ``typed_config``.
  // If no transport socket configuration is specified, new connections
  // will be set up with plaintext.
  core.v3.TransportSocket transport_socket = 24;

  // The Metadata field can be used to provide additional information about the
  // cluster. It can be used for stats, logging, and varying filter behavior.
  // Fields should use reverse DNS notation to denote which entity within Envoy
  // will need the information. For instance, if the metadata is intended for
  // the Router filter, the filter name should be specified as ``envoy.filters.http.router``.
  core.v3.Metadata metadata = 25;

  // Determines how Envoy selects the protocol used to speak to upstream hosts.
  // This has been deprecated in favor of setting explicit protocol selection
  // in the :ref:`http_protocol_options
  // <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
  // http_protocol_options can be set via the cluster's
  // :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
  ClusterProtocolSelection protocol_selection = 26
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Optional options for upstream connections.
  UpstreamConnectionOptions upstream_connection_options = 30;

  // If an upstream host becomes unhealthy (as determined by the configured health checks
  // or outlier detection), immediately close all connections to the failed host.
  //
  // .. note::
  //
  //   This is currently only supported for connections created by tcp_proxy.
  //
  // .. note::
  //
  //   The current implementation of this feature closes all connections immediately when
  //   the unhealthy status is detected. If there are a large number of connections open
  //   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
  //   time exclusively closing these connections, and not processing any other traffic.
  bool close_connections_on_host_health_failure = 31;

  // If set to true, Envoy will ignore the health value of a host when processing its removal
  // from service discovery. This means that if active health checking is used, Envoy will *not*
  // wait for the endpoint to go unhealthy before removing it.
  bool ignore_health_on_host_removal = 32;

  // An (optional) network filter chain, listed in the order the filters should be applied.
  // The chain will be applied to all outgoing connections that Envoy makes to the upstream
  // servers of this cluster.
  repeated Filter filters = 40;

  // If this field is set and is supported by the client, it will supersede the value of
  // :ref:`lb_policy<envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy>`.
  LoadBalancingPolicy load_balancing_policy = 41;

  // [#not-implemented-hide:]
  // If present, tells the client where to send load reports via LRS. If not present, the
  // client will fall back to a client-side default, which may be either (a) don't send any
  // load reports or (b) send load reports for all clusters to a single default server
  // (which may be configured in the bootstrap file).
  //
  // Note that if multiple clusters point to the same LRS server, the client may choose to
  // create a separate stream for each cluster or it may choose to coalesce the data for
  // multiple clusters onto a single stream. Either way, the client must make sure to send
  // the data for any given cluster on no more than one stream.
  //
  // [#next-major-version: In the v3 API, we should consider restructuring this somehow,
  // maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
  // from the LRS stream here.]
  core.v3.ConfigSource lrs_server = 42;

  // If track_timeout_budgets is true, the :ref:`timeout budget histograms
  // <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
  // request. These show what percentage of a request's per try and global timeout was used. A value
  // of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
  // of 100 would indicate that the request took the entirety of the timeout given to it.
  //
  // .. attention::
  //
  //   This field has been deprecated in favor of ``timeout_budgets``, part of
  //   :ref:`track_cluster_stats <envoy_v3_api_field_config.cluster.v3.Cluster.track_cluster_stats>`.
  bool track_timeout_budgets = 47
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Optional customization and configuration of upstream connection pool, and upstream type.
  //
  // Currently this field only applies for HTTP traffic but is designed for eventual use for custom
  // TCP upstreams.
  //
  // For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
  // HTTP, using the http connection pool and the codec from ``http2_protocol_options``
  //
  // For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
  // requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
  //
  // The default pool used is the generic connection pool which creates the HTTP upstream for most
  // HTTP requests, and the TCP upstream if CONNECT termination is configured.
  //
  // If users desire custom connection pool or upstream behavior, for example terminating
  // CONNECT only if a custom filter indicates it is appropriate, the custom factories
  // can be registered and configured here.
  // [#extension-category: envoy.upstreams]
  core.v3.TypedExtensionConfig upstream_config = 48;

  // Configuration to track optional cluster stats.
  TrackClusterStats track_cluster_stats = 49;

  // Preconnect configuration for this cluster.
  PreconnectPolicy preconnect_policy = 50;

  // If ``connection_pool_per_downstream_connection`` is true, the cluster will use a separate
  // connection pool for every downstream connection
  bool connection_pool_per_downstream_connection = 51;
}

// Extensible load balancing policy configuration.
//
// Every LB policy defined via this mechanism will be identified via a unique name using reverse
// DNS notation. If the policy needs configuration parameters, it must define a message for its
// own configuration, which will be stored in the config field. The name of the policy will tell
// clients which type of message they should expect to see in the config field.
//
// Note that there are cases where it is useful to be able to independently select LB policies
// for choosing a locality and for choosing an endpoint within that locality. For example, a
// given deployment may always use the same policy to choose the locality, but for choosing the
// endpoint within the locality, some clusters may use weighted-round-robin, while others may
// use some sort of session-based balancing.
//
// This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
// child LB policy for each locality. For each request, the parent chooses the locality and then
// delegates to the child policy for that locality to choose the endpoint within the locality.
//
// To facilitate this, the config message for the top-level LB policy may include a field of
// type LoadBalancingPolicy that specifies the child policy.
message LoadBalancingPolicy {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.LoadBalancingPolicy";

  message Policy {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.LoadBalancingPolicy.Policy";

    reserved 2, 1, 3;

    reserved "config", "name", "typed_config";

    // [#extension-category: envoy.load_balancing_policies]
    core.v3.TypedExtensionConfig typed_extension_config = 4;
  }

  // Each client will iterate over the list in order and stop at the first policy that it
  // supports. This provides a mechanism for starting to use new LB policies that are not yet
  // supported by all clients.
  repeated Policy policies = 1;
}

message UpstreamConnectionOptions {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.UpstreamConnectionOptions";

  // If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
  core.v3.TcpKeepalive tcp_keepalive = 1;

  // If enabled, associates the interface name of the local address with the upstream connection.
  // This can be used by extensions during processing of requests. The association mechanism is
  // implementation specific. Defaults to false due to performance concerns.
  bool set_local_interface_name_on_upstream_connections = 2;
}

message TrackClusterStats {
  // If timeout_budgets is true, the :ref:`timeout budget histograms
  // <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
  // request. These show what percentage of a request's per try and global timeout was used. A value
  // of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
  // of 100 would indicate that the request took the entirety of the timeout given to it.
  bool timeout_budgets = 1;

  // If request_response_sizes is true, then the :ref:`histograms
  // <config_cluster_manager_cluster_stats_request_response_sizes>`  tracking header and body sizes
  // of requests and responses will be published.
  bool request_response_sizes = 2;

  // If true, some stats will be emitted per-endpoint, similar to the stats in admin ``/clusters``
  // output.
  //
  // This does not currently output correct stats during a hot-restart.
  //
  // This is not currently implemented by all stat sinks.
  //
  // These stats do not honor filtering or tag extraction rules in :ref:`StatsConfig
  // <envoy_v3_api_msg_config.metrics.v3.StatsConfig>` (but fixed-value tags are supported). Admin
  // endpoint filtering is supported.
  //
  // This may not be used at the same time as
  // :ref:`load_stats_config <envoy_v3_api_field_config.bootstrap.v3.ClusterManager.load_stats_config>`.
  bool per_endpoint_stats = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/config/endpoint/v3:pkg",
        "//envoy/type/metadata/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/core/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.config.cluster.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/type/v3/percent.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.cluster.v3";
option java_outer_classname = "CircuitBreakerProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3;clusterv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Circuit breakers]

// :ref:`Circuit breaking<arch_overview_circuit_break>` settings can be
// specified individually for each defined priority.
message CircuitBreakers {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.cluster.CircuitBreakers";

  // A Thresholds defines CircuitBreaker settings for a
  // :ref:`RoutingPriority<envoy_v3_api_enum_config.core.v3.RoutingPriority>`.
  // [#next-free-field: 9]
  message Thresholds {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.cluster.CircuitBreakers.Thresholds";

    message RetryBudget {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.cluster.CircuitBreakers.Thresholds.RetryBudget";

      // Specifies the limit on concurrent retries as a percentage of the sum of active requests and
      // active pending requests. For example, if there are 100 active requests and the
      // budget_percent is set to 25, there may be 25 active retries.
      //
      // This parameter is optional. Defaults to 20%.
      type.v3.Percent budget_percent = 1;

      // Specifies the minimum retry concurrency allowed for the retry budget. The limit on the
      // number of active retries may never go below this number.
      //
      // This parameter is optional. Defaults to 3.
      google.protobuf.UInt32Value min_retry_concurrency = 2;
    }

    // The :ref:`RoutingPriority<envoy_v3_api_enum_config.core.v3.RoutingPriority>`
    // the specified CircuitBreaker settings apply to.
    core.v3.RoutingPriority priority = 1 [(validate.rules).enum = {defined_only: true}];

    // The maximum number of connections that Envoy will make to the upstream
    // cluster. If not specified, the default is 1024.
    google.protobuf.UInt32Value max_connections = 2;

    // The maximum number of pending requests that Envoy will allow to the
    // upstream cluster. If not specified, the default is 1024.
    // This limit is applied as a connection limit for non-HTTP traffic.
    google.protobuf.UInt32Value max_pending_requests = 3;

    // The maximum number of parallel requests that Envoy will make to the
    // upstream cluster. If not specified, the default is 1024.
    // This limit does not apply to non-HTTP traffic.
    google.protobuf.UInt32Value max_requests = 4;

    // The maximum number of parallel retries that Envoy will allow to the
    // upstream cluster. If not specified, the default is 3.
    google.protobuf.UInt32Value max_retries = 5;

    // Specifies a limit on concurrent retries in relation to the number of active requests. This
    // parameter is optional.
    //
    // .. note::
    //
    //    If this field is set, the retry budget will override any configured retry circuit
    //    breaker.
    RetryBudget retry_budget = 8;

    // If track_remaining is true, then stats will be published that expose
    // the number of resources remaining until the circuit breakers open. If
    // not specified, the default is false.
    //
    // .. note::
    //
    //    If a retry budget is used in lieu of the max_retries circuit breaker,
    //    the remaining retry resources remaining will not be tracked.
    bool track_remaining = 6;

    // The maximum number of connection pools per cluster that Envoy will concurrently support at
    // once. If not specified, the default is unlimited. Set this for clusters which create a
    // large number of connection pools. See
    // :ref:`Circuit Breaking <arch_overview_circuit_break_cluster_maximum_connection_pools>` for
    // more details.
    google.protobuf.UInt32Value max_connection_pools = 7;
  }

  // If multiple :ref:`Thresholds<envoy_v3_api_msg_config.cluster.v3.CircuitBreakers.Thresholds>`
  // are defined with the same :ref:`RoutingPriority<envoy_v3_api_enum_config.core.v3.RoutingPriority>`,
  // the first one in the list is used. If no Thresholds is defined for a given
  // :ref:`RoutingPriority<envoy_v3_api_enum_config.core.v3.RoutingPriority>`, the default values
  // are used.
  repeated Thresholds thresholds = 1;

  // Optional per-host limits which apply to each individual host in a cluster.
  //
  // .. note::
  //  currently only the :ref:`max_connections
  //  <envoy_v3_api_field_config.cluster.v3.CircuitBreakers.Thresholds.max_connections>` field is supported for per-host limits.
  //
  // If multiple per-host :ref:`Thresholds<envoy_v3_api_msg_config.cluster.v3.CircuitBreakers.Thresholds>`
  // are defined with the same :ref:`RoutingPriority<envoy_v3_api_enum_config.core.v3.RoutingPriority>`,
  // the first one in the list is used. If no per-host Thresholds are defined for a given
  // :ref:`RoutingPriority<envoy_v3_api_enum_config.core.v3.RoutingPriority>`,
  // the cluster will not have per-host limits.
  repeated Thresholds per_host_thresholds = 2;
}
syntax = "proto3";

package envoy.config.listener.v2;

import "google/protobuf/any.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.listener.v2";
option java_outer_classname = "ApiListenerProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/listener/v2;listenerv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.config.listener.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: API listener]

// Describes a type of API listener, which is used in non-proxy clients. The type of API
// exposed to the non-proxy application depends on the type of API listener.
message ApiListener {
  // The type in this field determines the type of API listener. At present, the following
  // types are supported:
  // envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager (HTTP)
  // [#next-major-version: In the v3 API, replace this Any field with a oneof containing the
  // specific config message for each type of API listener. We could not do this in v2 because
  // it would have caused circular dependencies for go protos: lds.proto depends on this file,
  // and http_connection_manager.proto depends on rds.proto, which is in the same directory as
  // lds.proto, so lds.proto cannot depend on this file.]
  google.protobuf.Any api_listener = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.listener.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/protocol.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.listener.v3";
option java_outer_classname = "QuicConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3;listenerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: QUIC listener config]

// Configuration specific to the UDP QUIC listener.
// [#next-free-field: 10]
message QuicProtocolOptions {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.listener.QuicProtocolOptions";

  core.v3.QuicProtocolOptions quic_protocol_options = 1;

  // Maximum number of milliseconds that connection will be alive when there is
  // no network activity.
  //
  // If it is less than 1ms, Envoy will use 1ms. 300000ms if not specified.
  google.protobuf.Duration idle_timeout = 2;

  // Connection timeout in milliseconds before the crypto handshake is finished.
  //
  // If it is less than 5000ms, Envoy will use 5000ms. 20000ms if not specified.
  google.protobuf.Duration crypto_handshake_timeout = 3;

  // Runtime flag that controls whether the listener is enabled or not. If not specified, defaults
  // to enabled.
  core.v3.RuntimeFeatureFlag enabled = 4;

  // A multiplier to number of connections which is used to determine how many packets to read per
  // event loop. A reasonable number should allow the listener to process enough payload but not
  // starve TCP and other UDP sockets and also prevent long event loop duration.
  // The default value is 32. This means if there are N QUIC connections, the total number of
  // packets to read in each read event will be 32 * N.
  // The actual number of packets to read in total by the UDP listener is also
  // bound by 6000, regardless of this field or how many connections there are.
  google.protobuf.UInt32Value packets_to_read_to_connection_count_ratio = 5
      [(validate.rules).uint32 = {gte: 1}];

  // Configure which implementation of ``quic::QuicCryptoClientStreamBase`` to be used for this listener.
  // If not specified the :ref:`QUICHE default one configured by <envoy_v3_api_msg_extensions.quic.crypto_stream.v3.CryptoServerStreamConfig>` will be used.
  // [#extension-category: envoy.quic.server.crypto_stream]
  core.v3.TypedExtensionConfig crypto_stream_config = 6;

  // Configure which implementation of ``quic::ProofSource`` to be used for this listener.
  // If not specified the :ref:`default one configured by <envoy_v3_api_msg_extensions.quic.proof_source.v3.ProofSourceConfig>` will be used.
  // [#extension-category: envoy.quic.proof_source]
  core.v3.TypedExtensionConfig proof_source_config = 7;

  // Config which implementation of ``quic::ConnectionIdGeneratorInterface`` to be used for this listener.
  // If not specified the :ref:`default one configured by <envoy_v3_api_msg_extensions.quic.connection_id_generator.v3.DeterministicConnectionIdGeneratorConfig>` will be used.
  // [#extension-category: envoy.quic.connection_id_generator]
  core.v3.TypedExtensionConfig connection_id_generator_config = 8;

  // Configure the server's preferred address to advertise so that client can migrate to it. See :ref:`example <envoy_v3_api_msg_extensions.quic.server_preferred_address.v3.FixedServerPreferredAddressConfig>` which configures a pair of v4 and v6 preferred addresses.
  // The current QUICHE implementation will advertise only one of the preferred IPv4 and IPv6 addresses based on the address family the client initially connects with, and only if the client is also QUICHE-based.
  // If not specified, Envoy will not advertise any server's preferred address.
  // [#extension-category: envoy.quic.server_preferred_address]
  core.v3.TypedExtensionConfig server_preferred_address_config = 9
      [(xds.annotations.v3.field_status).work_in_progress = true];
}
syntax = "proto3";

package envoy.config.listener.v3;

import "google/protobuf/any.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.config.listener.v3";
option java_outer_classname = "ApiListenerProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3;listenerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: API listener]

// Describes a type of API listener, which is used in non-proxy clients. The type of API
// exposed to the non-proxy application depends on the type of API listener.
message ApiListener {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.listener.v2.ApiListener";

  // The type in this field determines the type of API listener. At present, the following
  // types are supported:
  // envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager (HTTP)
  // envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager (HTTP)
  // [#next-major-version: In the v3 API, replace this Any field with a oneof containing the
  // specific config message for each type of API listener. We could not do this in v2 because
  // it would have caused circular dependencies for go protos: lds.proto depends on this file,
  // and http_connection_manager.proto depends on rds.proto, which is in the same directory as
  // lds.proto, so lds.proto cannot depend on this file.]
  google.protobuf.Any api_listener = 1;
}
syntax = "proto3";

package envoy.config.listener.v3;

import "envoy/config/accesslog/v3/accesslog.proto";
import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/socket_option.proto";
import "envoy/config/listener/v3/api_listener.proto";
import "envoy/config/listener/v3/listener_components.proto";
import "envoy/config/listener/v3/udp_listener_config.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";
import "xds/core/v3/collection_entry.proto";
import "xds/type/matcher/v3/matcher.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/security.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.listener.v3";
option java_outer_classname = "ListenerProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3;listenerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Listener configuration]
// Listener :ref:`configuration overview <config_listeners>`

// The additional address the listener is listening on.
message AdditionalAddress {
  core.v3.Address address = 1;

  // Additional socket options that may not be present in Envoy source code or
  // precompiled binaries. If specified, this will override the
  // :ref:`socket_options <envoy_v3_api_field_config.listener.v3.Listener.socket_options>`
  // in the listener. If specified with no
  // :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`
  // or an empty list of :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`,
  // it means no socket option will apply.
  core.v3.SocketOptionsOverride socket_options = 2;
}

// Listener list collections. Entries are ``Listener`` resources or references.
// [#not-implemented-hide:]
message ListenerCollection {
  repeated xds.core.v3.CollectionEntry entries = 1;
}

// [#next-free-field: 35]
message Listener {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.Listener";

  enum DrainType {
    // Drain in response to calling /healthcheck/fail admin endpoint (along with the health check
    // filter), listener removal/modification, and hot restart.
    DEFAULT = 0;

    // Drain in response to listener removal/modification and hot restart. This setting does not
    // include /healthcheck/fail. This setting may be desirable if Envoy is hosting both ingress
    // and egress listeners.
    MODIFY_ONLY = 1;
  }

  // [#not-implemented-hide:]
  message DeprecatedV1 {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.Listener.DeprecatedV1";

    // Whether the listener should bind to the port. A listener that doesn't
    // bind can only receive connections redirected from other listeners that
    // set use_original_dst parameter to true. Default is true.
    //
    // This is deprecated. Use :ref:`Listener.bind_to_port
    // <envoy_v3_api_field_config.listener.v3.Listener.bind_to_port>`
    google.protobuf.BoolValue bind_to_port = 1;
  }

  // Configuration for listener connection balancing.
  message ConnectionBalanceConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.Listener.ConnectionBalanceConfig";

    // A connection balancer implementation that does exact balancing. This means that a lock is
    // held during balancing so that connection counts are nearly exactly balanced between worker
    // threads. This is "nearly" exact in the sense that a connection might close in parallel thus
    // making the counts incorrect, but this should be rectified on the next accept. This balancer
    // sacrifices accept throughput for accuracy and should be used when there are a small number of
    // connections that rarely cycle (e.g., service mesh gRPC egress).
    message ExactBalance {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.Listener.ConnectionBalanceConfig.ExactBalance";
    }

    oneof balance_type {
      option (validate.required) = true;

      // If specified, the listener will use the exact connection balancer.
      ExactBalance exact_balance = 1;

      // The listener will use the connection balancer according to ``type_url``. If ``type_url`` is invalid,
      // Envoy will not attempt to balance active connections between worker threads.
      // [#extension-category: envoy.network.connection_balance]
      core.v3.TypedExtensionConfig extend_balance = 2;
    }
  }

  // Configuration for envoy internal listener. All the future internal listener features should be added here.
  message InternalListenerConfig {
  }

  reserved 14, 23;

  // The unique name by which this listener is known. If no name is provided,
  // Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
  // updated or removed via :ref:`LDS <config_listeners_lds>` a unique name must be provided.
  string name = 1;

  // The address that the listener should listen on. In general, the address must be unique, though
  // that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
  // Linux as the actual port will be allocated by the OS.
  // Required unless ``api_listener`` or ``listener_specifier`` is populated.
  core.v3.Address address = 2;

  // The additional addresses the listener should listen on. The addresses must be unique across all
  // listeners. Multiple addresses with port 0 can be supplied. When using multiple addresses in a single listener,
  // all addresses use the same protocol, and multiple internal addresses are not supported.
  repeated AdditionalAddress additional_addresses = 33;

  // Optional prefix to use on listener stats. If empty, the stats will be rooted at
  // ``listener.<address as string>.``. If non-empty, stats will be rooted at
  // ``listener.<stat_prefix>.``.
  string stat_prefix = 28;

  // A list of filter chains to consider for this listener. The
  // :ref:`FilterChain <envoy_v3_api_msg_config.listener.v3.FilterChain>` with the most specific
  // :ref:`FilterChainMatch <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>` criteria is used on a
  // connection.
  //
  // Example using SNI for filter chain selection can be found in the
  // :ref:`FAQ entry <faq_how_to_setup_sni>`.
  repeated FilterChain filter_chains = 3;

  // :ref:`Matcher API <arch_overview_matching_listener>` resolving the filter chain name from the
  // network properties. This matcher is used as a replacement for the filter chain match condition
  // :ref:`filter_chain_match
  // <envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match>`. If specified, all
  // :ref:`filter_chains <envoy_v3_api_field_config.listener.v3.Listener.filter_chains>` must have a
  // non-empty and unique :ref:`name <envoy_v3_api_field_config.listener.v3.FilterChain.name>` field
  // and not specify :ref:`filter_chain_match
  // <envoy_v3_api_field_config.listener.v3.FilterChain.filter_chain_match>` field.
  //
  // .. note::
  //
  //  Once matched, each connection is permanently bound to its filter chain.
  //  If the matcher changes but the filter chain remains the same, the
  //  connections bound to the filter chain are not drained. If, however, the
  //  filter chain is removed or structurally modified, then the drain for its
  //  connections is initiated.
  xds.type.matcher.v3.Matcher filter_chain_matcher = 32
      [(xds.annotations.v3.field_status).work_in_progress = true];

  // If a connection is redirected using ``iptables``, the port on which the proxy
  // receives it might be different from the original destination address. When this flag is set to
  // true, the listener hands off redirected connections to the listener associated with the
  // original destination address. If there is no listener associated with the original destination
  // address, the connection is handled by the listener that receives it. Defaults to false.
  google.protobuf.BoolValue use_original_dst = 4;

  // The default filter chain if none of the filter chain matches. If no default filter chain is supplied,
  // the connection will be closed. The filter chain match is ignored in this field.
  FilterChain default_filter_chain = 25;

  // Soft limit on size of the listeners new connection read and write buffers.
  // If unspecified, an implementation defined default is applied (1MiB).
  google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5
      [(udpa.annotations.security).configure_for_untrusted_downstream = true];

  // Listener metadata.
  core.v3.Metadata metadata = 6;

  // [#not-implemented-hide:]
  DeprecatedV1 deprecated_v1 = 7
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // The type of draining to perform at a listener-wide level.
  DrainType drain_type = 8;

  // Listener filters have the opportunity to manipulate and augment the connection metadata that
  // is used in connection filter chain matching, for example. These filters are run before any in
  // :ref:`filter_chains <envoy_v3_api_field_config.listener.v3.Listener.filter_chains>`. Order matters as the
  // filters are processed sequentially right after a socket has been accepted by the listener, and
  // before a connection is created.
  // UDP Listener filters can be specified when the protocol in the listener socket address in
  // :ref:`protocol <envoy_v3_api_field_config.core.v3.SocketAddress.protocol>` is :ref:`UDP
  // <envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP>` and no
  // :ref:`quic_options <envoy_v3_api_field_config.listener.v3.UdpListenerConfig.quic_options>` is specified in :ref:`udp_listener_config <envoy_v3_api_field_config.listener.v3.Listener.udp_listener_config>`.
  // QUIC listener filters can be specified when :ref:`quic_options
  // <envoy_v3_api_field_config.listener.v3.UdpListenerConfig.quic_options>` is
  // specified in :ref:`udp_listener_config <envoy_v3_api_field_config.listener.v3.Listener.udp_listener_config>`.
  // They are processed sequentially right before connection creation. And like TCP Listener filters, they can be used to manipulate the connection metadata and socket. But the difference is that they can't be used to pause connection creation.
  repeated ListenerFilter listener_filters = 9;

  // The timeout to wait for all listener filters to complete operation. If the timeout is reached,
  // the accepted socket is closed without a connection being created unless
  // ``continue_on_listener_filters_timeout`` is set to true. Specify 0 to disable the
  // timeout. If not specified, a default timeout of 15s is used.
  google.protobuf.Duration listener_filters_timeout = 15;

  // Whether a connection should be created when listener filters timeout. Default is false.
  //
  // .. attention::
  //
  //   Some listener filters, such as :ref:`Proxy Protocol filter
  //   <config_listener_filters_proxy_protocol>`, should not be used with this option. It will cause
  //   unexpected behavior when a connection is created.
  bool continue_on_listener_filters_timeout = 17;

  // Whether the listener should be set as a transparent socket.
  // When this flag is set to true, connections can be redirected to the listener using an
  // ``iptables`` ``TPROXY`` target, in which case the original source and destination addresses and
  // ports are preserved on accepted connections. This flag should be used in combination with
  // :ref:`an original_dst <config_listener_filters_original_dst>` :ref:`listener filter
  // <envoy_v3_api_field_config.listener.v3.Listener.listener_filters>` to mark the connections' local addresses as
  // "restored." This can be used to hand off each redirected connection to another listener
  // associated with the connection's destination address. Direct connections to the socket without
  // using ``TPROXY`` cannot be distinguished from connections redirected using ``TPROXY`` and are
  // therefore treated as if they were redirected.
  // When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
  // Setting this flag requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
  // When this flag is not set (default), the socket is not modified, i.e. the transparent option
  // is neither set nor reset.
  google.protobuf.BoolValue transparent = 10;

  // Whether the listener should set the ``IP_FREEBIND`` socket option. When this
  // flag is set to true, listeners can be bound to an IP address that is not
  // configured on the system running Envoy. When this flag is set to false, the
  // option ``IP_FREEBIND`` is disabled on the socket. When this flag is not set
  // (default), the socket is not modified, i.e. the option is neither enabled
  // nor disabled.
  google.protobuf.BoolValue freebind = 11;

  // Additional socket options that may not be present in Envoy source code or
  // precompiled binaries. The socket options can be updated for a listener when
  // :ref:`enable_reuse_port <envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port>`
  // is ``true``. Otherwise, if socket options change during a listener update the update will be rejected
  // to make it clear that the options were not updated.
  repeated core.v3.SocketOption socket_options = 13;

  // Whether the listener should accept TCP Fast Open (TFO) connections.
  // When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
  // the socket, with a queue length of the specified size
  // (see `details in RFC7413 <https://tools.ietf.org/html/rfc7413#section-5.1>`_).
  // When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
  // When this flag is not set (default), the socket is not modified,
  // i.e. the option is neither enabled nor disabled.
  //
  // On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
  // TCP_FASTOPEN.
  // See `ip-sysctl.txt <https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt>`_.
  //
  // On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
  // To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
  google.protobuf.UInt32Value tcp_fast_open_queue_length = 12;

  // Specifies the intended direction of the traffic relative to the local Envoy.
  // This property is required on Windows for listeners using the original destination filter,
  // see :ref:`Original Destination <config_listener_filters_original_dst>`.
  core.v3.TrafficDirection traffic_direction = 16;

  // If the protocol in the listener socket address in :ref:`protocol
  // <envoy_v3_api_field_config.core.v3.SocketAddress.protocol>` is :ref:`UDP
  // <envoy_v3_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP>`, this field specifies UDP
  // listener specific configuration.
  UdpListenerConfig udp_listener_config = 18;

  // Used to represent an API listener, which is used in non-proxy clients. The type of API
  // exposed to the non-proxy application depends on the type of API listener.
  // When this field is set, no other field except for :ref:`name<envoy_v3_api_field_config.listener.v3.Listener.name>`
  // should be set.
  //
  // .. note::
  //
  //  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
  //  not LDS.
  //
  // [#next-major-version: In the v3 API, instead of this messy approach where the socket
  // listener fields are directly in the top-level Listener message and the API listener types
  // are in the ApiListener message, the socket listener messages should be in their own message,
  // and the top-level Listener should essentially be a oneof that selects between the
  // socket listener and the various types of API listener. That way, a given Listener message
  // can structurally only contain the fields of the relevant type.]
  ApiListener api_listener = 19;

  // The listener's connection balancer configuration, currently only applicable to TCP listeners.
  // If no configuration is specified, Envoy will not attempt to balance active connections between
  // worker threads.
  //
  // In the scenario that the listener X redirects all the connections to the listeners Y1 and Y2
  // by setting :ref:`use_original_dst <envoy_v3_api_field_config.listener.v3.Listener.use_original_dst>` in X
  // and :ref:`bind_to_port <envoy_v3_api_field_config.listener.v3.Listener.bind_to_port>` to false in Y1 and Y2,
  // it is recommended to disable the balance config in listener X to avoid the cost of balancing, and
  // enable the balance config in Y1 and Y2 to balance the connections among the workers.
  ConnectionBalanceConfig connection_balance_config = 20;

  // Deprecated. Use ``enable_reuse_port`` instead.
  bool reuse_port = 21 [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // When this flag is set to true, listeners set the ``SO_REUSEPORT`` socket option and
  // create one socket for each worker thread. This makes inbound connections
  // distribute among worker threads roughly evenly in cases where there are a high number
  // of connections. When this flag is set to false, all worker threads share one socket. This field
  // defaults to true. The change of field will be rejected during an listener update when the
  // runtime flag ``envoy.reloadable_features.enable_update_listener_socket_options`` is enabled.
  // Otherwise, the update of this field will be ignored quietly.
  //
  // .. attention::
  //
  //   Although this field defaults to true, it has different behavior on different platforms. See
  //   the following text for more information.
  //
  // * On Linux, reuse_port is respected for both TCP and UDP listeners. It also works correctly
  //   with hot restart.
  // * On macOS, reuse_port for TCP does not do what it does on Linux. Instead of load balancing,
  //   the last socket wins and receives all connections/packets. For TCP, reuse_port is force
  //   disabled and the user is warned. For UDP, it is enabled, but only one worker will receive
  //   packets. For QUIC/H3, SW routing will send packets to other workers. For "raw" UDP, only
  //   a single worker will currently receive packets.
  // * On Windows, reuse_port for TCP has undefined behavior. It is force disabled and the user
  //   is warned similar to macOS. It is left enabled for UDP with undefined behavior currently.
  google.protobuf.BoolValue enable_reuse_port = 29;

  // Configuration for :ref:`access logs <arch_overview_access_logs>`
  // emitted by this listener.
  repeated accesslog.v3.AccessLog access_log = 22;

  // The maximum length a tcp listener's pending connections queue can grow to. If no value is
  // provided net.core.somaxconn will be used on Linux and 128 otherwise.
  google.protobuf.UInt32Value tcp_backlog_size = 24;

  // The maximum number of connections to accept from the kernel per socket
  // event. Envoy may decide to close these connections after accepting them
  // from the kernel e.g. due to load shedding, or other policies.
  // If there are more than max_connections_to_accept_per_socket_event
  // connections pending accept, connections over this threshold will be
  // accepted in later event loop iterations.
  // If no value is provided Envoy will accept all connections pending accept
  // from the kernel.
  google.protobuf.UInt32Value max_connections_to_accept_per_socket_event = 34
      [(validate.rules).uint32 = {gt: 0}];

  // Whether the listener should bind to the port. A listener that doesn't
  // bind can only receive connections redirected from other listeners that set
  // :ref:`use_original_dst <envoy_v3_api_field_config.listener.v3.Listener.use_original_dst>`
  // to true. Default is true.
  google.protobuf.BoolValue bind_to_port = 26;

  // The exclusive listener type and the corresponding config.
  oneof listener_specifier {
    // Used to represent an internal listener which does not listen on OSI L4 address but can be used by the
    // :ref:`envoy cluster <envoy_v3_api_msg_config.cluster.v3.Cluster>` to create a user space connection to.
    // The internal listener acts as a TCP listener. It supports listener filters and network filter chains.
    // Upstream clusters refer to the internal listeners by their :ref:`name
    // <envoy_v3_api_field_config.listener.v3.Listener.name>`. :ref:`Address
    // <envoy_v3_api_field_config.listener.v3.Listener.address>` must not be set on the internal listeners.
    //
    // There are some limitations that are derived from the implementation. The known limitations include:
    //
    // * :ref:`ConnectionBalanceConfig <envoy_v3_api_msg_config.listener.v3.Listener.ConnectionBalanceConfig>` is not
    //   allowed because both the cluster connection and the listener connection must be owned by the same dispatcher.
    // * :ref:`tcp_backlog_size <envoy_v3_api_field_config.listener.v3.Listener.tcp_backlog_size>`
    // * :ref:`freebind <envoy_v3_api_field_config.listener.v3.Listener.freebind>`
    // * :ref:`transparent <envoy_v3_api_field_config.listener.v3.Listener.transparent>`
    InternalListenerConfig internal_listener = 27;
  }

  // Enable MPTCP (multi-path TCP) on this listener. Clients will be allowed to establish
  // MPTCP connections. Non-MPTCP clients will fall back to regular TCP.
  bool enable_mptcp = 30;

  // Whether the listener should limit connections based upon the value of
  // :ref:`global_downstream_max_connections <config_overload_manager_limiting_connections>`.
  bool ignore_global_conn_limit = 31;
}

// A placeholder proto so that users can explicitly configure the standard
// Listener Manager via the bootstrap's :ref:`listener_manager <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.listener_manager>`.
// [#not-implemented-hide:]
message ListenerManager {
}

// A placeholder proto so that users can explicitly configure the standard
// Validation Listener Manager via the bootstrap's :ref:`listener_manager <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.listener_manager>`.
// [#not-implemented-hide:]
message ValidationListenerManager {
}

// A placeholder proto so that users can explicitly configure the API
// Listener Manager via the bootstrap's :ref:`listener_manager <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.listener_manager>`.
// [#not-implemented-hide:]
message ApiListenerManager {
}
syntax = "proto3";

package envoy.config.listener.v3;

import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/config_source.proto";
import "envoy/type/v3/range.proto";

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.listener.v3";
option java_outer_classname = "ListenerComponentsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3;listenerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Listener components]
// Listener :ref:`configuration overview <config_listeners>`

// [#next-free-field: 6]
message Filter {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.listener.Filter";

  reserved 3, 2;

  reserved "config";

  // The name of the filter configuration.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  oneof config_type {
    // Filter specific configuration which depends on the filter being
    // instantiated. See the supported filters for further documentation.
    // [#extension-category: envoy.filters.network]
    google.protobuf.Any typed_config = 4;

    // Configuration source specifier for an extension configuration discovery
    // service. In case of a failure and without the default configuration, the
    // listener closes the connections.
    core.v3.ExtensionConfigSource config_discovery = 5;
  }
}

// Specifies the match criteria for selecting a specific filter chain for a
// listener.
//
// In order for a filter chain to be selected, *ALL* of its criteria must be
// fulfilled by the incoming connection, properties of which are set by the
// networking stack and/or listener filters.
//
// The following order applies:
//
// 1. Destination port.
// 2. Destination IP address.
// 3. Server name (e.g. SNI for TLS protocol),
// 4. Transport protocol.
// 5. Application protocols (e.g. ALPN for TLS protocol).
// 6. Directly connected source IP address (this will only be different from the source IP address
//    when using a listener filter that overrides the source address, such as the :ref:`Proxy Protocol
//    listener filter <config_listener_filters_proxy_protocol>`).
// 7. Source type (e.g. any, local or external network).
// 8. Source IP address.
// 9. Source port.
//
// For criteria that allow ranges or wildcards, the most specific value in any
// of the configured filter chains that matches the incoming connection is going
// to be used (e.g. for SNI ``www.example.com`` the most specific match would be
// ``www.example.com``, then ``*.example.com``, then ``*.com``, then any filter
// chain without ``server_names`` requirements).
//
// A different way to reason about the filter chain matches:
// Suppose there exists N filter chains. Prune the filter chain set using the above 8 steps.
// In each step, filter chains which most specifically matches the attributes continue to the next step.
// The listener guarantees at most 1 filter chain is left after all of the steps.
//
// Example:
//
// For destination port, filter chains specifying the destination port of incoming traffic are the
// most specific match. If none of the filter chains specifies the exact destination port, the filter
// chains which do not specify ports are the most specific match. Filter chains specifying the
// wrong port can never be the most specific match.
//
// [#comment: Implemented rules are kept in the preference order, with deprecated fields
// listed at the end, because that's how we want to list them in the docs.
//
// [#comment:TODO(PiotrSikora): Add support for configurable precedence of the rules]
// [#next-free-field: 14]
message FilterChainMatch {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.listener.FilterChainMatch";

  enum ConnectionSourceType {
    // Any connection source matches.
    ANY = 0;

    // Match a connection originating from the same host.
    SAME_IP_OR_LOOPBACK = 1;

    // Match a connection originating from a different host.
    EXTERNAL = 2;
  }

  reserved 1;

  // Optional destination port to consider when use_original_dst is set on the
  // listener in determining a filter chain match.
  google.protobuf.UInt32Value destination_port = 8 [(validate.rules).uint32 = {lte: 65535 gte: 1}];

  // If non-empty, an IP address and prefix length to match addresses when the
  // listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
  repeated core.v3.CidrRange prefix_ranges = 3;

  // If non-empty, an IP address and suffix length to match addresses when the
  // listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
  // [#not-implemented-hide:]
  string address_suffix = 4;

  // [#not-implemented-hide:]
  google.protobuf.UInt32Value suffix_len = 5;

  // The criteria is satisfied if the directly connected source IP address of the downstream
  // connection is contained in at least one of the specified subnets. If the parameter is not
  // specified or the list is empty, the directly connected source IP address is ignored.
  repeated core.v3.CidrRange direct_source_prefix_ranges = 13;

  // Specifies the connection source IP match type. Can be any, local or external network.
  ConnectionSourceType source_type = 12 [(validate.rules).enum = {defined_only: true}];

  // The criteria is satisfied if the source IP address of the downstream
  // connection is contained in at least one of the specified subnets. If the
  // parameter is not specified or the list is empty, the source IP address is
  // ignored.
  repeated core.v3.CidrRange source_prefix_ranges = 6;

  // The criteria is satisfied if the source port of the downstream connection
  // is contained in at least one of the specified ports. If the parameter is
  // not specified, the source port is ignored.
  repeated uint32 source_ports = 7
      [(validate.rules).repeated = {items {uint32 {lte: 65535 gte: 1}}}];

  // If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining
  // a filter chain match. Those values will be compared against the server names of a new
  // connection, when detected by one of the listener filters.
  //
  // The server name will be matched against all wildcard domains, i.e. ``www.example.com``
  // will be first matched against ``www.example.com``, then ``*.example.com``, then ``*.com``.
  //
  // Note that partial wildcards are not supported, and values like ``*w.example.com`` are invalid.
  // The value ``*`` is also not supported, and ``server_names`` should be omitted instead.
  //
  // .. attention::
  //
  //   See the :ref:`FAQ entry <faq_how_to_setup_sni>` on how to configure SNI for more
  //   information.
  repeated string server_names = 11;

  // If non-empty, a transport protocol to consider when determining a filter chain match.
  // This value will be compared against the transport protocol of a new connection, when
  // it's detected by one of the listener filters.
  //
  // Suggested values include:
  //
  // * ``raw_buffer`` - default, used when no transport protocol is detected,
  // * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
  //   when TLS protocol is detected.
  string transport_protocol = 9;

  // If non-empty, a list of application protocols (e.g. ALPN for TLS protocol) to consider when
  // determining a filter chain match. Those values will be compared against the application
  // protocols of a new connection, when detected by one of the listener filters.
  //
  // Suggested values include:
  //
  // * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
  //   <config_listener_filters_tls_inspector>`,
  // * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
  //
  // .. attention::
  //
  //   Currently, only :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides
  //   application protocol detection based on the requested
  //   `ALPN <https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_ values.
  //
  //   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
  //   and matching on values other than ``h2`` is going to lead to a lot of false negatives,
  //   unless all connecting clients are known to use ALPN.
  repeated string application_protocols = 10;
}

// A filter chain wraps a set of match criteria, an option TLS context, a set of filters, and
// various other parameters.
// [#next-free-field: 10]
message FilterChain {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.listener.FilterChain";

  // The configuration for on-demand filter chain. If this field is not empty in FilterChain message,
  // a filter chain will be built on-demand.
  // On-demand filter chains help speedup the warming up of listeners since the building and initialization of
  // an on-demand filter chain will be postponed to the arrival of new connection requests that require this filter chain.
  // Filter chains that are not often used can be set as on-demand.
  message OnDemandConfiguration {
    // The timeout to wait for filter chain placeholders to complete rebuilding.
    // 1. If this field is set to 0, timeout is disabled.
    // 2. If not specified, a default timeout of 15s is used.
    // Rebuilding will wait until dependencies are ready, have failed, or this timeout is reached.
    // Upon failure or timeout, all connections related to this filter chain will be closed.
    // Rebuilding will start again on the next new connection.
    google.protobuf.Duration rebuild_timeout = 1;
  }

  reserved 2;

  reserved "tls_context";

  // The criteria to use when matching a connection to this filter chain.
  FilterChainMatch filter_chain_match = 1;

  // A list of individual network filters that make up the filter chain for
  // connections established with the listener. Order matters as the filters are
  // processed sequentially as connection events happen. Note: If the filter
  // list is empty, the connection will close by default.
  //
  // For QUIC listeners, network filters other than HTTP Connection Manager (HCM)
  // can be created, but due to differences in the connection implementation compared
  // to TCP, the onData() method will never be called. Therefore, network filters
  // for QUIC listeners should only expect to do work at the start of a new connection
  // (i.e. in onNewConnection()). HCM must be the last (or only) filter in the chain.
  repeated Filter filters = 3;

  // Whether the listener should expect a PROXY protocol V1 header on new
  // connections. If this option is enabled, the listener will assume that that
  // remote address of the connection is the one specified in the header. Some
  // load balancers including the AWS ELB support this option. If the option is
  // absent or set to false, Envoy will use the physical peer address of the
  // connection as the remote address.
  //
  // This field is deprecated. Add a
  // :ref:`PROXY protocol listener filter <config_listener_filters_proxy_protocol>`
  // explicitly instead.
  google.protobuf.BoolValue use_proxy_proto = 4
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // [#not-implemented-hide:] filter chain metadata.
  core.v3.Metadata metadata = 5;

  // Optional custom transport socket implementation to use for downstream connections.
  // To setup TLS, set a transport socket with name ``envoy.transport_sockets.tls`` and
  // :ref:`DownstreamTlsContext <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.DownstreamTlsContext>` in the ``typed_config``.
  // If no transport socket configuration is specified, new connections
  // will be set up with plaintext.
  // [#extension-category: envoy.transport_sockets.downstream]
  core.v3.TransportSocket transport_socket = 6;

  // If present and nonzero, the amount of time to allow incoming connections to complete any
  // transport socket negotiations. If this expires before the transport reports connection
  // establishment, the connection is summarily closed.
  google.protobuf.Duration transport_socket_connect_timeout = 9;

  // The unique name (or empty) by which this filter chain is known.
  // Note: :ref:`filter_chain_matcher
  // <envoy_v3_api_field_config.listener.v3.Listener.filter_chain_matcher>`
  // requires that filter chains are uniquely named within a listener.
  string name = 7;

  // [#not-implemented-hide:] The configuration to specify whether the filter chain will be built on-demand.
  // If this field is not empty, the filter chain will be built on-demand.
  // Otherwise, the filter chain will be built normally and block listener warming.
  OnDemandConfiguration on_demand_configuration = 8;
}

// Listener filter chain match configuration. This is a recursive structure which allows complex
// nested match configurations to be built using various logical operators.
//
// Examples:
//
// * Matches if the destination port is 3306.
//
// .. code-block:: yaml
//
//  destination_port_range:
//   start: 3306
//   end: 3307
//
// * Matches if the destination port is 3306 or 15000.
//
// .. code-block:: yaml
//
//  or_match:
//    rules:
//      - destination_port_range:
//          start: 3306
//          end: 3307
//      - destination_port_range:
//          start: 15000
//          end: 15001
//
// [#next-free-field: 6]
message ListenerFilterChainMatchPredicate {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.listener.ListenerFilterChainMatchPredicate";

  // A set of match configurations used for logical operations.
  message MatchSet {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet";

    // The list of rules that make up the set.
    repeated ListenerFilterChainMatchPredicate rules = 1
        [(validate.rules).repeated = {min_items: 2}];
  }

  oneof rule {
    option (validate.required) = true;

    // A set that describes a logical OR. If any member of the set matches, the match configuration
    // matches.
    MatchSet or_match = 1;

    // A set that describes a logical AND. If all members of the set match, the match configuration
    // matches.
    MatchSet and_match = 2;

    // A negation match. The match configuration will match if the negated match condition matches.
    ListenerFilterChainMatchPredicate not_match = 3;

    // The match configuration will always match.
    bool any_match = 4 [(validate.rules).bool = {const: true}];

    // Match destination port. Particularly, the match evaluation must use the recovered local port if
    // the owning listener filter is after :ref:`an original_dst listener filter <config_listener_filters_original_dst>`.
    type.v3.Int32Range destination_port_range = 5;
  }
}

// [#next-free-field: 6]
message ListenerFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.listener.ListenerFilter";

  reserved 2;

  reserved "config";

  // The name of the filter configuration.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  oneof config_type {
    // Filter specific configuration which depends on the filter being
    // instantiated. See the supported filters for further documentation.
    // [#extension-category: envoy.filters.listener,envoy.filters.udp_listener]
    google.protobuf.Any typed_config = 3;

    // Configuration source specifier for an extension configuration discovery
    // service. In case of a failure and without the default configuration, the
    // listener closes the connections.
    core.v3.ExtensionConfigSource config_discovery = 5;
  }

  // Optional match predicate used to disable the filter. The filter is enabled when this field is empty.
  // See :ref:`ListenerFilterChainMatchPredicate <envoy_v3_api_msg_config.listener.v3.ListenerFilterChainMatchPredicate>`
  // for further examples.
  ListenerFilterChainMatchPredicate filter_disabled = 4;
}
syntax = "proto3";

package envoy.config.listener.v3;

import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/udp_socket_config.proto";
import "envoy/config/listener/v3/quic_config.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.config.listener.v3";
option java_outer_classname = "UdpListenerConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3;listenerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: UDP listener config]
// Listener :ref:`configuration overview <config_listeners>`

// [#next-free-field: 9]
message UdpListenerConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.listener.UdpListenerConfig";

  reserved 1, 2, 3, 4, 6;

  reserved "config";

  // UDP socket configuration for the listener. The default for
  // :ref:`prefer_gro <envoy_v3_api_field_config.core.v3.UdpSocketConfig.prefer_gro>` is false for
  // listener sockets. If receiving a large amount of datagrams from a small number of sources, it
  // may be worthwhile to enable this option after performance testing.
  core.v3.UdpSocketConfig downstream_socket_config = 5;

  // Configuration for QUIC protocol. If empty, QUIC will not be enabled on this listener. Set
  // to the default object to enable QUIC without modifying any additional options.
  QuicProtocolOptions quic_options = 7;

  // Configuration for the UDP packet writer. If empty, HTTP/3 will use GSO if available
  // (:ref:`UdpDefaultWriterFactory <envoy_v3_api_msg_extensions.udp_packet_writer.v3.UdpGsoBatchWriterFactory>`)
  // or the default kernel sendmsg if not,
  // (:ref:`UdpDefaultWriterFactory <envoy_v3_api_msg_extensions.udp_packet_writer.v3.UdpDefaultWriterFactory>`)
  // and raw UDP will use kernel sendmsg.
  // [#extension-category: envoy.udp_packet_writer]
  core.v3.TypedExtensionConfig udp_packet_packet_writer_config = 8;
}

message ActiveRawUdpListenerConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.listener.ActiveRawUdpListenerConfig";
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/accesslog/v3:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
        "@com_github_cncf_xds//xds/core/v3:pkg",
        "@com_github_cncf_xds//xds/type/matcher/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.config.trace.v2;

import "envoy/api/v2/core/grpc_service.proto";

import "opencensus/proto/trace/v1/trace_config.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v2";
option java_outer_classname = "OpencensusProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v2;tracev2";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: OpenCensus tracer]

// Configuration for the OpenCensus tracer.
// [#next-free-field: 15]
// [#extension: envoy.tracers.opencensus]
message OpenCensusConfig {
  enum TraceContext {
    // No-op default, no trace context is utilized.
    NONE = 0;

    // W3C Trace-Context format "traceparent:" header.
    TRACE_CONTEXT = 1;

    // Binary "grpc-trace-bin:" header.
    GRPC_TRACE_BIN = 2;

    // "X-Cloud-Trace-Context:" header.
    CLOUD_TRACE_CONTEXT = 3;

    // X-B3-* headers.
    B3 = 4;
  }

  reserved 7;

  // Configures tracing, e.g. the sampler, max number of annotations, etc.
  opencensus.proto.trace.v1.TraceConfig trace_config = 1;

  // Enables the stdout exporter if set to true. This is intended for debugging
  // purposes.
  bool stdout_exporter_enabled = 2;

  // Enables the Stackdriver exporter if set to true. The project_id must also
  // be set.
  bool stackdriver_exporter_enabled = 3;

  // The Cloud project_id to use for Stackdriver tracing.
  string stackdriver_project_id = 4;

  // (optional) By default, the Stackdriver exporter will connect to production
  // Stackdriver. If stackdriver_address is non-empty, it will instead connect
  // to this address, which is in the gRPC format:
  // https://github.com/grpc/grpc/blob/master/doc/naming.md
  string stackdriver_address = 10;

  // (optional) The gRPC server that hosts Stackdriver tracing service. Only
  // Google gRPC is supported. If :ref:`target_uri <envoy_v3_api_field_config.core.v3.GrpcService.GoogleGrpc.target_uri>`
  // is not provided, the default production Stackdriver address will be used.
  api.v2.core.GrpcService stackdriver_grpc_service = 13;

  // Enables the Zipkin exporter if set to true. The url and service name must
  // also be set.
  bool zipkin_exporter_enabled = 5;

  // The URL to Zipkin, e.g. "http://127.0.0.1:9411/api/v2/spans"
  string zipkin_url = 6;

  // Enables the OpenCensus Agent exporter if set to true. The ocagent_address or
  // ocagent_grpc_service must also be set.
  bool ocagent_exporter_enabled = 11;

  // The address of the OpenCensus Agent, if its exporter is enabled, in gRPC
  // format: https://github.com/grpc/grpc/blob/master/doc/naming.md
  // [#comment:TODO: deprecate this field]
  string ocagent_address = 12;

  // (optional) The gRPC server hosted by the OpenCensus Agent. Only Google gRPC is supported.
  // This is only used if the ocagent_address is left empty.
  api.v2.core.GrpcService ocagent_grpc_service = 14;

  // List of incoming trace context headers we will accept. First one found
  // wins.
  repeated TraceContext incoming_trace_context = 8;

  // List of outgoing trace context headers we will produce.
  repeated TraceContext outgoing_trace_context = 9;
}
syntax = "proto3";

package envoy.config.trace.v2;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v2";
option java_outer_classname = "LightstepProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v2;tracev2";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: LightStep tracer]

// Configuration for the LightStep tracer.
// [#extension: envoy.tracers.lightstep]
message LightstepConfig {
  // Available propagation modes
  enum PropagationMode {
    // Propagate trace context in the single header x-ot-span-context.
    ENVOY = 0;

    // Propagate trace context using LightStep's native format.
    LIGHTSTEP = 1;

    // Propagate trace context using the b3 format.
    B3 = 2;

    // Propagation trace context using the w3 trace-context standard.
    TRACE_CONTEXT = 3;
  }

  // The cluster manager cluster that hosts the LightStep collectors.
  string collector_cluster = 1 [(validate.rules).string = {min_bytes: 1}];

  // File containing the access token to the `LightStep
  // <https://lightstep.com/>`_ API.
  string access_token_file = 2 [(validate.rules).string = {min_bytes: 1}];

  // Propagation modes to use by LightStep's tracer.
  repeated PropagationMode propagation_modes = 3
      [(validate.rules).repeated = {items {enum {defined_only: true}}}];
}
syntax = "proto3";

package envoy.config.trace.v2;

import public "envoy/config/trace/v2/datadog.proto";
import public "envoy/config/trace/v2/dynamic_ot.proto";
import public "envoy/config/trace/v2/http_tracer.proto";
import public "envoy/config/trace/v2/lightstep.proto";
import public "envoy/config/trace/v2/opencensus.proto";
import public "envoy/config/trace/v2/service.proto";
import public "envoy/config/trace/v2/zipkin.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v2";
option java_outer_classname = "TraceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v2;tracev2";
syntax = "proto3";

package envoy.config.trace.v2;

import "envoy/api/v2/core/grpc_service.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v2";
option java_outer_classname = "ServiceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v2;tracev2";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Trace Service]

// Configuration structure.
message TraceServiceConfig {
  // The upstream gRPC cluster that hosts the metrics service.
  api.v2.core.GrpcService grpc_service = 1 [(validate.rules).message = {required: true}];
}
syntax = "proto3";

package envoy.config.trace.v2;

import "google/protobuf/any.proto";
import "google/protobuf/struct.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v2";
option java_outer_classname = "HttpTracerProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v2;tracev2";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Tracing]
// Tracing :ref:`architecture overview <arch_overview_tracing>`.

// The tracing configuration specifies settings for an HTTP tracer provider used by Envoy.
//
// Envoy may support other tracers in the future, but right now the HTTP tracer is the only one
// supported.
//
// .. attention::
//
//   Use of this message type has been deprecated in favor of direct use of
//   :ref:`Tracing.Http <envoy_api_msg_config.trace.v2.Tracing.Http>`.
message Tracing {
  // Configuration for an HTTP tracer provider used by Envoy.
  //
  // The configuration is defined by the
  // :ref:`HttpConnectionManager.Tracing <envoy_api_msg_config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing>`
  // :ref:`provider <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing.provider>`
  // field.
  message Http {
    // The name of the HTTP trace driver to instantiate. The name must match a
    // supported HTTP trace driver. Built-in trace drivers:
    //
    // - *envoy.tracers.lightstep*
    // - *envoy.tracers.zipkin*
    // - *envoy.tracers.dynamic_ot*
    // - *envoy.tracers.datadog*
    // - *envoy.tracers.opencensus*
    // - *envoy.tracers.xray*
    string name = 1 [(validate.rules).string = {min_bytes: 1}];

    // Trace driver specific configuration which depends on the driver being instantiated.
    // See the trace drivers for examples:
    //
    // - :ref:`LightstepConfig <envoy_api_msg_config.trace.v2.LightstepConfig>`
    // - :ref:`ZipkinConfig <envoy_api_msg_config.trace.v2.ZipkinConfig>`
    // - :ref:`DynamicOtConfig <envoy_api_msg_config.trace.v2.DynamicOtConfig>`
    // - :ref:`DatadogConfig <envoy_api_msg_config.trace.v2.DatadogConfig>`
    // - :ref:`OpenCensusConfig <envoy_api_msg_config.trace.v2.OpenCensusConfig>`
    // - :ref:`AWS X-Ray <envoy_api_msg_config.trace.v2alpha.XRayConfig>`
    oneof config_type {
      google.protobuf.Struct config = 2 [deprecated = true];

      google.protobuf.Any typed_config = 3;
    }
  }

  // Provides configuration for the HTTP tracer.
  Http http = 1;
}
syntax = "proto3";

package envoy.config.trace.v2;

import "google/protobuf/struct.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v2";
option java_outer_classname = "DynamicOtProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v2;tracev2";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Dynamically loadable OpenTracing tracer]

// DynamicOtConfig is used to dynamically load a tracer from a shared library
// that implements the `OpenTracing dynamic loading API
// <https://github.com/opentracing/opentracing-cpp>`_.
// [#extension: envoy.tracers.dynamic_ot]
message DynamicOtConfig {
  // Dynamic library implementing the `OpenTracing API
  // <https://github.com/opentracing/opentracing-cpp>`_.
  string library = 1 [(validate.rules).string = {min_bytes: 1}];

  // The configuration to use when creating a tracer from the given dynamic
  // library.
  google.protobuf.Struct config = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/api/v2/core:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@opencensus_proto//opencensus/proto/trace/v1:trace_config_proto",
    ],
)
syntax = "proto3";

package envoy.config.trace.v2;

import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v2";
option java_outer_classname = "ZipkinProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v2;tracev2";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Zipkin tracer]

// Configuration for the Zipkin tracer.
// [#extension: envoy.tracers.zipkin]
// [#next-free-field: 6]
message ZipkinConfig {
  // Available Zipkin collector endpoint versions.
  enum CollectorEndpointVersion {
    // Zipkin API v1, JSON over HTTP.
    // [#comment: The default implementation of Zipkin client before this field is added was only v1
    // and the way user configure this was by not explicitly specifying the version. Consequently,
    // before this is added, the corresponding Zipkin collector expected to receive v1 payload.
    // Hence the motivation of adding HTTP_JSON_V1 as the default is to avoid a breaking change when
    // user upgrading Envoy with this change. Furthermore, we also immediately deprecate this field,
    // since in Zipkin realm this v1 version is considered to be not preferable anymore.]
    HTTP_JSON_V1 = 0 [deprecated = true, (envoy.annotations.disallowed_by_default_enum) = true];

    // Zipkin API v2, JSON over HTTP.
    HTTP_JSON = 1;

    // Zipkin API v2, protobuf over HTTP.
    HTTP_PROTO = 2;

    // [#not-implemented-hide:]
    GRPC = 3;
  }

  // The cluster manager cluster that hosts the Zipkin collectors. Note that the
  // Zipkin cluster must be defined in the :ref:`Bootstrap static cluster
  // resources <envoy_api_field_config.bootstrap.v2.Bootstrap.StaticResources.clusters>`.
  string collector_cluster = 1 [(validate.rules).string = {min_bytes: 1}];

  // The API endpoint of the Zipkin service where the spans will be sent. When
  // using a standard Zipkin installation, the API endpoint is typically
  // /api/v1/spans, which is the default value.
  string collector_endpoint = 2 [(validate.rules).string = {min_bytes: 1}];

  // Determines whether a 128bit trace id will be used when creating a new
  // trace instance. The default value is false, which will result in a 64 bit trace id being used.
  bool trace_id_128bit = 3;

  // Determines whether client and server spans will share the same span context.
  // The default value is true.
  google.protobuf.BoolValue shared_span_context = 4;

  // Determines the selected collector endpoint version. By default, the ``HTTP_JSON_V1`` will be
  // used.
  CollectorEndpointVersion collector_endpoint_version = 5;
}
syntax = "proto3";

package envoy.config.trace.v2;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v2";
option java_outer_classname = "DatadogProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v2;tracev2";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Datadog tracer]

// Configuration for the Datadog tracer.
// [#extension: envoy.tracers.datadog]
message DatadogConfig {
  // The cluster to use for submitting traces to the Datadog agent.
  string collector_cluster = 1 [(validate.rules).string = {min_bytes: 1}];

  // The name used for the service when traces are generated by envoy.
  string service_name = 2 [(validate.rules).string = {min_bytes: 1}];
}
syntax = "proto3";

package envoy.config.trace.v3;

import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/grpc_service.proto";
import "envoy/config/core/v3/http_service.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v3";
option java_outer_classname = "OpentelemetryProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v3;tracev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: OpenTelemetry tracer]

// Configuration for the OpenTelemetry tracer.
//  [#extension: envoy.tracers.opentelemetry]
// [#next-free-field: 6]
message OpenTelemetryConfig {
  // The upstream gRPC cluster that will receive OTLP traces.
  // Note that the tracer drops traces if the server does not read data fast enough.
  // This field can be left empty to disable reporting traces to the gRPC service.
  // Only one of ``grpc_service``, ``http_service`` may be used.
  core.v3.GrpcService grpc_service = 1
      [(udpa.annotations.field_migrate).oneof_promotion = "otlp_exporter"];

  // The upstream HTTP cluster that will receive OTLP traces.
  // This field can be left empty to disable reporting traces to the HTTP service.
  // Only one of ``grpc_service``, ``http_service`` may be used.
  //
  // .. note::
  //
  //   Note: The ``request_headers_to_add`` property in the OTLP HTTP exporter service
  //   does not support the :ref:`format specifier <config_access_log_format>` as used for
  //   :ref:`HTTP access logging <config_access_log>`.
  //   The values configured are added as HTTP headers on the OTLP export request
  //   without any formatting applied.
  core.v3.HttpService http_service = 3
      [(udpa.annotations.field_migrate).oneof_promotion = "otlp_exporter"];

  // The name for the service. This will be populated in the ResourceSpan Resource attributes.
  // If it is not provided, it will default to "unknown_service:envoy".
  string service_name = 2;

  // An ordered list of resource detectors
  // [#extension-category: envoy.tracers.opentelemetry.resource_detectors]
  repeated core.v3.TypedExtensionConfig resource_detectors = 4;

  // Specifies the sampler to be used by the OpenTelemetry tracer.
  // The configured sampler implements the Sampler interface defined by the OpenTelemetry specification.
  // This field can be left empty. In this case, the default Envoy sampling decision is used.
  //
  // See: `OpenTelemetry sampler specification <https://opentelemetry.io/docs/specs/otel/trace/sdk/#sampler>`_
  // [#extension-category: envoy.tracers.opentelemetry.samplers]
  core.v3.TypedExtensionConfig sampler = 5;
}
syntax = "proto3";

package envoy.config.trace.v3;

import "envoy/config/core/v3/grpc_service.proto";

import "opencensus/proto/trace/v1/trace_config.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v3";
option java_outer_classname = "OpencensusProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v3;tracev3";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.tracers.opencensus.v4alpha";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: OpenCensus tracer]

// Configuration for the OpenCensus tracer.
// [#next-free-field: 15]
// [#extension: envoy.tracers.opencensus]
message OpenCensusConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.trace.v2.OpenCensusConfig";

  enum TraceContext {
    // No-op default, no trace context is utilized.
    NONE = 0;

    // W3C Trace-Context format "traceparent:" header.
    TRACE_CONTEXT = 1;

    // Binary "grpc-trace-bin:" header.
    GRPC_TRACE_BIN = 2;

    // "X-Cloud-Trace-Context:" header.
    CLOUD_TRACE_CONTEXT = 3;

    // X-B3-* headers.
    B3 = 4;
  }

  reserved 7;

  // Configures tracing, e.g. the sampler, max number of annotations, etc.
  opencensus.proto.trace.v1.TraceConfig trace_config = 1
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Enables the stdout exporter if set to true. This is intended for debugging
  // purposes.
  bool stdout_exporter_enabled = 2
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Enables the Stackdriver exporter if set to true. The project_id must also
  // be set.
  bool stackdriver_exporter_enabled = 3
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // The Cloud project_id to use for Stackdriver tracing.
  string stackdriver_project_id = 4
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // (optional) By default, the Stackdriver exporter will connect to production
  // Stackdriver. If stackdriver_address is non-empty, it will instead connect
  // to this address, which is in the gRPC format:
  // https://github.com/grpc/grpc/blob/master/doc/naming.md
  string stackdriver_address = 10
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // (optional) The gRPC server that hosts Stackdriver tracing service. Only
  // Google gRPC is supported. If :ref:`target_uri <envoy_v3_api_field_config.core.v3.GrpcService.GoogleGrpc.target_uri>`
  // is not provided, the default production Stackdriver address will be used.
  core.v3.GrpcService stackdriver_grpc_service = 13
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Enables the Zipkin exporter if set to true. The url and service name must
  // also be set. This is deprecated, prefer to use Envoy's :ref:`native Zipkin
  // tracer <envoy_v3_api_msg_config.trace.v3.ZipkinConfig>`.
  bool zipkin_exporter_enabled = 5
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // The URL to Zipkin, e.g. "http://127.0.0.1:9411/api/v2/spans". This is
  // deprecated, prefer to use Envoy's :ref:`native Zipkin tracer
  // <envoy_v3_api_msg_config.trace.v3.ZipkinConfig>`.
  string zipkin_url = 6
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Enables the OpenCensus Agent exporter if set to true. The ocagent_address or
  // ocagent_grpc_service must also be set.
  bool ocagent_exporter_enabled = 11
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // The address of the OpenCensus Agent, if its exporter is enabled, in gRPC
  // format: https://github.com/grpc/grpc/blob/master/doc/naming.md
  // [#comment:TODO: deprecate this field]
  string ocagent_address = 12
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // (optional) The gRPC server hosted by the OpenCensus Agent. Only Google gRPC is supported.
  // This is only used if the ocagent_address is left empty.
  core.v3.GrpcService ocagent_grpc_service = 14
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // List of incoming trace context headers we will accept. First one found
  // wins.
  repeated TraceContext incoming_trace_context = 8
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // List of outgoing trace context headers we will produce.
  repeated TraceContext outgoing_trace_context = 9
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];
}
syntax = "proto3";

package envoy.config.trace.v3;

import "envoy/config/core/v3/base.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v3";
option java_outer_classname = "LightstepProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v3;tracev3";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.tracers.lightstep.v4alpha";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: LightStep tracer]

// Configuration for the LightStep tracer.
// [#extension: envoy.tracers.lightstep]
// [#not-implemented-hide:]
message LightstepConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.trace.v2.LightstepConfig";

  // Available propagation modes
  enum PropagationMode {
    // Propagate trace context in the single header x-ot-span-context.
    ENVOY = 0;

    // Propagate trace context using LightStep's native format.
    LIGHTSTEP = 1;

    // Propagate trace context using the b3 format.
    B3 = 2;

    // Propagation trace context using the w3 trace-context standard.
    TRACE_CONTEXT = 3;
  }

  // The cluster manager cluster that hosts the LightStep collectors.
  string collector_cluster = 1 [(validate.rules).string = {min_len: 1}];

  // File containing the access token to the `LightStep
  // <https://lightstep.com/>`_ API.
  string access_token_file = 2
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Access token to the `LightStep <https://lightstep.com/>`_ API.
  core.v3.DataSource access_token = 4;

  // Propagation modes to use by LightStep's tracer.
  repeated PropagationMode propagation_modes = 3
      [(validate.rules).repeated = {items {enum {defined_only: true}}}];
}
syntax = "proto3";

package envoy.config.trace.v3;

import public "envoy/config/trace/v3/datadog.proto";
import public "envoy/config/trace/v3/dynamic_ot.proto";
import public "envoy/config/trace/v3/http_tracer.proto";
import public "envoy/config/trace/v3/lightstep.proto";
import public "envoy/config/trace/v3/opencensus.proto";
import public "envoy/config/trace/v3/opentelemetry.proto";
import public "envoy/config/trace/v3/service.proto";
import public "envoy/config/trace/v3/zipkin.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v3";
option java_outer_classname = "TraceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v3;tracev3";
syntax = "proto3";

package envoy.config.trace.v3;

import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/base.proto";

import "google/protobuf/struct.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v3";
option java_outer_classname = "XrayProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v3;tracev3";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.tracers.xray.v4alpha";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: AWS X-Ray Tracer Configuration]
// Configuration for AWS X-Ray tracer

// [#extension: envoy.tracers.xray]
message XRayConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.trace.v2alpha.XRayConfig";

  message SegmentFields {
    // The type of AWS resource, e.g. "AWS::AppMesh::Proxy".
    string origin = 1;

    // AWS resource metadata dictionary.
    // See: `X-Ray Segment Document documentation <https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html#api-segmentdocuments-aws>`__
    google.protobuf.Struct aws = 2;
  }

  // The UDP endpoint of the X-Ray Daemon where the spans will be sent.
  // If this value is not set, the default value of 127.0.0.1:2000 will be used.
  core.v3.SocketAddress daemon_endpoint = 1;

  // The name of the X-Ray segment.
  string segment_name = 2 [(validate.rules).string = {min_len: 1}];

  // The location of a local custom sampling rules JSON file.
  // For an example of the sampling rules see:
  // `X-Ray SDK documentation
  // <https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-go-configuration.html#xray-sdk-go-configuration-sampling>`_
  core.v3.DataSource sampling_rule_manifest = 3;

  // Optional custom fields to be added to each trace segment.
  // see: `X-Ray Segment Document documentation
  // <https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html>`__
  SegmentFields segment_fields = 4;
}
syntax = "proto3";

package envoy.config.trace.v3;

import "envoy/config/core/v3/grpc_service.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v3";
option java_outer_classname = "ServiceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v3;tracev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Trace Service]

// Configuration structure.
message TraceServiceConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.trace.v2.TraceServiceConfig";

  // The upstream gRPC cluster that hosts the metrics service.
  core.v3.GrpcService grpc_service = 1 [(validate.rules).message = {required: true}];
}
syntax = "proto3";

package envoy.config.trace.v3;

import "google/protobuf/any.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v3";
option java_outer_classname = "HttpTracerProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v3;tracev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Tracing]
// Tracing :ref:`architecture overview <arch_overview_tracing>`.

// The tracing configuration specifies settings for an HTTP tracer provider used by Envoy.
//
// Envoy may support other tracers in the future, but right now the HTTP tracer is the only one
// supported.
//
// .. attention::
//
//   Use of this message type has been deprecated in favor of direct use of
//   :ref:`Tracing.Http <envoy_v3_api_msg_config.trace.v3.Tracing.Http>`.
message Tracing {
  option (udpa.annotations.versioning).previous_message_type = "envoy.config.trace.v2.Tracing";

  // Configuration for an HTTP tracer provider used by Envoy.
  //
  // The configuration is defined by the
  // :ref:`HttpConnectionManager.Tracing <envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing>`
  // :ref:`provider <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.provider>`
  // field.
  message Http {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.trace.v2.Tracing.Http";

    reserved 2;

    reserved "config";

    // The name of the HTTP trace driver to instantiate. The name must match a
    // supported HTTP trace driver.
    // See the :ref:`extensions listed in typed_config below <extension_category_envoy.tracers>` for the default list of the HTTP trace driver.
    string name = 1 [(validate.rules).string = {min_len: 1}];

    // Trace driver specific configuration which must be set according to the driver being instantiated.
    // [#extension-category: envoy.tracers]
    oneof config_type {
      google.protobuf.Any typed_config = 3;
    }
  }

  // Provides configuration for the HTTP tracer.
  Http http = 1;
}
syntax = "proto3";

package envoy.config.trace.v3;

import "google/protobuf/struct.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v3";
option java_outer_classname = "DynamicOtProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v3;tracev3";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.tracers.dynamic_ot.v4alpha";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Dynamically loadable OpenTracing tracer]

// DynamicOtConfig is used to dynamically load a tracer from a shared library
// that implements the `OpenTracing dynamic loading API
// <https://github.com/opentracing/opentracing-cpp>`_.
// [#extension: envoy.tracers.dynamic_ot]
message DynamicOtConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.trace.v2.DynamicOtConfig";

  // Dynamic library implementing the `OpenTracing API
  // <https://github.com/opentracing/opentracing-cpp>`_.
  string library = 1 [
    deprecated = true,
    (validate.rules).string = {min_len: 1},
    (envoy.annotations.deprecated_at_minor_version) = "3.0"
  ];

  // The configuration to use when creating a tracer from the given dynamic
  // library.
  google.protobuf.Struct config = 2
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@opencensus_proto//opencensus/proto/trace/v1:trace_config_proto",
    ],
)
syntax = "proto3";

package envoy.config.trace.v3;

import "envoy/config/core/v3/grpc_service.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/sensitive.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v3";
option java_outer_classname = "SkywalkingProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v3;tracev3";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.tracers.skywalking.v4alpha";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: SkyWalking tracer]

// Configuration for the SkyWalking tracer. Please note that if SkyWalking tracer is used as the
// provider of tracing, then
// :ref:`spawn_upstream_span <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.spawn_upstream_span>`
// in the tracing config must be set to true to get the correct topology and tracing data. Moreover, SkyWalking
// Tracer does not support SkyWalking extension header (``sw8-x``) temporarily.
// [#extension: envoy.tracers.skywalking]
message SkyWalkingConfig {
  // SkyWalking collector service.
  core.v3.GrpcService grpc_service = 1 [(validate.rules).message = {required: true}];

  ClientConfig client_config = 2;
}

// Client config for SkyWalking tracer.
message ClientConfig {
  // Service name for SkyWalking tracer. If this field is empty, then local service cluster name
  // that configured by :ref:`Bootstrap node <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.node>`
  // message's :ref:`cluster <envoy_v3_api_field_config.core.v3.Node.cluster>` field or command line
  // option :option:`--service-cluster` will be used. If both this field and local service cluster
  // name are empty, ``EnvoyProxy`` is used as the service name by default.
  string service_name = 1;

  // Service instance name for SkyWalking tracer. If this field is empty, then local service node
  // that configured by :ref:`Bootstrap node <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.node>`
  // message's :ref:`id <envoy_v3_api_field_config.core.v3.Node.id>` field or command line  option
  // :option:`--service-node` will be used. If both this field and local service node are empty,
  // ``EnvoyProxy`` is used as the instance name by default.
  string instance_name = 2;

  // Authentication token config for SkyWalking. SkyWalking can use token authentication to secure
  // that monitoring application data can be trusted. In current version, Token is considered as a
  // simple string.
  // [#comment:TODO(wbpcode): Get backend token through the SDS API.]
  oneof backend_token_specifier {
    // Inline authentication token string.
    string backend_token = 3 [(udpa.annotations.sensitive) = true];
  }

  // Envoy caches the segment in memory when the SkyWalking backend service is temporarily unavailable.
  // This field specifies the maximum number of segments that can be cached. If not specified, the
  // default is 1024.
  google.protobuf.UInt32Value max_cache_size = 4;
}
syntax = "proto3";

package envoy.config.trace.v3;

import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v3";
option java_outer_classname = "ZipkinProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v3;tracev3";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.tracers.zipkin.v4alpha";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Zipkin tracer]

// Configuration for the Zipkin tracer.
// [#extension: envoy.tracers.zipkin]
// [#next-free-field: 8]
message ZipkinConfig {
  option (udpa.annotations.versioning).previous_message_type = "envoy.config.trace.v2.ZipkinConfig";

  // Available Zipkin collector endpoint versions.
  enum CollectorEndpointVersion {
    // Zipkin API v1, JSON over HTTP.
    // [#comment: The default implementation of Zipkin client before this field is added was only v1
    // and the way user configure this was by not explicitly specifying the version. Consequently,
    // before this is added, the corresponding Zipkin collector expected to receive v1 payload.
    // Hence the motivation of adding HTTP_JSON_V1 as the default is to avoid a breaking change when
    // user upgrading Envoy with this change. Furthermore, we also immediately deprecate this field,
    // since in Zipkin realm this v1 version is considered to be not preferable anymore.]
    DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE = 0
        [deprecated = true, (envoy.annotations.disallowed_by_default_enum) = true];

    // Zipkin API v2, JSON over HTTP.
    HTTP_JSON = 1;

    // Zipkin API v2, protobuf over HTTP.
    HTTP_PROTO = 2;

    // [#not-implemented-hide:]
    GRPC = 3;
  }

  // The cluster manager cluster that hosts the Zipkin collectors.
  string collector_cluster = 1 [(validate.rules).string = {min_len: 1}];

  // The API endpoint of the Zipkin service where the spans will be sent. When
  // using a standard Zipkin installation.
  string collector_endpoint = 2 [(validate.rules).string = {min_len: 1}];

  // Determines whether a 128bit trace id will be used when creating a new
  // trace instance. The default value is false, which will result in a 64 bit trace id being used.
  bool trace_id_128bit = 3;

  // Determines whether client and server spans will share the same span context.
  // The default value is true.
  google.protobuf.BoolValue shared_span_context = 4;

  // Determines the selected collector endpoint version.
  CollectorEndpointVersion collector_endpoint_version = 5;

  // Optional hostname to use when sending spans to the collector_cluster. Useful for collectors
  // that require a specific hostname. Defaults to :ref:`collector_cluster <envoy_v3_api_field_config.trace.v3.ZipkinConfig.collector_cluster>` above.
  string collector_hostname = 6;

  // If this is set to true, then Envoy will be treated as an independent hop in trace chain. A complete span pair will be created for a single
  // request. Server span will be created for the downstream request and client span will be created for the related upstream request.
  // This should be set to true in the following cases:
  //
  // * The Envoy Proxy is used as gateway or ingress.
  // * The Envoy Proxy is used as sidecar but inbound traffic capturing or outbound traffic capturing is disabled.
  // * Any case that the :ref:`start_child_span of router <envoy_v3_api_field_extensions.filters.http.router.v3.Router.start_child_span>` is set to true.
  //
  // .. attention::
  //
  //   If this is set to true, then the
  //   :ref:`start_child_span of router <envoy_v3_api_field_extensions.filters.http.router.v3.Router.start_child_span>`
  //   SHOULD be set to true also to ensure the correctness of trace chain.
  bool split_spans_for_request = 7;
}
syntax = "proto3";

package envoy.config.trace.v3;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v3";
option java_outer_classname = "DatadogProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v3;tracev3";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.tracers.datadog.v4alpha";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Datadog tracer]

// Configuration for the Datadog tracer.
// [#extension: envoy.tracers.datadog]
message DatadogConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.trace.v2.DatadogConfig";

  // The cluster to use for submitting traces to the Datadog agent.
  string collector_cluster = 1 [(validate.rules).string = {min_len: 1}];

  // The name used for the service when traces are generated by envoy.
  string service_name = 2 [(validate.rules).string = {min_len: 1}];

  // Optional hostname to use when sending spans to the collector_cluster. Useful for collectors
  // that require a specific hostname. Defaults to :ref:`collector_cluster <envoy_v3_api_field_config.trace.v3.DatadogConfig.collector_cluster>` above.
  string collector_hostname = 3;
}
syntax = "proto3";

package envoy.config.trace.v2alpha;

import "envoy/api/v2/core/address.proto";
import "envoy/api/v2/core/base.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.trace.v2alpha";
option java_outer_classname = "XrayProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/trace/v2alpha";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: AWS X-Ray Tracer Configuration]
// Configuration for AWS X-Ray tracer

message XRayConfig {
  // The UDP endpoint of the X-Ray Daemon where the spans will be sent.
  // If this value is not set, the default value of 127.0.0.1:2000 will be used.
  api.v2.core.SocketAddress daemon_endpoint = 1;

  // The name of the X-Ray segment.
  string segment_name = 2 [(validate.rules).string = {min_len: 1}];

  // The location of a local custom sampling rules JSON file.
  // For an example of the sampling rules see:
  // `X-Ray SDK documentation
  // <https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-go-configuration.html#xray-sdk-go-configuration-sampling>`_
  api.v2.core.DataSource sampling_rule_manifest = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.core.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "SocketOptionProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Socket option]

// Generic socket option message. This would be used to set socket options that
// might not exist in upstream kernels or precompiled Envoy binaries.
//
// For example:
//
// .. code-block:: json
//
//  {
//    "description": "support tcp keep alive",
//    "state": 0,
//    "level": 1,
//    "name": 9,
//    "int_value": 1,
//  }
//
// 1 means SOL_SOCKET and 9 means SO_KEEPALIVE on Linux.
// With the above configuration, `TCP Keep-Alives <https://www.freesoft.org/CIE/RFC/1122/114.htm>`_
// can be enabled in socket with Linux, which can be used in
// :ref:`listener's<envoy_v3_api_field_config.listener.v3.Listener.socket_options>` or
// :ref:`admin's <envoy_v3_api_field_config.bootstrap.v3.Admin.socket_options>` socket_options etc.
//
// It should be noted that the name or level may have different values on different platforms.
// [#next-free-field: 7]
message SocketOption {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.SocketOption";

  enum SocketState {
    // Socket options are applied after socket creation but before binding the socket to a port
    STATE_PREBIND = 0;

    // Socket options are applied after binding the socket to a port but before calling listen()
    STATE_BOUND = 1;

    // Socket options are applied after calling listen()
    STATE_LISTENING = 2;
  }

  // An optional name to give this socket option for debugging, etc.
  // Uniqueness is not required and no special meaning is assumed.
  string description = 1;

  // Corresponding to the level value passed to setsockopt, such as IPPROTO_TCP
  int64 level = 2;

  // The numeric name as passed to setsockopt
  int64 name = 3;

  oneof value {
    option (validate.required) = true;

    // Because many sockopts take an int value.
    int64 int_value = 4;

    // Otherwise it's a byte buffer.
    bytes buf_value = 5;
  }

  // The state in which the option will be applied. When used in BindConfig
  // STATE_PREBIND is currently the only valid value.
  SocketState state = 6 [(validate.rules).enum = {defined_only: true}];
}

message SocketOptionsOverride {
  repeated SocketOption socket_options = 1;
}
syntax = "proto3";

package envoy.config.core.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/event_service_config.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/type/matcher/v3/string.proto";
import "envoy/type/v3/http.proto";
import "envoy/type/v3/range.proto";

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "HealthCheckProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Health check]
// * Health checking :ref:`architecture overview <arch_overview_health_checking>`.
// * If health checking is configured for a cluster, additional statistics are emitted. They are
//   documented :ref:`here <config_cluster_manager_cluster_stats>`.

// Endpoint health status.
enum HealthStatus {
  // The health status is not known. This is interpreted by Envoy as ``HEALTHY``.
  UNKNOWN = 0;

  // Healthy.
  HEALTHY = 1;

  // Unhealthy.
  UNHEALTHY = 2;

  // Connection draining in progress. E.g.,
  // `<https://aws.amazon.com/blogs/aws/elb-connection-draining-remove-instances-from-service-with-care/>`_
  // or
  // `<https://cloud.google.com/compute/docs/load-balancing/enabling-connection-draining>`_.
  // This is interpreted by Envoy as ``UNHEALTHY``.
  DRAINING = 3;

  // Health check timed out. This is part of HDS and is interpreted by Envoy as
  // ``UNHEALTHY``.
  TIMEOUT = 4;

  // Degraded.
  DEGRADED = 5;
}

message HealthStatusSet {
  // An order-independent set of health status.
  repeated HealthStatus statuses = 1
      [(validate.rules).repeated = {items {enum {defined_only: true}}}];
}

// [#next-free-field: 26]
message HealthCheck {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.HealthCheck";

  // Describes the encoding of the payload bytes in the payload.
  message Payload {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.core.HealthCheck.Payload";

    oneof payload {
      option (validate.required) = true;

      // Hex encoded payload. E.g., "000000FF".
      string text = 1 [(validate.rules).string = {min_len: 1}];

      // Binary payload.
      bytes binary = 2;
    }
  }

  // [#next-free-field: 15]
  message HttpHealthCheck {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.core.HealthCheck.HttpHealthCheck";

    reserved 5, 7;

    reserved "service_name", "use_http2";

    // The value of the host header in the HTTP health check request. If
    // left empty (default value), the name of the cluster this health check is associated
    // with will be used. The host header can be customized for a specific endpoint by setting the
    // :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>` field.
    string host = 1 [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];

    // Specifies the HTTP path that will be requested during health checking. For example
    // ``/healthcheck``.
    string path = 2
        [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_VALUE strict: false}];

    // [#not-implemented-hide:] HTTP specific payload.
    Payload send = 3;

    // Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
    // If it is set, both the expected response check and status code determine the health check.
    // When checking the response, fuzzy matching is performed such that each payload block must be found,
    // and in the order specified, but not necessarily contiguous.
    //
    // .. note::
    //
    //   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
    //   The default buffer size is 1024 bytes when it is not set.
    repeated Payload receive = 4;

    // Specifies the size of response buffer in bytes that is used to Payload match.
    // The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
    google.protobuf.UInt64Value response_buffer_size = 14 [(validate.rules).uint64 = {gte: 0}];

    // Specifies a list of HTTP headers that should be added to each request that is sent to the
    // health checked cluster. For more information, including details on header value syntax, see
    // the documentation on :ref:`custom request headers
    // <config_http_conn_man_headers_custom_request_headers>`.
    repeated HeaderValueOption request_headers_to_add = 6
        [(validate.rules).repeated = {max_items: 1000}];

    // Specifies a list of HTTP headers that should be removed from each request that is sent to the
    // health checked cluster.
    repeated string request_headers_to_remove = 8 [(validate.rules).repeated = {
      items {string {well_known_regex: HTTP_HEADER_NAME strict: false}}
    }];

    // Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
    // 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
    // semantics of :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each
    // range are required. Only statuses in the range [100, 600) are allowed.
    repeated type.v3.Int64Range expected_statuses = 9;

    // Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
    // will count towards the configured :ref:`unhealthy_threshold <envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold>`,
    // but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
    // :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each range are required.
    // Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
    // field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
    // be considered a successful health check. By default all responses not in
    // :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>` will result in
    // the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
    // non-200 response will result in the host being marked unhealthy.
    repeated type.v3.Int64Range retriable_statuses = 12;

    // Use specified application protocol for health checks.
    type.v3.CodecClientType codec_client_type = 10 [(validate.rules).enum = {defined_only: true}];

    // An optional service name parameter which is used to validate the identity of
    // the health checked cluster using a :ref:`StringMatcher
    // <envoy_v3_api_msg_type.matcher.v3.StringMatcher>`. See the :ref:`architecture overview
    // <arch_overview_health_checking_identity>` for more information.
    type.matcher.v3.StringMatcher service_name_matcher = 11;

    // HTTP Method that will be used for health checking, default is "GET".
    // GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
    // CONNECT method is disallowed because it is not appropriate for health check request.
    // If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`.
    RequestMethod method = 13 [(validate.rules).enum = {defined_only: true not_in: 6}];
  }

  message TcpHealthCheck {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.core.HealthCheck.TcpHealthCheck";

    // Empty payloads imply a connect-only health check.
    Payload send = 1;

    // When checking the response, fuzzy matching is performed such that each
    // payload block must be found, and in the order specified, but not
    // necessarily contiguous.
    repeated Payload receive = 2;
  }

  message RedisHealthCheck {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.core.HealthCheck.RedisHealthCheck";

    // If set, optionally perform ``EXISTS <key>`` instead of ``PING``. A return value
    // from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
    // than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
    // by setting the specified key to any value and waiting for traffic to drain.
    string key = 1;
  }

  // `grpc.health.v1.Health
  // <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_-based
  // healthcheck. See `gRPC doc <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_
  // for details.
  message GrpcHealthCheck {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.core.HealthCheck.GrpcHealthCheck";

    // An optional service name parameter which will be sent to gRPC service in
    // `grpc.health.v1.HealthCheckRequest
    // <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20>`_.
    // message. See `gRPC health-checking overview
    // <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ for more information.
    string service_name = 1;

    // The value of the :authority header in the gRPC health check request. If
    // left empty (default value), the name of the cluster this health check is associated
    // with will be used. The authority header can be customized for a specific endpoint by setting
    // the :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>` field.
    string authority = 2
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];

    // Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
    // that is sent to the health checked cluster. For more information, including details on header value syntax,
    // see the documentation on :ref:`custom request headers
    // <config_http_conn_man_headers_custom_request_headers>`.
    repeated HeaderValueOption initial_metadata = 3 [(validate.rules).repeated = {max_items: 1000}];
  }

  // Custom health check.
  message CustomHealthCheck {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.core.HealthCheck.CustomHealthCheck";

    reserved 2;

    reserved "config";

    // The registered name of the custom health checker.
    string name = 1 [(validate.rules).string = {min_len: 1}];

    // A custom health checker specific configuration which depends on the custom health checker
    // being instantiated. See :api:`envoy/config/health_checker` for reference.
    // [#extension-category: envoy.health_checkers]
    oneof config_type {
      google.protobuf.Any typed_config = 3;
    }
  }

  // Health checks occur over the transport socket specified for the cluster. This implies that if a
  // cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.
  //
  // This allows overriding the cluster TLS settings, just for health check connections.
  message TlsOptions {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.core.HealthCheck.TlsOptions";

    // Specifies the ALPN protocols for health check connections. This is useful if the
    // corresponding upstream is using ALPN-based :ref:`FilterChainMatch
    // <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>` along with different protocols for health checks
    // versus data connections. If empty, no ALPN protocols will be set on health check connections.
    repeated string alpn_protocols = 1;
  }

  reserved 10;

  // The time to wait for a health check response. If the timeout is reached the
  // health check attempt will be considered a failure.
  google.protobuf.Duration timeout = 1 [(validate.rules).duration = {
    required: true
    gt {}
  }];

  // The interval between health checks.
  google.protobuf.Duration interval = 2 [(validate.rules).duration = {
    required: true
    gt {}
  }];

  // An optional jitter amount in milliseconds. If specified, Envoy will start health
  // checking after for a random time in ms between 0 and initial_jitter. This only
  // applies to the first health check.
  google.protobuf.Duration initial_jitter = 20;

  // An optional jitter amount in milliseconds. If specified, during every
  // interval Envoy will add interval_jitter to the wait time.
  google.protobuf.Duration interval_jitter = 3;

  // An optional jitter amount as a percentage of interval_ms. If specified,
  // during every interval Envoy will add ``interval_ms`` *
  // ``interval_jitter_percent`` / 100 to the wait time.
  //
  // If interval_jitter_ms and interval_jitter_percent are both set, both of
  // them will be used to increase the wait time.
  uint32 interval_jitter_percent = 18;

  // The number of unhealthy health checks required before a host is marked
  // unhealthy. Note that for ``http`` health checking if a host responds with a code not in
  // :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
  // or :ref:`retriable_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses>`,
  // this threshold is ignored and the host is considered immediately unhealthy.
  google.protobuf.UInt32Value unhealthy_threshold = 4 [(validate.rules).message = {required: true}];

  // The number of healthy health checks required before a host is marked
  // healthy. Note that during startup, only a single successful health check is
  // required to mark a host healthy.
  google.protobuf.UInt32Value healthy_threshold = 5 [(validate.rules).message = {required: true}];

  // [#not-implemented-hide:] Non-serving port for health checking.
  google.protobuf.UInt32Value alt_port = 6;

  // Reuse health check connection between health checks. Default is true.
  google.protobuf.BoolValue reuse_connection = 7;

  oneof health_checker {
    option (validate.required) = true;

    // HTTP health check.
    HttpHealthCheck http_health_check = 8;

    // TCP health check.
    TcpHealthCheck tcp_health_check = 9;

    // gRPC health check.
    GrpcHealthCheck grpc_health_check = 11;

    // Custom health check.
    CustomHealthCheck custom_health_check = 13;
  }

  // The "no traffic interval" is a special health check interval that is used when a cluster has
  // never had traffic routed to it. This lower interval allows cluster information to be kept up to
  // date, without sending a potentially large amount of active health checking traffic for no
  // reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
  // standard health check interval that is defined. Note that this interval takes precedence over
  // any other.
  //
  // The default value for "no traffic interval" is 60 seconds.
  google.protobuf.Duration no_traffic_interval = 12 [(validate.rules).duration = {gt {}}];

  // The "no traffic healthy interval" is a special health check interval that
  // is used for hosts that are currently passing active health checking
  // (including new hosts) when the cluster has received no traffic.
  //
  // This is useful for when we want to send frequent health checks with
  // ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
  // a host in the cluster is marked as healthy.
  //
  // Once a cluster has been used for traffic routing, Envoy will shift back to using the
  // standard health check interval that is defined.
  //
  // If no_traffic_healthy_interval is not set, it will default to the
  // no traffic interval and send that interval regardless of health state.
  google.protobuf.Duration no_traffic_healthy_interval = 24 [(validate.rules).duration = {gt {}}];

  // The "unhealthy interval" is a health check interval that is used for hosts that are marked as
  // unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
  // standard health check interval that is defined.
  //
  // The default value for "unhealthy interval" is the same as "interval".
  google.protobuf.Duration unhealthy_interval = 14 [(validate.rules).duration = {gt {}}];

  // The "unhealthy edge interval" is a special health check interval that is used for the first
  // health check right after a host is marked as unhealthy. For subsequent health checks
  // Envoy will shift back to using either "unhealthy interval" if present or the standard health
  // check interval that is defined.
  //
  // The default value for "unhealthy edge interval" is the same as "unhealthy interval".
  google.protobuf.Duration unhealthy_edge_interval = 15 [(validate.rules).duration = {gt {}}];

  // The "healthy edge interval" is a special health check interval that is used for the first
  // health check right after a host is marked as healthy. For subsequent health checks
  // Envoy will shift back to using the standard health check interval that is defined.
  //
  // The default value for "healthy edge interval" is the same as the default interval.
  google.protobuf.Duration healthy_edge_interval = 16 [(validate.rules).duration = {gt {}}];

  // .. attention::
  // This field is deprecated in favor of the extension
  // :ref:`event_logger <envoy_v3_api_field_config.core.v3.HealthCheck.event_logger>` and
  // :ref:`event_log_path <envoy_v3_api_field_extensions.health_check.event_sinks.file.v3.HealthCheckEventFileSink.event_log_path>`
  // in the file sink extension.
  //
  // Specifies the path to the :ref:`health check event log <arch_overview_health_check_logging>`.
  string event_log_path = 17
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // A list of event log sinks to process the health check event.
  // [#extension-category: envoy.health_check.event_sinks]
  repeated TypedExtensionConfig event_logger = 25;

  // [#not-implemented-hide:]
  // The gRPC service for the health check event service.
  // If empty, health check events won't be sent to a remote endpoint.
  EventServiceConfig event_service = 22;

  // If set to true, health check failure events will always be logged. If set to false, only the
  // initial health check failure event will be logged.
  // The default value is false.
  bool always_log_health_check_failures = 19;

  // This allows overriding the cluster TLS settings, just for health check connections.
  TlsOptions tls_options = 21;

  // Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
  // :ref:`tranport socket matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`.
  // For example, the following match criteria
  //
  // .. code-block:: yaml
  //
  //  transport_socket_match_criteria:
  //    useMTLS: true
  //
  // Will match the following :ref:`cluster socket match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>`
  //
  // .. code-block:: yaml
  //
  //  transport_socket_matches:
  //  - name: "useMTLS"
  //    match:
  //      useMTLS: true
  //    transport_socket:
  //      name: envoy.transport_sockets.tls
  //      config: { ... } # tls socket configuration
  //
  // If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
  // :ref:`LbEndpoint.Metadata <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>`.
  // This allows using different transport socket capabilities for health checking versus proxying to the
  // endpoint.
  //
  // If the key/values pairs specified do not match any
  // :ref:`transport socket matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`,
  // the cluster's :ref:`transport socket <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket>`
  // will be used for health check socket configuration.
  google.protobuf.Struct transport_socket_match_criteria = 23;
}
syntax = "proto3";

package envoy.config.core.v3;

import "google/protobuf/any.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "ExtensionProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Extension configuration]

// Message type for extension configuration.
// [#next-major-version: revisit all existing typed_config that doesn't use this wrapper.].
message TypedExtensionConfig {
  // The name of an extension. This is not used to select the extension, instead
  // it serves the role of an opaque identifier.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // The typed config for the extension. The type URL will be used to identify
  // the extension. In the case that the type URL is ``xds.type.v3.TypedStruct``
  // (or, for historical reasons, ``udpa.type.v1.TypedStruct``), the inner type
  // URL of ``TypedStruct`` will be utilized. See the
  // :ref:`extension configuration overview
  // <config_overview_extension_configuration>` for further details.
  google.protobuf.Any typed_config = 2 [(validate.rules).any = {required: true}];
}
syntax = "proto3";

package envoy.config.core.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "ProxyProtocolProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Proxy protocol]

message ProxyProtocolPassThroughTLVs {
  enum PassTLVsMatchType {
    // Pass all TLVs.
    INCLUDE_ALL = 0;

    // Pass specific TLVs defined in tlv_type.
    INCLUDE = 1;
  }

  // The strategy to pass through TLVs. Default is INCLUDE_ALL.
  // If INCLUDE_ALL is set, all TLVs will be passed through no matter the tlv_type field.
  PassTLVsMatchType match_type = 1;

  // The TLV types that are applied based on match_type.
  // TLV type is defined as uint8_t in proxy protocol. See `the spec
  // <https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt>`_ for details.
  repeated uint32 tlv_type = 2 [(validate.rules).repeated = {items {uint32 {lt: 256}}}];
}

message ProxyProtocolConfig {
  enum Version {
    // PROXY protocol version 1. Human readable format.
    V1 = 0;

    // PROXY protocol version 2. Binary format.
    V2 = 1;
  }

  // The PROXY protocol version to use. See https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt for details
  Version version = 1;

  // This config controls which TLVs can be passed to upstream if it is Proxy Protocol
  // V2 header. If there is no setting for this field, no TLVs will be passed through.
  ProxyProtocolPassThroughTLVs pass_through_tlvs = 2;
}
syntax = "proto3";

package envoy.config.core.v3;

import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/backoff.proto";
import "envoy/config/core/v3/http_uri.proto";
import "envoy/type/v3/percent.proto";
import "envoy/type/v3/semantic_version.proto";

import "google/protobuf/any.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";

import "xds/core/v3/context_params.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "BaseProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common types]

// Envoy supports :ref:`upstream priority routing
// <arch_overview_http_routing_priority>` both at the route and the virtual
// cluster level. The current priority implementation uses different connection
// pool and circuit breaking settings for each priority level. This means that
// even for HTTP/2 requests, two physical connections will be used to an
// upstream host. In the future Envoy will likely support true HTTP/2 priority
// over a single upstream connection.
enum RoutingPriority {
  DEFAULT = 0;
  HIGH = 1;
}

// HTTP request method.
enum RequestMethod {
  METHOD_UNSPECIFIED = 0;
  GET = 1;
  HEAD = 2;
  POST = 3;
  PUT = 4;
  DELETE = 5;
  CONNECT = 6;
  OPTIONS = 7;
  TRACE = 8;
  PATCH = 9;
}

// Identifies the direction of the traffic relative to the local Envoy.
enum TrafficDirection {
  // Default option is unspecified.
  UNSPECIFIED = 0;

  // The transport is used for incoming traffic.
  INBOUND = 1;

  // The transport is used for outgoing traffic.
  OUTBOUND = 2;
}

// Identifies location of where either Envoy runs or where upstream hosts run.
message Locality {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.Locality";

  // Region this :ref:`zone <envoy_v3_api_field_config.core.v3.Locality.zone>` belongs to.
  string region = 1;

  // Defines the local service zone where Envoy is running. Though optional, it
  // should be set if discovery service routing is used and the discovery
  // service exposes :ref:`zone data <envoy_v3_api_field_config.endpoint.v3.LocalityLbEndpoints.locality>`,
  // either in this message or via :option:`--service-zone`. The meaning of zone
  // is context dependent, e.g. `Availability Zone (AZ)
  // <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html>`_
  // on AWS, `Zone <https://cloud.google.com/compute/docs/regions-zones/>`_ on
  // GCP, etc.
  string zone = 2;

  // When used for locality of upstream hosts, this field further splits zone
  // into smaller chunks of sub-zones so they can be load balanced
  // independently.
  string sub_zone = 3;
}

// BuildVersion combines SemVer version of extension with free-form build information
// (i.e. 'alpha', 'private-build') as a set of strings.
message BuildVersion {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.BuildVersion";

  // SemVer version of extension.
  type.v3.SemanticVersion version = 1;

  // Free-form build information.
  // Envoy defines several well known keys in the source/common/version/version.h file
  google.protobuf.Struct metadata = 2;
}

// Version and identification for an Envoy extension.
// [#next-free-field: 7]
message Extension {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.Extension";

  // This is the name of the Envoy filter as specified in the Envoy
  // configuration, e.g. envoy.filters.http.router, com.acme.widget.
  string name = 1;

  // Category of the extension.
  // Extension category names use reverse DNS notation. For instance "envoy.filters.listener"
  // for Envoy's built-in listener filters or "com.acme.filters.http" for HTTP filters from
  // acme.com vendor.
  // [#comment:TODO(yanavlasov): Link to the doc with existing envoy category names.]
  string category = 2;

  // [#not-implemented-hide:] Type descriptor of extension configuration proto.
  // [#comment:TODO(yanavlasov): Link to the doc with existing configuration protos.]
  // [#comment:TODO(yanavlasov): Add tests when PR #9391 lands.]
  string type_descriptor = 3
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // The version is a property of the extension and maintained independently
  // of other extensions and the Envoy API.
  // This field is not set when extension did not provide version information.
  BuildVersion version = 4;

  // Indicates that the extension is present but was disabled via dynamic configuration.
  bool disabled = 5;

  // Type URLs of extension configuration protos.
  repeated string type_urls = 6;
}

// Identifies a specific Envoy instance. The node identifier is presented to the
// management server, which may use this identifier to distinguish per Envoy
// configuration for serving.
// [#next-free-field: 13]
message Node {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.Node";

  reserved 5;

  reserved "build_version";

  // An opaque node identifier for the Envoy node. This also provides the local
  // service node name. It should be set if any of the following features are
  // used: :ref:`statsd <arch_overview_statistics>`, :ref:`CDS
  // <config_cluster_manager_cds>`, and :ref:`HTTP tracing
  // <arch_overview_tracing>`, either in this message or via
  // :option:`--service-node`.
  string id = 1;

  // Defines the local service cluster name where Envoy is running. Though
  // optional, it should be set if any of the following features are used:
  // :ref:`statsd <arch_overview_statistics>`, :ref:`health check cluster
  // verification
  // <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.service_name_matcher>`,
  // :ref:`runtime override directory <envoy_v3_api_msg_config.bootstrap.v3.Runtime>`,
  // :ref:`user agent addition
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.add_user_agent>`,
  // :ref:`HTTP global rate limiting <config_http_filters_rate_limit>`,
  // :ref:`CDS <config_cluster_manager_cds>`, and :ref:`HTTP tracing
  // <arch_overview_tracing>`, either in this message or via
  // :option:`--service-cluster`.
  string cluster = 2;

  // Opaque metadata extending the node identifier. Envoy will pass this
  // directly to the management server.
  google.protobuf.Struct metadata = 3;

  // Map from xDS resource type URL to dynamic context parameters. These may vary at runtime (unlike
  // other fields in this message). For example, the xDS client may have a shard identifier that
  // changes during the lifetime of the xDS client. In Envoy, this would be achieved by updating the
  // dynamic context on the Server::Instance's LocalInfo context provider. The shard ID dynamic
  // parameter then appears in this field during future discovery requests.
  map<string, xds.core.v3.ContextParams> dynamic_parameters = 12;

  // Locality specifying where the Envoy instance is running.
  Locality locality = 4;

  // Free-form string that identifies the entity requesting config.
  // E.g. "envoy" or "grpc"
  string user_agent_name = 6;

  oneof user_agent_version_type {
    // Free-form string that identifies the version of the entity requesting config.
    // E.g. "1.12.2" or "abcd1234", or "SpecialEnvoyBuild"
    string user_agent_version = 7;

    // Structured version of the entity requesting config.
    BuildVersion user_agent_build_version = 8;
  }

  // List of extensions and their versions supported by the node.
  repeated Extension extensions = 9;

  // Client feature support list. These are well known features described
  // in the Envoy API repository for a given major version of an API. Client features
  // use reverse DNS naming scheme, for example ``com.acme.feature``.
  // See :ref:`the list of features <client_features>` that xDS client may
  // support.
  repeated string client_features = 10;

  // Known listening ports on the node as a generic hint to the management server
  // for filtering :ref:`listeners <config_listeners>` to be returned. For example,
  // if there is a listener bound to port 80, the list can optionally contain the
  // SocketAddress ``(0.0.0.0,80)``. The field is optional and just a hint.
  repeated Address listening_addresses = 11
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];
}

// Metadata provides additional inputs to filters based on matched listeners,
// filter chains, routes and endpoints. It is structured as a map, usually from
// filter name (in reverse DNS format) to metadata specific to the filter. Metadata
// key-values for a filter are merged as connection and request handling occurs,
// with later values for the same key overriding earlier values.
//
// An example use of metadata is providing additional values to
// http_connection_manager in the envoy.http_connection_manager.access_log
// namespace.
//
// Another example use of metadata is to per service config info in cluster metadata, which may get
// consumed by multiple filters.
//
// For load balancing, Metadata provides a means to subset cluster endpoints.
// Endpoints have a Metadata object associated and routes contain a Metadata
// object to match against. There are some well defined metadata used today for
// this purpose:
//
// * ``{"envoy.lb": {"canary": <bool> }}`` This indicates the canary status of an
//   endpoint and is also used during header processing
//   (x-envoy-upstream-canary) and for stats purposes.
// [#next-major-version: move to type/metadata/v2]
message Metadata {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.Metadata";

  // Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*``
  // namespace is reserved for Envoy's built-in filters.
  // If both ``filter_metadata`` and
  // :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>`
  // fields are present in the metadata with same keys,
  // only ``typed_filter_metadata`` field will be parsed.
  map<string, google.protobuf.Struct> filter_metadata = 1;

  // Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*``
  // namespace is reserved for Envoy's built-in filters.
  // The value is encoded as google.protobuf.Any.
  // If both :ref:`filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.filter_metadata>`
  // and ``typed_filter_metadata`` fields are present in the metadata with same keys,
  // only ``typed_filter_metadata`` field will be parsed.
  map<string, google.protobuf.Any> typed_filter_metadata = 2;
}

// Runtime derived uint32 with a default when not specified.
message RuntimeUInt32 {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.RuntimeUInt32";

  // Default value if runtime value is not available.
  uint32 default_value = 2;

  // Runtime key to get value for comparison. This value is used if defined.
  string runtime_key = 3 [(validate.rules).string = {min_len: 1}];
}

// Runtime derived percentage with a default when not specified.
message RuntimePercent {
  // Default value if runtime value is not available.
  type.v3.Percent default_value = 1;

  // Runtime key to get value for comparison. This value is used if defined.
  string runtime_key = 2 [(validate.rules).string = {min_len: 1}];
}

// Runtime derived double with a default when not specified.
message RuntimeDouble {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.RuntimeDouble";

  // Default value if runtime value is not available.
  double default_value = 1;

  // Runtime key to get value for comparison. This value is used if defined.
  string runtime_key = 2 [(validate.rules).string = {min_len: 1}];
}

// Runtime derived bool with a default when not specified.
message RuntimeFeatureFlag {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.core.RuntimeFeatureFlag";

  // Default value if runtime value is not available.
  google.protobuf.BoolValue default_value = 1 [(validate.rules).message = {required: true}];

  // Runtime key to get value for comparison. This value is used if defined. The boolean value must
  // be represented via its
  // `canonical JSON encoding <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
  string runtime_key = 2 [(validate.rules).string = {min_len: 1}];
}

// Query parameter name/value pair.
message QueryParameter {
  // The key of the query parameter. Case sensitive.
  string key = 1 [(validate.rules).string = {min_len: 1}];

  // The value of the query parameter.
  string value = 2;
}

// Header name/value pair.
message HeaderValue {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.HeaderValue";

  // Header name.
  string key = 1
      [(validate.rules).string =
           {min_len: 1 max_bytes: 16384 well_known_regex: HTTP_HEADER_NAME strict: false}];

  // Header value.
  //
  // The same :ref:`format specifier <config_access_log_format>` as used for
  // :ref:`HTTP access logging <config_access_log>` applies here, however
  // unknown header values are replaced with the empty string instead of ``-``.
  // Header value is encoded as string. This does not work for non-utf8 characters.
  // Only one of ``value`` or ``raw_value`` can be set.
  string value = 2 [
    (validate.rules).string = {max_bytes: 16384 well_known_regex: HTTP_HEADER_VALUE strict: false},
    (udpa.annotations.field_migrate).oneof_promotion = "value_type"
  ];

  // Header value is encoded as bytes which can support non-utf8 characters.
  // Only one of ``value`` or ``raw_value`` can be set.
  bytes raw_value = 3 [
    (validate.rules).bytes = {min_len: 0 max_len: 16384},
    (udpa.annotations.field_migrate).oneof_promotion = "value_type"
  ];
}

// Header name/value pair plus option to control append behavior.
message HeaderValueOption {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.core.HeaderValueOption";

  // Describes the supported actions types for header append action.
  enum HeaderAppendAction {
    // If the header already exists, this action will result in:
    //
    // - Comma-concatenated for predefined inline headers.
    // - Duplicate header added in the ``HeaderMap`` for other headers.
    //
    // If the header doesn't exist then this will add new header with specified key and value.
    APPEND_IF_EXISTS_OR_ADD = 0;

    // This action will add the header if it doesn't already exist. If the header
    // already exists then this will be a no-op.
    ADD_IF_ABSENT = 1;

    // This action will overwrite the specified value by discarding any existing values if
    // the header already exists. If the header doesn't exist then this will add the header
    // with specified key and value.
    OVERWRITE_IF_EXISTS_OR_ADD = 2;

    // This action will overwrite the specified value by discarding any existing values if
    // the header already exists. If the header doesn't exist then this will be no-op.
    OVERWRITE_IF_EXISTS = 3;
  }

  // Header name/value pair that this option applies to.
  HeaderValue header = 1 [(validate.rules).message = {required: true}];

  // Should the value be appended? If true (default), the value is appended to
  // existing values. Otherwise it replaces any existing values.
  // This field is deprecated and please use
  // :ref:`append_action <envoy_v3_api_field_config.core.v3.HeaderValueOption.append_action>` as replacement.
  //
  // .. note::
  //   The :ref:`external authorization service <envoy_v3_api_msg_service.auth.v3.CheckResponse>` and
  //   :ref:`external processor service <envoy_v3_api_msg_service.ext_proc.v3.ProcessingResponse>` have
  //   default value (``false``) for this field.
  google.protobuf.BoolValue append = 2
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Describes the action taken to append/overwrite the given value for an existing header
  // or to only add this header if it's absent.
  // Value defaults to :ref:`APPEND_IF_EXISTS_OR_ADD
  // <envoy_v3_api_enum_value_config.core.v3.HeaderValueOption.HeaderAppendAction.APPEND_IF_EXISTS_OR_ADD>`.
  HeaderAppendAction append_action = 3 [(validate.rules).enum = {defined_only: true}];

  // Is the header value allowed to be empty? If false (default), custom headers with empty values are dropped,
  // otherwise they are added.
  bool keep_empty_value = 4;
}

// Wrapper for a set of headers.
message HeaderMap {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.HeaderMap";

  repeated HeaderValue headers = 1;
}

// A directory that is watched for changes, e.g. by inotify on Linux. Move/rename
// events inside this directory trigger the watch.
message WatchedDirectory {
  // Directory path to watch.
  string path = 1 [(validate.rules).string = {min_len: 1}];
}

// Data source consisting of a file, an inline value, or an environment variable.
message DataSource {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.DataSource";

  oneof specifier {
    option (validate.required) = true;

    // Local filesystem data source.
    string filename = 1 [(validate.rules).string = {min_len: 1}];

    // Bytes inlined in the configuration.
    bytes inline_bytes = 2;

    // String inlined in the configuration.
    string inline_string = 3;

    // Environment variable data source.
    string environment_variable = 4 [(validate.rules).string = {min_len: 1}];
  }
}

// The message specifies the retry policy of remote data source when fetching fails.
message RetryPolicy {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.RetryPolicy";

  // Specifies parameters that control :ref:`retry backoff strategy <envoy_v3_api_msg_config.core.v3.BackoffStrategy>`.
  // This parameter is optional, in which case the default base interval is 1000 milliseconds. The
  // default maximum interval is 10 times the base interval.
  BackoffStrategy retry_back_off = 1;

  // Specifies the allowed number of retries. This parameter is optional and
  // defaults to 1.
  google.protobuf.UInt32Value num_retries = 2
      [(udpa.annotations.field_migrate).rename = "max_retries"];
}

// The message specifies how to fetch data from remote and how to verify it.
message RemoteDataSource {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.RemoteDataSource";

  // The HTTP URI to fetch the remote data.
  HttpUri http_uri = 1 [(validate.rules).message = {required: true}];

  // SHA256 string for verifying data.
  string sha256 = 2 [(validate.rules).string = {min_len: 1}];

  // Retry policy for fetching remote data.
  RetryPolicy retry_policy = 3;
}

// Async data source which support async data fetch.
message AsyncDataSource {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.AsyncDataSource";

  oneof specifier {
    option (validate.required) = true;

    // Local async data source.
    DataSource local = 1;

    // Remote async data source.
    RemoteDataSource remote = 2;
  }
}

// Configuration for transport socket in :ref:`listeners <config_listeners>` and
// :ref:`clusters <envoy_v3_api_msg_config.cluster.v3.Cluster>`. If the configuration is
// empty, a default transport socket implementation and configuration will be
// chosen based on the platform and existence of tls_context.
message TransportSocket {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.TransportSocket";

  reserved 2;

  reserved "config";

  // The name of the transport socket to instantiate. The name must match a supported transport
  // socket implementation.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // Implementation specific configuration which depends on the implementation being instantiated.
  // See the supported transport socket implementations for further documentation.
  oneof config_type {
    google.protobuf.Any typed_config = 3;
  }
}

// Runtime derived FractionalPercent with defaults for when the numerator or denominator is not
// specified via a runtime key.
//
// .. note::
//
//   Parsing of the runtime key's data is implemented such that it may be represented as a
//   :ref:`FractionalPercent <envoy_v3_api_msg_type.v3.FractionalPercent>` proto represented as JSON/YAML
//   and may also be represented as an integer with the assumption that the value is an integral
//   percentage out of 100. For instance, a runtime key lookup returning the value "42" would parse
//   as a ``FractionalPercent`` whose numerator is 42 and denominator is HUNDRED.
message RuntimeFractionalPercent {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.core.RuntimeFractionalPercent";

  // Default value if the runtime value's for the numerator/denominator keys are not available.
  type.v3.FractionalPercent default_value = 1 [(validate.rules).message = {required: true}];

  // Runtime key for a YAML representation of a FractionalPercent.
  string runtime_key = 2;
}

// Identifies a specific ControlPlane instance that Envoy is connected to.
message ControlPlane {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.ControlPlane";

  // An opaque control plane identifier that uniquely identifies an instance
  // of control plane. This can be used to identify which control plane instance,
  // the Envoy is connected to.
  string identifier = 1;
}
syntax = "proto3";

package envoy.config.core.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/http_uri.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "HttpServiceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP services]

// HTTP service configuration.
message HttpService {
  // The service's HTTP URI. For example:
  //
  // .. code-block:: yaml
  //
  //    http_uri:
  //      uri: https://www.myserviceapi.com/v1/data
  //      cluster: www.myserviceapi.com|443
  //
  HttpUri http_uri = 1;

  // Specifies a list of HTTP headers that should be added to each request
  // handled by this virtual host.
  repeated HeaderValueOption request_headers_to_add = 2
      [(validate.rules).repeated = {max_items: 1000}];
}
syntax = "proto3";

package envoy.config.core.v3;

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "HttpUriProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP service URI ]

// Envoy external URI descriptor
message HttpUri {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.HttpUri";

  // The HTTP server URI. It should be a full FQDN with protocol, host and path.
  //
  // Example:
  //
  // .. code-block:: yaml
  //
  //    uri: https://www.googleapis.com/oauth2/v1/certs
  //
  string uri = 1 [(validate.rules).string = {min_len: 1}];

  // Specify how ``uri`` is to be fetched. Today, this requires an explicit
  // cluster, but in the future we may support dynamic cluster creation or
  // inline DNS resolution. See `issue
  // <https://github.com/envoyproxy/envoy/issues/1606>`_.
  oneof http_upstream_type {
    option (validate.required) = true;

    // A cluster is created in the Envoy "cluster_manager" config
    // section. This field specifies the cluster name.
    //
    // Example:
    //
    // .. code-block:: yaml
    //
    //    cluster: jwks_cluster
    //
    string cluster = 2 [(validate.rules).string = {min_len: 1}];
  }

  // Sets the maximum duration in milliseconds that a response can take to arrive upon request.
  google.protobuf.Duration timeout = 3 [(validate.rules).duration = {
    required: true
    lt {seconds: 4294967296}
    gte {}
  }];
}
syntax = "proto3";

package envoy.config.core.v3;

import "envoy/config/core/v3/extension.proto";
import "envoy/type/v3/percent.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "ProtocolProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Protocol options]

// [#not-implemented-hide:]
message TcpProtocolOptions {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.core.TcpProtocolOptions";
}

// Config for keepalive probes in a QUIC connection.
// Note that QUIC keep-alive probing packets work differently from HTTP/2 keep-alive PINGs in a sense that the probing packet
// itself doesn't timeout waiting for a probing response. Quic has a shorter idle timeout than TCP, so it doesn't rely on such probing to discover dead connections. If the peer fails to respond, the connection will idle timeout eventually. Thus, they are configured differently from :ref:`connection_keepalive <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.connection_keepalive>`.
message QuicKeepAliveSettings {
  // The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout <envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout>` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
  //
  // If :ref:`initial_interval <envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval>` is absent or zero, a client connection will use this value to start probing.
  //
  // If zero, disable keepalive probing.
  // If absent, use the QUICHE default interval to probe.
  google.protobuf.Duration max_interval = 1 [(validate.rules).duration = {
    lte {}
    gte {seconds: 1}
  }];

  // The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval <envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval>`. And the probes afterwards will always use :ref:`max_interval <envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval>`.
  //
  // The value should be smaller than :ref:`connection idle_timeout <envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout>` to prevent idle timeout and smaller than max_interval to take effect.
  //
  // If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval <envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval>`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
  google.protobuf.Duration initial_interval = 2 [(validate.rules).duration = {
    lte {}
    gte {seconds: 1}
  }];
}

// QUIC protocol options which apply to both downstream and upstream connections.
// [#next-free-field: 8]
message QuicProtocolOptions {
  // Maximum number of streams that the client can negotiate per connection. 100
  // if not specified.
  google.protobuf.UInt32Value max_concurrent_streams = 1 [(validate.rules).uint32 = {gte: 1}];

  // `Initial stream-level flow-control receive window
  // <https://tools.ietf.org/html/draft-ietf-quic-transport-34#section-4.1>`_ size. Valid values range from
  // 1 to 16777216 (2^24, maximum supported by QUICHE) and defaults to 65536 (2^16).
  //
  // NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. If configured smaller than it, we will use 16384 instead.
  // QUICHE IETF Quic implementation supports 1 bytes window. We only support increasing the default window size now, so it's also the minimum.
  //
  // This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
  // QUIC stream send and receive buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
  // stop the flow of data to the stream buffers.
  google.protobuf.UInt32Value initial_stream_window_size = 2
      [(validate.rules).uint32 = {lte: 16777216 gte: 1}];

  // Similar to ``initial_stream_window_size``, but for connection-level
  // flow-control. Valid values rage from 1 to 25165824 (24MB, maximum supported by QUICHE) and defaults to 65536 (2^16).
  // window. Currently, this has the same minimum/default as ``initial_stream_window_size``.
  //
  // NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. We only support increasing the default
  // window size now, so it's also the minimum.
  google.protobuf.UInt32Value initial_connection_window_size = 3
      [(validate.rules).uint32 = {lte: 25165824 gte: 1}];

  // The number of timeouts that can occur before port migration is triggered for QUIC clients.
  // This defaults to 4. If set to 0, port migration will not occur on path degrading.
  // Timeout here refers to QUIC internal path degrading timeout mechanism, such as PTO.
  // This has no effect on server sessions.
  google.protobuf.UInt32Value num_timeouts_to_trigger_port_migration = 4
      [(validate.rules).uint32 = {lte: 5 gte: 0}];

  // Probes the peer at the configured interval to solicit traffic, i.e. ACK or PATH_RESPONSE, from the peer to push back connection idle timeout.
  // If absent, use the default keepalive behavior of which a client connection sends PINGs every 15s, and a server connection doesn't do anything.
  QuicKeepAliveSettings connection_keepalive = 5;

  // A comma-separated list of strings representing QUIC connection options defined in
  // `QUICHE <https://github.com/google/quiche/blob/main/quiche/quic/core/crypto/crypto_protocol.h>`_ and to be sent by upstream connections.
  string connection_options = 6;

  // A comma-separated list of strings representing QUIC client connection options defined in
  // `QUICHE <https://github.com/google/quiche/blob/main/quiche/quic/core/crypto/crypto_protocol.h>`_ and to be sent by upstream connections.
  string client_connection_options = 7;
}

message UpstreamHttpProtocolOptions {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.core.UpstreamHttpProtocolOptions";

  // Set transport socket `SNI <https://en.wikipedia.org/wiki/Server_Name_Indication>`_ for new
  // upstream connections based on the downstream HTTP host/authority header or any other arbitrary
  // header when :ref:`override_auto_sni_header <envoy_v3_api_field_config.core.v3.UpstreamHttpProtocolOptions.override_auto_sni_header>`
  // is set, as seen by the :ref:`router filter <config_http_filters_router>`.
  // Does nothing if a filter before the http router filter sets the corresponding metadata.
  bool auto_sni = 1;

  // Automatic validate upstream presented certificate for new upstream connections based on the
  // downstream HTTP host/authority header or any other arbitrary header when :ref:`override_auto_sni_header <envoy_v3_api_field_config.core.v3.UpstreamHttpProtocolOptions.override_auto_sni_header>`
  // is set, as seen by the :ref:`router filter <config_http_filters_router>`.
  // This field is intended to be set with ``auto_sni`` field.
  // Does nothing if a filter before the http router filter sets the corresponding metadata.
  bool auto_san_validation = 2;

  // An optional alternative to the host/authority header to be used for setting the SNI value.
  // It should be a valid downstream HTTP header, as seen by the
  // :ref:`router filter <config_http_filters_router>`.
  // If unset, host/authority header will be used for populating the SNI. If the specified header
  // is not found or the value is empty, host/authority header will be used instead.
  // This field is intended to be set with ``auto_sni`` and/or ``auto_san_validation`` fields.
  // If none of these fields are set then setting this would be a no-op.
  // Does nothing if a filter before the http router filter sets the corresponding metadata.
  string override_auto_sni_header = 3
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];
}

// Configures the alternate protocols cache which tracks alternate protocols that can be used to
// make an HTTP connection to an origin server. See https://tools.ietf.org/html/rfc7838 for
// HTTP Alternative Services and https://datatracker.ietf.org/doc/html/draft-ietf-dnsop-svcb-https-04
// for the "HTTPS" DNS resource record.
// [#next-free-field: 6]
message AlternateProtocolsCacheOptions {
  // Allows pre-populating the cache with HTTP/3 alternate protocols entries with a 7 day lifetime.
  // This will cause Envoy to attempt HTTP/3 to those upstreams, even if the upstreams have not
  // advertised HTTP/3 support. These entries will be overwritten by alt-svc
  // response headers or cached values.
  // As with regular cached entries, if the origin response would result in clearing an existing
  // alternate protocol cache entry, pre-populated entries will also be cleared.
  // Adding a cache entry with hostname=foo.com port=123 is the equivalent of getting
  // response headers
  // alt-svc: h3=:"123"; ma=86400" in a response to a request to foo.com:123
  message AlternateProtocolsCacheEntry {
    // The host name for the alternate protocol entry.
    string hostname = 1
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];

    // The port for the alternate protocol entry.
    uint32 port = 2 [(validate.rules).uint32 = {lt: 65535 gt: 0}];
  }

  // The name of the cache. Multiple named caches allow independent alternate protocols cache
  // configurations to operate within a single Envoy process using different configurations. All
  // alternate protocols cache options with the same name *must* be equal in all fields when
  // referenced from different configuration components. Configuration will fail to load if this is
  // not the case.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // The maximum number of entries that the cache will hold. If not specified defaults to 1024.
  //
  // .. note:
  //
  //   The implementation is approximate and enforced independently on each worker thread, thus
  //   it is possible for the maximum entries in the cache to go slightly above the configured
  //   value depending on timing. This is similar to how other circuit breakers work.
  google.protobuf.UInt32Value max_entries = 2 [(validate.rules).uint32 = {gt: 0}];

  // Allows configuring a persistent
  // :ref:`key value store <envoy_v3_api_msg_config.common.key_value.v3.KeyValueStoreConfig>` to flush
  // alternate protocols entries to disk.
  // This function is currently only supported if concurrency is 1
  // Cached entries will take precedence over pre-populated entries below.
  TypedExtensionConfig key_value_store_config = 3;

  // Allows pre-populating the cache with entries, as described above.
  repeated AlternateProtocolsCacheEntry prepopulated_entries = 4;

  // Optional list of hostnames suffixes for which Alt-Svc entries can be shared. For example, if
  // this list contained the value ``.c.example.com``, then an Alt-Svc entry for ``foo.c.example.com``
  // could be shared with ``bar.c.example.com`` but would not be shared with ``baz.example.com``. On
  // the other hand, if the list contained the value ``.example.com`` then all three hosts could share
  // Alt-Svc entries. Each entry must start with ``.``. If a hostname matches multiple suffixes, the
  // first listed suffix will be used.
  //
  // Since lookup in this list is O(n), it is recommended that the number of suffixes be limited.
  // [#not-implemented-hide:]
  repeated string canonical_suffixes = 5;
}

// [#next-free-field: 7]
message HttpProtocolOptions {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.core.HttpProtocolOptions";

  // Action to take when Envoy receives client request with header names containing underscore
  // characters.
  // Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
  // as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
  // characters.
  enum HeadersWithUnderscoresAction {
    // Allow headers with underscores. This is the default behavior.
    ALLOW = 0;

    // Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
    // end with the stream reset. The "httpN.requests_rejected_with_underscores_in_headers" counter
    // is incremented for each rejected request.
    REJECT_REQUEST = 1;

    // Drop the client header with name containing underscores. The header is dropped before the filter chain is
    // invoked and as such filters will not see dropped headers. The
    // "httpN.dropped_headers_with_underscores" is incremented for each dropped header.
    DROP_HEADER = 2;
  }

  // The idle timeout for connections. The idle timeout is defined as the
  // period in which there are no active requests. When the
  // idle timeout is reached the connection will be closed. If the connection is an HTTP/2
  // downstream connection a drain sequence will occur prior to closing the connection, see
  // :ref:`drain_timeout
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout>`.
  // Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
  // If not specified, this defaults to 1 hour. To disable idle timeouts explicitly set this to 0.
  //
  // .. warning::
  //   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
  //   FIN packets, etc.
  //
  // If the :ref:`overload action <config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
  // is configured, this timeout is scaled for downstream connections according to the value for
  // :ref:`HTTP_DOWNSTREAM_CONNECTION_IDLE <envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_CONNECTION_IDLE>`.
  google.protobuf.Duration idle_timeout = 1;

  // The maximum duration of a connection. The duration is defined as a period since a connection
  // was established. If not set, there is no max duration. When max_connection_duration is reached
  // and if there are no active streams, the connection will be closed. If the connection is a
  // downstream connection and there are any active streams, the drain sequence will kick-in,
  // and the connection will be force-closed after the drain period. See :ref:`drain_timeout
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout>`.
  google.protobuf.Duration max_connection_duration = 3;

  // The maximum number of headers. If unconfigured, the default
  // maximum number of request headers allowed is 100. Requests that exceed this limit will receive
  // a 431 response for HTTP/1.x and cause a stream reset for HTTP/2.
  google.protobuf.UInt32Value max_headers_count = 2 [(validate.rules).uint32 = {gte: 1}];

  // Total duration to keep alive an HTTP request/response stream. If the time limit is reached the stream will be
  // reset independent of any other timeouts. If not specified, this value is not set.
  google.protobuf.Duration max_stream_duration = 4;

  // Action to take when a client request with a header name containing underscore characters is received.
  // If this setting is not specified, the value defaults to ALLOW.
  // Note: upstream responses are not affected by this setting.
  // Note: this only affects client headers. It does not affect headers added
  // by Envoy filters and does not have any impact if added to cluster config.
  HeadersWithUnderscoresAction headers_with_underscores_action = 5;

  // Optional maximum requests for both upstream and downstream connections.
  // If not specified, there is no limit.
  // Setting this parameter to 1 will effectively disable keep alive.
  // For HTTP/2 and HTTP/3, due to concurrent stream processing, the limit is approximate.
  google.protobuf.UInt32Value max_requests_per_connection = 6;
}

// [#next-free-field: 11]
message Http1ProtocolOptions {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.core.Http1ProtocolOptions";

  // [#next-free-field: 9]
  message HeaderKeyFormat {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat";

    message ProperCaseWords {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords";
    }

    oneof header_format {
      option (validate.required) = true;

      // Formats the header by proper casing words: the first character and any character following
      // a special character will be capitalized if it's an alpha character. For example,
      // "content-type" becomes "Content-Type", and "foo$b#$are" becomes "Foo$B#$Are".
      // Note that while this results in most headers following conventional casing, certain headers
      // are not covered. For example, the "TE" header will be formatted as "Te".
      ProperCaseWords proper_case_words = 1;

      // Configuration for stateful formatter extensions that allow using received headers to
      // affect the output of encoding headers. E.g., preserving case during proxying.
      // [#extension-category: envoy.http.stateful_header_formatters]
      TypedExtensionConfig stateful_formatter = 8;
    }
  }

  // Handle HTTP requests with absolute URLs in the requests. These requests
  // are generally sent by clients to forward/explicit proxies. This allows clients to configure
  // envoy as their HTTP proxy. In Unix, for example, this is typically done by setting the
  // ``http_proxy`` environment variable.
  google.protobuf.BoolValue allow_absolute_url = 1;

  // Handle incoming HTTP/1.0 and HTTP 0.9 requests.
  // This is off by default, and not fully standards compliant. There is support for pre-HTTP/1.1
  // style connect logic, dechunking, and handling lack of client host iff
  // ``default_host_for_http_10`` is configured.
  bool accept_http_10 = 2;

  // A default host for HTTP/1.0 requests. This is highly suggested if ``accept_http_10`` is true as
  // Envoy does not otherwise support HTTP/1.0 without a Host header.
  // This is a no-op if ``accept_http_10`` is not true.
  string default_host_for_http_10 = 3;

  // Describes how the keys for response headers should be formatted. By default, all header keys
  // are lower cased.
  HeaderKeyFormat header_key_format = 4;

  // Enables trailers for HTTP/1. By default the HTTP/1 codec drops proxied trailers.
  //
  // .. attention::
  //
  //   Note that this only happens when Envoy is chunk encoding which occurs when:
  //   - The request is HTTP/1.1.
  //   - Is neither a HEAD only request nor a HTTP Upgrade.
  //   - Not a response to a HEAD request.
  //   - The content length header is not present.
  bool enable_trailers = 5;

  // Allows Envoy to process requests/responses with both ``Content-Length`` and ``Transfer-Encoding``
  // headers set. By default such messages are rejected, but if option is enabled - Envoy will
  // remove Content-Length header and process message.
  // See `RFC7230, sec. 3.3.3 <https://tools.ietf.org/html/rfc7230#section-3.3.3>`_ for details.
  //
  // .. attention::
  //   Enabling this option might lead to request smuggling vulnerability, especially if traffic
  //   is proxied via multiple layers of proxies.
  // [#comment:TODO: This field is ignored when the
  // :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
  // is present.]
  bool allow_chunked_length = 6;

  // Allows invalid HTTP messaging. When this option is false, then Envoy will terminate
  // HTTP/1.1 connections upon receiving an invalid HTTP message. However,
  // when this option is true, then Envoy will leave the HTTP/1.1 connection
  // open where possible.
  // If set, this overrides any HCM :ref:`stream_error_on_invalid_http_messaging
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`.
  google.protobuf.BoolValue override_stream_error_on_invalid_http_message = 7;

  // Allows sending fully qualified URLs when proxying the first line of the
  // response. By default, Envoy will only send the path components in the first line.
  // If this is true, Envoy will create a fully qualified URI composing scheme
  // (inferred if not present), host (from the host/:authority header) and path
  // (from first line or :path header).
  bool send_fully_qualified_url = 8;

  // [#not-implemented-hide:] Hiding so that field can be removed after BalsaParser is rolled out.
  // If set, force HTTP/1 parser: BalsaParser if true, http-parser if false.
  // If unset, HTTP/1 parser is selected based on
  // envoy.reloadable_features.http1_use_balsa_parser.
  // See issue #21245.
  google.protobuf.BoolValue use_balsa_parser = 9
      [(xds.annotations.v3.field_status).work_in_progress = true];

  // [#not-implemented-hide:] Hiding so that field can be removed.
  // If true, and BalsaParser is used (either `use_balsa_parser` above is true,
  // or `envoy.reloadable_features.http1_use_balsa_parser` is true and
  // `use_balsa_parser` is unset), then every non-empty method with only valid
  // characters is accepted. Otherwise, methods not on the hard-coded list are
  // rejected.
  // Once UHV is enabled, this field should be removed, and BalsaParser should
  // allow any method. UHV validates the method, rejecting empty string or
  // invalid characters, and provides :ref:`restrict_http_methods
  // <envoy_v3_api_field_extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig.restrict_http_methods>`
  // to reject custom methods.
  bool allow_custom_methods = 10 [(xds.annotations.v3.field_status).work_in_progress = true];
}

message KeepaliveSettings {
  // Send HTTP/2 PING frames at this period, in order to test that the connection is still alive.
  // If this is zero, interval PINGs will not be sent.
  google.protobuf.Duration interval = 1 [(validate.rules).duration = {gte {nanos: 1000000}}];

  // How long to wait for a response to a keepalive PING. If a response is not received within this
  // time period, the connection will be aborted. Note that in order to prevent the influence of
  // Head-of-line (HOL) blocking the timeout period is extended when *any* frame is received on
  // the connection, under the assumption that if a frame is received the connection is healthy.
  google.protobuf.Duration timeout = 2 [(validate.rules).duration = {
    required: true
    gte {nanos: 1000000}
  }];

  // A random jitter amount as a percentage of interval that will be added to each interval.
  // A value of zero means there will be no jitter.
  // The default value is 15%.
  type.v3.Percent interval_jitter = 3;

  // If the connection has been idle for this duration, send a HTTP/2 ping ahead
  // of new stream creation, to quickly detect dead connections.
  // If this is zero, this type of PING will not be sent.
  // If an interval ping is outstanding, a second ping will not be sent as the
  // interval ping will determine if the connection is dead.
  //
  // The same feature for HTTP/3 is given by inheritance from QUICHE which uses :ref:`connection idle_timeout <envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout>` and the current PTO of the connection to decide whether to probe before sending a new request.
  google.protobuf.Duration connection_idle_interval = 4
      [(validate.rules).duration = {gte {nanos: 1000000}}];
}

// [#next-free-field: 17]
message Http2ProtocolOptions {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.core.Http2ProtocolOptions";

  // Defines a parameter to be sent in the SETTINGS frame.
  // See `RFC7540, sec. 6.5.1 <https://tools.ietf.org/html/rfc7540#section-6.5.1>`_ for details.
  message SettingsParameter {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter";

    // The 16 bit parameter identifier.
    google.protobuf.UInt32Value identifier = 1 [
      (validate.rules).uint32 = {lte: 65535 gte: 0},
      (validate.rules).message = {required: true}
    ];

    // The 32 bit parameter value.
    google.protobuf.UInt32Value value = 2 [(validate.rules).message = {required: true}];
  }

  // `Maximum table size <https://httpwg.org/specs/rfc7541.html#rfc.section.4.2>`_
  // (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
  // range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
  // compression.
  google.protobuf.UInt32Value hpack_table_size = 1;

  // `Maximum concurrent streams <https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2>`_
  // allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
  // and defaults to 2147483647.
  //
  // For upstream connections, this also limits how many streams Envoy will initiate concurrently
  // on a single connection. If the limit is reached, Envoy may queue requests or establish
  // additional connections (as allowed per circuit breaker limits).
  //
  // This acts as an upper bound: Envoy will lower the max concurrent streams allowed on a given
  // connection based on upstream settings. Config dumps will reflect the configured upper bound,
  // not the per-connection negotiated limits.
  google.protobuf.UInt32Value max_concurrent_streams = 2
      [(validate.rules).uint32 = {lte: 2147483647 gte: 1}];

  // `Initial stream-level flow-control window
  // <https://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2>`_ size. Valid values range from 65535
  // (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to 268435456
  // (256 * 1024 * 1024).
  //
  // NOTE: 65535 is the initial window size from HTTP/2 spec. We only support increasing the default
  // window size now, so it's also the minimum.
  //
  // This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
  // HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
  // stop the flow of data to the codec buffers.
  google.protobuf.UInt32Value initial_stream_window_size = 3
      [(validate.rules).uint32 = {lte: 2147483647 gte: 65535}];

  // Similar to ``initial_stream_window_size``, but for connection-level flow-control
  // window. Currently, this has the same minimum/maximum/default as ``initial_stream_window_size``.
  google.protobuf.UInt32Value initial_connection_window_size = 4
      [(validate.rules).uint32 = {lte: 2147483647 gte: 65535}];

  // Allows proxying Websocket and other upgrades over H2 connect.
  bool allow_connect = 5;

  // [#not-implemented-hide:] Hiding until envoy has full metadata support.
  // Still under implementation. DO NOT USE.
  //
  // Allows metadata. See [metadata
  // docs](https://github.com/envoyproxy/envoy/blob/main/source/docs/h2_metadata.md) for more
  // information.
  bool allow_metadata = 6;

  // Limit the number of pending outbound downstream frames of all types (frames that are waiting to
  // be written into the socket). Exceeding this limit triggers flood mitigation and connection is
  // terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
  // to flood mitigation. The default limit is 10000.
  google.protobuf.UInt32Value max_outbound_frames = 7 [(validate.rules).uint32 = {gte: 1}];

  // Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
  // preventing high memory utilization when receiving continuous stream of these frames. Exceeding
  // this limit triggers flood mitigation and connection is terminated. The
  // ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
  // mitigation. The default limit is 1000.
  google.protobuf.UInt32Value max_outbound_control_frames = 8 [(validate.rules).uint32 = {gte: 1}];

  // Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
  // empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
  // might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
  // stat tracks the number of connections terminated due to flood mitigation.
  // Setting this to 0 will terminate connection upon receiving first frame with an empty payload
  // and no end stream flag. The default limit is 1.
  google.protobuf.UInt32Value max_consecutive_inbound_frames_with_empty_payload = 9;

  // Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
  // of PRIORITY frames received over the lifetime of connection exceeds the value calculated
  // using this formula::
  //
  //   ``max_inbound_priority_frames_per_stream`` * (1 + ``opened_streams``)
  //
  // the connection is terminated. For downstream connections the ``opened_streams`` is incremented when
  // Envoy receives complete response headers from the upstream server. For upstream connection the
  // ``opened_streams`` is incremented when Envoy send the HEADERS frame for a new stream. The
  // ``http2.inbound_priority_frames_flood`` stat tracks
  // the number of connections terminated due to flood mitigation. The default limit is 100.
  google.protobuf.UInt32Value max_inbound_priority_frames_per_stream = 10;

  // Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
  // of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
  // using this formula::
  //
  //   5 + 2 * (``opened_streams`` +
  //            ``max_inbound_window_update_frames_per_data_frame_sent`` * ``outbound_data_frames``)
  //
  // the connection is terminated. For downstream connections the ``opened_streams`` is incremented when
  // Envoy receives complete response headers from the upstream server. For upstream connections the
  // ``opened_streams`` is incremented when Envoy sends the HEADERS frame for a new stream. The
  // ``http2.inbound_priority_frames_flood`` stat tracks the number of connections terminated due to
  // flood mitigation. The default max_inbound_window_update_frames_per_data_frame_sent value is 10.
  // Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
  // but more complex implementations that try to estimate available bandwidth require at least 2.
  google.protobuf.UInt32Value max_inbound_window_update_frames_per_data_frame_sent = 11
      [(validate.rules).uint32 = {gte: 1}];

  // Allows invalid HTTP messaging and headers. When this option is disabled (default), then
  // the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
  // when this option is enabled, only the offending stream is terminated.
  //
  // This is overridden by HCM :ref:`stream_error_on_invalid_http_messaging
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`
  // iff present.
  //
  // This is deprecated in favor of :ref:`override_stream_error_on_invalid_http_message
  // <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message>`
  //
  // See `RFC7540, sec. 8.1 <https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
  bool stream_error_on_invalid_http_messaging = 12
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Allows invalid HTTP messaging and headers. When this option is disabled (default), then
  // the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
  // when this option is enabled, only the offending stream is terminated.
  //
  // This overrides any HCM :ref:`stream_error_on_invalid_http_messaging
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`
  //
  // See `RFC7540, sec. 8.1 <https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
  google.protobuf.BoolValue override_stream_error_on_invalid_http_message = 14;

  // [#not-implemented-hide:]
  // Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:
  //
  // 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
  // Envoy.
  //
  // 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
  // 'allow_connect'.
  //
  // Note that custom parameters specified through this field can not also be set in the
  // corresponding named parameters:
  //
  // .. code-block:: text
  //
  //   ID    Field Name
  //   ----------------
  //   0x1   hpack_table_size
  //   0x3   max_concurrent_streams
  //   0x4   initial_stream_window_size
  //
  // Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
  // between custom parameters with the same identifier will trigger a failure.
  //
  // See `IANA HTTP/2 Settings
  // <https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings>`_ for
  // standardized identifiers.
  repeated SettingsParameter custom_settings_parameters = 13;

  // Send HTTP/2 PING frames to verify that the connection is still healthy. If the remote peer
  // does not respond within the configured timeout, the connection will be aborted.
  KeepaliveSettings connection_keepalive = 15;

  // [#not-implemented-hide:] Hiding so that the field can be removed after oghttp2 is rolled out.
  // If set, force use of a particular HTTP/2 codec: oghttp2 if true, nghttp2 if false.
  // If unset, HTTP/2 codec is selected based on envoy.reloadable_features.http2_use_oghttp2.
  google.protobuf.BoolValue use_oghttp2_codec = 16
      [(xds.annotations.v3.field_status).work_in_progress = true];
}

// [#not-implemented-hide:]
message GrpcProtocolOptions {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.core.GrpcProtocolOptions";

  Http2ProtocolOptions http2_protocol_options = 1;
}

// A message which allows using HTTP/3.
// [#next-free-field: 6]
message Http3ProtocolOptions {
  QuicProtocolOptions quic_protocol_options = 1;

  // Allows invalid HTTP messaging and headers. When this option is disabled (default), then
  // the whole HTTP/3 connection is terminated upon receiving invalid HEADERS frame. However,
  // when this option is enabled, only the offending stream is terminated.
  //
  // If set, this overrides any HCM :ref:`stream_error_on_invalid_http_messaging
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`.
  google.protobuf.BoolValue override_stream_error_on_invalid_http_message = 2;

  // Allows proxying Websocket and other upgrades over HTTP/3 CONNECT using
  // the header mechanisms from the `HTTP/2 extended connect RFC
  // <https://datatracker.ietf.org/doc/html/rfc8441>`_
  // and settings `proposed for HTTP/3
  // <https://datatracker.ietf.org/doc/draft-ietf-httpbis-h3-websockets/>`_
  // Note that HTTP/3 CONNECT is not yet an RFC.
  bool allow_extended_connect = 5 [(xds.annotations.v3.field_status).work_in_progress = true];
}

// A message to control transformations to the :scheme header
message SchemeHeaderTransformation {
  oneof transformation {
    // Overwrite any Scheme header with the contents of this string.
    string scheme_to_overwrite = 1 [(validate.rules).string = {in: "http" in: "https"}];
  }
}
syntax = "proto3";

package envoy.config.core.v3;

import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/socket_option.proto";

import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "AddressProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Network addresses]

message Pipe {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.Pipe";

  // Unix Domain Socket path. On Linux, paths starting with '@' will use the
  // abstract namespace. The starting '@' is replaced by a null byte by Envoy.
  // Paths starting with '@' will result in an error in environments other than
  // Linux.
  string path = 1 [(validate.rules).string = {min_len: 1}];

  // The mode for the Pipe. Not applicable for abstract sockets.
  uint32 mode = 2 [(validate.rules).uint32 = {lte: 511}];
}

// The address represents an envoy internal listener.
// [#comment: TODO(asraa): When address available, remove workaround from test/server/server_fuzz_test.cc:30.]
message EnvoyInternalAddress {
  oneof address_name_specifier {
    option (validate.required) = true;

    // Specifies the :ref:`name <envoy_v3_api_field_config.listener.v3.Listener.name>` of the
    // internal listener.
    string server_listener_name = 1;
  }

  // Specifies an endpoint identifier to distinguish between multiple endpoints for the same internal listener in a
  // single upstream pool. Only used in the upstream addresses for tracking changes to individual endpoints. This, for
  // example, may be set to the final destination IP for the target internal listener.
  string endpoint_id = 2;
}

// [#next-free-field: 7]
message SocketAddress {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.SocketAddress";

  enum Protocol {
    TCP = 0;
    UDP = 1;
  }

  Protocol protocol = 1 [(validate.rules).enum = {defined_only: true}];

  // The address for this socket. :ref:`Listeners <config_listeners>` will bind
  // to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::``
  // to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:
  // It is possible to distinguish a Listener address via the prefix/suffix matching
  // in :ref:`FilterChainMatch <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>`.] When used
  // within an upstream :ref:`BindConfig <envoy_v3_api_msg_config.core.v3.BindConfig>`, the address
  // controls the source address of outbound connections. For :ref:`clusters
  // <envoy_v3_api_msg_config.cluster.v3.Cluster>`, the cluster type determines whether the
  // address must be an IP (``STATIC`` or ``EDS`` clusters) or a hostname resolved by DNS
  // (``STRICT_DNS`` or ``LOGICAL_DNS`` clusters). Address resolution can be customized
  // via :ref:`resolver_name <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>`.
  string address = 2 [(validate.rules).string = {min_len: 1}];

  oneof port_specifier {
    option (validate.required) = true;

    uint32 port_value = 3 [(validate.rules).uint32 = {lte: 65535}];

    // This is only valid if :ref:`resolver_name
    // <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>` is specified below and the
    // named resolver is capable of named port resolution.
    string named_port = 4;
  }

  // The name of the custom resolver. This must have been registered with Envoy. If
  // this is empty, a context dependent default applies. If the address is a concrete
  // IP address, no resolution will occur. If address is a hostname this
  // should be set for resolution other than DNS. Specifying a custom resolver with
  // ``STRICT_DNS`` or ``LOGICAL_DNS`` will generate an error at runtime.
  string resolver_name = 5;

  // When binding to an IPv6 address above, this enables `IPv4 compatibility
  // <https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to ``::`` will
  // allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
  // IPv6 space as ``::FFFF:<IPv4-address>``.
  bool ipv4_compat = 6;
}

message TcpKeepalive {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.TcpKeepalive";

  // Maximum number of keepalive probes to send without response before deciding
  // the connection is dead. Default is to use the OS level configuration (unless
  // overridden, Linux defaults to 9.)
  google.protobuf.UInt32Value keepalive_probes = 1;

  // The number of seconds a connection needs to be idle before keep-alive probes
  // start being sent. Default is to use the OS level configuration (unless
  // overridden, Linux defaults to 7200s (i.e., 2 hours.)
  google.protobuf.UInt32Value keepalive_time = 2;

  // The number of seconds between keep-alive probes. Default is to use the OS
  // level configuration (unless overridden, Linux defaults to 75s.)
  google.protobuf.UInt32Value keepalive_interval = 3;
}

message ExtraSourceAddress {
  // The additional address to bind.
  SocketAddress address = 1 [(validate.rules).message = {required: true}];

  // Additional socket options that may not be present in Envoy source code or
  // precompiled binaries. If specified, this will override the
  // :ref:`socket_options <envoy_v3_api_field_config.core.v3.BindConfig.socket_options>`
  // in the BindConfig. If specified with no
  // :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`
  // or an empty list of :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`,
  // it means no socket option will apply.
  SocketOptionsOverride socket_options = 2;
}

// [#next-free-field: 7]
message BindConfig {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.BindConfig";

  // The address to bind to when creating a socket.
  SocketAddress source_address = 1;

  // Whether to set the ``IP_FREEBIND`` option when creating the socket. When this
  // flag is set to true, allows the :ref:`source_address
  // <envoy_v3_api_field_config.core.v3.BindConfig.source_address>` to be an IP address
  // that is not configured on the system running Envoy. When this flag is set
  // to false, the option ``IP_FREEBIND`` is disabled on the socket. When this
  // flag is not set (default), the socket is not modified, i.e. the option is
  // neither enabled nor disabled.
  google.protobuf.BoolValue freebind = 2;

  // Additional socket options that may not be present in Envoy source code or
  // precompiled binaries.
  repeated SocketOption socket_options = 3;

  // Extra source addresses appended to the address specified in the ``source_address``
  // field. This enables to specify multiple source addresses.
  // The source address selection is determined by :ref:`local_address_selector
  // <envoy_v3_api_field_config.core.v3.BindConfig.local_address_selector>`.
  repeated ExtraSourceAddress extra_source_addresses = 5;

  // Deprecated by
  // :ref:`extra_source_addresses <envoy_v3_api_field_config.core.v3.BindConfig.extra_source_addresses>`
  repeated SocketAddress additional_source_addresses = 4
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Custom local address selector to override the default (i.e.
  // :ref:`DefaultLocalAddressSelector
  // <envoy_v3_api_msg_config.upstream.local_address_selector.v3.DefaultLocalAddressSelector>`).
  // [#extension-category: envoy.upstream.local_address_selector]
  TypedExtensionConfig local_address_selector = 6;
}

// Addresses specify either a logical or physical address and port, which are
// used to tell Envoy where to bind/listen, connect to upstream and find
// management servers.
message Address {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.Address";

  oneof address {
    option (validate.required) = true;

    SocketAddress socket_address = 1;

    Pipe pipe = 2;

    // Specifies a user-space address handled by :ref:`internal listeners
    // <envoy_v3_api_field_config.listener.v3.Listener.internal_listener>`.
    EnvoyInternalAddress envoy_internal_address = 3;
  }
}

// CidrRange specifies an IP Address and a prefix length to construct
// the subnet mask for a `CIDR <https://tools.ietf.org/html/rfc4632>`_ range.
message CidrRange {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.CidrRange";

  // IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``.
  string address_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // Length of prefix, e.g. 0, 32. Defaults to 0 when unset.
  google.protobuf.UInt32Value prefix_len = 2 [(validate.rules).uint32 = {lte: 128}];
}
syntax = "proto3";

package envoy.config.core.v3;

import "envoy/config/core/v3/grpc_service.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "EventServiceConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#not-implemented-hide:]
// Configuration of the event reporting service endpoint.
message EventServiceConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.core.EventServiceConfig";

  oneof config_source_specifier {
    option (validate.required) = true;

    // Specifies the gRPC service that hosts the event reporting service.
    GrpcService grpc_service = 1;
  }
}
syntax = "proto3";

package envoy.config.core.v3;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "UdpSocketConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: UDP socket config]

// Generic UDP socket configuration.
message UdpSocketConfig {
  // The maximum size of received UDP datagrams. Using a larger size will cause Envoy to allocate
  // more memory per socket. Received datagrams above this size will be dropped. If not set
  // defaults to 1500 bytes.
  google.protobuf.UInt64Value max_rx_datagram_size = 1
      [(validate.rules).uint64 = {lt: 65536 gt: 0}];

  // Configures whether Generic Receive Offload (GRO)
  // <https://en.wikipedia.org/wiki/Large_receive_offload>_ is preferred when reading from the
  // UDP socket. The default is context dependent and is documented where UdpSocketConfig is used.
  // This option affects performance but not functionality. If GRO is not supported by the operating
  // system, non-GRO receive will be used.
  google.protobuf.BoolValue prefer_gro = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/type/matcher/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
        "@com_github_cncf_xds//xds/core/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.config.core.v3;

import "envoy/config/core/v3/address.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "ResolverProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Resolver]

// Configuration of DNS resolver option flags which control the behavior of the DNS resolver.
message DnsResolverOptions {
  // Use TCP for all DNS queries instead of the default protocol UDP.
  bool use_tcp_for_dns_lookups = 1;

  // Do not use the default search domains; only query hostnames as-is or as aliases.
  bool no_default_search_domain = 2;
}

// DNS resolution configuration which includes the underlying dns resolver addresses and options.
message DnsResolutionConfig {
  // A list of dns resolver addresses. If specified, the DNS client library will perform resolution
  // via the underlying DNS resolvers. Otherwise, the default system resolvers
  // (e.g., /etc/resolv.conf) will be used.
  repeated Address resolvers = 1 [(validate.rules).repeated = {min_items: 1}];

  // Configuration of DNS resolver option flags which control the behavior of the DNS resolver.
  DnsResolverOptions dns_resolver_options = 2;
}
syntax = "proto3";

package envoy.config.core.v3;

import "envoy/config/core/v3/base.proto";

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/sensitive.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "GrpcServiceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: gRPC services]

// gRPC service configuration. This is used by :ref:`ApiConfigSource
// <envoy_v3_api_msg_config.core.v3.ApiConfigSource>` and filter configurations.
// [#next-free-field: 6]
message GrpcService {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.GrpcService";

  message EnvoyGrpc {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.core.GrpcService.EnvoyGrpc";

    // The name of the upstream gRPC cluster. SSL credentials will be supplied
    // in the :ref:`Cluster <envoy_v3_api_msg_config.cluster.v3.Cluster>` :ref:`transport_socket
    // <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket>`.
    string cluster_name = 1 [(validate.rules).string = {min_len: 1}];

    // The ``:authority`` header in the grpc request. If this field is not set, the authority header value will be ``cluster_name``.
    // Note that this authority does not override the SNI. The SNI is provided by the transport socket of the cluster.
    string authority = 2
        [(validate.rules).string =
             {min_len: 0 max_bytes: 16384 well_known_regex: HTTP_HEADER_VALUE strict: false}];

    // Indicates the retry policy for re-establishing the gRPC stream
    // This field is optional. If max interval is not provided, it will be set to ten times the provided base interval.
    // Currently only supported for xDS gRPC streams.
    // If not set, xDS gRPC streams default base interval:500ms, maximum interval:30s will be applied.
    RetryPolicy retry_policy = 3;
  }

  // [#next-free-field: 9]
  message GoogleGrpc {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.core.GrpcService.GoogleGrpc";

    // See https://grpc.io/grpc/cpp/structgrpc_1_1_ssl_credentials_options.html.
    message SslCredentials {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.core.GrpcService.GoogleGrpc.SslCredentials";

      // PEM encoded server root certificates.
      DataSource root_certs = 1;

      // PEM encoded client private key.
      DataSource private_key = 2 [(udpa.annotations.sensitive) = true];

      // PEM encoded client certificate chain.
      DataSource cert_chain = 3;
    }

    // Local channel credentials. Only UDS is supported for now.
    // See https://github.com/grpc/grpc/pull/15909.
    message GoogleLocalCredentials {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.core.GrpcService.GoogleGrpc.GoogleLocalCredentials";
    }

    // See https://grpc.io/docs/guides/auth.html#credential-types to understand Channel and Call
    // credential types.
    message ChannelCredentials {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.core.GrpcService.GoogleGrpc.ChannelCredentials";

      oneof credential_specifier {
        option (validate.required) = true;

        SslCredentials ssl_credentials = 1;

        // https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61
        google.protobuf.Empty google_default = 2;

        GoogleLocalCredentials local_credentials = 3;
      }
    }

    // [#next-free-field: 8]
    message CallCredentials {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.core.GrpcService.GoogleGrpc.CallCredentials";

      message ServiceAccountJWTAccessCredentials {
        option (udpa.annotations.versioning).previous_message_type =
            "envoy.api.v2.core.GrpcService.GoogleGrpc.CallCredentials."
            "ServiceAccountJWTAccessCredentials";

        string json_key = 1;

        uint64 token_lifetime_seconds = 2;
      }

      message GoogleIAMCredentials {
        option (udpa.annotations.versioning).previous_message_type =
            "envoy.api.v2.core.GrpcService.GoogleGrpc.CallCredentials.GoogleIAMCredentials";

        string authorization_token = 1;

        string authority_selector = 2;
      }

      message MetadataCredentialsFromPlugin {
        option (udpa.annotations.versioning).previous_message_type =
            "envoy.api.v2.core.GrpcService.GoogleGrpc.CallCredentials."
            "MetadataCredentialsFromPlugin";

        reserved 2;

        reserved "config";

        string name = 1;

        // [#extension-category: envoy.grpc_credentials]
        oneof config_type {
          google.protobuf.Any typed_config = 3;
        }
      }

      // Security token service configuration that allows Google gRPC to
      // fetch security token from an OAuth 2.0 authorization server.
      // See https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16 and
      // https://github.com/grpc/grpc/pull/19587.
      // [#next-free-field: 10]
      message StsService {
        option (udpa.annotations.versioning).previous_message_type =
            "envoy.api.v2.core.GrpcService.GoogleGrpc.CallCredentials.StsService";

        // URI of the token exchange service that handles token exchange requests.
        // [#comment:TODO(asraa): Add URI validation when implemented. Tracked by
        // https://github.com/bufbuild/protoc-gen-validate/issues/303]
        string token_exchange_service_uri = 1;

        // Location of the target service or resource where the client
        // intends to use the requested security token.
        string resource = 2;

        // Logical name of the target service where the client intends to
        // use the requested security token.
        string audience = 3;

        // The desired scope of the requested security token in the
        // context of the service or resource where the token will be used.
        string scope = 4;

        // Type of the requested security token.
        string requested_token_type = 5;

        // The path of subject token, a security token that represents the
        // identity of the party on behalf of whom the request is being made.
        string subject_token_path = 6 [(validate.rules).string = {min_len: 1}];

        // Type of the subject token.
        string subject_token_type = 7 [(validate.rules).string = {min_len: 1}];

        // The path of actor token, a security token that represents the identity
        // of the acting party. The acting party is authorized to use the
        // requested security token and act on behalf of the subject.
        string actor_token_path = 8;

        // Type of the actor token.
        string actor_token_type = 9;
      }

      oneof credential_specifier {
        option (validate.required) = true;

        // Access token credentials.
        // https://grpc.io/grpc/cpp/namespacegrpc.html#ad3a80da696ffdaea943f0f858d7a360d.
        string access_token = 1;

        // Google Compute Engine credentials.
        // https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61
        google.protobuf.Empty google_compute_engine = 2;

        // Google refresh token credentials.
        // https://grpc.io/grpc/cpp/namespacegrpc.html#a96901c997b91bc6513b08491e0dca37c.
        string google_refresh_token = 3;

        // Service Account JWT Access credentials.
        // https://grpc.io/grpc/cpp/namespacegrpc.html#a92a9f959d6102461f66ee973d8e9d3aa.
        ServiceAccountJWTAccessCredentials service_account_jwt_access = 4;

        // Google IAM credentials.
        // https://grpc.io/grpc/cpp/namespacegrpc.html#a9fc1fc101b41e680d47028166e76f9d0.
        GoogleIAMCredentials google_iam = 5;

        // Custom authenticator credentials.
        // https://grpc.io/grpc/cpp/namespacegrpc.html#a823c6a4b19ffc71fb33e90154ee2ad07.
        // https://grpc.io/docs/guides/auth.html#extending-grpc-to-support-other-authentication-mechanisms.
        MetadataCredentialsFromPlugin from_plugin = 6;

        // Custom security token service which implements OAuth 2.0 token exchange.
        // https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16
        // See https://github.com/grpc/grpc/pull/19587.
        StsService sts_service = 7;
      }
    }

    // Channel arguments.
    message ChannelArgs {
      message Value {
        // Pointer values are not supported, since they don't make any sense when
        // delivered via the API.
        oneof value_specifier {
          option (validate.required) = true;

          string string_value = 1;

          int64 int_value = 2;
        }
      }

      // See grpc_types.h GRPC_ARG #defines for keys that work here.
      map<string, Value> args = 1;
    }

    // The target URI when using the `Google C++ gRPC client
    // <https://github.com/grpc/grpc>`_. SSL credentials will be supplied in
    // :ref:`channel_credentials <envoy_v3_api_field_config.core.v3.GrpcService.GoogleGrpc.channel_credentials>`.
    string target_uri = 1 [(validate.rules).string = {min_len: 1}];

    ChannelCredentials channel_credentials = 2;

    // A set of call credentials that can be composed with `channel credentials
    // <https://grpc.io/docs/guides/auth.html#credential-types>`_.
    repeated CallCredentials call_credentials = 3;

    // The human readable prefix to use when emitting statistics for the gRPC
    // service.
    //
    // .. csv-table::
    //    :header: Name, Type, Description
    //    :widths: 1, 1, 2
    //
    //    streams_total, Counter, Total number of streams opened
    //    streams_closed_<gRPC status code>, Counter, Total streams closed with <gRPC status code>
    string stat_prefix = 4 [(validate.rules).string = {min_len: 1}];

    // The name of the Google gRPC credentials factory to use. This must have been registered with
    // Envoy. If this is empty, a default credentials factory will be used that sets up channel
    // credentials based on other configuration parameters.
    string credentials_factory_name = 5;

    // Additional configuration for site-specific customizations of the Google
    // gRPC library.
    google.protobuf.Struct config = 6;

    // How many bytes each stream can buffer internally.
    // If not set an implementation defined default is applied (1MiB).
    google.protobuf.UInt32Value per_stream_buffer_limit_bytes = 7;

    // Custom channels args.
    ChannelArgs channel_args = 8;
  }

  reserved 4;

  oneof target_specifier {
    option (validate.required) = true;

    // Envoy's in-built gRPC client.
    // See the :ref:`gRPC services overview <arch_overview_grpc_services>`
    // documentation for discussion on gRPC client selection.
    EnvoyGrpc envoy_grpc = 1;

    // `Google C++ gRPC client <https://github.com/grpc/grpc>`_
    // See the :ref:`gRPC services overview <arch_overview_grpc_services>`
    // documentation for discussion on gRPC client selection.
    GoogleGrpc google_grpc = 2;
  }

  // The timeout for the gRPC request. This is the timeout for a specific
  // request.
  google.protobuf.Duration timeout = 3;

  // Additional metadata to include in streams initiated to the GrpcService. This can be used for
  // scenarios in which additional ad hoc authorization headers (e.g. ``x-foo-bar: baz-key``) are to
  // be injected. For more information, including details on header value syntax, see the
  // documentation on :ref:`custom request headers
  // <config_http_conn_man_headers_custom_request_headers>`.
  repeated HeaderValue initial_metadata = 5;
}
syntax = "proto3";

package envoy.config.core.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/grpc_service.proto";

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "xds/core/v3/authority.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "ConfigSourceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Configuration sources]

// xDS API and non-xDS services version. This is used to describe both resource and transport
// protocol versions (in distinct configuration fields).
enum ApiVersion {
  // When not specified, we assume v2, to ease migration to Envoy's stable API
  // versioning. If a client does not support v2 (e.g. due to deprecation), this
  // is an invalid value.
  AUTO = 0 [deprecated = true, (envoy.annotations.deprecated_at_minor_version_enum) = "3.0"];

  // Use xDS v2 API.
  V2 = 1 [deprecated = true, (envoy.annotations.deprecated_at_minor_version_enum) = "3.0"];

  // Use xDS v3 API.
  V3 = 2;
}

// API configuration source. This identifies the API type and cluster that Envoy
// will use to fetch an xDS API.
// [#next-free-field: 10]
message ApiConfigSource {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.ApiConfigSource";

  // APIs may be fetched via either REST or gRPC.
  enum ApiType {
    // Ideally this would be 'reserved 0' but one can't reserve the default
    // value. Instead we throw an exception if this is ever used.
    DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE = 0
        [deprecated = true, (envoy.annotations.disallowed_by_default_enum) = true];

    // REST-JSON v2 API. The `canonical JSON encoding
    // <https://developers.google.com/protocol-buffers/docs/proto3#json>`_ for
    // the v2 protos is used.
    REST = 1;

    // SotW gRPC service.
    GRPC = 2;

    // Using the delta xDS gRPC service, i.e. DeltaDiscovery{Request,Response}
    // rather than Discovery{Request,Response}. Rather than sending Envoy the entire state
    // with every update, the xDS server only sends what has changed since the last update.
    DELTA_GRPC = 3;

    // SotW xDS gRPC with ADS. All resources which resolve to this configuration source will be
    // multiplexed on a single connection to an ADS endpoint.
    // [#not-implemented-hide:]
    AGGREGATED_GRPC = 5;

    // Delta xDS gRPC with ADS. All resources which resolve to this configuration source will be
    // multiplexed on a single connection to an ADS endpoint.
    // [#not-implemented-hide:]
    AGGREGATED_DELTA_GRPC = 6;
  }

  // API type (gRPC, REST, delta gRPC)
  ApiType api_type = 1 [(validate.rules).enum = {defined_only: true}];

  // API version for xDS transport protocol. This describes the xDS gRPC/REST
  // endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
  ApiVersion transport_api_version = 8 [(validate.rules).enum = {defined_only: true}];

  // Cluster names should be used only with REST. If > 1
  // cluster is defined, clusters will be cycled through if any kind of failure
  // occurs.
  //
  // .. note::
  //
  //  The cluster with name ``cluster_name`` must be statically defined and its
  //  type must not be ``EDS``.
  repeated string cluster_names = 2;

  // Multiple gRPC services be provided for GRPC. If > 1 cluster is defined,
  // services will be cycled through if any kind of failure occurs.
  repeated GrpcService grpc_services = 4;

  // For REST APIs, the delay between successive polls.
  google.protobuf.Duration refresh_delay = 3;

  // For REST APIs, the request timeout. If not set, a default value of 1s will be used.
  google.protobuf.Duration request_timeout = 5 [(validate.rules).duration = {gt {}}];

  // For GRPC APIs, the rate limit settings. If present, discovery requests made by Envoy will be
  // rate limited.
  RateLimitSettings rate_limit_settings = 6;

  // Skip the node identifier in subsequent discovery requests for streaming gRPC config types.
  bool set_node_on_first_message_only = 7;

  // A list of config validators that will be executed when a new update is
  // received from the ApiConfigSource. Note that each validator handles a
  // specific xDS service type, and only the validators corresponding to the
  // type url (in ``:ref: DiscoveryResponse`` or ``:ref: DeltaDiscoveryResponse``)
  // will be invoked.
  // If the validator returns false or throws an exception, the config will be rejected by
  // the client, and a NACK will be sent.
  // [#extension-category: envoy.config.validators]
  repeated TypedExtensionConfig config_validators = 9;
}

// Aggregated Discovery Service (ADS) options. This is currently empty, but when
// set in :ref:`ConfigSource <envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
// specify that ADS is to be used.
message AggregatedConfigSource {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.core.AggregatedConfigSource";
}

// [#not-implemented-hide:]
// Self-referencing config source options. This is currently empty, but when
// set in :ref:`ConfigSource <envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
// specify that other data can be obtained from the same server.
message SelfConfigSource {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.SelfConfigSource";

  // API version for xDS transport protocol. This describes the xDS gRPC/REST
  // endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
  ApiVersion transport_api_version = 1 [(validate.rules).enum = {defined_only: true}];
}

// Rate Limit settings to be applied for discovery requests made by Envoy.
message RateLimitSettings {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.core.RateLimitSettings";

  // Maximum number of tokens to be used for rate limiting discovery request calls. If not set, a
  // default value of 100 will be used.
  google.protobuf.UInt32Value max_tokens = 1;

  // Rate at which tokens will be filled per second. If not set, a default fill rate of 10 tokens
  // per second will be used. The minimal fill rate is once per year. Lower
  // fill rates will be set to once per year.
  google.protobuf.DoubleValue fill_rate = 2 [(validate.rules).double = {gt: 0.0}];
}

// Local filesystem path configuration source.
message PathConfigSource {
  // Path on the filesystem to source and watch for configuration updates.
  // When sourcing configuration for a :ref:`secret <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.Secret>`,
  // the certificate and key files are also watched for updates.
  //
  // .. note::
  //
  //  The path to the source must exist at config load time.
  //
  // .. note::
  //
  //   If ``watched_directory`` is *not* configured, Envoy will watch the file path for *moves*.
  //   This is because in general only moves are atomic. The same method of swapping files as is
  //   demonstrated in the :ref:`runtime documentation <config_runtime_symbolic_link_swap>` can be
  //   used here also. If ``watched_directory`` is configured, no watch will be placed directly on
  //   this path. Instead, the configured ``watched_directory`` will be used to trigger reloads of
  //   this path. This is required in certain deployment scenarios. See below for more information.
  string path = 1 [(validate.rules).string = {min_len: 1}];

  // If configured, this directory will be watched for *moves*. When an entry in this directory is
  // moved to, the ``path`` will be reloaded. This is required in certain deployment scenarios.
  //
  // Specifically, if trying to load an xDS resource using a
  // `Kubernetes ConfigMap <https://kubernetes.io/docs/concepts/configuration/configmap/>`_, the
  // following configuration might be used:
  // 1. Store xds.yaml inside a ConfigMap.
  // 2. Mount the ConfigMap to ``/config_map/xds``
  // 3. Configure path ``/config_map/xds/xds.yaml``
  // 4. Configure watched directory ``/config_map/xds``
  //
  // The above configuration will ensure that Envoy watches the owning directory for moves which is
  // required due to how Kubernetes manages ConfigMap symbolic links during atomic updates.
  WatchedDirectory watched_directory = 2;
}

// Configuration for :ref:`listeners <config_listeners>`, :ref:`clusters
// <config_cluster_manager>`, :ref:`routes
// <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`, :ref:`endpoints
// <arch_overview_service_discovery>` etc. may either be sourced from the
// filesystem or from an xDS API source. Filesystem configs are watched with
// inotify for updates.
// [#next-free-field: 9]
message ConfigSource {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.ConfigSource";

  // Authorities that this config source may be used for. An authority specified in a xdstp:// URL
  // is resolved to a ``ConfigSource`` prior to configuration fetch. This field provides the
  // association between authority name and configuration source.
  // [#not-implemented-hide:]
  repeated xds.core.v3.Authority authorities = 7;

  oneof config_source_specifier {
    option (validate.required) = true;

    // Deprecated in favor of ``path_config_source``. Use that field instead.
    string path = 1 [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

    // Local filesystem path configuration source.
    PathConfigSource path_config_source = 8;

    // API configuration source.
    ApiConfigSource api_config_source = 2;

    // When set, ADS will be used to fetch resources. The ADS API configuration
    // source in the bootstrap configuration is used.
    AggregatedConfigSource ads = 3;

    // [#not-implemented-hide:]
    // When set, the client will access the resources from the same server it got the
    // ConfigSource from, although not necessarily from the same stream. This is similar to the
    // :ref:`ads<envoy_v3_api_field.ConfigSource.ads>` field, except that the client may use a
    // different stream to the same server. As a result, this field can be used for things
    // like LRS that cannot be sent on an ADS stream. It can also be used to link from (e.g.)
    // LDS to RDS on the same server without requiring the management server to know its name
    // or required credentials.
    // [#next-major-version: In xDS v3, consider replacing the ads field with this one, since
    // this field can implicitly mean to use the same stream in the case where the ConfigSource
    // is provided via ADS and the specified data can also be obtained via ADS.]
    SelfConfigSource self = 5;
  }

  // When this timeout is specified, Envoy will wait no longer than the specified time for first
  // config response on this xDS subscription during the :ref:`initialization process
  // <arch_overview_initialization>`. After reaching the timeout, Envoy will move to the next
  // initialization phase, even if the first config is not delivered yet. The timer is activated
  // when the xDS API subscription starts, and is disarmed on first config update or on error. 0
  // means no timeout - Envoy will wait indefinitely for the first xDS config (unless another
  // timeout applies). The default is 15s.
  google.protobuf.Duration initial_fetch_timeout = 4;

  // API version for xDS resources. This implies the type URLs that the client
  // will request for resources and the resource type that the client will in
  // turn expect to be delivered.
  ApiVersion resource_api_version = 6 [(validate.rules).enum = {defined_only: true}];
}

// Configuration source specifier for a late-bound extension configuration. The
// parent resource is warmed until all the initial extension configurations are
// received, unless the flag to apply the default configuration is set.
// Subsequent extension updates are atomic on a per-worker basis. Once an
// extension configuration is applied to a request or a connection, it remains
// constant for the duration of processing. If the initial delivery of the
// extension configuration fails, due to a timeout for example, the optional
// default configuration is applied. Without a default configuration, the
// extension is disabled, until an extension configuration is received. The
// behavior of a disabled extension depends on the context. For example, a
// filter chain with a disabled extension filter rejects all incoming streams.
message ExtensionConfigSource {
  ConfigSource config_source = 1 [(validate.rules).any = {required: true}];

  // Optional default configuration to use as the initial configuration if
  // there is a failure to receive the initial extension configuration or if
  // ``apply_default_config_without_warming`` flag is set.
  google.protobuf.Any default_config = 2;

  // Use the default config as the initial configuration without warming and
  // waiting for the first discovery response. Requires the default configuration
  // to be supplied.
  bool apply_default_config_without_warming = 3;

  // A set of permitted extension type URLs. Extension configuration updates are rejected
  // if they do not match any type URL in the set.
  repeated string type_urls = 4 [(validate.rules).repeated = {min_items: 1}];
}
syntax = "proto3";

package envoy.config.core.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";

import "google/protobuf/struct.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "SubstitutionFormatStringProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Substitution format string]

// Optional configuration options to be used with json_format.
message JsonFormatOptions {
  // The output JSON string properties will be sorted.
  bool sort_properties = 1;
}

// Configuration to use multiple :ref:`command operators <config_access_log_command_operators>`
// to generate a new string in either plain text or JSON format.
// [#next-free-field: 8]
message SubstitutionFormatString {
  oneof format {
    option (validate.required) = true;

    // Specify a format with command operators to form a text string.
    // Its details is described in :ref:`format string<config_access_log_format_strings>`.
    //
    // For example, setting ``text_format`` like below,
    //
    // .. validated-code-block:: yaml
    //   :type-name: envoy.config.core.v3.SubstitutionFormatString
    //
    //   text_format: "%LOCAL_REPLY_BODY%:%RESPONSE_CODE%:path=%REQ(:path)%\n"
    //
    // generates plain text similar to:
    //
    // .. code-block:: text
    //
    //   upstream connect error:503:path=/foo
    //
    // Deprecated in favor of :ref:`text_format_source <envoy_v3_api_field_config.core.v3.SubstitutionFormatString.text_format_source>`. To migrate text format strings, use the :ref:`inline_string <envoy_v3_api_field_config.core.v3.DataSource.inline_string>` field.
    string text_format = 1
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

    // Specify a format with command operators to form a JSON string.
    // Its details is described in :ref:`format dictionary<config_access_log_format_dictionaries>`.
    // Values are rendered as strings, numbers, or boolean values as appropriate.
    // Nested JSON objects may be produced by some command operators (e.g. FILTER_STATE or DYNAMIC_METADATA).
    // See the documentation for a specific command operator for details.
    //
    // .. validated-code-block:: yaml
    //   :type-name: envoy.config.core.v3.SubstitutionFormatString
    //
    //   json_format:
    //     status: "%RESPONSE_CODE%"
    //     message: "%LOCAL_REPLY_BODY%"
    //
    // The following JSON object would be created:
    //
    // .. code-block:: json
    //
    //  {
    //    "status": 500,
    //    "message": "My error message"
    //  }
    //
    google.protobuf.Struct json_format = 2 [(validate.rules).message = {required: true}];

    // Specify a format with command operators to form a text string.
    // Its details is described in :ref:`format string<config_access_log_format_strings>`.
    //
    // For example, setting ``text_format`` like below,
    //
    // .. validated-code-block:: yaml
    //   :type-name: envoy.config.core.v3.SubstitutionFormatString
    //
    //   text_format_source:
    //     inline_string: "%LOCAL_REPLY_BODY%:%RESPONSE_CODE%:path=%REQ(:path)%\n"
    //
    // generates plain text similar to:
    //
    // .. code-block:: text
    //
    //   upstream connect error:503:path=/foo
    //
    DataSource text_format_source = 5;
  }

  // If set to true, when command operators are evaluated to null,
  //
  // * for ``text_format``, the output of the empty operator is changed from ``-`` to an
  //   empty string, so that empty values are omitted entirely.
  // * for ``json_format`` the keys with null values are omitted in the output structure.
  bool omit_empty_values = 3;

  // Specify a ``content_type`` field.
  // If this field is not set then ``text/plain`` is used for ``text_format`` and
  // ``application/json`` is used for ``json_format``.
  //
  // .. validated-code-block:: yaml
  //   :type-name: envoy.config.core.v3.SubstitutionFormatString
  //
  //   content_type: "text/html; charset=UTF-8"
  //
  string content_type = 4
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];

  // Specifies a collection of Formatter plugins that can be called from the access log configuration.
  // See the formatters extensions documentation for details.
  // [#extension-category: envoy.formatter]
  repeated TypedExtensionConfig formatters = 6;

  // If json_format is used, the options will be applied to the output JSON string.
  JsonFormatOptions json_format_options = 7;
}
syntax = "proto3";

package envoy.config.core.v3;

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "BackoffProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Backoff strategy]

// Configuration defining a jittered exponential back off strategy.
message BackoffStrategy {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.BackoffStrategy";

  // The base interval to be used for the next back off computation. It should
  // be greater than zero and less than or equal to :ref:`max_interval
  // <envoy_v3_api_field_config.core.v3.BackoffStrategy.max_interval>`.
  google.protobuf.Duration base_interval = 1 [(validate.rules).duration = {
    required: true
    gte {nanos: 1000000}
  }];

  // Specifies the maximum interval between retries. This parameter is optional,
  // but must be greater than or equal to the :ref:`base_interval
  // <envoy_v3_api_field_config.core.v3.BackoffStrategy.base_interval>` if set. The default
  // is 10 times the :ref:`base_interval
  // <envoy_v3_api_field_config.core.v3.BackoffStrategy.base_interval>`.
  google.protobuf.Duration max_interval = 2 [(validate.rules).duration = {gt {}}];
}
syntax = "proto3";

package envoy.config.core.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.core.v3";
option java_outer_classname = "GrpcMethodListProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/core/v3;corev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: gRPC method list]

// A list of gRPC methods which can be used as an allowlist, for example.
message GrpcMethodList {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.core.GrpcMethodList";

  message Service {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.core.GrpcMethodList.Service";

    // The name of the gRPC service.
    string name = 1 [(validate.rules).string = {min_len: 1}];

    // The names of the gRPC methods in this service.
    repeated string method_names = 2 [(validate.rules).repeated = {min_items: 1}];
  }

  repeated Service services = 1;
}
syntax = "proto3";

package envoy.config.bootstrap.v2;

import "envoy/api/v2/auth/secret.proto";
import "envoy/api/v2/cluster.proto";
import "envoy/api/v2/core/address.proto";
import "envoy/api/v2/core/base.proto";
import "envoy/api/v2/core/config_source.proto";
import "envoy/api/v2/core/event_service_config.proto";
import "envoy/api/v2/core/socket_option.proto";
import "envoy/api/v2/listener.proto";
import "envoy/config/metrics/v2/stats.proto";
import "envoy/config/overload/v2alpha/overload.proto";
import "envoy/config/trace/v2/http_tracer.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.bootstrap.v2";
option java_outer_classname = "BootstrapProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v2;bootstrapv2";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Bootstrap]
// This proto is supplied via the :option:`-c` CLI flag and acts as the root
// of the Envoy v2 configuration. See the :ref:`v2 configuration overview
// <config_overview_bootstrap>` for more detail.

// Bootstrap :ref:`configuration overview <config_overview_bootstrap>`.
// [#next-free-field: 21]
message Bootstrap {
  message StaticResources {
    // Static :ref:`Listeners <envoy_api_msg_Listener>`. These listeners are
    // available regardless of LDS configuration.
    repeated api.v2.Listener listeners = 1;

    // If a network based configuration source is specified for :ref:`cds_config
    // <envoy_api_field_config.bootstrap.v2.Bootstrap.DynamicResources.cds_config>`, it's necessary
    // to have some initial cluster definitions available to allow Envoy to know
    // how to speak to the management server. These cluster definitions may not
    // use :ref:`EDS <arch_overview_dynamic_config_eds>` (i.e. they should be static
    // IP or DNS-based).
    repeated api.v2.Cluster clusters = 2;

    // These static secrets can be used by :ref:`SdsSecretConfig
    // <envoy_api_msg_auth.SdsSecretConfig>`
    repeated api.v2.auth.Secret secrets = 3;
  }

  message DynamicResources {
    reserved 4;

    // All :ref:`Listeners <envoy_api_msg_Listener>` are provided by a single
    // :ref:`LDS <arch_overview_dynamic_config_lds>` configuration source.
    api.v2.core.ConfigSource lds_config = 1;

    // All post-bootstrap :ref:`Cluster <envoy_api_msg_Cluster>` definitions are
    // provided by a single :ref:`CDS <arch_overview_dynamic_config_cds>`
    // configuration source.
    api.v2.core.ConfigSource cds_config = 2;

    // A single :ref:`ADS <config_overview_ads>` source may be optionally
    // specified. This must have :ref:`api_type
    // <envoy_api_field_core.ApiConfigSource.api_type>` :ref:`GRPC
    // <envoy_api_enum_value_core.ApiConfigSource.ApiType.GRPC>`. Only
    // :ref:`ConfigSources <envoy_api_msg_core.ConfigSource>` that have
    // the :ref:`ads <envoy_api_field_core.ConfigSource.ads>` field set will be
    // streamed on the ADS channel.
    api.v2.core.ApiConfigSource ads_config = 3;
  }

  reserved 10;

  // Node identity to present to the management server and for instance
  // identification purposes (e.g. in generated headers).
  api.v2.core.Node node = 1;

  // Statically specified resources.
  StaticResources static_resources = 2;

  // xDS configuration sources.
  DynamicResources dynamic_resources = 3;

  // Configuration for the cluster manager which owns all upstream clusters
  // within the server.
  ClusterManager cluster_manager = 4;

  // Health discovery service config option.
  // (:ref:`core.ApiConfigSource <envoy_api_msg_core.ApiConfigSource>`)
  api.v2.core.ApiConfigSource hds_config = 14;

  // Optional file system path to search for startup flag files.
  string flags_path = 5;

  // Optional set of stats sinks.
  repeated metrics.v2.StatsSink stats_sinks = 6;

  // Configuration for internal processing of stats.
  metrics.v2.StatsConfig stats_config = 13;

  // Optional duration between flushes to configured stats sinks. For
  // performance reasons Envoy latches counters and only flushes counters and
  // gauges at a periodic interval. If not specified the default is 5000ms (5
  // seconds).
  // Duration must be at least 1ms and at most 5 min.
  google.protobuf.Duration stats_flush_interval = 7 [(validate.rules).duration = {
    lt {seconds: 300}
    gte {nanos: 1000000}
  }];

  // Optional watchdog configuration.
  Watchdog watchdog = 8;

  // Configuration for an external tracing provider.
  //
  // .. attention::
  //  This field has been deprecated in favor of :ref:`HttpConnectionManager.Tracing.provider
  //  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing.provider>`.
  trace.v2.Tracing tracing = 9;

  // Configuration for the runtime configuration provider (deprecated). If not
  // specified, a null provider will be used which will result in all defaults
  // being used.
  Runtime runtime = 11 [deprecated = true, (envoy.annotations.disallowed_by_default) = true];

  // Configuration for the runtime configuration provider. If not
  // specified, a null provider will be used which will result in all defaults
  // being used.
  LayeredRuntime layered_runtime = 17;

  // Configuration for the local administration HTTP server.
  Admin admin = 12;

  // Optional overload manager configuration.
  overload.v2alpha.OverloadManager overload_manager = 15;

  // Enable :ref:`stats for event dispatcher <operations_performance>`, defaults to false.
  // Note that this records a value for each iteration of the event loop on every thread. This
  // should normally be minimal overhead, but when using
  // :ref:`statsd <envoy_api_msg_config.metrics.v2.StatsdSink>`, it will send each observed value
  // over the wire individually because the statsd protocol doesn't have any way to represent a
  // histogram summary. Be aware that this can be a very large volume of data.
  bool enable_dispatcher_stats = 16;

  // Optional string which will be used in lieu of x-envoy in prefixing headers.
  //
  // For example, if this string is present and set to X-Foo, then x-envoy-retry-on will be
  // transformed into x-foo-retry-on etc.
  //
  // Note this applies to the headers Envoy will generate, the headers Envoy will sanitize, and the
  // headers Envoy will trust for core code and core extensions only. Be VERY careful making
  // changes to this string, especially in multi-layer Envoy deployments or deployments using
  // extensions which are not upstream.
  string header_prefix = 18;

  // Optional proxy version which will be used to set the value of :ref:`server.version statistic
  // <server_statistics>` if specified. Envoy will not process this value, it will be sent as is to
  // :ref:`stats sinks <envoy_api_msg_config.metrics.v2.StatsSink>`.
  google.protobuf.UInt64Value stats_server_version_override = 19;

  // Always use TCP queries instead of UDP queries for DNS lookups.
  // This may be overridden on a per-cluster basis in cds_config,
  // when :ref:`dns_resolvers <envoy_api_field_Cluster.dns_resolvers>` and
  // :ref:`use_tcp_for_dns_lookups <envoy_api_field_Cluster.use_tcp_for_dns_lookups>` are
  // specified.
  // Setting this value causes failure if the
  // ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
  // server startup. Apple' API only uses UDP for DNS resolution.
  bool use_tcp_for_dns_lookups = 20;
}

// Administration interface :ref:`operations documentation
// <operations_admin_interface>`.
message Admin {
  // The path to write the access log for the administration server. If no
  // access log is desired specify /dev/null. This is only required if
  // :ref:`address <envoy_api_field_config.bootstrap.v2.Admin.address>` is set.
  string access_log_path = 1;

  // The cpu profiler output path for the administration server. If no profile
  // path is specified, the default is /var/log/envoy/envoy.prof.
  string profile_path = 2;

  // The TCP address that the administration server will listen on.
  // If not specified, Envoy will not start an administration server.
  api.v2.core.Address address = 3;

  // Additional socket options that may not be present in Envoy source code or
  // precompiled binaries.
  repeated api.v2.core.SocketOption socket_options = 4;
}

// Cluster manager :ref:`architecture overview <arch_overview_cluster_manager>`.
message ClusterManager {
  message OutlierDetection {
    // Specifies the path to the outlier event log.
    string event_log_path = 1;

    // [#not-implemented-hide:]
    // The gRPC service for the outlier detection event service.
    // If empty, outlier detection events won't be sent to a remote endpoint.
    api.v2.core.EventServiceConfig event_service = 2;
  }

  // Name of the local cluster (i.e., the cluster that owns the Envoy running
  // this configuration). In order to enable :ref:`zone aware routing
  // <arch_overview_load_balancing_zone_aware_routing>` this option must be set.
  // If *local_cluster_name* is defined then :ref:`clusters
  // <envoy_api_msg_Cluster>` must be defined in the :ref:`Bootstrap
  // static cluster resources
  // <envoy_api_field_config.bootstrap.v2.Bootstrap.StaticResources.clusters>`. This is unrelated to
  // the :option:`--service-cluster` option which does not `affect zone aware
  // routing <https://github.com/envoyproxy/envoy/issues/774>`_.
  string local_cluster_name = 1;

  // Optional global configuration for outlier detection.
  OutlierDetection outlier_detection = 2;

  // Optional configuration used to bind newly established upstream connections.
  // This may be overridden on a per-cluster basis by upstream_bind_config in the cds_config.
  api.v2.core.BindConfig upstream_bind_config = 3;

  // A management server endpoint to stream load stats to via
  // *StreamLoadStats*. This must have :ref:`api_type
  // <envoy_api_field_core.ApiConfigSource.api_type>` :ref:`GRPC
  // <envoy_api_enum_value_core.ApiConfigSource.ApiType.GRPC>`.
  api.v2.core.ApiConfigSource load_stats_config = 4;
}

// Envoy process watchdog configuration. When configured, this monitors for
// nonresponsive threads and kills the process after the configured thresholds.
// See the :ref:`watchdog documentation <operations_performance_watchdog>` for more information.
message Watchdog {
  // The duration after which Envoy counts a nonresponsive thread in the
  // *watchdog_miss* statistic. If not specified the default is 200ms.
  google.protobuf.Duration miss_timeout = 1;

  // The duration after which Envoy counts a nonresponsive thread in the
  // *watchdog_mega_miss* statistic. If not specified the default is
  // 1000ms.
  google.protobuf.Duration megamiss_timeout = 2;

  // If a watched thread has been nonresponsive for this duration, assume a
  // programming error and kill the entire Envoy process. Set to 0 to disable
  // kill behavior. If not specified the default is 0 (disabled).
  google.protobuf.Duration kill_timeout = 3;

  // If at least two watched threads have been nonresponsive for at least this
  // duration assume a true deadlock and kill the entire Envoy process. Set to 0
  // to disable this behavior. If not specified the default is 0 (disabled).
  google.protobuf.Duration multikill_timeout = 4;
}

// Runtime :ref:`configuration overview <config_runtime>` (deprecated).
message Runtime {
  // The implementation assumes that the file system tree is accessed via a
  // symbolic link. An atomic link swap is used when a new tree should be
  // switched to. This parameter specifies the path to the symbolic link. Envoy
  // will watch the location for changes and reload the file system tree when
  // they happen. If this parameter is not set, there will be no disk based
  // runtime.
  string symlink_root = 1;

  // Specifies the subdirectory to load within the root directory. This is
  // useful if multiple systems share the same delivery mechanism. Envoy
  // configuration elements can be contained in a dedicated subdirectory.
  string subdirectory = 2;

  // Specifies an optional subdirectory to load within the root directory. If
  // specified and the directory exists, configuration values within this
  // directory will override those found in the primary subdirectory. This is
  // useful when Envoy is deployed across many different types of servers.
  // Sometimes it is useful to have a per service cluster directory for runtime
  // configuration. See below for exactly how the override directory is used.
  string override_subdirectory = 3;

  // Static base runtime. This will be :ref:`overridden
  // <config_runtime_layering>` by other runtime layers, e.g.
  // disk or admin. This follows the :ref:`runtime protobuf JSON representation
  // encoding <config_runtime_proto_json>`.
  google.protobuf.Struct base = 4;
}

// [#next-free-field: 6]
message RuntimeLayer {
  // :ref:`Disk runtime <config_runtime_local_disk>` layer.
  message DiskLayer {
    // The implementation assumes that the file system tree is accessed via a
    // symbolic link. An atomic link swap is used when a new tree should be
    // switched to. This parameter specifies the path to the symbolic link.
    // Envoy will watch the location for changes and reload the file system tree
    // when they happen. See documentation on runtime :ref:`atomicity
    // <config_runtime_atomicity>` for further details on how reloads are
    // treated.
    string symlink_root = 1;

    // Specifies the subdirectory to load within the root directory. This is
    // useful if multiple systems share the same delivery mechanism. Envoy
    // configuration elements can be contained in a dedicated subdirectory.
    string subdirectory = 3;

    // :ref:`Append <config_runtime_local_disk_service_cluster_subdirs>` the
    // service cluster to the path under symlink root.
    bool append_service_cluster = 2;
  }

  // :ref:`Admin console runtime <config_runtime_admin>` layer.
  message AdminLayer {
  }

  // :ref:`Runtime Discovery Service (RTDS) <config_runtime_rtds>` layer.
  message RtdsLayer {
    // Resource to subscribe to at *rtds_config* for the RTDS layer.
    string name = 1;

    // RTDS configuration source.
    api.v2.core.ConfigSource rtds_config = 2;
  }

  // Descriptive name for the runtime layer. This is only used for the runtime
  // :http:get:`/runtime` output.
  string name = 1 [(validate.rules).string = {min_bytes: 1}];

  oneof layer_specifier {
    option (validate.required) = true;

    // :ref:`Static runtime <config_runtime_bootstrap>` layer.
    // This follows the :ref:`runtime protobuf JSON representation encoding
    // <config_runtime_proto_json>`. Unlike static xDS resources, this static
    // layer is overridable by later layers in the runtime virtual filesystem.
    google.protobuf.Struct static_layer = 2;

    DiskLayer disk_layer = 3;

    AdminLayer admin_layer = 4;

    RtdsLayer rtds_layer = 5;
  }
}

// Runtime :ref:`configuration overview <config_runtime>`.
message LayeredRuntime {
  // The :ref:`layers <config_runtime_layering>` of the runtime. This is ordered
  // such that later layers in the list overlay earlier entries.
  repeated RuntimeLayer layers = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/api/v2:pkg",
        "//envoy/api/v2/auth:pkg",
        "//envoy/api/v2/core:pkg",
        "//envoy/config/metrics/v2:pkg",
        "//envoy/config/overload/v2alpha:pkg",
        "//envoy/config/trace/v2:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.bootstrap.v3;

import "envoy/config/accesslog/v3/accesslog.proto";
import "envoy/config/cluster/v3/cluster.proto";
import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/config_source.proto";
import "envoy/config/core/v3/event_service_config.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/resolver.proto";
import "envoy/config/core/v3/socket_option.proto";
import "envoy/config/listener/v3/listener.proto";
import "envoy/config/metrics/v3/stats.proto";
import "envoy/config/overload/v3/overload.proto";
import "envoy/config/trace/v3/http_tracer.proto";
import "envoy/extensions/transport_sockets/tls/v3/secret.proto";
import "envoy/type/v3/percent.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/security.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.bootstrap.v3";
option java_outer_classname = "BootstrapProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3;bootstrapv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Bootstrap]
// This proto is supplied via the :option:`-c` CLI flag and acts as the root
// of the Envoy v3 configuration. See the :ref:`v3 configuration overview
// <config_overview_bootstrap>` for more detail.

// Bootstrap :ref:`configuration overview <config_overview_bootstrap>`.
// [#next-free-field: 41]
message Bootstrap {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.bootstrap.v2.Bootstrap";

  message StaticResources {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.bootstrap.v2.Bootstrap.StaticResources";

    // Static :ref:`Listeners <envoy_v3_api_msg_config.listener.v3.Listener>`. These listeners are
    // available regardless of LDS configuration.
    repeated listener.v3.Listener listeners = 1;

    // If a network based configuration source is specified for :ref:`cds_config
    // <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.DynamicResources.cds_config>`, it's necessary
    // to have some initial cluster definitions available to allow Envoy to know
    // how to speak to the management server. These cluster definitions may not
    // use :ref:`EDS <arch_overview_dynamic_config_eds>` (i.e. they should be static
    // IP or DNS-based).
    repeated cluster.v3.Cluster clusters = 2;

    // These static secrets can be used by :ref:`SdsSecretConfig
    // <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.SdsSecretConfig>`
    repeated envoy.extensions.transport_sockets.tls.v3.Secret secrets = 3;
  }

  // [#next-free-field: 7]
  message DynamicResources {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.bootstrap.v2.Bootstrap.DynamicResources";

    reserved 4;

    // All :ref:`Listeners <envoy_v3_api_msg_config.listener.v3.Listener>` are provided by a single
    // :ref:`LDS <arch_overview_dynamic_config_lds>` configuration source.
    core.v3.ConfigSource lds_config = 1;

    // xdstp:// resource locator for listener collection.
    // [#not-implemented-hide:]
    string lds_resources_locator = 5;

    // All post-bootstrap :ref:`Cluster <envoy_v3_api_msg_config.cluster.v3.Cluster>` definitions are
    // provided by a single :ref:`CDS <arch_overview_dynamic_config_cds>`
    // configuration source.
    core.v3.ConfigSource cds_config = 2;

    // xdstp:// resource locator for cluster collection.
    // [#not-implemented-hide:]
    string cds_resources_locator = 6;

    // A single :ref:`ADS <config_overview_ads>` source may be optionally
    // specified. This must have :ref:`api_type
    // <envoy_v3_api_field_config.core.v3.ApiConfigSource.api_type>` :ref:`GRPC
    // <envoy_v3_api_enum_value_config.core.v3.ApiConfigSource.ApiType.GRPC>`. Only
    // :ref:`ConfigSources <envoy_v3_api_msg_config.core.v3.ConfigSource>` that have
    // the :ref:`ads <envoy_v3_api_field_config.core.v3.ConfigSource.ads>` field set will be
    // streamed on the ADS channel.
    core.v3.ApiConfigSource ads_config = 3;
  }

  message ApplicationLogConfig {
    message LogFormat {
      oneof log_format {
        option (validate.required) = true;

        // Flush application logs in JSON format. The configured JSON struct can
        // support all the format flags specified in the :option:`--log-format`
        // command line options section, except for the ``%v`` and ``%_`` flags.
        google.protobuf.Struct json_format = 1;

        // Flush application log in a format defined by a string. The text format
        // can support all the format flags specified in the :option:`--log-format`
        // command line option section.
        string text_format = 2;
      }
    }

    // Optional field to set the application logs format. If this field is set, it will override
    // the default log format. Setting both this field and :option:`--log-format` command line
    // option is not allowed, and will cause a bootstrap error.
    LogFormat log_format = 1;
  }

  message DeferredStatOptions {
    // When the flag is enabled, Envoy will lazily initialize a subset of the stats (see below).
    // This will save memory and CPU cycles when creating the objects that own these stats, if those
    // stats are never referenced throughout the lifetime of the process. However, it will incur additional
    // memory overhead for these objects, and a small increase of CPU usage when a at least one of the stats
    // is updated for the first time.
    // Groups of stats that will be lazily initialized:
    // - Cluster traffic stats: a subgroup of the :ref:`cluster statistics <config_cluster_manager_cluster_stats>`
    // that are used when requests are routed to the cluster.
    bool enable_deferred_creation_stats = 1;
  }

  message GrpcAsyncClientManagerConfig {
    // Optional field to set the expiration time for the cached gRPC client object.
    // The minimal value is 5s and the default is 50s.
    google.protobuf.Duration max_cached_entry_idle_duration = 1
        [(validate.rules).duration = {gte {seconds: 5}}];
  }

  reserved 10, 11;

  reserved "runtime";

  // Node identity to present to the management server and for instance
  // identification purposes (e.g. in generated headers).
  core.v3.Node node = 1;

  // A list of :ref:`Node <envoy_v3_api_msg_config.core.v3.Node>` field names
  // that will be included in the context parameters of the effective
  // xdstp:// URL that is sent in a discovery request when resource
  // locators are used for LDS/CDS. Any non-string field will have its JSON
  // encoding set as the context parameter value, with the exception of
  // metadata, which will be flattened (see example below). The supported field
  // names are:
  // - "cluster"
  // - "id"
  // - "locality.region"
  // - "locality.sub_zone"
  // - "locality.zone"
  // - "metadata"
  // - "user_agent_build_version.metadata"
  // - "user_agent_build_version.version"
  // - "user_agent_name"
  // - "user_agent_version"
  //
  // The node context parameters act as a base layer dictionary for the context
  // parameters (i.e. more specific resource specific context parameters will
  // override). Field names will be prefixed with udpa.node. when included in
  // context parameters.
  //
  // For example, if node_context_params is ``["user_agent_name", "metadata"]``,
  // the implied context parameters might be::
  //
  //   node.user_agent_name: "envoy"
  //   node.metadata.foo: "{\"bar\": \"baz\"}"
  //   node.metadata.some: "42"
  //   node.metadata.thing: "\"thing\""
  //
  // [#not-implemented-hide:]
  repeated string node_context_params = 26;

  // Statically specified resources.
  StaticResources static_resources = 2;

  // xDS configuration sources.
  DynamicResources dynamic_resources = 3;

  // Configuration for the cluster manager which owns all upstream clusters
  // within the server.
  ClusterManager cluster_manager = 4;

  // Health discovery service config option.
  // (:ref:`core.ApiConfigSource <envoy_v3_api_msg_config.core.v3.ApiConfigSource>`)
  core.v3.ApiConfigSource hds_config = 14;

  // Optional file system path to search for startup flag files.
  string flags_path = 5;

  // Optional set of stats sinks.
  repeated metrics.v3.StatsSink stats_sinks = 6;

  // Options to control behaviors of deferred creation compatible stats.
  DeferredStatOptions deferred_stat_options = 39;

  // Configuration for internal processing of stats.
  metrics.v3.StatsConfig stats_config = 13;

  // Optional duration between flushes to configured stats sinks. For
  // performance reasons Envoy latches counters and only flushes counters and
  // gauges at a periodic interval. If not specified the default is 5000ms (5
  // seconds). Only one of ``stats_flush_interval`` or ``stats_flush_on_admin``
  // can be set.
  // Duration must be at least 1ms and at most 5 min.
  google.protobuf.Duration stats_flush_interval = 7 [
    (validate.rules).duration = {
      lt {seconds: 300}
      gte {nanos: 1000000}
    },
    (udpa.annotations.field_migrate).oneof_promotion = "stats_flush"
  ];

  oneof stats_flush {
    // Flush stats to sinks only when queried for on the admin interface. If set,
    // a flush timer is not created. Only one of ``stats_flush_on_admin`` or
    // ``stats_flush_interval`` can be set.
    bool stats_flush_on_admin = 29 [(validate.rules).bool = {const: true}];
  }

  // Optional watchdog configuration.
  // This is for a single watchdog configuration for the entire system.
  // Deprecated in favor of ``watchdogs`` which has finer granularity.
  Watchdog watchdog = 8
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Optional watchdogs configuration.
  // This is used for specifying different watchdogs for the different subsystems.
  // [#extension-category: envoy.guarddog_actions]
  Watchdogs watchdogs = 27;

  // Configuration for an external tracing provider.
  //
  // .. attention::
  //  This field has been deprecated in favor of :ref:`HttpConnectionManager.Tracing.provider
  //  <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.provider>`.
  trace.v3.Tracing tracing = 9
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Configuration for the runtime configuration provider. If not
  // specified, a null provider will be used which will result in all defaults
  // being used.
  LayeredRuntime layered_runtime = 17;

  // Configuration for the local administration HTTP server.
  Admin admin = 12;

  // Optional overload manager configuration.
  overload.v3.OverloadManager overload_manager = 15 [
    (udpa.annotations.security).configure_for_untrusted_downstream = true,
    (udpa.annotations.security).configure_for_untrusted_upstream = true
  ];

  // Enable :ref:`stats for event dispatcher <operations_performance>`, defaults to false.
  // Note that this records a value for each iteration of the event loop on every thread. This
  // should normally be minimal overhead, but when using
  // :ref:`statsd <envoy_v3_api_msg_config.metrics.v3.StatsdSink>`, it will send each observed value
  // over the wire individually because the statsd protocol doesn't have any way to represent a
  // histogram summary. Be aware that this can be a very large volume of data.
  bool enable_dispatcher_stats = 16;

  // Optional string which will be used in lieu of x-envoy in prefixing headers.
  //
  // For example, if this string is present and set to X-Foo, then x-envoy-retry-on will be
  // transformed into x-foo-retry-on etc.
  //
  // Note this applies to the headers Envoy will generate, the headers Envoy will sanitize, and the
  // headers Envoy will trust for core code and core extensions only. Be VERY careful making
  // changes to this string, especially in multi-layer Envoy deployments or deployments using
  // extensions which are not upstream.
  string header_prefix = 18;

  // Optional proxy version which will be used to set the value of :ref:`server.version statistic
  // <server_statistics>` if specified. Envoy will not process this value, it will be sent as is to
  // :ref:`stats sinks <envoy_v3_api_msg_config.metrics.v3.StatsSink>`.
  google.protobuf.UInt64Value stats_server_version_override = 19;

  // Always use TCP queries instead of UDP queries for DNS lookups.
  // This may be overridden on a per-cluster basis in cds_config,
  // when :ref:`dns_resolvers <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolvers>` and
  // :ref:`use_tcp_for_dns_lookups <envoy_v3_api_field_config.cluster.v3.Cluster.use_tcp_for_dns_lookups>` are
  // specified.
  // This field is deprecated in favor of ``dns_resolution_config``
  // which aggregates all of the DNS resolver configuration in a single message.
  bool use_tcp_for_dns_lookups = 20
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // DNS resolution configuration which includes the underlying dns resolver addresses and options.
  // This may be overridden on a per-cluster basis in cds_config, when
  // :ref:`dns_resolution_config <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>`
  // is specified.
  // This field is deprecated in favor of
  // :ref:`typed_dns_resolver_config <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.typed_dns_resolver_config>`.
  core.v3.DnsResolutionConfig dns_resolution_config = 30
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
  // or any other DNS resolver types and the related parameters.
  // For example, an object of
  // :ref:`CaresDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
  // can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
  // :ref:`dns_resolution_config <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.dns_resolution_config>`
  // configuration.
  // During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
  // when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
  // When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
  // [#extension-category: envoy.network.dns_resolver]
  core.v3.TypedExtensionConfig typed_dns_resolver_config = 31;

  // Specifies optional bootstrap extensions to be instantiated at startup time.
  // Each item contains extension specific configuration.
  // [#extension-category: envoy.bootstrap]
  repeated core.v3.TypedExtensionConfig bootstrap_extensions = 21;

  // Specifies optional extensions instantiated at startup time and
  // invoked during crash time on the request that caused the crash.
  repeated FatalAction fatal_actions = 28;

  // Configuration sources that will participate in
  // xdstp:// URL authority resolution. The algorithm is as
  // follows:
  // 1. The authority field is taken from the xdstp:// URL, call
  //    this ``resource_authority``.
  // 2. ``resource_authority`` is compared against the authorities in any peer
  //    ``ConfigSource``. The peer ``ConfigSource`` is the configuration source
  //    message which would have been used unconditionally for resolution
  //    with opaque resource names. If there is a match with an authority, the
  //    peer ``ConfigSource`` message is used.
  // 3. ``resource_authority`` is compared sequentially with the authorities in
  //    each configuration source in ``config_sources``. The first ``ConfigSource``
  //    to match wins.
  // 4. As a fallback, if no configuration source matches, then
  //    ``default_config_source`` is used.
  // 5. If ``default_config_source`` is not specified, resolution fails.
  // [#not-implemented-hide:]
  repeated core.v3.ConfigSource config_sources = 22;

  // Default configuration source for xdstp:// URLs if all
  // other resolution fails.
  // [#not-implemented-hide:]
  core.v3.ConfigSource default_config_source = 23;

  // Optional overriding of default socket interface. The value must be the name of one of the
  // socket interface factories initialized through a bootstrap extension
  string default_socket_interface = 24;

  // Global map of CertificateProvider instances. These instances are referred to by name in the
  // :ref:`CommonTlsContext.CertificateProviderInstance.instance_name
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance.instance_name>`
  // field.
  // [#not-implemented-hide:]
  map<string, core.v3.TypedExtensionConfig> certificate_provider_instances = 25;

  // Specifies a set of headers that need to be registered as inline header. This configuration
  // allows users to customize the inline headers on-demand at Envoy startup without modifying
  // Envoy's source code.
  //
  // Note that the 'set-cookie' header cannot be registered as inline header.
  repeated CustomInlineHeader inline_headers = 32;

  // Optional path to a file with performance tracing data created by "Perfetto" SDK in binary
  // ProtoBuf format. The default value is "envoy.pftrace".
  string perf_tracing_file_path = 33;

  // Optional overriding of default regex engine.
  // If the value is not specified, Google RE2 will be used by default.
  // [#extension-category: envoy.regex_engines]
  core.v3.TypedExtensionConfig default_regex_engine = 34;

  // Optional XdsResourcesDelegate configuration, which allows plugging custom logic into both
  // fetch and load events during xDS processing.
  // If a value is not specified, no XdsResourcesDelegate will be used.
  // TODO(abeyad): Add public-facing documentation.
  // [#not-implemented-hide:]
  core.v3.TypedExtensionConfig xds_delegate_extension = 35;

  // Optional XdsConfigTracker configuration, which allows tracking xDS responses in external components,
  // e.g., external tracer or monitor. It provides the process point when receive, ingest, or fail to
  // process xDS resources and messages. If a value is not specified, no XdsConfigTracker will be used.
  //
  // .. note::
  //
  //    There are no in-repo extensions currently, and the :repo:`XdsConfigTracker <envoy/config/xds_config_tracker.h>`
  //    interface should be implemented before using.
  //    See :repo:`xds_config_tracker_integration_test <test/integration/xds_config_tracker_integration_test.cc>`
  //    for an example usage of the interface.
  core.v3.TypedExtensionConfig xds_config_tracker_extension = 36;

  // [#not-implemented-hide:]
  // This controls the type of listener manager configured for Envoy. Currently
  // Envoy only supports ListenerManager for this field and Envoy Mobile
  // supports ApiListenerManager.
  core.v3.TypedExtensionConfig listener_manager = 37;

  // Optional application log configuration.
  ApplicationLogConfig application_log_config = 38;

  // Optional gRPC async manager config.
  GrpcAsyncClientManagerConfig grpc_async_client_manager_config = 40;
}

// Administration interface :ref:`operations documentation
// <operations_admin_interface>`.
// [#next-free-field: 7]
message Admin {
  option (udpa.annotations.versioning).previous_message_type = "envoy.config.bootstrap.v2.Admin";

  // Configuration for :ref:`access logs <arch_overview_access_logs>`
  // emitted by the administration server.
  repeated accesslog.v3.AccessLog access_log = 5;

  // The path to write the access log for the administration server. If no
  // access log is desired specify /dev/null. This is only required if
  // :ref:`address <envoy_v3_api_field_config.bootstrap.v3.Admin.address>` is set.
  // Deprecated in favor of ``access_log`` which offers more options.
  string access_log_path = 1
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // The cpu profiler output path for the administration server. If no profile
  // path is specified, the default is /var/log/envoy/envoy.prof.
  string profile_path = 2;

  // The TCP address that the administration server will listen on.
  // If not specified, Envoy will not start an administration server.
  core.v3.Address address = 3;

  // Additional socket options that may not be present in Envoy source code or
  // precompiled binaries.
  repeated core.v3.SocketOption socket_options = 4;

  // Indicates whether :ref:`global_downstream_max_connections <config_overload_manager_limiting_connections>`
  // should apply to the admin interface or not.
  bool ignore_global_conn_limit = 6;
}

// Cluster manager :ref:`architecture overview <arch_overview_cluster_manager>`.
// [#next-free-field: 6]
message ClusterManager {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.bootstrap.v2.ClusterManager";

  message OutlierDetection {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.bootstrap.v2.ClusterManager.OutlierDetection";

    // Specifies the path to the outlier event log.
    string event_log_path = 1;

    // [#not-implemented-hide:]
    // The gRPC service for the outlier detection event service.
    // If empty, outlier detection events won't be sent to a remote endpoint.
    core.v3.EventServiceConfig event_service = 2;
  }

  // Name of the local cluster (i.e., the cluster that owns the Envoy running
  // this configuration). In order to enable :ref:`zone aware routing
  // <arch_overview_load_balancing_zone_aware_routing>` this option must be set.
  // If ``local_cluster_name`` is defined then :ref:`clusters
  // <envoy_v3_api_msg_config.cluster.v3.Cluster>` must be defined in the :ref:`Bootstrap
  // static cluster resources
  // <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.StaticResources.clusters>`. This is unrelated to
  // the :option:`--service-cluster` option which does not `affect zone aware
  // routing <https://github.com/envoyproxy/envoy/issues/774>`_.
  string local_cluster_name = 1;

  // Optional global configuration for outlier detection.
  OutlierDetection outlier_detection = 2;

  // Optional configuration used to bind newly established upstream connections.
  // This may be overridden on a per-cluster basis by upstream_bind_config in the cds_config.
  core.v3.BindConfig upstream_bind_config = 3;

  // A management server endpoint to stream load stats to via
  // ``StreamLoadStats``. This must have :ref:`api_type
  // <envoy_v3_api_field_config.core.v3.ApiConfigSource.api_type>` :ref:`GRPC
  // <envoy_v3_api_enum_value_config.core.v3.ApiConfigSource.ApiType.GRPC>`.
  core.v3.ApiConfigSource load_stats_config = 4;

  // Whether the ClusterManager will create clusters on the worker threads
  // inline during requests. This will save memory and CPU cycles in cases where
  // there are lots of inactive clusters and > 1 worker thread.
  bool enable_deferred_cluster_creation = 5;
}

// Allows you to specify different watchdog configs for different subsystems.
// This allows finer tuned policies for the watchdog. If a subsystem is omitted
// the default values for that system will be used.
message Watchdogs {
  // Watchdog for the main thread.
  Watchdog main_thread_watchdog = 1;

  // Watchdog for the worker threads.
  Watchdog worker_watchdog = 2;
}

// Envoy process watchdog configuration. When configured, this monitors for
// nonresponsive threads and kills the process after the configured thresholds.
// See the :ref:`watchdog documentation <operations_performance_watchdog>` for more information.
// [#next-free-field: 8]
message Watchdog {
  option (udpa.annotations.versioning).previous_message_type = "envoy.config.bootstrap.v2.Watchdog";

  message WatchdogAction {
    // The events are fired in this order: KILL, MULTIKILL, MEGAMISS, MISS.
    // Within an event type, actions execute in the order they are configured.
    // For KILL/MULTIKILL there is a default PANIC that will run after the
    // registered actions and kills the process if it wasn't already killed.
    // It might be useful to specify several debug actions, and possibly an
    // alternate FATAL action.
    enum WatchdogEvent {
      UNKNOWN = 0;
      KILL = 1;
      MULTIKILL = 2;
      MEGAMISS = 3;
      MISS = 4;
    }

    // Extension specific configuration for the action.
    core.v3.TypedExtensionConfig config = 1;

    WatchdogEvent event = 2 [(validate.rules).enum = {defined_only: true}];
  }

  // Register actions that will fire on given WatchDog events.
  // See ``WatchDogAction`` for priority of events.
  repeated WatchdogAction actions = 7;

  // The duration after which Envoy counts a nonresponsive thread in the
  // ``watchdog_miss`` statistic. If not specified the default is 200ms.
  google.protobuf.Duration miss_timeout = 1;

  // The duration after which Envoy counts a nonresponsive thread in the
  // ``watchdog_mega_miss`` statistic. If not specified the default is
  // 1000ms.
  google.protobuf.Duration megamiss_timeout = 2;

  // If a watched thread has been nonresponsive for this duration, assume a
  // programming error and kill the entire Envoy process. Set to 0 to disable
  // kill behavior. If not specified the default is 0 (disabled).
  google.protobuf.Duration kill_timeout = 3;

  // Defines the maximum jitter used to adjust the ``kill_timeout`` if ``kill_timeout`` is
  // enabled. Enabling this feature would help to reduce risk of synchronized
  // watchdog kill events across proxies due to external triggers. Set to 0 to
  // disable. If not specified the default is 0 (disabled).
  google.protobuf.Duration max_kill_timeout_jitter = 6 [(validate.rules).duration = {gte {}}];

  // If ``max(2, ceil(registered_threads * Fraction(*multikill_threshold*)))``
  // threads have been nonresponsive for at least this duration kill the entire
  // Envoy process. Set to 0 to disable this behavior. If not specified the
  // default is 0 (disabled).
  google.protobuf.Duration multikill_timeout = 4;

  // Sets the threshold for ``multikill_timeout`` in terms of the percentage of
  // nonresponsive threads required for the ``multikill_timeout``.
  // If not specified the default is 0.
  type.v3.Percent multikill_threshold = 5;
}

// Fatal actions to run while crashing. Actions can be safe (meaning they are
// async-signal safe) or unsafe. We run all safe actions before we run unsafe actions.
// If using an unsafe action that could get stuck or deadlock, it important to
// have an out of band system to terminate the process.
//
// The interface for the extension is ``Envoy::Server::Configuration::FatalAction``.
// ``FatalAction`` extensions live in the ``envoy.extensions.fatal_actions`` API
// namespace.
message FatalAction {
  // Extension specific configuration for the action. It's expected to conform
  // to the ``Envoy::Server::Configuration::FatalAction`` interface.
  core.v3.TypedExtensionConfig config = 1;
}

// Runtime :ref:`configuration overview <config_runtime>` (deprecated).
message Runtime {
  option (udpa.annotations.versioning).previous_message_type = "envoy.config.bootstrap.v2.Runtime";

  // The implementation assumes that the file system tree is accessed via a
  // symbolic link. An atomic link swap is used when a new tree should be
  // switched to. This parameter specifies the path to the symbolic link. Envoy
  // will watch the location for changes and reload the file system tree when
  // they happen. If this parameter is not set, there will be no disk based
  // runtime.
  string symlink_root = 1;

  // Specifies the subdirectory to load within the root directory. This is
  // useful if multiple systems share the same delivery mechanism. Envoy
  // configuration elements can be contained in a dedicated subdirectory.
  string subdirectory = 2;

  // Specifies an optional subdirectory to load within the root directory. If
  // specified and the directory exists, configuration values within this
  // directory will override those found in the primary subdirectory. This is
  // useful when Envoy is deployed across many different types of servers.
  // Sometimes it is useful to have a per service cluster directory for runtime
  // configuration. See below for exactly how the override directory is used.
  string override_subdirectory = 3;

  // Static base runtime. This will be :ref:`overridden
  // <config_runtime_layering>` by other runtime layers, e.g.
  // disk or admin. This follows the :ref:`runtime protobuf JSON representation
  // encoding <config_runtime_proto_json>`.
  google.protobuf.Struct base = 4;
}

// [#next-free-field: 6]
message RuntimeLayer {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.bootstrap.v2.RuntimeLayer";

  // :ref:`Disk runtime <config_runtime_local_disk>` layer.
  message DiskLayer {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.bootstrap.v2.RuntimeLayer.DiskLayer";

    // The implementation assumes that the file system tree is accessed via a
    // symbolic link. An atomic link swap is used when a new tree should be
    // switched to. This parameter specifies the path to the symbolic link.
    // Envoy will watch the location for changes and reload the file system tree
    // when they happen. See documentation on runtime :ref:`atomicity
    // <config_runtime_atomicity>` for further details on how reloads are
    // treated.
    string symlink_root = 1;

    // Specifies the subdirectory to load within the root directory. This is
    // useful if multiple systems share the same delivery mechanism. Envoy
    // configuration elements can be contained in a dedicated subdirectory.
    string subdirectory = 3;

    // :ref:`Append <config_runtime_local_disk_service_cluster_subdirs>` the
    // service cluster to the path under symlink root.
    bool append_service_cluster = 2;
  }

  // :ref:`Admin console runtime <config_runtime_admin>` layer.
  message AdminLayer {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.bootstrap.v2.RuntimeLayer.AdminLayer";
  }

  // :ref:`Runtime Discovery Service (RTDS) <config_runtime_rtds>` layer.
  message RtdsLayer {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayer";

    // Resource to subscribe to at ``rtds_config`` for the RTDS layer.
    string name = 1;

    // RTDS configuration source.
    core.v3.ConfigSource rtds_config = 2;
  }

  // Descriptive name for the runtime layer. This is only used for the runtime
  // :http:get:`/runtime` output.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  oneof layer_specifier {
    option (validate.required) = true;

    // :ref:`Static runtime <config_runtime_bootstrap>` layer.
    // This follows the :ref:`runtime protobuf JSON representation encoding
    // <config_runtime_proto_json>`. Unlike static xDS resources, this static
    // layer is overridable by later layers in the runtime virtual filesystem.
    google.protobuf.Struct static_layer = 2;

    DiskLayer disk_layer = 3;

    AdminLayer admin_layer = 4;

    RtdsLayer rtds_layer = 5;
  }
}

// Runtime :ref:`configuration overview <config_runtime>`.
message LayeredRuntime {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.bootstrap.v2.LayeredRuntime";

  // The :ref:`layers <config_runtime_layering>` of the runtime. This is ordered
  // such that later layers in the list overlay earlier entries.
  repeated RuntimeLayer layers = 1;
}

// Used to specify the header that needs to be registered as an inline header.
//
// If request or response contain multiple headers with the same name and the header
// name is registered as an inline header. Then multiple headers will be folded
// into one, and multiple header values will be concatenated by a suitable delimiter.
// The delimiter is generally a comma.
//
// For example, if 'foo' is registered as an inline header, and the headers contains
// the following two headers:
//
// .. code-block:: text
//
//   foo: bar
//   foo: eep
//
// Then they will eventually be folded into:
//
// .. code-block:: text
//
//   foo: bar, eep
//
// Inline headers provide O(1) search performance, but each inline header imposes
// an additional memory overhead on all instances of the corresponding type of
// HeaderMap or TrailerMap.
message CustomInlineHeader {
  enum InlineHeaderType {
    REQUEST_HEADER = 0;
    REQUEST_TRAILER = 1;
    RESPONSE_HEADER = 2;
    RESPONSE_TRAILER = 3;
  }

  // The name of the header that is expected to be set as the inline header.
  string inline_header_name = 1
      [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

  // The type of the header that is expected to be set as the inline header.
  InlineHeaderType inline_header_type = 2 [(validate.rules).enum = {defined_only: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/accesslog/v3:pkg",
        "//envoy/config/cluster/v3:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/config/listener/v3:pkg",
        "//envoy/config/metrics/v3:pkg",
        "//envoy/config/overload/v3:pkg",
        "//envoy/config/trace/v3:pkg",
        "//envoy/extensions/transport_sockets/tls/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.route.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/proxy_protocol.proto";
import "envoy/type/matcher/v3/metadata.proto";
import "envoy/type/matcher/v3/regex.proto";
import "envoy/type/matcher/v3/string.proto";
import "envoy/type/metadata/v3/metadata.proto";
import "envoy/type/tracing/v3/custom_tag.proto";
import "envoy/type/v3/percent.proto";
import "envoy/type/v3/range.proto";

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";
import "xds/type/matcher/v3/matcher.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.route.v3";
option java_outer_classname = "RouteComponentsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/route/v3;routev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP route components]
// * Routing :ref:`architecture overview <arch_overview_http_routing>`
// * HTTP :ref:`router filter <config_http_filters_router>`

// The top level element in the routing configuration is a virtual host. Each virtual host has
// a logical name as well as a set of domains that get routed to it based on the incoming request's
// host header. This allows a single listener to service multiple top level domain path trees. Once
// a virtual host is selected based on the domain, the routes are processed in order to see which
// upstream cluster to route to or whether to perform a redirect.
// [#next-free-field: 25]
message VirtualHost {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.VirtualHost";

  enum TlsRequirementType {
    // No TLS requirement for the virtual host.
    NONE = 0;

    // External requests must use TLS. If a request is external and it is not
    // using TLS, a 301 redirect will be sent telling the client to use HTTPS.
    EXTERNAL_ONLY = 1;

    // All requests must use TLS. If a request is not using TLS, a 301 redirect
    // will be sent telling the client to use HTTPS.
    ALL = 2;
  }

  reserved 9, 12;

  reserved "per_filter_config";

  // The logical name of the virtual host. This is used when emitting certain
  // statistics but is not relevant for routing.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // A list of domains (host/authority header) that will be matched to this
  // virtual host. Wildcard hosts are supported in the suffix or prefix form.
  //
  // Domain search order:
  //  1. Exact domain names: ``www.foo.com``.
  //  2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
  //  3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
  //  4. Special wildcard ``*`` matching any domain.
  //
  // .. note::
  //
  //   The wildcard will not match the empty string.
  //   e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
  //   The longest wildcards match first.
  //   Only a single virtual host in the entire route configuration can match on ``*``. A domain
  //   must be unique across all virtual hosts or the config will fail to load.
  //
  // Domains cannot contain control characters. This is validated by the well_known_regex HTTP_HEADER_VALUE.
  repeated string domains = 2 [(validate.rules).repeated = {
    min_items: 1
    items {string {well_known_regex: HTTP_HEADER_VALUE strict: false}}
  }];

  // The list of routes that will be matched, in order, for incoming requests.
  // The first route that matches will be used.
  // Only one of this and ``matcher`` can be specified.
  repeated Route routes = 3;

  // [#next-major-version: This should be included in a oneof with routes wrapped in a message.]
  // The match tree to use when resolving route actions for incoming requests. Only one of this and ``routes``
  // can be specified.
  xds.type.matcher.v3.Matcher matcher = 21
      [(xds.annotations.v3.field_status).work_in_progress = true];

  // Specifies the type of TLS enforcement the virtual host expects. If this option is not
  // specified, there is no TLS requirement for the virtual host.
  TlsRequirementType require_tls = 4 [(validate.rules).enum = {defined_only: true}];

  // A list of virtual clusters defined for this virtual host. Virtual clusters
  // are used for additional statistics gathering.
  repeated VirtualCluster virtual_clusters = 5;

  // Specifies a set of rate limit configurations that will be applied to the
  // virtual host.
  repeated RateLimit rate_limits = 6;

  // Specifies a list of HTTP headers that should be added to each request
  // handled by this virtual host. Headers specified at this level are applied
  // after headers from enclosed :ref:`envoy_v3_api_msg_config.route.v3.Route` and before headers from the
  // enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
  // details on header value syntax, see the documentation on :ref:`custom request headers
  // <config_http_conn_man_headers_custom_request_headers>`.
  repeated core.v3.HeaderValueOption request_headers_to_add = 7
      [(validate.rules).repeated = {max_items: 1000}];

  // Specifies a list of HTTP headers that should be removed from each request
  // handled by this virtual host.
  repeated string request_headers_to_remove = 13 [(validate.rules).repeated = {
    items {string {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}}
  }];

  // Specifies a list of HTTP headers that should be added to each response
  // handled by this virtual host. Headers specified at this level are applied
  // after headers from enclosed :ref:`envoy_v3_api_msg_config.route.v3.Route` and before headers from the
  // enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
  // details on header value syntax, see the documentation on :ref:`custom request headers
  // <config_http_conn_man_headers_custom_request_headers>`.
  repeated core.v3.HeaderValueOption response_headers_to_add = 10
      [(validate.rules).repeated = {max_items: 1000}];

  // Specifies a list of HTTP headers that should be removed from each response
  // handled by this virtual host.
  repeated string response_headers_to_remove = 11 [(validate.rules).repeated = {
    items {string {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}}
  }];

  // Indicates that the virtual host has a CORS policy. This field is ignored if related cors policy is
  // found in the
  // :ref:`VirtualHost.typed_per_filter_config<envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`.
  //
  // .. attention::
  //
  //   This option has been deprecated. Please use
  //   :ref:`VirtualHost.typed_per_filter_config<envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`
  //   to configure the CORS HTTP filter.
  CorsPolicy cors = 8 [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // This field can be used to provide virtual host level per filter config. The key should match the
  // :ref:`filter config name
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`.
  // See :ref:`Http filter route specific config <arch_overview_http_filters_per_filter_config>`
  // for details.
  // [#comment: An entry's value may be wrapped in a
  // :ref:`FilterConfig<envoy_v3_api_msg_config.route.v3.FilterConfig>`
  // message to specify additional options.]
  map<string, google.protobuf.Any> typed_per_filter_config = 15;

  // Decides whether the :ref:`x-envoy-attempt-count
  // <config_http_filters_router_x-envoy-attempt-count>` header should be included
  // in the upstream request. Setting this option will cause it to override any existing header
  // value, so in the case of two Envoys on the request path with this option enabled, the upstream
  // will see the attempt count as perceived by the second Envoy. Defaults to false.
  // This header is unaffected by the
  // :ref:`suppress_envoy_headers
  // <envoy_v3_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.
  //
  // [#next-major-version: rename to include_attempt_count_in_request.]
  bool include_request_attempt_count = 14;

  // Decides whether the :ref:`x-envoy-attempt-count
  // <config_http_filters_router_x-envoy-attempt-count>` header should be included
  // in the downstream response. Setting this option will cause the router to override any existing header
  // value, so in the case of two Envoys on the request path with this option enabled, the downstream
  // will see the attempt count as perceived by the Envoy closest upstream from itself. Defaults to false.
  // This header is unaffected by the
  // :ref:`suppress_envoy_headers
  // <envoy_v3_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.
  bool include_attempt_count_in_response = 19;

  // Indicates the retry policy for all routes in this virtual host. Note that setting a
  // route level entry will take precedence over this config and it'll be treated
  // independently (e.g.: values are not inherited).
  RetryPolicy retry_policy = 16;

  // [#not-implemented-hide:]
  // Specifies the configuration for retry policy extension. Note that setting a route level entry
  // will take precedence over this config and it'll be treated independently (e.g.: values are not
  // inherited). :ref:`Retry policy <envoy_v3_api_field_config.route.v3.VirtualHost.retry_policy>` should not be
  // set if this field is used.
  google.protobuf.Any retry_policy_typed_config = 20;

  // Indicates the hedge policy for all routes in this virtual host. Note that setting a
  // route level entry will take precedence over this config and it'll be treated
  // independently (e.g.: values are not inherited).
  HedgePolicy hedge_policy = 17;

  // Decides whether to include the :ref:`x-envoy-is-timeout-retry <config_http_filters_router_x-envoy-is-timeout-retry>`
  // request header in retries initiated by per try timeouts.
  bool include_is_timeout_retry_header = 23;

  // The maximum bytes which will be buffered for retries and shadowing.
  // If set and a route-specific limit is not set, the bytes actually buffered will be the minimum
  // value of this and the listener per_connection_buffer_limit_bytes.
  google.protobuf.UInt32Value per_request_buffer_limit_bytes = 18;

  // Specify a set of default request mirroring policies for every route under this virtual host.
  // It takes precedence over the route config mirror policy entirely.
  // That is, policies are not merged, the most specific non-empty one becomes the mirror policies.
  repeated RouteAction.RequestMirrorPolicy request_mirror_policies = 22;

  // The metadata field can be used to provide additional information
  // about the virtual host. It can be used for configuration, stats, and logging.
  // The metadata should go under the filter namespace that will need it.
  // For instance, if the metadata is intended for the Router filter,
  // the filter name should be specified as ``envoy.filters.http.router``.
  core.v3.Metadata metadata = 24;
}

// A filter-defined action type.
message FilterAction {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.FilterAction";

  google.protobuf.Any action = 1;
}

// This can be used in route matcher :ref:`VirtualHost.matcher <envoy_v3_api_field_config.route.v3.VirtualHost.matcher>`.
// When the matcher matches, routes will be matched and run.
message RouteList {
  // The list of routes that will be matched and run, in order. The first route that matches will be used.
  repeated Route routes = 1;
}

// A route is both a specification of how to match a request as well as an indication of what to do
// next (e.g., redirect, forward, rewrite, etc.).
//
// .. attention::
//
//   Envoy supports routing on HTTP method via :ref:`header matching
//   <envoy_v3_api_msg_config.route.v3.HeaderMatcher>`.
// [#next-free-field: 20]
message Route {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.Route";

  reserved 6, 8;

  reserved "per_filter_config";

  // Name for the route.
  string name = 14;

  // Route matching parameters.
  RouteMatch match = 1 [(validate.rules).message = {required: true}];

  oneof action {
    option (validate.required) = true;

    // Route request to some upstream cluster.
    RouteAction route = 2;

    // Return a redirect.
    RedirectAction redirect = 3;

    // Return an arbitrary HTTP response directly, without proxying.
    DirectResponseAction direct_response = 7;

    // [#not-implemented-hide:]
    // A filter-defined action (e.g., it could dynamically generate the RouteAction).
    // [#comment: TODO(samflattery): Remove cleanup in route_fuzz_test.cc when
    // implemented]
    FilterAction filter_action = 17;

    // [#not-implemented-hide:]
    // An action used when the route will generate a response directly,
    // without forwarding to an upstream host. This will be used in non-proxy
    // xDS clients like the gRPC server. It could also be used in the future
    // in Envoy for a filter that directly generates responses for requests.
    NonForwardingAction non_forwarding_action = 18;
  }

  // The Metadata field can be used to provide additional information
  // about the route. It can be used for configuration, stats, and logging.
  // The metadata should go under the filter namespace that will need it.
  // For instance, if the metadata is intended for the Router filter,
  // the filter name should be specified as ``envoy.filters.http.router``.
  core.v3.Metadata metadata = 4;

  // Decorator for the matched route.
  Decorator decorator = 5;

  // This field can be used to provide route specific per filter config. The key should match the
  // :ref:`filter config name
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`.
  // See :ref:`Http filter route specific config <arch_overview_http_filters_per_filter_config>`
  // for details.
  // [#comment: An entry's value may be wrapped in a
  // :ref:`FilterConfig<envoy_v3_api_msg_config.route.v3.FilterConfig>`
  // message to specify additional options.]
  map<string, google.protobuf.Any> typed_per_filter_config = 13;

  // Specifies a set of headers that will be added to requests matching this
  // route. Headers specified at this level are applied before headers from the
  // enclosing :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` and
  // :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
  // header value syntax, see the documentation on :ref:`custom request headers
  // <config_http_conn_man_headers_custom_request_headers>`.
  repeated core.v3.HeaderValueOption request_headers_to_add = 9
      [(validate.rules).repeated = {max_items: 1000}];

  // Specifies a list of HTTP headers that should be removed from each request
  // matching this route.
  repeated string request_headers_to_remove = 12 [(validate.rules).repeated = {
    items {string {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}}
  }];

  // Specifies a set of headers that will be added to responses to requests
  // matching this route. Headers specified at this level are applied before
  // headers from the enclosing :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` and
  // :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
  // details on header value syntax, see the documentation on
  // :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
  repeated core.v3.HeaderValueOption response_headers_to_add = 10
      [(validate.rules).repeated = {max_items: 1000}];

  // Specifies a list of HTTP headers that should be removed from each response
  // to requests matching this route.
  repeated string response_headers_to_remove = 11 [(validate.rules).repeated = {
    items {string {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}}
  }];

  // Presence of the object defines whether the connection manager's tracing configuration
  // is overridden by this route specific instance.
  Tracing tracing = 15;

  // The maximum bytes which will be buffered for retries and shadowing.
  // If set, the bytes actually buffered will be the minimum value of this and the
  // listener per_connection_buffer_limit_bytes.
  google.protobuf.UInt32Value per_request_buffer_limit_bytes = 16;

  // The human readable prefix to use when emitting statistics for this endpoint.
  // The statistics are rooted at vhost.<virtual host name>.route.<stat_prefix>.
  // This should be set for highly critical
  // endpoints that one wishes to get per-route statistics on.
  // If not set, endpoint statistics are not generated.
  //
  // The emitted statistics are the same as those documented for :ref:`virtual clusters <config_http_filters_router_vcluster_stats>`.
  //
  // .. warning::
  //
  //    We do not recommend setting up a stat prefix for
  //    every application endpoint. This is both not easily maintainable and
  //    statistics use a non-trivial amount of memory(approximately 1KiB per route).
  string stat_prefix = 19;
}

// Compared to the :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` field that specifies a
// single upstream cluster as the target of a request, the :ref:`weighted_clusters
// <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>` option allows for specification of
// multiple upstream clusters along with weights that indicate the percentage of
// traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
// weights.
message WeightedCluster {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.WeightedCluster";

  // [#next-free-field: 13]
  message ClusterWeight {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.route.WeightedCluster.ClusterWeight";

    reserved 7, 8;

    reserved "per_filter_config";

    // Only one of ``name`` and ``cluster_header`` may be specified.
    // [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1}]
    // Name of the upstream cluster. The cluster must exist in the
    // :ref:`cluster manager configuration <config_cluster_manager>`.
    string name = 1 [(udpa.annotations.field_migrate).oneof_promotion = "cluster_specifier"];

    // Only one of ``name`` and ``cluster_header`` may be specified.
    // [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1 }]
    // Envoy will determine the cluster to route to by reading the value of the
    // HTTP header named by cluster_header from the request headers. If the
    // header is not found or the referenced cluster does not exist, Envoy will
    // return a 404 response.
    //
    // .. attention::
    //
    //   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1
    //   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
    //
    // .. note::
    //
    //   If the header appears multiple times only the first value is used.
    string cluster_header = 12 [
      (validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false},
      (udpa.annotations.field_migrate).oneof_promotion = "cluster_specifier"
    ];

    // The weight of the cluster. This value is relative to the other clusters'
    // weights. When a request matches the route, the choice of an upstream cluster
    // is determined by its weight. The sum of weights across all
    // entries in the clusters array must be greater than 0, and must not exceed
    // uint32_t maximal value (4294967295).
    google.protobuf.UInt32Value weight = 2;

    // Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
    // the upstream cluster with metadata matching what is set in this field will be considered for
    // load balancing. Note that this will be merged with what's provided in
    // :ref:`RouteAction.metadata_match <envoy_v3_api_field_config.route.v3.RouteAction.metadata_match>`, with
    // values here taking precedence. The filter name should be specified as ``envoy.lb``.
    core.v3.Metadata metadata_match = 3;

    // Specifies a list of headers to be added to requests when this cluster is selected
    // through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
    // Headers specified at this level are applied before headers from the enclosing
    // :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`, and
    // :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
    // header value syntax, see the documentation on :ref:`custom request headers
    // <config_http_conn_man_headers_custom_request_headers>`.
    repeated core.v3.HeaderValueOption request_headers_to_add = 4
        [(validate.rules).repeated = {max_items: 1000}];

    // Specifies a list of HTTP headers that should be removed from each request when
    // this cluster is selected through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
    repeated string request_headers_to_remove = 9 [(validate.rules).repeated = {
      items {string {well_known_regex: HTTP_HEADER_NAME strict: false}}
    }];

    // Specifies a list of headers to be added to responses when this cluster is selected
    // through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
    // Headers specified at this level are applied before headers from the enclosing
    // :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`, and
    // :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
    // header value syntax, see the documentation on :ref:`custom request headers
    // <config_http_conn_man_headers_custom_request_headers>`.
    repeated core.v3.HeaderValueOption response_headers_to_add = 5
        [(validate.rules).repeated = {max_items: 1000}];

    // Specifies a list of headers to be removed from responses when this cluster is selected
    // through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
    repeated string response_headers_to_remove = 6 [(validate.rules).repeated = {
      items {string {well_known_regex: HTTP_HEADER_NAME strict: false}}
    }];

    // This field can be used to provide weighted cluster specific per filter config. The key should match the
    // :ref:`filter config name
    // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`.
    // See :ref:`Http filter route specific config <arch_overview_http_filters_per_filter_config>`
    // for details.
    // [#comment: An entry's value may be wrapped in a
    // :ref:`FilterConfig<envoy_v3_api_msg_config.route.v3.FilterConfig>`
    // message to specify additional options.]
    map<string, google.protobuf.Any> typed_per_filter_config = 10;

    oneof host_rewrite_specifier {
      // Indicates that during forwarding, the host header will be swapped with
      // this value.
      string host_rewrite_literal = 11
          [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];
    }
  }

  // Specifies one or more upstream clusters associated with the route.
  repeated ClusterWeight clusters = 1 [(validate.rules).repeated = {min_items: 1}];

  // Specifies the total weight across all clusters. The sum of all cluster weights must equal this
  // value, if this is greater than 0.
  // This field is now deprecated, and the client will use the sum of all
  // cluster weights. It is up to the management server to supply the correct weights.
  google.protobuf.UInt32Value total_weight = 3
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Specifies the runtime key prefix that should be used to construct the
  // runtime keys associated with each cluster. When the ``runtime_key_prefix`` is
  // specified, the router will look for weights associated with each upstream
  // cluster under the key ``runtime_key_prefix`` + ``.`` + ``cluster[i].name`` where
  // ``cluster[i]`` denotes an entry in the clusters array field. If the runtime
  // key for the cluster does not exist, the value specified in the
  // configuration file will be used as the default weight. See the :ref:`runtime documentation
  // <operations_runtime>` for how key names map to the underlying implementation.
  string runtime_key_prefix = 2;

  oneof random_value_specifier {
    // Specifies the header name that is used to look up the random value passed in the request header.
    // This is used to ensure consistent cluster picking across multiple proxy levels for weighted traffic.
    // If header is not present or invalid, Envoy will fall back to use the internally generated random value.
    // This header is expected to be single-valued header as we only want to have one selected value throughout
    // the process for the consistency. And the value is a unsigned number between 0 and UINT64_MAX.
    string header_name = 4
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false}];
  }
}

// Configuration for a cluster specifier plugin.
message ClusterSpecifierPlugin {
  // The name of the plugin and its opaque configuration.
  core.v3.TypedExtensionConfig extension = 1 [(validate.rules).message = {required: true}];

  // If is_optional is not set or is set to false and the plugin defined by this message is not a
  // supported type, the containing resource is NACKed. If is_optional is set to true, the resource
  // would not be NACKed for this reason. In this case, routes referencing this plugin's name would
  // not be treated as an illegal configuration, but would result in a failure if the route is
  // selected.
  bool is_optional = 2;
}

// [#next-free-field: 16]
message RouteMatch {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.RouteMatch";

  message GrpcRouteMatchOptions {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions";
  }

  message TlsContextMatchOptions {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.route.RouteMatch.TlsContextMatchOptions";

    // If specified, the route will match against whether or not a certificate is presented.
    // If not specified, certificate presentation status (true or false) will not be considered when route matching.
    google.protobuf.BoolValue presented = 1;

    // If specified, the route will match against whether or not a certificate is validated.
    // If not specified, certificate validation status (true or false) will not be considered when route matching.
    //
    // .. warning::
    //
    //    Client certificate validation is not currently performed upon TLS session resumption. For
    //    a resumed TLS session the route will match only when ``validated`` is false, regardless of
    //    whether the client TLS certificate is valid.
    //
    //    The only known workaround for this issue is to disable TLS session resumption entirely, by
    //    setting both :ref:`disable_stateless_session_resumption <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.disable_stateless_session_resumption>`
    //    and :ref:`disable_stateful_session_resumption <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.disable_stateful_session_resumption>` on the DownstreamTlsContext.
    google.protobuf.BoolValue validated = 2;
  }

  // An extensible message for matching CONNECT or CONNECT-UDP requests.
  message ConnectMatcher {
  }

  reserved 5, 3;

  reserved "regex";

  oneof path_specifier {
    option (validate.required) = true;

    // If specified, the route is a prefix rule meaning that the prefix must
    // match the beginning of the ``:path`` header.
    string prefix = 1;

    // If specified, the route is an exact path rule meaning that the path must
    // exactly match the ``:path`` header once the query string is removed.
    string path = 2;

    // If specified, the route is a regular expression rule meaning that the
    // regex must match the ``:path`` header once the query string is removed. The entire path
    // (without the query string) must match the regex. The rule will not match if only a
    // subsequence of the ``:path`` header matches the regex.
    //
    // [#next-major-version: In the v3 API we should redo how path specification works such
    // that we utilize StringMatcher, and additionally have consistent options around whether we
    // strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
    // to deprecate the existing options. We should even consider whether we want to do away with
    // path_specifier entirely and just rely on a set of header matchers which can already match
    // on :path, etc. The issue with that is it is unclear how to generically deal with query string
    // stripping. This needs more thought.]
    type.matcher.v3.RegexMatcher safe_regex = 10 [(validate.rules).message = {required: true}];

    // If this is used as the matcher, the matcher will only match CONNECT or CONNECT-UDP requests.
    // Note that this will not match other Extended CONNECT requests (WebSocket and the like) as
    // they are normalized in Envoy as HTTP/1.1 style upgrades.
    // This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2 and HTTP/3,
    // where Extended CONNECT requests may have a path, the path matchers will work if
    // there is a path present.
    // Note that CONNECT support is currently considered alpha in Envoy.
    // [#comment: TODO(htuch): Replace the above comment with an alpha tag.]
    ConnectMatcher connect_matcher = 12;

    // If specified, the route is a path-separated prefix rule meaning that the
    // ``:path`` header (without the query string) must either exactly match the
    // ``path_separated_prefix`` or have it as a prefix, followed by ``/``
    //
    // For example, ``/api/dev`` would match
    // ``/api/dev``, ``/api/dev/``, ``/api/dev/v1``, and ``/api/dev?param=true``
    // but would not match ``/api/developer``
    //
    // Expect the value to not contain ``?`` or ``#`` and not to end in ``/``
    string path_separated_prefix = 14 [(validate.rules).string = {pattern: "^[^?#]+[^?#/]$"}];

    // [#extension-category: envoy.path.match]
    core.v3.TypedExtensionConfig path_match_policy = 15;
  }

  // Indicates that prefix/path matching should be case sensitive. The default
  // is true. Ignored for safe_regex matching.
  google.protobuf.BoolValue case_sensitive = 4;

  // Indicates that the route should additionally match on a runtime key. Every time the route
  // is considered for a match, it must also fall under the percentage of matches indicated by
  // this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
  // number is <= the value of the numerator N, or if the key is not present, the default
  // value, the router continues to evaluate the remaining match criteria. A runtime_fraction
  // route configuration can be used to roll out route changes in a gradual manner without full
  // code/config deploys. Refer to the :ref:`traffic shifting
  // <config_http_conn_man_route_table_traffic_splitting_shift>` docs for additional documentation.
  //
  // .. note::
  //
  //    Parsing this field is implemented such that the runtime key's data may be represented
  //    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
  //    integer with the assumption that the value is an integral percentage out of 100. For
  //    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
  //    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
  core.v3.RuntimeFractionalPercent runtime_fraction = 9;

  // Specifies a set of headers that the route should match on. The router will
  // check the requests headers against all the specified headers in the route
  // config. A match will happen if all the headers in the route are present in
  // the request with the same values (or based on presence if the value field
  // is not in the config).
  repeated HeaderMatcher headers = 6;

  // Specifies a set of URL query parameters on which the route should
  // match. The router will check the query string from the ``path`` header
  // against all the specified query parameters. If the number of specified
  // query parameters is nonzero, they all must match the ``path`` header's
  // query string for a match to occur. In the event query parameters are
  // repeated, only the first value for each key will be considered.
  //
  // .. note::
  //
  //    If query parameters are used to pass request message fields when
  //    `grpc_json_transcoder <https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter>`_
  //    is used, the transcoded message fields maybe different. The query parameters are
  //    url encoded, but the message fields are not. For example, if a query
  //    parameter is "foo%20bar", the message field will be "foo bar".
  repeated QueryParameterMatcher query_parameters = 7;

  // If specified, only gRPC requests will be matched. The router will check
  // that the content-type header has a application/grpc or one of the various
  // application/grpc+ values.
  GrpcRouteMatchOptions grpc = 8;

  // If specified, the client tls context will be matched against the defined
  // match options.
  //
  // [#next-major-version: unify with RBAC]
  TlsContextMatchOptions tls_context = 11;

  // Specifies a set of dynamic metadata matchers on which the route should match.
  // The router will check the dynamic metadata against all the specified dynamic metadata matchers.
  // If the number of specified dynamic metadata matchers is nonzero, they all must match the
  // dynamic metadata for a match to occur.
  repeated type.matcher.v3.MetadataMatcher dynamic_metadata = 13;
}

// Cors policy configuration.
//
// .. attention::
//
//   This message has been deprecated. Please use
//   :ref:`CorsPolicy in filter extension <envoy_v3_api_msg_extensions.filters.http.cors.v3.CorsPolicy>`
//   as as alternative.
//
// [#next-free-field: 13]
message CorsPolicy {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.CorsPolicy";

  reserved 1, 8, 7;

  reserved "allow_origin", "allow_origin_regex", "enabled";

  // Specifies string patterns that match allowed origins. An origin is allowed if any of the
  // string matchers match.
  repeated type.matcher.v3.StringMatcher allow_origin_string_match = 11;

  // Specifies the content for the ``access-control-allow-methods`` header.
  string allow_methods = 2;

  // Specifies the content for the ``access-control-allow-headers`` header.
  string allow_headers = 3;

  // Specifies the content for the ``access-control-expose-headers`` header.
  string expose_headers = 4;

  // Specifies the content for the ``access-control-max-age`` header.
  string max_age = 5;

  // Specifies whether the resource allows credentials.
  google.protobuf.BoolValue allow_credentials = 6;

  oneof enabled_specifier {
    // Specifies the % of requests for which the CORS filter is enabled.
    //
    // If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS
    // filter will be enabled for 100% of the requests.
    //
    // If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is
    // specified, Envoy will lookup the runtime key to get the percentage of requests to filter.
    core.v3.RuntimeFractionalPercent filter_enabled = 9;
  }

  // Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not
  // enforced.
  //
  // This field is intended to be used when ``filter_enabled`` and ``enabled`` are off. One of those
  // fields have to explicitly disable the filter in order for this setting to take effect.
  //
  // If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is specified,
  // Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
  // and track the request's ``Origin`` to determine if it's valid but will not enforce any policies.
  core.v3.RuntimeFractionalPercent shadow_enabled = 10;

  // Specify whether allow requests whose target server's IP address is more private than that from
  // which the request initiator was fetched.
  //
  // More details refer to https://developer.chrome.com/blog/private-network-access-preflight.
  google.protobuf.BoolValue allow_private_network_access = 12;
}

// [#next-free-field: 42]
message RouteAction {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.RouteAction";

  enum ClusterNotFoundResponseCode {
    // HTTP status code - 503 Service Unavailable.
    SERVICE_UNAVAILABLE = 0;

    // HTTP status code - 404 Not Found.
    NOT_FOUND = 1;

    // HTTP status code - 500 Internal Server Error.
    INTERNAL_SERVER_ERROR = 2;
  }

  // Configures :ref:`internal redirect <arch_overview_internal_redirects>` behavior.
  // [#next-major-version: remove this definition - it's defined in the InternalRedirectPolicy message.]
  enum InternalRedirectAction {
    option deprecated = true;

    PASS_THROUGH_INTERNAL_REDIRECT = 0;
    HANDLE_INTERNAL_REDIRECT = 1;
  }

  // The router is capable of shadowing traffic from one cluster to another. The current
  // implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
  // respond before returning the response from the primary cluster. All normal statistics are
  // collected for the shadow cluster making this feature useful for testing.
  //
  // During shadowing, the host/authority header is altered such that ``-shadow`` is appended. This is
  // useful for logging. For example, ``cluster1`` becomes ``cluster1-shadow``.
  //
  // .. note::
  //
  //   Shadowing will not be triggered if the primary cluster does not exist.
  //
  // .. note::
  //
  //   Shadowing doesn't support Http CONNECT and upgrades.
  // [#next-free-field: 6]
  message RequestMirrorPolicy {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.route.RouteAction.RequestMirrorPolicy";

    reserved 2;

    reserved "runtime_key";

    // Only one of ``cluster`` and ``cluster_header`` can be specified.
    // [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1}]
    // Specifies the cluster that requests will be mirrored to. The cluster must
    // exist in the cluster manager configuration.
    string cluster = 1 [(udpa.annotations.field_migrate).oneof_promotion = "cluster_specifier"];

    // Only one of ``cluster`` and ``cluster_header`` can be specified.
    // Envoy will determine the cluster to route to by reading the value of the
    // HTTP header named by cluster_header from the request headers. Only the first value in header is used,
    // and no shadow request will happen if the value is not found in headers. Envoy will not wait for
    // the shadow cluster to respond before returning the response from the primary cluster.
    //
    // .. attention::
    //
    //   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1
    //   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
    //
    // .. note::
    //
    //   If the header appears multiple times only the first value is used.
    string cluster_header = 5 [
      (validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false},
      (udpa.annotations.field_migrate).oneof_promotion = "cluster_specifier"
    ];

    // If not specified, all requests to the target cluster will be mirrored.
    //
    // If specified, this field takes precedence over the ``runtime_key`` field and requests must also
    // fall under the percentage of matches indicated by this field.
    //
    // For some fraction N/D, a random number in the range [0,D) is selected. If the
    // number is <= the value of the numerator N, or if the key is not present, the default
    // value, the request will be mirrored.
    core.v3.RuntimeFractionalPercent runtime_fraction = 3;

    // Determines if the trace span should be sampled. Defaults to true.
    google.protobuf.BoolValue trace_sampled = 4;
  }

  // Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
  // <arch_overview_load_balancing_types>`.
  // [#next-free-field: 7]
  message HashPolicy {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.route.RouteAction.HashPolicy";

    message Header {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.route.RouteAction.HashPolicy.Header";

      // The name of the request header that will be used to obtain the hash
      // key. If the request header is not present, no hash will be produced.
      string header_name = 1
          [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

      // If specified, the request header value will be rewritten and used
      // to produce the hash key.
      type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 2;
    }

    // CookieAttribute defines an API for adding additional attributes for a HTTP cookie.
    message CookieAttribute {
      // The name of the cookie attribute.
      string name = 1
          [(validate.rules).string =
               {min_len: 1 max_bytes: 16384 well_known_regex: HTTP_HEADER_NAME strict: false}];

      // The optional value of the cookie attribute.
      string value = 2 [(validate.rules).string =
                            {max_bytes: 16384 well_known_regex: HTTP_HEADER_VALUE strict: false}];
    }

    // Envoy supports two types of cookie affinity:
    //
    // 1. Passive. Envoy takes a cookie that's present in the cookies header and
    //    hashes on its value.
    //
    // 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
    //    on the first request from the client in its response to the client,
    //    based on the endpoint the request gets sent to. The client then
    //    presents this on the next and all subsequent requests. The hash of
    //    this is sufficient to ensure these requests get sent to the same
    //    endpoint. The cookie is generated by hashing the source and
    //    destination ports and addresses so that multiple independent HTTP2
    //    streams on the same connection will independently receive the same
    //    cookie, even if they arrive at the Envoy simultaneously.
    message Cookie {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.route.RouteAction.HashPolicy.Cookie";

      // The name of the cookie that will be used to obtain the hash key. If the
      // cookie is not present and ttl below is not set, no hash will be
      // produced.
      string name = 1 [(validate.rules).string = {min_len: 1}];

      // If specified, a cookie with the TTL will be generated if the cookie is
      // not present. If the TTL is present and zero, the generated cookie will
      // be a session cookie.
      google.protobuf.Duration ttl = 2;

      // The name of the path for the cookie. If no path is specified here, no path
      // will be set for the cookie.
      string path = 3;

      // Additional attributes for the cookie. They will be used when generating a new cookie.
      repeated CookieAttribute attributes = 4;
    }

    message ConnectionProperties {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties";

      // Hash on source IP address.
      bool source_ip = 1;
    }

    message QueryParameter {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter";

      // The name of the URL query parameter that will be used to obtain the hash
      // key. If the parameter is not present, no hash will be produced. Query
      // parameter names are case-sensitive. If query parameters are repeated, only
      // the first value will be considered.
      string name = 1 [(validate.rules).string = {min_len: 1}];
    }

    message FilterState {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.route.RouteAction.HashPolicy.FilterState";

      // The name of the Object in the per-request filterState, which is an
      // Envoy::Hashable object. If there is no data associated with the key,
      // or the stored object is not Envoy::Hashable, no hash will be produced.
      string key = 1 [(validate.rules).string = {min_len: 1}];
    }

    oneof policy_specifier {
      option (validate.required) = true;

      // Header hash policy.
      Header header = 1;

      // Cookie hash policy.
      Cookie cookie = 2;

      // Connection properties hash policy.
      ConnectionProperties connection_properties = 3;

      // Query parameter hash policy.
      QueryParameter query_parameter = 5;

      // Filter state hash policy.
      FilterState filter_state = 6;
    }

    // The flag that short-circuits the hash computing. This field provides a
    // 'fallback' style of configuration: "if a terminal policy doesn't work,
    // fallback to rest of the policy list", it saves time when the terminal
    // policy works.
    //
    // If true, and there is already a hash computed, ignore rest of the
    // list of hash polices.
    // For example, if the following hash methods are configured:
    //
    //  ========= ========
    //  specifier terminal
    //  ========= ========
    //  Header A  true
    //  Header B  false
    //  Header C  false
    //  ========= ========
    //
    // The generateHash process ends if policy "header A" generates a hash, as
    // it's a terminal policy.
    bool terminal = 4;
  }

  // Allows enabling and disabling upgrades on a per-route basis.
  // This overrides any enabled/disabled upgrade filter chain specified in the
  // HttpConnectionManager
  // :ref:`upgrade_configs
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.upgrade_configs>`
  // but does not affect any custom filter chain specified there.
  message UpgradeConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.route.RouteAction.UpgradeConfig";

    // Configuration for sending data upstream as a raw data payload. This is used for
    // CONNECT or POST requests, when forwarding request payload as raw TCP.
    message ConnectConfig {
      // If present, the proxy protocol header will be prepended to the CONNECT payload sent upstream.
      core.v3.ProxyProtocolConfig proxy_protocol_config = 1;

      // If set, the route will also allow forwarding POST payload as raw TCP.
      bool allow_post = 2;
    }

    // The case-insensitive name of this upgrade, e.g. "websocket".
    // For each upgrade type present in upgrade_configs, requests with
    // Upgrade: [upgrade_type] will be proxied upstream.
    string upgrade_type = 1
        [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_VALUE strict: false}];

    // Determines if upgrades are available on this route. Defaults to true.
    google.protobuf.BoolValue enabled = 2;

    // Configuration for sending data upstream as a raw data payload. This is used for
    // CONNECT requests, when forwarding CONNECT payload as raw TCP.
    // Note that CONNECT support is currently considered alpha in Envoy.
    // [#comment: TODO(htuch): Replace the above comment with an alpha tag.]
    ConnectConfig connect_config = 3;
  }

  message MaxStreamDuration {
    // Specifies the maximum duration allowed for streams on the route. If not specified, the value
    // from the :ref:`max_stream_duration
    // <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration>` field in
    // :ref:`HttpConnectionManager.common_http_protocol_options
    // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.common_http_protocol_options>`
    // is used. If this field is set explicitly to zero, any
    // HttpConnectionManager max_stream_duration timeout will be disabled for
    // this route.
    google.protobuf.Duration max_stream_duration = 1;

    // If present, and the request contains a `grpc-timeout header
    // <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, use that value as the
    // ``max_stream_duration``, but limit the applied timeout to the maximum value specified here.
    // If set to 0, the ``grpc-timeout`` header is used without modification.
    google.protobuf.Duration grpc_timeout_header_max = 2;

    // If present, Envoy will adjust the timeout provided by the ``grpc-timeout`` header by
    // subtracting the provided duration from the header. This is useful for allowing Envoy to set
    // its global timeout to be less than that of the deadline imposed by the calling client, which
    // makes it more likely that Envoy will handle the timeout instead of having the call canceled
    // by the client. If, after applying the offset, the resulting timeout is zero or negative,
    // the stream will timeout immediately.
    google.protobuf.Duration grpc_timeout_header_offset = 3;
  }

  reserved 12, 18, 19, 16, 22, 21, 10;

  reserved "request_mirror_policy";

  oneof cluster_specifier {
    option (validate.required) = true;

    // Indicates the upstream cluster to which the request should be routed
    // to.
    string cluster = 1 [(validate.rules).string = {min_len: 1}];

    // Envoy will determine the cluster to route to by reading the value of the
    // HTTP header named by cluster_header from the request headers. If the
    // header is not found or the referenced cluster does not exist, Envoy will
    // return a 404 response.
    //
    // .. attention::
    //
    //   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1
    //   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
    //
    // .. note::
    //
    //   If the header appears multiple times only the first value is used.
    string cluster_header = 2
        [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

    // Multiple upstream clusters can be specified for a given route. The
    // request is routed to one of the upstream clusters based on weights
    // assigned to each cluster. See
    // :ref:`traffic splitting <config_http_conn_man_route_table_traffic_splitting_split>`
    // for additional documentation.
    WeightedCluster weighted_clusters = 3;

    // Name of the cluster specifier plugin to use to determine the cluster for requests on this route.
    // The cluster specifier plugin name must be defined in the associated
    // :ref:`cluster specifier plugins <envoy_v3_api_field_config.route.v3.RouteConfiguration.cluster_specifier_plugins>`
    // in the :ref:`name <envoy_v3_api_field_config.core.v3.TypedExtensionConfig.name>` field.
    string cluster_specifier_plugin = 37;

    // Custom cluster specifier plugin configuration to use to determine the cluster for requests
    // on this route.
    ClusterSpecifierPlugin inline_cluster_specifier_plugin = 39;
  }

  // The HTTP status code to use when configured cluster is not found.
  // The default response code is 503 Service Unavailable.
  ClusterNotFoundResponseCode cluster_not_found_response_code = 20
      [(validate.rules).enum = {defined_only: true}];

  // Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
  // in the upstream cluster with metadata matching what's set in this field will be considered
  // for load balancing. If using :ref:`weighted_clusters
  // <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`, metadata will be merged, with values
  // provided there taking precedence. The filter name should be specified as ``envoy.lb``.
  core.v3.Metadata metadata_match = 4;

  // Indicates that during forwarding, the matched prefix (or path) should be
  // swapped with this value. This option allows application URLs to be rooted
  // at a different path from those exposed at the reverse proxy layer. The router filter will
  // place the original path before rewrite into the :ref:`x-envoy-original-path
  // <config_http_filters_router_x-envoy-original-path>` header.
  //
  // Only one of :ref:`regex_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>`
  // :ref:`path_rewrite_policy <envoy_v3_api_field_config.route.v3.RouteAction.path_rewrite_policy>`,
  // or :ref:`prefix_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>` may be specified.
  //
  // .. attention::
  //
  //   Pay careful attention to the use of trailing slashes in the
  //   :ref:`route's match <envoy_v3_api_field_config.route.v3.Route.match>` prefix value.
  //   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
  //   rewriting ``/prefix`` to ``/`` and ``/prefix/etc`` to ``/etc`` cannot be done in a single
  //   :ref:`Route <envoy_v3_api_msg_config.route.v3.Route>`, as shown by the below config entries:
  //
  //   .. code-block:: yaml
  //
  //     - match:
  //         prefix: "/prefix/"
  //       route:
  //         prefix_rewrite: "/"
  //     - match:
  //         prefix: "/prefix"
  //       route:
  //         prefix_rewrite: "/"
  //
  //   Having above entries in the config, requests to ``/prefix`` will be stripped to ``/``, while
  //   requests to ``/prefix/etc`` will be stripped to ``/etc``.
  string prefix_rewrite = 5
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];

  // Indicates that during forwarding, portions of the path that match the
  // pattern should be rewritten, even allowing the substitution of capture
  // groups from the pattern into the new path as specified by the rewrite
  // substitution string. This is useful to allow application paths to be
  // rewritten in a way that is aware of segments with variable content like
  // identifiers. The router filter will place the original path as it was
  // before the rewrite into the :ref:`x-envoy-original-path
  // <config_http_filters_router_x-envoy-original-path>` header.
  //
  // Only one of :ref:`regex_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>`,
  // :ref:`prefix_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`, or
  // :ref:`path_rewrite_policy <envoy_v3_api_field_config.route.v3.RouteAction.path_rewrite_policy>`]
  // may be specified.
  //
  // Examples using Google's `RE2 <https://github.com/google/re2>`_ engine:
  //
  // * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
  //   string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
  //   into ``/v1/api/instance/foo``.
  //
  // * The pattern ``one`` paired with a substitution string of ``two`` would
  //   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
  //
  // * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
  //   ``\1two\2`` would replace only the first occurrence of ``one``,
  //   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
  //
  // * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
  //   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
  //   ``/aaa/yyy/bbb``.
  type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 32;

  // [#extension-category: envoy.path.rewrite]
  core.v3.TypedExtensionConfig path_rewrite_policy = 41;

  oneof host_rewrite_specifier {
    // Indicates that during forwarding, the host header will be swapped with
    // this value. Using this option will append the
    // :ref:`config_http_conn_man_headers_x-forwarded-host` header if
    // :ref:`append_x_forwarded_host <envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
    // is set.
    string host_rewrite_literal = 6
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];

    // Indicates that during forwarding, the host header will be swapped with
    // the hostname of the upstream host chosen by the cluster manager. This
    // option is applicable only when the destination cluster for a route is of
    // type ``strict_dns`` or ``logical_dns``,
    // or when :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.hostname>`
    // field is not empty. Setting this to true with other cluster types
    // has no effect. Using this option will append the
    // :ref:`config_http_conn_man_headers_x-forwarded-host` header if
    // :ref:`append_x_forwarded_host <envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
    // is set.
    google.protobuf.BoolValue auto_host_rewrite = 7;

    // Indicates that during forwarding, the host header will be swapped with the content of given
    // downstream or :ref:`custom <config_http_conn_man_headers_custom_request_headers>` header.
    // If header value is empty, host header is left intact. Using this option will append the
    // :ref:`config_http_conn_man_headers_x-forwarded-host` header if
    // :ref:`append_x_forwarded_host <envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
    // is set.
    //
    // .. attention::
    //
    //   Pay attention to the potential security implications of using this option. Provided header
    //   must come from trusted source.
    //
    // .. note::
    //
    //   If the header appears multiple times only the first value is used.
    string host_rewrite_header = 29
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false}];

    // Indicates that during forwarding, the host header will be swapped with
    // the result of the regex substitution executed on path value with query and fragment removed.
    // This is useful for transitioning variable content between path segment and subdomain.
    // Using this option will append the
    // :ref:`config_http_conn_man_headers_x-forwarded-host` header if
    // :ref:`append_x_forwarded_host <envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
    // is set.
    //
    // For example with the following config:
    //
    //   .. code-block:: yaml
    //
    //     host_rewrite_path_regex:
    //       pattern:
    //         google_re2: {}
    //         regex: "^/(.+)/.+$"
    //       substitution: \1
    //
    // Would rewrite the host header to ``envoyproxy.io`` given the path ``/envoyproxy.io/some/path``.
    type.matcher.v3.RegexMatchAndSubstitute host_rewrite_path_regex = 35;
  }

  // If set, then a host rewrite action (one of
  // :ref:`host_rewrite_literal <envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_literal>`,
  // :ref:`auto_host_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite>`,
  // :ref:`host_rewrite_header <envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_header>`, or
  // :ref:`host_rewrite_path_regex <envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_path_regex>`)
  // causes the original value of the host header, if any, to be appended to the
  // :ref:`config_http_conn_man_headers_x-forwarded-host` HTTP header if it is different to the last value appended.
  // This can be disabled by setting the runtime guard ``envoy_reloadable_features_append_xfh_idempotent`` to false.
  bool append_x_forwarded_host = 38;

  // Specifies the upstream timeout for the route. If not specified, the default is 15s. This
  // spans between the point at which the entire downstream request (i.e. end-of-stream) has been
  // processed and when the upstream response has been completely processed. A value of 0 will
  // disable the route's timeout.
  //
  // .. note::
  //
  //   This timeout includes all retries. See also
  //   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
  //   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
  //   :ref:`retry overview <arch_overview_http_routing_retry>`.
  google.protobuf.Duration timeout = 8;

  // Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
  // although the connection manager wide :ref:`stream_idle_timeout
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
  // will still apply. A value of 0 will completely disable the route's idle timeout, even if a
  // connection manager stream idle timeout is configured.
  //
  // The idle timeout is distinct to :ref:`timeout
  // <envoy_v3_api_field_config.route.v3.RouteAction.timeout>`, which provides an upper bound
  // on the upstream response time; :ref:`idle_timeout
  // <envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout>` instead bounds the amount
  // of time the request's stream may be idle.
  //
  // After header decoding, the idle timeout will apply on downstream and
  // upstream request events. Each time an encode/decode event for headers or
  // data is processed for the stream, the timer will be reset. If the timeout
  // fires, the stream is terminated with a 408 Request Timeout error code if no
  // upstream response header has been received, otherwise a stream reset
  // occurs.
  //
  // If the :ref:`overload action <config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
  // is configured, this timeout is scaled according to the value for
  // :ref:`HTTP_DOWNSTREAM_STREAM_IDLE <envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE>`.
  google.protobuf.Duration idle_timeout = 24;

  // Specifies how to send request over TLS early data.
  // If absent, allows `safe HTTP requests <https://www.rfc-editor.org/rfc/rfc7231#section-4.2.1>`_ to be sent on early data.
  // [#extension-category: envoy.route.early_data_policy]
  core.v3.TypedExtensionConfig early_data_policy = 40;

  // Indicates that the route has a retry policy. Note that if this is set,
  // it'll take precedence over the virtual host level retry policy entirely
  // (e.g.: policies are not merged, most internal one becomes the enforced policy).
  RetryPolicy retry_policy = 9;

  // [#not-implemented-hide:]
  // Specifies the configuration for retry policy extension. Note that if this is set, it'll take
  // precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
  // most internal one becomes the enforced policy). :ref:`Retry policy <envoy_v3_api_field_config.route.v3.VirtualHost.retry_policy>`
  // should not be set if this field is used.
  google.protobuf.Any retry_policy_typed_config = 33;

  // Specify a set of route request mirroring policies.
  // It takes precedence over the virtual host and route config mirror policy entirely.
  // That is, policies are not merged, the most specific non-empty one becomes the mirror policies.
  repeated RequestMirrorPolicy request_mirror_policies = 30;

  // Optionally specifies the :ref:`routing priority <arch_overview_http_routing_priority>`.
  core.v3.RoutingPriority priority = 11 [(validate.rules).enum = {defined_only: true}];

  // Specifies a set of rate limit configurations that could be applied to the
  // route.
  repeated RateLimit rate_limits = 13;

  // Specifies if the rate limit filter should include the virtual host rate
  // limits. By default, if the route configured rate limits, the virtual host
  // :ref:`rate_limits <envoy_v3_api_field_config.route.v3.VirtualHost.rate_limits>` are not applied to the
  // request.
  //
  // This field is deprecated. Please use :ref:`vh_rate_limits <envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimitPerRoute.vh_rate_limits>`
  google.protobuf.BoolValue include_vh_rate_limits = 14
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Specifies a list of hash policies to use for ring hash load balancing. Each
  // hash policy is evaluated individually and the combined result is used to
  // route the request. The method of combination is deterministic such that
  // identical lists of hash policies will produce the same hash. Since a hash
  // policy examines specific parts of a request, it can fail to produce a hash
  // (i.e. if the hashed header is not present). If (and only if) all configured
  // hash policies fail to generate a hash, no hash will be produced for
  // the route. In this case, the behavior is the same as if no hash policies
  // were specified (i.e. the ring hash load balancer will choose a random
  // backend). If a hash policy has the "terminal" attribute set to true, and
  // there is already a hash generated, the hash is returned immediately,
  // ignoring the rest of the hash policy list.
  repeated HashPolicy hash_policy = 15;

  // Indicates that the route has a CORS policy. This field is ignored if related cors policy is
  // found in the :ref:`Route.typed_per_filter_config<envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>` or
  // :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config<envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`.
  //
  // .. attention::
  //
  //   This option has been deprecated. Please use
  //   :ref:`Route.typed_per_filter_config<envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>` or
  //   :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config<envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`
  //   to configure the CORS HTTP filter.
  CorsPolicy cors = 17 [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Deprecated by :ref:`grpc_timeout_header_max <envoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_max>`
  // If present, and the request is a gRPC request, use the
  // `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_,
  // or its default value (infinity) instead of
  // :ref:`timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>`, but limit the applied timeout
  // to the maximum value specified here. If configured as 0, the maximum allowed timeout for
  // gRPC requests is infinity. If not configured at all, the ``grpc-timeout`` header is not used
  // and gRPC requests time out like any other requests using
  // :ref:`timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>` or its default.
  // This can be used to prevent unexpected upstream request timeouts due to potentially long
  // time gaps between gRPC request and response in gRPC streaming mode.
  //
  // .. note::
  //
  //    If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes
  //    precedence over `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, when
  //    both are present. See also
  //    :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
  //    :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
  //    :ref:`retry overview <arch_overview_http_routing_retry>`.
  google.protobuf.Duration max_grpc_timeout = 23
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Deprecated by :ref:`grpc_timeout_header_offset <envoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_offset>`.
  // If present, Envoy will adjust the timeout provided by the ``grpc-timeout`` header by subtracting
  // the provided duration from the header. This is useful in allowing Envoy to set its global
  // timeout to be less than that of the deadline imposed by the calling client, which makes it more
  // likely that Envoy will handle the timeout instead of having the call canceled by the client.
  // The offset will only be applied if the provided grpc_timeout is greater than the offset. This
  // ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
  // infinity).
  google.protobuf.Duration grpc_timeout_offset = 28
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  repeated UpgradeConfig upgrade_configs = 25;

  // If present, Envoy will try to follow an upstream redirect response instead of proxying the
  // response back to the downstream. An upstream redirect response is defined
  // by :ref:`redirect_response_codes
  // <envoy_v3_api_field_config.route.v3.InternalRedirectPolicy.redirect_response_codes>`.
  InternalRedirectPolicy internal_redirect_policy = 34;

  InternalRedirectAction internal_redirect_action = 26
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // An internal redirect is handled, iff the number of previous internal redirects that a
  // downstream request has encountered is lower than this value, and
  // :ref:`internal_redirect_action <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_action>`
  // is set to :ref:`HANDLE_INTERNAL_REDIRECT
  // <envoy_v3_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT>`
  // In the case where a downstream request is bounced among multiple routes by internal redirect,
  // the first route that hits this threshold, or has
  // :ref:`internal_redirect_action <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_action>`
  // set to
  // :ref:`PASS_THROUGH_INTERNAL_REDIRECT
  // <envoy_v3_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT>`
  // will pass the redirect back to downstream.
  //
  // If not specified, at most one redirect will be followed.
  google.protobuf.UInt32Value max_internal_redirects = 31
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Indicates that the route has a hedge policy. Note that if this is set,
  // it'll take precedence over the virtual host level hedge policy entirely
  // (e.g.: policies are not merged, most internal one becomes the enforced policy).
  HedgePolicy hedge_policy = 27;

  // Specifies the maximum stream duration for this route.
  MaxStreamDuration max_stream_duration = 36;
}

// HTTP retry :ref:`architecture overview <arch_overview_http_routing_retry>`.
// [#next-free-field: 14]
message RetryPolicy {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.RetryPolicy";

  enum ResetHeaderFormat {
    SECONDS = 0;
    UNIX_TIMESTAMP = 1;
  }

  message RetryPriority {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.route.RetryPolicy.RetryPriority";

    reserved 2;

    reserved "config";

    string name = 1 [(validate.rules).string = {min_len: 1}];

    // [#extension-category: envoy.retry_priorities]
    oneof config_type {
      google.protobuf.Any typed_config = 3;
    }
  }

  message RetryHostPredicate {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.route.RetryPolicy.RetryHostPredicate";

    reserved 2;

    reserved "config";

    string name = 1 [(validate.rules).string = {min_len: 1}];

    // [#extension-category: envoy.retry_host_predicates]
    oneof config_type {
      google.protobuf.Any typed_config = 3;
    }
  }

  message RetryBackOff {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.route.RetryPolicy.RetryBackOff";

    // Specifies the base interval between retries. This parameter is required and must be greater
    // than zero. Values less than 1 ms are rounded up to 1 ms.
    // See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's
    // back-off algorithm.
    google.protobuf.Duration base_interval = 1 [(validate.rules).duration = {
      required: true
      gt {}
    }];

    // Specifies the maximum interval between retries. This parameter is optional, but must be
    // greater than or equal to the ``base_interval`` if set. The default is 10 times the
    // ``base_interval``. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion
    // of Envoy's back-off algorithm.
    google.protobuf.Duration max_interval = 2 [(validate.rules).duration = {gt {}}];
  }

  message ResetHeader {
    // The name of the reset header.
    //
    // .. note::
    //
    //   If the header appears multiple times only the first value is used.
    string name = 1
        [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

    // The format of the reset header.
    ResetHeaderFormat format = 2 [(validate.rules).enum = {defined_only: true}];
  }

  // A retry back-off strategy that applies when the upstream server rate limits
  // the request.
  //
  // Given this configuration:
  //
  // .. code-block:: yaml
  //
  //   rate_limited_retry_back_off:
  //     reset_headers:
  //     - name: Retry-After
  //       format: SECONDS
  //     - name: X-RateLimit-Reset
  //       format: UNIX_TIMESTAMP
  //     max_interval: "300s"
  //
  // The following algorithm will apply:
  //
  //  1. If the response contains the header ``Retry-After`` its value must be on
  //     the form ``120`` (an integer that represents the number of seconds to
  //     wait before retrying). If so, this value is used as the back-off interval.
  //  2. Otherwise, if the response contains the header ``X-RateLimit-Reset`` its
  //     value must be on the form ``1595320702`` (an integer that represents the
  //     point in time at which to retry, as a Unix timestamp in seconds). If so,
  //     the current time is subtracted from this value and the result is used as
  //     the back-off interval.
  //  3. Otherwise, Envoy will use the default
  //     :ref:`exponential back-off <envoy_v3_api_field_config.route.v3.RetryPolicy.retry_back_off>`
  //     strategy.
  //
  // No matter which format is used, if the resulting back-off interval exceeds
  // ``max_interval`` it is discarded and the next header in ``reset_headers``
  // is tried. If a request timeout is configured for the route it will further
  // limit how long the request will be allowed to run.
  //
  // To prevent many clients retrying at the same point in time jitter is added
  // to the back-off interval, so the resulting interval is decided by taking:
  // ``random(interval, interval * 1.5)``.
  //
  // .. attention::
  //
  //   Configuring ``rate_limited_retry_back_off`` will not by itself cause a request
  //   to be retried. You will still need to configure the right retry policy to match
  //   the responses from the upstream server.
  message RateLimitedRetryBackOff {
    // Specifies the reset headers (like ``Retry-After`` or ``X-RateLimit-Reset``)
    // to match against the response. Headers are tried in order, and matched case
    // insensitive. The first header to be parsed successfully is used. If no headers
    // match the default exponential back-off is used instead.
    repeated ResetHeader reset_headers = 1 [(validate.rules).repeated = {min_items: 1}];

    // Specifies the maximum back off interval that Envoy will allow. If a reset
    // header contains an interval longer than this then it will be discarded and
    // the next header will be tried. Defaults to 300 seconds.
    google.protobuf.Duration max_interval = 2 [(validate.rules).duration = {gt {}}];
  }

  // Specifies the conditions under which retry takes place. These are the same
  // conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
  // :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
  string retry_on = 1;

  // Specifies the allowed number of retries. This parameter is optional and
  // defaults to 1. These are the same conditions documented for
  // :ref:`config_http_filters_router_x-envoy-max-retries`.
  google.protobuf.UInt32Value num_retries = 2
      [(udpa.annotations.field_migrate).rename = "max_retries"];

  // Specifies a non-zero upstream timeout per retry attempt (including the initial attempt). This
  // parameter is optional. The same conditions documented for
  // :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.
  //
  // .. note::
  //
  //   If left unspecified, Envoy will use the global
  //   :ref:`route timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>` for the request.
  //   Consequently, when using a :ref:`5xx <config_http_filters_router_x-envoy-retry-on>` based
  //   retry policy, a request that times out will not be retried as the total timeout budget
  //   would have been exhausted.
  google.protobuf.Duration per_try_timeout = 3;

  // Specifies an upstream idle timeout per retry attempt (including the initial attempt). This
  // parameter is optional and if absent there is no per try idle timeout. The semantics of the per
  // try idle timeout are similar to the
  // :ref:`route idle timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>` and
  // :ref:`stream idle timeout
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
  // both enforced by the HTTP connection manager. The difference is that this idle timeout
  // is enforced by the router for each individual attempt and thus after all previous filters have
  // run, as opposed to *before* all previous filters run for the other idle timeouts. This timeout
  // is useful in cases in which total request timeout is bounded by a number of retries and a
  // :ref:`per_try_timeout <envoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout>`, but
  // there is a desire to ensure each try is making incremental progress. Note also that similar
  // to :ref:`per_try_timeout <envoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout>`,
  // this idle timeout does not start until after both the entire request has been received by the
  // router *and* a connection pool connection has been obtained. Unlike
  // :ref:`per_try_timeout <envoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout>`,
  // the idle timer continues once the response starts streaming back to the downstream client.
  // This ensures that response data continues to make progress without using one of the HTTP
  // connection manager idle timeouts.
  google.protobuf.Duration per_try_idle_timeout = 13;

  // Specifies an implementation of a RetryPriority which is used to determine the
  // distribution of load across priorities used for retries. Refer to
  // :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more details.
  RetryPriority retry_priority = 4;

  // Specifies a collection of RetryHostPredicates that will be consulted when selecting a host
  // for retries. If any of the predicates reject the host, host selection will be reattempted.
  // Refer to :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more
  // details.
  repeated RetryHostPredicate retry_host_predicate = 5;

  // Retry options predicates that will be applied prior to retrying a request. These predicates
  // allow customizing request behavior between retries.
  // [#comment: add [#extension-category: envoy.retry_options_predicates] when there are built-in extensions]
  repeated core.v3.TypedExtensionConfig retry_options_predicates = 12;

  // The maximum number of times host selection will be reattempted before giving up, at which
  // point the host that was last selected will be routed to. If unspecified, this will default to
  // retrying once.
  int64 host_selection_retry_max_attempts = 6;

  // HTTP status codes that should trigger a retry in addition to those specified by retry_on.
  repeated uint32 retriable_status_codes = 7;

  // Specifies parameters that control exponential retry back off. This parameter is optional, in which case the
  // default base interval is 25 milliseconds or, if set, the current value of the
  // ``upstream.base_retry_backoff_ms`` runtime parameter. The default maximum interval is 10 times
  // the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries`
  // describes Envoy's back-off algorithm.
  RetryBackOff retry_back_off = 8;

  // Specifies parameters that control a retry back-off strategy that is used
  // when the request is rate limited by the upstream server. The server may
  // return a response header like ``Retry-After`` or ``X-RateLimit-Reset`` to
  // provide feedback to the client on how long to wait before retrying. If
  // configured, this back-off strategy will be used instead of the
  // default exponential back off strategy (configured using ``retry_back_off``)
  // whenever a response includes the matching headers.
  RateLimitedRetryBackOff rate_limited_retry_back_off = 11;

  // HTTP response headers that trigger a retry if present in the response. A retry will be
  // triggered if any of the header matches match the upstream response headers.
  // The field is only consulted if 'retriable-headers' retry policy is active.
  repeated HeaderMatcher retriable_headers = 9;

  // HTTP headers which must be present in the request for retries to be attempted.
  repeated HeaderMatcher retriable_request_headers = 10;
}

// HTTP request hedging :ref:`architecture overview <arch_overview_http_routing_hedging>`.
message HedgePolicy {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.HedgePolicy";

  // Specifies the number of initial requests that should be sent upstream.
  // Must be at least 1.
  // Defaults to 1.
  // [#not-implemented-hide:]
  google.protobuf.UInt32Value initial_requests = 1 [(validate.rules).uint32 = {gte: 1}];

  // Specifies a probability that an additional upstream request should be sent
  // on top of what is specified by initial_requests.
  // Defaults to 0.
  // [#not-implemented-hide:]
  type.v3.FractionalPercent additional_request_chance = 2;

  // Indicates that a hedged request should be sent when the per-try timeout is hit.
  // This means that a retry will be issued without resetting the original request, leaving multiple upstream requests in flight.
  // The first request to complete successfully will be the one returned to the caller.
  //
  // * At any time, a successful response (i.e. not triggering any of the retry-on conditions) would be returned to the client.
  // * Before per-try timeout, an error response (per retry-on conditions) would be retried immediately or returned ot the client
  //   if there are no more retries left.
  // * After per-try timeout, an error response would be discarded, as a retry in the form of a hedged request is already in progress.
  //
  // Note: For this to have effect, you must have a :ref:`RetryPolicy <envoy_v3_api_msg_config.route.v3.RetryPolicy>` that retries at least
  // one error code and specifies a maximum number of retries.
  //
  // Defaults to false.
  bool hedge_on_per_try_timeout = 3;
}

// [#next-free-field: 10]
message RedirectAction {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.RedirectAction";

  enum RedirectResponseCode {
    // Moved Permanently HTTP Status Code - 301.
    MOVED_PERMANENTLY = 0;

    // Found HTTP Status Code - 302.
    FOUND = 1;

    // See Other HTTP Status Code - 303.
    SEE_OTHER = 2;

    // Temporary Redirect HTTP Status Code - 307.
    TEMPORARY_REDIRECT = 3;

    // Permanent Redirect HTTP Status Code - 308.
    PERMANENT_REDIRECT = 4;
  }

  // When the scheme redirection take place, the following rules apply:
  //  1. If the source URI scheme is ``http`` and the port is explicitly
  //     set to ``:80``, the port will be removed after the redirection
  //  2. If the source URI scheme is ``https`` and the port is explicitly
  //     set to ``:443``, the port will be removed after the redirection
  oneof scheme_rewrite_specifier {
    // The scheme portion of the URL will be swapped with "https".
    bool https_redirect = 4;

    // The scheme portion of the URL will be swapped with this value.
    string scheme_redirect = 7;
  }

  // The host portion of the URL will be swapped with this value.
  string host_redirect = 1
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];

  // The port value of the URL will be swapped with this value.
  uint32 port_redirect = 8;

  oneof path_rewrite_specifier {
    // The path portion of the URL will be swapped with this value.
    // Please note that query string in path_redirect will override the
    // request's query string and will not be stripped.
    //
    // For example, let's say we have the following routes:
    //
    // - match: { path: "/old-path-1" }
    //   redirect: { path_redirect: "/new-path-1" }
    // - match: { path: "/old-path-2" }
    //   redirect: { path_redirect: "/new-path-2", strip-query: "true" }
    // - match: { path: "/old-path-3" }
    //   redirect: { path_redirect: "/new-path-3?foo=1", strip_query: "true" }
    //
    // 1. if request uri is "/old-path-1?bar=1", users will be redirected to "/new-path-1?bar=1"
    // 2. if request uri is "/old-path-2?bar=1", users will be redirected to "/new-path-2"
    // 3. if request uri is "/old-path-3?bar=1", users will be redirected to "/new-path-3?foo=1"
    string path_redirect = 2
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];

    // Indicates that during redirection, the matched prefix (or path)
    // should be swapped with this value. This option allows redirect URLs be dynamically created
    // based on the request.
    //
    // .. attention::
    //
    //   Pay attention to the use of trailing slashes as mentioned in
    //   :ref:`RouteAction's prefix_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`.
    string prefix_rewrite = 5
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];

    // Indicates that during redirect, portions of the path that match the
    // pattern should be rewritten, even allowing the substitution of capture
    // groups from the pattern into the new path as specified by the rewrite
    // substitution string. This is useful to allow application paths to be
    // rewritten in a way that is aware of segments with variable content like
    // identifiers.
    //
    // Examples using Google's `RE2 <https://github.com/google/re2>`_ engine:
    //
    // * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
    //   string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
    //   into ``/v1/api/instance/foo``.
    //
    // * The pattern ``one`` paired with a substitution string of ``two`` would
    //   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
    //
    // * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
    //   ``\1two\2`` would replace only the first occurrence of ``one``,
    //   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
    //
    // * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
    //   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
    //   ``/aaa/yyy/bbb``.
    type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 9;
  }

  // The HTTP status code to use in the redirect response. The default response
  // code is MOVED_PERMANENTLY (301).
  RedirectResponseCode response_code = 3 [(validate.rules).enum = {defined_only: true}];

  // Indicates that during redirection, the query portion of the URL will
  // be removed. Default value is false.
  bool strip_query = 6;
}

message DirectResponseAction {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.route.DirectResponseAction";

  // Specifies the HTTP response status to be returned.
  uint32 status = 1 [(validate.rules).uint32 = {lt: 600 gte: 200}];

  // Specifies the content of the response body. If this setting is omitted,
  // no body is included in the generated response.
  //
  // .. note::
  //
  //   Headers can be specified using ``response_headers_to_add`` in the enclosing
  //   :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` or
  //   :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`.
  core.v3.DataSource body = 2;
}

// [#not-implemented-hide:]
message NonForwardingAction {
}

message Decorator {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.Decorator";

  // The operation name associated with the request matched to this route. If tracing is
  // enabled, this information will be used as the span name reported for this request.
  //
  // .. note::
  //
  //   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
  //   by the :ref:`x-envoy-decorator-operation
  //   <config_http_filters_router_x-envoy-decorator-operation>` header.
  string operation = 1 [(validate.rules).string = {min_len: 1}];

  // Whether the decorated details should be propagated to the other party. The default is true.
  google.protobuf.BoolValue propagate = 2;
}

message Tracing {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.Tracing";

  // Target percentage of requests managed by this HTTP connection manager that will be force
  // traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
  // header is set. This field is a direct analog for the runtime variable
  // 'tracing.client_enabled' in the :ref:`HTTP Connection Manager
  // <config_http_conn_man_runtime>`.
  // Default: 100%
  type.v3.FractionalPercent client_sampling = 1;

  // Target percentage of requests managed by this HTTP connection manager that will be randomly
  // selected for trace generation, if not requested by the client or not forced. This field is
  // a direct analog for the runtime variable 'tracing.random_sampling' in the
  // :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
  // Default: 100%
  type.v3.FractionalPercent random_sampling = 2;

  // Target percentage of requests managed by this HTTP connection manager that will be traced
  // after all other sampling checks have been applied (client-directed, force tracing, random
  // sampling). This field functions as an upper limit on the total configured sampling rate. For
  // instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
  // of client requests with the appropriate headers to be force traced. This field is a direct
  // analog for the runtime variable 'tracing.global_enabled' in the
  // :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
  // Default: 100%
  type.v3.FractionalPercent overall_sampling = 3;

  // A list of custom tags with unique tag name to create tags for the active span.
  // It will take effect after merging with the :ref:`corresponding configuration
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.custom_tags>`
  // configured in the HTTP connection manager. If two tags with the same name are configured
  // each in the HTTP connection manager and the route level, the one configured here takes
  // priority.
  repeated type.tracing.v3.CustomTag custom_tags = 4;
}

// A virtual cluster is a way of specifying a regex matching rule against
// certain important endpoints such that statistics are generated explicitly for
// the matched requests. The reason this is useful is that when doing
// prefix/path matching Envoy does not always know what the application
// considers to be an endpoint. Thus, its impossible for Envoy to generically
// emit per endpoint statistics. However, often systems have highly critical
// endpoints that they wish to get perfect statistics on. Virtual cluster
// statistics are perfect in the sense that they are emitted on the downstream
// side such that they include network level failures.
//
// Documentation for :ref:`virtual cluster statistics <config_http_filters_router_vcluster_stats>`.
//
// .. note::
//
//    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
//    every application endpoint. This is both not easily maintainable and as well the matching and
//    statistics output are not free.
message VirtualCluster {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.VirtualCluster";

  reserved 1, 3;

  reserved "pattern", "method";

  // Specifies a list of header matchers to use for matching requests. Each specified header must
  // match. The pseudo-headers ``:path`` and ``:method`` can be used to match the request path and
  // method, respectively.
  repeated HeaderMatcher headers = 4;

  // Specifies the name of the virtual cluster. The virtual cluster name as well
  // as the virtual host name are used when emitting statistics. The statistics are emitted by the
  // router filter and are documented :ref:`here <config_http_filters_router_stats>`.
  string name = 2 [(validate.rules).string = {min_len: 1}];
}

// Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
// Also applies to Local rate limiting :ref:`using descriptors <config_http_filters_local_rate_limit_descriptors>`.
message RateLimit {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.RateLimit";

  // [#next-free-field: 12]
  message Action {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.route.RateLimit.Action";

    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("source_cluster", "<local service cluster>")
    //
    // <local service cluster> is derived from the :option:`--service-cluster` option.
    message SourceCluster {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.route.RateLimit.Action.SourceCluster";
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("destination_cluster", "<routed target cluster>")
    //
    // Once a request matches against a route table rule, a routed cluster is determined by one of
    // the following :ref:`route table configuration <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`
    // settings:
    //
    // * :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` indicates the upstream cluster
    //   to route to.
    // * :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`
    //   chooses a cluster randomly from a set of clusters with attributed weight.
    // * :ref:`cluster_header <envoy_v3_api_field_config.route.v3.RouteAction.cluster_header>` indicates which
    //   header in the request contains the target cluster.
    message DestinationCluster {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.route.RateLimit.Action.DestinationCluster";
    }

    // The following descriptor entry is appended when a header contains a key that matches the
    // ``header_name``:
    //
    // .. code-block:: cpp
    //
    //   ("<descriptor_key>", "<header_value_queried_from_header>")
    message RequestHeaders {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.route.RateLimit.Action.RequestHeaders";

      // The header name to be queried from the request headers. The headers
      // value is used to populate the value of the descriptor entry for the
      // descriptor_key.
      string header_name = 1
          [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

      // The key to use in the descriptor entry.
      string descriptor_key = 2 [(validate.rules).string = {min_len: 1}];

      // If set to true, Envoy skips the descriptor while calling rate limiting service
      // when header is not present in the request. By default it skips calling the
      // rate limiting service if this header is not present in the request.
      bool skip_if_absent = 3;
    }

    // The following descriptor entry is appended to the descriptor and is populated using the
    // trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
    //
    // .. code-block:: cpp
    //
    //   ("remote_address", "<trusted address from x-forwarded-for>")
    message RemoteAddress {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.route.RateLimit.Action.RemoteAddress";
    }

    // The following descriptor entry is appended to the descriptor and is populated using the
    // masked address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
    //
    // .. code-block:: cpp
    //
    //   ("masked_remote_address", "<masked address from x-forwarded-for>")
    message MaskedRemoteAddress {
      // Length of prefix mask len for IPv4 (e.g. 0, 32).
      // Defaults to 32 when unset.
      // For example, trusted address from x-forwarded-for is ``192.168.1.1``,
      // the descriptor entry is ("masked_remote_address", "192.168.1.1/32");
      // if mask len is 24, the descriptor entry is ("masked_remote_address", "192.168.1.0/24").
      google.protobuf.UInt32Value v4_prefix_mask_len = 1 [(validate.rules).uint32 = {lte: 32}];

      // Length of prefix mask len for IPv6 (e.g. 0, 128).
      // Defaults to 128 when unset.
      // For example, trusted address from x-forwarded-for is ``2001:abcd:ef01:2345:6789:abcd:ef01:234``,
      // the descriptor entry is ("masked_remote_address", "2001:abcd:ef01:2345:6789:abcd:ef01:234/128");
      // if mask len is 64, the descriptor entry is ("masked_remote_address", "2001:abcd:ef01:2345::/64").
      google.protobuf.UInt32Value v6_prefix_mask_len = 2 [(validate.rules).uint32 = {lte: 128}];
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("generic_key", "<descriptor_value>")
    message GenericKey {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.route.RateLimit.Action.GenericKey";

      // The value to use in the descriptor entry.
      string descriptor_value = 1 [(validate.rules).string = {min_len: 1}];

      // An optional key to use in the descriptor entry. If not set it defaults
      // to 'generic_key' as the descriptor key.
      string descriptor_key = 2;
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("header_match", "<descriptor_value>")
    message HeaderValueMatch {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.route.RateLimit.Action.HeaderValueMatch";

      // The key to use in the descriptor entry. Defaults to ``header_match``.
      string descriptor_key = 4;

      // The value to use in the descriptor entry.
      string descriptor_value = 1 [(validate.rules).string = {min_len: 1}];

      // If set to true, the action will append a descriptor entry when the
      // request matches the headers. If set to false, the action will append a
      // descriptor entry when the request does not match the headers. The
      // default value is true.
      google.protobuf.BoolValue expect_match = 2;

      // Specifies a set of headers that the rate limit action should match
      // on. The action will check the requests headers against all the
      // specified headers in the config. A match will happen if all the
      // headers in the config are present in the request with the same values
      // (or based on presence if the value field is not in the config).
      repeated HeaderMatcher headers = 3 [(validate.rules).repeated = {min_items: 1}];
    }

    // The following descriptor entry is appended when the
    // :ref:`dynamic metadata <well_known_dynamic_metadata>` contains a key value:
    //
    // .. code-block:: cpp
    //
    //   ("<descriptor_key>", "<value_queried_from_dynamic_metadata>")
    //
    // .. attention::
    //   This action has been deprecated in favor of the :ref:`metadata <envoy_v3_api_msg_config.route.v3.RateLimit.Action.MetaData>` action
    message DynamicMetaData {
      // The key to use in the descriptor entry.
      string descriptor_key = 1 [(validate.rules).string = {min_len: 1}];

      // Metadata struct that defines the key and path to retrieve the string value. A match will
      // only happen if the value in the dynamic metadata is of type string.
      type.metadata.v3.MetadataKey metadata_key = 2 [(validate.rules).message = {required: true}];

      // An optional value to use if ``metadata_key`` is empty. If not set and
      // no value is present under the metadata_key then no descriptor is generated.
      string default_value = 3;
    }

    // The following descriptor entry is appended when the metadata contains a key value:
    //
    // .. code-block:: cpp
    //
    //   ("<descriptor_key>", "<value_queried_from_metadata>")
    // [#next-free-field: 6]
    message MetaData {
      enum Source {
        // Query :ref:`dynamic metadata <well_known_dynamic_metadata>`
        DYNAMIC = 0;

        // Query :ref:`route entry metadata <envoy_v3_api_field_config.route.v3.Route.metadata>`
        ROUTE_ENTRY = 1;
      }

      // The key to use in the descriptor entry.
      string descriptor_key = 1 [(validate.rules).string = {min_len: 1}];

      // Metadata struct that defines the key and path to retrieve the string value. A match will
      // only happen if the value in the metadata is of type string.
      type.metadata.v3.MetadataKey metadata_key = 2 [(validate.rules).message = {required: true}];

      // An optional value to use if ``metadata_key`` is empty. If not set and
      // no value is present under the metadata_key then ``skip_if_absent`` is followed to
      // skip calling the rate limiting service or skip the descriptor.
      string default_value = 3;

      // Source of metadata
      Source source = 4 [(validate.rules).enum = {defined_only: true}];

      // If set to true, Envoy skips the descriptor while calling rate limiting service
      // when ``metadata_key`` is empty and ``default_value`` is not set. By default it skips calling the
      // rate limiting service in that case.
      bool skip_if_absent = 5;
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("query_match", "<descriptor_value>")
    message QueryParameterValueMatch {
      // The key to use in the descriptor entry. Defaults to ``query_match``.
      string descriptor_key = 4;

      // The value to use in the descriptor entry.
      string descriptor_value = 1 [(validate.rules).string = {min_len: 1}];

      // If set to true, the action will append a descriptor entry when the
      // request matches the headers. If set to false, the action will append a
      // descriptor entry when the request does not match the headers. The
      // default value is true.
      google.protobuf.BoolValue expect_match = 2;

      // Specifies a set of query parameters that the rate limit action should match
      // on. The action will check the requests query parameters against all the
      // specified query parameters in the config. A match will happen if all the
      // query parameters in the config are present in the request with the same values
      // (or based on presence if the value field is not in the config).
      repeated QueryParameterMatcher query_parameters = 3
          [(validate.rules).repeated = {min_items: 1}];
    }

    oneof action_specifier {
      option (validate.required) = true;

      // Rate limit on source cluster.
      SourceCluster source_cluster = 1;

      // Rate limit on destination cluster.
      DestinationCluster destination_cluster = 2;

      // Rate limit on request headers.
      RequestHeaders request_headers = 3;

      // Rate limit on remote address.
      RemoteAddress remote_address = 4;

      // Rate limit on a generic key.
      GenericKey generic_key = 5;

      // Rate limit on the existence of request headers.
      HeaderValueMatch header_value_match = 6;

      // Rate limit on dynamic metadata.
      //
      // .. attention::
      //   This field has been deprecated in favor of the :ref:`metadata <envoy_v3_api_field_config.route.v3.RateLimit.Action.metadata>` field
      DynamicMetaData dynamic_metadata = 7 [
        deprecated = true,
        (envoy.annotations.deprecated_at_minor_version) = "3.0",
        (envoy.annotations.disallowed_by_default) = true
      ];

      // Rate limit on metadata.
      MetaData metadata = 8;

      // Rate limit descriptor extension. See the rate limit descriptor extensions documentation.
      //
      // :ref:`HTTP matching input functions <arch_overview_matching_api>` are
      // permitted as descriptor extensions. The input functions are only
      // looked up if there is no rate limit descriptor extension matching
      // the type URL.
      //
      // [#extension-category: envoy.rate_limit_descriptors]
      core.v3.TypedExtensionConfig extension = 9;

      // Rate limit on masked remote address.
      MaskedRemoteAddress masked_remote_address = 10;

      // Rate limit on the existence of query parameters.
      QueryParameterValueMatch query_parameter_value_match = 11;
    }
  }

  message Override {
    // Fetches the override from the dynamic metadata.
    message DynamicMetadata {
      // Metadata struct that defines the key and path to retrieve the struct value.
      // The value must be a struct containing an integer "requests_per_unit" property
      // and a "unit" property with a value parseable to :ref:`RateLimitUnit
      // enum <envoy_v3_api_enum_type.v3.RateLimitUnit>`
      type.metadata.v3.MetadataKey metadata_key = 1 [(validate.rules).message = {required: true}];
    }

    oneof override_specifier {
      option (validate.required) = true;

      // Limit override from dynamic metadata.
      DynamicMetadata dynamic_metadata = 1;
    }
  }

  // Refers to the stage set in the filter. The rate limit configuration only
  // applies to filters with the same stage number. The default stage number is
  // 0.
  //
  // .. note::
  //
  //   The filter supports a range of 0 - 10 inclusively for stage numbers.
  google.protobuf.UInt32Value stage = 1 [(validate.rules).uint32 = {lte: 10}];

  // The key to be set in runtime to disable this rate limit configuration.
  string disable_key = 2;

  // A list of actions that are to be applied for this rate limit configuration.
  // Order matters as the actions are processed sequentially and the descriptor
  // is composed by appending descriptor entries in that sequence. If an action
  // cannot append a descriptor entry, no descriptor is generated for the
  // configuration. See :ref:`composing actions
  // <config_http_filters_rate_limit_composing_actions>` for additional documentation.
  repeated Action actions = 3 [(validate.rules).repeated = {min_items: 1}];

  // An optional limit override to be appended to the descriptor produced by this
  // rate limit configuration. If the override value is invalid or cannot be resolved
  // from metadata, no override is provided. See :ref:`rate limit override
  // <config_http_filters_rate_limit_rate_limit_override>` for more information.
  Override limit = 4;
}

// .. attention::
//
//   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1 ``Host``
//   header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
//
// .. attention::
//
//   To route on HTTP method, use the special HTTP/2 ``:method`` header. This works for both
//   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
//
//   .. code-block:: json
//
//     {
//       "name": ":method",
//       "string_match": {
//         "exact": "POST"
//       }
//     }
//
// .. attention::
//   In the absence of any header match specifier, match will default to :ref:`present_match
//   <envoy_v3_api_field_config.route.v3.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
//   <envoy_v3_api_field_config.route.v3.HeaderMatcher.name>` header will match, regardless of the header's
//   value.
//
//  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
// [#next-free-field: 15]
message HeaderMatcher {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.route.HeaderMatcher";

  reserved 2, 3, 5;

  reserved "regex_match";

  // Specifies the name of the header in the request.
  string name = 1
      [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

  // Specifies how the header match will be performed to route the request.
  oneof header_match_specifier {
    // If specified, header match will be performed based on the value of the header.
    // This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
    string exact_match = 4
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

    // If specified, this regex string is a regular expression rule which implies the entire request
    // header value must match the regex. The rule will not match if only a subsequence of the
    // request header value matches the regex.
    // This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
    type.matcher.v3.RegexMatcher safe_regex_match = 11
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

    // If specified, header match will be performed based on range.
    // The rule will match if the request header value is within this range.
    // The entire request header value must represent an integer in base 10 notation: consisting of
    // an optional plus or minus sign followed by a sequence of digits. The rule will not match if
    // the header value does not represent an integer. Match will fail for empty values, floating
    // point numbers or if only a subsequence of the header value is an integer.
    //
    // Examples:
    //
    // * For range [-10,0), route will match for header value -1, but not for 0, ``somestring``, 10.9,
    //   ``-1somestring``
    type.v3.Int64Range range_match = 6;

    // If specified as true, header match will be performed based on whether the header is in the
    // request. If specified as false, header match will be performed based on whether the header is absent.
    bool present_match = 7;

    // If specified, header match will be performed based on the prefix of the header value.
    // Note: empty prefix is not allowed, please use present_match instead.
    // This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
    //
    // Examples:
    //
    // * The prefix ``abcd`` matches the value ``abcdxyz``, but not for ``abcxyz``.
    string prefix_match = 9 [
      deprecated = true,
      (validate.rules).string = {min_len: 1},
      (envoy.annotations.deprecated_at_minor_version) = "3.0"
    ];

    // If specified, header match will be performed based on the suffix of the header value.
    // Note: empty suffix is not allowed, please use present_match instead.
    // This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
    //
    // Examples:
    //
    // * The suffix ``abcd`` matches the value ``xyzabcd``, but not for ``xyzbcd``.
    string suffix_match = 10 [
      deprecated = true,
      (validate.rules).string = {min_len: 1},
      (envoy.annotations.deprecated_at_minor_version) = "3.0"
    ];

    // If specified, header match will be performed based on whether the header value contains
    // the given value or not.
    // Note: empty contains match is not allowed, please use present_match instead.
    // This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
    //
    // Examples:
    //
    // * The value ``abcd`` matches the value ``xyzabcdpqr``, but not for ``xyzbcdpqr``.
    string contains_match = 12 [
      deprecated = true,
      (validate.rules).string = {min_len: 1},
      (envoy.annotations.deprecated_at_minor_version) = "3.0"
    ];

    // If specified, header match will be performed based on the string match of the header value.
    type.matcher.v3.StringMatcher string_match = 13;
  }

  // If specified, the match result will be inverted before checking. Defaults to false.
  //
  // Examples:
  //
  // * The regex ``\d{3}`` does not match the value ``1234``, so it will match when inverted.
  // * The range [-10,0) will match the value -1, so it will not match when inverted.
  bool invert_match = 8;

  // If specified, for any header match rule, if the header match rule specified header
  // does not exist, this header value will be treated as empty. Defaults to false.
  //
  // Examples:
  //
  // * The header match rule specified header "header1" to range match of [0, 10],
  //   :ref:`invert_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match>`
  //   is set to true and :ref:`treat_missing_header_as_empty <envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
  //   is set to true; The "header1" header is not present. The match rule will
  //   treat the "header1" as an empty header. The empty header does not match the range,
  //   so it will match when inverted.
  // * The header match rule specified header "header2" to range match of [0, 10],
  //   :ref:`invert_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match>`
  //   is set to true and :ref:`treat_missing_header_as_empty <envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
  //   is set to false; The "header2" header is not present and the header
  //   matcher rule for "header2" will be ignored so it will not match.
  // * The header match rule specified header "header3" to a string regex match
  //   ``^$`` which means an empty string, and
  //   :ref:`treat_missing_header_as_empty <envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
  //   is set to true; The "header3" header is not present.
  //   The match rule will treat the "header3" header as an empty header so it will match.
  // * The header match rule specified header "header4" to a string regex match
  //   ``^$`` which means an empty string, and
  //   :ref:`treat_missing_header_as_empty <envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
  //   is set to false; The "header4" header is not present.
  //   The match rule for "header4" will be ignored so it will not match.
  bool treat_missing_header_as_empty = 14;
}

// Query parameter matching treats the query string of a request's :path header
// as an ampersand-separated list of keys and/or key=value elements.
// [#next-free-field: 7]
message QueryParameterMatcher {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.route.QueryParameterMatcher";

  reserved 3, 4;

  reserved "value", "regex";

  // Specifies the name of a key that must be present in the requested
  // ``path``'s query string.
  string name = 1 [(validate.rules).string = {min_len: 1 max_bytes: 1024}];

  oneof query_parameter_match_specifier {
    // Specifies whether a query parameter value should match against a string.
    type.matcher.v3.StringMatcher string_match = 5 [(validate.rules).message = {required: true}];

    // Specifies whether a query parameter should be present.
    bool present_match = 6;
  }
}

// HTTP Internal Redirect :ref:`architecture overview <arch_overview_internal_redirects>`.
// [#next-free-field: 6]
message InternalRedirectPolicy {
  // An internal redirect is not handled, unless the number of previous internal redirects that a
  // downstream request has encountered is lower than this value.
  // In the case where a downstream request is bounced among multiple routes by internal redirect,
  // the first route that hits this threshold, or does not set :ref:`internal_redirect_policy
  // <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_policy>`
  // will pass the redirect back to downstream.
  //
  // If not specified, at most one redirect will be followed.
  google.protobuf.UInt32Value max_internal_redirects = 1;

  // Defines what upstream response codes are allowed to trigger internal redirect. If unspecified,
  // only 302 will be treated as internal redirect.
  // Only 301, 302, 303, 307 and 308 are valid values. Any other codes will be ignored.
  repeated uint32 redirect_response_codes = 2 [(validate.rules).repeated = {max_items: 5}];

  // Specifies a list of predicates that are queried when an upstream response is deemed
  // to trigger an internal redirect by all other criteria. Any predicate in the list can reject
  // the redirect, causing the response to be proxied to downstream.
  // [#extension-category: envoy.internal_redirect_predicates]
  repeated core.v3.TypedExtensionConfig predicates = 3;

  // Allow internal redirect to follow a target URI with a different scheme than the value of
  // x-forwarded-proto. The default is false.
  bool allow_cross_scheme_redirect = 4;

  // Specifies a list of headers, by name, to copy from the internal redirect into the subsequent
  // request. If a header is specified here but not present in the redirect, it will be cleared in
  // the subsequent request.
  repeated string response_headers_to_copy = 5 [(validate.rules).repeated = {
    unique: true
    items {string {well_known_regex: HTTP_HEADER_NAME strict: false}}
  }];
}

// A simple wrapper for an HTTP filter config. This is intended to be used as a wrapper for the
// map value in
// :ref:`VirtualHost.typed_per_filter_config<envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`,
// :ref:`Route.typed_per_filter_config<envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>`,
// or :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config<envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`
// to add additional flags to the filter.
message FilterConfig {
  // The filter config.
  google.protobuf.Any config = 1;

  // If true, the filter is optional, meaning that if the client does
  // not support the specified filter, it may ignore the map entry rather
  // than rejecting the config.
  bool is_optional = 2;

  // If true, the filter is disabled in the route or virtual host and the ``config`` field is ignored.
  // See :ref:`route based filter chain <arch_overview_http_filters_route_based_filter_chain>`
  // for more details.
  //
  // .. note::
  //
  //   This field will take effect when the request arrive and filter chain is created for the request.
  //   If initial route is selected for the request and a filter is disabled in the initial route, then
  //   the filter will not be added to the filter chain.
  //   And if the request is mutated later and re-match to another route, the disabled filter by the
  //   initial route will not be added back to the filter chain because the filter chain is already
  //   created and it is too late to change the chain.
  //
  //   This field only make sense for the downstream HTTP filters for now.
  bool disabled = 3;
}
syntax = "proto3";

package envoy.config.route.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/config_source.proto";
import "envoy/config/route/v3/route_components.proto";

import "google/protobuf/any.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.route.v3";
option java_outer_classname = "RouteProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/route/v3;routev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP route configuration]
// * Routing :ref:`architecture overview <arch_overview_http_routing>`
// * HTTP :ref:`router filter <config_http_filters_router>`

// [#next-free-field: 18]
message RouteConfiguration {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.RouteConfiguration";

  // The name of the route configuration. For example, it might match
  // :ref:`route_config_name
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.Rds.route_config_name>` in
  // :ref:`envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.Rds`.
  string name = 1;

  // An array of virtual hosts that make up the route table.
  repeated VirtualHost virtual_hosts = 2;

  // An array of virtual hosts will be dynamically loaded via the VHDS API.
  // Both ``virtual_hosts`` and ``vhds`` fields will be used when present. ``virtual_hosts`` can be used
  // for a base routing table or for infrequently changing virtual hosts. ``vhds`` is used for
  // on-demand discovery of virtual hosts. The contents of these two fields will be merged to
  // generate a routing table for a given RouteConfiguration, with ``vhds`` derived configuration
  // taking precedence.
  Vhds vhds = 9;

  // Optionally specifies a list of HTTP headers that the connection manager
  // will consider to be internal only. If they are found on external requests they will be cleaned
  // prior to filter invocation. See :ref:`config_http_conn_man_headers_x-envoy-internal` for more
  // information.
  repeated string internal_only_headers = 3 [
    (validate.rules).repeated = {items {string {well_known_regex: HTTP_HEADER_NAME strict: false}}}
  ];

  // Specifies a list of HTTP headers that should be added to each response that
  // the connection manager encodes. Headers specified at this level are applied
  // after headers from any enclosed :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` or
  // :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`. For more information, including details on
  // header value syntax, see the documentation on :ref:`custom request headers
  // <config_http_conn_man_headers_custom_request_headers>`.
  repeated core.v3.HeaderValueOption response_headers_to_add = 4
      [(validate.rules).repeated = {max_items: 1000}];

  // Specifies a list of HTTP headers that should be removed from each response
  // that the connection manager encodes.
  repeated string response_headers_to_remove = 5 [
    (validate.rules).repeated = {items {string {well_known_regex: HTTP_HEADER_NAME strict: false}}}
  ];

  // Specifies a list of HTTP headers that should be added to each request
  // routed by the HTTP connection manager. Headers specified at this level are
  // applied after headers from any enclosed :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` or
  // :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`. For more information, including details on
  // header value syntax, see the documentation on :ref:`custom request headers
  // <config_http_conn_man_headers_custom_request_headers>`.
  repeated core.v3.HeaderValueOption request_headers_to_add = 6
      [(validate.rules).repeated = {max_items: 1000}];

  // Specifies a list of HTTP headers that should be removed from each request
  // routed by the HTTP connection manager.
  repeated string request_headers_to_remove = 8 [
    (validate.rules).repeated = {items {string {well_known_regex: HTTP_HEADER_NAME strict: false}}}
  ];

  // Headers mutations at all levels are evaluated, if specified. By default, the order is from most
  // specific (i.e. route entry level) to least specific (i.e. route configuration level). Later header
  // mutations may override earlier mutations.
  // This order can be reversed by setting this field to true. In other words, most specific level mutation
  // is evaluated last.
  //
  bool most_specific_header_mutations_wins = 10;

  // An optional boolean that specifies whether the clusters that the route
  // table refers to will be validated by the cluster manager. If set to true
  // and a route refers to a non-existent cluster, the route table will not
  // load. If set to false and a route refers to a non-existent cluster, the
  // route table will load and the router filter will return a 404 if the route
  // is selected at runtime. This setting defaults to true if the route table
  // is statically defined via the :ref:`route_config
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.route_config>`
  // option. This setting default to false if the route table is loaded dynamically via the
  // :ref:`rds
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.rds>`
  // option. Users may wish to override the default behavior in certain cases (for example when
  // using CDS with a static route table).
  google.protobuf.BoolValue validate_clusters = 7;

  // The maximum bytes of the response :ref:`direct response body
  // <envoy_v3_api_field_config.route.v3.DirectResponseAction.body>` size. If not specified the default
  // is 4096.
  //
  // .. warning::
  //
  //   Envoy currently holds the content of :ref:`direct response body
  //   <envoy_v3_api_field_config.route.v3.DirectResponseAction.body>` in memory. Be careful setting
  //   this to be larger than the default 4KB, since the allocated memory for direct response body
  //   is not subject to data plane buffering controls.
  //
  google.protobuf.UInt32Value max_direct_response_body_size_bytes = 11;

  // A list of plugins and their configurations which may be used by a
  // :ref:`cluster specifier plugin name <envoy_v3_api_field_config.route.v3.RouteAction.cluster_specifier_plugin>`
  // within the route. All ``extension.name`` fields in this list must be unique.
  repeated ClusterSpecifierPlugin cluster_specifier_plugins = 12;

  // Specify a set of default request mirroring policies which apply to all routes under its virtual hosts.
  // Note that policies are not merged, the most specific non-empty one becomes the mirror policies.
  repeated RouteAction.RequestMirrorPolicy request_mirror_policies = 13;

  // By default, port in :authority header (if any) is used in host matching.
  // With this option enabled, Envoy will ignore the port number in the :authority header (if any) when picking VirtualHost.
  // NOTE: this option will not strip the port number (if any) contained in route config
  // :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`.domains field.
  bool ignore_port_in_host_matching = 14;

  // Ignore path-parameters in path-matching.
  // Before RFC3986, URI were like(RFC1808): <scheme>://<net_loc>/<path>;<params>?<query>#<fragment>
  // Envoy by default takes ":path" as "<path>;<params>".
  // For users who want to only match path on the "<path>" portion, this option should be true.
  bool ignore_path_parameters_in_path_matching = 15;

  // This field can be used to provide RouteConfiguration level per filter config. The key should match the
  // :ref:`filter config name
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`.
  // See :ref:`Http filter route specific config <arch_overview_http_filters_per_filter_config>`
  // for details.
  // [#comment: An entry's value may be wrapped in a
  // :ref:`FilterConfig<envoy_v3_api_msg_config.route.v3.FilterConfig>`
  // message to specify additional options.]
  map<string, google.protobuf.Any> typed_per_filter_config = 16;

  // The metadata field can be used to provide additional information
  // about the route configuration. It can be used for configuration, stats, and logging.
  // The metadata should go under the filter namespace that will need it.
  // For instance, if the metadata is intended for the Router filter,
  // the filter name should be specified as ``envoy.filters.http.router``.
  core.v3.Metadata metadata = 17;
}

message Vhds {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.Vhds";

  // Configuration source specifier for VHDS.
  core.v3.ConfigSource config_source = 1 [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "//envoy/type/metadata/v3:pkg",
        "//envoy/type/tracing/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
        "@com_github_cncf_xds//xds/type/matcher/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.config.route.v3;

import "envoy/config/route/v3/route.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.route.v3";
option java_outer_classname = "ScopedRouteProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/route/v3;routev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP scoped routing configuration]
// * Routing :ref:`architecture overview <arch_overview_http_routing>`

// Specifies a routing scope, which associates a
// :ref:`Key<envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration.Key>` to a
// :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`.
// The :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` can be obtained dynamically
// via RDS (:ref:`route_configuration_name<envoy_v3_api_field_config.route.v3.ScopedRouteConfiguration.route_configuration_name>`)
// or specified inline (:ref:`route_configuration<envoy_v3_api_field_config.route.v3.ScopedRouteConfiguration.route_configuration>`).
//
// The HTTP connection manager builds up a table consisting of these Key to
// RouteConfiguration mappings, and looks up the RouteConfiguration to use per
// request according to the algorithm specified in the
// :ref:`scope_key_builder<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scope_key_builder>`
// assigned to the HttpConnectionManager.
//
// For example, with the following configurations (in YAML):
//
// HttpConnectionManager config:
//
// .. code::
//
//   ...
//   scoped_routes:
//     name: foo-scoped-routes
//     scope_key_builder:
//       fragments:
//         - header_value_extractor:
//             name: X-Route-Selector
//             element_separator: ","
//             element:
//               separator: =
//               key: vip
//
// ScopedRouteConfiguration resources (specified statically via
// :ref:`scoped_route_configurations_list<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scoped_route_configurations_list>`
// or obtained dynamically via SRDS):
//
// .. code::
//
//  (1)
//   name: route-scope1
//   route_configuration_name: route-config1
//   key:
//      fragments:
//        - string_key: 172.10.10.20
//
//  (2)
//   name: route-scope2
//   route_configuration_name: route-config2
//   key:
//     fragments:
//       - string_key: 172.20.20.30
//
// A request from a client such as:
//
// .. code::
//
//     GET / HTTP/1.1
//     Host: foo.com
//     X-Route-Selector: vip=172.10.10.20
//
// would result in the routing table defined by the ``route-config1``
// RouteConfiguration being assigned to the HTTP request/stream.
//
// [#next-free-field: 6]
message ScopedRouteConfiguration {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.ScopedRouteConfiguration";

  // Specifies a key which is matched against the output of the
  // :ref:`scope_key_builder<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scope_key_builder>`
  // specified in the HttpConnectionManager. The matching is done per HTTP
  // request and is dependent on the order of the fragments contained in the
  // Key.
  message Key {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.ScopedRouteConfiguration.Key";

    message Fragment {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.ScopedRouteConfiguration.Key.Fragment";

      oneof type {
        option (validate.required) = true;

        // A string to match against.
        string string_key = 1;
      }
    }

    // The ordered set of fragments to match against. The order must match the
    // fragments in the corresponding
    // :ref:`scope_key_builder<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scope_key_builder>`.
    repeated Fragment fragments = 1 [(validate.rules).repeated = {min_items: 1}];
  }

  // Whether the RouteConfiguration should be loaded on demand.
  bool on_demand = 4;

  // The name assigned to the routing scope.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // The resource name to use for a :ref:`envoy_v3_api_msg_service.discovery.v3.DiscoveryRequest` to an
  // RDS server to fetch the :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` associated
  // with this scope.
  string route_configuration_name = 2
      [(udpa.annotations.field_migrate).oneof_promotion = "route_config"];

  // The :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` associated with the scope.
  RouteConfiguration route_configuration = 5
      [(udpa.annotations.field_migrate).oneof_promotion = "route_config"];

  // The key to match against.
  Key key = 3 [(validate.rules).message = {required: true}];
}
syntax = "proto3";

package envoy.config.retry.omit_canary_hosts.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.retry.omit_canary_hosts.v2";
option java_outer_classname = "OmitCanaryHostsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/retry/omit_canary_hosts/v2;omit_canary_hostsv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.retry.host.omit_canary_hosts.v3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Omit Canary Hosts Predicate]
// [#extension: envoy.retry_host_predicates.omit_canary_hosts]

message OmitCanaryHostsPredicate {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.retry.omit_host_metadata.v2;

import "envoy/api/v2/core/base.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.retry.omit_host_metadata.v2";
option java_outer_classname = "OmitHostMetadataConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/retry/omit_host_metadata/v2;omit_host_metadatav2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.retry.host.omit_host_metadata.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Omit host metadata retry predicate]

// A retry host predicate that can be used to reject a host based on
// predefined metadata match criteria.
// [#extension: envoy.retry_host_predicates.omit_host_metadata]
message OmitHostMetadataConfig {
  // Retry host predicate metadata match criteria. The hosts in
  // the upstream cluster with matching metadata will be omitted while
  // attempting a retry of a failed request. The metadata should be specified
  // under the *envoy.lb* key.
  api.v2.core.Metadata metadata_match = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.retry.previous_priorities;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.retry.previous_priorities";
option java_outer_classname = "PreviousPrioritiesConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/retry/previous_priorities";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.retry.priority.previous_priorities.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Previous priorities retry selector]

// A retry host selector that attempts to spread retries between priorities, even if certain
// priorities would not normally be attempted due to higher priorities being available.
//
// As priorities get excluded, load will be distributed amongst the remaining healthy priorities
// based on the relative health of the priorities, matching how load is distributed during regular
// host selection. For example, given priority healths of {100, 50, 50}, the original load will be
// {100, 0, 0} (since P0 has capacity to handle 100% of the traffic). If P0 is excluded, the load
// changes to {0, 50, 50}, because P1 is only able to handle 50% of the traffic, causing the
// remaining to spill over to P2.
//
// Each priority attempted will be excluded until there are no healthy priorities left, at which
// point the list of attempted priorities will be reset, essentially starting from the beginning.
// For example, given three priorities P0, P1, P2 with healthy % of 100, 0 and 50 respectively, the
// following sequence of priorities would be selected (assuming update_frequency = 1):
// Attempt 1: P0 (P0 is 100% healthy)
// Attempt 2: P2 (P0 already attempted, P2 only healthy priority)
// Attempt 3: P0 (no healthy priorities, reset)
// Attempt 4: P2
//
// In the case of all upstream hosts being unhealthy, no adjustments will be made to the original
// priority load, so behavior should be identical to not using this plugin.
//
// Using this PriorityFilter requires rebuilding the priority load, which runs in O(# of
// priorities), which might incur significant overhead for clusters with many priorities.
// [#extension: envoy.retry_priorities.previous_priorities]
message PreviousPrioritiesConfig {
  // How often the priority load should be updated based on previously attempted priorities. Useful
  // to allow each priorities to receive more than one request before being excluded or to reduce
  // the number of times that the priority load has to be recomputed.
  //
  // For example, by setting this to 2, then the first two attempts (initial attempt and first
  // retry) will use the unmodified priority load. The third and fourth attempt will use priority
  // load which excludes the priorities routed to with the first two attempts, and the fifth and
  // sixth attempt will use the priority load excluding the priorities used for the first four
  // attempts.
  //
  // Must be greater than 0.
  int32 update_frequency = 1 [(validate.rules).int32 = {gt: 0}];
}
syntax = "proto3";

package envoy.config.retry.previous_hosts.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.retry.previous_hosts.v2";
option java_outer_classname = "PreviousHostsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/retry/previous_hosts/v2;previous_hostsv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.retry.host.previous_hosts.v3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Previous Hosts Predicate]
// [#extension: envoy.retry_host_predicates.previous_hosts]

message PreviousHostsPredicate {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/common/matcher/v3:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/config/route/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.tap.v3;

import "envoy/config/common/matcher/v3/matcher.proto";
import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/grpc_service.proto";
import "envoy/config/route/v3/route_components.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.tap.v3";
option java_outer_classname = "CommonProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/tap/v3;tapv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Tap common configuration]

// Tap configuration.
message TapConfig {
  // [#comment:TODO(mattklein123): Rate limiting]

  option (udpa.annotations.versioning).previous_message_type =
      "envoy.service.tap.v2alpha.TapConfig";

  // The match configuration. If the configuration matches the data source being tapped, a tap will
  // occur, with the result written to the configured output.
  // Exactly one of :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` and
  // :ref:`match_config <envoy_v3_api_field_config.tap.v3.TapConfig.match_config>` must be set. If both
  // are set, the :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` will be used.
  MatchPredicate match_config = 1
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // The match configuration. If the configuration matches the data source being tapped, a tap will
  // occur, with the result written to the configured output.
  // Exactly one of :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` and
  // :ref:`match_config <envoy_v3_api_field_config.tap.v3.TapConfig.match_config>` must be set. If both
  // are set, the :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` will be used.
  common.matcher.v3.MatchPredicate match = 4;

  // The tap output configuration. If a match configuration matches a data source being tapped,
  // a tap will occur and the data will be written to the configured output.
  OutputConfig output_config = 2 [(validate.rules).message = {required: true}];

  // [#not-implemented-hide:] Specify if Tap matching is enabled. The % of requests\connections for
  // which the tap matching is enabled. When not enabled, the request\connection will not be
  // recorded.
  //
  // .. note::
  //
  //   This field defaults to 100/:ref:`HUNDRED
  //   <envoy_v3_api_enum_type.v3.FractionalPercent.DenominatorType>`.
  core.v3.RuntimeFractionalPercent tap_enabled = 3;
}

// Tap match configuration. This is a recursive structure which allows complex nested match
// configurations to be built using various logical operators.
// [#next-free-field: 11]
message MatchPredicate {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.service.tap.v2alpha.MatchPredicate";

  // A set of match configurations used for logical operations.
  message MatchSet {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.service.tap.v2alpha.MatchPredicate.MatchSet";

    // The list of rules that make up the set.
    repeated MatchPredicate rules = 1 [(validate.rules).repeated = {min_items: 2}];
  }

  oneof rule {
    option (validate.required) = true;

    // A set that describes a logical OR. If any member of the set matches, the match configuration
    // matches.
    MatchSet or_match = 1;

    // A set that describes a logical AND. If all members of the set match, the match configuration
    // matches.
    MatchSet and_match = 2;

    // A negation match. The match configuration will match if the negated match condition matches.
    MatchPredicate not_match = 3;

    // The match configuration will always match.
    bool any_match = 4 [(validate.rules).bool = {const: true}];

    // HTTP request headers match configuration.
    HttpHeadersMatch http_request_headers_match = 5;

    // HTTP request trailers match configuration.
    HttpHeadersMatch http_request_trailers_match = 6;

    // HTTP response headers match configuration.
    HttpHeadersMatch http_response_headers_match = 7;

    // HTTP response trailers match configuration.
    HttpHeadersMatch http_response_trailers_match = 8;

    // HTTP request generic body match configuration.
    HttpGenericBodyMatch http_request_generic_body_match = 9;

    // HTTP response generic body match configuration.
    HttpGenericBodyMatch http_response_generic_body_match = 10;
  }
}

// HTTP headers match configuration.
message HttpHeadersMatch {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.service.tap.v2alpha.HttpHeadersMatch";

  // HTTP headers to match.
  repeated route.v3.HeaderMatcher headers = 1;
}

// HTTP generic body match configuration.
// List of text strings and hex strings to be located in HTTP body.
// All specified strings must be found in the HTTP body for positive match.
// The search may be limited to specified number of bytes from the body start.
//
// .. attention::
//
//   Searching for patterns in HTTP body is potentially cpu intensive. For each specified pattern, http body is scanned byte by byte to find a match.
//   If multiple patterns are specified, the process is repeated for each pattern. If location of a pattern is known, ``bytes_limit`` should be specified
//   to scan only part of the http body.
message HttpGenericBodyMatch {
  message GenericTextMatch {
    oneof rule {
      option (validate.required) = true;

      // Text string to be located in HTTP body.
      string string_match = 1 [(validate.rules).string = {min_len: 1}];

      // Sequence of bytes to be located in HTTP body.
      bytes binary_match = 2 [(validate.rules).bytes = {min_len: 1}];
    }
  }

  // Limits search to specified number of bytes - default zero (no limit - match entire captured buffer).
  uint32 bytes_limit = 1;

  // List of patterns to match.
  repeated GenericTextMatch patterns = 2 [(validate.rules).repeated = {min_items: 1}];
}

// Tap output configuration.
message OutputConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.service.tap.v2alpha.OutputConfig";

  // Output sinks for tap data. Currently a single sink is allowed in the list. Once multiple
  // sink types are supported this constraint will be relaxed.
  repeated OutputSink sinks = 1 [(validate.rules).repeated = {min_items: 1 max_items: 1}];

  // For buffered tapping, the maximum amount of received body that will be buffered prior to
  // truncation. If truncation occurs, the :ref:`truncated
  // <envoy_v3_api_field_data.tap.v3.Body.truncated>` field will be set. If not specified, the
  // default is 1KiB.
  google.protobuf.UInt32Value max_buffered_rx_bytes = 2;

  // For buffered tapping, the maximum amount of transmitted body that will be buffered prior to
  // truncation. If truncation occurs, the :ref:`truncated
  // <envoy_v3_api_field_data.tap.v3.Body.truncated>` field will be set. If not specified, the
  // default is 1KiB.
  google.protobuf.UInt32Value max_buffered_tx_bytes = 3;

  // Indicates whether taps produce a single buffered message per tap, or multiple streamed
  // messages per tap in the emitted :ref:`TraceWrapper
  // <envoy_v3_api_msg_data.tap.v3.TraceWrapper>` messages. Note that streamed tapping does not
  // mean that no buffering takes place. Buffering may be required if data is processed before a
  // match can be determined. See the HTTP tap filter :ref:`streaming
  // <config_http_filters_tap_streaming>` documentation for more information.
  bool streaming = 4;
}

// Tap output sink configuration.
// [#next-free-field: 7]
message OutputSink {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.service.tap.v2alpha.OutputSink";

  // Output format. All output is in the form of one or more :ref:`TraceWrapper
  // <envoy_v3_api_msg_data.tap.v3.TraceWrapper>` messages. This enumeration indicates
  // how those messages are written. Note that not all sinks support all output formats. See
  // individual sink documentation for more information.
  enum Format {
    // Each message will be written as JSON. Any :ref:`body <envoy_v3_api_msg_data.tap.v3.Body>`
    // data will be present in the :ref:`as_bytes
    // <envoy_v3_api_field_data.tap.v3.Body.as_bytes>` field. This means that body data will be
    // base64 encoded as per the `proto3 JSON mappings
    // <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
    JSON_BODY_AS_BYTES = 0;

    // Each message will be written as JSON. Any :ref:`body <envoy_v3_api_msg_data.tap.v3.Body>`
    // data will be present in the :ref:`as_string
    // <envoy_v3_api_field_data.tap.v3.Body.as_string>` field. This means that body data will be
    // string encoded as per the `proto3 JSON mappings
    // <https://developers.google.com/protocol-buffers/docs/proto3#json>`_. This format type is
    // useful when it is known that that body is human readable (e.g., JSON over HTTP) and the
    // user wishes to view it directly without being forced to base64 decode the body.
    JSON_BODY_AS_STRING = 1;

    // Binary proto format. Note that binary proto is not self-delimiting. If a sink writes
    // multiple binary messages without any length information the data stream will not be
    // useful. However, for certain sinks that are self-delimiting (e.g., one message per file)
    // this output format makes consumption simpler.
    PROTO_BINARY = 2;

    // Messages are written as a sequence tuples, where each tuple is the message length encoded
    // as a `protobuf 32-bit varint
    // <https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.io.coded_stream>`_
    // followed by the binary message. The messages can be read back using the language specific
    // protobuf coded stream implementation to obtain the message length and the message.
    PROTO_BINARY_LENGTH_DELIMITED = 3;

    // Text proto format.
    PROTO_TEXT = 4;
  }

  // Sink output format.
  Format format = 1 [(validate.rules).enum = {defined_only: true}];

  oneof output_sink_type {
    option (validate.required) = true;

    // Tap output will be streamed out the :http:post:`/tap` admin endpoint.
    //
    // .. attention::
    //
    //   It is only allowed to specify the streaming admin output sink if the tap is being
    //   configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
    //   been configured to receive tap configuration from some other source (e.g., static
    //   file, XDS, etc.) configuring the streaming admin output type will fail.
    StreamingAdminSink streaming_admin = 2;

    // Tap output will be written to a file per tap sink.
    FilePerTapSink file_per_tap = 3;

    // [#not-implemented-hide:]
    // GrpcService to stream data to. The format argument must be PROTO_BINARY.
    // [#comment: TODO(samflattery): remove cleanup in uber_per_filter.cc once implemented]
    StreamingGrpcSink streaming_grpc = 4;

    // Tap output will be buffered in a single block before flushing to the :http:post:`/tap` admin endpoint
    //
    // .. attention::
    //
    //   It is only allowed to specify the buffered admin output sink if the tap is being
    //   configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
    //   been configured to receive tap configuration from some other source (e.g., static
    //   file, XDS, etc.) configuring the buffered admin output type will fail.
    BufferedAdminSink buffered_admin = 5;

    // Tap output filter will be defined by an extension type
    core.v3.TypedExtensionConfig custom_sink = 6;
  }
}

// Streaming admin sink configuration.
message StreamingAdminSink {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.service.tap.v2alpha.StreamingAdminSink";
}

// BufferedAdminSink configures a tap output to collect traces without returning them until
// one of multiple criteria are satisfied.
// Similar to StreamingAdminSink, it is only allowed to specify the buffered admin output
// sink if the tap is being configured from the ``/tap`` admin endpoint.
message BufferedAdminSink {
  // Stop collecting traces when the specified number are collected.
  // If other criteria for ending collection are reached first, this value will not be used.
  uint64 max_traces = 1 [(validate.rules).uint64 = {gt: 0}];

  // Acts as a fallback to prevent the client from waiting for long periods of time.
  // After timeout has occurred, a buffer flush will be triggered, returning the traces buffered so far.
  // This may result in returning fewer traces than were requested, and in the case that no traces are
  // buffered during this time, no traces will be returned.
  // Specifying 0 for the timeout value (or not specifying a value at all) indicates an infinite timeout.
  google.protobuf.Duration timeout = 2;
}

// The file per tap sink outputs a discrete file for every tapped stream.
message FilePerTapSink {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.service.tap.v2alpha.FilePerTapSink";

  // Path prefix. The output file will be of the form <path_prefix>_<id>.pb, where <id> is an
  // identifier distinguishing the recorded trace for stream instances (the Envoy
  // connection ID, HTTP stream ID, etc.).
  string path_prefix = 1 [(validate.rules).string = {min_len: 1}];
}

// [#not-implemented-hide:] Streaming gRPC sink configuration sends the taps to an external gRPC
// server.
message StreamingGrpcSink {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.service.tap.v2alpha.StreamingGrpcSink";

  // Opaque identifier, that will be sent back to the streaming grpc server.
  string tap_id = 1;

  // The gRPC server that hosts the Tap Sink Service.
  core.v3.GrpcService grpc_service = 2 [(validate.rules).message = {required: true}];
}
Protocol buffer definitions for Envoy's bootstrap, filter, and service configuration.

Visibility should be constrained to none or `//envoy/config/bootstrap/v2` by default.
syntax = "proto3";

package envoy.config.grpc_credential.v3;

import "envoy/config/core/v3/base.proto";

import "udpa/annotations/sensitive.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.config.grpc_credential.v3";
option java_outer_classname = "FileBasedMetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/grpc_credential/v3;grpc_credentialv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Grpc Credentials File Based Metadata]
// Configuration for File Based Metadata Grpc Credentials Plugin
// [#extension: envoy.grpc_credentials.file_based_metadata]

message FileBasedMetadataConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.grpc_credential.v2alpha.FileBasedMetadataConfig";

  // Location or inline data of secret to use for authentication of the Google gRPC connection
  // this secret will be attached to a header of the gRPC connection
  core.v3.DataSource secret_data = 1 [(udpa.annotations.sensitive) = true];

  // Metadata header key to use for sending the secret data
  // if no header key is set, "authorization" header will be used
  string header_key = 2;

  // Prefix to prepend to the secret in the metadata header
  // if no prefix is set, the default is to use no prefix
  string header_prefix = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.grpc_credential.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.grpc_credential.v3";
option java_outer_classname = "AwsIamProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/grpc_credential/v3;grpc_credentialv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Grpc Credentials AWS IAM]
// Configuration for AWS IAM Grpc Credentials Plugin
// [#extension: envoy.grpc_credentials.aws_iam]

message AwsIamConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.grpc_credential.v2alpha.AwsIamConfig";

  // The `service namespace
  // <https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces>`_
  // of the Grpc endpoint.
  //
  // Example: appmesh
  string service_name = 1 [(validate.rules).string = {min_len: 1}];

  // The `region <https://docs.aws.amazon.com/general/latest/gr/rande.html>`_ hosting the Grpc
  // endpoint. If unspecified, the extension will use the value in the ``AWS_REGION`` environment
  // variable.
  //
  // Example: us-west-2
  string region = 2;
}
syntax = "proto3";

package envoy.config.grpc_credential.v2alpha;

import "envoy/api/v2/core/base.proto";

import "udpa/annotations/sensitive.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.grpc_credential.v2alpha";
option java_outer_classname = "FileBasedMetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/grpc_credential/v2alpha";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Grpc Credentials File Based Metadata]
// Configuration for File Based Metadata Grpc Credentials Plugin
// [#extension: envoy.grpc_credentials.file_based_metadata]

message FileBasedMetadataConfig {
  // Location or inline data of secret to use for authentication of the Google gRPC connection
  // this secret will be attached to a header of the gRPC connection
  api.v2.core.DataSource secret_data = 1 [(udpa.annotations.sensitive) = true];

  // Metadata header key to use for sending the secret data
  // if no header key is set, "authorization" header will be used
  string header_key = 2;

  // Prefix to prepend to the secret in the metadata header
  // if no prefix is set, the default is to use no prefix
  string header_prefix = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.grpc_credential.v2alpha;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.grpc_credential.v2alpha";
option java_outer_classname = "AwsIamProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/grpc_credential/v2alpha";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Grpc Credentials AWS IAM]
// Configuration for AWS IAM Grpc Credentials Plugin
// [#extension: envoy.grpc_credentials.aws_iam]

message AwsIamConfig {
  // The `service namespace
  // <https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces>`_
  // of the Grpc endpoint.
  //
  // Example: appmesh
  string service_name = 1 [(validate.rules).string = {min_bytes: 1}];

  // The `region <https://docs.aws.amazon.com/general/latest/gr/rande.html>`_ hosting the Grpc
  // endpoint. If unspecified, the extension will use the value in the ``AWS_REGION`` environment
  // variable.
  //
  // Example: us-west-2
  string region = 2;
}
syntax = "proto3";

package envoy.config.ratelimit.v2;

import "envoy/api/v2/core/grpc_service.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.ratelimit.v2";
option java_outer_classname = "RlsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/ratelimit/v2;ratelimitv2";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Rate limit service]

// Rate limit :ref:`configuration overview <config_rate_limit_service>`.
message RateLimitServiceConfig {
  reserved 1, 3;

  // Specifies the gRPC service that hosts the rate limit service. The client
  // will connect to this cluster when it needs to make rate limit service
  // requests.
  api.v2.core.GrpcService grpc_service = 2 [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.ratelimit.v3;

import "envoy/config/core/v3/config_source.proto";
import "envoy/config/core/v3/grpc_service.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.ratelimit.v3";
option java_outer_classname = "RlsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/ratelimit/v3;ratelimitv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Rate limit service]

// Rate limit :ref:`configuration overview <config_rate_limit_service>`.
message RateLimitServiceConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.ratelimit.v2.RateLimitServiceConfig";

  reserved 1, 3;

  // Specifies the gRPC service that hosts the rate limit service. The client
  // will connect to this cluster when it needs to make rate limit service
  // requests.
  core.v3.GrpcService grpc_service = 2 [(validate.rules).message = {required: true}];

  // API version for rate limit transport protocol. This describes the rate limit gRPC endpoint and
  // version of messages used on the wire.
  core.v3.ApiVersion transport_api_version = 4 [(validate.rules).enum = {defined_only: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.common.mutation_rules.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/type/matcher/v3/regex.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.common.mutation_rules.v3";
option java_outer_classname = "MutationRulesProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/common/mutation_rules/v3;mutation_rulesv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Header mutation rules]

// The HeaderMutationRules structure specifies what headers may be
// manipulated by a processing filter. This set of rules makes it
// possible to control which modifications a filter may make.
//
// By default, an external processing server may add, modify, or remove
// any header except for an "Envoy internal" header (which is typically
// denoted by an x-envoy prefix) or specific headers that may affect
// further filter processing:
//
// * ``host``
// * ``:authority``
// * ``:scheme``
// * ``:method``
//
// Every attempt to add, change, append, or remove a header will be
// tested against the rules here. Disallowed header mutations will be
// ignored unless ``disallow_is_error`` is set to true.
//
// Attempts to remove headers are further constrained -- regardless of the
// settings, system-defined headers (that start with ``:``) and the ``host``
// header may never be removed.
//
// In addition, a counter will be incremented whenever a mutation is
// rejected. In the ext_proc filter, that counter is named
// ``rejected_header_mutations``.
// [#next-free-field: 8]
message HeaderMutationRules {
  // By default, certain headers that could affect processing of subsequent
  // filters or request routing cannot be modified. These headers are
  // ``host``, ``:authority``, ``:scheme``, and ``:method``. Setting this parameter
  // to true allows these headers to be modified as well.
  google.protobuf.BoolValue allow_all_routing = 1;

  // If true, allow modification of envoy internal headers. By default, these
  // start with ``x-envoy`` but this may be overridden in the ``Bootstrap``
  // configuration using the
  // :ref:`header_prefix <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.header_prefix>`
  // field. Default is false.
  google.protobuf.BoolValue allow_envoy = 2;

  // If true, prevent modification of any system header, defined as a header
  // that starts with a ``:`` character, regardless of any other settings.
  // A processing server may still override the ``:status`` of an HTTP response
  // using an ``ImmediateResponse`` message. Default is false.
  google.protobuf.BoolValue disallow_system = 3;

  // If true, prevent modifications of all header values, regardless of any
  // other settings. A processing server may still override the ``:status``
  // of an HTTP response using an ``ImmediateResponse`` message. Default is false.
  google.protobuf.BoolValue disallow_all = 4;

  // If set, specifically allow any header that matches this regular
  // expression. This overrides all other settings except for
  // ``disallow_expression``.
  type.matcher.v3.RegexMatcher allow_expression = 5;

  // If set, specifically disallow any header that matches this regular
  // expression regardless of any other settings.
  type.matcher.v3.RegexMatcher disallow_expression = 6;

  // If true, and if the rules in this list cause a header mutation to be
  // disallowed, then the filter using this configuration will terminate the
  // request with a 500 error. In addition, regardless of the setting of this
  // parameter, any attempt to set, add, or modify a disallowed header will
  // cause the ``rejected_header_mutations`` counter to be incremented.
  // Default is false.
  google.protobuf.BoolValue disallow_is_error = 7;
}

// The HeaderMutation structure specifies an action that may be taken on HTTP
// headers.
message HeaderMutation {
  oneof action {
    option (validate.required) = true;

    // Remove the specified header if it exists.
    string remove = 1
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];

    // Append new header by the specified HeaderValueOption.
    core.v3.HeaderValueOption append = 2;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.common.dynamic_forward_proxy.v2alpha;

import "envoy/api/v2/cluster.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.common.dynamic_forward_proxy.v2alpha";
option java_outer_classname = "DnsCacheProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/common/dynamic_forward_proxy/v2alpha";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.common.dynamic_forward_proxy.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Dynamic forward proxy common configuration]

// Configuration for the dynamic forward proxy DNS cache. See the :ref:`architecture overview
// <arch_overview_http_dynamic_forward_proxy>` for more information.
// [#next-free-field: 7]
message DnsCacheConfig {
  // The name of the cache. Multiple named caches allow independent dynamic forward proxy
  // configurations to operate within a single Envoy process using different configurations. All
  // configurations with the same name *must* otherwise have the same settings when referenced
  // from different configuration components. Configuration will fail to load if this is not
  // the case.
  string name = 1 [(validate.rules).string = {min_bytes: 1}];

  // The DNS lookup family to use during resolution.
  //
  // [#comment:TODO(mattklein123): Figure out how to support IPv4/IPv6 "happy eyeballs" mode. The
  // way this might work is a new lookup family which returns both IPv4 and IPv6 addresses, and
  // then configures a host to have a primary and fall back address. With this, we could very
  // likely build a "happy eyeballs" connection pool which would race the primary / fall back
  // address and return the one that wins. This same method could potentially also be used for
  // QUIC to TCP fall back.]
  api.v2.Cluster.DnsLookupFamily dns_lookup_family = 2
      [(validate.rules).enum = {defined_only: true}];

  // The DNS refresh rate for currently cached DNS hosts. If not specified defaults to 60s.
  //
  // .. note:
  //
  //  The returned DNS TTL is not currently used to alter the refresh rate. This feature will be
  //  added in a future change.
  //
  // .. note:
  //
  // The refresh rate is rounded to the closest millisecond, and must be at least 1ms.
  google.protobuf.Duration dns_refresh_rate = 3
      [(validate.rules).duration = {gte {nanos: 1000000}}];

  // The TTL for hosts that are unused. Hosts that have not been used in the configured time
  // interval will be purged. If not specified defaults to 5m.
  //
  // .. note:
  //
  //   The TTL is only checked at the time of DNS refresh, as specified by *dns_refresh_rate*. This
  //   means that if the configured TTL is shorter than the refresh rate the host may not be removed
  //   immediately.
  //
  //  .. note:
  //
  //   The TTL has no relation to DNS TTL and is only used to control Envoy's resource usage.
  google.protobuf.Duration host_ttl = 4 [(validate.rules).duration = {gt {}}];

  // The maximum number of hosts that the cache will hold. If not specified defaults to 1024.
  //
  // .. note:
  //
  //   The implementation is approximate and enforced independently on each worker thread, thus
  //   it is possible for the maximum hosts in the cache to go slightly above the configured
  //   value depending on timing. This is similar to how other circuit breakers work.
  google.protobuf.UInt32Value max_hosts = 5 [(validate.rules).uint32 = {gt: 0}];

  // If the DNS failure refresh rate is specified,
  // this is used as the cache's DNS refresh rate when DNS requests are failing. If this setting is
  // not specified, the failure refresh rate defaults to the dns_refresh_rate.
  api.v2.Cluster.RefreshRate dns_failure_refresh_rate = 6;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/service/tap/v2alpha:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.common.tap.v2alpha;

import "envoy/service/tap/v2alpha/common.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.common.tap.v2alpha";
option java_outer_classname = "CommonProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/common/tap/v2alpha";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.common.tap.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Common tap extension configuration]

// Common configuration for all tap extensions.
message CommonExtensionConfig {
  oneof config_type {
    option (validate.required) = true;

    // If specified, the tap filter will be configured via an admin handler.
    AdminConfig admin_config = 1;

    // If specified, the tap filter will be configured via a static configuration that cannot be
    // changed.
    service.tap.v2alpha.TapConfig static_config = 2;
  }
}

// Configuration for the admin handler. See :ref:`here <config_http_filters_tap_admin_handler>` for
// more information.
message AdminConfig {
  // Opaque configuration ID. When requests are made to the admin handler, the passed opaque ID is
  // matched to the configured filter opaque ID to determine which filter to configure.
  string config_id = 1 [(validate.rules).string = {min_bytes: 1}];
}
syntax = "proto3";

package envoy.config.common.matcher.v3;

import "envoy/config/core/v3/extension.proto";
import "envoy/config/route/v3/route_components.proto";
import "envoy/type/matcher/v3/string.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.common.matcher.v3";
option java_outer_classname = "MatcherProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/common/matcher/v3;matcherv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Unified Matcher API]

// A matcher, which may traverse a matching tree in order to result in a match action.
// During matching, the tree will be traversed until a match is found, or if no match
// is found the action specified by the most specific on_no_match will be evaluated.
// As an on_no_match might result in another matching tree being evaluated, this process
// might repeat several times until the final OnMatch (or no match) is decided.
//
// .. note::
//   Please use the syntactically equivalent :ref:`matching API <envoy_v3_api_msg_.xds.type.matcher.v3.Matcher>`
message Matcher {
  // What to do if a match is successful.
  message OnMatch {
    oneof on_match {
      option (validate.required) = true;

      // Nested matcher to evaluate.
      // If the nested matcher does not match and does not specify
      // on_no_match, then this matcher is considered not to have
      // matched, even if a predicate at this level or above returned
      // true.
      Matcher matcher = 1;

      // Protocol-specific action to take.
      core.v3.TypedExtensionConfig action = 2;
    }
  }

  // A linear list of field matchers.
  // The field matchers are evaluated in order, and the first match
  // wins.
  message MatcherList {
    // Predicate to determine if a match is successful.
    message Predicate {
      // Predicate for a single input field.
      message SinglePredicate {
        // Protocol-specific specification of input field to match on.
        // [#extension-category: envoy.matching.common_inputs]
        core.v3.TypedExtensionConfig input = 1 [(validate.rules).message = {required: true}];

        oneof matcher {
          option (validate.required) = true;

          // Built-in string matcher.
          type.matcher.v3.StringMatcher value_match = 2;

          // Extension for custom matching logic.
          // [#extension-category: envoy.matching.input_matchers]
          core.v3.TypedExtensionConfig custom_match = 3;
        }
      }

      // A list of two or more matchers. Used to allow using a list within a oneof.
      message PredicateList {
        repeated Predicate predicate = 1 [(validate.rules).repeated = {min_items: 2}];
      }

      oneof match_type {
        option (validate.required) = true;

        // A single predicate to evaluate.
        SinglePredicate single_predicate = 1;

        // A list of predicates to be OR-ed together.
        PredicateList or_matcher = 2;

        // A list of predicates to be AND-ed together.
        PredicateList and_matcher = 3;

        // The invert of a predicate
        Predicate not_matcher = 4;
      }
    }

    // An individual matcher.
    message FieldMatcher {
      // Determines if the match succeeds.
      Predicate predicate = 1 [(validate.rules).message = {required: true}];

      // What to do if the match succeeds.
      OnMatch on_match = 2 [(validate.rules).message = {required: true}];
    }

    // A list of matchers. First match wins.
    repeated FieldMatcher matchers = 1 [(validate.rules).repeated = {min_items: 1}];
  }

  message MatcherTree {
    // A map of configured matchers. Used to allow using a map within a oneof.
    message MatchMap {
      map<string, OnMatch> map = 1 [(validate.rules).map = {min_pairs: 1}];
    }

    // Protocol-specific specification of input field to match on.
    core.v3.TypedExtensionConfig input = 1 [(validate.rules).message = {required: true}];

    // Exact or prefix match maps in which to look up the input value.
    // If the lookup succeeds, the match is considered successful, and
    // the corresponding OnMatch is used.
    oneof tree_type {
      option (validate.required) = true;

      MatchMap exact_match_map = 2;

      // Longest matching prefix wins.
      MatchMap prefix_match_map = 3;

      // Extension for custom matching logic.
      core.v3.TypedExtensionConfig custom_match = 4;
    }
  }

  oneof matcher_type {
    option (validate.required) = true;

    // A linear list of matchers to evaluate.
    MatcherList matcher_list = 1;

    // A match tree to evaluate.
    MatcherTree matcher_tree = 2;
  }

  // Optional OnMatch to use if the matcher failed.
  // If specified, the OnMatch is used, and the matcher is considered
  // to have matched.
  // If not specified, the matcher is considered not to have matched.
  OnMatch on_no_match = 3;
}

// Match configuration. This is a recursive structure which allows complex nested match
// configurations to be built using various logical operators.
// [#next-free-field: 11]
message MatchPredicate {
  // A set of match configurations used for logical operations.
  message MatchSet {
    // The list of rules that make up the set.
    repeated MatchPredicate rules = 1 [(validate.rules).repeated = {min_items: 2}];
  }

  oneof rule {
    option (validate.required) = true;

    // A set that describes a logical OR. If any member of the set matches, the match configuration
    // matches.
    MatchSet or_match = 1;

    // A set that describes a logical AND. If all members of the set match, the match configuration
    // matches.
    MatchSet and_match = 2;

    // A negation match. The match configuration will match if the negated match condition matches.
    MatchPredicate not_match = 3;

    // The match configuration will always match.
    bool any_match = 4 [(validate.rules).bool = {const: true}];

    // HTTP request headers match configuration.
    HttpHeadersMatch http_request_headers_match = 5;

    // HTTP request trailers match configuration.
    HttpHeadersMatch http_request_trailers_match = 6;

    // HTTP response headers match configuration.
    HttpHeadersMatch http_response_headers_match = 7;

    // HTTP response trailers match configuration.
    HttpHeadersMatch http_response_trailers_match = 8;

    // HTTP request generic body match configuration.
    HttpGenericBodyMatch http_request_generic_body_match = 9;

    // HTTP response generic body match configuration.
    HttpGenericBodyMatch http_response_generic_body_match = 10;
  }
}

// HTTP headers match configuration.
message HttpHeadersMatch {
  // HTTP headers to match.
  repeated route.v3.HeaderMatcher headers = 1;
}

// HTTP generic body match configuration.
// List of text strings and hex strings to be located in HTTP body.
// All specified strings must be found in the HTTP body for positive match.
// The search may be limited to specified number of bytes from the body start.
//
// .. attention::
//
//   Searching for patterns in HTTP body is potentially cpu intensive. For each specified pattern, http body is scanned byte by byte to find a match.
//   If multiple patterns are specified, the process is repeated for each pattern. If location of a pattern is known, ``bytes_limit`` should be specified
//   to scan only part of the http body.
message HttpGenericBodyMatch {
  message GenericTextMatch {
    oneof rule {
      option (validate.required) = true;

      // Text string to be located in HTTP body.
      string string_match = 1 [(validate.rules).string = {min_len: 1}];

      // Sequence of bytes to be located in HTTP body.
      bytes binary_match = 2 [(validate.rules).bytes = {min_len: 1}];
    }
  }

  // Limits search to specified number of bytes - default zero (no limit - match entire captured buffer).
  uint32 bytes_limit = 1;

  // List of patterns to match.
  repeated GenericTextMatch patterns = 2 [(validate.rules).repeated = {min_items: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/config/route/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.config.common.key_value.v3;

import "envoy/config/core/v3/extension.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.common.key_value.v3";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/common/key_value/v3;key_valuev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Key/value store storage plugin]

// This shared configuration for Envoy key value stores.
message KeyValueStoreConfig {
  option (xds.annotations.v3.message_status).work_in_progress = true;

  // [#extension-category: envoy.common.key_value]
  core.v3.TypedExtensionConfig config = 1 [(validate.rules).message = {required: true}];
}
syntax = "proto3";

package envoy.config.endpoint.v3;

import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/base.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.endpoint.v3";
option java_outer_classname = "LoadReportProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3;endpointv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Load Report]

// These are stats Envoy reports to the management server at a frequency defined by
// :ref:`LoadStatsResponse.load_reporting_interval<envoy_v3_api_field_service.load_stats.v3.LoadStatsResponse.load_reporting_interval>`.
// Stats per upstream region/zone and optionally per subzone.
// [#next-free-field: 9]
message UpstreamLocalityStats {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.endpoint.UpstreamLocalityStats";

  // Name of zone, region and optionally endpoint group these metrics were
  // collected from. Zone and region names could be empty if unknown.
  core.v3.Locality locality = 1;

  // The total number of requests successfully completed by the endpoints in the
  // locality.
  uint64 total_successful_requests = 2;

  // The total number of unfinished requests
  uint64 total_requests_in_progress = 3;

  // The total number of requests that failed due to errors at the endpoint,
  // aggregated over all endpoints in the locality.
  uint64 total_error_requests = 4;

  // The total number of requests that were issued by this Envoy since
  // the last report. This information is aggregated over all the
  // upstream endpoints in the locality.
  uint64 total_issued_requests = 8;

  // Stats for multi-dimensional load balancing.
  repeated EndpointLoadMetricStats load_metric_stats = 5;

  // Endpoint granularity stats information for this locality. This information
  // is populated if the Server requests it by setting
  // :ref:`LoadStatsResponse.report_endpoint_granularity<envoy_v3_api_field_service.load_stats.v3.LoadStatsResponse.report_endpoint_granularity>`.
  repeated UpstreamEndpointStats upstream_endpoint_stats = 7;

  // [#not-implemented-hide:] The priority of the endpoint group these metrics
  // were collected from.
  uint32 priority = 6;
}

// [#next-free-field: 8]
message UpstreamEndpointStats {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.endpoint.UpstreamEndpointStats";

  // Upstream host address.
  core.v3.Address address = 1;

  // Opaque and implementation dependent metadata of the
  // endpoint. Envoy will pass this directly to the management server.
  google.protobuf.Struct metadata = 6;

  // The total number of requests successfully completed by the endpoints in the
  // locality. These include non-5xx responses for HTTP, where errors
  // originate at the client and the endpoint responded successfully. For gRPC,
  // the grpc-status values are those not covered by total_error_requests below.
  uint64 total_successful_requests = 2;

  // The total number of unfinished requests for this endpoint.
  uint64 total_requests_in_progress = 3;

  // The total number of requests that failed due to errors at the endpoint.
  // For HTTP these are responses with 5xx status codes and for gRPC the
  // grpc-status values:
  //
  //   - DeadlineExceeded
  //   - Unimplemented
  //   - Internal
  //   - Unavailable
  //   - Unknown
  //   - DataLoss
  uint64 total_error_requests = 4;

  // The total number of requests that were issued to this endpoint
  // since the last report. A single TCP connection, HTTP or gRPC
  // request or stream is counted as one request.
  uint64 total_issued_requests = 7;

  // Stats for multi-dimensional load balancing.
  repeated EndpointLoadMetricStats load_metric_stats = 5;
}

message EndpointLoadMetricStats {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.endpoint.EndpointLoadMetricStats";

  // Name of the metric; may be empty.
  string metric_name = 1;

  // Number of calls that finished and included this metric.
  uint64 num_requests_finished_with_metric = 2;

  // Sum of metric values across all calls that finished with this metric for
  // load_reporting_interval.
  double total_metric_value = 3;
}

// Per cluster load stats. Envoy reports these stats a management server in a
// :ref:`LoadStatsRequest<envoy_v3_api_msg_service.load_stats.v3.LoadStatsRequest>`
// Next ID: 7
// [#next-free-field: 7]
message ClusterStats {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.endpoint.ClusterStats";

  message DroppedRequests {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.endpoint.ClusterStats.DroppedRequests";

    // Identifier for the policy specifying the drop.
    string category = 1 [(validate.rules).string = {min_len: 1}];

    // Total number of deliberately dropped requests for the category.
    uint64 dropped_count = 2;
  }

  // The name of the cluster.
  string cluster_name = 1 [(validate.rules).string = {min_len: 1}];

  // The eds_cluster_config service_name of the cluster.
  // It's possible that two clusters send the same service_name to EDS,
  // in that case, the management server is supposed to do aggregation on the load reports.
  string cluster_service_name = 6;

  // Need at least one.
  repeated UpstreamLocalityStats upstream_locality_stats = 2
      [(validate.rules).repeated = {min_items: 1}];

  // Cluster-level stats such as total_successful_requests may be computed by
  // summing upstream_locality_stats. In addition, below there are additional
  // cluster-wide stats.
  //
  // The total number of dropped requests. This covers requests
  // deliberately dropped by the drop_overload policy and circuit breaking.
  uint64 total_dropped_requests = 3;

  // Information about deliberately dropped requests for each category specified
  // in the DropOverload policy.
  repeated DroppedRequests dropped_requests = 5;

  // Period over which the actual load report occurred. This will be guaranteed to include every
  // request reported. Due to system load and delays between the ``LoadStatsRequest`` sent from Envoy
  // and the ``LoadStatsResponse`` message sent from the management server, this may be longer than
  // the requested load reporting interval in the ``LoadStatsResponse``.
  google.protobuf.Duration load_report_interval = 4;
}
syntax = "proto3";

package envoy.config.endpoint.v3;

import "envoy/config/endpoint/v3/endpoint_components.proto";
import "envoy/type/v3/percent.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.endpoint.v3";
option java_outer_classname = "EndpointProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3;endpointv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Endpoint configuration]
// Endpoint discovery :ref:`architecture overview <arch_overview_service_discovery_types_eds>`

// Each route from RDS will map to a single cluster or traffic split across
// clusters using weights expressed in the RDS WeightedCluster.
//
// With EDS, each cluster is treated independently from a LB perspective, with
// LB taking place between the Localities within a cluster and at a finer
// granularity between the hosts within a locality. The percentage of traffic
// for each endpoint is determined by both its load_balancing_weight, and the
// load_balancing_weight of its locality. First, a locality will be selected,
// then an endpoint within that locality will be chose based on its weight.
// [#next-free-field: 6]
message ClusterLoadAssignment {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.ClusterLoadAssignment";

  // Load balancing policy settings.
  // [#next-free-field: 7]
  message Policy {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.ClusterLoadAssignment.Policy";

    message DropOverload {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.api.v2.ClusterLoadAssignment.Policy.DropOverload";

      // Identifier for the policy specifying the drop.
      string category = 1 [(validate.rules).string = {min_len: 1}];

      // Percentage of traffic that should be dropped for the category.
      type.v3.FractionalPercent drop_percentage = 2;
    }

    reserved 1, 5;

    reserved "disable_overprovisioning";

    // Action to trim the overall incoming traffic to protect the upstream
    // hosts. This action allows protection in case the hosts are unable to
    // recover from an outage, or unable to autoscale or unable to handle
    // incoming traffic volume for any reason.
    //
    // At the client each category is applied one after the other to generate
    // the 'actual' drop percentage on all outgoing traffic. For example:
    //
    // .. code-block:: json
    //
    //  { "drop_overloads": [
    //      { "category": "throttle", "drop_percentage": 60 }
    //      { "category": "lb", "drop_percentage": 50 }
    //  ]}
    //
    // The actual drop percentages applied to the traffic at the clients will be
    //    "throttle"_drop = 60%
    //    "lb"_drop = 20%  // 50% of the remaining 'actual' load, which is 40%.
    //    actual_outgoing_load = 20% // remaining after applying all categories.
    //
    // Envoy supports only one element and will NACK if more than one element is present.
    // Other xDS-capable data planes will not necessarily have this limitation.
    repeated DropOverload drop_overloads = 2;

    // Priority levels and localities are considered overprovisioned with this
    // factor (in percentage). This means that we don't consider a priority
    // level or locality unhealthy until the fraction of healthy hosts
    // multiplied by the overprovisioning factor drops below 100.
    // With the default value 140(1.4), Envoy doesn't consider a priority level
    // or a locality unhealthy until their percentage of healthy hosts drops
    // below 72%. For example:
    //
    // .. code-block:: json
    //
    //  { "overprovisioning_factor": 100 }
    //
    // Read more at :ref:`priority levels <arch_overview_load_balancing_priority_levels>` and
    // :ref:`localities <arch_overview_load_balancing_locality_weighted_lb>`.
    google.protobuf.UInt32Value overprovisioning_factor = 3 [(validate.rules).uint32 = {gt: 0}];

    // The max time until which the endpoints from this assignment can be used.
    // If no new assignments are received before this time expires the endpoints
    // are considered stale and should be marked unhealthy.
    // Defaults to 0 which means endpoints never go stale.
    google.protobuf.Duration endpoint_stale_after = 4 [(validate.rules).duration = {gt {}}];

    // If true, use the :ref:`load balancing weight
    // <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.load_balancing_weight>` of healthy and unhealthy
    // hosts to determine the health of the priority level. If false, use the number of healthy and unhealthy hosts
    // to determine the health of the priority level, or in other words assume each host has a weight of 1 for
    // this calculation.
    //
    // Note: this is not currently implemented for
    // :ref:`locality weighted load balancing <arch_overview_load_balancing_locality_weighted_lb>`.
    bool weighted_priority_health = 6;
  }

  // Name of the cluster. This will be the :ref:`service_name
  // <envoy_v3_api_field_config.cluster.v3.Cluster.EdsClusterConfig.service_name>` value if specified
  // in the cluster :ref:`EdsClusterConfig
  // <envoy_v3_api_msg_config.cluster.v3.Cluster.EdsClusterConfig>`.
  string cluster_name = 1 [(validate.rules).string = {min_len: 1}];

  // List of endpoints to load balance to.
  repeated LocalityLbEndpoints endpoints = 2;

  // Map of named endpoints that can be referenced in LocalityLbEndpoints.
  // [#not-implemented-hide:]
  map<string, Endpoint> named_endpoints = 5;

  // Load balancing policy settings.
  Policy policy = 4;
}
syntax = "proto3";

package envoy.config.endpoint.v3;

import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/config_source.proto";
import "envoy/config/core/v3/health_check.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.endpoint.v3";
option java_outer_classname = "EndpointComponentsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3;endpointv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Endpoints]

// Upstream host identifier.
message Endpoint {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.endpoint.Endpoint";

  // The optional health check configuration.
  message HealthCheckConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.endpoint.Endpoint.HealthCheckConfig";

    // Optional alternative health check port value.
    //
    // By default the health check address port of an upstream host is the same
    // as the host's serving address port. This provides an alternative health
    // check port. Setting this with a non-zero value allows an upstream host
    // to have different health check address port.
    uint32 port_value = 1 [(validate.rules).uint32 = {lte: 65535}];

    // By default, the host header for L7 health checks is controlled by cluster level configuration
    // (see: :ref:`host <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.host>` and
    // :ref:`authority <envoy_v3_api_field_config.core.v3.HealthCheck.GrpcHealthCheck.authority>`). Setting this
    // to a non-empty value allows overriding the cluster level configuration for a specific
    // endpoint.
    string hostname = 2;

    // Optional alternative health check host address.
    //
    // .. attention::
    //
    //   The form of the health check host address is expected to be a direct IP address.
    core.v3.Address address = 3;

    // Optional flag to control if perform active health check for this endpoint.
    // Active health check is enabled by default if there is a health checker.
    bool disable_active_health_check = 4;
  }

  message AdditionalAddress {
    // Additional address that is associated with the endpoint.
    core.v3.Address address = 1;
  }

  // The upstream host address.
  //
  // .. attention::
  //
  //   The form of host address depends on the given cluster type. For STATIC or EDS,
  //   it is expected to be a direct IP address (or something resolvable by the
  //   specified :ref:`resolver <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>`
  //   in the Address). For LOGICAL or STRICT DNS, it is expected to be hostname,
  //   and will be resolved via DNS.
  core.v3.Address address = 1;

  // The optional health check configuration is used as configuration for the
  // health checker to contact the health checked host.
  //
  // .. attention::
  //
  //   This takes into effect only for upstream clusters with
  //   :ref:`active health checking <arch_overview_health_checking>` enabled.
  HealthCheckConfig health_check_config = 2;

  // The hostname associated with this endpoint. This hostname is not used for routing or address
  // resolution. If provided, it will be associated with the endpoint, and can be used for features
  // that require a hostname, like
  // :ref:`auto_host_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite>`.
  string hostname = 3;

  // An ordered list of addresses that together with ``address`` comprise the
  // list of addresses for an endpoint. The address given in the ``address`` is
  // prepended to this list. It is assumed that the list must already be
  // sorted by preference order of the addresses. This will only be supported
  // for STATIC and EDS clusters.
  repeated AdditionalAddress additional_addresses = 4;
}

// An Endpoint that Envoy can route traffic to.
// [#next-free-field: 6]
message LbEndpoint {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.endpoint.LbEndpoint";

  // Upstream host identifier or a named reference.
  oneof host_identifier {
    Endpoint endpoint = 1;

    // [#not-implemented-hide:]
    string endpoint_name = 5;
  }

  // Optional health status when known and supplied by EDS server.
  core.v3.HealthStatus health_status = 2;

  // The endpoint metadata specifies values that may be used by the load
  // balancer to select endpoints in a cluster for a given request. The filter
  // name should be specified as ``envoy.lb``. An example boolean key-value pair
  // is ``canary``, providing the optional canary status of the upstream host.
  // This may be matched against in a route's
  // :ref:`RouteAction <envoy_v3_api_msg_config.route.v3.RouteAction>` metadata_match field
  // to subset the endpoints considered in cluster load balancing.
  core.v3.Metadata metadata = 3;

  // The optional load balancing weight of the upstream host; at least 1.
  // Envoy uses the load balancing weight in some of the built in load
  // balancers. The load balancing weight for an endpoint is divided by the sum
  // of the weights of all endpoints in the endpoint's locality to produce a
  // percentage of traffic for the endpoint. This percentage is then further
  // weighted by the endpoint's locality's load balancing weight from
  // LocalityLbEndpoints. If unspecified, will be treated as 1. The sum
  // of the weights of all endpoints in the endpoint's locality must not
  // exceed uint32_t maximal value (4294967295).
  google.protobuf.UInt32Value load_balancing_weight = 4 [(validate.rules).uint32 = {gte: 1}];
}

// [#not-implemented-hide:]
// A configuration for a LEDS collection.
message LedsClusterLocalityConfig {
  // Configuration for the source of LEDS updates for a Locality.
  core.v3.ConfigSource leds_config = 1;

  // The xDS transport protocol glob collection resource name.
  // The service is only supported in delta xDS (incremental) mode.
  string leds_collection_name = 2;
}

// A group of endpoints belonging to a Locality.
// One can have multiple LocalityLbEndpoints for a locality, but only if
// they have different priorities.
// [#next-free-field: 9]
message LocalityLbEndpoints {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.endpoint.LocalityLbEndpoints";

  // [#not-implemented-hide:]
  // A list of endpoints of a specific locality.
  message LbEndpointList {
    repeated LbEndpoint lb_endpoints = 1;
  }

  // Identifies location of where the upstream hosts run.
  core.v3.Locality locality = 1;

  // The group of endpoints belonging to the locality specified.
  // [#comment:TODO(adisuissa): Once LEDS is implemented this field needs to be
  // deprecated and replaced by ``load_balancer_endpoints``.]
  repeated LbEndpoint lb_endpoints = 2;

  // [#not-implemented-hide:]
  oneof lb_config {
    // The group of endpoints belonging to the locality.
    // [#comment:TODO(adisuissa): Once LEDS is implemented the ``lb_endpoints`` field
    // needs to be deprecated.]
    LbEndpointList load_balancer_endpoints = 7;

    // LEDS Configuration for the current locality.
    LedsClusterLocalityConfig leds_cluster_locality_config = 8;
  }

  // Optional: Per priority/region/zone/sub_zone weight; at least 1. The load
  // balancing weight for a locality is divided by the sum of the weights of all
  // localities  at the same priority level to produce the effective percentage
  // of traffic for the locality. The sum of the weights of all localities at
  // the same priority level must not exceed uint32_t maximal value (4294967295).
  //
  // Locality weights are only considered when :ref:`locality weighted load
  // balancing <arch_overview_load_balancing_locality_weighted_lb>` is
  // configured. These weights are ignored otherwise. If no weights are
  // specified when locality weighted load balancing is enabled, the locality is
  // assigned no load.
  google.protobuf.UInt32Value load_balancing_weight = 3 [(validate.rules).uint32 = {gte: 1}];

  // Optional: the priority for this LocalityLbEndpoints. If unspecified this will
  // default to the highest priority (0).
  //
  // Under usual circumstances, Envoy will only select endpoints for the highest
  // priority (0). In the event that enough endpoints for a particular priority are
  // unavailable/unhealthy, Envoy will fail over to selecting endpoints for the
  // next highest priority group. Read more at :ref:`priority levels <arch_overview_load_balancing_priority_levels>`.
  //
  // Priorities should range from 0 (highest) to N (lowest) without skipping.
  uint32 priority = 5 [(validate.rules).uint32 = {lte: 128}];

  // Optional: Per locality proximity value which indicates how close this
  // locality is from the source locality. This value only provides ordering
  // information (lower the value, closer it is to the source locality).
  // This will be consumed by load balancing schemes that need proximity order
  // to determine where to route the requests.
  // [#not-implemented-hide:]
  google.protobuf.UInt32Value proximity = 6;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.accesslog.v2;

import "google/protobuf/struct.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.accesslog.v2";
option java_outer_classname = "FileProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v2;accesslogv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.access_loggers.file.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: File access log]
// [#extension: envoy.access_loggers.file]

// Custom configuration for an :ref:`AccessLog <envoy_api_msg_config.filter.accesslog.v2.AccessLog>`
// that writes log entries directly to a file. Configures the built-in *envoy.access_loggers.file*
// AccessLog.
message FileAccessLog {
  // A path to a local file to which to write the access log entries.
  string path = 1 [(validate.rules).string = {min_bytes: 1}];

  oneof access_log_format {
    // Access log :ref:`format string<config_access_log_format_strings>`.
    // Envoy supports :ref:`custom access log formats <config_access_log_format>` as well as a
    // :ref:`default format <config_access_log_default_format>`.
    string format = 2;

    // Access log :ref:`format dictionary<config_access_log_format_dictionaries>`. All values
    // are rendered as strings.
    google.protobuf.Struct json_format = 3;

    // Access log :ref:`format dictionary<config_access_log_format_dictionaries>`. Values are
    // rendered as strings, numbers, or boolean values as appropriate. Nested JSON objects may
    // be produced by some command operators (e.g.FILTER_STATE or DYNAMIC_METADATA). See the
    // documentation for a specific command operator for details.
    google.protobuf.Struct typed_json_format = 4;
  }
}
syntax = "proto3";

package envoy.config.accesslog.v2;

import "envoy/api/v2/core/grpc_service.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.accesslog.v2";
option java_outer_classname = "AlsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v2;accesslogv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.access_loggers.grpc.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: gRPC Access Log Service (ALS)]

// Configuration for the built-in *envoy.access_loggers.http_grpc*
// :ref:`AccessLog <envoy_api_msg_config.filter.accesslog.v2.AccessLog>`. This configuration will
// populate :ref:`StreamAccessLogsMessage.http_logs
// <envoy_api_field_service.accesslog.v2.StreamAccessLogsMessage.http_logs>`.
// [#extension: envoy.access_loggers.http_grpc]
message HttpGrpcAccessLogConfig {
  CommonGrpcAccessLogConfig common_config = 1 [(validate.rules).message = {required: true}];

  // Additional request headers to log in :ref:`HTTPRequestProperties.request_headers
  // <envoy_api_field_data.accesslog.v2.HTTPRequestProperties.request_headers>`.
  repeated string additional_request_headers_to_log = 2;

  // Additional response headers to log in :ref:`HTTPResponseProperties.response_headers
  // <envoy_api_field_data.accesslog.v2.HTTPResponseProperties.response_headers>`.
  repeated string additional_response_headers_to_log = 3;

  // Additional response trailers to log in :ref:`HTTPResponseProperties.response_trailers
  // <envoy_api_field_data.accesslog.v2.HTTPResponseProperties.response_trailers>`.
  repeated string additional_response_trailers_to_log = 4;
}

// Configuration for the built-in *envoy.access_loggers.tcp_grpc* type. This configuration will
// populate *StreamAccessLogsMessage.tcp_logs*.
// [#extension: envoy.access_loggers.tcp_grpc]
message TcpGrpcAccessLogConfig {
  CommonGrpcAccessLogConfig common_config = 1 [(validate.rules).message = {required: true}];
}

// Common configuration for gRPC access logs.
// [#next-free-field: 6]
message CommonGrpcAccessLogConfig {
  // The friendly name of the access log to be returned in :ref:`StreamAccessLogsMessage.Identifier
  // <envoy_api_msg_service.accesslog.v2.StreamAccessLogsMessage.Identifier>`. This allows the
  // access log server to differentiate between different access logs coming from the same Envoy.
  string log_name = 1 [(validate.rules).string = {min_bytes: 1}];

  // The gRPC service for the access log service.
  api.v2.core.GrpcService grpc_service = 2 [(validate.rules).message = {required: true}];

  // Interval for flushing access logs to the gRPC stream. Logger will flush requests every time
  // this interval is elapsed, or when batch size limit is hit, whichever comes first. Defaults to
  // 1 second.
  google.protobuf.Duration buffer_flush_interval = 3 [(validate.rules).duration = {gt {}}];

  // Soft size limit in bytes for access log entries buffer. Logger will buffer requests until
  // this limit it hit, or every time flush interval is elapsed, whichever comes first. Setting it
  // to zero effectively disables the batching. Defaults to 16384.
  google.protobuf.UInt32Value buffer_size_bytes = 4;

  // Additional filter state objects to log in :ref:`filter_state_objects
  // <envoy_api_field_data.accesslog.v2.AccessLogCommon.filter_state_objects>`.
  // Logger will call `FilterState::Object::serializeAsProto` to serialize the filter state object.
  repeated string filter_state_objects_to_log = 5;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/config/route/v3:pkg",
        "//envoy/data/accesslog/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.accesslog.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/route/v3/route_components.proto";
import "envoy/data/accesslog/v3/accesslog.proto";
import "envoy/type/matcher/v3/metadata.proto";
import "envoy/type/v3/percent.proto";

import "google/protobuf/any.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.accesslog.v3";
option java_outer_classname = "AccesslogProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3;accesslogv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common access log types]

message AccessLog {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.AccessLog";

  reserved 3;

  reserved "config";

  // The name of the access log extension configuration.
  string name = 1;

  // Filter which is used to determine if the access log needs to be written.
  AccessLogFilter filter = 2;

  // Custom configuration that must be set according to the access logger extension being instantiated.
  // [#extension-category: envoy.access_loggers]
  oneof config_type {
    google.protobuf.Any typed_config = 4;
  }
}

// [#next-free-field: 14]
message AccessLogFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.AccessLogFilter";

  oneof filter_specifier {
    option (validate.required) = true;

    // Status code filter.
    StatusCodeFilter status_code_filter = 1;

    // Duration filter.
    DurationFilter duration_filter = 2;

    // Not health check filter.
    NotHealthCheckFilter not_health_check_filter = 3;

    // Traceable filter.
    TraceableFilter traceable_filter = 4;

    // Runtime filter.
    RuntimeFilter runtime_filter = 5;

    // And filter.
    AndFilter and_filter = 6;

    // Or filter.
    OrFilter or_filter = 7;

    // Header filter.
    HeaderFilter header_filter = 8;

    // Response flag filter.
    ResponseFlagFilter response_flag_filter = 9;

    // gRPC status filter.
    GrpcStatusFilter grpc_status_filter = 10;

    // Extension filter.
    // [#extension-category: envoy.access_loggers.extension_filters]
    ExtensionFilter extension_filter = 11;

    // Metadata Filter
    MetadataFilter metadata_filter = 12;

    // Log Type Filter
    LogTypeFilter log_type_filter = 13;
  }
}

// Filter on an integer comparison.
message ComparisonFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.ComparisonFilter";

  enum Op {
    // =
    EQ = 0;

    // >=
    GE = 1;

    // <=
    LE = 2;
  }

  // Comparison operator.
  Op op = 1 [(validate.rules).enum = {defined_only: true}];

  // Value to compare against.
  core.v3.RuntimeUInt32 value = 2 [(validate.rules).message = {required: true}];
}

// Filters on HTTP response/status code.
message StatusCodeFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.StatusCodeFilter";

  // Comparison.
  ComparisonFilter comparison = 1 [(validate.rules).message = {required: true}];
}

// Filters based on the duration of the request or stream, in milliseconds.
// For end of stream access logs, the total duration of the stream will be used.
// For :ref:`periodic access logs<arch_overview_access_log_periodic>`,
// the duration of the stream at the time of log recording will be used.
message DurationFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.DurationFilter";

  // Comparison.
  ComparisonFilter comparison = 1 [(validate.rules).message = {required: true}];
}

// Filters for requests that are not health check requests. A health check
// request is marked by the health check filter.
message NotHealthCheckFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.NotHealthCheckFilter";
}

// Filters for requests that are traceable. See the tracing overview for more
// information on how a request becomes traceable.
message TraceableFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.TraceableFilter";
}

// Filters for random sampling of requests.
message RuntimeFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.RuntimeFilter";

  // Runtime key to get an optional overridden numerator for use in the
  // ``percent_sampled`` field. If found in runtime, this value will replace the
  // default numerator.
  string runtime_key = 1 [(validate.rules).string = {min_len: 1}];

  // The default sampling percentage. If not specified, defaults to 0% with
  // denominator of 100.
  type.v3.FractionalPercent percent_sampled = 2;

  // By default, sampling pivots on the header
  // :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` being
  // present. If :ref:`x-request-id<config_http_conn_man_headers_x-request-id>`
  // is present, the filter will consistently sample across multiple hosts based
  // on the runtime key value and the value extracted from
  // :ref:`x-request-id<config_http_conn_man_headers_x-request-id>`. If it is
  // missing, or ``use_independent_randomness`` is set to true, the filter will
  // randomly sample based on the runtime key value alone.
  // ``use_independent_randomness`` can be used for logging kill switches within
  // complex nested :ref:`AndFilter
  // <envoy_v3_api_msg_config.accesslog.v3.AndFilter>` and :ref:`OrFilter
  // <envoy_v3_api_msg_config.accesslog.v3.OrFilter>` blocks that are easier to
  // reason about from a probability perspective (i.e., setting to true will
  // cause the filter to behave like an independent random variable when
  // composed within logical operator filters).
  bool use_independent_randomness = 3;
}

// Performs a logical and operation on the result of each filter in filters.
// Filters are evaluated sequentially and if one of them returns false, the
// filter returns false immediately.
message AndFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.AndFilter";

  repeated AccessLogFilter filters = 1 [(validate.rules).repeated = {min_items: 2}];
}

// Performs a logical or operation on the result of each individual filter.
// Filters are evaluated sequentially and if one of them returns true, the
// filter returns true immediately.
message OrFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.OrFilter";

  repeated AccessLogFilter filters = 2 [(validate.rules).repeated = {min_items: 2}];
}

// Filters requests based on the presence or value of a request header.
message HeaderFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.HeaderFilter";

  // Only requests with a header which matches the specified HeaderMatcher will
  // pass the filter check.
  route.v3.HeaderMatcher header = 1 [(validate.rules).message = {required: true}];
}

// Filters requests that received responses with an Envoy response flag set.
// A list of the response flags can be found
// in the access log formatter
// :ref:`documentation<config_access_log_format_response_flags>`.
message ResponseFlagFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.ResponseFlagFilter";

  // Only responses with the any of the flags listed in this field will be
  // logged. This field is optional. If it is not specified, then any response
  // flag will pass the filter check.
  repeated string flags = 1 [(validate.rules).repeated = {
    items {
      string {
        in: "LH"
        in: "UH"
        in: "UT"
        in: "LR"
        in: "UR"
        in: "UF"
        in: "UC"
        in: "UO"
        in: "NR"
        in: "DI"
        in: "FI"
        in: "RL"
        in: "UAEX"
        in: "RLSE"
        in: "DC"
        in: "URX"
        in: "SI"
        in: "IH"
        in: "DPE"
        in: "UMSDR"
        in: "RFCF"
        in: "NFCF"
        in: "DT"
        in: "UPE"
        in: "NC"
        in: "OM"
        in: "DF"
        in: "DO"
      }
    }
  }];
}

// Filters gRPC requests based on their response status. If a gRPC status is not
// provided, the filter will infer the status from the HTTP status code.
message GrpcStatusFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.GrpcStatusFilter";

  enum Status {
    OK = 0;
    CANCELED = 1;
    UNKNOWN = 2;
    INVALID_ARGUMENT = 3;
    DEADLINE_EXCEEDED = 4;
    NOT_FOUND = 5;
    ALREADY_EXISTS = 6;
    PERMISSION_DENIED = 7;
    RESOURCE_EXHAUSTED = 8;
    FAILED_PRECONDITION = 9;
    ABORTED = 10;
    OUT_OF_RANGE = 11;
    UNIMPLEMENTED = 12;
    INTERNAL = 13;
    UNAVAILABLE = 14;
    DATA_LOSS = 15;
    UNAUTHENTICATED = 16;
  }

  // Logs only responses that have any one of the gRPC statuses in this field.
  repeated Status statuses = 1 [(validate.rules).repeated = {items {enum {defined_only: true}}}];

  // If included and set to true, the filter will instead block all responses
  // with a gRPC status or inferred gRPC status enumerated in statuses, and
  // allow all other responses.
  bool exclude = 2;
}

// Filters based on matching dynamic metadata.
// If the matcher path and key correspond to an existing key in dynamic
// metadata, the request is logged only if the matcher value is equal to the
// metadata value. If the matcher path and key *do not* correspond to an
// existing key in dynamic metadata, the request is logged only if
// match_if_key_not_found is "true" or unset.
message MetadataFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.MetadataFilter";

  // Matcher to check metadata for specified value. For example, to match on the
  // access_log_hint metadata, set the filter to "envoy.common" and the path to
  // "access_log_hint", and the value to "true".
  type.matcher.v3.MetadataMatcher matcher = 1;

  // Default result if the key does not exist in dynamic metadata: if unset or
  // true, then log; if false, then don't log.
  google.protobuf.BoolValue match_if_key_not_found = 2;
}

// Filters based on access log type.
message LogTypeFilter {
  // Logs only records which their type is one of the types defined in this field.
  repeated data.accesslog.v3.AccessLogType types = 1
      [(validate.rules).repeated = {items {enum {defined_only: true}}}];

  // If this field is set to true, the filter will instead block all records
  // with a access log type in types field, and allow all other records.
  bool exclude = 2;
}

// Extension filter is statically registered at runtime.
message ExtensionFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.accesslog.v2.ExtensionFilter";

  reserved 2;

  reserved "config";

  // The name of the filter implementation to instantiate. The name must
  // match a statically registered filter.
  string name = 1;

  // Custom configuration that depends on the filter being instantiated.
  oneof config_type {
    google.protobuf.Any typed_config = 3;
  }
}
syntax = "proto3";

package envoy.config.filter.listener.tls_inspector.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.listener.tls_inspector.v2";
option java_outer_classname = "TlsInspectorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/listener/tls_inspector/v2;tls_inspectorv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.listener.tls_inspector.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: TLS Inspector Filter]
// Allows detecting whether the transport appears to be TLS or plaintext.
// [#extension: envoy.filters.listener.tls_inspector]

message TlsInspector {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.listener.original_src.v2alpha1;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.listener.original_src.v2alpha1";
option java_outer_classname = "OriginalSrcProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/listener/original_src/v2alpha1";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.listener.original_src.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Original Src Filter]
// Use the Original source address on upstream connections.
// [#extension: envoy.filters.listener.original_src]

// The Original Src filter binds upstream connections to the original source address determined
// for the connection. This address could come from something like the Proxy Protocol filter, or it
// could come from trusted http headers.
message OriginalSrc {
  // Whether to bind the port to the one used in the original downstream connection.
  // [#not-implemented-hide:]
  bool bind_port = 1;

  // Sets the SO_MARK option on the upstream connection's socket to the provided value. Used to
  // ensure that non-local addresses may be routed back through envoy when binding to the original
  // source address. The option will not be applied if the mark is 0.
  uint32 mark = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.listener.http_inspector.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.listener.http_inspector.v2";
option java_outer_classname = "HttpInspectorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/listener/http_inspector/v2;http_inspectorv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.listener.http_inspector.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: HTTP Inspector Filter]
// Detect whether the application protocol is HTTP.
// [#extension: envoy.filters.listener.http_inspector]

message HttpInspector {
}
syntax = "proto3";

package envoy.config.filter.listener.original_dst.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.listener.original_dst.v2";
option java_outer_classname = "OriginalDstProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/listener/original_dst/v2;original_dstv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.listener.original_dst.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Original Dst Filter]
// Use the Original destination address on downstream connections.
// [#extension: envoy.filters.listener.original_dst]

message OriginalDst {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.listener.proxy_protocol.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.listener.proxy_protocol.v2";
option java_outer_classname = "ProxyProtocolProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/listener/proxy_protocol/v2;proxy_protocolv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.listener.proxy_protocol.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Proxy Protocol Filter]
// PROXY protocol listener filter.
// [#extension: envoy.filters.listener.proxy_protocol]

message ProxyProtocol {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.udp.udp_proxy.v2alpha;

import "google/protobuf/duration.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.udp.udp_proxy.v2alpha";
option java_outer_classname = "UdpProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/udp/udp_proxy/v2alpha";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.udp.udp_proxy.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: UDP proxy]
// UDP proxy :ref:`configuration overview <config_udp_listener_filters_udp_proxy>`.
// [#extension: envoy.filters.udp_listener.udp_proxy]

// Configuration for the UDP proxy filter.
message UdpProxyConfig {
  // The stat prefix used when emitting UDP proxy filter stats.
  string stat_prefix = 1 [(validate.rules).string = {min_bytes: 1}];

  oneof route_specifier {
    option (validate.required) = true;

    // The upstream cluster to connect to.
    string cluster = 2 [(validate.rules).string = {min_bytes: 1}];
  }

  // The idle timeout for sessions. Idle is defined as no datagrams between received or sent by
  // the session. The default if not specified is 1 minute.
  google.protobuf.Duration idle_timeout = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/rbac/v2:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.network.rbac.v2;

import "envoy/config/rbac/v2/rbac.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.rbac.v2";
option java_outer_classname = "RbacProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/rbac/v2;rbacv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.network.rbac.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: RBAC]
// Role-Based Access Control :ref:`configuration overview <config_network_filters_rbac>`.
// [#extension: envoy.filters.network.rbac]

// RBAC network filter config.
//
// Header should not be used in rules/shadow_rules in RBAC network filter as
// this information is only available in :ref:`RBAC http filter <config_http_filters_rbac>`.
message RBAC {
  enum EnforcementType {
    // Apply RBAC policies when the first byte of data arrives on the connection.
    ONE_TIME_ON_FIRST_BYTE = 0;

    // Continuously apply RBAC policies as data arrives. Use this mode when
    // using RBAC with message oriented protocols such as Mongo, MySQL, Kafka,
    // etc. when the protocol decoders emit dynamic metadata such as the
    // resources being accessed and the operations on the resources.
    CONTINUOUS = 1;
  }

  // Specify the RBAC rules to be applied globally.
  // If absent, no enforcing RBAC policy will be applied.
  config.rbac.v2.RBAC rules = 1;

  // Shadow rules are not enforced by the filter but will emit stats and logs
  // and can be used for rule testing.
  // If absent, no shadow RBAC policy will be applied.
  config.rbac.v2.RBAC shadow_rules = 2;

  // The prefix to use when emitting statistics.
  string stat_prefix = 3 [(validate.rules).string = {min_bytes: 1}];

  // RBAC enforcement strategy. By default RBAC will be enforced only once
  // when the first byte of data arrives from the downstream. When used in
  // conjunction with filters that emit dynamic metadata after decoding
  // every payload (e.g., Mongo, MySQL, Kafka) set the enforcement type to
  // CONTINUOUS to enforce RBAC policies on every message boundary.
  EnforcementType enforcement_type = 4;
}
syntax = "proto3";

package envoy.config.filter.network.echo.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.echo.v2";
option java_outer_classname = "EchoProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/echo/v2;echov2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.network.echo.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Echo]
// Echo :ref:`configuration overview <config_network_filters_echo>`.
// [#extension: envoy.filters.network.echo]

message Echo {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.network.tcp_proxy.v2;

import "envoy/api/v2/core/address.proto";
import "envoy/api/v2/core/base.proto";
import "envoy/config/filter/accesslog/v2/accesslog.proto";
import "envoy/type/hash_policy.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.tcp_proxy.v2";
option java_outer_classname = "TcpProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/tcp_proxy/v2;tcp_proxyv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.tcp_proxy.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: TCP Proxy]
// TCP Proxy :ref:`configuration overview <config_network_filters_tcp_proxy>`.
// [#extension: envoy.filters.network.tcp_proxy]

// [#next-free-field: 13]
message TcpProxy {
  // [#not-implemented-hide:] Deprecated.
  // TCP Proxy filter configuration using V1 format.
  message DeprecatedV1 {
    option deprecated = true;

    // A TCP proxy route consists of a set of optional L4 criteria and the
    // name of a cluster. If a downstream connection matches all the
    // specified criteria, the cluster in the route is used for the
    // corresponding upstream connection. Routes are tried in the order
    // specified until a match is found. If no match is found, the connection
    // is closed. A route with no criteria is valid and always produces a
    // match.
    // [#next-free-field: 6]
    message TCPRoute {
      // The cluster to connect to when a the downstream network connection
      // matches the specified criteria.
      string cluster = 1 [(validate.rules).string = {min_bytes: 1}];

      // An optional list of IP address subnets in the form
      // ip_address/xx. The criteria is satisfied if the destination IP
      // address of the downstream connection is contained in at least one of
      // the specified subnets. If the parameter is not specified or the list
      // is empty, the destination IP address is ignored. The destination IP
      // address of the downstream connection might be different from the
      // addresses on which the proxy is listening if the connection has been
      // redirected.
      repeated api.v2.core.CidrRange destination_ip_list = 2;

      // An optional string containing a comma-separated list of port numbers
      // or ranges. The criteria is satisfied if the destination port of the
      // downstream connection is contained in at least one of the specified
      // ranges. If the parameter is not specified, the destination port is
      // ignored. The destination port address of the downstream connection
      // might be different from the port on which the proxy is listening if
      // the connection has been redirected.
      string destination_ports = 3;

      // An optional list of IP address subnets in the form
      // ip_address/xx. The criteria is satisfied if the source IP address
      // of the downstream connection is contained in at least one of the
      // specified subnets. If the parameter is not specified or the list is
      // empty, the source IP address is ignored.
      repeated api.v2.core.CidrRange source_ip_list = 4;

      // An optional string containing a comma-separated list of port numbers
      // or ranges. The criteria is satisfied if the source port of the
      // downstream connection is contained in at least one of the specified
      // ranges. If the parameter is not specified, the source port is
      // ignored.
      string source_ports = 5;
    }

    // The route table for the filter. All filter instances must have a route
    // table, even if it is empty.
    repeated TCPRoute routes = 1 [(validate.rules).repeated = {min_items: 1}];
  }

  // Allows for specification of multiple upstream clusters along with weights
  // that indicate the percentage of traffic to be forwarded to each cluster.
  // The router selects an upstream cluster based on these weights.
  message WeightedCluster {
    message ClusterWeight {
      // Name of the upstream cluster.
      string name = 1 [(validate.rules).string = {min_bytes: 1}];

      // When a request matches the route, the choice of an upstream cluster is
      // determined by its weight. The sum of weights across all entries in the
      // clusters array determines the total weight.
      uint32 weight = 2 [(validate.rules).uint32 = {gte: 1}];

      // Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
      // in the upstream cluster with metadata matching what is set in this field will be considered
      // for load balancing. Note that this will be merged with what's provided in
      // :ref:`TcpProxy.metadata_match
      // <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.metadata_match>`, with values
      // here taking precedence. The filter name should be specified as *envoy.lb*.
      api.v2.core.Metadata metadata_match = 3;
    }

    // Specifies one or more upstream clusters associated with the route.
    repeated ClusterWeight clusters = 1 [(validate.rules).repeated = {min_items: 1}];
  }

  // Configuration for tunneling TCP over other transports or application layers.
  // Currently, only HTTP/2 is supported. When other options exist, HTTP/2 will
  // remain the default.
  message TunnelingConfig {
    // The hostname to send in the synthesized CONNECT headers to the upstream proxy.
    string hostname = 1 [(validate.rules).string = {min_bytes: 1}];
  }

  // The prefix to use when emitting :ref:`statistics
  // <config_network_filters_tcp_proxy_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_bytes: 1}];

  oneof cluster_specifier {
    option (validate.required) = true;

    // The upstream cluster to connect to.
    string cluster = 2;

    // Multiple upstream clusters can be specified for a given route. The
    // request is routed to one of the upstream clusters based on weights
    // assigned to each cluster.
    WeightedCluster weighted_clusters = 10;
  }

  // Optional endpoint metadata match criteria. Only endpoints in the upstream
  // cluster with metadata matching that set in metadata_match will be
  // considered. The filter name should be specified as *envoy.lb*.
  api.v2.core.Metadata metadata_match = 9;

  // The idle timeout for connections managed by the TCP proxy filter. The idle timeout
  // is defined as the period in which there are no bytes sent or received on either
  // the upstream or downstream connection. If not set, the default idle timeout is 1 hour. If set
  // to 0s, the timeout will be disabled.
  //
  // .. warning::
  //   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
  //   FIN packets, etc.
  google.protobuf.Duration idle_timeout = 8;

  // [#not-implemented-hide:] The idle timeout for connections managed by the TCP proxy
  // filter. The idle timeout is defined as the period in which there is no
  // active traffic. If not set, there is no idle timeout. When the idle timeout
  // is reached the connection will be closed. The distinction between
  // downstream_idle_timeout/upstream_idle_timeout provides a means to set
  // timeout based on the last byte sent on the downstream/upstream connection.
  google.protobuf.Duration downstream_idle_timeout = 3;

  // [#not-implemented-hide:]
  google.protobuf.Duration upstream_idle_timeout = 4;

  // Configuration for :ref:`access logs <arch_overview_access_logs>`
  // emitted by the this tcp_proxy.
  repeated accesslog.v2.AccessLog access_log = 5;

  // [#not-implemented-hide:] Deprecated.
  DeprecatedV1 deprecated_v1 = 6 [deprecated = true];

  // The maximum number of unsuccessful connection attempts that will be made before
  // giving up. If the parameter is not specified, 1 connection attempt will be made.
  google.protobuf.UInt32Value max_connect_attempts = 7 [(validate.rules).uint32 = {gte: 1}];

  // Optional configuration for TCP proxy hash policy. If hash_policy is not set, the hash-based
  // load balancing algorithms will select a host randomly. Currently the number of hash policies is
  // limited to 1.
  repeated type.HashPolicy hash_policy = 11 [(validate.rules).repeated = {max_items: 1}];

  // [#not-implemented-hide:] feature in progress
  // If set, this configures tunneling, e.g. configuration options to tunnel multiple TCP
  // payloads over a shared HTTP/2 tunnel. If this message is absent, the payload
  // will be proxied upstream as per usual.
  TunnelingConfig tunneling_config = 12;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "//envoy/config/filter/accesslog/v2:pkg",
        "//envoy/type:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/filter/fault/v2:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.network.mongo_proxy.v2;

import "envoy/config/filter/fault/v2/fault.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.mongo_proxy.v2";
option java_outer_classname = "MongoProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/mongo_proxy/v2;mongo_proxyv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.mongo_proxy.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Mongo proxy]
// MongoDB :ref:`configuration overview <config_network_filters_mongo_proxy>`.
// [#extension: envoy.filters.network.mongo_proxy]

message MongoProxy {
  // The human readable prefix to use when emitting :ref:`statistics
  // <config_network_filters_mongo_proxy_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_bytes: 1}];

  // The optional path to use for writing Mongo access logs. If not access log
  // path is specified no access logs will be written. Note that access log is
  // also gated :ref:`runtime <config_network_filters_mongo_proxy_runtime>`.
  string access_log = 2;

  // Inject a fixed delay before proxying a Mongo operation. Delays are
  // applied to the following MongoDB operations: Query, Insert, GetMore,
  // and KillCursors. Once an active delay is in progress, all incoming
  // data up until the timer event fires will be a part of the delay.
  fault.v2.FaultDelay delay = 3;

  // Flag to specify whether :ref:`dynamic metadata
  // <config_network_filters_mongo_proxy_dynamic_metadata>` should be emitted. Defaults to false.
  bool emit_dynamic_metadata = 4;
}
syntax = "proto3";

package envoy.config.filter.network.zookeeper_proxy.v1alpha1;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.zookeeper_proxy.v1alpha1";
option java_outer_classname = "ZookeeperProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/zookeeper_proxy/v1alpha1";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.zookeeper_proxy.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: ZooKeeper proxy]
// ZooKeeper Proxy :ref:`configuration overview <config_network_filters_zookeeper_proxy>`.
// [#extension: envoy.filters.network.zookeeper_proxy]

message ZooKeeperProxy {
  // The human readable prefix to use when emitting :ref:`statistics
  // <config_network_filters_zookeeper_proxy_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_bytes: 1}];

  // [#not-implemented-hide:] The optional path to use for writing ZooKeeper access logs.
  // If the access log field is empty, access logs will not be written.
  string access_log = 2;

  // Messages  requests, responses and events  that are bigger than this value will
  // be ignored. If it is not set, the default value is 1Mb.
  //
  // The value here should match the jute.maxbuffer property in your cluster configuration:
  //
  // https://zookeeper.apache.org/doc/r3.4.10/zookeeperAdmin.html#Unsafe+Options
  //
  // if that is set. If it isn't, ZooKeeper's default is also 1Mb.
  google.protobuf.UInt32Value max_packet_bytes = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.network.redis_proxy.v2;

import "envoy/api/v2/core/base.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/sensitive.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.redis_proxy.v2";
option java_outer_classname = "RedisProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/redis_proxy/v2;redis_proxyv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.redis_proxy.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Redis Proxy]
// Redis Proxy :ref:`configuration overview <config_network_filters_redis_proxy>`.
// [#extension: envoy.filters.network.redis_proxy]

// [#next-free-field: 7]
message RedisProxy {
  // Redis connection pool settings.
  // [#next-free-field: 9]
  message ConnPoolSettings {
    // ReadPolicy controls how Envoy routes read commands to Redis nodes. This is currently
    // supported for Redis Cluster. All ReadPolicy settings except MASTER may return stale data
    // because replication is asynchronous and requires some delay. You need to ensure that your
    // application can tolerate stale data.
    enum ReadPolicy {
      // Default mode. Read from the current primary node.
      MASTER = 0;

      // Read from the primary, but if it is unavailable, read from replica nodes.
      PREFER_MASTER = 1;

      // Read from replica nodes. If multiple replica nodes are present within a shard, a random
      // node is selected. Healthy nodes have precedent over unhealthy nodes.
      REPLICA = 2;

      // Read from the replica nodes (similar to REPLICA), but if all replicas are unavailable (not
      // present or unhealthy), read from the primary.
      PREFER_REPLICA = 3;

      // Read from any node of the cluster. A random node is selected among the primary and
      // replicas, healthy nodes have precedent over unhealthy nodes.
      ANY = 4;
    }

    // Per-operation timeout in milliseconds. The timer starts when the first
    // command of a pipeline is written to the backend connection. Each response received from Redis
    // resets the timer since it signifies that the next command is being processed by the backend.
    // The only exception to this behavior is when a connection to a backend is not yet established.
    // In that case, the connect timeout on the cluster will govern the timeout until the connection
    // is ready.
    google.protobuf.Duration op_timeout = 1 [(validate.rules).duration = {required: true}];

    // Use hash tagging on every redis key to guarantee that keys with the same hash tag will be
    // forwarded to the same upstream. The hash key used for determining the upstream in a
    // consistent hash ring configuration will be computed from the hash tagged key instead of the
    // whole key. The algorithm used to compute the hash tag is identical to the `redis-cluster
    // implementation <https://redis.io/topics/cluster-spec#keys-hash-tags>`_.
    //
    // Examples:
    //
    // * '{user1000}.following' and '{user1000}.followers' **will** be sent to the same upstream
    // * '{user1000}.following' and '{user1001}.following' **might** be sent to the same upstream
    bool enable_hashtagging = 2;

    // Accept `moved and ask redirection
    // <https://redis.io/topics/cluster-spec#redirection-and-resharding>`_ errors from upstream
    // redis servers, and retry commands to the specified target server. The target server does not
    // need to be known to the cluster manager. If the command cannot be redirected, then the
    // original error is passed downstream unchanged. By default, this support is not enabled.
    bool enable_redirection = 3;

    // Maximum size of encoded request buffer before flush is triggered and encoded requests
    // are sent upstream. If this is unset, the buffer flushes whenever it receives data
    // and performs no batching.
    // This feature makes it possible for multiple clients to send requests to Envoy and have
    // them batched- for example if one is running several worker processes, each with its own
    // Redis connection. There is no benefit to using this with a single downstream process.
    // Recommended size (if enabled) is 1024 bytes.
    uint32 max_buffer_size_before_flush = 4;

    // The encoded request buffer is flushed N milliseconds after the first request has been
    // encoded, unless the buffer size has already exceeded `max_buffer_size_before_flush`.
    // If `max_buffer_size_before_flush` is not set, this flush timer is not used. Otherwise,
    // the timer should be set according to the number of clients, overall request rate and
    // desired maximum latency for a single command. For example, if there are many requests
    // being batched together at a high rate, the buffer will likely be filled before the timer
    // fires. Alternatively, if the request rate is lower the buffer will not be filled as often
    // before the timer fires.
    // If `max_buffer_size_before_flush` is set, but `buffer_flush_timeout` is not, the latter
    // defaults to 3ms.
    google.protobuf.Duration buffer_flush_timeout = 5;

    // `max_upstream_unknown_connections` controls how many upstream connections to unknown hosts
    // can be created at any given time by any given worker thread (see `enable_redirection` for
    // more details). If the host is unknown and a connection cannot be created due to enforcing
    // this limit, then redirection will fail and the original redirection error will be passed
    // downstream unchanged. This limit defaults to 100.
    google.protobuf.UInt32Value max_upstream_unknown_connections = 6;

    // Enable per-command statistics per upstream cluster, in addition to the filter level aggregate
    // count.
    bool enable_command_stats = 8;

    // Read policy. The default is to read from the primary.
    ReadPolicy read_policy = 7 [(validate.rules).enum = {defined_only: true}];
  }

  message PrefixRoutes {
    message Route {
      // The router is capable of shadowing traffic from one cluster to another. The current
      // implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
      // respond before returning the response from the primary cluster. All normal statistics are
      // collected for the shadow cluster making this feature useful for testing.
      message RequestMirrorPolicy {
        // Specifies the cluster that requests will be mirrored to. The cluster must
        // exist in the cluster manager configuration.
        string cluster = 1 [(validate.rules).string = {min_bytes: 1}];

        // If not specified or the runtime key is not present, all requests to the target cluster
        // will be mirrored.
        //
        // If specified, Envoy will lookup the runtime key to get the percentage of requests to the
        // mirror.
        api.v2.core.RuntimeFractionalPercent runtime_fraction = 2;

        // Set this to TRUE to only mirror write commands, this is effectively replicating the
        // writes in a "fire and forget" manner.
        bool exclude_read_commands = 3;
      }

      // String prefix that must match the beginning of the keys. Envoy will always favor the
      // longest match.
      string prefix = 1;

      // Indicates if the prefix needs to be removed from the key when forwarded.
      bool remove_prefix = 2;

      // Upstream cluster to forward the command to.
      string cluster = 3 [(validate.rules).string = {min_bytes: 1}];

      // Indicates that the route has a request mirroring policy.
      repeated RequestMirrorPolicy request_mirror_policy = 4;
    }

    // List of prefix routes.
    repeated Route routes = 1;

    // Indicates that prefix matching should be case insensitive.
    bool case_insensitive = 2;

    // Optional catch-all route to forward commands that doesn't match any of the routes. The
    // catch-all route becomes required when no routes are specified.
    // .. attention::
    //
    //   This field is deprecated. Use a :ref:`catch_all
    //   route<envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route>`
    //   instead.
    string catch_all_cluster = 3
        [deprecated = true, (envoy.annotations.disallowed_by_default) = true];

    // Optional catch-all route to forward commands that doesn't match any of the routes. The
    // catch-all route becomes required when no routes are specified.
    Route catch_all_route = 4;
  }

  // The prefix to use when emitting :ref:`statistics <config_network_filters_redis_proxy_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_bytes: 1}];

  // Name of cluster from cluster manager. See the :ref:`configuration section
  // <arch_overview_redis_configuration>` of the architecture overview for recommendations on
  // configuring the backing cluster.
  //
  // .. attention::
  //
  //   This field is deprecated. Use a :ref:`catch_all
  //   route<envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route>`
  //   instead.
  string cluster = 2 [deprecated = true, (envoy.annotations.disallowed_by_default) = true];

  // Network settings for the connection pool to the upstream clusters.
  ConnPoolSettings settings = 3 [(validate.rules).message = {required: true}];

  // Indicates that latency stat should be computed in microseconds. By default it is computed in
  // milliseconds.
  bool latency_in_micros = 4;

  // List of **unique** prefixes used to separate keys from different workloads to different
  // clusters. Envoy will always favor the longest match first in case of overlap. A catch-all
  // cluster can be used to forward commands when there is no match. Time complexity of the
  // lookups are in O(min(longest key prefix, key length)).
  //
  // Example:
  //
  // .. code-block:: yaml
  //
  //    prefix_routes:
  //      routes:
  //        - prefix: "ab"
  //          cluster: "cluster_a"
  //        - prefix: "abc"
  //          cluster: "cluster_b"
  //
  // When using the above routes, the following prefixes would be sent to:
  //
  // * ``get abc:users`` would retrieve the key 'abc:users' from cluster_b.
  // * ``get ab:users`` would retrieve the key 'ab:users' from cluster_a.
  // * ``get z:users`` would return a NoUpstreamHost error. A :ref:`catch-all
  //   route<envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route>`
  //   would have retrieved the key from that cluster instead.
  //
  // See the :ref:`configuration section
  // <arch_overview_redis_configuration>` of the architecture overview for recommendations on
  // configuring the backing clusters.
  PrefixRoutes prefix_routes = 5;

  // Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
  // AUTH command <https://redis.io/commands/auth>`_ with this password before enabling any other
  // command. If an AUTH command's password matches this password, an "OK" response will be returned
  // to the client. If the AUTH command password does not match this password, then an "ERR invalid
  // password" error will be returned. If any other command is received before AUTH when this
  // password is set, then a "NOAUTH Authentication required." error response will be sent to the
  // client. If an AUTH command is received when the password is not set, then an "ERR Client sent
  // AUTH, but no password is set" error will be returned.
  api.v2.core.DataSource downstream_auth_password = 6 [(udpa.annotations.sensitive) = true];
}

// RedisProtocolOptions specifies Redis upstream protocol options. This object is used in
// :ref:`typed_extension_protocol_options<envoy_api_field_Cluster.typed_extension_protocol_options>`,
// keyed by the name `envoy.filters.network.redis_proxy`.
message RedisProtocolOptions {
  // Upstream server password as defined by the `requirepass` directive
  // <https://redis.io/topics/config>`_ in the server's configuration file.
  api.v2.core.DataSource auth_password = 1 [(udpa.annotations.sensitive) = true];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/api/v2/core:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.network.http_connection_manager.v2;

import "envoy/api/v2/core/config_source.proto";
import "envoy/api/v2/core/protocol.proto";
import "envoy/api/v2/route.proto";
import "envoy/api/v2/scoped_route.proto";
import "envoy/config/filter/accesslog/v2/accesslog.proto";
import "envoy/config/trace/v2/http_tracer.proto";
import "envoy/type/percent.proto";
import "envoy/type/tracing/v2/custom_tag.proto";

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.http_connection_manager.v2";
option java_outer_classname = "HttpConnectionManagerProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/http_connection_manager/v2;http_connection_managerv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.http_connection_manager.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: HTTP connection manager]
// HTTP connection manager :ref:`configuration overview <config_http_conn_man>`.
// [#extension: envoy.filters.network.http_connection_manager]

// [#next-free-field: 37]
message HttpConnectionManager {
  enum CodecType {
    // For every new connection, the connection manager will determine which
    // codec to use. This mode supports both ALPN for TLS listeners as well as
    // protocol inference for plaintext listeners. If ALPN data is available, it
    // is preferred, otherwise protocol inference is used. In almost all cases,
    // this is the right option to choose for this setting.
    AUTO = 0;

    // The connection manager will assume that the client is speaking HTTP/1.1.
    HTTP1 = 1;

    // The connection manager will assume that the client is speaking HTTP/2
    // (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
    // Prior knowledge is allowed).
    HTTP2 = 2;

    // [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
    // caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
    // to distinguish HTTP1 and HTTP2 traffic.
    HTTP3 = 3;
  }

  enum ServerHeaderTransformation {
    // Overwrite any Server header with the contents of server_name.
    OVERWRITE = 0;

    // If no Server header is present, append Server server_name
    // If a Server header is present, pass it through.
    APPEND_IF_ABSENT = 1;

    // Pass through the value of the server header, and do not append a header
    // if none is present.
    PASS_THROUGH = 2;
  }

  // How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
  // header.
  enum ForwardClientCertDetails {
    // Do not send the XFCC header to the next hop. This is the default value.
    SANITIZE = 0;

    // When the client connection is mTLS (Mutual TLS), forward the XFCC header
    // in the request.
    FORWARD_ONLY = 1;

    // When the client connection is mTLS, append the client certificate
    // information to the requests XFCC header and forward it.
    APPEND_FORWARD = 2;

    // When the client connection is mTLS, reset the XFCC header with the client
    // certificate information and send it to the next hop.
    SANITIZE_SET = 3;

    // Always forward the XFCC header in the request, regardless of whether the
    // client connection is mTLS.
    ALWAYS_FORWARD_ONLY = 4;
  }

  // [#next-free-field: 10]
  message Tracing {
    enum OperationName {
      // The HTTP listener is used for ingress/incoming requests.
      INGRESS = 0;

      // The HTTP listener is used for egress/outgoing requests.
      EGRESS = 1;
    }

    // The span name will be derived from this field. If
    // :ref:`traffic_direction <envoy_api_field_Listener.traffic_direction>` is
    // specified on the parent listener, then it is used instead of this field.
    //
    // .. attention::
    //  This field has been deprecated in favor of `traffic_direction`.
    OperationName operation_name = 1 [
      deprecated = true,
      (validate.rules).enum = {defined_only: true},
      (envoy.annotations.disallowed_by_default) = true
    ];

    // A list of header names used to create tags for the active span. The header name is used to
    // populate the tag name, and the header value is used to populate the tag value. The tag is
    // created if the specified header name is present in the request's headers.
    //
    // .. attention::
    //  This field has been deprecated in favor of :ref:`custom_tags
    //  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.tracing.custom_tags>`.
    repeated string request_headers_for_tags = 2 [deprecated = true];

    // Target percentage of requests managed by this HTTP connection manager that will be force
    // traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
    // header is set. This field is a direct analog for the runtime variable
    // 'tracing.client_enabled' in the :ref:`HTTP Connection Manager
    // <config_http_conn_man_runtime>`.
    // Default: 100%
    type.Percent client_sampling = 3;

    // Target percentage of requests managed by this HTTP connection manager that will be randomly
    // selected for trace generation, if not requested by the client or not forced. This field is
    // a direct analog for the runtime variable 'tracing.random_sampling' in the
    // :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
    // Default: 100%
    type.Percent random_sampling = 4;

    // Target percentage of requests managed by this HTTP connection manager that will be traced
    // after all other sampling checks have been applied (client-directed, force tracing, random
    // sampling). This field functions as an upper limit on the total configured sampling rate. For
    // instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
    // of client requests with the appropriate headers to be force traced. This field is a direct
    // analog for the runtime variable 'tracing.global_enabled' in the
    // :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
    // Default: 100%
    type.Percent overall_sampling = 5;

    // Whether to annotate spans with additional data. If true, spans will include logs for stream
    // events.
    bool verbose = 6;

    // Maximum length of the request path to extract and include in the HttpUrl tag. Used to
    // truncate lengthy request paths to meet the needs of a tracing backend.
    // Default: 256
    google.protobuf.UInt32Value max_path_tag_length = 7;

    // A list of custom tags with unique tag name to create tags for the active span.
    repeated type.tracing.v2.CustomTag custom_tags = 8;

    // Configuration for an external tracing provider.
    // If not specified, no tracing will be performed.
    //
    // .. attention::
    //   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
    //   in Envoy lifetime.
    //   Any attempts to reconfigure it or to use different configurations for different HCM filters
    //   will be rejected.
    //   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
    //   on OpenCensus side.
    trace.v2.Tracing.Http provider = 9;
  }

  message InternalAddressConfig {
    // Whether unix socket addresses should be considered internal.
    bool unix_sockets = 1;
  }

  // [#next-free-field: 7]
  message SetCurrentClientCertDetails {
    reserved 2;

    // Whether to forward the subject of the client cert. Defaults to false.
    google.protobuf.BoolValue subject = 1;

    // Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
    // XFCC header comma separated from other values with the value Cert="PEM".
    // Defaults to false.
    bool cert = 3;

    // Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
    // format. This will appear in the XFCC header comma separated from other values with the value
    // Chain="PEM".
    // Defaults to false.
    bool chain = 6;

    // Whether to forward the DNS type Subject Alternative Names of the client cert.
    // Defaults to false.
    bool dns = 4;

    // Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
    // false.
    bool uri = 5;
  }

  // The configuration for HTTP upgrades.
  // For each upgrade type desired, an UpgradeConfig must be added.
  //
  // .. warning::
  //
  //    The current implementation of upgrade headers does not handle
  //    multi-valued upgrade headers. Support for multi-valued headers may be
  //    added in the future if needed.
  //
  // .. warning::
  //    The current implementation of upgrade headers does not work with HTTP/2
  //    upstreams.
  message UpgradeConfig {
    // The case-insensitive name of this upgrade, e.g. "websocket".
    // For each upgrade type present in upgrade_configs, requests with
    // Upgrade: [upgrade_type]
    // will be proxied upstream.
    string upgrade_type = 1;

    // If present, this represents the filter chain which will be created for
    // this type of upgrade. If no filters are present, the filter chain for
    // HTTP connections will be used for this upgrade type.
    repeated HttpFilter filters = 2;

    // Determines if upgrades are enabled or disabled by default. Defaults to true.
    // This can be overridden on a per-route basis with :ref:`cluster
    // <envoy_api_field_route.RouteAction.upgrade_configs>` as documented in the
    // :ref:`upgrade documentation <arch_overview_upgrades>`.
    google.protobuf.BoolValue enabled = 3;
  }

  reserved 27;

  // Supplies the type of codec that the connection manager should use.
  CodecType codec_type = 1 [(validate.rules).enum = {defined_only: true}];

  // The human readable prefix to use when emitting statistics for the
  // connection manager. See the :ref:`statistics documentation <config_http_conn_man_stats>` for
  // more information.
  string stat_prefix = 2 [(validate.rules).string = {min_bytes: 1}];

  oneof route_specifier {
    option (validate.required) = true;

    // The connection managers route table will be dynamically loaded via the RDS API.
    Rds rds = 3;

    // The route table for the connection manager is static and is specified in this property.
    api.v2.RouteConfiguration route_config = 4;

    // A route table will be dynamically assigned to each request based on request attributes
    // (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
    // specified in this message.
    ScopedRoutes scoped_routes = 31;
  }

  // A list of individual HTTP filters that make up the filter chain for
  // requests made to the connection manager. :ref:`Order matters <arch_overview_http_filters_ordering>`
  // as the filters are processed sequentially as request events happen.
  repeated HttpFilter http_filters = 5;

  // Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
  // and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
  // documentation for more information. Defaults to false.
  google.protobuf.BoolValue add_user_agent = 6;

  // Presence of the object defines whether the connection manager
  // emits :ref:`tracing <arch_overview_tracing>` data to the :ref:`configured tracing provider
  // <envoy_api_msg_config.trace.v2.Tracing>`.
  Tracing tracing = 7;

  // Additional settings for HTTP requests handled by the connection manager. These will be
  // applicable to both HTTP1 and HTTP2 requests.
  api.v2.core.HttpProtocolOptions common_http_protocol_options = 35;

  // Additional HTTP/1 settings that are passed to the HTTP/1 codec.
  api.v2.core.Http1ProtocolOptions http_protocol_options = 8;

  // Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
  api.v2.core.Http2ProtocolOptions http2_protocol_options = 9;

  // An optional override that the connection manager will write to the server
  // header in responses. If not set, the default is *envoy*.
  string server_name = 10;

  // Defines the action to be applied to the Server header on the response path.
  // By default, Envoy will overwrite the header with the value specified in
  // server_name.
  ServerHeaderTransformation server_header_transformation = 34
      [(validate.rules).enum = {defined_only: true}];

  // The maximum request headers size for incoming connections.
  // If unconfigured, the default max request headers allowed is 60 KiB.
  // Requests that exceed this limit will receive a 431 response.
  google.protobuf.UInt32Value max_request_headers_kb = 29
      [(validate.rules).uint32 = {lte: 8192 gt: 0}];

  // The idle timeout for connections managed by the connection manager. The
  // idle timeout is defined as the period in which there are no active
  // requests. If not set, there is no idle timeout. When the idle timeout is
  // reached the connection will be closed. If the connection is an HTTP/2
  // connection a drain sequence will occur prior to closing the connection.
  // This field is deprecated. Use :ref:`idle_timeout
  // <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.common_http_protocol_options>`
  // instead.
  google.protobuf.Duration idle_timeout = 11
      [deprecated = true, (envoy.annotations.disallowed_by_default) = true];

  // The stream idle timeout for connections managed by the connection manager.
  // If not specified, this defaults to 5 minutes. The default value was selected
  // so as not to interfere with any smaller configured timeouts that may have
  // existed in configurations prior to the introduction of this feature, while
  // introducing robustness to TCP connections that terminate without a FIN.
  //
  // This idle timeout applies to new streams and is overridable by the
  // :ref:`route-level idle_timeout
  // <envoy_api_field_route.RouteAction.idle_timeout>`. Even on a stream in
  // which the override applies, prior to receipt of the initial request
  // headers, the :ref:`stream_idle_timeout
  // <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>`
  // applies. Each time an encode/decode event for headers or data is processed
  // for the stream, the timer will be reset. If the timeout fires, the stream
  // is terminated with a 408 Request Timeout error code if no upstream response
  // header has been received, otherwise a stream reset occurs.
  //
  // This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
  // window to write any remaining stream data once the entirety of stream data (local end stream is
  // true) has been buffered pending available window. In other words, this timeout defends against
  // a peer that does not release enough window to completely write the stream, even though all
  // data has been proxied within available flow control windows. If the timeout is hit in this
  // case, the :ref:`tx_flush_timeout <config_http_conn_man_stats_per_codec>` counter will be
  // incremented. Note that :ref:`max_stream_duration
  // <envoy_api_field_core.HttpProtocolOptions.max_stream_duration>` does not apply to this corner
  // case.
  //
  // Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
  // to the granularity of events presented to the connection manager. For example, while receiving
  // very large request headers, it may be the case that there is traffic regularly arriving on the
  // wire while the connection manage is only able to observe the end-of-headers event, hence the
  // stream may still idle timeout.
  //
  // A value of 0 will completely disable the connection manager stream idle
  // timeout, although per-route idle timeout overrides will continue to apply.
  google.protobuf.Duration stream_idle_timeout = 24;

  // The amount of time that Envoy will wait for the entire request to be received.
  // The timer is activated when the request is initiated, and is disarmed when the last byte of the
  // request is sent upstream (i.e. all decoding filters have processed the request), OR when the
  // response is initiated. If not specified or set to 0, this timeout is disabled.
  google.protobuf.Duration request_timeout = 28;

  // The time that Envoy will wait between sending an HTTP/2 shutdown
  // notification (GOAWAY frame with max stream ID) and a final GOAWAY frame.
  // This is used so that Envoy provides a grace period for new streams that
  // race with the final GOAWAY frame. During this grace period, Envoy will
  // continue to accept new streams. After the grace period, a final GOAWAY
  // frame is sent and Envoy will start refusing new streams. Draining occurs
  // both when a connection hits the idle timeout or during general server
  // draining. The default grace period is 5000 milliseconds (5 seconds) if this
  // option is not specified.
  google.protobuf.Duration drain_timeout = 12;

  // The delayed close timeout is for downstream connections managed by the HTTP connection manager.
  // It is defined as a grace period after connection close processing has been locally initiated
  // during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
  // from the downstream connection) prior to Envoy closing the socket associated with that
  // connection.
  // NOTE: This timeout is enforced even when the socket associated with the downstream connection
  // is pending a flush of the write buffer. However, any progress made writing data to the socket
  // will restart the timer associated with this timeout. This means that the total grace period for
  // a socket in this state will be
  // <total_time_waiting_for_write_buffer_flushes>+<delayed_close_timeout>.
  //
  // Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
  // sequence mitigates a race condition that exists when downstream clients do not drain/process
  // data in a connection's receive buffer after a remote close has been detected via a socket
  // write(). This race leads to such clients failing to process the response code sent by Envoy,
  // which could result in erroneous downstream processing.
  //
  // If the timeout triggers, Envoy will close the connection's socket.
  //
  // The default timeout is 1000 ms if this option is not specified.
  //
  // .. NOTE::
  //    To be useful in avoiding the race condition described above, this timeout must be set
  //    to *at least* <max round trip time expected between clients and Envoy>+<100ms to account for
  //    a reasonable "worst" case processing time for a full iteration of Envoy's event loop>.
  //
  // .. WARNING::
  //    A value of 0 will completely disable delayed close processing. When disabled, the downstream
  //    connection's socket will be closed immediately after the write flush is completed or will
  //    never close if the write flush does not complete.
  google.protobuf.Duration delayed_close_timeout = 26;

  // Configuration for :ref:`HTTP access logs <arch_overview_access_logs>`
  // emitted by the connection manager.
  repeated accesslog.v2.AccessLog access_log = 13;

  // If set to true, the connection manager will use the real remote address
  // of the client connection when determining internal versus external origin and manipulating
  // various headers. If set to false or absent, the connection manager will use the
  // :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
  // :ref:`config_http_conn_man_headers_x-forwarded-for`,
  // :ref:`config_http_conn_man_headers_x-envoy-internal`, and
  // :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
  google.protobuf.BoolValue use_remote_address = 14;

  // The number of additional ingress proxy hops from the right side of the
  // :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
  // determining the origin client's IP address. The default is zero if this option
  // is not specified. See the documentation for
  // :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
  uint32 xff_num_trusted_hops = 19;

  // Configures what network addresses are considered internal for stats and header sanitation
  // purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
  // See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
  // information about internal/external addresses.
  InternalAddressConfig internal_address_config = 25;

  // If set, Envoy will not append the remote address to the
  // :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
  // conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
  // has mutated the request headers. While :ref:`use_remote_address
  // <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.use_remote_address>`
  // will also suppress XFF addition, it has consequences for logging and other
  // Envoy uses of the remote address, so *skip_xff_append* should be used
  // when only an elision of XFF addition is intended.
  bool skip_xff_append = 21;

  // Via header value to append to request and response headers. If this is
  // empty, no via header will be appended.
  string via = 22;

  // Whether the connection manager will generate the :ref:`x-request-id
  // <config_http_conn_man_headers_x-request-id>` header if it does not exist. This defaults to
  // true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
  // is not desired it can be disabled.
  google.protobuf.BoolValue generate_request_id = 15;

  // Whether the connection manager will keep the :ref:`x-request-id
  // <config_http_conn_man_headers_x-request-id>` header if passed for a request that is edge
  // (Edge request is the request from external clients to front Envoy) and not reset it, which
  // is the current Envoy behaviour. This defaults to false.
  bool preserve_external_request_id = 32;

  // How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
  // header.
  ForwardClientCertDetails forward_client_cert_details = 16
      [(validate.rules).enum = {defined_only: true}];

  // This field is valid only when :ref:`forward_client_cert_details
  // <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.forward_client_cert_details>`
  // is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
  // the client certificate to be forwarded. Note that in the
  // :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
  // *By* is always set when the client certificate presents the URI type Subject Alternative Name
  // value.
  SetCurrentClientCertDetails set_current_client_cert_details = 17;

  // If proxy_100_continue is true, Envoy will proxy incoming "Expect:
  // 100-continue" headers upstream, and forward "100 Continue" responses
  // downstream. If this is false or not set, Envoy will instead strip the
  // "Expect: 100-continue" header, and send a "100 Continue" response itself.
  bool proxy_100_continue = 18;

  // If
  // :ref:`use_remote_address
  // <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.use_remote_address>`
  // is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
  // an IPv4 address, the address will be mapped to IPv6 before it is appended to *x-forwarded-for*.
  // This is useful for testing compatibility of upstream services that parse the header value. For
  // example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
  // <https://tools.ietf.org/html/rfc4291#section-2.5.5.2>`_ for details. This will also affect the
  // :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
  // :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
  // <config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6>` for runtime
  // control.
  // [#not-implemented-hide:]
  bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = 20;

  repeated UpgradeConfig upgrade_configs = 23;

  // Should paths be normalized according to RFC 3986 before any processing of
  // requests by HTTP filters or routing? This affects the upstream *:path* header
  // as well. For paths that fail this check, Envoy will respond with 400 to
  // paths that are malformed. This defaults to false currently but will default
  // true in the future. When not specified, this value may be overridden by the
  // runtime variable
  // :ref:`http_connection_manager.normalize_path<config_http_conn_man_runtime_normalize_path>`.
  // See `Normalization and Comparison <https://tools.ietf.org/html/rfc3986#section-6>`_
  // for details of normalization.
  // Note that Envoy does not perform
  // `case normalization <https://tools.ietf.org/html/rfc3986#section-6.2.2.1>`_
  google.protobuf.BoolValue normalize_path = 30;

  // Determines if adjacent slashes in the path are merged into one before any processing of
  // requests by HTTP filters or routing. This affects the upstream *:path* header as well. Without
  // setting this option, incoming requests with path `//dir///file` will not match against route
  // with `prefix` match set to `/dir`. Defaults to `false`. Note that slash merging is not part of
  // `HTTP spec <https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
  bool merge_slashes = 33;

  // The configuration of the request ID extension. This includes operations such as
  // generation, validation, and associated tracing operations.
  //
  // If not set, Envoy uses the default UUID-based behavior:
  //
  // 1. Request ID is propagated using *x-request-id* header.
  //
  // 2. Request ID is a universally unique identifier (UUID).
  //
  // 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
  RequestIDExtension request_id_extension = 36;
}

message Rds {
  // Configuration source specifier for RDS.
  api.v2.core.ConfigSource config_source = 1 [(validate.rules).message = {required: true}];

  // The name of the route configuration. This name will be passed to the RDS
  // API. This allows an Envoy configuration with multiple HTTP listeners (and
  // associated HTTP connection manager filters) to use different route
  // configurations.
  string route_config_name = 2 [(validate.rules).string = {min_bytes: 1}];
}

// This message is used to work around the limitations with 'oneof' and repeated fields.
message ScopedRouteConfigurationsList {
  repeated api.v2.ScopedRouteConfiguration scoped_route_configurations = 1
      [(validate.rules).repeated = {min_items: 1}];
}

// [#next-free-field: 6]
message ScopedRoutes {
  // Specifies the mechanism for constructing "scope keys" based on HTTP request attributes. These
  // keys are matched against a set of :ref:`Key<envoy_api_msg_ScopedRouteConfiguration.Key>`
  // objects assembled from :ref:`ScopedRouteConfiguration<envoy_api_msg_ScopedRouteConfiguration>`
  // messages distributed via SRDS (the Scoped Route Discovery Service) or assigned statically via
  // :ref:`scoped_route_configurations_list<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scoped_route_configurations_list>`.
  //
  // Upon receiving a request's headers, the Router will build a key using the algorithm specified
  // by this message. This key will be used to look up the routing table (i.e., the
  // :ref:`RouteConfiguration<envoy_api_msg_RouteConfiguration>`) to use for the request.
  message ScopeKeyBuilder {
    // Specifies the mechanism for constructing key fragments which are composed into scope keys.
    message FragmentBuilder {
      // Specifies how the value of a header should be extracted.
      // The following example maps the structure of a header to the fields in this message.
      //
      // .. code::
      //
      //              <0> <1>   <-- index
      //    X-Header: a=b;c=d
      //    |         || |
      //    |         || \----> <element_separator>
      //    |         ||
      //    |         |\----> <element.separator>
      //    |         |
      //    |         \----> <element.key>
      //    |
      //    \----> <name>
      //
      //    Each 'a=b' key-value pair constitutes an 'element' of the header field.
      message HeaderValueExtractor {
        // Specifies a header field's key value pair to match on.
        message KvElement {
          // The separator between key and value (e.g., '=' separates 'k=v;...').
          // If an element is an empty string, the element is ignored.
          // If an element contains no separator, the whole element is parsed as key and the
          // fragment value is an empty string.
          // If there are multiple values for a matched key, the first value is returned.
          string separator = 1 [(validate.rules).string = {min_bytes: 1}];

          // The key to match on.
          string key = 2 [(validate.rules).string = {min_bytes: 1}];
        }

        // The name of the header field to extract the value from.
        //
        // .. note::
        //
        //   If the header appears multiple times only the first value is used.
        string name = 1 [(validate.rules).string = {min_bytes: 1}];

        // The element separator (e.g., ';' separates 'a;b;c;d').
        // Default: empty string. This causes the entirety of the header field to be extracted.
        // If this field is set to an empty string and 'index' is used in the oneof below, 'index'
        // must be set to 0.
        string element_separator = 2;

        oneof extract_type {
          // Specifies the zero based index of the element to extract.
          // Note Envoy concatenates multiple values of the same header key into a comma separated
          // string, the splitting always happens after the concatenation.
          uint32 index = 3;

          // Specifies the key value pair to extract the value from.
          KvElement element = 4;
        }
      }

      oneof type {
        option (validate.required) = true;

        // Specifies how a header field's value should be extracted.
        HeaderValueExtractor header_value_extractor = 1;
      }
    }

    // The final(built) scope key consists of the ordered union of these fragments, which are compared in order with the
    // fragments of a :ref:`ScopedRouteConfiguration<envoy_api_msg_ScopedRouteConfiguration>`.
    // A missing fragment during comparison will make the key invalid, i.e., the computed key doesn't match any key.
    repeated FragmentBuilder fragments = 1 [(validate.rules).repeated = {min_items: 1}];
  }

  // The name assigned to the scoped routing configuration.
  string name = 1 [(validate.rules).string = {min_bytes: 1}];

  // The algorithm to use for constructing a scope key for each request.
  ScopeKeyBuilder scope_key_builder = 2 [(validate.rules).message = {required: true}];

  // Configuration source specifier for RDS.
  // This config source is used to subscribe to RouteConfiguration resources specified in
  // ScopedRouteConfiguration messages.
  api.v2.core.ConfigSource rds_config_source = 3 [(validate.rules).message = {required: true}];

  oneof config_specifier {
    option (validate.required) = true;

    // The set of routing scopes corresponding to the HCM. A scope is assigned to a request by
    // matching a key constructed from the request's attributes according to the algorithm specified
    // by the
    // :ref:`ScopeKeyBuilder<envoy_api_msg_config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder>`
    // in this message.
    ScopedRouteConfigurationsList scoped_route_configurations_list = 4;

    // The set of routing scopes associated with the HCM will be dynamically loaded via the SRDS
    // API. A scope is assigned to a request by matching a key constructed from the request's
    // attributes according to the algorithm specified by the
    // :ref:`ScopeKeyBuilder<envoy_api_msg_config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder>`
    // in this message.
    ScopedRds scoped_rds = 5;
  }
}

message ScopedRds {
  // Configuration source specifier for scoped RDS.
  api.v2.core.ConfigSource scoped_rds_config_source = 1
      [(validate.rules).message = {required: true}];
}

message HttpFilter {
  reserved 3;

  // The name of the filter to instantiate. The name must match a
  // :ref:`supported filter <config_http_filters>`.
  string name = 1 [(validate.rules).string = {min_bytes: 1}];

  // Filter specific configuration which depends on the filter being instantiated. See the supported
  // filters for further documentation.
  oneof config_type {
    google.protobuf.Struct config = 2 [deprecated = true];

    google.protobuf.Any typed_config = 4;
  }
}

message RequestIDExtension {
  // Request ID extension specific configuration.
  google.protobuf.Any typed_config = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/api/v2:pkg",
        "//envoy/api/v2/core:pkg",
        "//envoy/config/filter/accesslog/v2:pkg",
        "//envoy/config/trace/v2:pkg",
        "//envoy/type:pkg",
        "//envoy/type/tracing/v2:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.network.dubbo_proxy.v2alpha1;

import "envoy/config/filter/network/dubbo_proxy/v2alpha1/route.proto";

import "google/protobuf/any.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.dubbo_proxy.v2alpha1";
option java_outer_classname = "DubboProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/dubbo_proxy/v2alpha1";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.dubbo_proxy.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Dubbo Proxy]
// Dubbo Proxy :ref:`configuration overview <config_network_filters_dubbo_proxy>`.
// [#extension: envoy.filters.network.dubbo_proxy]

// Dubbo Protocol types supported by Envoy.
enum ProtocolType {
  // the default protocol.
  Dubbo = 0;
}

// Dubbo Serialization types supported by Envoy.
enum SerializationType {
  // the default serialization protocol.
  Hessian2 = 0;
}

// [#next-free-field: 6]
message DubboProxy {
  // The human readable prefix to use when emitting statistics.
  string stat_prefix = 1 [(validate.rules).string = {min_bytes: 1}];

  // Configure the protocol used.
  ProtocolType protocol_type = 2 [(validate.rules).enum = {defined_only: true}];

  // Configure the serialization protocol used.
  SerializationType serialization_type = 3 [(validate.rules).enum = {defined_only: true}];

  // The route table for the connection manager is static and is specified in this property.
  repeated RouteConfiguration route_config = 4;

  // A list of individual Dubbo filters that make up the filter chain for requests made to the
  // Dubbo proxy. Order matters as the filters are processed sequentially. For backwards
  // compatibility, if no dubbo_filters are specified, a default Dubbo router filter
  // (`envoy.filters.dubbo.router`) is used.
  repeated DubboFilter dubbo_filters = 5;
}

// DubboFilter configures a Dubbo filter.
message DubboFilter {
  // The name of the filter to instantiate. The name must match a supported
  // filter.
  string name = 1 [(validate.rules).string = {min_bytes: 1}];

  // Filter specific configuration which depends on the filter being
  // instantiated. See the supported filters for further documentation.
  google.protobuf.Any config = 2;
}
syntax = "proto3";

package envoy.config.filter.network.dubbo_proxy.v2alpha1;

import "envoy/api/v2/route/route_components.proto";
import "envoy/type/matcher/string.proto";
import "envoy/type/range.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.dubbo_proxy.v2alpha1";
option java_outer_classname = "RouteProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/dubbo_proxy/v2alpha1";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.dubbo_proxy.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Dubbo Proxy Route Configuration]
// Dubbo Proxy :ref:`configuration overview <config_network_filters_dubbo_proxy>`.

// [#next-free-field: 6]
message RouteConfiguration {
  // The name of the route configuration. Reserved for future use in asynchronous route discovery.
  string name = 1;

  // The interface name of the service.
  string interface = 2;

  // Which group does the interface belong to.
  string group = 3;

  // The version number of the interface.
  string version = 4;

  // The list of routes that will be matched, in order, against incoming requests. The first route
  // that matches will be used.
  repeated Route routes = 5;
}

message Route {
  // Route matching parameters.
  RouteMatch match = 1 [(validate.rules).message = {required: true}];

  // Route request to some upstream cluster.
  RouteAction route = 2 [(validate.rules).message = {required: true}];
}

message RouteMatch {
  // Method level routing matching.
  MethodMatch method = 1;

  // Specifies a set of headers that the route should match on. The router will check the requests
  // headers against all the specified headers in the route config. A match will happen if all the
  // headers in the route are present in the request with the same values (or based on presence if
  // the value field is not in the config).
  repeated api.v2.route.HeaderMatcher headers = 2;
}

message RouteAction {
  oneof cluster_specifier {
    option (validate.required) = true;

    // Indicates the upstream cluster to which the request should be routed.
    string cluster = 1;

    // Multiple upstream clusters can be specified for a given route. The
    // request is routed to one of the upstream clusters based on weights
    // assigned to each cluster.
    // Currently ClusterWeight only supports the name and weight fields.
    api.v2.route.WeightedCluster weighted_clusters = 2;
  }
}

message MethodMatch {
  // The parameter matching type.
  message ParameterMatchSpecifier {
    oneof parameter_match_specifier {
      // If specified, header match will be performed based on the value of the header.
      string exact_match = 3;

      // If specified, header match will be performed based on range.
      // The rule will match if the request header value is within this range.
      // The entire request header value must represent an integer in base 10 notation: consisting
      // of an optional plus or minus sign followed by a sequence of digits. The rule will not match
      // if the header value does not represent an integer. Match will fail for empty values,
      // floating point numbers or if only a subsequence of the header value is an integer.
      //
      // Examples:
      //
      // * For range [-10,0), route will match for header value -1, but not for 0,
      //   "somestring", 10.9, "-1somestring"
      type.Int64Range range_match = 4;
    }
  }

  // The name of the method.
  type.matcher.StringMatcher name = 1;

  // Method parameter definition.
  // The key is the parameter index, starting from 0.
  // The value is the parameter matching type.
  map<uint32, ParameterMatchSpecifier> params_match = 2;
}
Protocol buffer definitions for the Dubbo proxy.
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/route:pkg",
        "//envoy/type:pkg",
        "//envoy/type/matcher:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.network.ext_authz.v2;

import "envoy/api/v2/core/grpc_service.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.ext_authz.v2";
option java_outer_classname = "ExtAuthzProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/ext_authz/v2;ext_authzv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.ext_authz.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Network External Authorization ]
// The network layer external authorization service configuration
// :ref:`configuration overview <config_network_filters_ext_authz>`.
// [#extension: envoy.filters.network.ext_authz]

// External Authorization filter calls out to an external service over the
// gRPC Authorization API defined by
// :ref:`CheckRequest <envoy_api_msg_service.auth.v2.CheckRequest>`.
// A failed check will cause this filter to close the TCP connection.
message ExtAuthz {
  // The prefix to use when emitting statistics.
  string stat_prefix = 1 [(validate.rules).string = {min_bytes: 1}];

  // The external authorization gRPC service configuration.
  // The default timeout is set to 200ms by this filter.
  api.v2.core.GrpcService grpc_service = 2;

  // The filter's behaviour in case the external authorization service does
  // not respond back. When it is set to true, Envoy will also allow traffic in case of
  // communication failure between authorization service and the proxy.
  // Defaults to false.
  bool failure_mode_allow = 3;

  // Specifies if the peer certificate is sent to the external service.
  //
  // When this field is true, Envoy will include the peer X.509 certificate, if available, in the
  // :ref:`certificate<envoy_api_field_service.auth.v2.AttributeContext.Peer.certificate>`.
  bool include_peer_certificate = 4;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "//envoy/type:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.network.local_rate_limit.v2alpha;

import "envoy/api/v2/core/base.proto";
import "envoy/type/token_bucket.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.local_rate_limit.v2alpha";
option java_outer_classname = "LocalRateLimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/local_rate_limit/v2alpha";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.local_ratelimit.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Local rate limit]
// Local rate limit :ref:`configuration overview <config_network_filters_local_rate_limit>`.
// [#extension: envoy.filters.network.local_ratelimit]

message LocalRateLimit {
  // The prefix to use when emitting :ref:`statistics
  // <config_network_filters_local_rate_limit_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_bytes: 1}];

  // The token bucket configuration to use for rate limiting connections that are processed by the
  // filter's filter chain. Each incoming connection processed by the filter consumes a single
  // token. If the token is available, the connection will be allowed. If no tokens are available,
  // the connection will be immediately closed.
  //
  // .. note::
  //   In the current implementation each filter and filter chain has an independent rate limit.
  //
  // .. note::
  //   In the current implementation the token bucket's :ref:`fill_interval
  //   <envoy_api_field_type.TokenBucket.fill_interval>` must be >= 50ms to avoid too aggressive
  //   refills.
  type.TokenBucket token_bucket = 2 [(validate.rules).message = {required: true}];

  // Runtime flag that controls whether the filter is enabled or not. If not specified, defaults
  // to enabled.
  api.v2.core.RuntimeFeatureFlag runtime_enabled = 3;
}
syntax = "proto3";

package envoy.config.filter.network.kafka_broker.v2alpha1;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.kafka_broker.v2alpha1";
option java_outer_classname = "KafkaBrokerProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/kafka_broker/v2alpha1";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.kafka_broker.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Kafka Broker]
// Kafka Broker :ref:`configuration overview <config_network_filters_kafka_broker>`.
// [#extension: envoy.filters.network.kafka_broker]

message KafkaBroker {
  // The prefix to use when emitting :ref:`statistics <config_network_filters_kafka_broker_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_bytes: 1}];

  // Set to true if broker filter should attempt to serialize the received responses from the
  // upstream broker instead of passing received bytes as is.
  // Disabled by default.
  bool force_response_rewrite = 2;

  // Optional broker address rewrite specification.
  // Allows the broker filter to rewrite Kafka responses so that all connections established by
  // the Kafka clients point to Envoy.
  // This allows Kafka cluster not to configure its 'advertised.listeners' property
  // (as the necessary re-pointing will be done by this filter).
  // This collection of rules should cover all brokers in the cluster that is being proxied,
  // otherwise some nodes' addresses might leak to the downstream clients.
  oneof broker_address_rewrite_spec {
    // Broker address rewrite rules that match by broker ID.
    IdBasedBrokerRewriteSpec id_based_broker_address_rewrite_spec = 3;
  }
}

// Collection of rules matching by broker ID.
message IdBasedBrokerRewriteSpec {
  repeated IdBasedBrokerRewriteRule rules = 1;
}

// Defines a rule to rewrite broker address data.
message IdBasedBrokerRewriteRule {
  // Broker ID to match.
  uint32 id = 1 [(validate.rules).uint32 = {gte: 0}];

  // The host value to use (resembling the host part of Kafka's advertised.listeners).
  // The value should point to the Envoy (not Kafka) listener, so that all client traffic goes
  // through Envoy.
  string host = 2 [(validate.rules).string = {min_len: 1}];

  // The port value to use (resembling the port part of Kafka's advertised.listeners).
  // The value should point to the Envoy (not Kafka) listener, so that all client traffic goes
  // through Envoy.
  uint32 port = 3 [(validate.rules).uint32 = {lte: 65535}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.network.rate_limit.v2;

import "envoy/api/v2/ratelimit/ratelimit.proto";
import "envoy/config/ratelimit/v2/rls.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.rate_limit.v2";
option java_outer_classname = "RateLimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/rate_limit/v2;rate_limitv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.ratelimit.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Rate limit]
// Rate limit :ref:`configuration overview <config_network_filters_rate_limit>`.
// [#extension: envoy.filters.network.ratelimit]

// [#next-free-field: 7]
message RateLimit {
  // The prefix to use when emitting :ref:`statistics <config_network_filters_rate_limit_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_bytes: 1}];

  // The rate limit domain to use in the rate limit service request.
  string domain = 2 [(validate.rules).string = {min_bytes: 1}];

  // The rate limit descriptor list to use in the rate limit service request.
  repeated api.v2.ratelimit.RateLimitDescriptor descriptors = 3
      [(validate.rules).repeated = {min_items: 1}];

  // The timeout in milliseconds for the rate limit service RPC. If not
  // set, this defaults to 20ms.
  google.protobuf.Duration timeout = 4;

  // The filter's behaviour in case the rate limiting service does
  // not respond back. When it is set to true, Envoy will not allow traffic in case of
  // communication failure between rate limiting service and the proxy.
  // Defaults to false.
  bool failure_mode_deny = 5;

  // Configuration for an external rate limit service provider. If not
  // specified, any calls to the rate limit service will immediately return
  // success.
  ratelimit.v2.RateLimitServiceConfig rate_limit_service = 6
      [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/ratelimit:pkg",
        "//envoy/config/ratelimit/v2:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.network.client_ssl_auth.v2;

import "envoy/api/v2/core/address.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.client_ssl_auth.v2";
option java_outer_classname = "ClientSslAuthProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/client_ssl_auth/v2;client_ssl_authv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.client_ssl_auth.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Client TLS authentication]
// Client TLS authentication
// :ref:`configuration overview <config_network_filters_client_ssl_auth>`.
// [#extension: envoy.filters.network.client_ssl_auth]

message ClientSSLAuth {
  // The :ref:`cluster manager <arch_overview_cluster_manager>` cluster that runs
  // the authentication service. The filter will connect to the service every 60s to fetch the list
  // of principals. The service must support the expected :ref:`REST API
  // <config_network_filters_client_ssl_auth_rest_api>`.
  string auth_api_cluster = 1 [(validate.rules).string = {min_bytes: 1}];

  // The prefix to use when emitting :ref:`statistics
  // <config_network_filters_client_ssl_auth_stats>`.
  string stat_prefix = 2 [(validate.rules).string = {min_bytes: 1}];

  // Time in milliseconds between principal refreshes from the
  // authentication service. Default is 60000 (60s). The actual fetch time
  // will be this value plus a random jittered value between
  // 0-refresh_delay_ms milliseconds.
  google.protobuf.Duration refresh_delay = 3;

  // An optional list of IP address and subnet masks that should be white
  // listed for access by the filter. If no list is provided, there is no
  // IP allowlist.
  repeated api.v2.core.CidrRange ip_white_list = 4;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.network.direct_response.v2;

import "envoy/api/v2/core/base.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.direct_response.v2";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/direct_response/v2;direct_responsev2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.direct_response.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Direct response]
// Direct response :ref:`configuration overview <config_network_filters_direct_response>`.
// [#extension: envoy.filters.network.direct_response]

message Config {
  // Response data as a data source.
  api.v2.core.DataSource response = 1;
}
syntax = "proto3";

package envoy.config.filter.network.sni_cluster.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.sni_cluster.v2";
option java_outer_classname = "SniClusterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/sni_cluster/v2;sni_clusterv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.sni_cluster.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: SNI Cluster Filter]
// Set the upstream cluster name from the SNI field in the TLS connection.
// [#extension: envoy.filters.network.sni_cluster]

message SniCluster {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.network.mysql_proxy.v1alpha1;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.mysql_proxy.v1alpha1";
option java_outer_classname = "MysqlProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/mysql_proxy/v1alpha1";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.mysql_proxy.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: MySQL proxy]
// MySQL Proxy :ref:`configuration overview <config_network_filters_mysql_proxy>`.
// [#extension: envoy.filters.network.mysql_proxy]

message MySQLProxy {
  // The human readable prefix to use when emitting :ref:`statistics
  // <config_network_filters_mysql_proxy_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_bytes: 1}];

  // [#not-implemented-hide:] The optional path to use for writing MySQL access logs.
  // If the access log field is empty, access logs will not be written.
  string access_log = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.network.thrift_proxy.v2alpha1;

import "envoy/api/v2/core/base.proto";
import "envoy/api/v2/route/route_components.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.thrift_proxy.v2alpha1";
option java_outer_classname = "RouteProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/thrift_proxy/v2alpha1";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.thrift_proxy.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Thrift Proxy Route Configuration]
// Thrift Proxy :ref:`configuration overview <config_network_filters_thrift_proxy>`.

message RouteConfiguration {
  // The name of the route configuration. Reserved for future use in asynchronous route discovery.
  string name = 1;

  // The list of routes that will be matched, in order, against incoming requests. The first route
  // that matches will be used.
  repeated Route routes = 2;
}

message Route {
  // Route matching parameters.
  RouteMatch match = 1 [(validate.rules).message = {required: true}];

  // Route request to some upstream cluster.
  RouteAction route = 2 [(validate.rules).message = {required: true}];
}

message RouteMatch {
  oneof match_specifier {
    option (validate.required) = true;

    // If specified, the route must exactly match the request method name. As a special case, an
    // empty string matches any request method name.
    string method_name = 1;

    // If specified, the route must have the service name as the request method name prefix. As a
    // special case, an empty string matches any service name. Only relevant when service
    // multiplexing.
    string service_name = 2;
  }

  // Inverts whatever matching is done in the :ref:`method_name
  // <envoy_api_field_config.filter.network.thrift_proxy.v2alpha1.RouteMatch.method_name>` or
  // :ref:`service_name
  // <envoy_api_field_config.filter.network.thrift_proxy.v2alpha1.RouteMatch.service_name>` fields.
  // Cannot be combined with wildcard matching as that would result in routes never being matched.
  //
  // .. note::
  //
  //   This does not invert matching done as part of the :ref:`headers field
  //   <envoy_api_field_config.filter.network.thrift_proxy.v2alpha1.RouteMatch.headers>` field. To
  //   invert header matching, see :ref:`invert_match
  //   <envoy_api_field_route.HeaderMatcher.invert_match>`.
  bool invert = 3;

  // Specifies a set of headers that the route should match on. The router will check the requests
  // headers against all the specified headers in the route config. A match will happen if all the
  // headers in the route are present in the request with the same values (or based on presence if
  // the value field is not in the config). Note that this only applies for Thrift transports and/or
  // protocols that support headers.
  repeated api.v2.route.HeaderMatcher headers = 4;
}

// [#next-free-field: 7]
message RouteAction {
  oneof cluster_specifier {
    option (validate.required) = true;

    // Indicates a single upstream cluster to which the request should be routed
    // to.
    string cluster = 1 [(validate.rules).string = {min_bytes: 1}];

    // Multiple upstream clusters can be specified for a given route. The
    // request is routed to one of the upstream clusters based on weights
    // assigned to each cluster.
    WeightedCluster weighted_clusters = 2;

    // Envoy will determine the cluster to route to by reading the value of the
    // Thrift header named by cluster_header from the request headers. If the
    // header is not found or the referenced cluster does not exist Envoy will
    // respond with an unknown method exception or an internal error exception,
    // respectively.
    string cluster_header = 6 [(validate.rules).string = {min_bytes: 1}];
  }

  // Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
  // the upstream cluster with metadata matching what is set in this field will be considered.
  // Note that this will be merged with what's provided in :ref:`WeightedCluster.metadata_match
  // <envoy_api_field_config.filter.network.thrift_proxy.v2alpha1.WeightedCluster.ClusterWeight.metadata_match>`,
  // with values there taking precedence. Keys and values should be provided under the "envoy.lb"
  // metadata key.
  api.v2.core.Metadata metadata_match = 3;

  // Specifies a set of rate limit configurations that could be applied to the route.
  // N.B. Thrift service or method name matching can be achieved by specifying a RequestHeaders
  // action with the header name ":method-name".
  repeated api.v2.route.RateLimit rate_limits = 4;

  // Strip the service prefix from the method name, if there's a prefix. For
  // example, the method call Service:method would end up being just method.
  bool strip_service_name = 5;
}

// Allows for specification of multiple upstream clusters along with weights that indicate the
// percentage of traffic to be forwarded to each cluster. The router selects an upstream cluster
// based on these weights.
message WeightedCluster {
  message ClusterWeight {
    // Name of the upstream cluster.
    string name = 1 [(validate.rules).string = {min_bytes: 1}];

    // When a request matches the route, the choice of an upstream cluster is determined by its
    // weight. The sum of weights across all entries in the clusters array determines the total
    // weight.
    google.protobuf.UInt32Value weight = 2 [(validate.rules).uint32 = {gte: 1}];

    // Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
    // the upstream cluster with metadata matching what is set in this field, combined with what's
    // provided in :ref:`RouteAction's metadata_match
    // <envoy_api_field_config.filter.network.thrift_proxy.v2alpha1.RouteAction.metadata_match>`,
    // will be considered. Values here will take precedence. Keys and values should be provided
    // under the "envoy.lb" metadata key.
    api.v2.core.Metadata metadata_match = 3;
  }

  // Specifies one or more upstream clusters associated with the route.
  repeated ClusterWeight clusters = 1 [(validate.rules).repeated = {min_items: 1}];
}
Protocol buffer definitions for the Thrift proxy.
syntax = "proto3";

package envoy.config.filter.network.thrift_proxy.v2alpha1;

import "envoy/config/filter/network/thrift_proxy/v2alpha1/route.proto";

import "google/protobuf/any.proto";
import "google/protobuf/struct.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.network.thrift_proxy.v2alpha1";
option java_outer_classname = "ThriftProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/network/thrift_proxy/v2alpha1";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.thrift_proxy.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Thrift Proxy]
// Thrift Proxy :ref:`configuration overview <config_network_filters_thrift_proxy>`.
// [#extension: envoy.filters.network.thrift_proxy]

// Thrift transport types supported by Envoy.
enum TransportType {
  // For downstream connections, the Thrift proxy will attempt to determine which transport to use.
  // For upstream connections, the Thrift proxy will use same transport as the downstream
  // connection.
  AUTO_TRANSPORT = 0;

  // The Thrift proxy will use the Thrift framed transport.
  FRAMED = 1;

  // The Thrift proxy will use the Thrift unframed transport.
  UNFRAMED = 2;

  // The Thrift proxy will assume the client is using the Thrift header transport.
  HEADER = 3;
}

// Thrift Protocol types supported by Envoy.
enum ProtocolType {
  // For downstream connections, the Thrift proxy will attempt to determine which protocol to use.
  // Note that the older, non-strict (or lax) binary protocol is not included in automatic protocol
  // detection. For upstream connections, the Thrift proxy will use the same protocol as the
  // downstream connection.
  AUTO_PROTOCOL = 0;

  // The Thrift proxy will use the Thrift binary protocol.
  BINARY = 1;

  // The Thrift proxy will use Thrift non-strict binary protocol.
  LAX_BINARY = 2;

  // The Thrift proxy will use the Thrift compact protocol.
  COMPACT = 3;

  // The Thrift proxy will use the Thrift "Twitter" protocol implemented by the finagle library.
  TWITTER = 4;
}

// [#next-free-field: 6]
message ThriftProxy {
  // Supplies the type of transport that the Thrift proxy should use. Defaults to
  // :ref:`AUTO_TRANSPORT<envoy_api_enum_value_config.filter.network.thrift_proxy.v2alpha1.TransportType.AUTO_TRANSPORT>`.
  TransportType transport = 2 [(validate.rules).enum = {defined_only: true}];

  // Supplies the type of protocol that the Thrift proxy should use. Defaults to
  // :ref:`AUTO_PROTOCOL<envoy_api_enum_value_config.filter.network.thrift_proxy.v2alpha1.ProtocolType.AUTO_PROTOCOL>`.
  ProtocolType protocol = 3 [(validate.rules).enum = {defined_only: true}];

  // The human readable prefix to use when emitting statistics.
  string stat_prefix = 1 [(validate.rules).string = {min_bytes: 1}];

  // The route table for the connection manager is static and is specified in this property.
  RouteConfiguration route_config = 4;

  // A list of individual Thrift filters that make up the filter chain for requests made to the
  // Thrift proxy. Order matters as the filters are processed sequentially. For backwards
  // compatibility, if no thrift_filters are specified, a default Thrift router filter
  // (`envoy.filters.thrift.router`) is used.
  repeated ThriftFilter thrift_filters = 5;
}

// ThriftFilter configures a Thrift filter.
message ThriftFilter {
  // The name of the filter to instantiate. The name must match a supported
  // filter. The built-in filters are:
  //
  // [#comment:TODO(zuercher): Auto generate the following list]
  // * :ref:`envoy.filters.thrift.router <config_thrift_filters_router>`
  // * :ref:`envoy.filters.thrift.rate_limit <config_thrift_filters_rate_limit>`
  string name = 1 [(validate.rules).string = {min_bytes: 1}];

  // Filter specific configuration which depends on the filter being instantiated. See the supported
  // filters for further documentation.
  oneof config_type {
    google.protobuf.Struct config = 2 [deprecated = true];

    google.protobuf.Any typed_config = 3;
  }
}

// ThriftProtocolOptions specifies Thrift upstream protocol options. This object is used in
// in
// :ref:`typed_extension_protocol_options<envoy_api_field_Cluster.typed_extension_protocol_options>`,
// keyed by the name `envoy.filters.network.thrift_proxy`.
message ThriftProtocolOptions {
  // Supplies the type of transport that the Thrift proxy should use for upstream connections.
  // Selecting
  // :ref:`AUTO_TRANSPORT<envoy_api_enum_value_config.filter.network.thrift_proxy.v2alpha1.TransportType.AUTO_TRANSPORT>`,
  // which is the default, causes the proxy to use the same transport as the downstream connection.
  TransportType transport = 1 [(validate.rules).enum = {defined_only: true}];

  // Supplies the type of protocol that the Thrift proxy should use for upstream connections.
  // Selecting
  // :ref:`AUTO_PROTOCOL<envoy_api_enum_value_config.filter.network.thrift_proxy.v2alpha1.ProtocolType.AUTO_PROTOCOL>`,
  // which is the default, causes the proxy to use the same protocol as the downstream connection.
  ProtocolType protocol = 2 [(validate.rules).enum = {defined_only: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "//envoy/api/v2/route:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
Protocol buffer definitions for filters.

Visibility of the definitions should be constrained to none except for
shared definitions between explicitly enumerated filters (e.g. accesslog and fault definitions).
syntax = "proto3";

package envoy.config.filter.thrift.rate_limit.v2alpha1;

import "envoy/config/ratelimit/v2/rls.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.thrift.rate_limit.v2alpha1";
option java_outer_classname = "RateLimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/thrift/rate_limit/v2alpha1";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.thrift_proxy.filters.ratelimit.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Rate limit]
// Rate limit :ref:`configuration overview <config_thrift_filters_rate_limit>`.
// [#extension: envoy.filters.thrift.rate_limit]

// [#next-free-field: 6]
message RateLimit {
  // The rate limit domain to use in the rate limit service request.
  string domain = 1 [(validate.rules).string = {min_bytes: 1}];

  // Specifies the rate limit configuration stage. Each configured rate limit filter performs a
  // rate limit check using descriptors configured in the
  // :ref:`envoy_api_msg_config.filter.network.thrift_proxy.v2alpha1.RouteAction` for the request.
  // Only those entries with a matching stage number are used for a given filter. If not set, the
  // default stage number is 0.
  //
  // .. note::
  //
  //  The filter supports a range of 0 - 10 inclusively for stage numbers.
  uint32 stage = 2 [(validate.rules).uint32 = {lte: 10}];

  // The timeout in milliseconds for the rate limit service RPC. If not
  // set, this defaults to 20ms.
  google.protobuf.Duration timeout = 3;

  // The filter's behaviour in case the rate limiting service does
  // not respond back. When it is set to true, Envoy will not allow traffic in case of
  // communication failure between rate limiting service and the proxy.
  // Defaults to false.
  bool failure_mode_deny = 4;

  // Configuration for an external rate limit service provider. If not
  // specified, any calls to the rate limit service will immediately return
  // success.
  ratelimit.v2.RateLimitServiceConfig rate_limit_service = 5
      [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/ratelimit/v2:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.thrift.router.v2alpha1;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.thrift.router.v2alpha1";
option java_outer_classname = "RouterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/thrift/router/v2alpha1";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Router]
// Thrift router :ref:`configuration overview <config_thrift_filters_router>`.
// [#extension: envoy.filters.thrift.router]

message Router {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.http.header_to_metadata.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.header_to_metadata.v2";
option java_outer_classname = "HeaderToMetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/header_to_metadata/v2;header_to_metadatav2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.header_to_metadata.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Header-To-Metadata Filter]
//
// The configuration for transforming headers into metadata. This is useful
// for matching load balancer subsets, logging, etc.
//
// Header to Metadata :ref:`configuration overview <config_http_filters_header_to_metadata>`.
// [#extension: envoy.filters.http.header_to_metadata]

message Config {
  enum ValueType {
    STRING = 0;

    NUMBER = 1;

    // The value is a serialized `protobuf.Value
    // <https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/struct.proto#L62>`_.
    PROTOBUF_VALUE = 2;
  }

  // ValueEncode defines the encoding algorithm.
  enum ValueEncode {
    // The value is not encoded.
    NONE = 0;

    // The value is encoded in `Base64 <https://tools.ietf.org/html/rfc4648#section-4>`_.
    // Note: this is mostly used for STRING and PROTOBUF_VALUE to escape the
    // non-ASCII characters in the header.
    BASE64 = 1;
  }

  // [#next-free-field: 6]
  message KeyValuePair {
    // The namespace  if this is empty, the filter's namespace will be used.
    string metadata_namespace = 1;

    // The key to use within the namespace.
    string key = 2 [(validate.rules).string = {min_bytes: 1}];

    // The value to pair with the given key.
    //
    // When used for a `on_header_present` case, if value is non-empty it'll be used
    // instead of the header value. If both are empty, no metadata is added.
    //
    // When used for a `on_header_missing` case, a non-empty value must be provided
    // otherwise no metadata is added.
    string value = 3;

    // The value's type  defaults to string.
    ValueType type = 4;

    // How is the value encoded, default is NONE (not encoded).
    // The value will be decoded accordingly before storing to metadata.
    ValueEncode encode = 5;
  }

  // A Rule defines what metadata to apply when a header is present or missing.
  message Rule {
    // The header that triggers this rule  required.
    string header = 1
        [(validate.rules).string = {min_bytes: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

    // If the header is present, apply this metadata KeyValuePair.
    //
    // If the value in the KeyValuePair is non-empty, it'll be used instead
    // of the header value.
    KeyValuePair on_header_present = 2;

    // If the header is not present, apply this metadata KeyValuePair.
    //
    // The value in the KeyValuePair must be set, since it'll be used in lieu
    // of the missing header value.
    KeyValuePair on_header_missing = 3;

    // Whether or not to remove the header after a rule is applied.
    //
    // This prevents headers from leaking.
    bool remove = 4;
  }

  // The list of rules to apply to requests.
  repeated Rule request_rules = 1;

  // The list of rules to apply to responses.
  repeated Rule response_rules = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/rbac/v2:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.http.rbac.v2;

import "envoy/config/rbac/v2/rbac.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.rbac.v2";
option java_outer_classname = "RbacProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/rbac/v2;rbacv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.http.rbac.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: RBAC]
// Role-Based Access Control :ref:`configuration overview <config_http_filters_rbac>`.
// [#extension: envoy.filters.http.rbac]

// RBAC filter config.
message RBAC {
  // Specify the RBAC rules to be applied globally.
  // If absent, no enforcing RBAC policy will be applied.
  config.rbac.v2.RBAC rules = 1;

  // Shadow rules are not enforced by the filter (i.e., returning a 403)
  // but will emit stats and logs and can be used for rule testing.
  // If absent, no shadow RBAC policy will be applied.
  config.rbac.v2.RBAC shadow_rules = 2;
}

message RBACPerRoute {
  reserved 1;

  // Override the global configuration of the filter with this new config.
  // If absent, the global RBAC policy will be disabled for this route.
  RBAC rbac = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.http.grpc_http1_bridge.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.grpc_http1_bridge.v2";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/grpc_http1_bridge/v2;grpc_http1_bridgev2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.grpc_http1_bridge.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: gRPC HTTP/1.1 Bridge]
// gRPC HTTP/1.1 Bridge Filter :ref:`configuration overview <config_http_filters_grpc_bridge>`.
// [#extension: envoy.filters.http.grpc_http1_bridge]

// gRPC HTTP/1.1 Bridge filter config.
message Config {
}
syntax = "proto3";

package envoy.config.filter.http.on_demand.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.on_demand.v2";
option java_outer_classname = "OnDemandProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/on_demand/v2;on_demandv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.on_demand.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: OnDemand]
// IP tagging :ref:`configuration overview <config_http_filters_on_demand>`.
// [#extension: envoy.filters.http.on_demand]

message OnDemand {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.http.original_src.v2alpha1;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.original_src.v2alpha1";
option java_outer_classname = "OriginalSrcProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/original_src/v2alpha1";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.original_src.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Original Src Filter]
// Use the Original source address on upstream connections.

// The Original Src filter binds upstream connections to the original source address determined
// for the request. This address could come from something like the Proxy Protocol filter, or it
// could come from trusted http headers.
// [#extension: envoy.filters.http.original_src]
message OriginalSrc {
  // Sets the SO_MARK option on the upstream connection's socket to the provided value. Used to
  // ensure that non-local addresses may be routed back through envoy when binding to the original
  // source address. The option will not be applied if the mark is 0.
  uint32 mark = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.http.cache.v2alpha;

import "envoy/api/v2/route/route_components.proto";
import "envoy/type/matcher/string.proto";

import "google/protobuf/any.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.cache.v2alpha";
option java_outer_classname = "CacheProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/cache/v2alpha";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.cache.v3alpha";
option (udpa.annotations.file_status).work_in_progress = true;
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: HTTP Cache Filter]
// [#extension: envoy.filters.http.cache]

message CacheConfig {
  // [#not-implemented-hide:]
  // Modifies cache key creation by restricting which parts of the URL are included.
  message KeyCreatorParams {
    // If true, exclude the URL scheme from the cache key. Set to true if your origins always
    // produce the same response for http and https requests.
    bool exclude_scheme = 1;

    // If true, exclude the host from the cache key. Set to true if your origins' responses don't
    // ever depend on host.
    bool exclude_host = 2;

    // If *query_parameters_included* is nonempty, only query parameters matched
    // by one or more of its matchers are included in the cache key. Any other
    // query params will not affect cache lookup.
    repeated api.v2.route.QueryParameterMatcher query_parameters_included = 3;

    // If *query_parameters_excluded* is nonempty, query parameters matched by one
    // or more of its matchers are excluded from the cache key (even if also
    // matched by *query_parameters_included*), and will not affect cache lookup.
    repeated api.v2.route.QueryParameterMatcher query_parameters_excluded = 4;
  }

  // Config specific to the cache storage implementation.
  google.protobuf.Any typed_config = 1 [(validate.rules).any = {required: true}];

  // List of matching rules that defines allowed *Vary* headers.
  //
  // The *vary* response header holds a list of header names that affect the
  // contents of a response, as described by
  // https://httpwg.org/specs/rfc7234.html#caching.negotiated.responses.
  //
  // During insertion, *allowed_vary_headers* acts as a allowlist: if a
  // response's *vary* header mentions any header names that aren't matched by any rules in
  // *allowed_vary_headers*, that response will not be cached.
  //
  // During lookup, *allowed_vary_headers* controls what request headers will be
  // sent to the cache storage implementation.
  repeated type.matcher.StringMatcher allowed_vary_headers = 2;

  // [#not-implemented-hide:]
  // <TODO(toddmgreer) implement key customization>
  //
  // Modifies cache key creation by restricting which parts of the URL are included.
  KeyCreatorParams key_creator_params = 3;

  // [#not-implemented-hide:]
  // <TODO(toddmgreer) implement size limit>
  //
  // Max body size the cache filter will insert into a cache. 0 means unlimited (though the cache
  // storage implementation may have its own limit beyond which it will reject insertions).
  uint32 max_body_bytes = 4;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/route:pkg",
        "//envoy/type/matcher:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.http.squash.v2;

import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.squash.v2";
option java_outer_classname = "SquashProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/squash/v2;squashv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.http.squash.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Squash]
// Squash :ref:`configuration overview <config_http_filters_squash>`.
// [#extension: envoy.filters.http.squash]

// [#next-free-field: 6]
message Squash {
  // The name of the cluster that hosts the Squash server.
  string cluster = 1 [(validate.rules).string = {min_bytes: 1}];

  // When the filter requests the Squash server to create a DebugAttachment, it will use this
  // structure as template for the body of the request. It can contain reference to environment
  // variables in the form of '{{ ENV_VAR_NAME }}'. These can be used to provide the Squash server
  // with more information to find the process to attach the debugger to. For example, in a
  // Istio/k8s environment, this will contain information on the pod:
  //
  // .. code-block:: json
  //
  //  {
  //    "spec": {
  //      "attachment": {
  //        "pod": "{{ POD_NAME }}",
  //        "namespace": "{{ POD_NAMESPACE }}"
  //      },
  //      "match_request": true
  //    }
  //  }
  //
  // (where POD_NAME, POD_NAMESPACE are configured in the pod via the Downward API)
  google.protobuf.Struct attachment_template = 2;

  // The timeout for individual requests sent to the Squash cluster. Defaults to 1 second.
  google.protobuf.Duration request_timeout = 3;

  // The total timeout Squash will delay a request and wait for it to be attached. Defaults to 60
  // seconds.
  google.protobuf.Duration attachment_timeout = 4;

  // Amount of time to poll for the status of the attachment object in the Squash server
  // (to check if has been attached). Defaults to 1 second.
  google.protobuf.Duration attachment_poll_period = 5;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.http.dynamic_forward_proxy.v2alpha;

import "envoy/config/common/dynamic_forward_proxy/v2alpha/dns_cache.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.dynamic_forward_proxy.v2alpha";
option java_outer_classname = "DynamicForwardProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/dynamic_forward_proxy/v2alpha";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.dynamic_forward_proxy.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Dynamic forward proxy]

// Configuration for the dynamic forward proxy HTTP filter. See the :ref:`architecture overview
// <arch_overview_http_dynamic_forward_proxy>` for more information.
// [#extension: envoy.filters.http.dynamic_forward_proxy]
message FilterConfig {
  // The DNS cache configuration that the filter will attach to. Note this configuration must
  // match that of associated :ref:`dynamic forward proxy cluster configuration
  // <envoy_api_field_config.cluster.dynamic_forward_proxy.v2alpha.ClusterConfig.dns_cache_config>`.
  common.dynamic_forward_proxy.v2alpha.DnsCacheConfig dns_cache_config = 1
      [(validate.rules).message = {required: true}];
}

// Per route Configuration for the dynamic forward proxy HTTP filter.
message PerRouteConfig {
  oneof host_rewrite_specifier {
    // Indicates that before DNS lookup, the host header will be swapped with
    // this value. If not set or empty, the original host header value
    // will be used and no rewrite will happen.
    //
    // Note: this rewrite affects both DNS lookup and host header forwarding. However, this
    // option shouldn't be used with
    // :ref:`HCM host rewrite <envoy_api_field_route.RouteAction.host_rewrite>` given that the
    // value set here would be used for DNS lookups whereas the value set in the HCM would be used
    // for host header forwarding which is not the desired outcome.
    string host_rewrite = 1 [(udpa.annotations.field_migrate).rename = "host_rewrite_literal"];

    // Indicates that before DNS lookup, the host header will be swapped with
    // the value of this header. If not set or empty, the original host header
    // value will be used and no rewrite will happen.
    //
    // Note: this rewrite affects both DNS lookup and host header forwarding. However, this
    // option shouldn't be used with
    // :ref:`HCM host rewrite header <envoy_api_field_route.RouteAction.auto_host_rewrite_header>`
    // given that the value set here would be used for DNS lookups whereas the value set in the HCM
    // would be used for host header forwarding which is not the desired outcome.
    //
    // .. note::
    //
    //   If the header appears multiple times only the first value is used.
    string auto_host_rewrite_header = 2
        [(udpa.annotations.field_migrate).rename = "host_rewrite_header"];
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/common/dynamic_forward_proxy/v2alpha:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.http.compressor.v2;

import "envoy/api/v2/core/base.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.compressor.v2";
option java_outer_classname = "CompressorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/compressor/v2;compressorv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.compressor.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Compressor]

// [#next-free-field: 6]
message Compressor {
  // Minimum response length, in bytes, which will trigger compression. The default value is 30.
  google.protobuf.UInt32Value content_length = 1;

  // Set of strings that allows specifying which mime-types yield compression; e.g.,
  // application/json, text/html, etc. When this field is not defined, compression will be applied
  // to the following mime-types: "application/javascript", "application/json",
  // "application/xhtml+xml", "image/svg+xml", "text/css", "text/html", "text/plain", "text/xml"
  // and their synonyms.
  repeated string content_type = 2;

  // If true, disables compression when the response contains an etag header. When it is false, the
  // filter will preserve weak etags and remove the ones that require strong validation.
  bool disable_on_etag_header = 3;

  // If true, removes accept-encoding from the request headers before dispatching it to the upstream
  // so that responses do not get compressed before reaching the filter.
  // .. attention:
  //
  //    To avoid interfering with other compression filters in the same chain use this option in
  //    the filter closest to the upstream.
  bool remove_accept_encoding_header = 4;

  // Runtime flag that controls whether the filter is enabled or not. If set to false, the
  // filter will operate as a pass-through filter. If not specified, defaults to enabled.
  api.v2.core.RuntimeFeatureFlag runtime_enabled = 5;
}
syntax = "proto3";

package envoy.config.filter.http.transcoder.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.transcoder.v2";
option java_outer_classname = "TranscoderProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/transcoder/v2;transcoderv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.grpc_json_transcoder.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: gRPC-JSON transcoder]
// gRPC-JSON transcoder :ref:`configuration overview <config_http_filters_grpc_json_transcoder>`.
// [#extension: envoy.filters.http.grpc_json_transcoder]

// [#next-free-field: 10]
message GrpcJsonTranscoder {
  message PrintOptions {
    // Whether to add spaces, line breaks and indentation to make the JSON
    // output easy to read. Defaults to false.
    bool add_whitespace = 1;

    // Whether to always print primitive fields. By default primitive
    // fields with default values will be omitted in JSON output. For
    // example, an int32 field set to 0 will be omitted. Setting this flag to
    // true will override the default behavior and print primitive fields
    // regardless of their values. Defaults to false.
    bool always_print_primitive_fields = 2;

    // Whether to always print enums as ints. By default they are rendered
    // as strings. Defaults to false.
    bool always_print_enums_as_ints = 3;

    // Whether to preserve proto field names. By default protobuf will
    // generate JSON field names using the ``json_name`` option, or lower camel case,
    // in that order. Setting this flag will preserve the original field names. Defaults to false.
    bool preserve_proto_field_names = 4;
  }

  oneof descriptor_set {
    option (validate.required) = true;

    // Supplies the filename of
    // :ref:`the proto descriptor set <config_grpc_json_generate_proto_descriptor_set>` for the gRPC
    // services.
    string proto_descriptor = 1;

    // Supplies the binary content of
    // :ref:`the proto descriptor set <config_grpc_json_generate_proto_descriptor_set>` for the gRPC
    // services.
    bytes proto_descriptor_bin = 4;
  }

  // A list of strings that
  // supplies the fully qualified service names (i.e. "package_name.service_name") that
  // the transcoder will translate. If the service name doesn't exist in ``proto_descriptor``,
  // Envoy will fail at startup. The ``proto_descriptor`` may contain more services than
  // the service names specified here, but they won't be translated.
  repeated string services = 2 [(validate.rules).repeated = {min_items: 1}];

  // Control options for response JSON. These options are passed directly to
  // `JsonPrintOptions <https://developers.google.com/protocol-buffers/docs/reference/cpp/
  // google.protobuf.util.json_util#JsonPrintOptions>`_.
  PrintOptions print_options = 3;

  // Whether to keep the incoming request route after the outgoing headers have been transformed to
  // the match the upstream gRPC service. Note: This means that routes for gRPC services that are
  // not transcoded cannot be used in combination with *match_incoming_request_route*.
  bool match_incoming_request_route = 5;

  // A list of query parameters to be ignored for transcoding method mapping.
  // By default, the transcoder filter will not transcode a request if there are any
  // unknown/invalid query parameters.
  //
  // Example :
  //
  // .. code-block:: proto
  //
  //     service Bookstore {
  //       rpc GetShelf(GetShelfRequest) returns (Shelf) {
  //         option (google.api.http) = {
  //           get: "/shelves/{shelf}"
  //         };
  //       }
  //     }
  //
  //     message GetShelfRequest {
  //       int64 shelf = 1;
  //     }
  //
  //     message Shelf {}
  //
  // The request ``/shelves/100?foo=bar`` will not be mapped to ``GetShelf``` because variable
  // binding for ``foo`` is not defined. Adding ``foo`` to ``ignored_query_parameters`` will allow
  // the same request to be mapped to ``GetShelf``.
  repeated string ignored_query_parameters = 6;

  // Whether to route methods without the ``google.api.http`` option.
  //
  // Example :
  //
  // .. code-block:: proto
  //
  //     package bookstore;
  //
  //     service Bookstore {
  //       rpc GetShelf(GetShelfRequest) returns (Shelf) {}
  //     }
  //
  //     message GetShelfRequest {
  //       int64 shelf = 1;
  //     }
  //
  //     message Shelf {}
  //
  // The client could ``post`` a json body ``{"shelf": 1234}`` with the path of
  // ``/bookstore.Bookstore/GetShelfRequest`` to call ``GetShelfRequest``.
  bool auto_mapping = 7;

  // Whether to ignore query parameters that cannot be mapped to a corresponding
  // protobuf field. Use this if you cannot control the query parameters and do
  // not know them beforehand. Otherwise use ``ignored_query_parameters``.
  // Defaults to false.
  bool ignore_unknown_query_parameters = 8;

  // Whether to convert gRPC status headers to JSON.
  // When trailer indicates a gRPC error and there was no HTTP body, take ``google.rpc.Status``
  // from the ``grpc-status-details-bin`` header and use it as JSON body.
  // If there was no such header, make ``google.rpc.Status`` out of the ``grpc-status`` and
  // ``grpc-message`` headers.
  // The error details types must be present in the ``proto_descriptor``.
  //
  // For example, if an upstream server replies with headers:
  //
  // .. code-block:: none
  //
  //     grpc-status: 5
  //     grpc-status-details-bin:
  //         CAUaMwoqdHlwZS5nb29nbGVhcGlzLmNvbS9nb29nbGUucnBjLlJlcXVlc3RJbmZvEgUKA3ItMQ
  //
  // The ``grpc-status-details-bin`` header contains a base64-encoded protobuf message
  // ``google.rpc.Status``. It will be transcoded into:
  //
  // .. code-block:: none
  //
  //     HTTP/1.1 404 Not Found
  //     content-type: application/json
  //
  //     {"code":5,"details":[{"@type":"type.googleapis.com/google.rpc.RequestInfo","requestId":"r-1"}]}
  //
  // In order to transcode the message, the ``google.rpc.RequestInfo`` type from
  // the ``google/rpc/error_details.proto`` should be included in the configured
  // :ref:`proto descriptor set <config_grpc_json_generate_proto_descriptor_set>`.
  bool convert_grpc_status = 9;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.http.gzip.v2;

import "envoy/config/filter/http/compressor/v2/compressor.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.gzip.v2";
option java_outer_classname = "GzipProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/gzip/v2;gzipv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.http.gzip.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Gzip]

// [#next-free-field: 11]
message Gzip {
  enum CompressionStrategy {
    DEFAULT = 0;
    FILTERED = 1;
    HUFFMAN = 2;
    RLE = 3;
  }

  message CompressionLevel {
    enum Enum {
      DEFAULT = 0;
      BEST = 1;
      SPEED = 2;
    }
  }

  // Value from 1 to 9 that controls the amount of internal memory used by zlib. Higher values
  // use more memory, but are faster and produce better compression results. The default value is 5.
  google.protobuf.UInt32Value memory_level = 1 [(validate.rules).uint32 = {lte: 9 gte: 1}];

  // Minimum response length, in bytes, which will trigger compression. The default value is 30.
  // .. attention:
  //
  //    **This field is deprecated**. Set the `compressor` field instead.
  google.protobuf.UInt32Value content_length = 2 [deprecated = true];

  // A value used for selecting the zlib compression level. This setting will affect speed and
  // amount of compression applied to the content. "BEST" provides higher compression at the cost of
  // higher latency, "SPEED" provides lower compression with minimum impact on response time.
  // "DEFAULT" provides an optimal result between speed and compression. This field will be set to
  // "DEFAULT" if not specified.
  CompressionLevel.Enum compression_level = 3 [(validate.rules).enum = {defined_only: true}];

  // A value used for selecting the zlib compression strategy which is directly related to the
  // characteristics of the content. Most of the time "DEFAULT" will be the best choice, though
  // there are situations which changing this parameter might produce better results. For example,
  // run-length encoding (RLE) is typically used when the content is known for having sequences
  // which same data occurs many consecutive times. For more information about each strategy, please
  // refer to zlib manual.
  CompressionStrategy compression_strategy = 4 [(validate.rules).enum = {defined_only: true}];

  // Set of strings that allows specifying which mime-types yield compression; e.g.,
  // application/json, text/html, etc. When this field is not defined, compression will be applied
  // to the following mime-types: "application/javascript", "application/json",
  // "application/xhtml+xml", "image/svg+xml", "text/css", "text/html", "text/plain", "text/xml".
  // .. attention:
  //
  //    **This field is deprecated**. Set the `compressor` field instead.
  repeated string content_type = 6 [deprecated = true];

  // If true, disables compression when the response contains an etag header. When it is false, the
  // filter will preserve weak etags and remove the ones that require strong validation.
  // .. attention:
  //
  //    **This field is deprecated**. Set the `compressor` field instead.
  bool disable_on_etag_header = 7 [deprecated = true];

  // If true, removes accept-encoding from the request headers before dispatching it to the upstream
  // so that responses do not get compressed before reaching the filter.
  // .. attention:
  //
  //    **This field is deprecated**. Set the `compressor` field instead.
  bool remove_accept_encoding_header = 8 [deprecated = true];

  // Value from 9 to 15 that represents the base two logarithmic of the compressor's window size.
  // Larger window results in better compression at the expense of memory usage. The default is 12
  // which will produce a 4096 bytes window. For more details about this parameter, please refer to
  // zlib manual > deflateInit2.
  google.protobuf.UInt32Value window_bits = 9 [(validate.rules).uint32 = {lte: 15 gte: 9}];

  // Set of configuration parameters common for all compression filters. If this field is set then
  // the fields `content_length`, `content_type`, `disable_on_etag_header` and
  // `remove_accept_encoding_header` are ignored.
  compressor.v2.Compressor compressor = 10;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/filter/http/compressor/v2:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.http.dynamo.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.dynamo.v2";
option java_outer_classname = "DynamoProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/dynamo/v2;dynamov2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.http.dynamo.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Dynamo]
// Dynamo :ref:`configuration overview <config_http_filters_dynamo>`.
// [#extension: envoy.filters.http.dynamo]

// Dynamo filter config.
message Dynamo {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.http.aws_request_signing.v2alpha;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.aws_request_signing.v2alpha";
option java_outer_classname = "AwsRequestSigningProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/aws_request_signing/v2alpha";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.aws_request_signing.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: AwsRequestSigning]
// AwsRequestSigning :ref:`configuration overview <config_http_filters_aws_request_signing>`.
// [#extension: envoy.filters.http.aws_request_signing]

// Top level configuration for the AWS request signing filter.
message AwsRequestSigning {
  // The `service namespace
  // <https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces>`_
  // of the HTTP endpoint.
  //
  // Example: s3
  string service_name = 1 [(validate.rules).string = {min_bytes: 1}];

  // The `region <https://docs.aws.amazon.com/general/latest/gr/rande.html>`_ hosting the HTTP
  // endpoint.
  //
  // Example: us-west-2
  string region = 2 [(validate.rules).string = {min_bytes: 1}];

  // Indicates that before signing headers, the host header will be swapped with
  // this value. If not set or empty, the original host header value
  // will be used and no rewrite will happen.
  //
  // Note: this rewrite affects both signing and host header forwarding. However, this
  // option shouldn't be used with
  // :ref:`HCM host rewrite <envoy_api_field_route.RouteAction.host_rewrite>` given that the
  // value set here would be used for signing whereas the value set in the HCM would be used
  // for host header forwarding which is not the desired outcome.
  string host_rewrite = 3;
}
syntax = "proto3";

package envoy.config.filter.http.tap.v2alpha;

import "envoy/config/common/tap/v2alpha/common.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.tap.v2alpha";
option java_outer_classname = "TapProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/tap/v2alpha";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.http.tap.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Tap]
// Tap :ref:`configuration overview <config_http_filters_tap>`.
// [#extension: envoy.filters.http.tap]

// Top level configuration for the tap filter.
message Tap {
  // Common configuration for the HTTP tap filter.
  common.tap.v2alpha.CommonExtensionConfig common_config = 1
      [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/common/tap/v2alpha:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.http.lua.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.lua.v2";
option java_outer_classname = "LuaProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/lua/v2;luav2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.http.lua.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Lua]
// Lua :ref:`configuration overview <config_http_filters_lua>`.
// [#extension: envoy.filters.http.lua]

message Lua {
  // The Lua code that Envoy will execute. This can be a very small script that
  // further loads code from disk if desired. Note that if JSON configuration is used, the code must
  // be properly escaped. YAML configuration may be easier to read since YAML supports multi-line
  // strings so complex scripts can be easily expressed inline in the configuration.
  string inline_code = 1 [(validate.rules).string = {min_bytes: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.http.grpc_web.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.grpc_web.v2";
option java_outer_classname = "GrpcWebProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/grpc_web/v2;grpc_webv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.grpc_web.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: gRPC Web]
// gRPC Web :ref:`configuration overview <config_http_filters_grpc_web>`.
// [#extension: envoy.filters.http.grpc_web]

// gRPC Web filter config.
message GrpcWeb {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.http.ext_authz.v2;

import "envoy/api/v2/core/base.proto";
import "envoy/api/v2/core/grpc_service.proto";
import "envoy/api/v2/core/http_uri.proto";
import "envoy/type/http_status.proto";
import "envoy/type/matcher/string.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.ext_authz.v2";
option java_outer_classname = "ExtAuthzProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/ext_authz/v2;ext_authzv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.ext_authz.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: External Authorization]
// External Authorization :ref:`configuration overview <config_http_filters_ext_authz>`.
// [#extension: envoy.filters.http.ext_authz]

// [#next-free-field: 12]
message ExtAuthz {
  // External authorization service configuration.
  oneof services {
    // gRPC service configuration (default timeout: 200ms).
    api.v2.core.GrpcService grpc_service = 1;

    // HTTP service configuration (default timeout: 200ms).
    HttpService http_service = 3;
  }

  //  Changes filter's behaviour on errors:
  //
  //  1. When set to true, the filter will *accept* client request even if the communication with
  //  the authorization service has failed, or if the authorization service has returned a HTTP 5xx
  //  error.
  //
  //  2. When set to false, ext-authz will *reject* client requests and return a *Forbidden*
  //  response if the communication with the authorization service has failed, or if the
  //  authorization service has returned a HTTP 5xx error.
  //
  // Note that errors can be *always* tracked in the :ref:`stats
  // <config_http_filters_ext_authz_stats>`.
  bool failure_mode_allow = 2;

  // [#not-implemented-hide: Support for this field has been removed.]
  bool use_alpha = 4 [deprecated = true, (envoy.annotations.disallowed_by_default) = true];

  // Enables filter to buffer the client request body and send it within the authorization request.
  // A ``x-envoy-auth-partial-body: false|true`` metadata header will be added to the authorization
  // request message indicating if the body data is partial.
  BufferSettings with_request_body = 5;

  // Clears route cache in order to allow the external authorization service to correctly affect
  // routing decisions. Filter clears all cached routes when:
  //
  // 1. The field is set to *true*.
  //
  // 2. The status returned from the authorization service is a HTTP 200 or gRPC 0.
  //
  // 3. At least one *authorization response header* is added to the client request, or is used for
  // altering another client request header.
  //
  bool clear_route_cache = 6;

  // Sets the HTTP status that is returned to the client when there is a network error between the
  // filter and the authorization server. The default status is HTTP 403 Forbidden.
  type.HttpStatus status_on_error = 7;

  // Specifies a list of metadata namespaces whose values, if present, will be passed to the
  // ext_authz service as an opaque *protobuf::Struct*.
  //
  // For example, if the *jwt_authn* filter is used and :ref:`payload_in_metadata
  // <envoy_api_field_config.filter.http.jwt_authn.v2alpha.JwtProvider.payload_in_metadata>` is set,
  // then the following will pass the jwt payload to the authorization server.
  //
  // .. code-block:: yaml
  //
  //    metadata_context_namespaces:
  //    - envoy.filters.http.jwt_authn
  //
  repeated string metadata_context_namespaces = 8;

  // Specifies if the filter is enabled.
  //
  // If :ref:`runtime_key <envoy_api_field_core.RuntimeFractionalPercent.runtime_key>` is specified,
  // Envoy will lookup the runtime key to get the percentage of requests to filter.
  //
  // If this field is not specified, the filter will be enabled for all requests.
  api.v2.core.RuntimeFractionalPercent filter_enabled = 9;

  // Specifies whether to deny the requests, when the filter is disabled.
  // If :ref:`runtime_key <envoy_api_field_core.RuntimeFeatureFlag.runtime_key>` is specified,
  // Envoy will lookup the runtime key to determine whether to deny request for
  // filter protected path at filter disabling. If filter is disabled in
  // typed_per_filter_config for the path, requests will not be denied.
  //
  // If this field is not specified, all requests will be allowed when disabled.
  api.v2.core.RuntimeFeatureFlag deny_at_disable = 11;

  // Specifies if the peer certificate is sent to the external service.
  //
  // When this field is true, Envoy will include the peer X.509 certificate, if available, in the
  // :ref:`certificate<envoy_api_field_service.auth.v2.AttributeContext.Peer.certificate>`.
  bool include_peer_certificate = 10;
}

// Configuration for buffering the request data.
message BufferSettings {
  // Sets the maximum size of a message body that the filter will hold in memory. Envoy will return
  // *HTTP 413* and will *not* initiate the authorization process when buffer reaches the number
  // set in this field. Note that this setting will have precedence over :ref:`failure_mode_allow
  // <envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.failure_mode_allow>`.
  uint32 max_request_bytes = 1 [(validate.rules).uint32 = {gt: 0}];

  // When this field is true, Envoy will buffer the message until *max_request_bytes* is reached.
  // The authorization request will be dispatched and no 413 HTTP error will be returned by the
  // filter.
  bool allow_partial_message = 2;
}

// HttpService is used for raw HTTP communication between the filter and the authorization service.
// When configured, the filter will parse the client request and use these attributes to call the
// authorization server. Depending on the response, the filter may reject or accept the client
// request. Note that in any of these events, metadata can be added, removed or overridden by the
// filter:
//
// *On authorization request*, a list of allowed request headers may be supplied. See
// :ref:`allowed_headers
// <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationRequest.allowed_headers>`
// for details. Additional headers metadata may be added to the authorization request. See
// :ref:`headers_to_add
// <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationRequest.headers_to_add>` for
// details.
//
// On authorization response status HTTP 200 OK, the filter will allow traffic to the upstream and
// additional headers metadata may be added to the original client request. See
// :ref:`allowed_upstream_headers
// <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_upstream_headers>`
// for details.
//
// On other authorization response statuses, the filter will not allow traffic. Additional headers
// metadata as well as body may be added to the client's response. See :ref:`allowed_client_headers
// <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_client_headers>`
// for details.
// [#next-free-field: 9]
message HttpService {
  reserved 3, 4, 5, 6;

  // Sets the HTTP server URI which the authorization requests must be sent to.
  api.v2.core.HttpUri server_uri = 1;

  // Sets a prefix to the value of authorization request header *Path*.
  string path_prefix = 2;

  // Settings used for controlling authorization request metadata.
  AuthorizationRequest authorization_request = 7;

  // Settings used for controlling authorization response metadata.
  AuthorizationResponse authorization_response = 8;
}

message AuthorizationRequest {
  // Authorization request will include the client request headers that have a correspondent match
  // in the :ref:`list <envoy_api_msg_type.matcher.ListStringMatcher>`. Note that in addition to the
  // user's supplied matchers:
  //
  // 1. *Host*, *Method*, *Path* and *Content-Length* are automatically included to the list.
  //
  // 2. *Content-Length* will be set to 0 and the request to the authorization service will not have
  // a message body. However, the authorization request can include the buffered client request body
  // (controlled by :ref:`with_request_body
  // <envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.with_request_body>` setting),
  // consequently the value of *Content-Length* of the authorization request reflects the size of
  // its payload size.
  //
  type.matcher.ListStringMatcher allowed_headers = 1;

  // Sets a list of headers that will be included to the request to authorization service. Note that
  // client request of the same key will be overridden.
  repeated api.v2.core.HeaderValue headers_to_add = 2;
}

message AuthorizationResponse {
  // When this :ref:`list <envoy_api_msg_type.matcher.ListStringMatcher>` is set, authorization
  // response headers that have a correspondent match will be added to the original client request.
  // Note that coexistent headers will be overridden.
  type.matcher.ListStringMatcher allowed_upstream_headers = 1;

  // When this :ref:`list <envoy_api_msg_type.matcher.ListStringMatcher>` is set, authorization
  // response headers that have a correspondent match will be added to the client's response. Note
  // that when this list is *not* set, all the authorization response headers, except *Authority
  // (Host)* will be in the response to the client. When a header is included in this list, *Path*,
  // *Status*, *Content-Length*, *WWWAuthenticate* and *Location* are automatically added.
  type.matcher.ListStringMatcher allowed_client_headers = 2;
}

// Extra settings on a per virtualhost/route/weighted-cluster level.
message ExtAuthzPerRoute {
  oneof override {
    option (validate.required) = true;

    // Disable the ext auth filter for this particular vhost or route.
    // If disabled is specified in multiple per-filter-configs, the most specific one will be used.
    bool disabled = 1 [(validate.rules).bool = {const: true}];

    // Check request settings for this route.
    CheckSettings check_settings = 2 [(validate.rules).message = {required: true}];
  }
}

// Extra settings for the check request. You can use this to provide extra context for the
// external authorization server on specific virtual hosts \ routes. For example, adding a context
// extension on the virtual host level can give the ext-authz server information on what virtual
// host is used without needing to parse the host header. If CheckSettings is specified in multiple
// per-filter-configs, they will be merged in order, and the result will be used.
message CheckSettings {
  // Context extensions to set on the CheckRequest's
  // :ref:`AttributeContext.context_extensions<envoy_api_field_service.auth.v2.AttributeContext.context_extensions>`
  //
  // Merge semantics for this field are such that keys from more specific configs override.
  //
  // .. note::
  //
  //   These settings are only applied to a filter configured with a
  //   :ref:`grpc_service<envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.grpc_service>`.
  map<string, string> context_extensions = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/api/v2/core:pkg",
        "//envoy/type:pkg",
        "//envoy/type/matcher:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# JWT Authentication HTTP filter config

## Overview

1. The proto file in this folder defines an HTTP filter config for "jwt_authn" filter.

2. This filter will verify the JWT in the HTTP request as:
    - The signature should be valid
    - JWT should not be expired
    - Issuer and audiences are valid and specified in the filter config.

3. [JWK](https://tools.ietf.org/html/rfc7517#appendix-A) is needed to verify JWT signature. It can be fetched from a remote server or read from a local file. If the JWKS is fetched remotely, it will be cached by the filter.

3. If a JWT is valid, the user is authenticated and the request will be forwarded to the backend server. If a JWT is not valid, the request will be rejected with an error message.

## The locations to extract JWT

JWT will be extracted from the HTTP headers or query parameters. The default location is the HTTP header:
```
Authorization: Bearer <token>
```
The next default location is in the query parameter as:
```
?access_token=<TOKEN>
```

If a custom location is desired, `from_headers` or `from_params` can be used to specify custom locations to extract JWT.

## HTTP header to pass successfully verified JWT

If a JWT is valid, its payload will be passed to the backend in a new HTTP header specified in `forward_payload_header` field. Its value is base64url-encoded JWT payload in JSON.


## Further header options

In addition to the `name` field, which specifies the HTTP header name,
the `from_headers` section can specify an optional `value_prefix` value, as in:

```yaml
    from_headers:
      - name: bespoke
        value_prefix: jwt_value
```

The above will cause the jwt_authn filter to look for the JWT in the `bespoke` header, following the tag `jwt_value`.

Any non-JWT characters (i.e., anything _other than_ alphanumerics, `_`, `-`, and `.`) will be skipped,
and all following, contiguous, JWT-legal chars will be taken as the JWT.

This means all of the following will return a JWT of `eyJFbnZveSI6ICJyb2NrcyJ9.e30.c2lnbmVk`:

```text
bespoke: jwt_value=eyJFbnZveSI6ICJyb2NrcyJ9.e30.c2lnbmVk

bespoke: {"jwt_value": "eyJFbnZveSI6ICJyb2NrcyJ9.e30.c2lnbmVk"}

bespoke: beta:true,jwt_value:"eyJFbnZveSI6ICJyb2NrcyJ9.e30.c2lnbmVk",trace=1234
```

The header `name` may be `Authorization`.

The `value_prefix` must match exactly, i.e., case-sensitively.
If the `value_prefix` is not found, the header is skipped: not considered as a source for a JWT token.

If there are no JWT-legal characters after the `value_prefix`, the entire string after it
is taken to be the JWT token. This is unlikely to succeed; the error will reported by the JWT parser.
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "//envoy/api/v2/route:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.http.jwt_authn.v2alpha;

import "envoy/api/v2/core/base.proto";
import "envoy/api/v2/core/http_uri.proto";
import "envoy/api/v2/route/route_components.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.jwt_authn.v2alpha";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/jwt_authn/v2alpha";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.jwt_authn.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: JWT Authentication]
// JWT Authentication :ref:`configuration overview <config_http_filters_jwt_authn>`.
// [#extension: envoy.filters.http.jwt_authn]

// Please see following for JWT authentication flow:
//
// * `JSON Web Token (JWT) <https://tools.ietf.org/html/rfc7519>`_
// * `The OAuth 2.0 Authorization Framework <https://tools.ietf.org/html/rfc6749>`_
// * `OpenID Connect <http://openid.net/connect>`_
//
// A JwtProvider message specifies how a JSON Web Token (JWT) can be verified. It specifies:
//
// * issuer: the principal that issues the JWT. It has to match the one from the token.
// * allowed audiences: the ones in the token have to be listed here.
// * how to fetch public key JWKS to verify the token signature.
// * how to extract JWT token in the request.
// * how to pass successfully verified token payload.
//
// Example:
//
// .. code-block:: yaml
//
//     issuer: https://example.com
//     audiences:
//     - bookstore_android.apps.googleusercontent.com
//     - bookstore_web.apps.googleusercontent.com
//     remote_jwks:
//       http_uri:
//         uri: https://example.com/.well-known/jwks.json
//         cluster: example_jwks_cluster
//       cache_duration:
//         seconds: 300
//
// [#next-free-field: 10]
message JwtProvider {
  // Specify the `principal <https://tools.ietf.org/html/rfc7519#section-4.1.1>`_ that issued
  // the JWT, usually a URL or an email address.
  //
  // Example: https://securetoken.google.com
  // Example: 1234567-compute@developer.gserviceaccount.com
  //
  string issuer = 1 [(validate.rules).string = {min_bytes: 1}];

  // The list of JWT `audiences <https://tools.ietf.org/html/rfc7519#section-4.1.3>`_ are
  // allowed to access. A JWT containing any of these audiences will be accepted. If not specified,
  // will not check audiences in the token.
  //
  // Example:
  //
  // .. code-block:: yaml
  //
  //     audiences:
  //     - bookstore_android.apps.googleusercontent.com
  //     - bookstore_web.apps.googleusercontent.com
  //
  repeated string audiences = 2;

  // `JSON Web Key Set (JWKS) <https://tools.ietf.org/html/rfc7517#appendix-A>`_ is needed to
  // validate signature of a JWT. This field specifies where to fetch JWKS.
  oneof jwks_source_specifier {
    option (validate.required) = true;

    // JWKS can be fetched from remote server via HTTP/HTTPS. This field specifies the remote HTTP
    // URI and how the fetched JWKS should be cached.
    //
    // Example:
    //
    // .. code-block:: yaml
    //
    //    remote_jwks:
    //      http_uri:
    //        uri: https://www.googleapis.com/oauth2/v1/certs
    //        cluster: jwt.www.googleapis.com|443
    //      cache_duration:
    //        seconds: 300
    //
    RemoteJwks remote_jwks = 3;

    // JWKS is in local data source. It could be either in a local file or embedded in the
    // inline_string.
    //
    // Example: local file
    //
    // .. code-block:: yaml
    //
    //    local_jwks:
    //      filename: /etc/envoy/jwks/jwks1.txt
    //
    // Example: inline_string
    //
    // .. code-block:: yaml
    //
    //    local_jwks:
    //      inline_string: ACADADADADA
    //
    api.v2.core.DataSource local_jwks = 4;
  }

  // If false, the JWT is removed in the request after a success verification. If true, the JWT is
  // not removed in the request. Default value is false.
  bool forward = 5;

  // Two fields below define where to extract the JWT from an HTTP request.
  //
  // If no explicit location is specified, the following default locations are tried in order:
  //
  // 1. The Authorization header using the `Bearer schema
  // <https://tools.ietf.org/html/rfc6750#section-2.1>`_. Example::
  //
  //    Authorization: Bearer <token>.
  //
  // 2. `access_token <https://tools.ietf.org/html/rfc6750#section-2.3>`_ query parameter.
  //
  // Multiple JWTs can be verified for a request. Each JWT has to be extracted from the locations
  // its provider specified or from the default locations.
  //
  // Specify the HTTP headers to extract JWT token. For examples, following config:
  //
  // .. code-block:: yaml
  //
  //   from_headers:
  //   - name: x-goog-iap-jwt-assertion
  //
  // can be used to extract token from header::
  //
  //   ``x-goog-iap-jwt-assertion: <JWT>``.
  //
  repeated JwtHeader from_headers = 6;

  // JWT is sent in a query parameter. `jwt_params` represents the query parameter names.
  //
  // For example, if config is:
  //
  // .. code-block:: yaml
  //
  //   from_params:
  //   - jwt_token
  //
  // The JWT format in query parameter is::
  //
  //    /path?jwt_token=<JWT>
  //
  repeated string from_params = 7;

  // This field specifies the header name to forward a successfully verified JWT payload to the
  // backend. The forwarded data is::
  //
  //    base64url_encoded(jwt_payload_in_JSON)
  //
  // If it is not specified, the payload will not be forwarded.
  string forward_payload_header = 8;

  // If non empty, successfully verified JWT payloads will be written to StreamInfo DynamicMetadata
  // in the format as: *namespace* is the jwt_authn filter name as **envoy.filters.http.jwt_authn**
  // The value is the *protobuf::Struct*. The value of this field will be the key for its *fields*
  // and the value is the *protobuf::Struct* converted from JWT JSON payload.
  //
  // For example, if payload_in_metadata is *my_payload*:
  //
  // .. code-block:: yaml
  //
  //   envoy.filters.http.jwt_authn:
  //     my_payload:
  //       iss: https://example.com
  //       sub: test@example.com
  //       aud: https://example.com
  //       exp: 1501281058
  //
  string payload_in_metadata = 9;
}

// This message specifies how to fetch JWKS from remote and how to cache it.
message RemoteJwks {
  // The HTTP URI to fetch the JWKS. For example:
  //
  // .. code-block:: yaml
  //
  //    http_uri:
  //      uri: https://www.googleapis.com/oauth2/v1/certs
  //      cluster: jwt.www.googleapis.com|443
  //
  api.v2.core.HttpUri http_uri = 1;

  // Duration after which the cached JWKS should be expired. If not specified, default cache
  // duration is 5 minutes.
  google.protobuf.Duration cache_duration = 2;
}

// This message specifies a header location to extract JWT token.
message JwtHeader {
  // The HTTP header name.
  string name = 1 [(validate.rules).string = {min_bytes: 1}];

  // The value prefix. The value format is "value_prefix<token>"
  // For example, for "Authorization: Bearer <token>", value_prefix="Bearer " with a space at the
  // end.
  string value_prefix = 2;
}

// Specify a required provider with audiences.
message ProviderWithAudiences {
  // Specify a required provider name.
  string provider_name = 1;

  // This field overrides the one specified in the JwtProvider.
  repeated string audiences = 2;
}

// This message specifies a Jwt requirement. An empty message means JWT verification is not
// required. Here are some config examples:
//
// .. code-block:: yaml
//
//  # Example 1: not required with an empty message
//
//  # Example 2: require A
//  provider_name: provider-A
//
//  # Example 3: require A or B
//  requires_any:
//    requirements:
//      - provider_name: provider-A
//      - provider_name: provider-B
//
//  # Example 4: require A and B
//  requires_all:
//    requirements:
//      - provider_name: provider-A
//      - provider_name: provider-B
//
//  # Example 5: require A and (B or C)
//  requires_all:
//    requirements:
//      - provider_name: provider-A
//      - requires_any:
//        requirements:
//          - provider_name: provider-B
//          - provider_name: provider-C
//
//  # Example 6: require A or (B and C)
//  requires_any:
//    requirements:
//      - provider_name: provider-A
//      - requires_all:
//        requirements:
//          - provider_name: provider-B
//          - provider_name: provider-C
//
//  # Example 7: A is optional (if token from A is provided, it must be valid, but also allows
//  missing token.)
//  requires_any:
//    requirements:
//    - provider_name: provider-A
//    - allow_missing: {}
//
//  # Example 8: A is optional and B is required.
//  requires_all:
//    requirements:
//    - requires_any:
//        requirements:
//        - provider_name: provider-A
//        - allow_missing: {}
//    - provider_name: provider-B
//
// [#next-free-field: 7]
message JwtRequirement {
  oneof requires_type {
    // Specify a required provider name.
    string provider_name = 1;

    // Specify a required provider with audiences.
    ProviderWithAudiences provider_and_audiences = 2;

    // Specify list of JwtRequirement. Their results are OR-ed.
    // If any one of them passes, the result is passed.
    JwtRequirementOrList requires_any = 3;

    // Specify list of JwtRequirement. Their results are AND-ed.
    // All of them must pass, if one of them fails or missing, it fails.
    JwtRequirementAndList requires_all = 4;

    // The requirement is always satisfied even if JWT is missing or the JWT
    // verification fails. A typical usage is: this filter is used to only verify
    // JWTs and pass the verified JWT payloads to another filter, the other filter
    // will make decision. In this mode, all JWT tokens will be verified.
    google.protobuf.Empty allow_missing_or_failed = 5;

    // The requirement is satisfied if JWT is missing, but failed if JWT is
    // presented but invalid. Similar to allow_missing_or_failed, this is used
    // to only verify JWTs and pass the verified payload to another filter. The
    // different is this mode will reject requests with invalid tokens.
    google.protobuf.Empty allow_missing = 6;
  }
}

// This message specifies a list of RequiredProvider.
// Their results are OR-ed; if any one of them passes, the result is passed
message JwtRequirementOrList {
  // Specify a list of JwtRequirement.
  repeated JwtRequirement requirements = 1 [(validate.rules).repeated = {min_items: 2}];
}

// This message specifies a list of RequiredProvider.
// Their results are AND-ed; all of them must pass, if one of them fails or missing, it fails.
message JwtRequirementAndList {
  // Specify a list of JwtRequirement.
  repeated JwtRequirement requirements = 1 [(validate.rules).repeated = {min_items: 2}];
}

// This message specifies a Jwt requirement for a specific Route condition.
// Example 1:
//
// .. code-block:: yaml
//
//    - match:
//        prefix: /healthz
//
// In above example, "requires" field is empty for /healthz prefix match,
// it means that requests matching the path prefix don't require JWT authentication.
//
// Example 2:
//
// .. code-block:: yaml
//
//    - match:
//        prefix: /
//      requires: { provider_name: provider-A }
//
// In above example, all requests matched the path prefix require jwt authentication
// from "provider-A".
message RequirementRule {
  // The route matching parameter. Only when the match is satisfied, the "requires" field will
  // apply.
  //
  // For example: following match will match all requests.
  //
  // .. code-block:: yaml
  //
  //    match:
  //      prefix: /
  //
  api.v2.route.RouteMatch match = 1 [(validate.rules).message = {required: true}];

  // Specify a Jwt Requirement. Please detail comment in message JwtRequirement.
  JwtRequirement requires = 2;
}

// This message specifies Jwt requirements based on stream_info.filterState.
// This FilterState should use `Router::StringAccessor` object to set a string value.
// Other HTTP filters can use it to specify Jwt requirements dynamically.
//
// Example:
//
// .. code-block:: yaml
//
//    name: jwt_selector
//    requires:
//      issuer_1:
//        provider_name: issuer1
//      issuer_2:
//        provider_name: issuer2
//
// If a filter set "jwt_selector" with "issuer_1" to FilterState for a request,
// jwt_authn filter will use JwtRequirement{"provider_name": "issuer1"} to verify.
message FilterStateRule {
  // The filter state name to retrieve the `Router::StringAccessor` object.
  string name = 1 [(validate.rules).string = {min_bytes: 1}];

  // A map of string keys to requirements. The string key is the string value
  // in the FilterState with the name specified in the *name* field above.
  map<string, JwtRequirement>
  requires = 3;
}

// This is the Envoy HTTP filter config for JWT authentication.
//
// For example:
//
// .. code-block:: yaml
//
//   providers:
//      provider1:
//        issuer: issuer1
//        audiences:
//        - audience1
//        - audience2
//        remote_jwks:
//          http_uri:
//            uri: https://example.com/.well-known/jwks.json
//            cluster: example_jwks_cluster
//      provider2:
//        issuer: issuer2
//        local_jwks:
//          inline_string: jwks_string
//
//   rules:
//      # Not jwt verification is required for /health path
//      - match:
//          prefix: /health
//
//      # Jwt verification for provider1 is required for path prefixed with "prefix"
//      - match:
//          prefix: /prefix
//        requires:
//          provider_name: provider1
//
//      # Jwt verification for either provider1 or provider2 is required for all other requests.
//      - match:
//          prefix: /
//        requires:
//          requires_any:
//            requirements:
//              - provider_name: provider1
//              - provider_name: provider2
//
message JwtAuthentication {
  // Map of provider names to JwtProviders.
  //
  // .. code-block:: yaml
  //
  //   providers:
  //     provider1:
  //        issuer: issuer1
  //        audiences:
  //        - audience1
  //        - audience2
  //        remote_jwks:
  //          http_uri:
  //            uri: https://example.com/.well-known/jwks.json
  //            cluster: example_jwks_cluster
  //      provider2:
  //        issuer: provider2
  //        local_jwks:
  //          inline_string: jwks_string
  //
  map<string, JwtProvider> providers = 1;

  // Specifies requirements based on the route matches. The first matched requirement will be
  // applied. If there are overlapped match conditions, please put the most specific match first.
  //
  // Examples
  //
  // .. code-block:: yaml
  //
  //   rules:
  //     - match:
  //         prefix: /healthz
  //     - match:
  //         prefix: /baz
  //       requires:
  //         provider_name: provider1
  //     - match:
  //         prefix: /foo
  //       requires:
  //         requires_any:
  //           requirements:
  //             - provider_name: provider1
  //             - provider_name: provider2
  //     - match:
  //         prefix: /bar
  //       requires:
  //         requires_all:
  //           requirements:
  //             - provider_name: provider1
  //             - provider_name: provider2
  //
  repeated RequirementRule rules = 2;

  // This message specifies Jwt requirements based on stream_info.filterState.
  // Other HTTP filters can use it to specify Jwt requirements dynamically.
  // The *rules* field above is checked first, if it could not find any matches,
  // check this one.
  FilterStateRule filter_state_rules = 3;

  // When set to true, bypass the `CORS preflight request
  // <http://www.w3.org/TR/cors/#cross-origin-request-with-preflight>`_ regardless of JWT
  // requirements specified in the rules.
  bool bypass_cors_preflight = 4;
}
syntax = "proto3";

package envoy.config.filter.http.csrf.v2;

import "envoy/api/v2/core/base.proto";
import "envoy/type/matcher/string.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.csrf.v2";
option java_outer_classname = "CsrfProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/csrf/v2;csrfv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.http.csrf.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: CSRF]
// Cross-Site Request Forgery :ref:`configuration overview <config_http_filters_csrf>`.
// [#extension: envoy.filters.http.csrf]

// CSRF filter config.
message CsrfPolicy {
  // Specifies the % of requests for which the CSRF filter is enabled.
  //
  // If :ref:`runtime_key <envoy_api_field_core.RuntimeFractionalPercent.runtime_key>` is specified,
  // Envoy will lookup the runtime key to get the percentage of requests to filter.
  //
  // .. note::
  //
  //   This field defaults to 100/:ref:`HUNDRED
  //   <envoy_api_enum_type.FractionalPercent.DenominatorType>`.
  api.v2.core.RuntimeFractionalPercent filter_enabled = 1
      [(validate.rules).message = {required: true}];

  // Specifies that CSRF policies will be evaluated and tracked, but not enforced.
  //
  // This is intended to be used when ``filter_enabled`` is off and will be ignored otherwise.
  //
  // If :ref:`runtime_key <envoy_api_field_core.RuntimeFractionalPercent.runtime_key>` is specified,
  // Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
  // and track the request's *Origin* and *Destination* to determine if it's valid, but will not
  // enforce any policies.
  api.v2.core.RuntimeFractionalPercent shadow_enabled = 2;

  // Specifies additional source origins that will be allowed in addition to
  // the destination origin.
  //
  // More information on how this can be configured via runtime can be found
  // :ref:`here <csrf-configuration>`.
  repeated type.matcher.StringMatcher additional_origins = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "//envoy/type/matcher:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.http.ip_tagging.v2;

import "envoy/api/v2/core/address.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.ip_tagging.v2";
option java_outer_classname = "IpTaggingProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/ip_tagging/v2;ip_taggingv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.ip_tagging.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: IP tagging]
// IP tagging :ref:`configuration overview <config_http_filters_ip_tagging>`.
// [#extension: envoy.filters.http.ip_tagging]

message IPTagging {
  // The type of requests the filter should apply to. The supported types
  // are internal, external or both. The
  // :ref:`x-forwarded-for<config_http_conn_man_headers_x-forwarded-for_internal_origin>` header is
  // used to determine if a request is internal and will result in
  // :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>`
  // being set. The filter defaults to both, and it will apply to all request types.
  enum RequestType {
    // Both external and internal requests will be tagged. This is the default value.
    BOTH = 0;

    // Only internal requests will be tagged.
    INTERNAL = 1;

    // Only external requests will be tagged.
    EXTERNAL = 2;
  }

  // Supplies the IP tag name and the IP address subnets.
  message IPTag {
    // Specifies the IP tag name to apply.
    string ip_tag_name = 1;

    // A list of IP address subnets that will be tagged with
    // ip_tag_name. Both IPv4 and IPv6 are supported.
    repeated api.v2.core.CidrRange ip_list = 2;
  }

  // The type of request the filter should apply to.
  RequestType request_type = 1 [(validate.rules).enum = {defined_only: true}];

  // [#comment:TODO(ccaraman): Extend functionality to load IP tags from file system.
  // Tracked by issue https://github.com/envoyproxy/envoy/issues/2695]
  // The set of IP tags for the filter.
  repeated IPTag ip_tags = 4 [(validate.rules).repeated = {min_items: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.http.grpc_stats.v2alpha;

import "envoy/api/v2/core/grpc_method_list.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.grpc_stats.v2alpha";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/grpc_stats/v2alpha";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.grpc_stats.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: gRPC statistics] gRPC statistics filter
// :ref:`configuration overview <config_http_filters_grpc_stats>`.
// [#extension: envoy.filters.http.grpc_stats]

// gRPC statistics filter configuration
message FilterConfig {
  // If true, the filter maintains a filter state object with the request and response message
  // counts.
  bool emit_filter_state = 1;

  oneof per_method_stat_specifier {
    // If set, specifies an allowlist of service/methods that will have individual stats
    // emitted for them. Any call that does not match the allowlist will be counted
    // in a stat with no method specifier: `cluster.<name>.grpc.*`.
    api.v2.core.GrpcMethodList individual_method_stats_allowlist = 2;

    // If set to true, emit stats for all service/method names.
    //
    // If set to false, emit stats for all service/message types to the same stats without including
    // the service/method in the name, with prefix `cluster.<name>.grpc`. This can be useful if
    // service/method granularity is not needed, or if each cluster only receives a single method.
    //
    // .. attention::
    //   This option is only safe if all clients are trusted. If this option is enabled
    //   with untrusted clients, the clients could cause unbounded growth in the number of stats in
    //   Envoy, using unbounded memory and potentially slowing down stats pipelines.
    //
    // .. attention::
    //   If neither `individual_method_stats_allowlist` nor `stats_for_all_methods` is set, the
    //   behavior will default to `stats_for_all_methods=false`.
    google.protobuf.BoolValue stats_for_all_methods = 3;
  }
}

// gRPC statistics filter state object in protobuf form.
message FilterObject {
  // Count of request messages in the request stream.
  uint64 request_message_count = 1;

  // Count of response messages in the response stream.
  uint64 response_message_count = 2;
}
syntax = "proto3";

package envoy.config.filter.http.rate_limit.v2;

import "envoy/config/ratelimit/v2/rls.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.rate_limit.v2";
option java_outer_classname = "RateLimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/rate_limit/v2;rate_limitv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.ratelimit.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Rate limit]
// Rate limit :ref:`configuration overview <config_http_filters_rate_limit>`.
// [#extension: envoy.filters.http.ratelimit]

// [#next-free-field: 8]
message RateLimit {
  // The rate limit domain to use when calling the rate limit service.
  string domain = 1 [(validate.rules).string = {min_bytes: 1}];

  // Specifies the rate limit configurations to be applied with the same
  // stage number. If not set, the default stage number is 0.
  //
  // .. note::
  //
  //  The filter supports a range of 0 - 10 inclusively for stage numbers.
  uint32 stage = 2 [(validate.rules).uint32 = {lte: 10}];

  // The type of requests the filter should apply to. The supported
  // types are *internal*, *external* or *both*. A request is considered internal if
  // :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>` is set to true. If
  // :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>` is not set or false, a
  // request is considered external. The filter defaults to *both*, and it will apply to all request
  // types.
  string request_type = 3
      [(validate.rules).string = {in: "internal" in: "external" in: "both" in: ""}];

  // The timeout in milliseconds for the rate limit service RPC. If not
  // set, this defaults to 20ms.
  google.protobuf.Duration timeout = 4;

  // The filter's behaviour in case the rate limiting service does
  // not respond back. When it is set to true, Envoy will not allow traffic in case of
  // communication failure between rate limiting service and the proxy.
  // Defaults to false.
  bool failure_mode_deny = 5;

  // Specifies whether a `RESOURCE_EXHAUSTED` gRPC code must be returned instead
  // of the default `UNAVAILABLE` gRPC code for a rate limited gRPC call. The
  // HTTP code will be 200 for a gRPC response.
  bool rate_limited_as_resource_exhausted = 6;

  // Configuration for an external rate limit service provider. If not
  // specified, any calls to the rate limit service will immediately return
  // success.
  ratelimit.v2.RateLimitServiceConfig rate_limit_service = 7
      [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/ratelimit/v2:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.http.cors.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.cors.v2";
option java_outer_classname = "CorsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/cors/v2;corsv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.http.cors.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Cors]
// CORS Filter :ref:`configuration overview <config_http_filters_cors>`.
// [#extension: envoy.filters.http.cors]

// Cors filter config.
message Cors {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.http.adaptive_concurrency.v2alpha;

import "envoy/api/v2/core/base.proto";
import "envoy/type/percent.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.adaptive_concurrency.v2alpha";
option java_outer_classname = "AdaptiveConcurrencyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/adaptive_concurrency/v2alpha";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.adaptive_concurrency.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Adaptive Concurrency]
// Adaptive Concurrency Control :ref:`configuration overview
// <config_http_filters_adaptive_concurrency>`.
// [#extension: envoy.filters.http.adaptive_concurrency]

// Configuration parameters for the gradient controller.
message GradientControllerConfig {
  // Parameters controlling the periodic recalculation of the concurrency limit from sampled request
  // latencies.
  message ConcurrencyLimitCalculationParams {
    // The allowed upper-bound on the calculated concurrency limit. Defaults to 1000.
    google.protobuf.UInt32Value max_concurrency_limit = 2 [(validate.rules).uint32 = {gt: 0}];

    // The period of time samples are taken to recalculate the concurrency limit.
    google.protobuf.Duration concurrency_update_interval = 3 [(validate.rules).duration = {
      required: true
      gt {}
    }];
  }

  // Parameters controlling the periodic minRTT recalculation.
  // [#next-free-field: 6]
  message MinimumRTTCalculationParams {
    // The time interval between recalculating the minimum request round-trip time.
    google.protobuf.Duration interval = 1 [(validate.rules).duration = {
      required: true
      gt {}
    }];

    // The number of requests to aggregate/sample during the minRTT recalculation window before
    // updating. Defaults to 50.
    google.protobuf.UInt32Value request_count = 2 [(validate.rules).uint32 = {gt: 0}];

    // Randomized time delta that will be introduced to the start of the minRTT calculation window.
    // This is represented as a percentage of the interval duration. Defaults to 15%.
    //
    // Example: If the interval is 10s and the jitter is 15%, the next window will begin
    // somewhere in the range (10s - 11.5s).
    type.Percent jitter = 3;

    // The concurrency limit set while measuring the minRTT. Defaults to 3.
    google.protobuf.UInt32Value min_concurrency = 4 [(validate.rules).uint32 = {gt: 0}];

    // Amount added to the measured minRTT to add stability to the concurrency limit during natural
    // variability in latency. This is expressed as a percentage of the measured value and can be
    // adjusted to allow more or less tolerance to the sampled latency values.
    //
    // Defaults to 25%.
    type.Percent buffer = 5;
  }

  // The percentile to use when summarizing aggregated samples. Defaults to p50.
  type.Percent sample_aggregate_percentile = 1;

  ConcurrencyLimitCalculationParams concurrency_limit_params = 2
      [(validate.rules).message = {required: true}];

  MinimumRTTCalculationParams min_rtt_calc_params = 3 [(validate.rules).message = {required: true}];
}

message AdaptiveConcurrency {
  oneof concurrency_controller_config {
    option (validate.required) = true;

    // Gradient concurrency control will be used.
    GradientControllerConfig gradient_controller_config = 1
        [(validate.rules).message = {required: true}];
  }

  // If set to false, the adaptive concurrency filter will operate as a pass-through filter. If the
  // message is unspecified, the filter will be enabled.
  api.v2.core.RuntimeFeatureFlag enabled = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "//envoy/type:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.http.grpc_http1_reverse_bridge.v2alpha1;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.grpc_http1_reverse_bridge.v2alpha1";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/grpc_http1_reverse_bridge/v2alpha1";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.grpc_http1_reverse_bridge.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: gRPC HTTP/1.1 Reverse Bridge]
// gRPC HTTP/1.1 Reverse Bridge :ref:`configuration overview
// <config_http_filters_grpc_http1_reverse_bridge>`.
// [#extension: envoy.filters.http.grpc_http1_reverse_bridge]

// gRPC reverse bridge filter configuration
message FilterConfig {
  // The content-type to pass to the upstream when the gRPC bridge filter is applied.
  // The filter will also validate that the upstream responds with the same content type.
  string content_type = 1 [(validate.rules).string = {min_bytes: 1}];

  // If true, Envoy will assume that the upstream doesn't understand gRPC frames and
  // strip the gRPC frame from the request, and add it back in to the response. This will
  // hide the gRPC semantics from the upstream, allowing it to receive and respond with a
  // simple binary encoded protobuf.
  bool withhold_grpc_frames = 2;
}

// gRPC reverse bridge filter configuration per virtualhost/route/weighted-cluster level.
message FilterConfigPerRoute {
  // If true, disables gRPC reverse bridge filter for this particular vhost or route.
  // If disabled is specified in multiple per-filter-configs, the most specific one will be used.
  bool disabled = 1;
}
syntax = "proto3";

package envoy.config.filter.http.fault.v2;

import "envoy/api/v2/route/route_components.proto";
import "envoy/config/filter/fault/v2/fault.proto";
import "envoy/type/percent.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.fault.v2";
option java_outer_classname = "FaultProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/fault/v2;faultv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.http.fault.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Fault Injection]
// Fault Injection :ref:`configuration overview <config_http_filters_fault_injection>`.
// [#extension: envoy.filters.http.fault]

message FaultAbort {
  // Fault aborts are controlled via an HTTP header (if applicable). See the
  // :ref:`HTTP fault filter <config_http_filters_fault_injection_http_header>` documentation for
  // more information.
  message HeaderAbort {
  }

  reserved 1;

  oneof error_type {
    option (validate.required) = true;

    // HTTP status code to use to abort the HTTP request.
    uint32 http_status = 2 [(validate.rules).uint32 = {lt: 600 gte: 200}];

    // Fault aborts are controlled via an HTTP header (if applicable).
    HeaderAbort header_abort = 4;
  }

  // The percentage of requests/operations/connections that will be aborted with the error code
  // provided.
  type.FractionalPercent percentage = 3;
}

// [#next-free-field: 14]
message HTTPFault {
  // If specified, the filter will inject delays based on the values in the
  // object.
  filter.fault.v2.FaultDelay delay = 1;

  // If specified, the filter will abort requests based on the values in
  // the object. At least *abort* or *delay* must be specified.
  FaultAbort abort = 2;

  // Specifies the name of the (destination) upstream cluster that the
  // filter should match on. Fault injection will be restricted to requests
  // bound to the specific upstream cluster.
  string upstream_cluster = 3;

  // Specifies a set of headers that the filter should match on. The fault
  // injection filter can be applied selectively to requests that match a set of
  // headers specified in the fault filter config. The chances of actual fault
  // injection further depend on the value of the :ref:`percentage
  // <envoy_api_field_config.filter.http.fault.v2.FaultAbort.percentage>` field.
  // The filter will check the request's headers against all the specified
  // headers in the filter config. A match will happen if all the headers in the
  // config are present in the request with the same values (or based on
  // presence if the *value* field is not in the config).
  repeated api.v2.route.HeaderMatcher headers = 4;

  // Faults are injected for the specified list of downstream hosts. If this
  // setting is not set, faults are injected for all downstream nodes.
  // Downstream node name is taken from :ref:`the HTTP
  // x-envoy-downstream-service-node
  // <config_http_conn_man_headers_downstream-service-node>` header and compared
  // against downstream_nodes list.
  repeated string downstream_nodes = 5;

  // The maximum number of faults that can be active at a single time via the configured fault
  // filter. Note that because this setting can be overridden at the route level, it's possible
  // for the number of active faults to be greater than this value (if injected via a different
  // route). If not specified, defaults to unlimited. This setting can be overridden via
  // `runtime <config_http_filters_fault_injection_runtime>` and any faults that are not injected
  // due to overflow will be indicated via the `faults_overflow
  // <config_http_filters_fault_injection_stats>` stat.
  //
  // .. attention::
  //   Like other :ref:`circuit breakers <arch_overview_circuit_break>` in Envoy, this is a fuzzy
  //   limit. It's possible for the number of active faults to rise slightly above the configured
  //   amount due to the implementation details.
  google.protobuf.UInt32Value max_active_faults = 6;

  // The response rate limit to be applied to the response body of the stream. When configured,
  // the percentage can be overridden by the :ref:`fault.http.rate_limit.response_percent
  // <config_http_filters_fault_injection_runtime>` runtime key.
  //
  // .. attention::
  //  This is a per-stream limit versus a connection level limit. This means that concurrent streams
  //  will each get an independent limit.
  filter.fault.v2.FaultRateLimit response_rate_limit = 7;

  // The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
  // runtime. The default is: fault.http.delay.fixed_delay_percent
  string delay_percent_runtime = 8;

  // The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
  // runtime. The default is: fault.http.abort.abort_percent
  string abort_percent_runtime = 9;

  // The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
  // runtime. The default is: fault.http.delay.fixed_duration_ms
  string delay_duration_runtime = 10;

  // The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
  // runtime. The default is: fault.http.abort.http_status
  string abort_http_status_runtime = 11;

  // The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
  // runtime. The default is: fault.http.max_active_faults
  string max_active_faults_runtime = 12;

  // The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
  // runtime. The default is: fault.http.rate_limit.response_percent
  string response_rate_limit_percent_runtime = 13;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/route:pkg",
        "//envoy/config/filter/fault/v2:pkg",
        "//envoy/type:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.http.aws_lambda.v2alpha;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.aws_lambda.v2alpha";
option java_outer_classname = "AwsLambdaProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/aws_lambda/v2alpha";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.aws_lambda.v3";
option (udpa.annotations.file_status).work_in_progress = true;
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: AWS Lambda]
// AWS Lambda :ref:`configuration overview <config_http_filters_aws_lambda>`.
// [#extension: envoy.filters.http.aws_lambda]

// AWS Lambda filter config
message Config {
  enum InvocationMode {
    // This is the more common mode of invocation, in which Lambda responds after it has completed the function. In
    // this mode the output of the Lambda function becomes the response of the HTTP request.
    SYNCHRONOUS = 0;

    // In this mode Lambda responds immediately but continues to process the function asynchronously. This mode can be
    // used to signal events for example. In this mode, Lambda responds with an acknowledgment that it received the
    // call which is translated to an HTTP 200 OK by the filter.
    ASYNCHRONOUS = 1;
  }

  // The ARN of the AWS Lambda to invoke when the filter is engaged
  // Must be in the following format:
  // arn:<partition>:lambda:<region>:<account-number>:function:<function-name>
  string arn = 1 [(validate.rules).string = {min_len: 1}];

  // Whether to transform the request (headers and body) to a JSON payload or pass it as is.
  bool payload_passthrough = 2;

  // Determines the way to invoke the Lambda function.
  InvocationMode invocation_mode = 3 [(validate.rules).enum = {defined_only: true}];
}

// Per-route configuration for AWS Lambda. This can be useful when invoking a different Lambda function or a different
// version of the same Lambda depending on the route.
message PerRouteConfig {
  Config invoke_config = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.http.health_check.v2;

import "envoy/api/v2/route/route_components.proto";
import "envoy/type/percent.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.health_check.v2";
option java_outer_classname = "HealthCheckProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/health_check/v2;health_checkv2";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.http.health_check.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Health check]
// Health check :ref:`configuration overview <config_http_filters_health_check>`.
// [#extension: envoy.filters.http.health_check]

// [#next-free-field: 6]
message HealthCheck {
  reserved 2;

  // Specifies whether the filter operates in pass through mode or not.
  google.protobuf.BoolValue pass_through_mode = 1 [(validate.rules).message = {required: true}];

  // If operating in pass through mode, the amount of time in milliseconds
  // that the filter should cache the upstream response.
  google.protobuf.Duration cache_time = 3;

  // If operating in non-pass-through mode, specifies a set of upstream cluster
  // names and the minimum percentage of servers in each of those clusters that
  // must be healthy or degraded in order for the filter to return a 200.
  //
  // .. note::
  //
  //    This value is interpreted as an integer by truncating, so 12.50% will be calculated
  //    as if it were 12%.
  map<string, type.Percent> cluster_min_healthy_percentages = 4;

  // Specifies a set of health check request headers to match on. The health check filter will
  // check a requests headers against all the specified headers. To specify the health check
  // endpoint, set the ``:path`` header to match on.
  repeated api.v2.route.HeaderMatcher headers = 5;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/route:pkg",
        "//envoy/type:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.http.buffer.v2;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.buffer.v2";
option java_outer_classname = "BufferProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/buffer/v2;bufferv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.http.buffer.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Buffer]
// Buffer :ref:`configuration overview <config_http_filters_buffer>`.
// [#extension: envoy.filters.http.buffer]

message Buffer {
  reserved 2;

  // The maximum request size that the filter will buffer before the connection
  // manager will stop buffering and return a 413 response.
  google.protobuf.UInt32Value max_request_bytes = 1
      [(validate.rules).uint32 = {gt: 0}, (validate.rules).message = {required: true}];
}

message BufferPerRoute {
  oneof override {
    option (validate.required) = true;

    // Disable the buffer filter for this particular vhost or route.
    bool disabled = 1 [(validate.rules).bool = {const: true}];

    // Override the global configuration of the filter with this new config.
    Buffer buffer = 2 [(validate.rules).message = {required: true}];
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.http.router.v2;

import "envoy/config/filter/accesslog/v2/accesslog.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.http.router.v2";
option java_outer_classname = "RouterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/http/router/v2;routerv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.http.router.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Router]
// Router :ref:`configuration overview <config_http_filters_router>`.
// [#extension: envoy.filters.http.router]

// [#next-free-field: 7]
message Router {
  // Whether the router generates dynamic cluster statistics. Defaults to
  // true. Can be disabled in high performance scenarios.
  google.protobuf.BoolValue dynamic_stats = 1;

  // Whether to start a child span for egress routed calls. This can be
  // useful in scenarios where other filters (auth, ratelimit, etc.) make
  // outbound calls and have child spans rooted at the same ingress
  // parent. Defaults to false.
  bool start_child_span = 2;

  // Configuration for HTTP upstream logs emitted by the router. Upstream logs
  // are configured in the same way as access logs, but each log entry represents
  // an upstream request. Presuming retries are configured, multiple upstream
  // requests may be made for each downstream (inbound) request.
  repeated accesslog.v2.AccessLog upstream_log = 3;

  // Do not add any additional *x-envoy-* headers to requests or responses. This
  // only affects the :ref:`router filter generated *x-envoy-* headers
  // <config_http_filters_router_headers_set>`, other Envoy filters and the HTTP
  // connection manager may continue to set *x-envoy-* headers.
  bool suppress_envoy_headers = 4;

  // Specifies a list of HTTP headers to strictly validate. Envoy will reject a
  // request and respond with HTTP status 400 if the request contains an invalid
  // value for any of the headers listed in this field. Strict header checking
  // is only supported for the following headers:
  //
  // Value must be a ','-delimited list (i.e. no spaces) of supported retry
  // policy values:
  //
  // * :ref:`config_http_filters_router_x-envoy-retry-grpc-on`
  // * :ref:`config_http_filters_router_x-envoy-retry-on`
  //
  // Value must be an integer:
  //
  // * :ref:`config_http_filters_router_x-envoy-max-retries`
  // * :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`
  // * :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`
  repeated string strict_check_headers = 5 [(validate.rules).repeated = {
    items {
      string {
        in: "x-envoy-upstream-rq-timeout-ms"
        in: "x-envoy-upstream-rq-per-try-timeout-ms"
        in: "x-envoy-max-retries"
        in: "x-envoy-retry-grpc-on"
        in: "x-envoy-retry-on"
      }
    }
  }];

  // If not set, ingress Envoy will ignore
  // :ref:`config_http_filters_router_x-envoy-expected-rq-timeout-ms` header, populated by egress
  // Envoy, when deriving timeout for upstream cluster.
  bool respect_expected_rq_timeout = 6;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/filter/accesslog/v2:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/api/v2/core:pkg",
        "//envoy/api/v2/route:pkg",
        "//envoy/type:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.filter.accesslog.v2;

import "envoy/api/v2/core/base.proto";
import "envoy/api/v2/route/route_components.proto";
import "envoy/type/percent.proto";

import "google/protobuf/any.proto";
import "google/protobuf/struct.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.accesslog.v2";
option java_outer_classname = "AccesslogProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/accesslog/v2;accesslogv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.config.accesslog.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Common access log types]

message AccessLog {
  // The name of the access log implementation to instantiate. The name must
  // match a statically registered access log. Current built-in loggers include:
  //
  // #. "envoy.access_loggers.file"
  // #. "envoy.access_loggers.http_grpc"
  // #. "envoy.access_loggers.tcp_grpc"
  string name = 1;

  // Filter which is used to determine if the access log needs to be written.
  AccessLogFilter filter = 2;

  // Custom configuration that depends on the access log being instantiated. Built-in
  // configurations include:
  //
  // #. "envoy.access_loggers.file": :ref:`FileAccessLog
  //    <envoy_api_msg_config.accesslog.v2.FileAccessLog>`
  // #. "envoy.access_loggers.http_grpc": :ref:`HttpGrpcAccessLogConfig
  //    <envoy_api_msg_config.accesslog.v2.HttpGrpcAccessLogConfig>`
  // #. "envoy.access_loggers.tcp_grpc": :ref:`TcpGrpcAccessLogConfig
  //    <envoy_api_msg_config.accesslog.v2.TcpGrpcAccessLogConfig>`
  oneof config_type {
    google.protobuf.Struct config = 3 [deprecated = true];

    google.protobuf.Any typed_config = 4;
  }
}

// [#next-free-field: 12]
message AccessLogFilter {
  oneof filter_specifier {
    option (validate.required) = true;

    // Status code filter.
    StatusCodeFilter status_code_filter = 1;

    // Duration filter.
    DurationFilter duration_filter = 2;

    // Not health check filter.
    NotHealthCheckFilter not_health_check_filter = 3;

    // Traceable filter.
    TraceableFilter traceable_filter = 4;

    // Runtime filter.
    RuntimeFilter runtime_filter = 5;

    // And filter.
    AndFilter and_filter = 6;

    // Or filter.
    OrFilter or_filter = 7;

    // Header filter.
    HeaderFilter header_filter = 8;

    // Response flag filter.
    ResponseFlagFilter response_flag_filter = 9;

    // gRPC status filter.
    GrpcStatusFilter grpc_status_filter = 10;

    // Extension filter.
    ExtensionFilter extension_filter = 11;
  }
}

// Filter on an integer comparison.
message ComparisonFilter {
  enum Op {
    // =
    EQ = 0;

    // >=
    GE = 1;

    // <=
    LE = 2;
  }

  // Comparison operator.
  Op op = 1 [(validate.rules).enum = {defined_only: true}];

  // Value to compare against.
  api.v2.core.RuntimeUInt32 value = 2;
}

// Filters on HTTP response/status code.
message StatusCodeFilter {
  // Comparison.
  ComparisonFilter comparison = 1 [(validate.rules).message = {required: true}];
}

// Filters on total request duration in milliseconds.
message DurationFilter {
  // Comparison.
  ComparisonFilter comparison = 1 [(validate.rules).message = {required: true}];
}

// Filters for requests that are not health check requests. A health check
// request is marked by the health check filter.
message NotHealthCheckFilter {
}

// Filters for requests that are traceable. See the tracing overview for more
// information on how a request becomes traceable.
message TraceableFilter {
}

// Filters for random sampling of requests.
message RuntimeFilter {
  // Runtime key to get an optional overridden numerator for use in the *percent_sampled* field.
  // If found in runtime, this value will replace the default numerator.
  string runtime_key = 1 [(validate.rules).string = {min_bytes: 1}];

  // The default sampling percentage. If not specified, defaults to 0% with denominator of 100.
  type.FractionalPercent percent_sampled = 2;

  // By default, sampling pivots on the header
  // :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` being present. If
  // :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` is present, the filter will
  // consistently sample across multiple hosts based on the runtime key value and the value
  // extracted from :ref:`x-request-id<config_http_conn_man_headers_x-request-id>`. If it is
  // missing, or *use_independent_randomness* is set to true, the filter will randomly sample based
  // on the runtime key value alone. *use_independent_randomness* can be used for logging kill
  // switches within complex nested :ref:`AndFilter
  // <envoy_api_msg_config.filter.accesslog.v2.AndFilter>` and :ref:`OrFilter
  // <envoy_api_msg_config.filter.accesslog.v2.OrFilter>` blocks that are easier to reason about
  // from a probability perspective (i.e., setting to true will cause the filter to behave like
  // an independent random variable when composed within logical operator filters).
  bool use_independent_randomness = 3;
}

// Performs a logical and operation on the result of each filter in filters.
// Filters are evaluated sequentially and if one of them returns false, the
// filter returns false immediately.
message AndFilter {
  repeated AccessLogFilter filters = 1 [(validate.rules).repeated = {min_items: 2}];
}

// Performs a logical or operation on the result of each individual filter.
// Filters are evaluated sequentially and if one of them returns true, the
// filter returns true immediately.
message OrFilter {
  repeated AccessLogFilter filters = 2 [(validate.rules).repeated = {min_items: 2}];
}

// Filters requests based on the presence or value of a request header.
message HeaderFilter {
  // Only requests with a header which matches the specified HeaderMatcher will pass the filter
  // check.
  api.v2.route.HeaderMatcher header = 1 [(validate.rules).message = {required: true}];
}

// Filters requests that received responses with an Envoy response flag set.
// A list of the response flags can be found
// in the access log formatter :ref:`documentation<config_access_log_format_response_flags>`.
message ResponseFlagFilter {
  // Only responses with the any of the flags listed in this field will be logged.
  // This field is optional. If it is not specified, then any response flag will pass
  // the filter check.
  repeated string flags = 1 [(validate.rules).repeated = {
    items {
      string {
        in: "LH"
        in: "UH"
        in: "UT"
        in: "LR"
        in: "UR"
        in: "UF"
        in: "UC"
        in: "UO"
        in: "NR"
        in: "DI"
        in: "FI"
        in: "RL"
        in: "UAEX"
        in: "RLSE"
        in: "DC"
        in: "URX"
        in: "SI"
        in: "IH"
        in: "DPE"
      }
    }
  }];
}

// Filters gRPC requests based on their response status. If a gRPC status is not provided, the
// filter will infer the status from the HTTP status code.
message GrpcStatusFilter {
  enum Status {
    OK = 0;
    CANCELED = 1;
    UNKNOWN = 2;
    INVALID_ARGUMENT = 3;
    DEADLINE_EXCEEDED = 4;
    NOT_FOUND = 5;
    ALREADY_EXISTS = 6;
    PERMISSION_DENIED = 7;
    RESOURCE_EXHAUSTED = 8;
    FAILED_PRECONDITION = 9;
    ABORTED = 10;
    OUT_OF_RANGE = 11;
    UNIMPLEMENTED = 12;
    INTERNAL = 13;
    UNAVAILABLE = 14;
    DATA_LOSS = 15;
    UNAUTHENTICATED = 16;
  }

  // Logs only responses that have any one of the gRPC statuses in this field.
  repeated Status statuses = 1 [(validate.rules).repeated = {items {enum {defined_only: true}}}];

  // If included and set to true, the filter will instead block all responses with a gRPC status or
  // inferred gRPC status enumerated in statuses, and allow all other responses.
  bool exclude = 2;
}

// Extension filter is statically registered at runtime.
message ExtensionFilter {
  // The name of the filter implementation to instantiate. The name must
  // match a statically registered filter.
  string name = 1;

  // Custom configuration that depends on the filter being instantiated.
  oneof config_type {
    google.protobuf.Struct config = 2 [deprecated = true];

    google.protobuf.Any typed_config = 3;
  }
}
syntax = "proto3";

package envoy.config.filter.dubbo.router.v2alpha1;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.filter.dubbo.router.v2alpha1";
option java_outer_classname = "RouterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/dubbo/router/v2alpha1";
option (udpa.annotations.file_migrate).move_to_package =
    "envoy.extensions.filters.network.dubbo_proxy.router.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Router]
// Dubbo router :ref:`configuration overview <config_dubbo_filters_router>`.

message Router {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.filter.fault.v2;

import "envoy/type/percent.proto";

import "google/protobuf/duration.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.filter.fault.v2";
option java_outer_classname = "FaultProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/filter/fault/v2;faultv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.extensions.filters.common.fault.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Common fault injection types]

// Delay specification is used to inject latency into the
// HTTP/gRPC/Mongo/Redis operation or delay proxying of 