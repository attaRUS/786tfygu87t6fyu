     "catch-all ('*') virtual host in route {}",
                                       route_config.name()));
    }
  }
}

const VirtualHostImpl* RouteMatcherImpl::findWildcardVirtualHost(
    absl::string_view host, const RouteMatcherImpl::WildcardVirtualHosts& wildcard_virtual_hosts,
    RouteMatcherImpl::SubstringFunction substring_function) const {
  // We do a longest wildcard match against the host that's passed in
  // (e.g. "foo-bar.baz.com" should match "*-bar.baz.com" before matching "*.baz.com" for suffix
  // wildcards). This is done by scanning the length => wildcards map looking for every wildcard
  // whose size is < length.
  for (const auto& iter : wildcard_virtual_hosts) {
    const uint32_t wildcard_length = iter.first;
    const auto& wildcard_map = iter.second;
    // >= because *.foo.com shouldn't match .foo.com.
    if (wildcard_length >= host.size()) {
      continue;
    }
    const auto& match = wildcard_map.find(substring_function(host, wildcard_length));
    if (match != wildcard_map.end()) {
      return match->second.get();
    }
  }
  return nullptr;
}

const VirtualHostImpl* RouteMatcherImpl::findVirtualHost(const Request& request) const {
  absl::string_view host = request.host();

  // Fast path the case where we only have a default virtual host or host property is provided.
  if (host.empty() || (virtual_hosts_.empty() && wildcard_virtual_host_suffixes_.empty() &&
                       wildcard_virtual_host_prefixes_.empty())) {
    return default_virtual_host_.get();
  }

  const auto iter = virtual_hosts_.find(host);
  if (iter != virtual_hosts_.end()) {
    return iter->second.get();
  }

  if (!wildcard_virtual_host_suffixes_.empty()) {
    const VirtualHostImpl* vhost = findWildcardVirtualHost(
        host, wildcard_virtual_host_suffixes_,
        [](absl::string_view h, int l) -> absl::string_view { return h.substr(h.size() - l); });
    if (vhost != nullptr) {
      return vhost;
    }
  }

  if (!wildcard_virtual_host_prefixes_.empty()) {
    const VirtualHostImpl* vhost = findWildcardVirtualHost(
        host, wildcard_virtual_host_prefixes_,
        [](absl::string_view h, int l) -> absl::string_view { return h.substr(0, l); });
    if (vhost != nullptr) {
      return vhost;
    }
  }
  return default_virtual_host_.get();
}

RouteEntryConstSharedPtr RouteMatcherImpl::routeEntry(const Request& request) const {
  const auto* virtual_host = findVirtualHost(request);
  if (virtual_host != nullptr) {
    return virtual_host->routeEntry(request);
  }
  return nullptr;
}

} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include <memory>

#include "source/common/rds/common/route_config_provider_manager.h"

#include "contrib/envoy/extensions/filters/network/generic_proxy/v3/generic_proxy.pb.h"
#include "contrib/envoy/extensions/filters/network/generic_proxy/v3/generic_proxy.pb.validate.h"
#include "contrib/envoy/extensions/filters/network/generic_proxy/v3/route.pb.h"
#include "contrib/envoy/extensions/filters/network/generic_proxy/v3/route.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace GenericProxy {

using RouteConfigProviderManager = Rds::Common::RouteConfigProviderManager<
    envoy::extensions::filters::network::generic_proxy::v3::GenericRds,
    envoy::extensions::filters::network::generic_proxy::v3::RouteConfiguration>;

} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include <functional>
#include <memory>

#include "source/common/matcher/matcher.h"

#include "contrib/envoy/extensions/filters/network/generic_proxy/matcher/v3/matcher.pb.h"
#include "contrib/envoy/extensions/filters/network/generic_proxy/matcher/v3/matcher.pb.validate.h"
#include "contrib/generic_proxy/filters/network/source/interface/stream.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace GenericProxy {

using ServiceDataInputProto =
    envoy::extensions::filters::network::generic_proxy::matcher::v3::ServiceMatchInput;
using HostDataInputProto =
    envoy::extensions::filters::network::generic_proxy::matcher::v3::HostMatchInput;
using PathDataInputProto =
    envoy::extensions::filters::network::generic_proxy::matcher::v3::PathMatchInput;
using MethodDataInputProto =
    envoy::extensions::filters::network::generic_proxy::matcher::v3::MethodMatchInput;
using PropertyDataInputProto =
    envoy::extensions::filters::network::generic_proxy::matcher::v3::PropertyMatchInput;
using RequestInputProto =
    envoy::extensions::filters::network::generic_proxy::matcher::v3::RequestMatchInput;
using RequestMatcherProto =
    envoy::extensions::filters::network::generic_proxy::matcher::v3::RequestMatcher;
using StringMatcherProto = envoy::type::matcher::v3::StringMatcher;

// Fully qualified name of the generic proxy request match data type to avoid any possible
// collision with other match data types.
inline constexpr absl::string_view GenericRequestMatcheInputType =
    "Envoy::Extensions::NetworkFilters::GenericProxy::RequestMatchData";

class ServiceMatchDataInput : public Matcher::DataInput<Request> {
public:
  Matcher::DataInputGetResult get(const Request& data) const override {
    return {Matcher::DataInputGetResult::DataAvailability::AllDataAvailable,
            std::string(data.host())};
  }
};

class ServiceMatchDataInputFactory : public Matcher::DataInputFactory<Request> {
public:
  ServiceMatchDataInputFactory() = default;

  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<ServiceDataInputProto>();
  }

  Matcher::DataInputFactoryCb<Request>
  createDataInputFactoryCb(const Protobuf::Message&, ProtobufMessage::ValidationVisitor&) override {
    return []() { return std::make_unique<ServiceMatchDataInput>(); };
  }

  std::string name() const override { return "envoy.matching.generic_proxy.input.service"; }
};

class HostMatchDataInput : public Matcher::DataInput<Request> {
public:
  Matcher::DataInputGetResult get(const Request& data) const override {
    return {Matcher::DataInputGetResult::DataAvailability::AllDataAvailable,
            std::string(data.host())};
  }
};

class HostMatchDataInputFactory : public Matcher::DataInputFactory<Request> {
public:
  HostMatchDataInputFactory() = default;

  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<HostDataInputProto>();
  }

  Matcher::DataInputFactoryCb<Request>
  createDataInputFactoryCb(const Protobuf::Message&, ProtobufMessage::ValidationVisitor&) override {
    return []() { return std::make_unique<HostMatchDataInput>(); };
  }

  std::string name() const override { return "envoy.matching.generic_proxy.input.host"; }
};

class PathMatchDataInput : public Matcher::DataInput<Request> {
public:
  Matcher::DataInputGetResult get(const Request& data) const override {
    return {Matcher::DataInputGetResult::DataAvailability::AllDataAvailable,
            std::string(data.path())};
  }
};

class PathMatchDataInputFactory : public Matcher::DataInputFactory<Request> {
public:
  PathMatchDataInputFactory() = default;

  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<PathDataInputProto>();
  }

  Matcher::DataInputFactoryCb<Request>
  createDataInputFactoryCb(const Protobuf::Message&, ProtobufMessage::ValidationVisitor&) override {
    return []() { return std::make_unique<PathMatchDataInput>(); };
  }

  std::string name() const override { return "envoy.matching.generic_proxy.input.path"; }
};

class MethodMatchDataInput : public Matcher::DataInput<Request> {
public:
  Matcher::DataInputGetResult get(const Request& data) const override {
    return {Matcher::DataInputGetResult::DataAvailability::AllDataAvailable,
            std::string(data.method())};
  }
};

class MethodMatchDataInputFactory : public Matcher::DataInputFactory<Request> {
public:
  MethodMatchDataInputFactory() = default;

  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<MethodDataInputProto>();
  }

  Matcher::DataInputFactoryCb<Request>
  createDataInputFactoryCb(const Protobuf::Message&, ProtobufMessage::ValidationVisitor&) override {
    return []() { return std::make_unique<MethodMatchDataInput>(); };
  }

  std::string name() const override { return "envoy.matching.generic_proxy.input.method"; }
};

class PropertyMatchDataInput : public Matcher::DataInput<Request> {
public:
  PropertyMatchDataInput(const std::string& property_name) : name_(property_name) {}

  Matcher::DataInputGetResult get(const Request& data) const override {
    const auto value = data.get(name_);
    Matcher::MatchingDataType matching_data =
        value.has_value() ? Matcher::MatchingDataType(std::string(value.value()))
                          : absl::monostate();
    return {Matcher::DataInputGetResult::DataAvailability::AllDataAvailable, matching_data};
  }

private:
  const std::string name_;
};

class PropertyMatchDataInputFactory : public Matcher::DataInputFactory<Request> {
public:
  PropertyMatchDataInputFactory() = default;

  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<PropertyDataInputProto>();
  }

  Matcher::DataInputFactoryCb<Request>
  createDataInputFactoryCb(const Protobuf::Message& message,
                           ProtobufMessage::ValidationVisitor& visitor) override {
    const auto& config =
        MessageUtil::downcastAndValidate<const PropertyDataInputProto&>(message, visitor);
    const std::string name = config.property_name();

    return [name]() { return std::make_unique<PropertyMatchDataInput>(name); };
  }

  std::string name() const override { return "envoy.matching.generic_proxy.input.property"; }
};

// RequestMatchData is a wrapper of Request to be used as the matching data type.
class RequestMatchData : public Matcher::CustomMatchData {
public:
  RequestMatchData(const Request& data) : data_(data) {}

  const Request& request() const { return data_; }

private:
  const Request& data_;
};

class RequestMatchDataInput : public Matcher::DataInput<Request> {
public:
  RequestMatchDataInput() = default;

  Matcher::DataInputGetResult get(const Request& data) const override {
    auto request = std::make_shared<RequestMatchData>(data);
    return {Matcher::DataInputGetResult::DataAvailability::AllDataAvailable,
            Matcher::MatchingDataType{std::move(request)}};
  }

  absl::string_view dataInputType() const override { return GenericRequestMatcheInputType; }
};

class RequestMatchDataInputFactory : public Matcher::DataInputFactory<Request> {
public:
  RequestMatchDataInputFactory() = default;

  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<RequestInputProto>();
  }

  Matcher::DataInputFactoryCb<Request>
  createDataInputFactoryCb(const Protobuf::Message&, ProtobufMessage::ValidationVisitor&) override {
    return []() { return std::make_unique<RequestMatchDataInput>(); };
  }

  std::string name() const override { return "envoy.matching.generic_proxy.input.request"; }
};

class RequestMatchInputMatcher : public Matcher::InputMatcher {
public:
  RequestMatchInputMatcher(const RequestMatcherProto& config);

  bool match(const Matcher::MatchingDataType& input) override;

  bool match(const Request& request);

  absl::flat_hash_set<std::string> supportedDataInputTypes() const override {
    return absl::flat_hash_set<std::string>{std::string(GenericRequestMatcheInputType)};
  }

private:
  Matchers::StringMatcherPtr host_;
  Matchers::StringMatcherPtr path_;
  Matchers::StringMatcherPtr method_;
  std::vector<std::pair<std::string, Matchers::StringMatcherPtr>> properties_;
};

class RequestMatchDataInputMatcherFactory : public Matcher::InputMatcherFactory {
public:
  Matcher::InputMatcherFactoryCb createInputMatcherFactoryCb(
      const Protobuf::Message& config,
      Server::Configuration::ServerFactoryContext& factory_context) override;

  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<RequestMatcherProto>();
  }

  std::string name() const override {
    return "envoy.matching.input_matchers.generic_request_matcher";
  }
};

} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include <cstdint>
#include <memory>
#include <string>

#include "envoy/config/core/v3/extension.pb.h"
#include "envoy/network/connection.h"
#include "envoy/network/filter.h"
#include "envoy/server/factory_context.h"
#include "envoy/stats/timespan.h"
#include "envoy/tracing/tracer_manager.h"

#include "source/common/buffer/buffer_impl.h"
#include "source/common/common/linked_object.h"
#include "source/common/common/logger.h"
#include "source/common/stats/timespan_impl.h"
#include "source/common/stream_info/stream_info_impl.h"
#include "source/common/tracing/tracer_config_impl.h"
#include "source/common/tracing/tracer_impl.h"

#include "contrib/envoy/extensions/filters/network/generic_proxy/v3/generic_proxy.pb.h"
#include "contrib/envoy/extensions/filters/network/generic_proxy/v3/generic_proxy.pb.validate.h"
#include "contrib/envoy/extensions/filters/network/generic_proxy/v3/route.pb.h"
#include "contrib/generic_proxy/filters/network/source/interface/filter.h"
#include "contrib/generic_proxy/filters/network/source/interface/proxy_config.h"
#include "contrib/generic_proxy/filters/network/source/interface/route.h"
#include "contrib/generic_proxy/filters/network/source/interface/stream.h"
#include "contrib/generic_proxy/filters/network/source/rds.h"
#include "contrib/generic_proxy/filters/network/source/rds_impl.h"
#include "contrib/generic_proxy/filters/network/source/route.h"
#include "contrib/generic_proxy/filters/network/source/stats.h"
#include "contrib/generic_proxy/filters/network/source/tracing.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace GenericProxy {

using ProxyConfig = envoy::extensions::filters::network::generic_proxy::v3::GenericProxy;
using RouteConfiguration =
    envoy::extensions::filters::network::generic_proxy::v3::RouteConfiguration;

class Filter;
class ActiveStream;

struct NamedFilterFactoryCb {
  std::string config_name_;
  FilterFactoryCb callback_;
};

enum class DownstreamStreamResetReason : uint32_t {
  // The stream was reset because of the connection was closed.
  ConnectionTermination,
  // The stream was reset because of the connection was closed locally.
  LocalConnectionTermination,
  // Protocol error.
  ProtocolError,
};

class FilterConfigImpl : public FilterConfig {
public:
  FilterConfigImpl(const std::string& stat_prefix, CodecFactoryPtr codec,
                   Rds::RouteConfigProviderSharedPtr route_config_provider,
                   std::vector<NamedFilterFactoryCb> factories, Tracing::TracerSharedPtr tracer,
                   Tracing::ConnectionManagerTracingConfigPtr tracing_config,
                   std::vector<AccessLogInstanceSharedPtr>&& access_logs,
                   const CodeOrFlags& code_or_flags,
                   Envoy::Server::Configuration::FactoryContext& context)
      : stat_prefix_(stat_prefix),
        stats_(GenericFilterStats::generateStats(stat_prefix_, context.scope())),
        code_or_flags_(code_or_flags), codec_factory_(std::move(codec)),
        route_config_provider_(std::move(route_config_provider)), factories_(std::move(factories)),
        drain_decision_(context.drainDecision()), tracer_(std::move(tracer)),
        tracing_config_(std::move(tracing_config)), access_logs_(std::move(access_logs)),
        time_source_(context.serverFactoryContext().timeSource()) {}

  // FilterConfig
  RouteEntryConstSharedPtr routeEntry(const Request& request) const override {
    auto config = std::static_pointer_cast<const RouteMatcher>(route_config_provider_->config());
    return config->routeEntry(request);
  }
  const CodecFactory& codecFactory() const override { return *codec_factory_; }
  const Network::DrainDecision& drainDecision() const override { return drain_decision_; }
  OptRef<Tracing::Tracer> tracingProvider() const override {
    return makeOptRefFromPtr<Tracing::Tracer>(tracer_.get());
  }
  OptRef<const Tracing::ConnectionManagerTracingConfig> tracingConfig() const override {
    return makeOptRefFromPtr<const Tracing::ConnectionManagerTracingConfig>(tracing_config_.get());
  }
  GenericFilterStats& stats() override { return stats_; }
  const CodeOrFlags& codeOrFlags() const override { return code_or_flags_; }
  const std::vector<AccessLogInstanceSharedPtr>& accessLogs() const override {
    return access_logs_;
  }

  // FilterChainFactory
  void createFilterChain(FilterChainManager& manager) override {
    for (auto& factory : factories_) {
      manager.applyFilterFactoryCb({factory.config_name_}, factory.callback_);
    }
  }

private:
  friend class ActiveStream;
  friend class Filter;

  const std::string stat_prefix_;
  GenericFilterStats stats_;
  const CodeOrFlags& code_or_flags_;

  CodecFactoryPtr codec_factory_;

  Rds::RouteConfigProviderSharedPtr route_config_provider_;

  std::vector<NamedFilterFactoryCb> factories_;

  const Network::DrainDecision& drain_decision_;

  Tracing::TracerSharedPtr tracer_;
  Tracing::ConnectionManagerTracingConfigPtr tracing_config_;
  std::vector<AccessLogInstanceSharedPtr> access_logs_;

  TimeSource& time_source_;
};

class ActiveStream : public FilterChainManager,
                     public LinkedObject<ActiveStream>,
                     public Envoy::Event::DeferredDeletable,
                     public EncodingCallbacks,
                     public Tracing::Config,
                     Logger::Loggable<Envoy::Logger::Id::filter> {
public:
  class ActiveFilterBase : public virtual StreamFilterCallbacks {
  public:
    ActiveFilterBase(ActiveStream& parent, FilterContext context, bool is_dual)
        : parent_(parent), context_(context), is_dual_(is_dual) {}

    // StreamFilterCallbacks
    Envoy::Event::Dispatcher& dispatcher() override { return parent_.dispatcher(); }
    const CodecFactory& downstreamCodec() override { return parent_.downstreamCodec(); }
    const RouteEntry* routeEntry() const override { return parent_.routeEntry(); }
    const RouteSpecificFilterConfig* perFilterConfig() const override {
      if (const auto* entry = parent_.routeEntry(); entry != nullptr) {
        return entry->perFilterConfig(context_.config_name);
      }
      return nullptr;
    }
    const StreamInfo::StreamInfo& streamInfo() const override { return parent_.stream_info_; }
    StreamInfo::StreamInfo& streamInfo() override { return parent_.stream_info_; }
    Tracing::Span& activeSpan() override { return parent_.activeSpan(); }
    OptRef<const Tracing::Config> tracingConfig() const override { return parent_.tracingConfig(); }
    const Network::Connection* connection() const override;

    bool isDualFilter() const { return is_dual_; }

    ActiveStream& parent_;
    FilterContext context_;
    const bool is_dual_{};
  };

  class ActiveDecoderFilter : public ActiveFilterBase, public DecoderFilterCallback {
  public:
    ActiveDecoderFilter(ActiveStream& parent, FilterContext context, DecoderFilterSharedPtr filter,
                        bool is_dual)
        : ActiveFilterBase(parent, context, is_dual), filter_(std::move(filter)) {
      filter_->setDecoderFilterCallbacks(*this);
    }

    // DecoderFilterCallback
    void sendLocalReply(Status status, absl::string_view data,
                        ResponseUpdateFunction func) override {
      parent_.sendLocalReply(status, data, std::move(func));
    }
    void continueDecoding() override { parent_.continueDecoding(); }
    void onResponseStart(ResponsePtr response) override {
      parent_.onResponseStart(std::move(response));
    }
    void onResponseFrame(StreamFramePtr frame) override {
      parent_.onResponseFrame(std::move(frame));
    }
    void setRequestFramesHandler(StreamFrameHandler& handler) override {
      ASSERT(parent_.request_stream_frame_handler_ == nullptr,
             "request frames handler is already set");
      parent_.request_stream_frame_handler_ = &handler;
    }
    void completeDirectly() override { parent_.completeDirectly(); }

    DecoderFilterSharedPtr filter_;
  };
  using ActiveDecoderFilterPtr = std::unique_ptr<ActiveDecoderFilter>;

  class ActiveEncoderFilter : public ActiveFilterBase, public EncoderFilterCallback {
  public:
    ActiveEncoderFilter(ActiveStream& parent, FilterContext context, EncoderFilterSharedPtr filter,
                        bool is_dual)
        : ActiveFilterBase(parent, context, is_dual), filter_(std::move(filter)) {
      filter_->setEncoderFilterCallbacks(*this);
    }

    // EncoderFilterCallback
    void continueEncoding() override { parent_.continueEncoding(); }

    EncoderFilterSharedPtr filter_;
  };
  using ActiveEncoderFilterPtr = std::unique_ptr<ActiveEncoderFilter>;

  class FilterChainFactoryCallbacksHelper : public FilterChainFactoryCallbacks {
  public:
    FilterChainFactoryCallbacksHelper(ActiveStream& parent, FilterContext context)
        : parent_(parent), context_(context) {}

    // FilterChainFactoryCallbacks
    void addDecoderFilter(DecoderFilterSharedPtr filter) override {
      parent_.addDecoderFilter(
          std::make_unique<ActiveDecoderFilter>(parent_, context_, std::move(filter), false));
    }
    void addEncoderFilter(EncoderFilterSharedPtr filter) override {
      parent_.addEncoderFilter(
          std::make_unique<ActiveEncoderFilter>(parent_, context_, std::move(filter), false));
    }
    void addFilter(StreamFilterSharedPtr filter) override {
      parent_.addDecoderFilter(
          std::make_unique<ActiveDecoderFilter>(parent_, context_, filter, true));
      parent_.addEncoderFilter(
          std::make_unique<ActiveEncoderFilter>(parent_, context_, std::move(filter), true));
    }

  private:
    ActiveStream& parent_;
    FilterContext context_;
  };

  ActiveStream(Filter& parent, StreamRequestPtr request);

  void addDecoderFilter(ActiveDecoderFilterPtr filter) {
    decoder_filters_.emplace_back(std::move(filter));
  }
  void addEncoderFilter(ActiveEncoderFilterPtr filter) {
    encoder_filters_.emplace_back(std::move(filter));
  }

  void initializeFilterChain(FilterChainFactory& factory);

  Envoy::Event::Dispatcher& dispatcher();
  const CodecFactory& downstreamCodec();
  void resetStream(DownstreamStreamResetReason reason);
  StreamInfo::StreamInfoImpl& streamInfo() { return stream_info_; }
  const RouteEntry* routeEntry() const { return cached_route_entry_.get(); }

  void sendLocalReply(Status status, absl::string_view data, ResponseUpdateFunction func);
  void continueDecoding();
  void onResponseStart(StreamResponsePtr response);
  void onResponseFrame(StreamFramePtr frame);
  void completeDirectly();

  void continueEncoding();

  // FilterChainManager
  void applyFilterFactoryCb(FilterContext context, FilterFactoryCb& factory) override {
    FilterChainFactoryCallbacksHelper callbacks(*this, context);
    factory(callbacks);
  }

  // ResponseEncoderCallback
  void onEncodingSuccess(Buffer::Instance& buffer, bool end_stream) override;

  void onRequestFrame(StreamFramePtr frame);

  std::vector<ActiveDecoderFilterPtr>& decoderFiltersForTest() { return decoder_filters_; }
  std::vector<ActiveEncoderFilterPtr>& encoderFiltersForTest() { return encoder_filters_; }
  size_t nextDecoderFilterIndexForTest() { return next_decoder_filter_index_; }
  size_t nextEncoderFilterIndexForTest() { return next_encoder_filter_index_; }

  Tracing::Span& activeSpan() {
    if (active_span_) {
      return *active_span_;
    } else {
      return Tracing::NullSpan::instance();
    }
  }

  OptRef<const Tracing::Config> tracingConfig() const {
    if (connection_manager_tracing_config_.has_value()) {
      return {*this};
    }
    return {};
  }

  void completeRequest();

  uint64_t requestStreamId() const {
    return request_stream_->frameFlags().streamFlags().streamId();
  }

private:
  // Keep these methods private to ensure that these methods are only called by the reference
  // returned by the public tracingConfig() method.
  // Tracing::TracingConfig
  Tracing::OperationName operationName() const override;
  const Tracing::CustomTagMap* customTags() const override;
  bool verbose() const override;
  uint32_t maxPathTagLength() const override;
  bool spawnUpstreamSpan() const override;

  void sendRequestFrameToUpstream();

  void sendResponseStartToDownstream();
  void sendResponseFrameToDownstream();

  bool active_stream_reset_{false};

  bool registered_in_frame_handlers_{false};

  Filter& parent_;

  StreamRequestPtr request_stream_;
  std::list<StreamFramePtr> request_stream_frames_;
  bool request_stream_end_{false};
  bool request_filter_chain_complete_{false};

  StreamFrameHandler* request_stream_frame_handler_{nullptr};

  StreamResponsePtr response_stream_;
  std::list<StreamFramePtr> response_stream_frames_;
  bool response_stream_end_{false};
  bool response_filter_chain_complete_{false};
  bool local_reply_{false};

  RouteEntryConstSharedPtr cached_route_entry_;

  std::vector<ActiveDecoderFilterPtr> decoder_filters_;
  size_t next_decoder_filter_index_{0};

  std::vector<ActiveEncoderFilterPtr> encoder_filters_;
  size_t next_encoder_filter_index_{0};

  StreamInfo::StreamInfoImpl stream_info_;

  OptRef<const Tracing::ConnectionManagerTracingConfig> connection_manager_tracing_config_;
  Tracing::SpanPtr active_span_;
};
using ActiveStreamPtr = std::unique_ptr<ActiveStream>;

class Filter : public Envoy::Network::ReadFilter,
               public Network::ConnectionCallbacks,
               public Envoy::Logger::Loggable<Envoy::Logger::Id::filter>,
               public ServerCodecCallbacks {
public:
  Filter(FilterConfigSharedPtr config, Server::Configuration::FactoryContext& context)
      : config_(std::move(config)),
        stats_helper_(config_->codeOrFlags(), config_->stats(), context.scope()),
        drain_decision_(config_->drainDecision()),
        time_source_(context.serverFactoryContext().timeSource()),
        runtime_(context.serverFactoryContext().runtime()),
        cluster_manager_(context.serverFactoryContext().clusterManager()) {
    server_codec_ = config_->codecFactory().createServerCodec();
    server_codec_->setCodecCallbacks(*this);
  }

  // Envoy::Network::ReadFilter
  Envoy::Network::FilterStatus onData(Envoy::Buffer::Instance& data, bool end_stream) override;
  Envoy::Network::FilterStatus onNewConnection() override {
    return Envoy::Network::FilterStatus::Continue;
  }
  void initializeReadFilterCallbacks(Envoy::Network::ReadFilterCallbacks& callbacks) override {
    callbacks_ = &callbacks;
    callbacks_->connection().addConnectionCallbacks(*this);
  }

  // RequestDecoderCallback
  void onDecodingSuccess(StreamFramePtr request) override;
  void onDecodingFailure() override;
  void writeToConnection(Buffer::Instance& buffer) override;
  OptRef<Network::Connection> connection() override;

  // Network::ConnectionCallbacks
  void onEvent(Network::ConnectionEvent event) override {
    ENVOY_LOG(debug, "generic proxy: downstream connection event {}", static_cast<uint32_t>(event));
    if (event == Network::ConnectionEvent::Connected ||
        event == Network::ConnectionEvent::ConnectedZeroRtt) {
      return;
    }
    downstream_connection_closed_ = true;
    resetDownstreamAllStreams(event == Network::ConnectionEvent::LocalClose
                                  ? DownstreamStreamResetReason::LocalConnectionTermination
                                  : DownstreamStreamResetReason::ConnectionTermination);
  }
  void onAboveWriteBufferHighWatermark() override {}
  void onBelowWriteBufferLowWatermark() override {}

  void sendFrameToDownstream(StreamFrame& frame, EncodingCallbacks& callbacks);

  Network::Connection& downstreamConnection() {
    ASSERT(callbacks_ != nullptr);
    return callbacks_->connection();
  }

  /**
   * Create a new active stream and add it to the active stream list.
   * @param request the request to be processed.
   */
  void newDownstreamRequest(StreamRequestPtr request);

  /**
   * Move the stream to the deferred delete stream list. This is called when the stream is reset
   * or completed.
   * @param stream the stream to be deferred deleted.
   */
  void deferredStream(ActiveStream& stream);

  static const std::string& name() {
    CONSTRUCT_ON_FIRST_USE(std::string, "envoy.filters.network.generic_proxy");
  }

  std::list<ActiveStreamPtr>& activeStreamsForTest() { return active_streams_; }
  const auto& frameHandlersForTest() { return frame_handlers_; }

  // This may be called multiple times in some scenarios. But it is safe.
  void resetDownstreamAllStreams(DownstreamStreamResetReason reason);
  // This may be called multiple times in some scenarios. But it is safe.
  void closeDownstreamConnection();

  void mayBeDrainClose();

protected:
  // This will be called when drain decision is made and all active streams are handled.
  // This is a virtual method so that it can be overridden by derived classes.
  virtual void onDrainCloseAndNoActiveStreams();

  Envoy::Network::ReadFilterCallbacks* callbacks_{nullptr};

private:
  friend class ActiveStream;
  friend class UpstreamManagerImpl;

  void registerFrameHandler(uint64_t stream_id, ActiveStream* stream);
  void unregisterFrameHandler(uint64_t stream_id);

  bool downstream_connection_closed_{};

  FilterConfigSharedPtr config_{};
  GenericFilterStatsHelper stats_helper_;

  const Network::DrainDecision& drain_decision_;
  bool stream_drain_decision_{};
  TimeSource& time_source_;
  Runtime::Loader& runtime_;
  Upstream::ClusterManager& cluster_manager_;

  ServerCodecPtr server_codec_;

  Buffer::OwnedImpl response_buffer_;

  std::list<ActiveStreamPtr> active_streams_;
  absl::flat_hash_map<uint64_t, ActiveStream*> frame_handlers_;
};

} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/generic_proxy/filters/network/source/proxy.h"

#include <cstdint>

#include "envoy/common/exception.h"
#include "envoy/network/connection.h"

#include "source/common/config/utility.h"
#include "source/common/protobuf/protobuf.h"
#include "source/common/stream_info/stream_info_impl.h"

#include "contrib/generic_proxy/filters/network/source/interface/config.h"
#include "contrib/generic_proxy/filters/network/source/interface/filter.h"
#include "contrib/generic_proxy/filters/network/source/route.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace GenericProxy {

namespace {

Tracing::Decision tracingDecision(const Tracing::ConnectionManagerTracingConfig& tracing_config,
                                  Runtime::Loader& runtime) {
  bool traced = runtime.snapshot().featureEnabled("tracing.random_sampling",
                                                  tracing_config.getRandomSampling());

  if (traced) {
    return {Tracing::Reason::Sampling, true};
  }
  return {Tracing::Reason::NotTraceable, false};
}

StreamInfo::ResponseFlag
responseFlagFromDownstreamReasonReason(DownstreamStreamResetReason reason) {
  switch (reason) {
  case DownstreamStreamResetReason::ConnectionTermination:
    return StreamInfo::ResponseFlag::DownstreamConnectionTermination;
  case DownstreamStreamResetReason::LocalConnectionTermination:
    return StreamInfo::ResponseFlag::LocalReset;
  case DownstreamStreamResetReason::ProtocolError:
    return StreamInfo::ResponseFlag::DownstreamProtocolError;
  }
  PANIC("Unknown reset reason");
}

} // namespace

ActiveStream::ActiveStream(Filter& parent, StreamRequestPtr request)
    : parent_(parent), request_stream_(std::move(request)),
      request_stream_end_(request_stream_->frameFlags().endStream()),
      stream_info_(parent_.time_source_,
                   parent_.callbacks_->connection().connectionInfoProviderSharedPtr()) {
  if (!request_stream_end_) {
    // If the request is not fully received, register the stream to the frame handler map.
    parent_.registerFrameHandler(requestStreamId(), this);
    registered_in_frame_handlers_ = true;
  } else {
    // The request is fully received.
    stream_info_.downstreamTiming().onLastDownstreamRxByteReceived(parent_.time_source_);
  }

  parent_.stats_helper_.onRequest();

  connection_manager_tracing_config_ = parent_.config_->tracingConfig();

  auto tracer = parent_.config_->tracingProvider();

  if (!connection_manager_tracing_config_.has_value() || !tracer.has_value()) {
    return;
  }

  auto decision = tracingDecision(connection_manager_tracing_config_.value(), parent_.runtime_);
  if (decision.traced) {
    stream_info_.setTraceReason(decision.reason);
  }

  TraceContextBridge trace_context{*request_stream_};
  active_span_ = tracer->startSpan(*this, trace_context, stream_info_, decision);
}

Tracing::OperationName ActiveStream::operationName() const {
  ASSERT(connection_manager_tracing_config_.has_value());
  return connection_manager_tracing_config_->operationName();
}

const Tracing::CustomTagMap* ActiveStream::customTags() const {
  ASSERT(connection_manager_tracing_config_.has_value());
  return &connection_manager_tracing_config_->getCustomTags();
}

bool ActiveStream::verbose() const {
  ASSERT(connection_manager_tracing_config_.has_value());
  return connection_manager_tracing_config_->verbose();
}

uint32_t ActiveStream::maxPathTagLength() const {
  ASSERT(connection_manager_tracing_config_.has_value());
  return connection_manager_tracing_config_->maxPathTagLength();
}

bool ActiveStream::spawnUpstreamSpan() const {
  ASSERT(connection_manager_tracing_config_.has_value());
  return connection_manager_tracing_config_->spawnUpstreamSpan();
}

Envoy::Event::Dispatcher& ActiveStream::dispatcher() {
  return parent_.downstreamConnection().dispatcher();
}
const CodecFactory& ActiveStream::downstreamCodec() { return parent_.config_->codecFactory(); }
void ActiveStream::resetStream(DownstreamStreamResetReason reason) {
  if (active_stream_reset_) {
    return;
  }
  active_stream_reset_ = true;

  parent_.stats_helper_.onRequestReset();
  stream_info_.setResponseFlag(responseFlagFromDownstreamReasonReason(reason));

  parent_.deferredStream(*this);
}

void ActiveStream::sendResponseStartToDownstream() {
  ASSERT(response_stream_ != nullptr);
  response_filter_chain_complete_ = true;
  // The first frame of response is sent.
  stream_info_.downstreamTiming().onFirstDownstreamTxByteSent(parent_.time_source_);
  parent_.sendFrameToDownstream(*response_stream_, *this);
}

void ActiveStream::sendResponseFrameToDownstream() {
  if (!response_filter_chain_complete_) {
    // Wait for the response header frame to be sent first. It may be blocked by
    // the filter chain.
    return;
  }

  while (!response_stream_frames_.empty()) {
    // Pop the first frame from the queue.
    auto frame = std::move(response_stream_frames_.front());
    response_stream_frames_.pop_front();

    // Send the frame to downstream.
    parent_.sendFrameToDownstream(*frame, *this);
  }
}

void ActiveStream::sendRequestFrameToUpstream() {
  if (!request_filter_chain_complete_) {
    // Wait for the request header frame to be sent first. It may be blocked by
    // the filter chain.
    return;
  }

  if (request_stream_frame_handler_ == nullptr) {
    // The request stream frame handler is not ready yet.
    return;
  }

  while (!request_stream_frames_.empty()) {
    // Pop the first frame from the queue.
    auto frame = std::move(request_stream_frames_.front());
    request_stream_frames_.pop_front();

    // Send the frame to upstream.
    request_stream_frame_handler_->onStreamFrame(std::move(frame));
  }
}

// TODO(wbpcode): add the short_response_flags support to the sendLocalReply
// method.
void ActiveStream::sendLocalReply(Status status, absl::string_view data,
                                  ResponseUpdateFunction func) {
  response_stream_ = parent_.server_codec_->respond(status, data, *request_stream_);
  response_stream_frames_.clear();
  // Only one frame is allowed in the local reply.
  response_stream_end_ = true;

  ASSERT(response_stream_ != nullptr);

  if (func != nullptr) {
    func(*response_stream_);
  }

  local_reply_ = true;
  // status message will be used as response code details.
  stream_info_.setResponseCodeDetails(status.message());
  // Set the response code to the stream info.
  stream_info_.setResponseCode(response_stream_->status().code());

  sendResponseStartToDownstream();
}

void ActiveStream::continueDecoding() {
  if (active_stream_reset_ || request_stream_ == nullptr) {
    return;
  }

  if (cached_route_entry_ == nullptr) {
    cached_route_entry_ = parent_.config_->routeEntry(*request_stream_);
    if (cached_route_entry_ != nullptr) {
      auto* cluster =
          parent_.cluster_manager_.getThreadLocalCluster(cached_route_entry_->clusterName());
      if (cluster != nullptr) {
        stream_info_.setUpstreamClusterInfo(cluster->info());
      }
    }
  }

  ASSERT(request_stream_ != nullptr);
  for (; next_decoder_filter_index_ < decoder_filters_.size();) {
    auto status =
        decoder_filters_[next_decoder_filter_index_]->filter_->onStreamDecoded(*request_stream_);
    next_decoder_filter_index_++;
    if (status == FilterStatus::StopIteration) {
      break;
    }
  }
  if (next_decoder_filter_index_ == decoder_filters_.size()) {
    ENVOY_LOG(debug, "Complete decoder filters");
    request_filter_chain_complete_ = true;
    sendRequestFrameToUpstream();
  }
}

void ActiveStream::onRequestFrame(StreamFramePtr frame) {
  request_stream_end_ = frame->frameFlags().endStream();
  request_stream_frames_.emplace_back(std::move(frame));

  ASSERT(registered_in_frame_handlers_);
  if (request_stream_end_) {
    // The request is fully received.
    stream_info_.downstreamTiming().onLastDownstreamRxByteReceived(parent_.time_source_);

    // If the request is fully received, remove the stream from the
    // frame handler map.
    parent_.unregisterFrameHandler(requestStreamId());
    registered_in_frame_handlers_ = false;
  }

  // Try to send the frame to upstream immediately.
  sendRequestFrameToUpstream();
}

void ActiveStream::onResponseStart(ResponsePtr response) {
  ASSERT(response_stream_ == nullptr);
  response_stream_ = std::move(response);
  ASSERT(response_stream_ != nullptr);
  response_stream_end_ = response_stream_->frameFlags().endStream();
  parent_.stream_drain_decision_ = response_stream_->frameFlags().streamFlags().drainClose();

  // The response code details always be "via_upstream" for response from upstream.
  stream_info_.setResponseCodeDetails("via_upstream");
  // Set the response code to the stream info.
  stream_info_.setResponseCode(response_stream_->status().code());
  continueEncoding();
}

void ActiveStream::onResponseFrame(StreamFramePtr frame) {
  response_stream_end_ = frame->frameFlags().endStream();
  response_stream_frames_.emplace_back(std::move(frame));
  // Try to send the frame to downstream immediately.
  sendResponseFrameToDownstream();
}

void ActiveStream::completeDirectly() {
  response_stream_end_ = true;
  parent_.deferredStream(*this);
};

const Network::Connection* ActiveStream::ActiveFilterBase::connection() const {
  return &parent_.parent_.downstreamConnection();
}

void ActiveStream::continueEncoding() {
  if (active_stream_reset_ || response_stream_ == nullptr) {
    return;
  }

  ASSERT(response_stream_ != nullptr);
  for (; next_encoder_filter_index_ < encoder_filters_.size();) {
    auto status =
        encoder_filters_[next_encoder_filter_index_]->filter_->onStreamEncoded(*response_stream_);
    next_encoder_filter_index_++;
    if (status == FilterStatus::StopIteration) {
      break;
    }
  }

  if (next_encoder_filter_index_ == encoder_filters_.size()) {
    ENVOY_LOG(debug, "Complete encoder filters");
    sendResponseStartToDownstream();
    sendResponseFrameToDownstream();
  }
}

void ActiveStream::onEncodingSuccess(Buffer::Instance& buffer, bool end_stream) {
  ASSERT(parent_.downstreamConnection().state() == Network::Connection::State::Open);
  parent_.downstreamConnection().write(buffer, false);

  if (!end_stream) {
    return;
  }

  // The response is fully sent.
  stream_info_.downstreamTiming().onLastDownstreamTxByteSent(parent_.time_source_);

  ENVOY_LOG(debug, "Generic proxy: downstream response complete");

  ASSERT(response_stream_end_);
  ASSERT(response_stream_frames_.empty());

  parent_.deferredStream(*this);
}

void ActiveStream::initializeFilterChain(FilterChainFactory& factory) {
  factory.createFilterChain(*this);
  // Reverse the encoder filter chain so that the first encoder filter is the last filter in the
  // chain.
  std::reverse(encoder_filters_.begin(), encoder_filters_.end());
}

void ActiveStream::completeRequest() {
  if (registered_in_frame_handlers_) {
    parent_.unregisterFrameHandler(requestStreamId());
    registered_in_frame_handlers_ = false;
  }

  stream_info_.onRequestComplete();

  bool error_reply = false;
  // This response frame may be nullptr if the request is one-way.
  if (response_stream_ != nullptr) {
    error_reply = !response_stream_->status().ok();
  }
  parent_.stats_helper_.onRequestComplete(stream_info_, local_reply_, error_reply);

  if (active_span_) {
    TraceContextBridge trace_context{*request_stream_};
    Tracing::TracerUtility::finalizeSpan(*active_span_, trace_context, stream_info_, *this, false);
  }

  for (const auto& access_log : parent_.config_->accessLogs()) {
    access_log->log({request_stream_.get(), response_stream_.get()}, stream_info_);
  }

  for (auto& filter : decoder_filters_) {
    filter->filter_->onDestroy();
  }
  for (auto& filter : encoder_filters_) {
    if (filter->isDualFilter()) {
      continue;
    }
    filter->filter_->onDestroy();
  }
}

Envoy::Network::FilterStatus Filter::onData(Envoy::Buffer::Instance& data, bool end_stream) {
  if (downstream_connection_closed_) {
    return Envoy::Network::FilterStatus::StopIteration;
  }

  // Basically this end_stream should always be false because we don't support half-close.
  server_codec_->decode(data, end_stream);
  return Envoy::Network::FilterStatus::StopIteration;
}

void Filter::onDecodingSuccess(StreamFramePtr request) {
  const uint64_t stream_id = request->frameFlags().streamFlags().streamId();
  // One existing stream expects this frame.
  if (auto iter = frame_handlers_.find(stream_id); iter != frame_handlers_.end()) {
    iter->second->onRequestFrame(std::move(request));
    return;
  }

  StreamFramePtrHelper<StreamRequest> helper(std::move(request));

  // Create a new active stream for the leading StreamRequest frame.
  if (helper.typed_frame_ != nullptr) {
    newDownstreamRequest(std::move(helper.typed_frame_));
    return;
  }

  ASSERT(helper.frame_ != nullptr);
  // No existing stream expects this non-leading frame. It should not happen.
  // We treat it as request decoding failure.
  ENVOY_LOG(error, "generic proxy: id {} not found for stream frame",
            helper.frame_->frameFlags().streamFlags().streamId());
  onDecodingFailure();
}

void Filter::onDecodingFailure() {
  stats_helper_.onRequestDecodingError();

  resetDownstreamAllStreams(DownstreamStreamResetReason::ProtocolError);
  closeDownstreamConnection();
}

void Filter::writeToConnection(Buffer::Instance& buffer) {
  if (downstream_connection_closed_) {
    return;
  }
  downstreamConnection().write(buffer, false);
}

OptRef<Network::Connection> Filter::connection() {
  if (downstream_connection_closed_) {
    return {};
  }
  return {downstreamConnection()};
}

void Filter::sendFrameToDownstream(StreamFrame& frame, EncodingCallbacks& callbacks) {
  server_codec_->encode(frame, callbacks);
}

void Filter::registerFrameHandler(uint64_t stream_id, ActiveStream* raw_stream) {
  // If the stream expects variable length frames, then add it to the frame
  // handler map.
  // This map entry will be removed when the request or response end frame is
  // received.
  if (frame_handlers_.contains(stream_id)) {
    ENVOY_LOG(error, "generic proxy: repetitive stream id: {} at same time", stream_id);
    onDecodingFailure();
    return;
  }
  frame_handlers_[stream_id] = raw_stream;
}

void Filter::unregisterFrameHandler(uint64_t stream_id) { frame_handlers_.erase(stream_id); }

void Filter::newDownstreamRequest(StreamRequestPtr request) {
  auto stream = std::make_unique<ActiveStream>(*this, std::move(request));
  auto raw_stream = stream.get();
  LinkedList::moveIntoList(std::move(stream), active_streams_);

  // Initialize filter chian.
  raw_stream->initializeFilterChain(*config_);
  // Start request.
  raw_stream->continueDecoding();
}

void Filter::deferredStream(ActiveStream& stream) {
  stream.completeRequest();

  if (!stream.inserted()) {
    return;
  }
  callbacks_->connection().dispatcher().deferredDelete(stream.removeFromList(active_streams_));
  mayBeDrainClose();
}

void Filter::resetDownstreamAllStreams(DownstreamStreamResetReason reason) {
  while (!active_streams_.empty()) {
    active_streams_.front()->resetStream(reason);
  }
}

void Filter::closeDownstreamConnection() {
  if (downstream_connection_closed_) {
    return;
  }
  downstream_connection_closed_ = true;
  downstreamConnection().close(Network::ConnectionCloseType::FlushWrite);
}

void Filter::mayBeDrainClose() {
  if ((drain_decision_.drainClose() || stream_drain_decision_) && active_streams_.empty()) {
    onDrainCloseAndNoActiveStreams();
  }
}

// Default implementation for connection draining.
void Filter::onDrainCloseAndNoActiveStreams() { closeDownstreamConnection(); }

} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/generic_proxy/filters/network/source/tracing.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace GenericProxy {

absl::string_view TraceContextBridge::protocol() const { return request_.protocol(); }
absl::string_view TraceContextBridge::host() const { return request_.host(); }
absl::string_view TraceContextBridge::path() const { return request_.path(); }
absl::string_view TraceContextBridge::method() const { return request_.method(); }
void TraceContextBridge::forEach(IterateCallback callback) const { request_.forEach(callback); }
absl::optional<absl::string_view> TraceContextBridge::get(absl::string_view key) const {
  return request_.get(key);
}
void TraceContextBridge::set(absl::string_view key, absl::string_view val) {
  request_.set(key, val);
}
void TraceContextBridge::remove(absl::string_view key) { request_.erase(key); }

} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_library(
    name = "proxy_lib",
    srcs = [
        "proxy.cc",
    ],
    hdrs = [
        "proxy.h",
    ],
    deps = [
        ":rds_lib",
        ":route_lib",
        ":stats_lib",
        ":tracing_lib",
        "//contrib/generic_proxy/filters/network/source/interface:codec_interface",
        "//contrib/generic_proxy/filters/network/source/interface:proxy_config_interface",
        "//contrib/generic_proxy/filters/network/source/router:router_lib",
        "//envoy/network:filter_interface",
        "//envoy/server:factory_context_interface",
        "//envoy/stats:timespan_interface",
        "//source/common/common:linked_object",
        "//source/common/common:minimal_logger_lib",
        "//source/common/stats:timespan_lib",
        "//source/common/stream_info:stream_info_lib",
        "//source/common/tracing:tracer_config_lib",
        "//source/common/tracing:tracer_lib",
        "//source/common/tracing:tracer_manager_lib",
        "//source/extensions/filters/network/common:factory_base_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/generic_proxy/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_contrib_extension(
    name = "config",
    srcs = [
        "config.cc",
    ],
    hdrs = [
        "config.h",
    ],
    deps = [
        ":proxy_lib",
        "//contrib/generic_proxy/filters/network/source/router:config",
        "//envoy/server:filter_config_interface",
        "//source/common/access_log:access_log_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/generic_proxy/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "route_lib",
    srcs = [
        "route.cc",
    ],
    hdrs = [
        "route.h",
    ],
    deps = [
        ":match_lib",
        "//contrib/generic_proxy/filters/network/source/interface:config_interface",
        "//contrib/generic_proxy/filters/network/source/interface:route_interface",
        "//envoy/server:factory_context_interface",
        "//source/common/common:matchers_lib",
        "//source/common/config:metadata_lib",
        "//source/common/config:utility_lib",
        "//source/common/matcher:matcher_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/generic_proxy/action/v3:pkg_cc_proto",
        "@envoy_api//contrib/envoy/extensions/filters/network/generic_proxy/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/route/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "match_lib",
    srcs = [
        "match.cc",
    ],
    hdrs = [
        "match.h",
    ],
    deps = [
        "//contrib/generic_proxy/filters/network/source/interface:stream_interface",
        "//source/common/matcher:matcher_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/generic_proxy/matcher/v3:pkg_cc_proto",
    ],
    alwayslink = 1,
)

envoy_cc_library(
    name = "rds_interface",
    hdrs = ["rds.h"],
    deps = [
        "//envoy/rds:rds_interface",
        "@envoy_api//contrib/envoy/extensions/filters/network/generic_proxy/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "rds_lib",
    hdrs = [
        "rds_impl.h",
    ],
    deps = [
        ":rds_interface",
        ":route_lib",
        "//envoy/rds:rds_interface",
        "//source/common/rds:rds_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/generic_proxy/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "upstream_lib",
    srcs = [
        "upstream.cc",
    ],
    hdrs = [
        "upstream.h",
    ],
    deps = [
        "//contrib/generic_proxy/filters/network/source/interface:codec_interface",
        "//envoy/network:connection_interface",
        "//envoy/upstream:thread_local_cluster_interface",
    ],
)

envoy_cc_library(
    name = "stats_lib",
    srcs = ["stats.cc"],
    hdrs = ["stats.h"],
    deps = [
        "//envoy/server:factory_context_interface",
        "//envoy/stats:stats_interface",
        "//envoy/stats:stats_macros",
        "//source/common/stats:symbol_table_lib",
        "//source/common/stream_info:utility_lib",
    ],
)

envoy_cc_library(
    name = "file_access_log_lib",
    hdrs = [
        "file_access_log.h",
    ],
    deps = [
        "//envoy/access_log:access_log_config_interface",
        "//envoy/access_log:access_log_interface",
        "//source/common/common:utility_lib",
        "//source/common/formatter:substitution_format_string_lib",
        "@envoy_api//envoy/extensions/access_loggers/file/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "access_log_lib",
    srcs = [
        "access_log.cc",
    ],
    hdrs = [
        "access_log.h",
    ],
    deps = [
        ":file_access_log_lib",
        "//contrib/generic_proxy/filters/network/source/interface:stream_interface",
    ],
    # Ensure this factory in the source is always linked in.
    alwayslink = 1,
)

envoy_cc_library(
    name = "tracing_lib",
    srcs = [
        "tracing.cc",
    ],
    hdrs = [
        "tracing.h",
    ],
    external_deps = [
        "abseil_strings",
        "abseil_optional",
        "abseil_status",
    ],
    deps = [
        "//contrib/generic_proxy/filters/network/source/interface:stream_interface",
        "//envoy/common:pure_lib",
        "//envoy/tracing:trace_context_interface",
    ],
)
#pragma once

#include <memory>

#include "envoy/network/connection.h"
#include "envoy/upstream/thread_local_cluster.h"

#include "contrib/generic_proxy/filters/network/source/interface/codec.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace GenericProxy {

class UpstreamConnection : public Envoy::Event::DeferredDeletable,
                           public Tcp::ConnectionPool::Callbacks,
                           public Tcp::ConnectionPool::UpstreamCallbacks,
                           public Envoy::Logger::Loggable<Envoy::Logger::Id::upstream> {
public:
  ~UpstreamConnection() override;

  void newConnection() { tcp_pool_handle_ = tcp_pool_data_.newConnection(*this); }

  void initialize();
  virtual void cleanUp(bool close_connection);

  // Tcp::ConnectionPool::Callbacks
  void onPoolFailure(ConnectionPool::PoolFailureReason, absl::string_view,
                     Upstream::HostDescriptionConstSharedPtr) override;
  void onPoolReady(Tcp::ConnectionPool::ConnectionDataPtr&& conn_data,
                   Upstream::HostDescriptionConstSharedPtr host) override;

  // Tcp::ConnectionPool::UpstreamCallbacks
  void onAboveWriteBufferHighWatermark() override {}
  void onBelowWriteBufferLowWatermark() override {}
  void onUpstreamData(Buffer::Instance& data, bool end_stream) override;
  void onEvent(Network::ConnectionEvent) override;

  ClientCodecPtr& clientCodec() { return client_codec_; }

protected:
  UpstreamConnection(Upstream::TcpPoolData&& tcp_pool_data, ClientCodecPtr&& client_codec)
      : tcp_pool_data_(std::move(tcp_pool_data)), client_codec_(std::move(client_codec)) {}

  virtual void onEventImpl(Network::ConnectionEvent event) PURE;
  virtual void onPoolSuccessImpl() PURE;
  virtual void onPoolFailureImpl(ConnectionPool::PoolFailureReason reason,
                                 absl::string_view transport_failure_reason) PURE;

  Upstream::TcpPoolData tcp_pool_data_;
  ClientCodecPtr client_codec_;

  bool is_cleaned_up_{};
  // Whether the upstream connection is created. This will be set to true when the initialize()
  // is called.
  bool initialized_{};

  Tcp::ConnectionPool::Cancellable* tcp_pool_handle_{};
  Tcp::ConnectionPool::ConnectionDataPtr owned_conn_data_;
  Upstream::HostDescriptionConstSharedPtr upstream_host_;
};

} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include <string>

#include "envoy/server/factory_context.h"
#include "envoy/singleton/instance.h"
#include "envoy/stats/scope.h"
#include "envoy/stats/stats_macros.h"

#include "source/common/stats/symbol_table.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace GenericProxy {

/**
 * All code and flags that generic proxy filter can emit. This should be global singleton.
 */
class CodeOrFlags : public Singleton::Instance {
public:
  CodeOrFlags(Server::Configuration::ServerFactoryContext& context);

  Stats::StatName statNameFromCode(uint32_t code) const;
  Stats::StatName statNameFromFlag(StreamInfo::ResponseFlag flag) const;

private:
  Stats::StatNamePool pool_;

  std::vector<Stats::StatName> code_stat_names_;
  absl::flat_hash_map<StreamInfo::ResponseFlag, Stats::StatName> flag_stat_names_;

  Stats::StatName unknown_code_or_flag_;
};

/**
 * All generic filter stats. @see stats_macros.h. In addition to following stats, the generic
 * filter also exports stats for every status code and stream info response flag.
 */
#define ALL_GENERIC_FILTER_STATS(COUNTER, GAUGE, HISTOGRAM)                                        \
  COUNTER(downstream_rq_total)                                                                     \
  COUNTER(downstream_rq_error)                                                                     \
  COUNTER(downstream_rq_reset)                                                                     \
  COUNTER(downstream_rq_local)                                                                     \
  COUNTER(downstream_rq_decoding_error)                                                            \
  GAUGE(downstream_rq_active, Accumulate)                                                          \
  HISTOGRAM(downstream_rq_time, Milliseconds)                                                      \
  HISTOGRAM(downstream_rq_tx_time, Microseconds)

/**
 * Struct definition for all generic proxy stats. @see stats_macros.h
 */
struct GenericFilterStats {
  ALL_GENERIC_FILTER_STATS(GENERATE_COUNTER_STRUCT, GENERATE_GAUGE_STRUCT,
                           GENERATE_HISTOGRAM_STRUCT)

  Stats::StatNameManagedStorage stats_prefix_storage_;
  Stats::StatNameManagedStorage downstream_rq_code_storage_;
  Stats::StatNameManagedStorage downstream_rq_flag_storage_;

  Stats::StatName stats_prefix_{stats_prefix_storage_.statName()};
  Stats::StatName downstream_rq_code_{downstream_rq_code_storage_.statName()};
  Stats::StatName downstream_rq_flag_{downstream_rq_flag_storage_.statName()};

  static GenericFilterStats generateStats(const std::string& prefix, Stats::Scope& stats_scope) {
    return GenericFilterStats{
        ALL_GENERIC_FILTER_STATS(POOL_COUNTER_PREFIX(stats_scope, prefix),
                                 POOL_GAUGE_PREFIX(stats_scope, prefix),
                                 POOL_HISTOGRAM_PREFIX(stats_scope, prefix))
            Stats::StatNameManagedStorage{prefix, stats_scope.symbolTable()},
        Stats::StatNameManagedStorage{"downstream_rq_code", stats_scope.symbolTable()},
        Stats::StatNameManagedStorage{"downstream_rq_flag", stats_scope.symbolTable()},
    };
  }
};

class GenericFilterStatsHelper {
public:
  GenericFilterStatsHelper(const CodeOrFlags& code_or_flag, GenericFilterStats& stats,
                           Stats::Scope& stats_scope)
      : code_or_flag_(code_or_flag), stats_(stats), stats_scope_(stats_scope) {}

  void onRequestReset();
  void onRequestDecodingError();
  void onRequest();
  void onRequestComplete(const StreamInfo::StreamInfo& info, bool local_reply, bool error_reply);

private:
  const CodeOrFlags& code_or_flag_;
  GenericFilterStats& stats_;
  Stats::Scope& stats_scope_;

  // The following two pairs are used to avoid stats name creation and symbol table lookup
  // for every request. In all practical cases, there most requests will have the same
  // status code and response flag.
  // When a request is completed, we will check if the status code or response flag is
  // same as the last one. If so, we will use the same counter. Otherwise, we will try to
  // find the counter in the scope and update these pairs.
  // Even in the worst case where the status code and response flag are different for every
  // request, we will only do some additional integer comparisons and local variable
  // assignments which should be very cheap.
  std::pair<uint32_t, OptRef<Stats::Counter>> last_code_counter_{};
  std::pair<StreamInfo::ResponseFlag, OptRef<Stats::Counter>> last_flag_counter_{};
};

} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/tracing/trace_context.h"

#include "contrib/generic_proxy/filters/network/source/interface/stream.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace GenericProxy {

/*
 * Simple wrapper around a StreamRequest that provides the TraceContext interface.
 */
class TraceContextBridge : public Tracing::TraceContext {
public:
  TraceContextBridge(StreamRequest& request) : request_(request) {}

  // Tracing::TraceContext
  absl::string_view protocol() const override;
  absl::string_view host() const override;
  absl::string_view path() const override;
  absl::string_view method() const override;
  void forEach(IterateCallback callback) const override;
  absl::optional<absl::string_view> get(absl::string_view key) const override;
  void set(absl::string_view key, absl::string_view val) override;
  void remove(absl::string_view key) override;

private:
  StreamRequest& request_;
};

} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/generic_proxy/filters/network/source/config.h"

#include "source/common/access_log/access_log_impl.h"
#include "source/common/tracing/tracer_manager_impl.h"

#include "access_log.h"
#include "contrib/generic_proxy/filters/network/source/rds.h"
#include "contrib/generic_proxy/filters/network/source/rds_impl.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace GenericProxy {

SINGLETON_MANAGER_REGISTRATION(generic_route_config_provider_manager);
SINGLETON_MANAGER_REGISTRATION(generic_proxy_code_or_flag_stats);

std::pair<CodecFactoryPtr, ProxyFactoryPtr>
Factory::factoriesFromProto(const envoy::config::core::v3::TypedExtensionConfig& codec_config,
                            Envoy::Server::Configuration::FactoryContext& context) {
  auto& factory = Config::Utility::getAndCheckFactory<CodecFactoryConfig>(codec_config);

  ProtobufTypes::MessagePtr message = factory.createEmptyConfigProto();
  Envoy::Config::Utility::translateOpaqueConfig(codec_config.typed_config(),
                                                context.messageValidationVisitor(), *message);
  return {factory.createCodecFactory(*message, context),
          factory.createProxyFactory(*message, context)};
}

Rds::RouteConfigProviderSharedPtr
Factory::routeConfigProviderFromProto(const ProxyConfig& config,
                                      Server::Configuration::FactoryContext& context,
                                      RouteConfigProviderManager& route_config_provider_manager) {
  if (config.has_generic_rds()) {
    if (config.generic_rds().config_source().config_source_specifier_case() ==
        envoy::config::core::v3::ConfigSource::kApiConfigSource) {
      const auto api_type = config.generic_rds().config_source().api_config_source().api_type();
      if (api_type != envoy::config::core::v3::ApiConfigSource::AGGREGATED_GRPC &&
          api_type != envoy::config::core::v3::ApiConfigSource::AGGREGATED_DELTA_GRPC) {
        throw EnvoyException("genericrds supports only aggregated api_type in api_config_source");
      }
    }

    return route_config_provider_manager.createRdsRouteConfigProvider(
        config.generic_rds(), context.serverFactoryContext(), config.stat_prefix(),
        context.initManager());
  } else {
    return route_config_provider_manager.createStaticRouteConfigProvider(
        config.route_config(), context.serverFactoryContext());
  }
}

std::vector<NamedFilterFactoryCb>
Factory::filtersFactoryFromProto(const ProtobufWkt::RepeatedPtrField<TypedExtensionConfig>& filters,
                                 const TypedExtensionConfig& codec_config,
                                 const std::string stats_prefix,
                                 Envoy::Server::Configuration::FactoryContext& context) {
  std::vector<NamedFilterFactoryCb> factories;
  bool has_terminal_filter = false;
  std::string terminal_filter_name;
  for (const auto& filter : filters) {
    if (has_terminal_filter) {
      throw EnvoyException(fmt::format("Terminal filter: {} must be the last generic L7 filter",
                                       terminal_filter_name));
    }

    auto& factory = Config::Utility::getAndCheckFactory<NamedFilterConfigFactory>(filter);

    // Validate codec to see if this filter is compatible with the codec.
    const auto validate_codec_status = factory.validateCodec(codec_config);
    THROW_IF_NOT_OK_REF(validate_codec_status);

    ProtobufTypes::MessagePtr message = factory.createEmptyConfigProto();
    ASSERT(message != nullptr);
    Envoy::Config::Utility::translateOpaqueConfig(filter.typed_config(),
                                                  context.messageValidationVisitor(), *message);

    factories.push_back(
        {filter.name(), factory.createFilterFactoryFromProto(*message, stats_prefix, context)});

    if (factory.isTerminalFilter()) {
      terminal_filter_name = filter.name();
      has_terminal_filter = true;
    }
  }

  if (!has_terminal_filter) {
    throw EnvoyException("A terminal L7 filter is necessary for generic proxy");
  }
  return factories;
}

Envoy::Network::FilterFactoryCb
Factory::createFilterFactoryFromProtoTyped(const ProxyConfig& proto_config,
                                           Envoy::Server::Configuration::FactoryContext& context) {
  auto& server_context = context.serverFactoryContext();

  std::shared_ptr<RouteConfigProviderManager> route_config_provider_manager =
      server_context.singletonManager().getTyped<RouteConfigProviderManager>(
          SINGLETON_MANAGER_REGISTERED_NAME(generic_route_config_provider_manager),
          [&server_context] {
            return std::make_shared<RouteConfigProviderManagerImpl>(server_context.admin());
          });

  // Pinned singleton and we needn't to keep the shared_ptr.
  std::shared_ptr<CodeOrFlags> code_or_flags =
      server_context.singletonManager().getTyped<CodeOrFlags>(
          SINGLETON_MANAGER_REGISTERED_NAME(generic_proxy_code_or_flag_stats),
          [&server_context] { return std::make_shared<CodeOrFlags>(server_context); }, true);

  auto tracer_manager = Tracing::TracerManagerImpl::singleton(context);

  auto factories = factoriesFromProto(proto_config.codec_config(), context);
  std::shared_ptr<ProxyFactory> custom_proxy_factory = std::move(factories.second);

  Tracing::TracerSharedPtr tracer;
  Tracing::ConnectionManagerTracingConfigPtr tracing_config;
  if (proto_config.has_tracing()) {
    if (proto_config.tracing().has_provider()) {
      tracer = tracer_manager->getOrCreateTracer(&proto_config.tracing().provider());
    }
    tracing_config = std::make_unique<Tracing::ConnectionManagerTracingConfigImpl>(
        context.listenerInfo().direction(), proto_config.tracing());
  }

  // Access log configuration.
  std::vector<AccessLogInstanceSharedPtr> access_logs;
  for (const auto& access_log : proto_config.access_log()) {
    AccessLogInstanceSharedPtr current_access_log =
        AccessLog::AccessLogFactory::accessLoggerFromProto<FormatterContext>(access_log, context);
    access_logs.push_back(current_access_log);
  }

  const std::string stat_prefix = fmt::format("generic_proxy.{}.", proto_config.stat_prefix());

  const FilterConfigSharedPtr config = std::make_shared<FilterConfigImpl>(
      stat_prefix, std::move(factories.first),
      routeConfigProviderFromProto(proto_config, context, *route_config_provider_manager),
      filtersFactoryFromProto(proto_config.filters(), proto_config.codec_config(), stat_prefix,
                              context),
      std::move(tracer), std::move(tracing_config), std::move(access_logs), *code_or_flags,
      context);

  return [route_config_provider_manager, tracer_manager, config, &context,
          custom_proxy_factory](Envoy::Network::FilterManager& filter_manager) -> void {
    // Create filter by the custom filter factory if the custom filter factory is not null.
    if (custom_proxy_factory != nullptr) {
      custom_proxy_factory->createProxy(filter_manager, config);
      return;
    }

    filter_manager.addReadFilter(std::make_shared<Filter>(config, context));
  };
}

REGISTER_FACTORY(Factory, Envoy::Server::Configuration::NamedNetworkFilterConfigFactory);

} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/generic_proxy/filters/network/source/router/router.h"

#include <cstdint>

#include "envoy/common/conn_pool.h"
#include "envoy/network/connection.h"

#include "source/common/common/assert.h"
#include "source/common/config/well_known_names.h"
#include "source/common/router/metadatamatchcriteria_impl.h"
#include "source/common/tracing/tracer_impl.h"

#include "contrib/generic_proxy/filters/network/source/interface/filter.h"
#include "contrib/generic_proxy/filters/network/source/tracing.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace GenericProxy {
namespace Router {

namespace {
absl::string_view resetReasonToStringView(StreamResetReason reason) {
  static std::string Reasons[] = {"local_reset", "connection_failure", "connection_termination",
                                  "overflow", "protocol_error"};
  return Reasons[static_cast<uint32_t>(reason)];
}

constexpr absl::string_view RouterFilterName = "envoy.filters.generic.router";

} // namespace

void GenericUpstream::writeToConnection(Buffer::Instance& buffer) {
  if (is_cleaned_up_) {
    return;
  }

  if (owned_conn_data_ != nullptr) {
    ASSERT(owned_conn_data_->connection().state() == Network::Connection::State::Open);
    owned_conn_data_->connection().write(buffer, false);
  }
}

OptRef<Network::Connection> GenericUpstream::connection() {
  if (is_cleaned_up_) {
    return {};
  }
  if (owned_conn_data_ != nullptr) {
    return {owned_conn_data_->connection()};
  }
  return {};
}

BoundGenericUpstream::BoundGenericUpstream(const CodecFactory& codec_factory,
                                           Envoy::Upstream::TcpPoolData&& tcp_pool_data,
                                           Network::Connection& downstream_connection)
    : GenericUpstream(std::move(tcp_pool_data), codec_factory.createClientCodec()),
      downstream_connection_(downstream_connection) {

  connection_event_watcher_ = std::make_unique<EventWatcher>(*this);
  downstream_connection_.addConnectionCallbacks(*connection_event_watcher_);
}

void BoundGenericUpstream::onDownstreamConnectionEvent(Network::ConnectionEvent event) {
  if (event == Network::ConnectionEvent::LocalClose ||
      event == Network::ConnectionEvent::RemoteClose) {
    // The event should be handled first by the generic proxy first. So all pending
    // requests will be cleaned up by the downstream connection close event.
    ASSERT(waiting_upstream_requests_.empty());
    ASSERT(waiting_response_requests_.empty());

    // Close upstream connection and this will trigger the upstream connection close event.
    cleanUp(true);
  }
}

void BoundGenericUpstream::insertUpstreamRequest(uint64_t stream_id,
                                                 UpstreamRequest* pending_request) {
  if (upstream_connection_ready_.has_value()) {
    // Upstream connection is already ready. If the upstream connection is failed then
    // all pending requests will be reset and no new upstream request will be created.
    ASSERT(upstream_connection_ready_.value());
    if (!upstream_connection_ready_.value()) {
      return;
    }

    ASSERT(waiting_upstream_requests_.empty());

    if (waiting_response_requests_.contains(stream_id)) {
      ENVOY_LOG(error, "generic proxy: stream_id {} already registered for response", stream_id);
      // Close downstream connection because we treat this as request decoding failure.
      // The downstream closing will trigger the upstream connection closing.
      downstream_connection_.close(Network::ConnectionCloseType::FlushWrite);
      return;
    }

    waiting_response_requests_[stream_id] = pending_request;
    pending_request->onUpstreamSuccess(upstream_host_);
  } else {
    // Waiting for the upstream connection to be ready.
    if (waiting_upstream_requests_.contains(stream_id)) {
      ENVOY_LOG(error, "generic proxy: stream_id {} already registered for upstream", stream_id);
      // Close downstream connection because we treat this as request decoding failure.
      // The downstream closing will trigger the upstream connection closing.
      downstream_connection_.close(Network::ConnectionCloseType::FlushWrite);
      return;
    }

    waiting_upstream_requests_[stream_id] = pending_request;

    // Try to initialize the upstream connection after there is at least one pending request.
    // If the upstream connection is already initialized, this is a no-op.
    initialize();
  }
}

void BoundGenericUpstream::removeUpstreamRequest(uint64_t stream_id) {
  waiting_upstream_requests_.erase(stream_id);
  waiting_response_requests_.erase(stream_id);
}

void BoundGenericUpstream::onEventImpl(Network::ConnectionEvent event) {
  if (event == Network::ConnectionEvent::Connected ||
      event == Network::ConnectionEvent::ConnectedZeroRtt) {
    return;
  }

  ASSERT(waiting_upstream_requests_.empty());

  while (!waiting_response_requests_.empty()) {
    auto it = waiting_response_requests_.begin();
    auto cb = it->second;
    waiting_response_requests_.erase(it);

    cb->onConnectionClose(event);
  }

  // If the downstream connection is not closed, close it.
  if (downstream_connection_.state() == Network::Connection::State::Open) {
    downstream_connection_.close(Network::ConnectionCloseType::FlushWrite);
  }
}

void BoundGenericUpstream::cleanUp(bool close_connection) {
  // Shared upstream manager never release the connection back to the pool
  // because the connection is bound to the downstream connection.
  if (!close_connection) {
    return;
  }
  // Only actually do the cleanup when we want to close the connection.
  UpstreamConnection::cleanUp(true);
}

void BoundGenericUpstream::onPoolSuccessImpl() {
  // This should be called only once and all pending requests should be notified.
  // After this is called, the upstream connection is ready and new upstream requests
  // should be notified directly.

  ASSERT(!upstream_connection_ready_.has_value());
  upstream_connection_ready_ = true;

  ASSERT(waiting_response_requests_.empty());

  while (!waiting_upstream_requests_.empty()) {
    auto it = waiting_upstream_requests_.begin();
    auto cb = it->second;

    // Insert it to the waiting response list and remove it from the waiting upstream list.
    waiting_response_requests_[it->first] = cb;
    waiting_upstream_requests_.erase(it);

    // Now, notify the upstream request that the upstream connection is ready.
    cb->onUpstreamSuccess(upstream_host_);
  }
}

void BoundGenericUpstream::onPoolFailureImpl(ConnectionPool::PoolFailureReason reason,
                                             absl::string_view transport_failure_reason) {
  // This should be called only once and all pending requests should be notified.
  // Then the downstream connection will be closed.

  ASSERT(!upstream_connection_ready_.has_value());
  upstream_connection_ready_ = false;

  ASSERT(waiting_response_requests_.empty());

  while (!waiting_upstream_requests_.empty()) {
    auto it = waiting_upstream_requests_.begin();
    auto cb = it->second;

    // Remove it from the waiting upstream list.
    waiting_upstream_requests_.erase(it);

    // Now, notify the upstream request that the upstream connection is failed.
    cb->onUpstreamFailure(reason, transport_failure_reason, upstream_host_);
  }

  // If the downstream connection is not closed, close it.
  downstream_connection_.close(Network::ConnectionCloseType::FlushWrite);
}

void BoundGenericUpstream::onDecodingSuccess(StreamFramePtr response) {
  const uint64_t stream_id = response->frameFlags().streamFlags().streamId();
  const bool end_stream = response->frameFlags().endStream();

  auto it = waiting_response_requests_.find(stream_id);
  if (it == waiting_response_requests_.end()) {
    ENVOY_LOG(error, "generic proxy: id {} not found for frame", stream_id);
    return;
  }

  auto cb = it->second;

  // If the response is end, remove the callback from the map.
  if (end_stream) {
    waiting_response_requests_.erase(it);
  }

  return cb->onDecodingSuccess(std::move(response));
}

void BoundGenericUpstream::onDecodingFailure() {
  ENVOY_LOG(error, "generic proxy bound upstream manager: decoding failure");

  // This will trigger the upstream connection close event and all pending requests will be reset
  // by the upstream connection close event.
  cleanUp(true);

  // All pending streams will be reset by the upstream connection close event.
  ASSERT(waiting_response_requests_.empty());
}

OwnedGenericUpstream::OwnedGenericUpstream(const CodecFactory& codec_factory,
                                           Envoy::Upstream::TcpPoolData&& tcp_pool_data)
    : GenericUpstream(std::move(tcp_pool_data), codec_factory.createClientCodec()) {}

void OwnedGenericUpstream::insertUpstreamRequest(uint64_t, UpstreamRequest* pending_request) {
  upstream_request_ = pending_request;
  initialize();
}

void OwnedGenericUpstream::onEventImpl(Network::ConnectionEvent event) {
  if (event == Network::ConnectionEvent::Connected ||
      event == Network::ConnectionEvent::ConnectedZeroRtt) {
    return;
  }
  ASSERT(upstream_request_ != nullptr);
  upstream_request_->onConnectionClose(event);
}

void OwnedGenericUpstream::onPoolSuccessImpl() {
  ASSERT(upstream_request_ != nullptr);
  upstream_request_->onUpstreamSuccess(upstream_host_);
}

void OwnedGenericUpstream::onPoolFailureImpl(ConnectionPool::PoolFailureReason reason,
                                             absl::string_view transport_failure_reason) {
  ASSERT(upstream_request_ != nullptr);
  upstream_request_->onUpstreamFailure(reason, transport_failure_reason, upstream_host_);
}

// ResponseDecoderCallback
void OwnedGenericUpstream::onDecodingSuccess(StreamFramePtr response) {
  ASSERT(upstream_request_ != nullptr);
  upstream_request_->onDecodingSuccess(std::move(response));
}
void OwnedGenericUpstream::onDecodingFailure() {
  ASSERT(upstream_request_ != nullptr);
  upstream_request_->onDecodingFailure();
}

UpstreamRequest::UpstreamRequest(RouterFilter& parent, GenericUpstreamSharedPtr generic_upstream)
    : parent_(parent), generic_upstream_(std::move(generic_upstream)),
      stream_info_(parent.time_source_, nullptr),
      upstream_info_(std::make_shared<StreamInfo::UpstreamInfoImpl>()) {

  // Set the upstream info for the stream info.
  stream_info_.setUpstreamInfo(upstream_info_);
  parent_.callbacks_->streamInfo().setUpstreamInfo(upstream_info_);
  stream_info_.healthCheck(parent_.callbacks_->streamInfo().healthCheck());
  stream_info_.setUpstreamClusterInfo(parent_.cluster_);

  // Set request options.
  auto options = parent_.request_stream_->frameFlags().streamFlags();
  stream_id_ = options.streamId();
  expects_response_ = !options.oneWayStream();

  // Set tracing config.
  if (tracing_config_ = parent_.callbacks_->tracingConfig(); tracing_config_.has_value()) {
    span_ = parent_.callbacks_->activeSpan().spawnChild(
        tracing_config_.value().get(),
        absl::StrCat("router ", parent_.cluster_->observabilityName(), " egress"),
        parent.time_source_.systemTime());
  }
}

void UpstreamRequest::startStream() {
  connecting_start_time_ = parent_.time_source_.monotonicTime();
  generic_upstream_->insertUpstreamRequest(stream_id_, this);
}

void UpstreamRequest::resetStream(StreamResetReason reason) {
  if (stream_reset_) {
    return;
  }
  stream_reset_ = true;

  ENVOY_LOG(debug, "generic proxy upstream request: reset upstream request");

  generic_upstream_->removeUpstreamRequest(stream_id_);
  generic_upstream_->cleanUp(true);

  if (span_ != nullptr) {
    span_->setTag(Tracing::Tags::get().Error, Tracing::Tags::get().True);
    span_->setTag(Tracing::Tags::get().ErrorReason, resetReasonToStringView(reason));
    TraceContextBridge trace_context{*parent_.request_stream_};
    Tracing::TracerUtility::finalizeSpan(*span_, trace_context, stream_info_,
                                         tracing_config_.value().get(), true);
  }

  // Remove this stream form the parent's list because this upstream request is reset.
  deferredDelete();

  // Notify the parent filter that the upstream request has been reset.
  parent_.onUpstreamRequestReset(*this, reason);
}

void UpstreamRequest::clearStream(bool close_connection) {
  // Set the upstream response complete flag to true first to ensure the possible
  // connection close event will not be handled.
  response_complete_ = true;

  ENVOY_LOG(debug, "generic proxy upstream request: complete upstream request");

  if (span_ != nullptr) {
    TraceContextBridge trace_context{*parent_.request_stream_};
    Tracing::TracerUtility::finalizeSpan(*span_, trace_context, stream_info_,
                                         tracing_config_.value().get(), true);
  }

  generic_upstream_->removeUpstreamRequest(stream_id_);
  generic_upstream_->cleanUp(close_connection);

  // Remove this stream form the parent's list because this upstream request is complete.
  deferredDelete();
}

void UpstreamRequest::deferredDelete() {
  if (inserted()) {
    // Remove this stream from the parent's list of upstream requests and delete it at
    // next event loop iteration.
    parent_.callbacks_->dispatcher().deferredDelete(removeFromList(parent_.upstream_requests_));
  }
}

void UpstreamRequest::sendRequestStartToUpstream() {
  request_stream_header_sent_ = true;
  ASSERT(generic_upstream_ != nullptr);

  // The first frame of request is sent.
  upstream_info_->upstreamTiming().onFirstUpstreamTxByteSent(parent_.time_source_);
  generic_upstream_->clientCodec()->encode(*parent_.request_stream_, *this);
}

void UpstreamRequest::sendRequestFrameToUpstream() {
  if (!request_stream_header_sent_) {
    // Do not send request frame to upstream until the request header is sent. It may be blocked
    // by the upstream connecting.
    return;
  }

  while (!parent_.request_stream_frames_.empty()) {
    auto frame = std::move(parent_.request_stream_frames_.front());
    parent_.request_stream_frames_.pop_front();

    ASSERT(generic_upstream_ != nullptr);
    generic_upstream_->clientCodec()->encode(*frame, *this);
  }
}

void UpstreamRequest::onEncodingSuccess(Buffer::Instance& buffer, bool end_stream) {
  encodeBufferToUpstream(buffer);

  if (!end_stream) {
    return;
  }

  // The request is fully sent.
  upstream_info_->upstreamTiming().onLastUpstreamTxByteSent(parent_.time_source_);

  // Request is complete.
  ENVOY_LOG(debug, "upstream request encoding success");

  // Need not to wait for the upstream response and complete directly.
  if (!expects_response_) {
    clearStream(false);
    parent_.completeDirectly();
    return;
  }
}

void UpstreamRequest::onUpstreamFailure(ConnectionPool::PoolFailureReason reason, absl::string_view,
                                        Upstream::HostDescriptionConstSharedPtr host) {
  ENVOY_LOG(debug, "upstream request: tcp connection (bound or owned) failure");

  // Mimic an upstream reset.
  onUpstreamHostSelected(std::move(host));

  if (reason == ConnectionPool::PoolFailureReason::Overflow) {
    resetStream(StreamResetReason::Overflow);
    return;
  }

  resetStream(StreamResetReason::ConnectionFailure);
}

void UpstreamRequest::onUpstreamSuccess(Upstream::HostDescriptionConstSharedPtr host) {
  ENVOY_LOG(debug, "upstream request: {} tcp connection has ready",
            parent_.config_->bindUpstreamConnection() ? "bound" : "owned");

  onUpstreamHostSelected(std::move(host));

  if (span_ != nullptr) {
    TraceContextBridge trace_context{*parent_.request_stream_};
    span_->injectContext(trace_context, upstream_info_->upstream_host_);
  }

  sendRequestStartToUpstream();
  sendRequestFrameToUpstream();
}

void UpstreamRequest::onDecodingSuccess(StreamFramePtr response) {
  const bool end_stream = response->frameFlags().endStream();
  if (end_stream) {
    clearStream(response->frameFlags().streamFlags().drainClose());
  }

  if (response_stream_header_received_) {
    if (end_stream) {
      // The response is fully received.
      upstream_info_->upstreamTiming().onLastUpstreamRxByteReceived(parent_.time_source_);
    }

    parent_.onResponseFrame(std::move(response));
  } else {
    // The first frame of response is received.
    upstream_info_->upstreamTiming().onFirstUpstreamRxByteReceived(parent_.time_source_);

    StreamFramePtrHelper<StreamResponse> helper(std::move(response));
    if (helper.typed_frame_ == nullptr) {
      ENVOY_LOG(error, "upstream request: first frame is not StreamResponse");
      resetStream(StreamResetReason::ProtocolError);
      return;
    }
    response_stream_header_received_ = true;

    if (end_stream) {
      // The response is fully received.
      upstream_info_->upstreamTiming().onLastUpstreamRxByteReceived(parent_.time_source_);
    }
    parent_.onResponseStart(std::move(helper.typed_frame_));
  }
}

void UpstreamRequest::onDecodingFailure() { resetStream(StreamResetReason::ProtocolError); }

void UpstreamRequest::onConnectionClose(Network::ConnectionEvent event) {
  // If the upstream response is complete or the upstream request is reset then
  // ignore the connection close event.
  if (response_complete_ || stream_reset_) {
    return;
  }

  switch (event) {
  case Network::ConnectionEvent::LocalClose:
    resetStream(StreamResetReason::LocalReset);
    break;
  case Network::ConnectionEvent::RemoteClose:
    resetStream(StreamResetReason::ConnectionTermination);
    break;
  default:
    break;
  }
}

void UpstreamRequest::onUpstreamHostSelected(Upstream::HostDescriptionConstSharedPtr host) {
  ENVOY_LOG(debug, "upstream request: selected upstream {}", host->address()->asString());
  ASSERT(connecting_start_time_.has_value());
  upstream_info_->upstreamTiming().recordConnectionPoolCallbackLatency(
      connecting_start_time_.value(), parent_.time_source_);
  upstream_info_->setUpstreamHost(std::move(host));
}

void UpstreamRequest::encodeBufferToUpstream(Buffer::Instance& buffer) {
  ENVOY_LOG(trace, "proxying {} bytes", buffer.length());

  ASSERT(generic_upstream_ != nullptr);
  generic_upstream_->writeToConnection(buffer);
}

void RouterFilter::onResponseStart(ResponsePtr response) {
  filter_complete_ = response->frameFlags().endStream();
  callbacks_->onResponseStart(std::move(response));
}

void RouterFilter::onResponseFrame(StreamFramePtr frame) {
  ASSERT(!filter_complete_, "response frame received after response complete");
  filter_complete_ = frame->frameFlags().endStream();
  callbacks_->onResponseFrame(std::move(frame));
}

void RouterFilter::completeDirectly() {
  filter_complete_ = true;
  callbacks_->completeDirectly();
}

void RouterFilter::onUpstreamRequestReset(UpstreamRequest&, StreamResetReason reason) {
  if (filter_complete_) {
    return;
  }

  // TODO(wbpcode): To support retry policy.
  resetStream(reason);
}

void RouterFilter::cleanUpstreamRequests(bool filter_complete) {
  // If filter_complete_ is true then the resetStream() of RouterFilter will not be called on the
  // onUpstreamRequestReset() of RouterFilter.
  filter_complete_ = filter_complete;

  while (!upstream_requests_.empty()) {
    (*upstream_requests_.back()).resetStream(StreamResetReason::LocalReset);
  }
}

void RouterFilter::onDestroy() {
  if (filter_complete_) {
    return;
  }
  cleanUpstreamRequests(true);
}

void RouterFilter::resetStream(StreamResetReason reason) {
  if (filter_complete_) {
    return;
  }
  filter_complete_ = true;

  ASSERT(upstream_requests_.empty());
  switch (reason) {
  case StreamResetReason::LocalReset:
    // Note if the connection is closed because of the downstream connection close, this
    // resetStream() will not be called. So this means the connection is closed by the Envoy self
    // with unknown reason.
    callbacks_->sendLocalReply(Status(StatusCode::kUnavailable, resetReasonToStringView(reason)));
    break;
  case StreamResetReason::ProtocolError:
    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamProtocolError);
    callbacks_->sendLocalReply(Status(StatusCode::kUnavailable, resetReasonToStringView(reason)));
    break;
  case StreamResetReason::ConnectionFailure:
    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);
    callbacks_->sendLocalReply(Status(StatusCode::kUnavailable, resetReasonToStringView(reason)));
    break;
  case StreamResetReason::ConnectionTermination:
    callbacks_->streamInfo().setResponseFlag(
        StreamInfo::ResponseFlag::UpstreamConnectionTermination);
    callbacks_->sendLocalReply(Status(StatusCode::kUnavailable, resetReasonToStringView(reason)));
    break;
  case StreamResetReason::Overflow:
    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);
    callbacks_->sendLocalReply(Status(StatusCode::kUnavailable, resetReasonToStringView(reason)));
    break;
  }
}

void RouterFilter::kickOffNewUpstreamRequest() {
  const auto& cluster_name = route_entry_->clusterName();

  auto thread_local_cluster = cluster_manager_.getThreadLocalCluster(cluster_name);
  if (thread_local_cluster == nullptr) {
    filter_complete_ = true;
    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoClusterFound);
    callbacks_->sendLocalReply(Status(StatusCode::kNotFound, "cluster_not_found"));
    return;
  }

  cluster_ = thread_local_cluster->info();
  callbacks_->streamInfo().setUpstreamClusterInfo(cluster_);

  if (cluster_->maintenanceMode()) {
    filter_complete_ = true;
    // No response flag for maintenance mode for now.
    callbacks_->sendLocalReply(Status(StatusCode::kUnavailable, "cluster_maintain_mode"));
    return;
  }

  GenericUpstreamSharedPtr generic_upstream;

  if (config_->bindUpstreamConnection()) {
    // If the upstream connection binding is enabled.

    const auto* const_downstream_connection = callbacks_->connection();
    ASSERT(const_downstream_connection != nullptr);
    auto downstream_connection = const_cast<Network::Connection*>(const_downstream_connection);

    auto* bound_upstream =
        downstream_connection->streamInfo().filterState()->getDataMutable<BoundGenericUpstream>(
            RouterFilterName);
    if (bound_upstream == nullptr) {
      // The upstream connection is not bound yet and create a new bound upstream connection.
      auto pool_data = thread_local_cluster->tcpConnPool(Upstream::ResourcePriority::Default, this);
      if (!pool_data.has_value()) {
        filter_complete_ = true;
        callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoHealthyUpstream);
        callbacks_->sendLocalReply(Status(StatusCode::kUnavailable, "no_healthy_upstream"));
        return;
      }
      auto new_bound_upstream = std::make_shared<BoundGenericUpstream>(
          callbacks_->downstreamCodec(), std::move(pool_data.value()), *downstream_connection);
      bound_upstream = new_bound_upstream.get();
      downstream_connection->streamInfo().filterState()->setData(
          RouterFilterName, std::move(new_bound_upstream),
          StreamInfo::FilterState::StateType::Mutable,
          StreamInfo::FilterState::LifeSpan::Connection);
    }

    ASSERT(bound_upstream != nullptr);
    generic_upstream = bound_upstream->shared_from_this();
  } else {
    // Upstream connection binding is disabled and create a new upstream connection.
    auto pool_data = thread_local_cluster->tcpConnPool(Upstream::ResourcePriority::Default, this);
    if (!pool_data.has_value()) {
      filter_complete_ = true;
      callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoHealthyUpstream);
      callbacks_->sendLocalReply(Status(StatusCode::kUnavailable, "no_healthy_upstream"));
      return;
    }
    generic_upstream = std::make_shared<OwnedGenericUpstream>(callbacks_->downstreamCodec(),
                                                              std::move(pool_data.value()));
  }

  auto upstream_request = std::make_unique<UpstreamRequest>(*this, std::move(generic_upstream));
  auto raw_upstream_request = upstream_request.get();
  LinkedList::moveIntoList(std::move(upstream_request), upstream_requests_);
  raw_upstream_request->startStream();
}

void RouterFilter::onStreamFrame(StreamFramePtr frame) {
  request_stream_end_ = frame->frameFlags().endStream();
  request_stream_frames_.emplace_back(std::move(frame));

  if (upstream_requests_.empty()) {
    return;
  }

  upstream_requests_.front()->sendRequestFrameToUpstream();
}

FilterStatus RouterFilter::onStreamDecoded(StreamRequest& request) {
  ENVOY_LOG(debug, "Try route request to the upstream based on the route entry");

  setRouteEntry(callbacks_->routeEntry());
  request_stream_end_ = request.frameFlags().endStream();
  request_stream_ = &request;

  if (route_entry_ != nullptr) {
    kickOffNewUpstreamRequest();
    return FilterStatus::StopIteration;
  }

  ENVOY_LOG(debug, "No route for current request and send local reply");
  filter_complete_ = true;
  callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::NoRouteFound);
  callbacks_->sendLocalReply(Status(StatusCode::kNotFound, "route_not_found"));
  return FilterStatus::StopIteration;
}

const Envoy::Router::MetadataMatchCriteria* RouterFilter::metadataMatchCriteria() {
  // Have we been called before? If so, there's no need to recompute.
  if (metadata_match_ != nullptr) {
    return metadata_match_.get();
  }

  const auto& request_metadata = callbacks_->streamInfo().dynamicMetadata().filter_metadata();
  const auto filter_it = request_metadata.find(Envoy::Config::MetadataFilters::get().ENVOY_LB);

  if (filter_it == request_metadata.end()) {
    return nullptr;
  }

  metadata_match_ = std::make_unique<Envoy::Router::MetadataMatchCriteriaImpl>(filter_it->second);
  return metadata_match_.get();
}

const Network::Connection* RouterFilter::downstreamConnection() const {
  return callbacks_ != nullptr ? callbacks_->connection() : nullptr;
}

} // namespace Router
} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "contrib/envoy/extensions/filters/network/generic_proxy/router/v3/router.pb.h"
#include "contrib/envoy/extensions/filters/network/generic_proxy/router/v3/router.pb.validate.h"
#include "contrib/generic_proxy/filters/network/source/interface/config.h"
#include "contrib/generic_proxy/filters/network/source/router/router.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace GenericProxy {
namespace Router {

class RouterFactory : public NamedFilterConfigFactory {
public:
  FilterFactoryCb
  createFilterFactoryFromProto(const Protobuf::Message& config, const std::string& stat_prefix,
                               Server::Configuration::FactoryContext& context) override;

  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<
        envoy::extensions::filters::network::generic_proxy::router::v3::Router>();
  }
  ProtobufTypes::MessagePtr createEmptyRouteConfigProto() override { return nullptr; }
  RouteSpecificFilterConfigConstSharedPtr
  createRouteSpecificFilterConfig(const Protobuf::Message&,
                                  Server::Configuration::ServerFactoryContext&,
                                  ProtobufMessage::ValidationVisitor&) override {
    return nullptr;
  }
  bool isTerminalFilter() override { return true; }

  std::string name() const override { return "envoy.filters.generic.router"; }
};

} // namespace Router
} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_library(
    name = "router_lib",
    srcs = [
        "router.cc",
    ],
    hdrs = [
        "router.h",
    ],
    deps = [
        "//contrib/generic_proxy/filters/network/source:tracing_lib",
        "//contrib/generic_proxy/filters/network/source:upstream_lib",
        "//contrib/generic_proxy/filters/network/source/interface:codec_interface",
        "//contrib/generic_proxy/filters/network/source/interface:config_interface",
        "//contrib/generic_proxy/filters/network/source/interface:filter_interface",
        "//source/common/buffer:buffer_lib",
        "//source/common/common:linked_object",
        "//source/common/common:minimal_logger_lib",
        "//source/common/config:well_known_names",
        "//source/common/router:metadatamatchcriteria_lib",
        "//source/common/stream_info:stream_info_lib",
        "//source/common/tracing:tracer_lib",
        "//source/common/upstream:load_balancer_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/generic_proxy/router/v3:pkg_cc_proto",
    ],
)

envoy_cc_contrib_extension(
    name = "config",
    srcs = [
        "config.cc",
    ],
    hdrs = [
        "config.h",
    ],
    deps = [
        ":router_lib",
        "//contrib/generic_proxy/filters/network/source/interface:config_interface",
        "//envoy/registry",
        "@envoy_api//contrib/envoy/extensions/filters/network/generic_proxy/router/v3:pkg_cc_proto",
    ],
)
#pragma once

#include <cstdint>

#include "envoy/network/connection.h"
#include "envoy/server/factory_context.h"

#include "source/common/buffer/buffer_impl.h"
#include "source/common/common/linked_object.h"
#include "source/common/stream_info/stream_info_impl.h"
#include "source/common/upstream/load_balancer_impl.h"

#include "contrib/envoy/extensions/filters/network/generic_proxy/router/v3/router.pb.h"
#include "contrib/envoy/extensions/filters/network/generic_proxy/router/v3/router.pb.validate.h"
#include "contrib/generic_proxy/filters/network/source/interface/codec.h"
#include "contrib/generic_proxy/filters/network/source/interface/filter.h"
#include "contrib/generic_proxy/filters/network/source/interface/stream.h"
#include "contrib/generic_proxy/filters/network/source/upstream.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace GenericProxy {
namespace Router {

/**
 * Stream reset reasons.
 */
enum class StreamResetReason : uint32_t {
  LocalReset,
  // If the stream was locally reset by a connection pool due to an initial connection failure.
  ConnectionFailure,
  // If the stream was locally reset due to connection termination.
  ConnectionTermination,
  // The stream was reset because of a resource overflow.
  Overflow,
  // Protocol error.
  ProtocolError,
};

class RouterFilter;
class UpstreamRequest;

class GenericUpstream : public UpstreamConnection, public ClientCodecCallbacks {
public:
  GenericUpstream(Upstream::TcpPoolData&& tcp_pool_data, ClientCodecPtr&& client_codec)
      : UpstreamConnection(std::move(tcp_pool_data), std::move(client_codec)) {
    client_codec_->setCodecCallbacks(*this);
  }

  // ResponseDecoderCallback
  void writeToConnection(Buffer::Instance& buffer) override;
  OptRef<Network::Connection> connection() override;

  virtual void insertUpstreamRequest(uint64_t stream_id, UpstreamRequest* pending_request) PURE;
  virtual void removeUpstreamRequest(uint64_t stream_id) PURE;
};
using GenericUpstreamSharedPtr = std::shared_ptr<GenericUpstream>;

class BoundGenericUpstream : public GenericUpstream,
                             public StreamInfo::FilterState::Object,
                             public std::enable_shared_from_this<BoundGenericUpstream> {
public:
  BoundGenericUpstream(const CodecFactory& codec_factory,
                       Envoy::Upstream::TcpPoolData&& tcp_pool_data,
                       Network::Connection& downstream_connection);

  void onDownstreamConnectionEvent(Network::ConnectionEvent event);

  // UpstreamConnection
  void onPoolSuccessImpl() override;
  void onPoolFailureImpl(ConnectionPool::PoolFailureReason reason,
                         absl::string_view transport_failure_reason) override;
  void onEventImpl(Network::ConnectionEvent event) override;
  void cleanUp(bool close_connection) override;

  // ResponseDecoderCallback
  void onDecodingSuccess(StreamFramePtr response) override;
  void onDecodingFailure() override;

  // GenericUpstream
  void insertUpstreamRequest(uint64_t stream_id, UpstreamRequest* pending_request) override;
  void removeUpstreamRequest(uint64_t stream_id) override;

  const auto& waitingResponseRequestsForTest() const { return waiting_response_requests_; }
  const auto& waitingUpstreamRequestsForTest() const { return waiting_upstream_requests_; }

private:
  struct EventWatcher : public Network::ConnectionCallbacks {
    EventWatcher(BoundGenericUpstream& parent) : parent_(parent) {}
    BoundGenericUpstream& parent_;

    // Network::ConnectionCallbacks
    void onAboveWriteBufferHighWatermark() override {}
    void onBelowWriteBufferLowWatermark() override {}
    void onEvent(Network::ConnectionEvent downstream_event) override {
      parent_.onDownstreamConnectionEvent(downstream_event);
    }
  };

  Network::Connection& downstream_connection_;

  std::unique_ptr<EventWatcher> connection_event_watcher_;

  absl::optional<bool> upstream_connection_ready_;

  // Pending upstream requests that are waiting for the upstream response to be received.
  absl::flat_hash_map<uint64_t, UpstreamRequest*> waiting_response_requests_;
  // Pending upstream requests that are waiting for the upstream connection to be ready.
  absl::flat_hash_map<uint64_t, UpstreamRequest*> waiting_upstream_requests_;
};

class OwnedGenericUpstream : public GenericUpstream {
public:
  OwnedGenericUpstream(const CodecFactory& codec_factory,
                       Envoy::Upstream::TcpPoolData&& tcp_pool_data);

  void setResponseCallback();

  // UpstreamConnection
  void onEventImpl(Network::ConnectionEvent event) override;
  void onPoolSuccessImpl() override;
  void onPoolFailureImpl(ConnectionPool::PoolFailureReason reason,
                         absl::string_view transport_failure_reason) override;

  // ResponseDecoderCallback
  void onDecodingSuccess(StreamFramePtr response) override;
  void onDecodingFailure() override;

  // GenericUpstream
  void insertUpstreamRequest(uint64_t stream_id, UpstreamRequest* pending_request) override;
  void removeUpstreamRequest(uint64_t) override {}

private:
  UpstreamRequest* upstream_request_{};
};

class UpstreamRequest : public LinkedObject<UpstreamRequest>,
                        public Envoy::Event::DeferredDeletable,
                        public EncodingCallbacks,
                        Logger::Loggable<Envoy::Logger::Id::filter> {
public:
  UpstreamRequest(RouterFilter& parent, GenericUpstreamSharedPtr generic_upstream);

  void startStream();
  void resetStream(StreamResetReason reason);
  void clearStream(bool close_connection);

  // Called when the stream has been reset or completed.
  void deferredDelete();

  void onUpstreamFailure(ConnectionPool::PoolFailureReason reason,
                         absl::string_view transport_failure_reason,
                         Upstream::HostDescriptionConstSharedPtr host);
  void onUpstreamSuccess(Upstream::HostDescriptionConstSharedPtr host);

  void onConnectionClose(Network::ConnectionEvent event);

  void onDecodingSuccess(StreamFramePtr response);
  void onDecodingFailure();

  // RequestEncoderCallback
  void onEncodingSuccess(Buffer::Instance& buffer, bool end_stream) override;

  void onUpstreamHostSelected(Upstream::HostDescriptionConstSharedPtr host);
  void encodeBufferToUpstream(Buffer::Instance& buffer);

  void sendRequestStartToUpstream();
  void sendRequestFrameToUpstream();

  RouterFilter& parent_;
  uint64_t stream_id_{};

  GenericUpstreamSharedPtr generic_upstream_;

  Buffer::OwnedImpl upstream_request_buffer_;

  StreamInfo::StreamInfoImpl stream_info_;
  std::shared_ptr<StreamInfo::UpstreamInfoImpl> upstream_info_;
  OptRef<const Tracing::Config> tracing_config_;
  Tracing::SpanPtr span_;

  absl::optional<MonotonicTime> connecting_start_time_;

  // One of these flags should be set to true when the request is complete.
  bool stream_reset_{};
  bool response_complete_{};

  bool expects_response_{};

  bool request_stream_header_sent_{};
  bool response_stream_header_received_{};
};
using UpstreamRequestPtr = std::unique_ptr<UpstreamRequest>;

class RouterConfig {
public:
  RouterConfig(const envoy::extensions::filters::network::generic_proxy::router::v3::Router& config)
      : bind_upstream_connection_(config.bind_upstream_connection()) {}

  bool bindUpstreamConnection() const { return bind_upstream_connection_; }

private:
  const bool bind_upstream_connection_{};
};
using RouterConfigSharedPtr = std::shared_ptr<RouterConfig>;

class RouterFilter : public DecoderFilter,
                     public Upstream::LoadBalancerContextBase,
                     public StreamFrameHandler,
                     Logger::Loggable<Envoy::Logger::Id::filter> {
public:
  RouterFilter(RouterConfigSharedPtr config, Server::Configuration::FactoryContext& context)
      : config_(std::move(config)),
        cluster_manager_(context.serverFactoryContext().clusterManager()),
        time_source_(context.serverFactoryContext().timeSource()) {}

  // DecoderFilter
  void onDestroy() override;

  void setDecoderFilterCallbacks(DecoderFilterCallback& callbacks) override {
    callbacks_ = &callbacks;
    // Set handler for following request frames.
    callbacks_->setRequestFramesHandler(*this);
  }
  FilterStatus onStreamDecoded(StreamRequest& request) override;

  void onResponseStart(StreamResponsePtr response);
  void onResponseFrame(StreamFramePtr frame);
  void completeDirectly();

  void onUpstreamRequestReset(UpstreamRequest& upstream_request, StreamResetReason reason);
  void cleanUpstreamRequests(bool filter_complete);

  void setRouteEntry(const RouteEntry* route_entry) { route_entry_ = route_entry; }

  std::list<UpstreamRequestPtr>& upstreamRequestsForTest() { return upstream_requests_; }

  // Upstream::LoadBalancerContextBase
  const Envoy::Router::MetadataMatchCriteria* metadataMatchCriteria() override;
  const Network::Connection* downstreamConnection() const override;

  // StreamFrameHandler
  void onStreamFrame(StreamFramePtr frame) override;

private:
  friend class UpstreamRequest;
  friend class UpstreamManagerImpl;

  void kickOffNewUpstreamRequest();
  void resetStream(StreamResetReason reason);

  // Set filter_complete_ to true before any local or upstream response. Because the
  // response processing may complete and destroy the L7 filter chain directly and cause the
  // onDestory() of RouterFilter to be called. The filter_complete_ will be used to block
  // unnecessary clearUpstreamRequests() in the onDestory() of RouterFilter.
  bool filter_complete_{};

  const RouteEntry* route_entry_{};
  Upstream::ClusterInfoConstSharedPtr cluster_;
  Request* request_stream_{};
  std::list<StreamFramePtr> request_stream_frames_;
  bool request_stream_end_{};

  Envoy::Router::MetadataMatchCriteriaConstPtr metadata_match_;

  std::list<UpstreamRequestPtr> upstream_requests_;

  DecoderFilterCallback* callbacks_{};

  RouterConfigSharedPtr config_;
  Upstream::ClusterManager& cluster_manager_;
  TimeSource& time_source_;
};

} // namespace Router
} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/generic_proxy/filters/network/source/router/config.h"

#include "envoy/registry/registry.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace GenericProxy {
namespace Router {

FilterFactoryCb
RouterFactory::createFilterFactoryFromProto(const Protobuf::Message& config, const std::string&,
                                            Server::Configuration::FactoryContext& context) {
  const auto& typed_config = MessageUtil::downcastAndValidate<
      const envoy::extensions::filters::network::generic_proxy::router::v3::Router&>(
      config, context.messageValidationVisitor());

  auto router_config = std::make_shared<RouterConfig>(typed_config);

  return [&context, router_config](FilterChainFactoryCallbacks& callbacks) {
    callbacks.addDecoderFilter(std::make_shared<RouterFilter>(router_config, context));
  };
}

REGISTER_FACTORY(RouterFactory, NamedFilterConfigFactory);

} // namespace Router
} // namespace GenericProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
load("@envoy_toolshed//:macros.bzl", "json_data")
load(":contrib_build_config.bzl", "CONTRIB_EXTENSIONS")

licenses(["notice"])  # Apache 2

exports_files([
    "extensions_metadata.yaml",
    "contrib_build_config.bzl",
])

json_data(
    name = "contrib_extensions_build_config",
    data = CONTRIB_EXTENSIONS,
)

filegroup(
    name = "configs",
    srcs = select({
        "//bazel:windows_x86_64": [],
        "//conditions:default": [
            "//contrib/golang/filters/http/test/test_data/dummy:testing_shared_objects",
        ],
    }),
    visibility = ["//visibility:public"],
)
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_binary",
    "envoy_cc_test",
    "envoy_contrib_package",
)
load(
    "//contrib:all_contrib_extensions.bzl",
    "ARM64_SKIP_CONTRIB_TARGETS",
    "FIPS_SKIP_CONTRIB_TARGETS",
    "PPC_SKIP_CONTRIB_TARGETS",
    "envoy_all_contrib_extensions",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

alias(
    name = "envoy",
    actual = ":envoy-static",
)

SELECTED_CONTRIB_EXTENSIONS = select({
    "//bazel:linux_aarch64": envoy_all_contrib_extensions(ARM64_SKIP_CONTRIB_TARGETS),
    "//bazel:linux_ppc": envoy_all_contrib_extensions(PPC_SKIP_CONTRIB_TARGETS),
    "//bazel:boringssl_fips": envoy_all_contrib_extensions(FIPS_SKIP_CONTRIB_TARGETS),
    "//conditions:default": envoy_all_contrib_extensions(),
})

envoy_cc_binary(
    name = "envoy-static",
    stamped = True,
    visibility = ["//visibility:public"],
    deps = ["//source/exe:envoy_main_entry_lib"] + SELECTED_CONTRIB_EXTENSIONS,
)

envoy_cc_test(
    name = "example_configs_test",
    size = "large",
    data = [
        "//configs:example_contrib_configs",
        "//test/config_test:example_configs_test_setup.sh",
    ],
    env = {
        "EXAMPLE_CONFIGS_TAR_PATH": "envoy/configs/example_contrib_configs.tar",
        "DISABLE_TEST_MERGE": "true",
        "GODEBUG": "cgocheck=0",
    },
    deps = [
        "//test/config_test:example_configs_test_lib",
    ] + SELECTED_CONTRIB_EXTENSIONS,
)
#include "test/mocks/server/factory_context.h"

#include "contrib/checksum/filters/http/source/config.h"
#include "contrib/envoy/extensions/filters/http/checksum/v3alpha/checksum.pb.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using testing::_;

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace ChecksumFilter {
namespace {

TEST(ChecksumFilterConfigTest, ChecksumFilter) {
  NiceMock<Server::Configuration::MockFactoryContext> context;
  ChecksumFilterFactory factory;
  envoy::extensions::filters::http::checksum::v3alpha::ChecksumConfig proto_config;
  Http::FilterFactoryCb cb =
      factory.createFilterFactoryFromProto(proto_config, "stats", context).value();
  Http::MockFilterChainFactoryCallbacks filter_callback;
  EXPECT_CALL(filter_callback, addStreamFilter(_));
  cb(filter_callback);
}

} // namespace
} // namespace ChecksumFilter
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include <memory>
#include <string>

#include "source/common/buffer/buffer_impl.h"
#include "source/common/http/header_map_impl.h"

#include "test/mocks/http/mocks.h"
#include "test/test_common/printers.h"
#include "test/test_common/utility.h"

#include "contrib/checksum/filters/http/source/checksum_filter.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using testing::_;
using testing::NiceMock;

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace ChecksumFilter {
namespace {

class ChecksumFilterTest : public testing::Test {
public:
  void SetUp() override {
    envoy::extensions::filters::http::checksum::v3alpha::ChecksumConfig config;
    config.set_reject_unmatched(true);
    for (const absl::string_view path : {"/abc", "/123"}) {
      auto entry = config.add_checksums();
      entry->mutable_path_matcher()->set_exact(path);
      // The sha256 of the string "banana"
      entry->set_sha256("b493d48364afe44d11c0165cf470a4164d1e2609911ef998be868d46ade3de4e");
    }
    config_ = std::make_shared<ChecksumFilterConfig>(config);
    filter_ = std::make_unique<ChecksumFilter>(config_);
    filter_->setDecoderFilterCallbacks(decoder_callbacks_);
    filter_->setEncoderFilterCallbacks(encoder_callbacks_);
  }

  ~ChecksumFilterTest() override { filter_->onDestroy(); }

  std::shared_ptr<ChecksumFilterConfig> config_;
  std::unique_ptr<ChecksumFilter> filter_;
  NiceMock<Http::MockStreamDecoderFilterCallbacks> decoder_callbacks_;
  NiceMock<Http::MockStreamEncoderFilterCallbacks> encoder_callbacks_;
  Http::TestResponseHeaderMapImpl response_headers_;
  Http::TestResponseTrailerMapImpl response_trailers_;
};

TEST_F(ChecksumFilterTest, RejectsUnmatched) {
  EXPECT_CALL(decoder_callbacks_, sendLocalReply(_, _, _, _, "no_checksum_for_path"));
  Http::TestRequestHeaderMapImpl request_headers{{":path", "/1234"}};
  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, true));
}

TEST_F(ChecksumFilterTest, RejectsMatchedNoData) {
  EXPECT_CALL(encoder_callbacks_, sendLocalReply(_, _, _, _, "checksum_but_no_body"));
  Http::TestRequestHeaderMapImpl request_headers{{":path", "/123"}};
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, true));
  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->encodeHeaders(response_headers_, true));
}

TEST_F(ChecksumFilterTest, RejectsMatchedWithMismatchedData) {
  EXPECT_CALL(encoder_callbacks_, sendLocalReply(_, _, _, _, "mismatched_checksum"));
  Http::TestRequestHeaderMapImpl request_headers{{":path", "/123"}};
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, true));
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(response_headers_, false));
  Buffer::OwnedImpl wrong_buffer{"aaa"};
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->encodeData(wrong_buffer, true));
}

TEST_F(ChecksumFilterTest, RejectsMatchedWithMismatchedDataAndTrailers) {
  EXPECT_CALL(encoder_callbacks_, sendLocalReply(_, _, _, _, "mismatched_checksum"));
  Http::TestRequestHeaderMapImpl request_headers{{":path", "/123"}};
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, true));
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(response_headers_, false));
  Buffer::OwnedImpl wrong_buffer{"aaa"};
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(wrong_buffer, false));
  EXPECT_EQ(Http::FilterTrailersStatus::StopIteration, filter_->encodeTrailers(response_trailers_));
}

TEST_F(ChecksumFilterTest, AcceptsMatchedWithMatchingData) {
  EXPECT_CALL(decoder_callbacks_, sendLocalReply(_, _, _, _, _)).Times(0);
  EXPECT_CALL(encoder_callbacks_, sendLocalReply(_, _, _, _, _)).Times(0);
  Http::TestRequestHeaderMapImpl request_headers{{":path", "/123"}};
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, true));
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(response_headers_, false));
  Buffer::OwnedImpl right_buffer{"banana"};
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(right_buffer, true));
}

TEST_F(ChecksumFilterTest, AcceptsMatchedWithMatchingDataInParts) {
  EXPECT_CALL(decoder_callbacks_, sendLocalReply(_, _, _, _, _)).Times(0);
  EXPECT_CALL(encoder_callbacks_, sendLocalReply(_, _, _, _, _)).Times(0);
  Http::TestRequestHeaderMapImpl request_headers{{":path", "/123"}};
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, true));
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(response_headers_, false));
  Buffer::OwnedImpl right_buffer_1{"ban"};
  Buffer::OwnedImpl right_buffer_2{"ana"};
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(right_buffer_1, false));
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(right_buffer_2, true));
}

TEST_F(ChecksumFilterTest, AcceptsMatchedWithMatchingDataAndTrailers) {
  EXPECT_CALL(decoder_callbacks_, sendLocalReply(_, _, _, _, _)).Times(0);
  EXPECT_CALL(encoder_callbacks_, sendLocalReply(_, _, _, _, _)).Times(0);
  Http::TestRequestHeaderMapImpl request_headers{{":path", "/123"}};
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, true));
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(response_headers_, false));
  Buffer::OwnedImpl right_buffer{"banana"};
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(right_buffer, false));
  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->encodeTrailers(response_trailers_));
}

} // namespace
} // namespace ChecksumFilter
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_test",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_test(
    name = "checksum_filter_test",
    srcs = ["checksum_filter_test.cc"],
    deps = [
        "//contrib/checksum/filters/http/source:checksum_filter_lib",
        "//source/common/buffer:buffer_lib",
        "//source/common/http:header_map_lib",
        "//test/mocks/http:http_mocks",
        "//test/mocks/upstream:upstream_mocks",
        "//test/test_common:utility_lib",
    ],
)

envoy_cc_test(
    name = "config_test",
    srcs = ["config_test.cc"],
    deps = [
        "//contrib/checksum/filters/http/source:config",
        "//test/mocks/server:factory_context_mocks",
        "@envoy_api//contrib/envoy/extensions/filters/http/checksum/v3alpha:pkg_cc_proto",
    ],
)
#pragma once

#include "source/extensions/filters/http/common/factory_base.h"

#include "contrib/envoy/extensions/filters/http/checksum/v3alpha/checksum.pb.h"
#include "contrib/envoy/extensions/filters/http/checksum/v3alpha/checksum.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace ChecksumFilter {

/**
 * Config registration for the checksum filter.
 */
class ChecksumFilterFactory
    : public Common::FactoryBase<
          envoy::extensions::filters::http::checksum::v3alpha::ChecksumConfig> {
public:
  ChecksumFilterFactory() : FactoryBase("envoy.filters.http.checksum") {}

private:
  Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoy::extensions::filters::http::checksum::v3alpha::ChecksumConfig& proto_config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

using UpstreamChecksumFilterFactory = ChecksumFilterFactory;

DECLARE_FACTORY(ChecksumFilterFactory);

} // namespace ChecksumFilter
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/checksum/filters/http/source/checksum_filter.h"

#include <openssl/mem.h>

#include "source/common/common/assert.h"
#include "source/common/common/hex.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace ChecksumFilter {

static std::vector<ChecksumFilterConfig::ChecksumMatcher> buildMatchers(
    const envoy::extensions::filters::http::checksum::v3alpha::ChecksumConfig& proto_config) {
  std::vector<ChecksumFilterConfig::ChecksumMatcher> matchers;
  for (const auto& checksum : proto_config.checksums()) {
    std::vector<uint8_t> bytes = Hex::decode(checksum.sha256());
    matchers.emplace_back(std::make_unique<Matchers::PathMatcher>(checksum.path_matcher()),
                          Sha256Checksum{bytes.begin(), bytes.end()});
  }
  return matchers;
}

ChecksumFilterConfig::ChecksumFilterConfig(
    const envoy::extensions::filters::http::checksum::v3alpha::ChecksumConfig& proto_config)
    : matchers_(buildMatchers(proto_config)), reject_unmatched_(proto_config.reject_unmatched()) {}

OptRef<const Sha256Checksum> ChecksumFilterConfig::expectedChecksum(absl::string_view path) {
  for (const auto& m : matchers_) {
    if (m.first->match(path)) {
      return m.second;
    }
  }
  return absl::nullopt;
}

ChecksumFilter::ChecksumFilter(ChecksumFilterConfigSharedPtr config) : config_(config) {}

Http::FilterHeadersStatus ChecksumFilter::decodeHeaders(Http::RequestHeaderMap& headers,
                                                        bool /*end_stream*/) {
  expected_checksum_ = config_->expectedChecksum(headers.Path()->value().getStringView());
  if (!expected_checksum_.has_value() && config_->rejectUnmatched()) {
    decoder_callbacks_->sendLocalReply(Http::Code::Forbidden, "No checksum for path", nullptr,
                                       absl::nullopt, "no_checksum_for_path");
    return Http::FilterHeadersStatus::StopIteration;
  }
  return Http::FilterHeadersStatus::Continue;
}

Http::FilterHeadersStatus ChecksumFilter::encodeHeaders(Http::ResponseHeaderMap& /*headers*/,
                                                        bool end_stream) {
  if (end_stream && expected_checksum_.has_value()) {
    encoder_callbacks_->sendLocalReply(Http::Code::Forbidden,
                                       "Expected checksum has value but response has no body",
                                       nullptr, absl::nullopt, "checksum_but_no_body");
    return Http::FilterHeadersStatus::StopIteration;
  }
  SHA256_Init(&sha_);
  return Http::FilterHeadersStatus::Continue;
}

Http::FilterDataStatus ChecksumFilter::encodeData(Buffer::Instance& data, bool end_stream) {
  if (!expected_checksum_.has_value()) {
    return Http::FilterDataStatus::Continue;
  }
  for (const auto& slice : data.getRawSlices()) {
    SHA256_Update(&sha_, slice.mem_, slice.len_);
  }
  if (end_stream && !checksumMatched()) {
    encoder_callbacks_->sendLocalReply(Http::Code::Forbidden, "Mismatched checksum", nullptr,
                                       absl::nullopt, "mismatched_checksum");
    return Http::FilterDataStatus::StopIterationNoBuffer;
  }
  return Http::FilterDataStatus::Continue;
}

Http::FilterTrailersStatus ChecksumFilter::encodeTrailers(Http::ResponseTrailerMap&) {
  if (!expected_checksum_.has_value() || checksumMatched()) {
    return Http::FilterTrailersStatus::Continue;
  }
  encoder_callbacks_->sendLocalReply(Http::Code::Forbidden, "Mismatched checksum", nullptr,
                                     absl::nullopt, "mismatched_checksum");
  return Http::FilterTrailersStatus::StopIteration;
}

bool ChecksumFilter::checksumMatched() {
  ASSERT(expected_checksum_.has_value());
  uint8_t checksum_buffer[SHA256_DIGEST_LENGTH];
  SHA256_Final(checksum_buffer, &sha_);
  OPENSSL_cleanse(&sha_, sizeof(sha_));
  return absl::string_view{reinterpret_cast<const char*>(&(*expected_checksum_)[0]),
                           expected_checksum_->size()} ==
         absl::string_view{reinterpret_cast<const char*>(checksum_buffer), sizeof(checksum_buffer)};
}

} // namespace ChecksumFilter
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

# Checksum L7 HTTP filter

envoy_cc_library(
    name = "checksum_filter_lib",
    srcs = ["checksum_filter.cc"],
    hdrs = ["checksum_filter.h"],
    deps = [
        "//envoy/http:filter_interface",
        "//source/common/buffer:buffer_lib",
        "//source/common/common:assert_lib",
        "//source/common/common:hex_lib",
        "//source/common/common:matchers_lib",
        "//source/common/http:codes_lib",
        "//source/common/http:header_map_lib",
        "//source/common/http:headers_lib",
        "//source/common/http:utility_lib",
        "//source/extensions/filters/http/common:pass_through_filter_lib",
        "@envoy_api//contrib/envoy/extensions/filters/http/checksum/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_contrib_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    deps = [
        ":checksum_filter_lib",
        "//envoy/registry",
        "//source/extensions/filters/http/common:factory_base_lib",
        "@envoy_api//contrib/envoy/extensions/filters/http/checksum/v3alpha:pkg_cc_proto",
    ],
)
#pragma once

#include <openssl/sha.h>

#include <memory>
#include <string>
#include <vector>

#include "envoy/http/filter.h"

#include "source/common/common/matchers.h"
#include "source/extensions/filters/http/common/pass_through_filter.h"

#include "contrib/envoy/extensions/filters/http/checksum/v3alpha/checksum.pb.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace ChecksumFilter {

using Sha256Checksum = absl::FixedArray<uint8_t, 32>;

/**
 * Configuration for the checksum filter.
 */
class ChecksumFilterConfig {
public:
  using ChecksumMatcher = std::pair<std::unique_ptr<Matchers::PathMatcher>, Sha256Checksum>;

  ChecksumFilterConfig(
      const envoy::extensions::filters::http::checksum::v3alpha::ChecksumConfig& proto_config);

  bool rejectUnmatched() const { return reject_unmatched_; }
  // Returns nullopt on no match.
  OptRef<const Sha256Checksum> expectedChecksum(absl::string_view path);

private:
  const std::vector<ChecksumMatcher> matchers_;
  const bool reject_unmatched_;
};

using ChecksumFilterConfigSharedPtr = std::shared_ptr<ChecksumFilterConfig>;

/**
 * A filter that is capable of checksuming an entire request before dispatching it upstream.
 */
class ChecksumFilter : public Http::PassThroughFilter {
public:
  ChecksumFilter(ChecksumFilterConfigSharedPtr config);

  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& headers,
                                          bool end_stream) override;
  Http::FilterHeadersStatus encodeHeaders(Http::ResponseHeaderMap& headers,
                                          bool end_stream) override;
  Http::FilterDataStatus encodeData(Buffer::Instance& data, bool end_stream) override;
  Http::FilterTrailersStatus encodeTrailers(Http::ResponseTrailerMap& trailers) override;
  void onDestroy() override {}

private:
  bool checksumMatched();
  ChecksumFilterConfigSharedPtr config_;
  OptRef<const Sha256Checksum> expected_checksum_;
  SHA256_CTX sha_;
};

} // namespace ChecksumFilter
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/checksum/filters/http/source/config.h"

#include <cstdint>
#include <string>

#include "envoy/registry/registry.h"

#include "contrib/checksum/filters/http/source/checksum_filter.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace ChecksumFilter {

Http::FilterFactoryCb ChecksumFilterFactory::createFilterFactoryFromProtoTyped(
    const envoy::extensions::filters::http::checksum::v3alpha::ChecksumConfig& proto_config,
    const std::string&, Server::Configuration::FactoryContext&) {
  ChecksumFilterConfigSharedPtr filter_config(new ChecksumFilterConfig(proto_config));
  return [filter_config](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamFilter(std::make_shared<ChecksumFilter>(filter_config));
  };
}

/**
 * Static registration for the checksum filter (sha256). @see RegisterFactory.
 */
REGISTER_FACTORY(ChecksumFilterFactory, Server::Configuration::NamedHttpFilterConfigFactory);

} // namespace ChecksumFilter
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include <string>

#include "source/common/common/random_generator.h"
#include "source/extensions/transport_sockets/tls/private_key/private_key_manager_impl.h"

#include "test/common/stats/stat_test_utility.h"
#include "test/mocks/common.h"
#include "test/mocks/server/transport_socket_factory_context.h"
#include "test/mocks/ssl/mocks.h"
#include "test/mocks/thread_local/mocks.h"
#include "test/test_common/environment.h"
#include "test/test_common/registry.h"
#include "test/test_common/simulated_time_system.h"
#include "test/test_common/utility.h"

#include "contrib/cryptomb/private_key_providers/source/cryptomb_private_key_provider.h"
#include "fake_factory.h"
#include "gtest/gtest.h"

using testing::NiceMock;
using testing::ReturnRef;

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace CryptoMb {

envoy::extensions::transport_sockets::tls::v3::PrivateKeyProvider
parsePrivateKeyProviderFromV3Yaml(const std::string& yaml_string) {
  envoy::extensions::transport_sockets::tls::v3::PrivateKeyProvider private_key_provider;
  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml_string), private_key_provider);
  return private_key_provider;
}

class CryptoMbConfigTest : public Event::TestUsingSimulatedTime, public testing::Test {
public:
  CryptoMbConfigTest() : api_(Api::createApiForTest(store_, time_system_)) {
    ON_CALL(factory_context_.server_context_, api()).WillByDefault(ReturnRef(*api_));
    ON_CALL(factory_context_.server_context_, threadLocal()).WillByDefault(ReturnRef(tls_));
    ON_CALL(factory_context_, sslContextManager()).WillByDefault(ReturnRef(context_manager_));
    ON_CALL(context_manager_, privateKeyMethodManager())
        .WillByDefault(ReturnRef(private_key_method_manager_));
  }

  Ssl::PrivateKeyMethodProviderSharedPtr createWithConfig(std::string yaml,
                                                          bool supported_instruction_set = true) {
    FakeCryptoMbPrivateKeyMethodFactory cryptomb_factory(supported_instruction_set);
    Registry::InjectFactory<Ssl::PrivateKeyMethodProviderInstanceFactory>
        cryptomb_private_key_method_factory(cryptomb_factory);

    return factory_context_.sslContextManager()
        .privateKeyMethodManager()
        .createPrivateKeyMethodProvider(parsePrivateKeyProviderFromV3Yaml(yaml), factory_context_);
  }

  Event::SimulatedTimeSystem time_system_;
  NiceMock<Server::Configuration::MockTransportSocketFactoryContext> factory_context_;
  Stats::IsolatedStoreImpl store_;
  Api::ApiPtr api_;
  NiceMock<ThreadLocal::MockInstance> tls_;
  NiceMock<Ssl::MockContextManager> context_manager_;
  TransportSockets::Tls::PrivateKeyMethodManagerImpl private_key_method_manager_;
};

TEST_F(CryptoMbConfigTest, CreateRsa1024) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/rsa-1024.pem" }
)EOF";

  Ssl::PrivateKeyMethodProviderSharedPtr provider = createWithConfig(yaml);
  EXPECT_NE(nullptr, provider);
  EXPECT_EQ(false, provider->checkFips());
  EXPECT_EQ(provider->isAvailable(), true);
  Ssl::BoringSslPrivateKeyMethodSharedPtr method = provider->getBoringSslPrivateKeyMethod();
  EXPECT_NE(nullptr, method);

  ssl_private_key_result_t res;

  res = method->sign(nullptr, nullptr, nullptr, 0, 0, nullptr, 0);
  EXPECT_EQ(res, ssl_private_key_failure);
  res = method->decrypt(nullptr, nullptr, nullptr, 0, nullptr, 0);
  EXPECT_EQ(res, ssl_private_key_failure);
  res = method->complete(nullptr, nullptr, nullptr, 0);
  EXPECT_EQ(res, ssl_private_key_failure);
}

TEST_F(CryptoMbConfigTest, CreateRsa2048) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/rsa-2048.pem" }
)EOF";

  Ssl::PrivateKeyMethodProviderSharedPtr provider = createWithConfig(yaml);
  EXPECT_NE(nullptr, provider);
  EXPECT_EQ(provider->isAvailable(), true);
}

TEST_F(CryptoMbConfigTest, CreateRsa2048WithExponent3) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/rsa-2048-exponent-3.pem" }
)EOF";

  EXPECT_THROW_WITH_MESSAGE(createWithConfig(yaml), EnvoyException,
                            "Only RSA keys with \"e\" parameter value 65537 are allowed, because "
                            "we can validate the signatures using multi-buffer instructions.");
}

TEST_F(CryptoMbConfigTest, CreateRsa3072) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/rsa-3072.pem" }
)EOF";

  EXPECT_NE(nullptr, createWithConfig(yaml));
}

TEST_F(CryptoMbConfigTest, CreateRsa4096) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/rsa-4096.pem" }
)EOF";

  EXPECT_NE(nullptr, createWithConfig(yaml));
}

TEST_F(CryptoMbConfigTest, CreateRsa512) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/rsa-512.pem" }
)EOF";

  Ssl::PrivateKeyMethodProviderSharedPtr provider = createWithConfig(yaml);
  EXPECT_NE(nullptr, provider);
  EXPECT_EQ(provider->isAvailable(), false);
}

TEST_F(CryptoMbConfigTest, CreateEcdsaP256) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/ecdsa-p256.pem" }
)EOF";

  Ssl::PrivateKeyMethodProviderSharedPtr provider = createWithConfig(yaml);
  EXPECT_NE(nullptr, provider);
  EXPECT_EQ(false, provider->checkFips());
  Ssl::BoringSslPrivateKeyMethodSharedPtr method = provider->getBoringSslPrivateKeyMethod();
  EXPECT_NE(nullptr, method);

  ssl_private_key_result_t res;

  res = method->sign(nullptr, nullptr, nullptr, 0, 0, nullptr, 0);
  EXPECT_EQ(res, ssl_private_key_failure);
  res = method->decrypt(nullptr, nullptr, nullptr, 0, nullptr, 0);
  EXPECT_EQ(res, ssl_private_key_failure);
  res = method->complete(nullptr, nullptr, nullptr, 0);
  EXPECT_EQ(res, ssl_private_key_failure);
}

TEST_F(CryptoMbConfigTest, CreateEcdsaP256Inline) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key:
          inline_string: |
            -----BEGIN PRIVATE KEY-----
            MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgIxp5QZ3YFaT8s+CR
            rqUqeYSe5D9APgBZbyCvAkO2/JChRANCAARM53DFLHORcSyBpu5zpaG7/HfLXT8H
            r1RaoGEiH9pi3MIKg1H+b8EaM1M4wURT2yXMjuvogQ6ixs0B1mvRkZnL
            -----END PRIVATE KEY-----
)EOF";

  EXPECT_NE(nullptr, createWithConfig(yaml));
}

TEST_F(CryptoMbConfigTest, CreateEcdsaP384) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/ecdsa-p384.pem" }
)EOF";

  EXPECT_THROW_WITH_MESSAGE(createWithConfig(yaml), EnvoyException,
                            "Only P-256 ECDSA keys are supported.");
}

TEST_F(CryptoMbConfigTest, CreateMissingPrivateKey) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/missing.pem" }
)EOF";

  EXPECT_THROW(createWithConfig(yaml), EnvoyException);
}

TEST_F(CryptoMbConfigTest, CreateMissingKey) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.02s
        )EOF";

  EXPECT_THROW_WITH_MESSAGE(createWithConfig(yaml), EnvoyException,
                            "Unexpected DataSource::specifier_case(): 0");
}

TEST_F(CryptoMbConfigTest, CreateMissingPollDelay) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/rsa-4096.pem" }
        )EOF";

  EXPECT_THROW_WITH_REGEX(createWithConfig(yaml), EnvoyException,
                          "Proto constraint validation failed");
}

TEST_F(CryptoMbConfigTest, CreateZeroPollDelay) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0s
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/rsa-4096.pem" }
        )EOF";

  EXPECT_THROW_WITH_REGEX(createWithConfig(yaml), EnvoyException,
                          "Proto constraint validation failed");
}

TEST_F(CryptoMbConfigTest, CreateOneMillisecondPollDelay) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.001s
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/rsa-4096.pem" }
        )EOF";

  Ssl::PrivateKeyMethodProviderSharedPtr provider = createWithConfig(yaml);
  EXPECT_NE(nullptr, provider);
  EXPECT_EQ(provider->isAvailable(), true);
  CryptoMbPrivateKeyMethodProvider* cryptomb_provider =
      dynamic_cast<CryptoMbPrivateKeyMethodProvider*>(provider.get());
  EXPECT_EQ(cryptomb_provider->getPollDelayForTest(), std::chrono::microseconds(1000));
}

TEST_F(CryptoMbConfigTest, CreateTwoMillisecondPollDelay) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.002s
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/rsa-4096.pem" }
        )EOF";

  Ssl::PrivateKeyMethodProviderSharedPtr provider = createWithConfig(yaml);
  EXPECT_NE(nullptr, provider);
  EXPECT_EQ(provider->isAvailable(), true);
  CryptoMbPrivateKeyMethodProvider* cryptomb_provider =
      dynamic_cast<CryptoMbPrivateKeyMethodProvider*>(provider.get());
  EXPECT_EQ(cryptomb_provider->getPollDelayForTest(), std::chrono::microseconds(2000));
}

TEST_F(CryptoMbConfigTest, CreateLessThanOneMillisecondPollDelay) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        poll_delay: 0.0009s
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/rsa-4096.pem" }
        )EOF";

  EXPECT_THROW_WITH_REGEX(createWithConfig(yaml), EnvoyException,
                          "Proto constraint validation failed");
}

TEST_F(CryptoMbConfigTest, CreateNotSupportedInstructionSet) {
  const std::string yaml = R"EOF(
      provider_name: cryptomb
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.cryptomb.v3alpha.CryptoMbPrivateKeyMethodConfig
        private_key: { "filename": "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/rsa-4096.pem" }
        poll_delay: 0.02s
        )EOF";

  Ssl::PrivateKeyMethodProviderSharedPtr provider = createWithConfig(yaml, false);
  EXPECT_EQ(provider->isAvailable(), false);
}

} // namespace CryptoMb
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
-----BEGIN RSA PRIVATE KEY-----
MIIG4wIBAAKCAYEAv86yDTGazbq0uf6Xji4kdROCQaSmL+Ttse06BVXDiv7nf/13
wJwt6tQzexw1GXQ5P2I0Mjh1NUr1tFXf3D99laJE209GEVWaQPEdoyRLdVibgH8I
rtt8IhEIHMif8bBXONPwAy4M1HP0AWMIG0WV29ZTgZGmHknI+Rkm1P0bGhod6YBI
sNNY59PjL0tWOf1M8Mj6OOcDS7wBgVMNZSA0MlkUf10Kes4fay/gqDrM2dEHi1lB
7VNQ6nWbSNi5qTPMfhi0bkc64l2fXQ9qQ1BFaFR6AV/EQHQUhFv+AJ62d5vxssi3
4DgLVz9XVaGXyNHahdxtLGdBzbbZ9OKPXnSGZdfhBxvr3iKj/MDBFq97mzjXisOu
ZljFXx+I5VEiYjgdB2k+wFVOv9XNvwVQdO7p9lX9PJrV6pOKD5tJgh842j3134vA
PaANDaZBbYj+8HN4oDU9Dtvi7INO7G2yXsCiC1xWwczHBhKv+M2cip4eL8XH0OZj
hZi78mDSW1cY4x0xAgMBAAECggGALmijmh+jdh2ztsEMCIHPnmg+/wUIlNQOUxu0
CzBqJMpyVvyMKhVf4s6/Og1kJ6mAZH6tZG1WprNhaeXRSWgvSbI+eNXgfTc6IHZ2
lk+k1lq/HUMfZbeDfHakgNpmIMNrBzv4ebx9rDX2FxPQFVEr5kogYFxOVkvCDctx
It2u3gztqd65N9ebTlRtRrcywMsx/5yRNo1mtb9imdjvh8VX+8qj9AEeFQKkhXnL
IMlBYX57FdNd6T9cd65HCUQu/+qhJ7E/cRdoYTG0Hp9bc7pXM7b+6KqonUiMmi1k
SzNlEuYU3SEFKen1K0b8Bk+d/abUaWsqPDPA4jBQye5AdCIMYMazT/KNBGZkNBPu
abmlAut6MDVkwFsLDU5S4tpKqKUUeVmN7jte3BERICMQr3WD6cXd/AtdMrwWaBVm
HTq9Lf7GFUxIDVU1pyGGHkfeXjoK+Ur5DIwJEr6BfhEMC6LGLU3UeWcZOKm8nkc4
8ue73s+D+mcK4BiI0kRTwXejcnM1AoHBAN9VGvoyvR6s6J5lF59b+B/qQhU4MNfD
vyJS7UxZke/JNWXPKlrij1bZgz2vgjsF+WaPYc1BVKjxRy1fciNlIqaEsjgnxm4M
cHUD8uPeQi8ARPwm+kbRr/IVbD7pFIyKurYraNt3kQQq9aE9fOSOxjbnY+GhGbBM
WnbZp0TH2oUbqHuKRmGUsFIS0tAhfObo4OebHOhiyIB+I7OZQKBU2qVIWyAinjFN
PXiZ9ZT78v0YHZmI29ADEFw0cV1+R04P2wKBwQDb3Rrw+YXPifJDdeaupSno6xJ1
ACWc0Oof7LVRZC8JJw+eMtgbx9VCcQs811QHJ+q9gXRR3JC38J1JCYJaMcCpG++H
Spl3t2Rsd7dT3RxamYRnUtw6yFUTxYtEkbbViURxh5ghIMEuTyQ7vcV6SXNubGxp
Pc/TQboUZHpehSnJhNiFXsCHgjd7eu/q6cxMqaaqULIie+sfbB39lnbuZ53f1pLZ
7zb2E98m0DtjVstv+NYMoY7DG2DsJ8skw7QNiuMCgcEAhoYI/fRaHoQgimhyVjdb
uj2tGIMESLNMCizRa0/4q+sTEwQ6iww1MydJ+nohg9QRakmrq6tSh4DuUtJPOirN
OGhtwY2T5O3xP0rln4RdcVpEM253Cvl7deKZlTtoeU+HL/vt6WSYIV6PHlSfSj0G
AERY0avsgVk8lKJ+Mtv/MHZ8gg3EXzrlCkr0WRIS3jQgZOH2A7Sc+WkBsEj7uJfk
K/LtkOnJSAEyqdZzKw6oSvOfwL/DSATQcfnU33AVG1xJAoHAP7KYOpZgARe7G3ZO
Be0N7lAkgccwHnWcTvF6OoFm6yTo7nFWkP3dOCmeEttjmcsjxBF8TLc1KkVInD9o
B4+AfL3+MFkZi0iTjKVGdMKLk2gEpxanfVRK6baCubPpn4XsUWPyXC6sKSl+mtxJ
GTuseKJq6jahPlg9e+j8VuQHjj2xqTohV2EPh/O/DHT93nwMMC2+3iS+otTk/3IX
NMzKPW5iD0exyatKLGmJuycLO36BLRmlTbth4ilJPnaAdKf3AoHAANX+2JM3xxc0
CchCT31ZEnkGRjDtQCZ+gR6BWeWF02HpEXk+scHthD5hUyBwrJkYMTT9wCLkerQl
AioOGJCZkkio/5NDkPmJ80EW/4OcQc/p/uUY5H3PEsLAJBKbb3q30FC0KRlvhg3h
HqyzAOuEjuBJcaCNsN/c+XYIQEbN4I51Zm04HVIDoCYeBs+XRd56foVOSUfW1Dm1
jgbcxHBaZ1FYeBWoGutBj+BYGVNwD0XpltBVStlinaH48FWKCHiW
-----END RSA PRIVATE KEY-----
-----BEGIN RSA PRIVATE KEY-----
MIIBOgIBAAJBAJ5UTbiBg1SYFhLgXPawBf+joDBSVqsWQ4SS2lCt+pLSkit19LK9
73f5ZYBhZFsszPzPn7bFEGVwsRiegtf5FccCAwEAAQJABykg6rtQyT6noOrsyWtk
mg84a3cN3GcBXrmVjhiQQJubMkUNFE+l0JPNb8kzwzhcm8kzuO92CkqFSLXyQyDP
IQIhAMxkU+gZ5HIStWr0yPMOVoikNjcTW9PGtcUu1zucodilAiEAxk6KGDnHr9Dq
U150jT9aQTlZiZ6lF9kRU/gCcaIHPPsCIQC/6fRfGvDFq4tswittDSlzY70EOckf
MJW8cB7oekn9gQIgGVRg2TVQJ0nlFF8FPiFwctJTeHuWFNS6HOKZ1U/f4s8CIBAA
Kw3ZPC6zxfQNnkI+c96cbTQhQrVPGPlx5fC3l0Ru
-----END RSA PRIVATE KEY-----
-----BEGIN RSA PRIVATE KEY-----
MIIJKQIBAAKCAgEAwvYN7bZNnIbifmo4WlYqQPXoCXjLRUspAX8jkViYJH4XIXD6
lajlKOxvW27D9rIYjfNFShmfI8cf4IrXgrWUgV0TYBi8qm/Ppnr38R8wFy0z9fE6
anF61vKdxjsW89NhT4QjvDNmOS6B6gK4JxSWo2MNpqxX79IOidc8T6mX8nxLYZek
fb3qXeL8lGp46cwRnwmD0eua8r+9hHU/W4q3LBjVCEarK/8Haj+Mfccn97QAiaeh
44/oALNRK4cUr2L3s0JuiXf3ihLi6yWXZ9LIklB8rvjWaK5IgYRlLE1Kwc/k1WCC
H7IQVLRnZAZxhs/pXN+9XQYgnNDn9Bczj8UMNmzVs3wQQ+TMjpNSSEvUTIs6gfNH
MwiPfbKXjAXKWSJBOfK77mtcUByT2iilW7lwUYRebl+Sh9jJSYzhOdiIrBgtUTtG
C0bEhBHKNYt13C5NRLU2UpxxqDKdlV4iz7eDZONuasY2sU9krKNh631kyHe66EBx
B2IIA48apavlyzHP6TyTw8PM00oL5UOmCsd1oZi1kaJEH0yLdWMvfU/d0mLMlTUF
3bHsoe6zwn8ZhDQ4X781cxxt04j87bNNcDetJ2+4R/GsxyRozetJ3sf1DWYxeux0
+WbZwCbuFkJPqiLMcSNU7Mzzpqwsz6muRXexZrR0T+Mhfi4mSoKmhwgcRrkCAwEA
AQKCAgEAitUHFCkG2Zkf/t+LI6FKU5oJU31mWwDrwXoVDPKm3Q3BUPoQJ7TvAxZj
MhwNhkZKwALla6AVODgbVh3o29aMWxa5rmvPJhubJjVZDKal60swPko6zAPlct2w
RrJbZOQ43pP9ko6Tk9KvhsHK+2Fo6A6ocPE3absOyU+xThU5895ZG7UN2ND97T+v
l8y+L9c3ESaIbVs2qvipb4LCzGBakhdY1JzmVd01HY8Fb6f7qSPQYjYyTUdz8dO/
0JxPuZljRI7hAhmg9/z9BHBvgeqTE8YnE751iHPbhAeQuFyOCLgPf3dLEmENyhPx
sEP6YgL6bj2RroWngaQuGR7Qg+fRCkxBfBZGgkZd+WbN6Yv0EK3ktDkCcmi6urx3
6kOb4BWyRbwZCUMF4Jzo0aQYZSZQuHcl6QZbX6AhCSzPWjMyb7Q5GApbwRNRBcjI
iu8Ts+kXMiWtF7+Bd78JTnr6PPGMiPvjlZCGYTmvzq5/EJmIFvB8XlV3iskb29+w
9Fa/In+/mXuFKPM6Vpc6+FxPzm1P2cP68/jqB3mg3unwx0ecXxjkHBJKcPwNCTaz
nfPxjV+ep9VwyKViJ6SX3OPeMbsNQl6Zr4oCF+qvVZMGsrmd9fpE5NrKA7I+zYBE
6pyGod7cZRiBU41uVO44cFiSTURUPHilwFaTVwb4p2BAHfVKWJUCggEBAPu57609
SQZ8O4VpiHPDOa0inZJvzZ+0lAo6NOMyhTvY9CPn+YjfYNfol525W+T7JnrvWeic
FIin9jHxnpXK0B/AftUJTw4rEpCio5f79xpFAES0vw+241+4XOI7c9LCOC+FWBiT
4DVfYoob31vyK9+7pRSZ+SiMiu3vAY7seUSIAL0SvpvSbDyzZ+2eVZWBEgW6LVrz
tDE8oNqQUMXA2/FchZmv9ysATBmsTJBo9POVkKNTyUMQzxtslvC6v4oNr7K3OIHb
gcf4TzWXOzn9tG+4xYT9pWW5msGawiUZRcTaAna+E/OgpKWnEnZgCC4hboRLxPLX
53FmOM6M2G7thzsCggEBAMZFZyj++yu5Efce9ccQX6LyfHrqXjNkrU+u9Ed1v5WV
N9ACMmXrHJh5IYa5rhfMM4jWMFWyYbfsCzpfGn4S+5y/fzoFLoryPyH9ygDePA0Q
sRF/PLveyOyVWvP0QtqMjivV40zHpySlUdTfH6DMpEJcutN4Zb28++HVcrwhoC1k
6JAv6lMi0JVZPOQ9PdvWfqWiUFyWL4D2UzzGunCyDZRKhNFFZK8ZMwGrq1GwKbMY
UjR1V446+XmVy1UmJBcsfv8N1GNAmS4JZnIYAA3F79gSaPMouBiGEoq9STZNMV8i
yWX+q2+xF5on0HLiQQDF+CDf7TKQdn9nIb5T9UxH0psCggEBAIXdp5wVT1RnlK+q
I6qMU4vDMNDDLDKWMXQO6Dk6kKf3BD5kCsvDHxky1A5ImJn5Bcmyp7mP50uVJtQA
jjlSlcOM9uYMAUKjnUfVdfJJSGtr7mybQk/1Do3E2YBl5X5bUs3St7q6SS2ZACo6
EFoxOyvL+kouZ9Ysh2VpCQccspDDUsE5yqvLB0xwjABNh23uKctp6tzHZTgZ6eDR
hmLj4RNGBLZqYaM4kT/F5SGW70zqaPSyhgFoWvtWkB6M8XdVN+5uiVplhWr2ngj9
171LMj2HoWLMEL08KxRyXHSmL/gzh8Pl6W5SK7z8UFErWK5PkRpBwQbz0lz345XU
SPUU1CkCggEANl19Zd5UnK6IYIxatBSnRJTc0Q9GeS0X4IuGa7m7qJZb0Wtoyk1n
b9928+wh8mCJmPGyGy1oYfgVNBIzv3IRD+/qQMx+8JZv/TALnaVSLfrvsm6DBriV
u1lQsSe+1RJJQXfKdZkhGYlDIO11TLAQMiofCDExJI+XOVs/tJo7w3ax1idtRxJ6
wxjO+35XYdo0q9IP2vNLXz8rn7SWFqSb2Jd+R6uRafms5L5foWx+Yp8+mye5tEQz
d8U9FcH5j2kiAWmXXQeveNIXBx3RlfU6SLLzmAkIQaExoF06n+sWqJFvS8pC08Np
R1m3bGjhjga6fLkp3v2BoHl05S08S4g+FQKCAQARIy6gUizXPEv8x1Pk70LzHPDQ
y8Og3OozpYd1/AyY2TDPYdRhg4zk+R5JIYLQfsitdH5uzCO+UFwsKwhv76TIqN+D
ht+vEoJ0UXrVG8MQe8VnV7+vdQtYrpYMi/SqnXFQuzaqW3LtWVEjXQFOosNGEtNV
VupzeqsYa5GhhzagCTLMxkgAmyo7/GVa5h4dreiv3hq1xOwbmD7Y6J29NGJwlQPY
7nw4rBtXxbMxThVgktLHuKLBapr2Gulg4tDTj4e1VoM8u9Y34imc5NevoQ32hfvr
cZErq0WhWXvqvmbwRyyf1GRizFSdJ71TxT7EG71IKIMzcapod9UXtXXf/IWF
-----END RSA PRIVATE KEY-----
-----BEGIN EC PRIVATE KEY-----
MIGkAgEBBDBE7nkbGPIsiG0S1vajwJkfVtlZM7+KhrN9LSqolHsNAv/t4kGA0Sn3
McnWqcts9RugBwYFK4EEACKhZANiAAT2tXd7DLnmD9JL+YNYH4+RgBgQSD5DnP90
Xu8uuOUZwO3ZLdzuf+TRs0MneULXS3fWqBCYo7gNPRdZR40QrT/4dQGpQsDAFl3f
Yg9Un5cxR+XovaseGsnMQoP80majEYA=
-----END EC PRIVATE KEY-----
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIMpJw5U66K+DcA963b+/jZYrMrZDjaB0khHSwZte3vYCoAoGCCqGSM49
AwEHoUQDQgAELp3XvBfkVWQBOKo3ttAaJ6SUaUb8uKqCS504WXHWMO4h89F+nYtC
Ecgl8EiLXXyc86tawKjGdizcCjrKMiFo3A==
-----END EC PRIVATE KEY-----
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

filegroup(
    name = "certs",
    srcs = glob(["*.pem"]),
)
-----BEGIN RSA PRIVATE KEY-----
MIICXwIBAAKBgQDX/SburqyA+DDb1Kz24bC1QPqXAZKKk5eUX6kXyU4Xg/532gvb
eX9ie2S/NdQwH9UU4jO2pTdph7R7BJZlqTxRjrIre83mIeZPlsUh4T7LACE19T0p
xvxxjZphRYUNcz+06KRaT91IdscCJkVCHFPD9DquVMyUwp5pjfFEw6eRYQIDAQAB
AoGBAM2FlLs/uOPLxuoXWDJflT8Twp9YHrIAORc1Y3g/1DAqKESxVeEUnnL+iWIs
/WiBkceaaqzcT3r6Z3E7b0TzIXGVctJhOomclH6+NNOtC63WWXh6IFX/9YBDszUS
kRsIvOiqDqqAm6VVYpSArJvXFHMMLKvFtqu+AFW8zFkjkrhlAkEA+ZVunIWERDWL
KMxX/BZCkeIH3Rv/TczRrj7WqWPcIIPsBOsvqfL/xI3peagFs3TeLU/o16caWoLS
M7TltvTqtwJBAN2Kn+XiVm7GB9ITwoTNH95n6GL+3fX0jgwUvsygfo/UlhWoIMUh
Rb2Ic/72cDasBrnxIWjKlahqEOJh0YvNLKcCQQCYKP1VmaTovMgJaINfoeaV7/qh
V9dPhEZ1d8QBY2spu6Ph38ygTRCXsXkc/U30eZSWhXhMOYk8kzM56Nh/sVODAkEA
gAMzI9WmVfnt2PD8DFqu2Ie4G0PkI9P9JHP0UC9JEnknhDoTPXVdZAht5lymOKEs
fdMcl/2/foJTYUxeleanrwJBAKpgVmeC6Z8aUiDCJOEgfr9KvvWf77S2+PmgZwFx
lSK/Hz/MDhTHJlSjOin3gpl82VL5cmZywClkWIh1wE8PCvg=
-----END RSA PRIVATE KEY-----
-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAtBPRFC+8WpCauAyIr1uCTSK6qtAeevEW1vRkn/KkFQX27UWS
NgU/IukTbA091BDae7HEiWSp7IA1IDbu2q4IwY9UksjF8yFVNZYifr/IzS6lbHOI
ZRxuBzQOWgn0+7WNqzylXQ4y88yVVqSsdfiB8kJHi9o5r+M/3TBOrWCu75iYJeBV
w0nhMYIYOxB0RkPqB1+5z4cgLjyZYuC6iZe+9m718J4LRHTd60lg9wtg4H7RUE3u
VgjLSNpNyvVpOW2qHq+o21gdS7xBQ3pbD619vBWeNDkvCaBp6YZw4ENhUxeg4xaZ
nOrNEKZw4HQnzklDJe1a69InQI6F2b/26VEGgQIDAQABAoIBABKTzMkBV7QcIOoF
2QAGN74PbCR9Dffu8UVBtzPNC2Jj2CKIP9o01luaofdOsmczSebi4vytlt4gJ9rn
7+I9fAfD6pyt+8XmVW0OzQY4cNXCDyzOCm8r7Knvk990EYL6KuBUhFbCRT1jiLCE
koolFfrRHaJu4+6iSg9ekW9PfxyWfAxtEp4XrrqgN4jN3Lrx1rYCZnuYp3Lb+7WI
fJC/rK6MTphUMLbPMvmUwHjFzoe7g9MZxRRY3kY3h1n3Ju1ZbaCbP0Vi/+tdgKAl
290J2MStWWJfOoTNnnOSYhWIPQUiFtuUiab7tJ90GGb1DyLbOrr6wG2awJoqF9ZM
Qwvkf/UCgYEA5dsHhxuX+cTHF6m+aGuyB0pF/cnFccTtwWz2WwiH6tldnOAIPfSi
WJU33C988KwJFmAurcW43VVVs7fxYbC6ptQluEI+/L/3Mj/3WgwZaqX00cEPkzKA
M1XbvanQAU0nGfq+ja7sZVpdbBoBUb6Bh7HFyLM3LgliT0kMQeolKXMCgYEAyI9W
tEHnkHoPjAVSSobBOqCVpTp1WGb7XoxhahjjZcTOgxucna26mUyJeHQrOPp88PJo
xxdDJU410p/tZARtFBoAa++IK9qC6QLjN23CuwhD7y6RNZsRZg0kOCg9SLj+zVj5
mrvZFf6663EpL82UZ2zUGl4L1sMhYkia0TMjYzsCgYAFHuAIDoFQOyYETO/E+8E3
kFwGz1vqsOxrBrZmSMZeYQFI4WTNnImRV6Gq8hPieLKrIPFpRaJcq+4A1vQ1rO47
kTZV6IPmtZAYOnyUMPjP+2p80cQ7D0Dz49HFY+cSYFmipodgOKljiKPUKLAm1guk
rj0tv3BXQjZCdeoj/cdeKQKBgF8u3+hWqs5/j2dVkzN5drUbR0oOT2iwHzZFC2pt
+2XuHFBOx2px6/AbSdbX0zeMccVsVlu+Z4iJ8LNQYTqpexciK/cNzCN75csuKqXA
ur1G8+7Mu++j84LqU7kvJ76exZaxVmygICv3I8DfiLt+JqNbG+KTpay8GNjrOkZ0
raPHAoGAQ1p/Qvp7DHP2qOnUB/rItEVgWECD3uPx4NOCq7Zcx7mb9p7CI6nePT5y
heHpaJIqVyaS5/LHJDwvdB1nvtlgc9xKa5d1fWhLL3dwFCa98x5PDlN/JztH8DIt
tTlD+8NECIvI+ytbzLS0PZWBYctAR2rP2qlMCGdYerdjwl8S98E=
-----END RSA PRIVATE KEY-----
#!/bin/bash

set -e

openssl ecparam -name prime256v1 -genkey -noout -out ecdsa-p256.pem
openssl ecparam -name secp384r1 -genkey -noout -out ecdsa-p384.pem
openssl genrsa -out rsa-512.pem 512
openssl genrsa -out rsa-1024.pem 1024
openssl genrsa -out rsa-2048.pem 2048
openssl genrsa -3 -out rsa-2048-exponent-3.pem 2048
openssl genrsa -out rsa-3072.pem 3072
openssl genrsa -out rsa-4096.pem 4096

-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAwOQVkfs063s0I/wq/cBW63pX+6OxMxLXohNdBHCITbnwnI1B
xkEA6FvNWN+xRH2AW/8aiyyYSy38BErJwgOAbA1e9b6knYfZb5IIMVmnx519R7CK
TdYrZMnHbyvN3U2xULJZ+y+gPCnRihZSrL/hXlYHkyt/ef5OSxshyrjxN9RmxBLs
zTus5G+04mHN2RlmnjOALOjXApeHD9YGLddODqp89TUV+LpddI+s+0KFaRUWMxne
pegA+awoGSk4OGwHFbkMz5eIH9CZYCL3d6nt3Q9R48t4wsDGTJaNaAeg5Bv+6+pO
MuP9QteNl3d3ro/8KZOe7vvXDuAy/86tTjbYswIBAwKCAQEAgJgOYVIjR6d4F/1x
/oA58lGP/RfLd2HlFreTWEsFiSagaF4r2YCrRZKI5ep2LakAPVS8XMhlh3P9WDHb
1q0ASAjp+SnDE6/mSmFay5EahROo2nWxiTlyQzEvn3KJPjPLiyGRUh/AKBvhBrmM
cyqWPuQFDMeqUVQ0MhIWhyX2JTccM09IXbmV2WpAijw7encniBB8jy9eEzIkK6yE
HrDBOAN5Cq5MPgcbEZLrnixSKjm6Ti6KUMjhrPfUgfkS64eHtvdtKGoj9nWFqBjA
stmwZyCoYdLaeeuWsiT+m3lGJCH3YKM8dX723OIIUwlsld7kp9I5i6e153HZVow6
Va+gCwKBgQDg7VUKVHOJdzTRPw+N8xTJEzDsdHu0FhvD5HSZK9vCx05GOo2hC0Qj
1Zn0B+owIaMJmegcIFxoYxSasmZwkZYUyTNoXCa1hrS5D+C7IHZXYlCHhiws0T2v
Ak9fSEKliTov82TzpRCXq6C1NpghF0AIal5cqyUoBNQXn69zMqsKqQKBgQDbicb1
7DHCpxuC0/fmrlHiPunY4aYVz7CM6d6m0/Jpc1cBKqICkGuRBJlXhhXaCBt1I+vz
DF5GEyPOo80rRYqmuhKAttGcp2uX1B0bSu0N4A3NyuMEOqG1Pw+wNo8SJK7b55B/
3ZTzS+PL5FEztoGcw3nr8lseLuFVXkzimwRd+wKBgQCV844G4vew+iM2Kgpeog3b
YiCdov0iuWfX7aMQx+fXL4mEJwkWB4LCjmair/F1a8IGZpq9auhFl2MRzERLC7lj
MMzwPW8jryMmCpXSFaQ6QYsFBB1zNikfVt+U2tcZBibKokNNGLW6cmsjebrAuiqw
RumTHMNwAzgPv8pMzHIHGwKBgQCSW9n5SCEsb2esjU/vHuFBf0aQlm65NSBd8T8Z
4qGbojoAxxasYEe2AxDlBA6RWrz4wp1MsumEDMKJwojHg7HEfAxVzzZob50P4r4S
MfNelV6JMeytfGvOKgp1ebS2wx89RQr/6Q33h+0ymDYieau916adTDy+yeuOPt3s
Z1g+pwKBgQC5jdeQ5QVHWdpJnRSgiPsODpQ+AD+5H8ERTIWpb0e4uWfR76eOc2G3
NLdXvpU31ady05mVS1dCZsZyEytOkG2+AgfyjJsIfwxw+5PZCoV3xm90tb/43l+U
3YyKh/lmCfL8AM73ipXqSN1rQBf4gp4sXxJ0fbProsRQEIqveoyt8g==
-----END RSA PRIVATE KEY-----
#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#include "source/extensions/transport_sockets/tls/private_key/private_key_manager_impl.h"

#include "test/common/stats/stat_test_utility.h"
#include "test/test_common/environment.h"
#include "test/test_common/simulated_time_system.h"
#include "test/test_common/utility.h"

#include "contrib/cryptomb/private_key_providers/source/cryptomb_private_key_provider.h"
#include "fake_factory.h"
#include "gtest/gtest.h"
#include "openssl/evp.h"
#include "openssl/rsa.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace CryptoMb {

// Testing interface
ssl_private_key_result_t privateKeyCompleteForTest(CryptoMbPrivateKeyConnection* ops, uint8_t* out,
                                                   size_t* out_len, size_t max_out);
ssl_private_key_result_t ecdsaPrivateKeySignForTest(CryptoMbPrivateKeyConnection* ops, uint8_t* out,
                                                    size_t* out_len, size_t max_out,
                                                    uint16_t signature_algorithm, const uint8_t* in,
                                                    size_t in_len);
ssl_private_key_result_t rsaPrivateKeySignForTest(CryptoMbPrivateKeyConnection* ops, uint8_t* out,
                                                  size_t* out_len, size_t max_out,
                                                  uint16_t signature_algorithm, const uint8_t* in,
                                                  size_t in_len);
ssl_private_key_result_t rsaPrivateKeyDecryptForTest(CryptoMbPrivateKeyConnection* ops,
                                                     uint8_t* out, size_t* out_len, size_t max_out,
                                                     const uint8_t* in, size_t in_len);

namespace {

class TestCallbacks : public Envoy::Ssl::PrivateKeyConnectionCallbacks {
public:
  void onPrivateKeyMethodComplete() override{

  };
};

class CryptoMbProviderTest : public testing::Test {
protected:
  CryptoMbProviderTest()
      : api_(Api::createApiForTest(store_, time_system_)),
        dispatcher_(api_->allocateDispatcher("test_thread")),
        fakeIpp_(std::make_shared<FakeIppCryptoImpl>(true)),
        stats_(generateCryptoMbStats("cryptomb", *store_.rootScope())) {}

  bssl::UniquePtr<EVP_PKEY> makeEcdsaKey() {
    std::string file = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(
        "{{ test_rundir "
        "}}/contrib/cryptomb/private_key_providers/test/test_data/ecdsa-p256.pem"));
    bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(file.data(), file.size()));

    bssl::UniquePtr<EVP_PKEY> key(EVP_PKEY_new());

    EC_KEY* ec = PEM_read_bio_ECPrivateKey(bio.get(), nullptr, nullptr, nullptr);

    RELEASE_ASSERT(ec != nullptr, "PEM_read_bio_ECPrivateKey failed.");
    RELEASE_ASSERT(1 == EVP_PKEY_assign_EC_KEY(key.get(), ec), "EVP_PKEY_assign_EC_KEY failed.");
    return key;
  }

  bssl::UniquePtr<EVP_PKEY> makeRsaKey() {
    std::string file = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(
        "{{ test_rundir }}/contrib/cryptomb/private_key_providers/test/test_data/rsa-1024.pem"));
    bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(file.data(), file.size()));

    bssl::UniquePtr<EVP_PKEY> key(EVP_PKEY_new());

    RSA* rsa = PEM_read_bio_RSAPrivateKey(bio.get(), nullptr, nullptr, nullptr);
    RELEASE_ASSERT(rsa != nullptr, "PEM_read_bio_RSAPrivateKey failed.");
    RELEASE_ASSERT(1 == EVP_PKEY_assign_RSA(key.get(), rsa), "EVP_PKEY_assign_RSA failed.");
    return key;
  }

  Stats::TestUtil::TestStore store_;
  Api::ApiPtr api_;
  Event::SimulatedTimeSystem time_system_;
  Event::DispatcherPtr dispatcher_;
  std::shared_ptr<FakeIppCryptoImpl> fakeIpp_;
  CryptoMbStats stats_;

  // Result of an operation.
  ssl_private_key_result_t res_;

  // A size for signing and decryption operation input chosen for tests.
  static constexpr size_t in_len_ = 32;
  // Test input bytes for signing and decryption chosen for tests.
  static constexpr uint8_t in_[in_len_] = {0x7f};

  // Maximum size of out_ in all tests cases.
  static constexpr size_t max_out_len_ = 128;
  uint8_t out_[max_out_len_] = {0};

  // Size of output in out_ from an operation.
  size_t out_len_ = 0;
};

class CryptoMbProviderEcdsaTest : public CryptoMbProviderTest {
protected:
  CryptoMbProviderEcdsaTest()
      : queue_(std::chrono::milliseconds(200), KeyType::Ec, 256, fakeIpp_, *dispatcher_, stats_),
        pkey_(makeEcdsaKey()) {}
  CryptoMbQueue queue_;
  bssl::UniquePtr<EVP_PKEY> pkey_;

  const std::string queue_size_histogram_name_ = "cryptomb.ecdsa_queue_sizes";
};

class CryptoMbProviderRsaTest : public CryptoMbProviderTest {
protected:
  CryptoMbProviderRsaTest()
      : queue_(std::chrono::milliseconds(200), KeyType::Rsa, 1024, fakeIpp_, *dispatcher_, stats_),
        pkey_(makeRsaKey()) {
    RSA* rsa = EVP_PKEY_get0_RSA(pkey_.get());
    fakeIpp_->setRsaKey(rsa);
  }
  CryptoMbQueue queue_;
  bssl::UniquePtr<EVP_PKEY> pkey_;

  const std::string queue_size_histogram_name_ = "cryptomb.rsa_queue_sizes";
};

TEST_F(CryptoMbProviderEcdsaTest, TestEcdsaSigning) {
  // Initialize connections.
  TestCallbacks cbs[CryptoMbQueue::MULTIBUFF_BATCH];
  std::vector<std::unique_ptr<CryptoMbPrivateKeyConnection>> connections;
  for (auto& cb : cbs) {
    connections.push_back(std::make_unique<CryptoMbPrivateKeyConnection>(
        cb, *dispatcher_, bssl::UpRef(pkey_), queue_));
  }

  // Create MULTIBUFF_BATCH amount of signing operations.
  for (uint32_t i = 0; i < CryptoMbQueue::MULTIBUFF_BATCH; i++) {
    // Create request.
    res_ = ecdsaPrivateKeySignForTest(connections[i].get(), nullptr, nullptr, max_out_len_,
                                      SSL_SIGN_ECDSA_SECP256R1_SHA256, in_, in_len_);
    EXPECT_EQ(res_, ssl_private_key_retry);

    // No processing done after first requests.
    // After the last request, the status is set only from the event loop which is not run. This
    // should still be "retry", the cryptographic result is present anyway.
    res_ = privateKeyCompleteForTest(connections[i].get(), nullptr, nullptr, max_out_len_);
    EXPECT_EQ(res_, ssl_private_key_retry);
  }

  // Timeout does not have to be triggered when queue is at maximum size.
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);

  res_ = privateKeyCompleteForTest(connections[0].get(), out_, &out_len_, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_success);
  EXPECT_NE(out_len_, 0);
}

TEST_F(CryptoMbProviderRsaTest, TestRsaPkcs1Signing) {
  // Initialize connections.
  TestCallbacks cbs[CryptoMbQueue::MULTIBUFF_BATCH];
  std::vector<std::unique_ptr<CryptoMbPrivateKeyConnection>> connections;
  for (auto& cb : cbs) {
    connections.push_back(std::make_unique<CryptoMbPrivateKeyConnection>(
        cb, *dispatcher_, bssl::UpRef(pkey_), queue_));
  }

  // Create MULTIBUFF_BATCH amount of signing operations.
  for (uint32_t i = 0; i < CryptoMbQueue::MULTIBUFF_BATCH; i++) {
    // Create request.
    res_ = rsaPrivateKeySignForTest(connections[i].get(), nullptr, nullptr, max_out_len_,
                                    SSL_SIGN_RSA_PKCS1_SHA256, in_, in_len_);
    EXPECT_EQ(res_, ssl_private_key_retry);

    // No processing done after first requests.
    // After the last request, the status is set only from the event loop which is not run. This
    // should still be "retry", the cryptographic result is present anyway.
    res_ = privateKeyCompleteForTest(connections[i].get(), nullptr, nullptr, max_out_len_);
    EXPECT_EQ(res_, ssl_private_key_retry);
  }

  // Timeout does not have to be triggered when queue is at maximum size.
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);

  res_ = privateKeyCompleteForTest(connections[0].get(), out_, &out_len_, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_success);
  EXPECT_NE(out_len_, 0);

  // Check the signature in out_.
  RSA* rsa = EVP_PKEY_get0_RSA(pkey_.get());

  uint8_t buf[max_out_len_] = {0};
  size_t buf_len = 0;
  EXPECT_EQ(RSA_verify_raw(rsa, &buf_len, buf, max_out_len_, out_, out_len_, RSA_PKCS1_PADDING), 1);
}

TEST_F(CryptoMbProviderRsaTest, TestRsaPssSigning) {
  // Initialize connections.
  TestCallbacks cbs[CryptoMbQueue::MULTIBUFF_BATCH];
  std::vector<std::unique_ptr<CryptoMbPrivateKeyConnection>> connections;
  for (auto& cb : cbs) {
    connections.push_back(std::make_unique<CryptoMbPrivateKeyConnection>(
        cb, *dispatcher_, bssl::UpRef(pkey_), queue_));
  }

  // Create MULTIBUFF_BATCH amount of signing operations.
  for (uint32_t i = 0; i < CryptoMbQueue::MULTIBUFF_BATCH; i++) {
    // Create request.
    res_ = rsaPrivateKeySignForTest(connections[i].get(), nullptr, nullptr, max_out_len_,
                                    SSL_SIGN_RSA_PSS_SHA256, in_, in_len_);
    EXPECT_EQ(res_, ssl_private_key_retry);

    // No processing done after first requests.
    // After the last request, the status is set only from the event loop which is not run. This
    // should still be "retry", the cryptographic result is present anyway.
    res_ = privateKeyCompleteForTest(connections[i].get(), nullptr, nullptr, max_out_len_);
    EXPECT_EQ(res_, ssl_private_key_retry);
  }

  // Timeout does not have to be triggered when queue is at maximum size.
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);

  res_ = privateKeyCompleteForTest(connections[0].get(), out_, &out_len_, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_success);
  EXPECT_NE(out_len_, 0);

  // Check the signature in out_.
  RSA* rsa = EVP_PKEY_get0_RSA(pkey_.get());

  uint8_t buf[max_out_len_] = {0};
  unsigned int buf_len = 0;
  const EVP_MD* md = SSL_get_signature_algorithm_digest(SSL_SIGN_RSA_PSS_SHA256);
  EXPECT_NE(md, nullptr);
  bssl::ScopedEVP_MD_CTX ctx;
  // Calculate the message digest (so that we can be sure that it has been signed).
  EXPECT_EQ(EVP_DigestInit_ex(ctx.get(), md, nullptr), 1);
  EXPECT_EQ(EVP_DigestUpdate(ctx.get(), in_, in_len_), 1);
  EXPECT_EQ(EVP_DigestFinal_ex(ctx.get(), buf, &buf_len), 1);

  EXPECT_EQ(RSA_verify_pss_mgf1(rsa, buf, buf_len, md, nullptr, -1, out_, out_len_), 1);
}

TEST_F(CryptoMbProviderRsaTest, TestRsaDecrypt) {
  // Initialize connections.
  TestCallbacks cbs[CryptoMbQueue::MULTIBUFF_BATCH];
  std::vector<std::unique_ptr<CryptoMbPrivateKeyConnection>> connections;
  for (auto& cb : cbs) {
    connections.push_back(std::make_unique<CryptoMbPrivateKeyConnection>(
        cb, *dispatcher_, bssl::UpRef(pkey_), queue_));
  }

  // Create MULTIBUFF_BATCH amount of decryption operations.
  for (uint32_t i = 0; i < CryptoMbQueue::MULTIBUFF_BATCH; i++) {
    // Create request.
    res_ = rsaPrivateKeyDecryptForTest(connections[i].get(), nullptr, nullptr, max_out_len_, in_,
                                       in_len_);
    EXPECT_EQ(res_, ssl_private_key_retry);

    // No processing done after first requests.
    // After the last request, the status is set only from the event loop which is not run. This
    // should still be "retry", the cryptographic result is present anyway.
    res_ = privateKeyCompleteForTest(connections[i].get(), nullptr, nullptr, max_out_len_);
    EXPECT_EQ(res_, ssl_private_key_retry);
  }

  // Timeout does not have to be triggered when queue is at maximum size.
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);

  res_ = privateKeyCompleteForTest(connections[0].get(), out_, &out_len_, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_success);
  EXPECT_NE(out_len_, 0);
}

TEST_F(CryptoMbProviderTest, TestErrors) {
  bssl::UniquePtr<EVP_PKEY> pkey = makeEcdsaKey();
  bssl::UniquePtr<EVP_PKEY> rsa_pkey = makeRsaKey();

  CryptoMbQueue ec_queue(std::chrono::milliseconds(200), KeyType::Ec, 256, fakeIpp_, *dispatcher_,
                         stats_);
  CryptoMbQueue rsa_queue(std::chrono::milliseconds(200), KeyType::Rsa, 1024, fakeIpp_,
                          *dispatcher_, stats_);

  TestCallbacks cb;

  CryptoMbPrivateKeyConnection op_ec(cb, *dispatcher_, bssl::UpRef(pkey), ec_queue);
  CryptoMbPrivateKeyConnection op_rsa(cb, *dispatcher_, bssl::UpRef(rsa_pkey), rsa_queue);

  // no operation defined
  res_ = ecdsaPrivateKeySignForTest(nullptr, nullptr, nullptr, max_out_len_,
                                    SSL_SIGN_ECDSA_SECP256R1_SHA256, in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_failure);
  res_ = rsaPrivateKeySignForTest(nullptr, nullptr, nullptr, max_out_len_, SSL_SIGN_RSA_PSS_SHA256,
                                  in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_failure);
  res_ = rsaPrivateKeyDecryptForTest(nullptr, nullptr, nullptr, max_out_len_, in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_failure);

  // Unknown signature algorithm
  res_ = ecdsaPrivateKeySignForTest(&op_ec, nullptr, nullptr, max_out_len_, 1234, in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_failure);
  res_ = rsaPrivateKeySignForTest(&op_rsa, nullptr, nullptr, max_out_len_, 1234, in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_failure);

  // Wrong signature algorithm
  res_ = ecdsaPrivateKeySignForTest(&op_ec, nullptr, nullptr, max_out_len_, SSL_SIGN_RSA_PSS_SHA256,
                                    in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_failure);
  res_ = rsaPrivateKeySignForTest(&op_rsa, nullptr, nullptr, max_out_len_,
                                  SSL_SIGN_ECDSA_SECP256R1_SHA256, in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_failure);

  // Wrong operation type
  res_ = ecdsaPrivateKeySignForTest(&op_rsa, nullptr, nullptr, max_out_len_,
                                    SSL_SIGN_ECDSA_SECP256R1_SHA256, in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_failure);
  res_ = rsaPrivateKeySignForTest(&op_ec, nullptr, nullptr, max_out_len_, SSL_SIGN_RSA_PSS_SHA256,
                                  in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_failure);
  res_ = rsaPrivateKeyDecryptForTest(&op_ec, nullptr, nullptr, max_out_len_, in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_failure);
}

TEST_F(CryptoMbProviderEcdsaTest, TestEcdsaTimer) {
  TestCallbacks cbs[2];

  // Successful operation with timer.
  CryptoMbPrivateKeyConnection op0(cbs[0], *dispatcher_, bssl::UpRef(pkey_), queue_);
  res_ = ecdsaPrivateKeySignForTest(&op0, nullptr, nullptr, max_out_len_,
                                    SSL_SIGN_ECDSA_SECP256R1_SHA256, in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_retry);

  res_ = privateKeyCompleteForTest(&op0, nullptr, nullptr, max_out_len_);
  // No processing done yet after first request
  EXPECT_EQ(res_, ssl_private_key_retry);

  time_system_.advanceTimeAndRun(std::chrono::seconds(1), *dispatcher_,
                                 Event::Dispatcher::RunType::NonBlock);

  res_ = privateKeyCompleteForTest(&op0, out_, &out_len_, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_success);
  EXPECT_NE(out_len_, 0);

  // Unsuccessful operation with timer.
  // Add crypto library errors
  fakeIpp_->injectErrors(true);

  CryptoMbPrivateKeyConnection op1(cbs[1], *dispatcher_, bssl::UpRef(pkey_), queue_);

  res_ = ecdsaPrivateKeySignForTest(&op1, nullptr, nullptr, max_out_len_,
                                    SSL_SIGN_ECDSA_SECP256R1_SHA256, in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_retry);

  res_ = privateKeyCompleteForTest(&op1, nullptr, nullptr, max_out_len_);
  // No processing done yet after first request
  EXPECT_EQ(res_, ssl_private_key_retry);

  time_system_.advanceTimeAndRun(std::chrono::seconds(1), *dispatcher_,
                                 Event::Dispatcher::RunType::NonBlock);

  res_ = privateKeyCompleteForTest(&op1, out_, &out_len_, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_failure);
}

TEST_F(CryptoMbProviderRsaTest, TestRsaTimer) {
  TestCallbacks cbs[2];

  // Successful operation with timer.
  CryptoMbPrivateKeyConnection op0(cbs[0], *dispatcher_, bssl::UpRef(pkey_), queue_);
  res_ = rsaPrivateKeySignForTest(&op0, nullptr, nullptr, max_out_len_, SSL_SIGN_RSA_PSS_SHA256,
                                  in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_retry);

  res_ = privateKeyCompleteForTest(&op0, nullptr, nullptr, max_out_len_);
  // No processing done yet after first request
  EXPECT_EQ(res_, ssl_private_key_retry);

  time_system_.advanceTimeAndRun(std::chrono::seconds(1), *dispatcher_,
                                 Event::Dispatcher::RunType::NonBlock);

  res_ = privateKeyCompleteForTest(&op0, out_, &out_len_, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_success);
  EXPECT_NE(out_len_, 0);

  // Unsuccessful operation with timer.
  // Add crypto library errors
  fakeIpp_->injectErrors(true);

  CryptoMbPrivateKeyConnection op1(cbs[1], *dispatcher_, bssl::UpRef(pkey_), queue_);

  res_ = rsaPrivateKeySignForTest(&op1, nullptr, nullptr, max_out_len_, SSL_SIGN_RSA_PSS_SHA256,
                                  in_, in_len_);
  EXPECT_EQ(res_, ssl_private_key_retry);

  res_ = privateKeyCompleteForTest(&op1, nullptr, nullptr, max_out_len_);
  // No processing done yet after first request
  EXPECT_EQ(res_, ssl_private_key_retry);

  time_system_.advanceTimeAndRun(std::chrono::seconds(1), *dispatcher_,
                                 Event::Dispatcher::RunType::NonBlock);

  res_ = privateKeyCompleteForTest(&op1, out_, &out_len_, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_failure);
}

TEST_F(CryptoMbProviderEcdsaTest, TestEcdsaQueueSizeStatistics) {
  // Initialize connections.
  TestCallbacks cbs[CryptoMbQueue::MULTIBUFF_BATCH];
  std::vector<std::unique_ptr<CryptoMbPrivateKeyConnection>> connections;
  for (auto& cb : cbs) {
    connections.push_back(std::make_unique<CryptoMbPrivateKeyConnection>(
        cb, *dispatcher_, bssl::UpRef(pkey_), queue_));
  }

  // Increment all but the last queue size once inside the loop.
  for (uint32_t i = 1; i < CryptoMbQueue::MULTIBUFF_BATCH; i++) {
    // Create correct amount of signing operations for current index.
    for (uint32_t j = 0; j < i; j++) {
      res_ = ecdsaPrivateKeySignForTest(connections[j].get(), nullptr, nullptr, max_out_len_,
                                        SSL_SIGN_ECDSA_SECP256R1_SHA256, in_, in_len_);
      EXPECT_EQ(res_, ssl_private_key_retry);
    }

    time_system_.advanceTimeAndRun(std::chrono::seconds(1), *dispatcher_,
                                   Event::Dispatcher::RunType::NonBlock);

    out_len_ = 0;
    res_ = privateKeyCompleteForTest(connections[0].get(), out_, &out_len_, max_out_len_);
    EXPECT_EQ(res_, ssl_private_key_success);
    EXPECT_NE(out_len_, 0);

    // Check that current queue size is recorded.
    std::vector<uint64_t> histogram_values(
        store_.histogramValues(queue_size_histogram_name_, true));
    EXPECT_EQ(histogram_values.size(), 1);
    EXPECT_EQ(histogram_values[0], i);
  }

  // Increment last queue size once.
  // Create an amount of signing operations equal to maximum queue size.
  for (uint32_t j = 0; j < CryptoMbQueue::MULTIBUFF_BATCH; j++) {
    res_ = ecdsaPrivateKeySignForTest(connections[j].get(), nullptr, nullptr, max_out_len_,
                                      SSL_SIGN_ECDSA_SECP256R1_SHA256, in_, in_len_);
    EXPECT_EQ(res_, ssl_private_key_retry);
  }

  // Timeout does not have to be triggered when queue is at maximum size.
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);

  out_len_ = 0;
  res_ = privateKeyCompleteForTest(connections[0].get(), out_, &out_len_, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_success);
  EXPECT_NE(out_len_, 0);

  // Check that last queue size is recorded.
  std::vector<uint64_t> histogram_values(store_.histogramValues(queue_size_histogram_name_, true));
  EXPECT_EQ(histogram_values.size(), 1);
  EXPECT_EQ(histogram_values[0], CryptoMbQueue::MULTIBUFF_BATCH);
}

TEST_F(CryptoMbProviderRsaTest, TestRsaQueueSizeStatistics) {
  // Initialize connections.
  TestCallbacks cbs[CryptoMbQueue::MULTIBUFF_BATCH];
  std::vector<std::unique_ptr<CryptoMbPrivateKeyConnection>> connections;
  for (auto& cb : cbs) {
    connections.push_back(std::make_unique<CryptoMbPrivateKeyConnection>(
        cb, *dispatcher_, bssl::UpRef(pkey_), queue_));
  }

  // Increment all but the last queue size once inside the loop.
  for (uint32_t i = 1; i < CryptoMbQueue::MULTIBUFF_BATCH; i++) {
    // Create correct amount of signing operations for current index.
    for (uint32_t j = 0; j < i; j++) {
      res_ = rsaPrivateKeySignForTest(connections[j].get(), nullptr, nullptr, max_out_len_,
                                      SSL_SIGN_RSA_PSS_SHA256, in_, in_len_);
      EXPECT_EQ(res_, ssl_private_key_retry);
    }

    time_system_.advanceTimeAndRun(std::chrono::seconds(1), *dispatcher_,
                                   Event::Dispatcher::RunType::NonBlock);

    out_len_ = 0;
    res_ = privateKeyCompleteForTest(connections[0].get(), out_, &out_len_, max_out_len_);
    EXPECT_EQ(res_, ssl_private_key_success);
    EXPECT_NE(out_len_, 0);

    // Check that current queue size is recorded.
    std::vector<uint64_t> histogram_values(
        store_.histogramValues(queue_size_histogram_name_, true));
    EXPECT_EQ(histogram_values.size(), 1);
    EXPECT_EQ(histogram_values[0], i);
  }

  // Increment last queue size once.
  // Create an amount of signing operations equal to maximum queue size.
  for (uint32_t j = 0; j < CryptoMbQueue::MULTIBUFF_BATCH; j++) {
    res_ = rsaPrivateKeySignForTest(connections[j].get(), nullptr, nullptr, max_out_len_,
                                    SSL_SIGN_RSA_PSS_SHA256, in_, in_len_);
    EXPECT_EQ(res_, ssl_private_key_retry);
  }

  // Timeout does not have to be triggered when queue is at maximum size.
  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);

  out_len_ = 0;
  res_ = privateKeyCompleteForTest(connections[0].get(), out_, &out_len_, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_success);
  EXPECT_NE(out_len_, 0);

  // Check that last queue size is recorded.
  std::vector<uint64_t> histogram_values(store_.histogramValues(queue_size_histogram_name_, true));
  EXPECT_EQ(histogram_values.size(), 1);
  EXPECT_EQ(histogram_values[0], CryptoMbQueue::MULTIBUFF_BATCH);
}

} // namespace
} // namespace CryptoMb
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_test",
    "envoy_cc_test_library",
    "envoy_contrib_package",
)
load(
    "//contrib:all_contrib_extensions.bzl",
    "envoy_contrib_linux_x86_64_constraints",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_test_library(
    name = "test_fake_factory",
    srcs = [
        "fake_factory.cc",
    ],
    hdrs = [
        "fake_factory.h",
    ],
    external_deps = ["ssl"],
    # This makes the test targets dependent on this target only run on the desired platform.
    # The actual feature is dependent on hardware but this mock library can run on other platforms.
    target_compatible_with = envoy_contrib_linux_x86_64_constraints(),
    deps = [
        "//contrib/cryptomb/private_key_providers/source:cryptomb_private_key_provider_lib",
        "//contrib/cryptomb/private_key_providers/source:ipp_crypto_wrapper_lib",
        "//envoy/api:api_interface",
        "//envoy/event:dispatcher_interface",
        "//envoy/server:transport_socket_config_interface",
        "//envoy/ssl/private_key:private_key_config_interface",
        "//envoy/ssl/private_key:private_key_interface",
        "//source/common/config:datasource_lib",
        "//source/common/config:utility_lib",
        "//source/common/protobuf:utility_lib",
        "@envoy_api//contrib/envoy/extensions/private_key_providers/cryptomb/v3alpha:pkg_cc_proto",
        "@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto",
    ],
)

envoy_cc_test(
    name = "config_test",
    srcs = [
        "config_test.cc",
    ],
    data = [
        "//contrib/cryptomb/private_key_providers/test/test_data:certs",
    ],
    deps = [
        ":test_fake_factory",
        "//source/common/common:random_generator_lib",
        "//source/extensions/transport_sockets/tls/private_key:private_key_manager_lib",
        "//test/mocks/runtime:runtime_mocks",
        "//test/mocks/server:server_mocks",
        "//test/mocks/ssl:ssl_mocks",
        "//test/mocks/stats:stats_mocks",
        "//test/mocks/thread_local:thread_local_mocks",
        "//test/test_common:environment_lib",
        "//test/test_common:registry_lib",
        "//test/test_common:simulated_time_system_lib",
        "//test/test_common:utility_lib",
    ],
)

envoy_cc_test(
    name = "ops_test",
    srcs = [
        "ops_test.cc",
    ],
    data = [
        "//contrib/cryptomb/private_key_providers/test/test_data:certs",
    ],
    deps = [
        ":test_fake_factory",
        "//source/extensions/transport_sockets/tls/private_key:private_key_manager_lib",
        "//test/mocks/stats:stats_mocks",
        "//test/test_common:environment_lib",
        "//test/test_common:simulated_time_system_lib",
        "//test/test_common:utility_lib",
    ],
)
#include "fake_factory.h"

#include <memory>

#include "envoy/registry/registry.h"
#include "envoy/server/transport_socket_config.h"

#include "source/common/config/datasource.h"
#include "source/common/config/utility.h"
#include "source/common/protobuf/message_validator_impl.h"
#include "source/common/protobuf/utility.h"

#include "contrib/cryptomb/private_key_providers/source/cryptomb_private_key_provider.h"
#include "contrib/envoy/extensions/private_key_providers/cryptomb/v3alpha/cryptomb.pb.h"
#include "contrib/envoy/extensions/private_key_providers/cryptomb/v3alpha/cryptomb.pb.validate.h"
#include "openssl/rsa.h"
#include "openssl/ssl.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace CryptoMb {

FakeIppCryptoImpl::FakeIppCryptoImpl(bool supported_instruction_set)
    : supported_instruction_set_(supported_instruction_set) {}

int FakeIppCryptoImpl::mbxIsCryptoMbApplicable(uint64_t) {
  return supported_instruction_set_ ? 1 : 0;
}

uint32_t FakeIppCryptoImpl::mbxSetSts(uint32_t status, unsigned req_num, bool success) {
  if (success) {
    // clear bit req_num
    return status & ~(1UL << req_num);
  }
  // set bit req_num
  return status | (1UL << req_num);
}

bool FakeIppCryptoImpl::mbxGetSts(uint32_t status, unsigned req_num) {
  // return true if bit req_num if not set
  return !((status >> req_num) & 1UL);
}

uint32_t FakeIppCryptoImpl::mbxNistp256EcdsaSignSslMb8(uint8_t* pa_sign_r[8], uint8_t* pa_sign_s[8],
                                                       const uint8_t* const pa_msg[8],
                                                       const BIGNUM* const pa_eph_skey[8],
                                                       const BIGNUM* const pa_reg_skey[8]) {

  uint32_t status = 0xff;

  for (int i = 0; i < 8; i++) {
    EC_KEY* key;
    ECDSA_SIG* sig;

    if (pa_eph_skey[i] == nullptr) {
      break;
    }

    key = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
    EC_KEY_set_private_key(key, pa_reg_skey[i]);

    // Length of the message representative is equal to length of r (order of EC subgroup).
    sig = ECDSA_do_sign(pa_msg[i], 32, key);

    BN_bn2bin(sig->r, pa_sign_r[i]);
    BN_bn2bin(sig->s, pa_sign_s[i]);

    ECDSA_SIG_free(sig);
    EC_KEY_free(key);

    status = mbxSetSts(status, i, !inject_errors_);
  }

  return status;
}

uint32_t FakeIppCryptoImpl::mbxRsaPrivateCrtSslMb8(
    const uint8_t* const from_pa[8], uint8_t* const to_pa[8], const BIGNUM* const p_pa[8],
    const BIGNUM* const q_pa[8], const BIGNUM* const dp_pa[8], const BIGNUM* const dq_pa[8],
    const BIGNUM* const iq_pa[8], int expected_rsa_bitsize) {

  uint32_t status = 0xff;

  for (int i = 0; i < 8; i++) {
    RSA* rsa;
    size_t out_len = 0;
    int ret;

    if (from_pa[i] == nullptr) {
      break;
    }

    rsa = RSA_new();

    RSA_set0_factors(rsa, BN_dup(p_pa[i]), BN_dup(q_pa[i]));
    RSA_set0_crt_params(rsa, BN_dup(dp_pa[i]), BN_dup(dq_pa[i]), BN_dup(iq_pa[i]));

    // The real `mbx_rsa_private_crt_ssl_mb8` doesn't require these parameters to
    // be set, but BoringSSL does. That's why they are provided out-of-band in
    // the factory initialization.
    RSA_set0_key(rsa, BN_dup(n_), BN_dup(e_), BN_dup(d_));

    // From the docs: "Memory buffers of the plain- and `ciphertext` must be `ceil(rsaBitlen/8)`
    // bytes length."
    ret = RSA_sign_raw(rsa, &out_len, to_pa[i], expected_rsa_bitsize / 8, from_pa[i],
                       expected_rsa_bitsize / 8, RSA_NO_PADDING);

    RSA_free(rsa);

    status = mbxSetSts(status, i, inject_errors_ ? !ret : ret);
  }

  return status;
}

uint32_t FakeIppCryptoImpl::mbxRsaPublicSslMb8(const uint8_t* const from_pa[8],
                                               uint8_t* const to_pa[8], const BIGNUM* const e_pa[8],
                                               const BIGNUM* const n_pa[8],
                                               int expected_rsa_bitsize) {
  uint32_t status = 0xff;

  for (int i = 0; i < 8; i++) {
    RSA* rsa;
    size_t out_len = 0;
    int ret;

    if (e_pa[i] == nullptr) {
      break;
    }

    rsa = RSA_new();

    RSA_set0_key(rsa, BN_dup(n_pa[i]), BN_dup(e_pa[i]), BN_dup(d_));

    ret = RSA_verify_raw(rsa, &out_len, to_pa[i], expected_rsa_bitsize / 8, from_pa[i],
                         expected_rsa_bitsize / 8, RSA_NO_PADDING);

    RSA_free(rsa);

    status = mbxSetSts(status, i, inject_errors_ ? !ret : ret);
  }

  return status;
}

FakeCryptoMbPrivateKeyMethodFactory::FakeCryptoMbPrivateKeyMethodFactory(
    bool supported_instruction_set)
    : supported_instruction_set_(supported_instruction_set) {}

Ssl::PrivateKeyMethodProviderSharedPtr
FakeCryptoMbPrivateKeyMethodFactory::createPrivateKeyMethodProviderInstance(
    const envoy::extensions::transport_sockets::tls::v3::PrivateKeyProvider& proto_config,
    Server::Configuration::TransportSocketFactoryContext& private_key_provider_context) {
  ProtobufTypes::MessagePtr message =
      std::make_unique<envoy::extensions::private_key_providers::cryptomb::v3alpha::
                           CryptoMbPrivateKeyMethodConfig>();

  Config::Utility::translateOpaqueConfig(proto_config.typed_config(),
                                         ProtobufMessage::getNullValidationVisitor(), *message);
  const envoy::extensions::private_key_providers::cryptomb::v3alpha::CryptoMbPrivateKeyMethodConfig
      conf =
          MessageUtil::downcastAndValidate<const envoy::extensions::private_key_providers::
                                               cryptomb::v3alpha::CryptoMbPrivateKeyMethodConfig&>(
              *message, private_key_provider_context.messageValidationVisitor());

  std::shared_ptr<FakeIppCryptoImpl> fakeIpp =
      std::make_shared<FakeIppCryptoImpl>(supported_instruction_set_);

  // We need to get more RSA key params in order to be able to use BoringSSL signing functions.
  std::string private_key = Config::DataSource::read(
      conf.private_key(), false, private_key_provider_context.serverFactoryContext().api());

  bssl::UniquePtr<BIO> bio(
      BIO_new_mem_buf(const_cast<char*>(private_key.data()), private_key.size()));

  bssl::UniquePtr<EVP_PKEY> pkey(PEM_read_bio_PrivateKey(bio.get(), nullptr, nullptr, nullptr));
  if (pkey != nullptr && EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA) {
    RSA* rsa = EVP_PKEY_get0_RSA(pkey.get());
    fakeIpp->setRsaKey(rsa);
  }

  IppCryptoSharedPtr ipp = std::dynamic_pointer_cast<IppCrypto>(fakeIpp);

  return std::make_shared<CryptoMbPrivateKeyMethodProvider>(conf, private_key_provider_context,
                                                            ipp);
}

} // namespace CryptoMb
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/extensions/transport_sockets/tls/v3/cert.pb.h"
#include "envoy/ssl/private_key/private_key.h"
#include "envoy/ssl/private_key/private_key_config.h"

#include "contrib/cryptomb/private_key_providers/source/ipp_crypto.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace CryptoMb {

class FakeIppCryptoImpl : public virtual IppCrypto {
public:
  FakeIppCryptoImpl(bool supported_instruction_set);

  int mbxIsCryptoMbApplicable(uint64_t features) override;
  uint32_t mbxNistp256EcdsaSignSslMb8(uint8_t* pa_sign_r[8], uint8_t* pa_sign_s[8],
                                      const uint8_t* const pa_msg[8],
                                      const BIGNUM* const pa_eph_skey[8],
                                      const BIGNUM* const pa_reg_skey[8]) override;
  uint32_t mbxRsaPrivateCrtSslMb8(const uint8_t* const from_pa[8], uint8_t* const to_pa[8],
                                  const BIGNUM* const p_pa[8], const BIGNUM* const q_pa[8],
                                  const BIGNUM* const dp_pa[8], const BIGNUM* const dq_pa[8],
                                  const BIGNUM* const iq_pa[8], int expected_rsa_bitsize) override;
  uint32_t mbxRsaPublicSslMb8(const uint8_t* const from_pa[8], uint8_t* const to_pa[8],
                              const BIGNUM* const e_pa[8], const BIGNUM* const n_pa[8],
                              int expected_rsa_bitsize) override;
  bool mbxGetSts(uint32_t status, unsigned req_num) override;

  void setRsaKey(RSA* rsa) { RSA_get0_key(rsa, &n_, &e_, &d_); };

  void injectErrors(bool enabled) { inject_errors_ = enabled; }

private:
  uint32_t mbxSetSts(uint32_t status, unsigned req_num, bool success);

  bool supported_instruction_set_;
  const BIGNUM* n_{};
  const BIGNUM* e_{};
  const BIGNUM* d_{};

  bool inject_errors_{};
};

class FakeCryptoMbPrivateKeyMethodFactory : public Ssl::PrivateKeyMethodProviderInstanceFactory {
public:
  FakeCryptoMbPrivateKeyMethodFactory(bool supported_instruction_set);

  // Ssl::PrivateKeyMethodProviderInstanceFactory
  Ssl::PrivateKeyMethodProviderSharedPtr createPrivateKeyMethodProviderInstance(
      const envoy::extensions::transport_sockets::tls::v3::PrivateKeyProvider& message,
      Server::Configuration::TransportSocketFactoryContext& private_key_provider_context) override;
  std::string name() const override { return "cryptomb"; };

private:
  bool supported_instruction_set_;
};

} // namespace CryptoMb
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#include "contrib/cryptomb/private_key_providers/source/cryptomb_stats.h"

#include "envoy/stats/scope.h"
#include "envoy/stats/stats_macros.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace CryptoMb {

CryptoMbStats generateCryptoMbStats(const std::string& prefix, Stats::Scope& scope) {
  return CryptoMbStats{ALL_CRYPTOMB_STATS(POOL_HISTOGRAM_PREFIX(scope, prefix))};
}

} // namespace CryptoMb
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/stats/scope.h"
#include "envoy/stats/stats_macros.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace CryptoMb {

#define ALL_CRYPTOMB_STATS(HISTOGRAM)                                                              \
  HISTOGRAM(ecdsa_queue_sizes, Unspecified)                                                        \
  HISTOGRAM(rsa_queue_sizes, Unspecified)

/**
 * CryptoMb stats struct definition. @see stats_macros.h
 */
struct CryptoMbStats {
  ALL_CRYPTOMB_STATS(GENERATE_HISTOGRAM_STRUCT)
};

CryptoMbStats generateCryptoMbStats(const std::string& prefix, Stats::Scope& scope);

} // namespace CryptoMb
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/extensions/transport_sockets/tls/v3/cert.pb.h"
#include "envoy/ssl/private_key/private_key.h"
#include "envoy/ssl/private_key/private_key_config.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace CryptoMb {

class CryptoMbPrivateKeyMethodFactory : public Ssl::PrivateKeyMethodProviderInstanceFactory,
                                        public Logger::Loggable<Logger::Id::connection> {
public:
  // Ssl::PrivateKeyMethodProviderInstanceFactory
  Ssl::PrivateKeyMethodProviderSharedPtr createPrivateKeyMethodProviderInstance(
      const envoy::extensions::transport_sockets::tls::v3::PrivateKeyProvider& message,
      Server::Configuration::TransportSocketFactoryContext& private_key_provider_context) override;
  std::string name() const override { return "cryptomb"; };
};

} // namespace CryptoMb
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/api/api.h"
#include "envoy/event/dispatcher.h"
#include "envoy/ssl/private_key/private_key.h"
#include "envoy/ssl/private_key/private_key_config.h"
#include "envoy/thread_local/thread_local.h"

#include "source/common/common/c_smart_ptr.h"
#include "source/common/common/logger.h"

#include "contrib/cryptomb/private_key_providers/source/cryptomb_stats.h"
#include "contrib/cryptomb/private_key_providers/source/ipp_crypto.h"
#include "contrib/envoy/extensions/private_key_providers/cryptomb/v3alpha/cryptomb.pb.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace CryptoMb {

namespace {
void dontFreeBN(const BIGNUM*) {}
} // namespace
using BIGNUMConstPtr = CSmartPtr<const BIGNUM, dontFreeBN>;

enum class RequestStatus { Retry, Success, Error };
enum class KeyType { Rsa, Ec };

// CryptoMbContext holds the actual data to be signed or encrypted. It also has a
// reference to the worker thread dispatcher for communicating that it has
// has ran the `AVX-512` code and the result is ready to be used.
class CryptoMbContext {
public:
  static constexpr ssize_t MAX_SIGNATURE_SIZE = 512;

  CryptoMbContext(Event::Dispatcher& dispatcher, Ssl::PrivateKeyConnectionCallbacks& cb);
  virtual ~CryptoMbContext() = default;

  void setStatus(RequestStatus status) { status_ = status; }
  enum RequestStatus getStatus() { return status_; }
  void scheduleCallback(enum RequestStatus status);

  // Buffer length is the same as the max signature length (4096 bits = 512 bytes)
  unsigned char out_buf_[MAX_SIGNATURE_SIZE];
  // The real length of the signature.
  size_t out_len_{};
  // Incoming data buffer.
  std::unique_ptr<uint8_t[]> in_buf_;

private:
  // Whether the decryption / signing is ready.
  enum RequestStatus status_ {};

  Event::Dispatcher& dispatcher_;
  Ssl::PrivateKeyConnectionCallbacks& cb_;
  // For scheduling the callback to the next dispatcher cycle.
  Event::SchedulableCallbackPtr schedulable_{};
};

// CryptoMbEcdsaContext is a CryptoMbContext which holds the extra ECDSA parameters and has
// custom initialization function.
class CryptoMbEcdsaContext : public CryptoMbContext {
public:
  CryptoMbEcdsaContext(bssl::UniquePtr<EC_KEY> ec_key, Event::Dispatcher& dispatcher,
                       Ssl::PrivateKeyConnectionCallbacks& cb)
      : CryptoMbContext(dispatcher, cb), ec_key_(std::move(ec_key)) {}
  bool ecdsaInit(const uint8_t* in, size_t in_len);

  // ECDSA key.
  bssl::UniquePtr<EC_KEY> ec_key_{};
  // ECDSA context to create the ephemeral key k_.
  bssl::UniquePtr<BN_CTX> ctx_{};
  BIGNUM* k_{};
  // ECDSA parameters, which will contain values whose memory is managed within
  // BoringSSL ECDSA key structure, so not wrapped in smart pointers.
  const BIGNUM* priv_key_{};
  size_t sig_len_{};
};

// CryptoMbRsaContext is a CryptoMbContext which holds the extra RSA parameters and has
// custom initialization function. It also has a separate buffer for RSA result
// verification.
class CryptoMbRsaContext : public CryptoMbContext {
public:
  CryptoMbRsaContext(bssl::UniquePtr<EVP_PKEY> pkey, Event::Dispatcher& dispatcher,
                     Ssl::PrivateKeyConnectionCallbacks& cb)
      : CryptoMbContext(dispatcher, cb), rsa_(EVP_PKEY_get1_RSA(pkey.get())) {}
  bool rsaInit(const uint8_t* in, size_t in_len);

  // RSA key.
  bssl::UniquePtr<RSA> rsa_{};
  // RSA parameters. Const pointers, which will contain values whose memory is
  // managed within BoringSSL RSA key structure, so not wrapped in smart
  // pointers.
  const BIGNUM* d_{};
  const BIGNUM* e_{};
  const BIGNUM* n_{};
  const BIGNUM* p_{};
  const BIGNUM* q_{};
  const BIGNUM* dmp1_{};
  const BIGNUM* dmq1_{};
  const BIGNUM* iqmp_{};

  // Buffer for `Lenstra` check.
  unsigned char lenstra_to_[MAX_SIGNATURE_SIZE];
};

using CryptoMbContextSharedPtr = std::shared_ptr<CryptoMbContext>;
using CryptoMbEcdsaContextSharedPtr = std::shared_ptr<CryptoMbEcdsaContext>;
using CryptoMbRsaContextSharedPtr = std::shared_ptr<CryptoMbRsaContext>;

// CryptoMbQueue maintains the request queue and is able to process it.
class CryptoMbQueue : public Logger::Loggable<Logger::Id::connection> {
public:
  static constexpr uint32_t MULTIBUFF_BATCH = 8;

  CryptoMbQueue(std::chrono::milliseconds poll_delay, enum KeyType type, int keysize,
                IppCryptoSharedPtr ipp, Event::Dispatcher& d, CryptoMbStats& stats);
  void addAndProcessEightRequests(CryptoMbContextSharedPtr mb_ctx);
  const std::chrono::microseconds& getPollDelayForTest() const { return us_; }

private:
  void processRequests();
  void processRsaRequests();
  void processEcdsaRequests();
  bool postprocessEcdsaRequest(CryptoMbEcdsaContextSharedPtr mb_ctx, const uint8_t* sign_r,
                               const uint8_t* sign_s);
  void startTimer();
  void stopTimer();

  // Polling delay.
  std::chrono::microseconds us_{};

  // Queue for the requests.
  std::vector<CryptoMbContextSharedPtr> request_queue_;

  // Key size and key type allowed for this particular queue.
  const enum KeyType type_;
  int key_size_{};

  // Thread local data slot.
  ThreadLocal::SlotPtr slot_{};

  // Crypto operations library interface.
  IppCryptoSharedPtr ipp_{};

  // Timer to trigger queue processing if eight requests are not received in time.
  Event::TimerPtr timer_{};

  CryptoMbStats& stats_;
};

// CryptoMbPrivateKeyConnection maintains the data needed by a given SSL
// connection.
class CryptoMbPrivateKeyConnection : public Logger::Loggable<Logger::Id::connection> {
public:
  CryptoMbPrivateKeyConnection(Ssl::PrivateKeyConnectionCallbacks& cb,
                               Event::Dispatcher& dispatcher, bssl::UniquePtr<EVP_PKEY> pkey,
                               CryptoMbQueue& queue);
  virtual ~CryptoMbPrivateKeyConnection() = default;

  bssl::UniquePtr<EVP_PKEY> getPrivateKey() { return bssl::UpRef(pkey_); };
  void logDebugMsg(std::string msg) { ENVOY_LOG(debug, "CryptoMb: {}", msg); }
  void logWarnMsg(std::string msg) { ENVOY_LOG(warn, "CryptoMb: {}", msg); }
  void addToQueue(CryptoMbContextSharedPtr mb_ctx);

  CryptoMbQueue& queue_;
  Event::Dispatcher& dispatcher_;
  Ssl::PrivateKeyConnectionCallbacks& cb_;
  CryptoMbContextSharedPtr mb_ctx_{};

private:
  Event::FileEventPtr ssl_async_event_{};
  bssl::UniquePtr<EVP_PKEY> pkey_;
};

// CryptoMbPrivateKeyMethodProvider handles the private key method operations for
// an SSL socket.
class CryptoMbPrivateKeyMethodProvider : public virtual Ssl::PrivateKeyMethodProvider,
                                         public Logger::Loggable<Logger::Id::connection> {
public:
  CryptoMbPrivateKeyMethodProvider(
      const envoy::extensions::private_key_providers::cryptomb::v3alpha::
          CryptoMbPrivateKeyMethodConfig& config,
      Server::Configuration::TransportSocketFactoryContext& private_key_provider_context,
      IppCryptoSharedPtr ipp);

  // Ssl::PrivateKeyMethodProvider
  void registerPrivateKeyMethod(SSL* ssl, Ssl::PrivateKeyConnectionCallbacks& cb,
                                Event::Dispatcher& dispatcher) override;
  void unregisterPrivateKeyMethod(SSL* ssl) override;
  bool checkFips() override;
  bool isAvailable() override;
  Ssl::BoringSslPrivateKeyMethodSharedPtr getBoringSslPrivateKeyMethod() override;

  static int connectionIndex();

  const std::chrono::microseconds& getPollDelayForTest() const {
    return tls_->get()->queue_.getPollDelayForTest();
  }

private:
  // Thread local data containing a single queue per worker thread.
  struct ThreadLocalData : public ThreadLocal::ThreadLocalObject {
    ThreadLocalData(std::chrono::milliseconds poll_delay, enum KeyType type, int keysize,
                    IppCryptoSharedPtr ipp, Event::Dispatcher& d, CryptoMbStats& stats)
        : queue_(poll_delay, type, keysize, ipp, d, stats){};
    CryptoMbQueue queue_;
  };

  Ssl::BoringSslPrivateKeyMethodSharedPtr method_{};
  Api::Api& api_;
  bssl::UniquePtr<EVP_PKEY> pkey_;
  enum KeyType key_type_;

  ThreadLocal::TypedSlotPtr<ThreadLocalData> tls_;

  CryptoMbStats stats_;

  bool initialized_{};
};

} // namespace CryptoMb
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/common/pure.h"

#include "openssl/ssl.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace CryptoMb {

class IppCrypto {
public:
  virtual ~IppCrypto() = default;

  virtual int mbxIsCryptoMbApplicable(uint64_t features) PURE;
  virtual uint32_t mbxNistp256EcdsaSignSslMb8(uint8_t* pa_sign_r[8], uint8_t* pa_sign_s[8],
                                              const uint8_t* const pa_msg[8],
                                              const BIGNUM* const pa_eph_skey[8],
                                              const BIGNUM* const pa_reg_skey[8]) PURE;
  virtual uint32_t mbxRsaPrivateCrtSslMb8(const uint8_t* const from_pa[8], uint8_t* const to_pa[8],
                                          const BIGNUM* const p_pa[8], const BIGNUM* const q_pa[8],
                                          const BIGNUM* const dp_pa[8],
                                          const BIGNUM* const dq_pa[8],
                                          const BIGNUM* const iq_pa[8],
                                          int expected_rsa_bitsize) PURE;
  virtual uint32_t mbxRsaPublicSslMb8(const uint8_t* const from_pa[8], uint8_t* const to_pa[8],
                                      const BIGNUM* const e_pa[8], const BIGNUM* const n_pa[8],
                                      int expected_rsa_bitsize) PURE;
  virtual bool mbxGetSts(uint32_t status, unsigned req_num) PURE;
};

using IppCryptoSharedPtr = std::shared_ptr<IppCrypto>;

} // namespace CryptoMb
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "contrib/cryptomb/private_key_providers/source/ipp_crypto.h"
#include "crypto_mb/cpu_features.h"
#include "crypto_mb/ec_nistp256.h"
#include "crypto_mb/rsa.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace CryptoMb {

class IppCryptoImpl : public virtual IppCrypto {
public:
  int mbxIsCryptoMbApplicable(uint64_t features) override {
    return ::mbx_is_crypto_mb_applicable(features);
  }
  uint32_t mbxNistp256EcdsaSignSslMb8(uint8_t* pa_sign_r[8], uint8_t* pa_sign_s[8],
                                      const uint8_t* const pa_msg[8],
                                      const BIGNUM* const pa_eph_skey[8],
                                      const BIGNUM* const pa_reg_skey[8]) override {
    return ::mbx_nistp256_ecdsa_sign_ssl_mb8(pa_sign_r, pa_sign_s, pa_msg, pa_eph_skey, pa_reg_skey,
                                             nullptr);
  }
  uint32_t mbxRsaPrivateCrtSslMb8(const uint8_t* const from_pa[8], uint8_t* const to_pa[8],
                                  const BIGNUM* const p_pa[8], const BIGNUM* const q_pa[8],
                                  const BIGNUM* const dp_pa[8], const BIGNUM* const dq_pa[8],
                                  const BIGNUM* const iq_pa[8], int expected_rsa_bitsize) override {
    return ::mbx_rsa_private_crt_ssl_mb8(from_pa, to_pa, p_pa, q_pa, dp_pa, dq_pa, iq_pa,
                                         expected_rsa_bitsize);
  }
  uint32_t mbxRsaPublicSslMb8(const uint8_t* const from_pa[8], uint8_t* const to_pa[8],
                              const BIGNUM* const e_pa[8], const BIGNUM* const n_pa[8],
                              int expected_rsa_bitsize) override {
    return ::mbx_rsa_public_ssl_mb8(from_pa, to_pa, e_pa, n_pa, expected_rsa_bitsize);
  }
  bool mbxGetSts(uint32_t status, unsigned req_num) override {
    if (MBX_GET_STS(status, req_num) == MBX_STATUS_OK) {
      return true;
    }
    return false;
  };
};

} // namespace CryptoMb
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#include "contrib/cryptomb/private_key_providers/source/cryptomb_private_key_provider.h"

#include <memory>

#include "envoy/registry/registry.h"
#include "envoy/server/transport_socket_config.h"

#include "source/common/config/datasource.h"

#include "openssl/ssl.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace CryptoMb {

CryptoMbContext::CryptoMbContext(Event::Dispatcher& dispatcher,
                                 Ssl::PrivateKeyConnectionCallbacks& cb)
    : status_(RequestStatus::Retry), dispatcher_(dispatcher), cb_(cb) {}

void CryptoMbContext::scheduleCallback(enum RequestStatus status) {
  schedulable_ = dispatcher_.createSchedulableCallback([this, status]() {
    // The status can't be set beforehand, because the callback asserts
    // if someone else races to call doHandshake() and the status goes to
    // HandshakeComplete.
    setStatus(status);
    this->cb_.onPrivateKeyMethodComplete();
  });
  schedulable_->scheduleCallbackNextIteration();
}

bool CryptoMbEcdsaContext::ecdsaInit(const uint8_t* in, size_t in_len) {
  if (ec_key_ == nullptr) {
    return false;
  }

  const EC_GROUP* group = EC_KEY_get0_group(ec_key_.get());
  priv_key_ = EC_KEY_get0_private_key(ec_key_.get());
  if (group == nullptr || priv_key_ == nullptr) {
    return false;
  }

  const BIGNUM* order = EC_GROUP_get0_order(group);
  if (order == nullptr) {
    return false;
  }

  // Create an ephemeral key.
  ctx_ = bssl::UniquePtr<BN_CTX>(BN_CTX_new());
  if (ctx_ == nullptr) {
    return false;
  }
  BN_CTX_start(ctx_.get());
  k_ = BN_CTX_get(ctx_.get());
  if (!k_) {
    return false;
  }
  do {
    if (!BN_rand_range(k_, order)) {
      return false;
    }
  } while (BN_is_zero(k_));

  // Extent with zero paddings as CryptoMB expects in_buf_ being sign length.
  int len = BN_num_bits(order);
  size_t buf_len = (len + 7) / 8;
  if (8 * in_len < static_cast<unsigned long>(len)) {
    in_buf_ = std::make_unique<uint8_t[]>(buf_len);
    memcpy(in_buf_.get() + buf_len - in_len, in, in_len); // NOLINT(safe-memcpy)
  } else {
    in_buf_ = std::make_unique<uint8_t[]>(in_len);
    memcpy(in_buf_.get(), in, in_len); // NOLINT(safe-memcpy)
  }

  sig_len_ = ECDSA_size(ec_key_.get());
  if (sig_len_ > MAX_SIGNATURE_SIZE) {
    return false;
  }

  return true;
}

bool CryptoMbRsaContext::rsaInit(const uint8_t* in, size_t in_len) {
  if (rsa_ == nullptr) {
    return false;
  }

  // Initialize the values with the RSA key.
  size_t in_buf_size = in_len;
  out_len_ = RSA_size(rsa_.get());

  if (out_len_ > in_buf_size) {
    in_buf_size = out_len_;
  }

  RSA_get0_key(rsa_.get(), &n_, &e_, &d_);
  RSA_get0_factors(rsa_.get(), &p_, &q_);
  RSA_get0_crt_params(rsa_.get(), &dmp1_, &dmq1_, &iqmp_);

  if (p_ == nullptr || q_ == nullptr || dmp1_ == nullptr || dmq1_ == nullptr || iqmp_ == nullptr) {
    return false;
  }

  in_buf_ = std::make_unique<uint8_t[]>(in_buf_size);
  memcpy(in_buf_.get(), in, in_len); // NOLINT(safe-memcpy)

  return true;
}

namespace {

int calculateDigest(const EVP_MD* md, const uint8_t* in, size_t in_len, unsigned char* hash,
                    unsigned int* hash_len) {
  bssl::ScopedEVP_MD_CTX ctx;

  // Calculate the message digest for signing.
  if (!EVP_DigestInit_ex(ctx.get(), md, nullptr) || !EVP_DigestUpdate(ctx.get(), in, in_len) ||
      !EVP_DigestFinal_ex(ctx.get(), hash, hash_len)) {
    return 0;
  }
  return 1;
}

ssl_private_key_result_t ecdsaPrivateKeySignInternal(CryptoMbPrivateKeyConnection* ops, uint8_t*,
                                                     size_t*, size_t, uint16_t signature_algorithm,
                                                     const uint8_t* in, size_t in_len) {
  unsigned char hash[EVP_MAX_MD_SIZE];
  unsigned int hash_len;

  if (ops == nullptr) {
    return ssl_private_key_failure;
  }

  const EVP_MD* md = SSL_get_signature_algorithm_digest(signature_algorithm);
  if (md == nullptr) {
    return ssl_private_key_failure;
  }

  if (!calculateDigest(md, in, in_len, hash, &hash_len)) {
    return ssl_private_key_failure;
  }

  bssl::UniquePtr<EVP_PKEY> pkey = ops->getPrivateKey();
  if (pkey == nullptr) {
    return ssl_private_key_failure;
  }

  if (EVP_PKEY_id(pkey.get()) != SSL_get_signature_algorithm_key_type(signature_algorithm)) {
    return ssl_private_key_failure;
  }

  bssl::UniquePtr<EC_KEY> ec_key(EVP_PKEY_get1_EC_KEY(pkey.get()));
  if (ec_key == nullptr) {
    return ssl_private_key_failure;
  }

  // Create MB context which will be used for this particular
  // signing/decryption.
  CryptoMbEcdsaContextSharedPtr mb_ctx =
      std::make_shared<CryptoMbEcdsaContext>(std::move(ec_key), ops->dispatcher_, ops->cb_);

  if (!mb_ctx->ecdsaInit(hash, hash_len)) {
    return ssl_private_key_failure;
  }

  ops->addToQueue(mb_ctx);
  return ssl_private_key_retry;
}

ssl_private_key_result_t ecdsaPrivateKeySign(SSL* ssl, uint8_t* out, size_t* out_len,
                                             size_t max_out, uint16_t signature_algorithm,
                                             const uint8_t* in, size_t in_len) {
  return ssl == nullptr ? ssl_private_key_failure
                        : ecdsaPrivateKeySignInternal(
                              static_cast<CryptoMbPrivateKeyConnection*>(SSL_get_ex_data(
                                  ssl, CryptoMbPrivateKeyMethodProvider::connectionIndex())),
                              out, out_len, max_out, signature_algorithm, in, in_len);
}

ssl_private_key_result_t ecdsaPrivateKeyDecrypt(SSL*, uint8_t*, size_t*, size_t, const uint8_t*,
                                                size_t) {
  // Expecting to get only signing requests.
  return ssl_private_key_failure;
}

ssl_private_key_result_t rsaPrivateKeySignInternal(CryptoMbPrivateKeyConnection* ops, uint8_t*,
                                                   size_t*, size_t, uint16_t signature_algorithm,
                                                   const uint8_t* in, size_t in_len) {

  ssl_private_key_result_t status = ssl_private_key_failure;
  if (ops == nullptr) {
    return status;
  }

  bssl::UniquePtr<EVP_PKEY> pkey = ops->getPrivateKey();

  // Check if the SSL instance has correct data attached to it.
  if (EVP_PKEY_id(pkey.get()) != SSL_get_signature_algorithm_key_type(signature_algorithm)) {
    return status;
  }

  bssl::UniquePtr<RSA> rsa(EVP_PKEY_get1_RSA(pkey.get()));
  if (rsa == nullptr) {
    return status;
  }

  const EVP_MD* md = SSL_get_signature_algorithm_digest(signature_algorithm);
  if (md == nullptr) {
    return status;
  }

  unsigned char hash[EVP_MAX_MD_SIZE];
  unsigned int hash_len;
  if (!calculateDigest(md, in, in_len, hash, &hash_len)) {
    return status;
  }

  uint8_t* msg;
  size_t msg_len;

  // Add RSA padding to the the hash. `PSS` and `PKCS#1` v1.5 padding schemes are supported.
  if (SSL_is_signature_algorithm_rsa_pss(signature_algorithm)) {
    msg_len = RSA_size(rsa.get());
    msg = static_cast<uint8_t*>(OPENSSL_malloc(msg_len));
    if (msg == nullptr) {
      return status;
    }

    if (!RSA_padding_add_PKCS1_PSS_mgf1(rsa.get(), msg, hash, md, nullptr, -1)) {
      OPENSSL_free(msg);
      return status;
    }
  } else {
    // PKCS#1 1.5
    int prefix_allocated = 0;
    if (!RSA_add_pkcs1_prefix(&msg, &msg_len, &prefix_allocated, EVP_MD_type(md), hash, hash_len)) {
      if (prefix_allocated) {
        OPENSSL_free(msg);
      }
      return status;
    }

    // RFC 8017 section 9.2

    unsigned long rsa_len = RSA_size(rsa.get());
    // Header is 3 bytes, padding is min 8 bytes
    unsigned long header_len = 3;
    unsigned long padding_len = rsa_len - msg_len - header_len;

    if (padding_len < 8) {
      OPENSSL_free(msg);
      return status;
    }

    uint8_t* full_msg = static_cast<uint8_t*>(OPENSSL_malloc(rsa_len));
    if (full_msg == nullptr) {
      if (prefix_allocated) {
        OPENSSL_free(msg);
      }
      return status;
    }

    int idx = 0;
    full_msg[idx++] = 0x0;                     // first header byte
    full_msg[idx++] = 0x1;                     // second header byte
    memset(full_msg + idx, 0xff, padding_len); // padding
    idx += padding_len;
    full_msg[idx++] = 0x0;                // third header byte
    memcpy(full_msg + idx, msg, msg_len); // NOLINT(safe-memcpy)

    if (prefix_allocated) {
      OPENSSL_free(msg);
    }

    msg = full_msg;
    msg_len = rsa_len;
  }

  // Create MB context which will be used for this particular
  // signing/decryption.
  CryptoMbRsaContextSharedPtr mb_ctx =
      std::make_shared<CryptoMbRsaContext>(std::move(pkey), ops->dispatcher_, ops->cb_);

  if (!mb_ctx->rsaInit(msg, msg_len)) {
    OPENSSL_free(msg);
    return status;
  }

  ops->addToQueue(mb_ctx);
  status = ssl_private_key_retry;
  OPENSSL_free(msg);
  return status;
}

ssl_private_key_result_t rsaPrivateKeySign(SSL* ssl, uint8_t* out, size_t* out_len, size_t max_out,
                                           uint16_t signature_algorithm, const uint8_t* in,
                                           size_t in_len) {
  return ssl == nullptr ? ssl_private_key_failure
                        : rsaPrivateKeySignInternal(
                              static_cast<CryptoMbPrivateKeyConnection*>(SSL_get_ex_data(
                                  ssl, CryptoMbPrivateKeyMethodProvider::connectionIndex())),
                              out, out_len, max_out, signature_algorithm, in, in_len);
}

ssl_private_key_result_t rsaPrivateKeyDecryptInternal(CryptoMbPrivateKeyConnection* ops, uint8_t*,
                                                      size_t*, size_t, const uint8_t* in,
                                                      size_t in_len) {

  if (ops == nullptr) {
    return ssl_private_key_failure;
  }

  bssl::UniquePtr<EVP_PKEY> pkey = ops->getPrivateKey();

  // Check if the SSL instance has correct data attached to it.
  if (pkey == nullptr) {
    return ssl_private_key_failure;
  }

  CryptoMbRsaContextSharedPtr mb_ctx =
      std::make_shared<CryptoMbRsaContext>(std::move(pkey), ops->dispatcher_, ops->cb_);

  if (!mb_ctx->rsaInit(in, in_len)) {
    return ssl_private_key_failure;
  }

  ops->addToQueue(mb_ctx);
  return ssl_private_key_retry;
}

ssl_private_key_result_t rsaPrivateKeyDecrypt(SSL* ssl, uint8_t* out, size_t* out_len,
                                              size_t max_out, const uint8_t* in, size_t in_len) {
  return ssl == nullptr ? ssl_private_key_failure
                        : rsaPrivateKeyDecryptInternal(
                              static_cast<CryptoMbPrivateKeyConnection*>(SSL_get_ex_data(
                                  ssl, CryptoMbPrivateKeyMethodProvider::connectionIndex())),
                              out, out_len, max_out, in, in_len);
}

ssl_private_key_result_t privateKeyCompleteInternal(CryptoMbPrivateKeyConnection* ops, uint8_t* out,
                                                    size_t* out_len, size_t max_out) {
  if (ops == nullptr) {
    return ssl_private_key_failure;
  }

  // Check if the MB operation is ready yet. This can happen if someone calls
  // the top-level SSL function too early. The op status is only set from this
  // thread.
  if (ops->mb_ctx_->getStatus() == RequestStatus::Retry) {
    return ssl_private_key_retry;
  }

  // If this point is reached, the MB processing must be complete.

  // See if the operation failed.
  if (ops->mb_ctx_->getStatus() != RequestStatus::Success) {
    ops->logWarnMsg("private key operation failed.");
    return ssl_private_key_failure;
  }

  *out_len = ops->mb_ctx_->out_len_;

  if (*out_len > max_out) {
    return ssl_private_key_failure;
  }

  memcpy(out, ops->mb_ctx_->out_buf_, *out_len); // NOLINT(safe-memcpy)

  return ssl_private_key_success;
}

ssl_private_key_result_t privateKeyComplete(SSL* ssl, uint8_t* out, size_t* out_len,
                                            size_t max_out) {
  return ssl == nullptr ? ssl_private_key_failure
                        : privateKeyCompleteInternal(
                              static_cast<CryptoMbPrivateKeyConnection*>(SSL_get_ex_data(
                                  ssl, CryptoMbPrivateKeyMethodProvider::connectionIndex())),
                              out, out_len, max_out);
}

} // namespace

// External linking, meant for testing without SSL context.
ssl_private_key_result_t privateKeyCompleteForTest(CryptoMbPrivateKeyConnection* ops, uint8_t* out,
                                                   size_t* out_len, size_t max_out) {
  return privateKeyCompleteInternal(ops, out, out_len, max_out);
}
ssl_private_key_result_t ecdsaPrivateKeySignForTest(CryptoMbPrivateKeyConnection* ops, uint8_t* out,
                                                    size_t* out_len, size_t max_out,
                                                    uint16_t signature_algorithm, const uint8_t* in,
                                                    size_t in_len) {
  return ecdsaPrivateKeySignInternal(ops, out, out_len, max_out, signature_algorithm, in, in_len);
}
ssl_private_key_result_t rsaPrivateKeySignForTest(CryptoMbPrivateKeyConnection* ops, uint8_t* out,
                                                  size_t* out_len, size_t max_out,
                                                  uint16_t signature_algorithm, const uint8_t* in,
                                                  size_t in_len) {
  return rsaPrivateKeySignInternal(ops, out, out_len, max_out, signature_algorithm, in, in_len);
}
ssl_private_key_result_t rsaPrivateKeyDecryptForTest(CryptoMbPrivateKeyConnection* ops,
                                                     uint8_t* out, size_t* out_len, size_t max_out,
                                                     const uint8_t* in, size_t in_len) {
  return rsaPrivateKeyDecryptInternal(ops, out, out_len, max_out, in, in_len);
}

CryptoMbQueue::CryptoMbQueue(std::chrono::milliseconds poll_delay, enum KeyType type, int keysize,
                             IppCryptoSharedPtr ipp, Event::Dispatcher& d, CryptoMbStats& stats)
    : us_(std::chrono::duration_cast<std::chrono::microseconds>(poll_delay)), type_(type),
      key_size_(keysize), ipp_(ipp), timer_(d.createTimer([this]() { processRequests(); })),
      stats_(stats) {
  request_queue_.reserve(MULTIBUFF_BATCH);
}

void CryptoMbQueue::startTimer() { timer_->enableHRTimer(us_); }

void CryptoMbQueue::stopTimer() { timer_->disableTimer(); }

void CryptoMbQueue::addAndProcessEightRequests(CryptoMbContextSharedPtr mb_ctx) {
  // Add the request to the processing queue.
  ASSERT(request_queue_.size() < MULTIBUFF_BATCH);
  request_queue_.push_back(mb_ctx);

  if (request_queue_.size() == MULTIBUFF_BATCH) {
    // There are eight requests in the queue and we can process them.
    stopTimer();
    ENVOY_LOG(debug, "processing directly 8 requests");
    processRequests();
  } else if (request_queue_.size() == 1) {
    // First request in the queue, start the queue timer.
    startTimer();
  }
}

void CryptoMbQueue::processRequests() {
  switch (type_) {
  case KeyType::Rsa:
    // Record queue size statistic value for histogram.
    stats_.rsa_queue_sizes_.recordValue(request_queue_.size());
    processRsaRequests();
    break;
  case KeyType::Ec:
    // Record queue size statistic value for histogram.
    stats_.ecdsa_queue_sizes_.recordValue(request_queue_.size());
    processEcdsaRequests();
  }
  request_queue_.clear();
}

void CryptoMbQueue::processRsaRequests() {

  const unsigned char* rsa_priv_from[MULTIBUFF_BATCH] = {nullptr};
  unsigned char* rsa_priv_to[MULTIBUFF_BATCH] = {nullptr};
  const BIGNUM* rsa_lenstra_e[MULTIBUFF_BATCH] = {nullptr};
  const BIGNUM* rsa_lenstra_n[MULTIBUFF_BATCH] = {nullptr};
  const BIGNUM* rsa_priv_p[MULTIBUFF_BATCH] = {nullptr};
  const BIGNUM* rsa_priv_q[MULTIBUFF_BATCH] = {nullptr};
  const BIGNUM* rsa_priv_dmp1[MULTIBUFF_BATCH] = {nullptr};
  const BIGNUM* rsa_priv_dmq1[MULTIBUFF_BATCH] = {nullptr};
  const BIGNUM* rsa_priv_iqmp[MULTIBUFF_BATCH] = {nullptr};

  /* Build arrays of pointers for call */
  for (unsigned req_num = 0; req_num < request_queue_.size(); req_num++) {
    CryptoMbRsaContextSharedPtr mb_ctx =
        std::static_pointer_cast<CryptoMbRsaContext>(request_queue_[req_num]);
    rsa_priv_from[req_num] = mb_ctx->in_buf_.get();
    rsa_priv_to[req_num] = mb_ctx->out_buf_;
    rsa_priv_p[req_num] = mb_ctx->p_;
    rsa_priv_q[req_num] = mb_ctx->q_;
    rsa_priv_dmp1[req_num] = mb_ctx->dmp1_;
    rsa_priv_dmq1[req_num] = mb_ctx->dmq1_;
    rsa_priv_iqmp[req_num] = mb_ctx->iqmp_;
  }

  ENVOY_LOG(debug, "Multibuffer RSA process {} requests", request_queue_.size());

  uint32_t rsa_sts =
      ipp_->mbxRsaPrivateCrtSslMb8(rsa_priv_from, rsa_priv_to, rsa_priv_p, rsa_priv_q,
                                   rsa_priv_dmp1, rsa_priv_dmq1, rsa_priv_iqmp, key_size_);

  enum RequestStatus status[MULTIBUFF_BATCH] = {RequestStatus::Retry};

  for (unsigned req_num = 0; req_num < request_queue_.size(); req_num++) {
    CryptoMbRsaContextSharedPtr mb_ctx =
        std::static_pointer_cast<CryptoMbRsaContext>(request_queue_[req_num]);
    if (ipp_->mbxGetSts(rsa_sts, req_num)) {
      ENVOY_LOG(debug, "Multibuffer RSA request {} success", req_num);
      status[req_num] = RequestStatus::Success;
    } else {
      ENVOY_LOG(debug, "Multibuffer RSA request {} failure", req_num);
      status[req_num] = RequestStatus::Error;
    }

    // `Lenstra` check (validate that we get the same result back).
    rsa_priv_from[req_num] = rsa_priv_to[req_num];
    rsa_priv_to[req_num] = mb_ctx->lenstra_to_;
    rsa_lenstra_e[req_num] = mb_ctx->e_;
    rsa_lenstra_n[req_num] = mb_ctx->n_;
  }

  rsa_sts =
      ipp_->mbxRsaPublicSslMb8(rsa_priv_from, rsa_priv_to, rsa_lenstra_e, rsa_lenstra_n, key_size_);

  for (unsigned req_num = 0; req_num < request_queue_.size(); req_num++) {
    CryptoMbRsaContextSharedPtr mb_ctx =
        std::static_pointer_cast<CryptoMbRsaContext>(request_queue_[req_num]);
    enum RequestStatus ctx_status;
    if (ipp_->mbxGetSts(rsa_sts, req_num)) {
      if (CRYPTO_memcmp(mb_ctx->in_buf_.get(), rsa_priv_to[req_num], mb_ctx->out_len_) != 0) {
        status[req_num] = RequestStatus::Error;
      }
      // else keep the previous status from the private key operation
    } else {
      status[req_num] = RequestStatus::Error;
    }

    ctx_status = status[req_num];
    mb_ctx->scheduleCallback(ctx_status);
  }
}

void CryptoMbQueue::processEcdsaRequests() {
  uint8_t sig_r[MULTIBUFF_BATCH][32];
  uint8_t sig_s[MULTIBUFF_BATCH][32];
  uint8_t* pa_sig_r[MULTIBUFF_BATCH] = {sig_r[0], sig_r[1], sig_r[2], sig_r[3],
                                        sig_r[4], sig_r[5], sig_r[6], sig_r[7]};
  uint8_t* pa_sig_s[MULTIBUFF_BATCH] = {sig_s[0], sig_s[1], sig_s[2], sig_s[3],
                                        sig_s[4], sig_s[5], sig_s[6], sig_s[7]};
  const unsigned char* digest[MULTIBUFF_BATCH] = {nullptr};
  const BIGNUM* eph_key[MULTIBUFF_BATCH] = {nullptr};
  const BIGNUM* priv_key[MULTIBUFF_BATCH] = {nullptr};

  /* Build arrays of pointers for call */
  for (unsigned req_num = 0; req_num < request_queue_.size(); req_num++) {
    CryptoMbEcdsaContextSharedPtr mb_ctx =
        std::static_pointer_cast<CryptoMbEcdsaContext>(request_queue_[req_num]);
    digest[req_num] = mb_ctx->in_buf_.get();
    eph_key[req_num] = mb_ctx->k_;
    priv_key[req_num] = mb_ctx->priv_key_;
  }

  ENVOY_LOG(debug, "Multibuffer ECDSA process {} requests", request_queue_.size());

  uint32_t ecdsa_sts =
      ipp_->mbxNistp256EcdsaSignSslMb8(pa_sig_r, pa_sig_s, digest, eph_key, priv_key);

  enum RequestStatus status[MULTIBUFF_BATCH] = {RequestStatus::Retry};

  for (unsigned req_num = 0; req_num < request_queue_.size(); req_num++) {
    CryptoMbEcdsaContextSharedPtr mb_ctx =
        std::static_pointer_cast<CryptoMbEcdsaContext>(request_queue_[req_num]);
    enum RequestStatus ctx_status;
    if (ipp_->mbxGetSts(ecdsa_sts, req_num)) {
      ENVOY_LOG(debug, "Multibuffer ECDSA request {} success", req_num);
      if (postprocessEcdsaRequest(mb_ctx, pa_sig_r[req_num], pa_sig_s[req_num])) {
        status[req_num] = RequestStatus::Success;
      } else {
        status[req_num] = RequestStatus::Error;
      }
    } else {
      ENVOY_LOG(debug, "Multibuffer ECDSA request {} failure", req_num);
      status[req_num] = RequestStatus::Error;
    }

    ctx_status = status[req_num];
    mb_ctx->scheduleCallback(ctx_status);

    // End context to invalid the ephemeral key.
    BN_CTX_end(mb_ctx->ctx_.get());
  }
}

bool CryptoMbQueue::postprocessEcdsaRequest(CryptoMbEcdsaContextSharedPtr mb_ctx,
                                            const uint8_t* pa_sig_r, const uint8_t* pa_sig_s) {
  ECDSA_SIG* sig = ECDSA_SIG_new();
  if (sig == nullptr) {
    return false;
  }
  BIGNUM* sig_r = BN_bin2bn(pa_sig_r, 32, nullptr);
  BIGNUM* sig_s = BN_bin2bn(pa_sig_s, 32, nullptr);
  ECDSA_SIG_set0(sig, sig_r, sig_s);

  // Marshal signature into out_buf_.
  CBB cbb;
  if (!CBB_init_fixed(&cbb, mb_ctx->out_buf_, mb_ctx->sig_len_) || !ECDSA_SIG_marshal(&cbb, sig) ||
      !CBB_finish(&cbb, nullptr, &mb_ctx->out_len_)) {
    CBB_cleanup(&cbb);
    ECDSA_SIG_free(sig);
    return false;
  }

  ECDSA_SIG_free(sig);
  return true;
}

CryptoMbPrivateKeyConnection::CryptoMbPrivateKeyConnection(Ssl::PrivateKeyConnectionCallbacks& cb,
                                                           Event::Dispatcher& dispatcher,
                                                           bssl::UniquePtr<EVP_PKEY> pkey,
                                                           CryptoMbQueue& queue)
    : queue_(queue), dispatcher_(dispatcher), cb_(cb), pkey_(std::move(pkey)) {}

void CryptoMbPrivateKeyMethodProvider::registerPrivateKeyMethod(
    SSL* ssl, Ssl::PrivateKeyConnectionCallbacks& cb, Event::Dispatcher& dispatcher) {

  if (SSL_get_ex_data(ssl, CryptoMbPrivateKeyMethodProvider::connectionIndex()) != nullptr) {
    throw EnvoyException("Not registering the CryptoMb provider twice for same context");
  }

  ASSERT(tls_->currentThreadRegistered(), "Current thread needs to be registered.");

  CryptoMbQueue& queue = tls_->get()->queue_;

  CryptoMbPrivateKeyConnection* ops =
      new CryptoMbPrivateKeyConnection(cb, dispatcher, bssl::UpRef(pkey_), queue);
  SSL_set_ex_data(ssl, CryptoMbPrivateKeyMethodProvider::connectionIndex(), ops);
}

void CryptoMbPrivateKeyConnection::addToQueue(CryptoMbContextSharedPtr mb_ctx) {
  mb_ctx_ = mb_ctx;
  queue_.addAndProcessEightRequests(mb_ctx_);
}

bool CryptoMbPrivateKeyMethodProvider::checkFips() {
  // `ipp-crypto` library is not fips-certified at the moment
  // (https://github.com/intel/ipp-crypto#certification).
  return false;
}

bool CryptoMbPrivateKeyMethodProvider::isAvailable() { return initialized_; }

Ssl::BoringSslPrivateKeyMethodSharedPtr
CryptoMbPrivateKeyMethodProvider::getBoringSslPrivateKeyMethod() {
  return method_;
}

void CryptoMbPrivateKeyMethodProvider::unregisterPrivateKeyMethod(SSL* ssl) {
  CryptoMbPrivateKeyConnection* ops = static_cast<CryptoMbPrivateKeyConnection*>(
      SSL_get_ex_data(ssl, CryptoMbPrivateKeyMethodProvider::connectionIndex()));
  SSL_set_ex_data(ssl, CryptoMbPrivateKeyMethodProvider::connectionIndex(), nullptr);
  delete ops;
}

// The CryptoMbPrivateKeyMethodProvider is created on config.
CryptoMbPrivateKeyMethodProvider::CryptoMbPrivateKeyMethodProvider(
    const envoy::extensions::private_key_providers::cryptomb::v3alpha::
        CryptoMbPrivateKeyMethodConfig& conf,
    Server::Configuration::TransportSocketFactoryContext& factory_context, IppCryptoSharedPtr ipp)
    : api_(factory_context.serverFactoryContext().api()),
      tls_(ThreadLocal::TypedSlot<ThreadLocalData>::makeUnique(
          factory_context.serverFactoryContext().threadLocal())),
      stats_(generateCryptoMbStats("cryptomb", factory_context.statsScope())) {

  if (!ipp->mbxIsCryptoMbApplicable(0)) {
    ENVOY_LOG(warn, "Multi-buffer CPU instructions not available.");
    return;
  }

  std::chrono::milliseconds poll_delay =
      std::chrono::milliseconds(PROTOBUF_GET_MS_OR_DEFAULT(conf, poll_delay, 200));

  std::string private_key = Config::DataSource::read(conf.private_key(), false, api_);

  bssl::UniquePtr<BIO> bio(
      BIO_new_mem_buf(const_cast<char*>(private_key.data()), private_key.size()));

  bssl::UniquePtr<EVP_PKEY> pkey(PEM_read_bio_PrivateKey(bio.get(), nullptr, nullptr, nullptr));
  if (pkey == nullptr) {
    throw EnvoyException("Failed to read private key.");
  }

  method_ = std::make_shared<SSL_PRIVATE_KEY_METHOD>();

  int key_size;

  if (EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA) {
    ENVOY_LOG(debug, "CryptoMb key type: RSA");
    key_type_ = KeyType::Rsa;

    method_->sign = rsaPrivateKeySign;
    method_->decrypt = rsaPrivateKeyDecrypt;
    method_->complete = privateKeyComplete;

    RSA* rsa = EVP_PKEY_get0_RSA(pkey.get());
    switch (RSA_bits(rsa)) {
    case 1024:
      key_size = 1024;
      break;
    case 2048:
      key_size = 2048;
      break;
    case 3072:
      key_size = 3072;
      break;
    case 4096:
      key_size = 4096;
      break;
    default:
      ENVOY_LOG(warn, "Only RSA keys of 1024, 2048, 3072, and 4096 bits are supported.");
      return;
    }

    // If longer keys are ever supported, remember to change the signature buffer to be larger.
    ASSERT(key_size / 8 <= CryptoMbContext::MAX_SIGNATURE_SIZE);

    BIGNUM e_check;
    // const BIGNUMs, memory managed by BoringSSL in RSA key structure.
    const BIGNUM* e = nullptr;
    const BIGNUM* n = nullptr;
    const BIGNUM* d = nullptr;
    RSA_get0_key(rsa, &n, &e, &d);
    BN_init(&e_check);
    BN_add_word(&e_check, 65537);
    if (e == nullptr || BN_ucmp(e, &e_check) != 0) {
      BN_free(&e_check);
      throw EnvoyException("Only RSA keys with \"e\" parameter value 65537 are allowed, because "
                           "we can validate the signatures using multi-buffer instructions.");
    }
    BN_free(&e_check);
  } else if (EVP_PKEY_id(pkey.get()) == EVP_PKEY_EC) {
    ENVOY_LOG(debug, "CryptoMb key type: ECDSA");
    key_type_ = KeyType::Ec;

    method_->sign = ecdsaPrivateKeySign;
    method_->decrypt = ecdsaPrivateKeyDecrypt;
    method_->complete = privateKeyComplete;

    const EC_GROUP* ecdsa_group = EC_KEY_get0_group(EVP_PKEY_get0_EC_KEY(pkey.get()));
    if (ecdsa_group == nullptr) {
      throw EnvoyException("Invalid ECDSA key.");
    }
    BIGNUMConstPtr order(EC_GROUP_get0_order(ecdsa_group));
    if (EC_GROUP_get_curve_name(ecdsa_group) != NID_X9_62_prime256v1) {
      throw EnvoyException("Only P-256 ECDSA keys are supported.");
    }
    if (BN_num_bits(order.get()) < 160) {
      throw EnvoyException("Too few significant bits.");
    }
    key_size = EC_GROUP_get_degree(ecdsa_group);
    ASSERT(key_size == 256);
  } else {
    throw EnvoyException("Not supported key type, only EC and RSA are supported.");
  }

  pkey_ = std::move(pkey);

  enum KeyType key_type = key_type_;

  // Create a single queue for every worker thread to avoid locking.
  tls_->set([poll_delay, key_type, key_size, ipp, this](Event::Dispatcher& d) {
    ENVOY_LOG(debug, "Created CryptoMb Queue for thread {}", d.name());
    return std::make_shared<ThreadLocalData>(poll_delay, key_type, key_size, ipp, d, stats_);
  });

  initialized_ = true;
}

namespace {
int createIndex() {
  int index = SSL_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);
  RELEASE_ASSERT(index >= 0, "Failed to get SSL user data index.");
  return index;
}
} // namespace

int CryptoMbPrivateKeyMethodProvider::connectionIndex() {
  CONSTRUCT_ON_FIRST_USE(int, createIndex());
}

} // namespace CryptoMb
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_cmake",
    "envoy_contrib_package",
)
load(
    "//contrib:all_contrib_extensions.bzl",
    "envoy_contrib_linux_x86_64_constraints",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cmake(
    name = "ipp-crypto",
    cache_entries = {
        "BORINGSSL": "on",
    },
    defines = [
        "OPENSSL_USE_STATIC_LIBS=TRUE",
    ],
    lib_source = select({
        "//bazel:boringssl_fips": "@com_github_intel_ipp_crypto_crypto_mb_fips//:all",
        "//conditions:default": "@com_github_intel_ipp_crypto_crypto_mb//:all",
    }),
    out_static_libs = ["libcrypto_mb.a"],
    tags = ["skip_on_windows"],
    target_compatible_with = envoy_contrib_linux_x86_64_constraints(),
    visibility = ["//visibility:private"],
    working_directory = "sources/ippcp/crypto_mb",
    # Use boringssl alias to select fips vs non-fips version.
    deps = ["//bazel:boringssl"],
)

envoy_cc_library(
    name = "ipp_crypto_wrapper_lib",
    hdrs = ["ipp_crypto.h"] + select({
        "//bazel:linux_x86_64": [
            "ipp_crypto_impl.h",
        ],
        "//conditions:default": [
        ],
    }),
    defines = select({
        "//bazel:linux_x86_64": [],
        "//conditions:default": [
            "IPP_CRYPTO_DISABLED=1",
        ],
    }),
    external_deps = ["ssl"],
    repository = "@envoy",
    deps = select({
        "//bazel:linux_x86_64": [
            ":ipp-crypto",
        ],
        "//conditions:default": [],
    }),
)

envoy_cc_library(
    name = "cryptomb_private_key_provider_lib",
    srcs = [
        "cryptomb_private_key_provider.cc",
    ],
    hdrs = [
        "cryptomb_private_key_provider.h",
    ],
    external_deps = ["ssl"],
    repository = "@envoy",
    visibility = ["//visibility:public"],
    deps = [
        ":cryptomb_stats_lib",
        ":ipp_crypto_wrapper_lib",
        "//envoy/api:api_interface",
        "//envoy/event:dispatcher_interface",
        "//envoy/registry",
        "//envoy/server:transport_socket_config_interface",
        "//envoy/singleton:manager_interface",
        "//envoy/ssl/private_key:private_key_config_interface",
        "//envoy/ssl/private_key:private_key_interface",
        "//source/common/common:logger_lib",
        "//source/common/common:thread_lib",
        "//source/common/config:datasource_lib",
        "@envoy_api//contrib/envoy/extensions/private_key_providers/cryptomb/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "cryptomb_stats_lib",
    srcs = [
        "cryptomb_stats.cc",
    ],
    hdrs = [
        "cryptomb_stats.h",
    ],
    deps = [
        "//envoy/stats:stats_interface",
        "//envoy/stats:stats_macros",
        "//source/common/stats:symbol_table_lib",
        "//source/common/stats:utility_lib",
    ],
)

envoy_cc_contrib_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    defines = select({
        "//bazel:linux_x86_64": [],
        "//conditions:default": [
            "IPP_CRYPTO_DISABLED=1",
        ],
    }),
    deps = [
        "//envoy/registry",
        "//envoy/ssl/private_key:private_key_config_interface",
        "//envoy/ssl/private_key:private_key_interface",
        "//source/common/common:logger_lib",
        "//source/common/config:utility_lib",
        "//source/common/protobuf:utility_lib",
        "@envoy_api//contrib/envoy/extensions/private_key_providers/cryptomb/v3alpha:pkg_cc_proto",
        "@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto",
    ] + select({
        "//bazel:linux_x86_64": [
            ":cryptomb_private_key_provider_lib",
            ":ipp_crypto_wrapper_lib",
        ],
        "//conditions:default": [
        ],
    }),
)
#include "contrib/cryptomb/private_key_providers/source/config.h"

#include <memory>

#include "envoy/registry/registry.h"
#include "envoy/server/transport_socket_config.h"

#include "source/common/common/logger.h"
#include "source/common/config/utility.h"
#include "source/common/protobuf/message_validator_impl.h"
#include "source/common/protobuf/utility.h"

#ifndef IPP_CRYPTO_DISABLED
#include "contrib/cryptomb/private_key_providers/source/ipp_crypto_impl.h"
#include "contrib/cryptomb/private_key_providers/source/cryptomb_private_key_provider.h"
#endif

#include "contrib/envoy/extensions/private_key_providers/cryptomb/v3alpha/cryptomb.pb.h"
#include "contrib/envoy/extensions/private_key_providers/cryptomb/v3alpha/cryptomb.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace CryptoMb {

Ssl::PrivateKeyMethodProviderSharedPtr
CryptoMbPrivateKeyMethodFactory::createPrivateKeyMethodProviderInstance(
    const envoy::extensions::transport_sockets::tls::v3::PrivateKeyProvider& proto_config,
    Server::Configuration::TransportSocketFactoryContext& private_key_provider_context) {
  ProtobufTypes::MessagePtr message =
      std::make_unique<envoy::extensions::private_key_providers::cryptomb::v3alpha::
                           CryptoMbPrivateKeyMethodConfig>();

  Config::Utility::translateOpaqueConfig(proto_config.typed_config(),
                                         ProtobufMessage::getNullValidationVisitor(), *message);
  const envoy::extensions::private_key_providers::cryptomb::v3alpha::CryptoMbPrivateKeyMethodConfig
      conf =
          MessageUtil::downcastAndValidate<const envoy::extensions::private_key_providers::
                                               cryptomb::v3alpha::CryptoMbPrivateKeyMethodConfig&>(
              *message, private_key_provider_context.messageValidationVisitor());
  Ssl::PrivateKeyMethodProviderSharedPtr provider = nullptr;
#ifdef IPP_CRYPTO_DISABLED
  throw EnvoyException("X86_64 architecture is required for cryptomb provider.");
#else
  IppCryptoSharedPtr ipp = std::make_shared<IppCryptoImpl>();
  provider =
      std::make_shared<CryptoMbPrivateKeyMethodProvider>(conf, private_key_provider_context, ipp);
#endif
  return provider;
}

REGISTER_FACTORY(CryptoMbPrivateKeyMethodFactory, Ssl::PrivateKeyMethodProviderInstanceFactory);

} // namespace CryptoMb
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
// Note: this should be run with --compilation_mode=opt, and would benefit from
// a quiescent system with disabled cstate power management.

#include "source/common/common/assert.h"

#include "benchmark/benchmark.h"
#include "hs/hs.h"
#include "re2/re2.h"

namespace Envoy {

const std::vector<std::string>& clusterInputs() {
  CONSTRUCT_ON_FIRST_USE(
      std::vector<std::string>,
      {
          "cluster.no_trailing_dot",
          "cluster.match.",
          "cluster.match.normal",
          "cluster.match.and.a.whole.lot.of.things.coming.after.the.matches.really.too.much.stuff",
      });
}

const std::vector<const char*>& clusterRePatterns() {
  CONSTRUCT_ON_FIRST_USE(std::vector<const char*>, "^cluster\\.((.*?)\\.)");
}

// NOLINTNEXTLINE(readability-identifier-naming)
static void BM_RE2(benchmark::State& state) {
  re2::RE2 re(clusterRePatterns()[0]);
  uint32_t passes = 0;
  for (auto _ : state) { // NOLINT
    for (const std::string& cluster_input : clusterInputs()) {
      if (re2::RE2::FullMatch(cluster_input, re)) {
        ++passes;
      }
    }
  }
  RELEASE_ASSERT(passes > 0, "");
}
BENCHMARK(BM_RE2);

// NOLINTNEXTLINE(readability-identifier-naming)
static void BM_Hyperscan(benchmark::State& state) {
  hs_database_t* database{};
  hs_scratch_t* scratch{};
  hs_compile_error_t* compile_err;
  const std::vector<const char*>& cluster_re_patterns = clusterRePatterns();
  RELEASE_ASSERT(hs_compile_multi(cluster_re_patterns.data(), nullptr, nullptr,
                                  cluster_re_patterns.size(), HS_MODE_BLOCK, nullptr, &database,
                                  &compile_err) == HS_SUCCESS,
                 "");
  RELEASE_ASSERT(hs_alloc_scratch(database, &scratch) == HS_SUCCESS, "");
  uint32_t passes = 0;
  for (auto _ : state) { // NOLINT
    for (const std::string& cluster_input : clusterInputs()) {
      hs_error_t err = hs_scan(
          database, cluster_input.data(), cluster_input.size(), 0, scratch,
          [](unsigned int, unsigned long long, unsigned long long, unsigned int,
             void* context) -> int {
            uint32_t* passes = static_cast<uint32_t*>(context);
            *passes = *passes + 1;

            return 1;
          },
          &passes);
      ASSERT(err == HS_SUCCESS || err == HS_SCAN_TERMINATED);
    }
  }
  hs_free_scratch(scratch);
  hs_free_database(database);
  RELEASE_ASSERT(passes > 0, "");
}
BENCHMARK(BM_Hyperscan);

} // namespace Envoy
#ifndef HYPERSCAN_DISABLED
#include "source/common/thread_local/thread_local_impl.h"

#include "test/mocks/event/mocks.h"
#include "test/mocks/thread_local/mocks.h"
#include "test/test_common/utility.h"

#include "absl/synchronization/blocking_counter.h"
#include "contrib/hyperscan/matching/input_matchers/source/matcher.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

namespace Envoy {
namespace Extensions {
namespace Matching {
namespace InputMatchers {
namespace Hyperscan {

// Verify that we do not get TSAN or other errors when creating scratch in
// multithreading.
TEST(ThreadLocalTest, RaceScratchCreation) {
  Thread::ThreadFactory& thread_factory = Thread::threadFactoryForTest();

  hs_database_t* database;
  hs_compile_error_t* compile_err;
  hs_error_t err = hs_compile("hello", 0, HS_MODE_BLOCK, nullptr, &database, &compile_err);
  ASSERT(err == HS_SUCCESS);

  constexpr int num_threads = 100;
  std::vector<Thread::ThreadPtr> threads;
  threads.reserve(num_threads);
  ConditionalInitializer creation, wait;
  absl::BlockingCounter creates(num_threads);
  for (int i = 0; i < num_threads; ++i) {
    threads.push_back(thread_factory.createThread([&database, &creation, &wait, &creates]() {
      // Block each thread on waking up a common condition variable,
      // so we make it likely to race on creation.
      creation.wait();
      ScratchThreadLocal tls(database, nullptr);
      creates.DecrementCount();

      wait.wait();
    }));
  }
  creation.setReady();
  creates.Wait();

  wait.setReady();
  for (auto& thread : threads) {
    thread->join();
  }
}

// Verify that even if thread local is not initialized, matcher can work and create thread local
// afterwards.
TEST(ThreadLocalTest, NotInitialized) {
  std::vector<const char*> expressions{"^/asdf/.+"};
  std::vector<unsigned int> flags{0};
  std::vector<unsigned int> ids{0};

  Event::MockDispatcher dispatcher;
  ThreadLocal::MockInstance instance;
  EXPECT_CALL(instance, allocateSlot())
      .WillOnce(testing::Invoke(&instance, &ThreadLocal::MockInstance::allocateSlotMock));
  Matcher matcher(expressions, flags, ids, dispatcher, instance, false);
  // Simulate moving to another thread.
  instance.data_[0].reset();

  EXPECT_CALL(dispatcher, post(_));
  EXPECT_TRUE(matcher.match("/asdf/1"));
}

// Verify that comparing works correctly for bounds.
TEST(BoundTest, Compare) {
  EXPECT_LT(Bound(1, 1), Bound(2, 1));
  EXPECT_LT(Bound(1, 2), Bound(2, 1));
  EXPECT_LT(Bound(2, 2), Bound(2, 1));
}

class MatcherTest : public ::testing::Test {
protected:
  void setup(const char* expression, unsigned int flag, bool report_start_of_matching) {
    std::vector<const char*> expressions{expression};
    std::vector<unsigned int> flags{flag};
    std::vector<unsigned int> ids{0};
    matcher_ = std::make_unique<Matcher>(expressions, flags, ids, dispatcher_, instance_,
                                         report_start_of_matching);
  }

  void TearDown() override {
    instance_.shutdownGlobalThreading();
    ::testing::Test::TearDown();
  }

  Event::MockDispatcher dispatcher_;
  ThreadLocal::InstanceImpl instance_;
  std::unique_ptr<Matcher> matcher_;
};

// Verify that matching will be performed successfully.
TEST_F(MatcherTest, Regex) {
  setup("^/asdf/.+", 0, false);

  EXPECT_TRUE(matcher_->match("/asdf/1"));
  EXPECT_FALSE(matcher_->match("/ASDF/1"));
  EXPECT_FALSE(matcher_->match("/asdf/\n"));
  EXPECT_FALSE(matcher_->match("\n/asdf/1"));
}

// Verify that matching will be performed successfully on empty optional value.
TEST_F(MatcherTest, Nullopt) {
  setup("^/asdf/.+", 0, false);

  EXPECT_FALSE(matcher_->match(absl::monostate()));
}

// Verify that matching will be performed case-insensitively.
TEST_F(MatcherTest, RegexWithCaseless) {
  setup("^/asdf/.+", HS_FLAG_CASELESS, false);

  EXPECT_TRUE(matcher_->match("/asdf/1"));
  EXPECT_TRUE(matcher_->match("/ASDF/1"));
  EXPECT_FALSE(matcher_->match("/asdf/\n"));
  EXPECT_FALSE(matcher_->match("\n/asdf/1"));
}

// Verify that matching a `.` will not exclude newlines.
TEST_F(MatcherTest, RegexWithDotAll) {
  setup("^/asdf/.+", HS_FLAG_DOTALL, false);

  EXPECT_TRUE(matcher_->match("/asdf/1"));
  EXPECT_FALSE(matcher_->match("/ASDF/1"));
  EXPECT_TRUE(matcher_->match("/asdf/\n"));
  EXPECT_FALSE(matcher_->match("\n/asdf/1"));
}

// Verify that `^` and `$` anchors match any newlines in data.
TEST_F(MatcherTest, RegexWithMultiline) {
  setup("^/asdf/.+", HS_FLAG_MULTILINE, false);

  EXPECT_TRUE(matcher_->match("/asdf/1"));
  EXPECT_FALSE(matcher_->match("/ASDF/1"));
  EXPECT_FALSE(matcher_->match("/asdf/\n"));
  EXPECT_TRUE(matcher_->match("\n/asdf/1"));
}

// Verify that expressions which can match against an empty string.
TEST_F(MatcherTest, RegexWithAllowEmpty) {
  setup(".*", HS_FLAG_ALLOWEMPTY, false);

  EXPECT_TRUE(matcher_->match(""));
}

// Verify that treating the pattern as a sequence of UTF-8 characters.
TEST_F(MatcherTest, RegexWithUTF8) {
  setup("^.$", HS_FLAG_UTF8, false);

  EXPECT_TRUE(matcher_->match(""));
}

// Verify that using Unicode properties for character classes.
TEST_F(MatcherTest, RegexWithUCP) {
  setup("^\\w$", HS_FLAG_UTF8 | HS_FLAG_UCP, false);

  EXPECT_TRUE(matcher_->match(""));
}

// Verify that using logical combination.
TEST_F(MatcherTest, RegexWithCombination) {
  std::vector<const char*> expressions{"a", "b", "1 | 2"};
  std::vector<unsigned int> flags{HS_FLAG_QUIET, HS_FLAG_QUIET, HS_FLAG_COMBINATION};
  std::vector<unsigned int> ids{1, 2, 0};

  matcher_ = std::make_unique<Matcher>(expressions, flags, ids, dispatcher_, instance_, false);

  EXPECT_TRUE(matcher_->match("a"));
}

// Verify that invalid expression will cause a throw.
TEST_F(MatcherTest, InvalidRegex) {
  EXPECT_THROW_WITH_MESSAGE(
      setup("(", 0, false), EnvoyException,
      "unable to compile pattern '(': Missing close parenthesis for group started at index 0.");
}

// Verify that replace all works correctly.
TEST_F(MatcherTest, ReplaceAll) {
  setup("b+", 0, true);

  EXPECT_EQ(matcher_->replaceAll("yabba dabba doo", "d"), "yada dada doo");
}

} // namespace Hyperscan
} // namespace InputMatchers
} // namespace Matching
} // namespace Extensions
} // namespace Envoy
#endif
#include "test/mocks/server/factory_context.h"

#include "contrib/hyperscan/matching/input_matchers/source/config.h"
#include "gtest/gtest.h"

namespace Envoy {
namespace Extensions {
namespace Matching {
namespace InputMatchers {
namespace Hyperscan {

class ConfigTest : public ::testing::Test {
protected:
  void setup(const std::string& yaml) {
    envoy::config::core::v3::TypedExtensionConfig config;
    config.set_name("hyperscan");
    envoy::extensions::matching::input_matchers::hyperscan::v3alpha::Hyperscan hyperscan;
    TestUtility::loadFromYaml(yaml, hyperscan);
    config.mutable_typed_config()->PackFrom(hyperscan);

    Config factory;
    auto message = Envoy::Config::Utility::translateAnyToFactoryConfig(
        config.typed_config(), ProtobufMessage::getStrictValidationVisitor(), factory);
    matcher_ = factory.createInputMatcherFactoryCb(*message, context_)();
  }

  NiceMock<Server::Configuration::MockServerFactoryContext> context_;
  Envoy::Matcher::InputMatcherPtr matcher_;
};

#ifdef HYPERSCAN_DISABLED
// Verify that incompatible architecture will cause a throw.
TEST_F(ConfigTest, IncompatibleArchitecture) {
  EXPECT_THROW_WITH_MESSAGE(setup(R"EOF(
regexes:
- regex: ^/asdf/.+
)EOF"),
                            EnvoyException, "X86_64 architecture is required for Hyperscan.");
}
#else
// Verify that matching will be performed successfully.
TEST_F(ConfigTest, Regex) {
  setup(R"EOF(
regexes:
- regex: ^/asdf/.+
)EOF");

  EXPECT_TRUE(matcher_->match("/asdf/1"));
  EXPECT_FALSE(matcher_->match("/ASDF/1"));
  EXPECT_FALSE(matcher_->match("/asdf/\n"));
  EXPECT_FALSE(matcher_->match("\n/asdf/1"));
}

// Verify that matching will be performed case-insensitively.
TEST_F(ConfigTest, RegexWithCaseless) {
  setup(R"EOF(
regexes:
- regex: ^/asdf/.+
  caseless: true
)EOF");

  EXPECT_TRUE(matcher_->match("/asdf/1"));
  EXPECT_TRUE(matcher_->match("/ASDF/1"));
  EXPECT_FALSE(matcher_->match("/asdf/\n"));
  EXPECT_FALSE(matcher_->match("\n/asdf/1"));
}

// Verify that matching a `.` will not exclude newlines.
TEST_F(ConfigTest, RegexWithDotAll) {
  setup(R"EOF(
regexes:
- regex: ^/asdf/.+
  dot_all: true
)EOF");

  EXPECT_TRUE(matcher_->match("/asdf/1"));
  EXPECT_FALSE(matcher_->match("/ASDF/1"));
  EXPECT_TRUE(matcher_->match("/asdf/\n"));
  EXPECT_FALSE(matcher_->match("\n/asdf/1"));
}

// Verify that `^` and `$` anchors match any newlines in data.
TEST_F(ConfigTest, RegexWithMultiline) {
  setup(R"EOF(
regexes:
- regex: ^/asdf/.+
  multiline: true
)EOF");

  EXPECT_TRUE(matcher_->match("/asdf/1"));
  EXPECT_FALSE(matcher_->match("/ASDF/1"));
  EXPECT_FALSE(matcher_->match("/asdf/\n"));
  EXPECT_TRUE(matcher_->match("\n/asdf/1"));
}

// Verify that expressions which can match against an empty string.
TEST_F(ConfigTest, RegexWithAllowEmpty) {
  setup(R"EOF(
regexes:
- regex: .*
  allow_empty: true
)EOF");

  EXPECT_TRUE(matcher_->match(""));
}

// Verify that treating the pattern as a sequence of UTF-8 characters.
TEST_F(ConfigTest, RegexWithUTF8) {
  setup(R"EOF(
regexes:
- regex: ^.$
  utf8: true
)EOF");

  EXPECT_TRUE(matcher_->match(""));
}

// Verify that using Unicode properties for character classes.
TEST_F(ConfigTest, RegexWithUCP) {
  setup(R"EOF(
regexes:
- regex: ^\w$
  utf8: true
  ucp: true
)EOF");

  EXPECT_TRUE(matcher_->match(""));
}

// Verify that using logical combination.
TEST_F(ConfigTest, RegexWithCombination) {
  setup(R"EOF(
regexes:
- regex: a
  id: 1
  quiet: true
- regex: b
  id: 2
  quiet: true
- regex: 1 | 2
  combination: true
)EOF");

  EXPECT_TRUE(matcher_->match("a"));
}
#endif

} // namespace Hyperscan
} // namespace InputMatchers
} // namespace Matching
} // namespace Extensions
} // namespace Envoy
// Note: this should be run with --compilation_mode=opt, and would benefit from
// a quiescent system with disabled cstate power management.

#include "source/common/common/assert.h"
#include "source/common/common/regex.h"
#include "source/common/thread_local/thread_local_impl.h"

#include "test/mocks/event/mocks.h"

#include "benchmark/benchmark.h"
#include "contrib/hyperscan/matching/input_matchers/source/matcher.h"

namespace Envoy {

const std::vector<std::string>& clusterInputs() {
  CONSTRUCT_ON_FIRST_USE(
      std::vector<std::string>,
      {
          "cluster.no_trailing_dot",
          "cluster.match.",
          "cluster.match.normal",
          "cluster.match.and.a.whole.lot.of.things.coming.after.the.matches.really.too.much.stuff",
      });
}

constexpr absl::string_view ClusterRePattern = "^cluster\\.((.*?)\\.)";

// NOLINTNEXTLINE(readability-identifier-naming)
static void BM_CompiledGoogleReMatcher(benchmark::State& state) {
  envoy::type::matcher::v3::RegexMatcher config;
  config.mutable_google_re2();
  config.set_regex(std::string(ClusterRePattern));
  const auto matcher = Regex::CompiledGoogleReMatcher(config);
  uint32_t passes = 0;
  for (auto _ : state) { // NOLINT
    for (const std::string& cluster_input : clusterInputs()) {
      if (matcher.match(cluster_input)) {
        ++passes;
      }
    }
  }
  RELEASE_ASSERT(passes > 0, "");
}
BENCHMARK(BM_CompiledGoogleReMatcher);

// NOLINTNEXTLINE(readability-identifier-naming)
static void BM_HyperscanMatcher(benchmark::State& state) {
  Event::MockDispatcher dispatcher;
  ThreadLocal::InstanceImpl instance;
  auto matcher = Extensions::Matching::InputMatchers::Hyperscan::Matcher(
      {std::string(ClusterRePattern).c_str()}, {0}, {0}, dispatcher, instance, false);
  uint32_t passes = 0;
  for (auto _ : state) { // NOLINT
    for (const std::string& cluster_input : clusterInputs()) {
      if (matcher.match(cluster_input)) {
        ++passes;
      }
    }
  }
  RELEASE_ASSERT(passes > 0, "");
  instance.shutdownGlobalThreading();
}
BENCHMARK(BM_HyperscanMatcher);

} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_benchmark_binary",
    "envoy_cc_test",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_test(
    name = "config_test",
    srcs = ["config_test.cc"],
    deps = [
        "//contrib/hyperscan/matching/input_matchers/source:config",
        "//test/mocks/server:factory_context_mocks",
    ],
)

envoy_cc_test(
    name = "matcher_test",
    srcs = ["matcher_test.cc"],
    deps = [
        "//source/common/thread_local:thread_local_lib",
        "//test/mocks/event:event_mocks",
        "//test/mocks/thread_local:thread_local_mocks",
        "//test/test_common:utility_lib",
    ] + select({
        "//bazel:linux_x86_64": [
            "//contrib/hyperscan/matching/input_matchers/source:hyperscan_matcher_lib",
        ],
        "//bazel:linux_aarch64": [
            "//contrib/hyperscan/matching/input_matchers/source:vectorscan_matcher_lib",
        ],
    }),
)

envoy_cc_benchmark_binary(
    name = "hyperscan_speed_test",
    srcs = ["hyperscan_speed_test.cc"],
    external_deps = ["benchmark"],
    deps = [
        "//source/common/common:assert_lib",
        "//source/common/common:utility_lib",
        "@com_googlesource_code_re2//:re2",
    ] + select({
        "//bazel:linux_x86_64": [
            "//contrib/hyperscan/matching/input_matchers/source:hyperscan",
        ],
        "//bazel:linux_aarch64": [
            "//contrib/hyperscan/matching/input_matchers/source:vectorscan",
        ],
    }),
)

envoy_cc_benchmark_binary(
    name = "matcher_speed_test",
    srcs = ["matcher_speed_test.cc"],
    external_deps = ["benchmark"],
    deps = [
        "//source/common/common:assert_lib",
        "//source/common/common:regex_lib",
        "//source/common/common:utility_lib",
        "//source/common/thread_local:thread_local_lib",
        "//test/mocks/event:event_mocks",
    ] + select({
        "//bazel:linux_x86_64": [
            "//contrib/hyperscan/matching/input_matchers/source:hyperscan_matcher_lib",
        ],
        "//bazel:linux_aarch64": [
            "//contrib/hyperscan/matching/input_matchers/source:vectorscan_matcher_lib",
        ],
    }),
)
#pragma once

#include "envoy/common/regex.h"
#include "envoy/matcher/matcher.h"
#include "envoy/thread_local/thread_local.h"

#include "hs/hs.h"

namespace Envoy {
namespace Extensions {
namespace Matching {
namespace InputMatchers {
namespace Hyperscan {

struct ScratchThreadLocal : public ThreadLocal::ThreadLocalObject {
  ScratchThreadLocal(const hs_database_t* database, const hs_database_t* start_of_match_database);
  ~ScratchThreadLocal() override;

  hs_scratch_t* scratch_{};
};

using ScratchThreadLocalPtr = std::unique_ptr<ScratchThreadLocal>;

struct Bound {
  Bound(uint64_t begin, uint64_t end);

  bool operator<(const Bound& other) const;

  uint64_t begin_;
  uint64_t end_;
};

class Matcher : public Envoy::Regex::CompiledMatcher, public Envoy::Matcher::InputMatcher {
public:
  Matcher(const std::vector<const char*>& expressions, const std::vector<unsigned int>& flags,
          const std::vector<unsigned int>& ids, Event::Dispatcher& main_thread_dispatcher,
          ThreadLocal::SlotAllocator& tls, bool report_start_of_matching);
  ~Matcher() override;

  // Envoy::Regex::CompiledMatcher
  bool match(absl::string_view value) const override;
  std::string replaceAll(absl::string_view value, absl::string_view substitution) const override;

  // Envoy::Matcher::InputMatcher
  bool match(const ::Envoy::Matcher::MatchingDataType& input) override;

private:
  hs_database_t* database_{};
  hs_database_t* start_of_match_database_{};
  Event::Dispatcher& main_thread_dispatcher_;
  ThreadLocal::TypedSlotPtr<ScratchThreadLocal> tls_;

  // Compiles the Hyperscan database. It will throw on failure of insufficient memory or malformed
  // regex patterns and flags. Vector parameters should have the same size.
  void compile(const std::vector<const char*>& expressions, const std::vector<unsigned int>& flags,
               const std::vector<unsigned int>& ids, hs_database_t** database);

  hs_scratch_t* getScratch(ScratchThreadLocalPtr& local_scratch) const;
};

} // namespace Hyperscan
} // namespace InputMatchers
} // namespace Matching
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/matcher/matcher.h"
#include "envoy/server/factory_context.h"

#include "contrib/envoy/extensions/matching/input_matchers/hyperscan/v3alpha/hyperscan.pb.h"
#include "contrib/envoy/extensions/matching/input_matchers/hyperscan/v3alpha/hyperscan.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace Matching {
namespace InputMatchers {
namespace Hyperscan {

class Config : public Envoy::Matcher::InputMatcherFactory {
public:
  std::string name() const override { return "envoy.matching.matchers.hyperscan"; }

  Envoy::Matcher::InputMatcherFactoryCb createInputMatcherFactoryCb(
      const Protobuf::Message& config,
      Server::Configuration::ServerFactoryContext& factory_context) override;
  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<
        envoy::extensions::matching::input_matchers::hyperscan::v3alpha::Hyperscan>();
  }
};

} // namespace Hyperscan
} // namespace InputMatchers
} // namespace Matching
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_cmake",
    "envoy_contrib_package",
)
load(
    "//bazel:envoy_internal.bzl",
    "envoy_external_dep_path",
)
load(
    "//contrib:all_contrib_extensions.bzl",
    "envoy_contrib_linux_aarch64_constraints",
    "envoy_contrib_linux_x86_64_constraints",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cmake(
    name = "hyperscan",
    build_data = ["@org_boost//:header"],
    cache_entries = {
        "BOOST_ROOT": "$EXT_BUILD_ROOT/external/org_boost",
        "BUILD_AVX512": "on",
        "BUILD_AVX512VBMI": "on",
        "BUILD_EXAMPLES": "off",
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_INSTALL_LIBDIR": "lib",
        "FAT_RUNTIME": "on",
        "RAGEL": "$EXT_BUILD_DEPS/ragel/bin/ragel",
    },
    default_cache_entries = {},
    lib_source = "@io_hyperscan//:all",
    out_static_libs = ["libhs.a"],
    tags = ["skip_on_windows"],
    target_compatible_with = envoy_contrib_linux_x86_64_constraints(),
    deps = [
        envoy_external_dep_path("ragel"),
    ],
)

envoy_cmake(
    name = "vectorscan",
    build_data = ["@org_boost//:header"],
    cache_entries = {
        "BOOST_ROOT": "$EXT_BUILD_ROOT/external/org_boost",
        #        "BUILD_SVE2_BITPERM": "on",
        #        "BUILD_SVE2": "on",
        #        "BUILD_SVE": "on",
        "BUILD_EXAMPLES": "off",
        "BUILD_SHARED_LIBS": "off",
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_INSTALL_LIBDIR": "lib",
        "FAT_RUNTIME": "off",
        "SQLITE_SKIP_CHECK": "on",
        "RAGEL": "$EXT_BUILD_DEPS/ragel/bin/ragel",
    },
    default_cache_entries = {},
    lib_source = "@io_vectorscan//:all",
    out_static_libs = ["libhs.a"],
    tags = ["skip_on_windows"],
    target_compatible_with = envoy_contrib_linux_aarch64_constraints(),
    deps = [
        envoy_external_dep_path("ragel"),
    ],
)

envoy_cc_library(
    name = "hyperscan_matcher_lib",
    srcs = ["matcher.cc"],
    hdrs = ["matcher.h"],
    deps = [
        ":hyperscan",
        "//envoy/common:regex_interface",
        "//envoy/matcher:matcher_interface",
        "//envoy/thread_local:thread_local_interface",
    ],
)

envoy_cc_library(
    name = "vectorscan_matcher_lib",
    srcs = ["matcher.cc"],
    hdrs = ["matcher.h"],
    deps = [
        ":vectorscan",
        "//envoy/common:regex_interface",
        "//envoy/matcher:matcher_interface",
        "//envoy/thread_local:thread_local_interface",
    ],
)

envoy_cc_contrib_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    defines = select({
        "//bazel:linux_x86_64": [],
        "//bazel:linux_aarch64": [],
        "//conditions:default": [
            "HYPERSCAN_DISABLED=1",
        ],
    }),
    deps = [
        "//envoy/matcher:matcher_interface",
        "//envoy/registry",
        "//envoy/server:factory_context_interface",
        "//source/common/protobuf:utility_lib",
        "@envoy_api//contrib/envoy/extensions/matching/input_matchers/hyperscan/v3alpha:pkg_cc_proto",
    ] + select({
        "//bazel:linux_x86_64": [
            ":hyperscan_matcher_lib",
        ],
        "//bazel:linux_aarch64": [
            ":vectorscan_matcher_lib",
        ],
        "//conditions:default": [
        ],
    }),
)
#include "contrib/hyperscan/matching/input_matchers/source/matcher.h"

namespace Envoy {
namespace Extensions {
namespace Matching {
namespace InputMatchers {
namespace Hyperscan {

ScratchThreadLocal::ScratchThreadLocal(const hs_database_t* database,
                                       const hs_database_t* start_of_match_database) {
  hs_error_t err = hs_alloc_scratch(database, &scratch_);
  if (err != HS_SUCCESS) {
    IS_ENVOY_BUG(fmt::format("unable to allocate scratch space, error code {}.", err));
  }
  if (start_of_match_database) {
    err = hs_alloc_scratch(start_of_match_database, &scratch_);
    if (err != HS_SUCCESS) {
      IS_ENVOY_BUG(
          fmt::format("unable to allocate start of match scratch space, error code {}.", err));
    }
  }
}

ScratchThreadLocal::~ScratchThreadLocal() { hs_free_scratch(scratch_); }

Bound::Bound(uint64_t begin, uint64_t end) : begin_(begin), end_(end) {}

bool Bound::operator<(const Bound& other) const {
  if (begin_ == other.begin_) {
    return end_ > other.end_;
  }
  return begin_ < other.begin_;
}

Matcher::Matcher(const std::vector<const char*>& expressions,
                 const std::vector<unsigned int>& flags, const std::vector<unsigned int>& ids,
                 Event::Dispatcher& main_thread_dispatcher, ThreadLocal::SlotAllocator& tls,
                 bool report_start_of_matching)
    : main_thread_dispatcher_(main_thread_dispatcher),
      tls_(ThreadLocal::TypedSlot<ScratchThreadLocal>::makeUnique(tls)) {
  ASSERT(expressions.size() == flags.size());
  ASSERT(expressions.size() == ids.size());

  // Compile database.
  compile(expressions, flags, ids, &database_);

  // Compile start of match database which will report start of matching, works for replaceAll.
  if (report_start_of_matching) {
    std::vector<unsigned int> start_of_match_flags = flags;
    for (unsigned int& start_of_match_flag : start_of_match_flags) {
      start_of_match_flag = start_of_match_flag | HS_FLAG_SOM_LEFTMOST;
    }
    compile(expressions, start_of_match_flags, ids, &start_of_match_database_);
  }

  tls_->set([this](Event::Dispatcher&) {
    return std::make_shared<ScratchThreadLocal>(database_, start_of_match_database_);
  });
}

Matcher::~Matcher() {
  hs_free_database(database_);
  hs_free_database(start_of_match_database_);
}

bool Matcher::match(absl::string_view value) const {
  bool matched = false;
  ScratchThreadLocalPtr local_scratch;
  hs_scratch_t* scratch = getScratch(local_scratch);
  hs_error_t err = hs_scan(
      database_, value.data(), value.size(), 0, scratch,
      [](unsigned int, unsigned long long, unsigned long long, unsigned int, void* context) -> int {
        bool* matched = static_cast<bool*>(context);
        *matched = true;

        // Non-zero if the matching should cease. Always terminate on the first match.
        return 1;
      },
      &matched);
  if (err != HS_SUCCESS && err != HS_SCAN_TERMINATED) {
    IS_ENVOY_BUG(fmt::format("unable to scan, error code {}", err));
  }

  return matched;
}

std::string Matcher::replaceAll(absl::string_view value, absl::string_view substitution) const {
  // Find matched bounds.
  std::vector<Bound> bounds;
  ScratchThreadLocalPtr local_scratch;
  hs_scratch_t* scratch = getScratch(local_scratch);
  hs_error_t err = hs_scan(
      start_of_match_database_, value.data(), value.size(), 0, scratch,
      [](unsigned int, unsigned long long from, unsigned long long to, unsigned int,
         void* context) -> int {
        std::vector<Bound>* bounds = static_cast<std::vector<Bound>*>(context);
        bounds->push_back({from, to});

        // Continue searching.
        return 0;
      },
      &bounds);
  if (err != HS_SUCCESS && err != HS_SCAN_TERMINATED) {
    IS_ENVOY_BUG(fmt::format("unable to scan, error code {}", err));
    return std::string(value);
  }

  // Sort bounds. Make sure the longest length bound in the front will appear first.
  std::sort(bounds.begin(), bounds.end());

  // Concatenate string and replace matched pair with substitution.
  std::vector<absl::string_view> parts;
  parts.reserve(bounds.size() * 2);
  uint64_t pos = 0;
  for (Bound& bound : bounds) {
    if (bound.begin_ < pos) {
      continue;
    }

    parts.emplace_back(value.substr(pos, bound.begin_ - pos));
    parts.emplace_back(substitution);
    pos = bound.end_;
  }
  parts.emplace_back(value.substr(pos));
  return absl::StrJoin(parts, "");
}

bool Matcher::match(const ::Envoy::Matcher::MatchingDataType& input) {
  if (absl::holds_alternative<absl::monostate>(input)) {
    return false;
  }

  return static_cast<Envoy::Regex::CompiledMatcher*>(this)->match(absl::get<std::string>(input));
}

void Matcher::compile(const std::vector<const char*>& expressions,
                      const std::vector<unsigned int>& flags, const std::vector<unsigned int>& ids,
                      hs_database_t** database) {
  hs_compile_error_t* compile_err;
  hs_error_t err =
      hs_compile_multi(expressions.data(), flags.data(), ids.data(), expressions.size(),
                       HS_MODE_BLOCK, nullptr, database, &compile_err);
  if (err != HS_SUCCESS) {
    std::string compile_err_message(compile_err->message);
    int compile_err_expression = compile_err->expression;
    hs_free_compile_error(compile_err);

    if (compile_err_expression < 0) {
      IS_ENVOY_BUG(fmt::format("unable to compile database: {}", compile_err_message));
    } else {
      throw EnvoyException(fmt::format("unable to compile pattern '{}': {}",
                                       expressions.at(compile_err_expression),
                                       compile_err_message));
    }
  }
  hs_free_compile_error(compile_err);
}

hs_scratch_t* Matcher::getScratch(ScratchThreadLocalPtr& local_scratch) const {
  // Some matchers are constructed before dispatching threads and set() method of thread local slot
  // will only initialize thread local object in existing threads, which may lead to unintialized
  // thread local object in threads which are dispatched later. E.g, stats matchers are constructed
  // before workers while there is chance to use these matchers in working threads. As a result,
  // we have to ask main thread to allocate thread local object again.
  if (!tls_->get().has_value()) {
    main_thread_dispatcher_.post([this]() {
      tls_->set([this](Event::Dispatcher&) {
        return std::make_shared<ScratchThreadLocal>(database_, start_of_match_database_);
      });
    });

    local_scratch = std::make_unique<ScratchThreadLocal>(database_, start_of_match_database_);
    return local_scratch->scratch_;
  }

  return tls_->get()->scratch_;
}

} // namespace Hyperscan
} // namespace InputMatchers
} // namespace Matching
} // namespace Extensions
} // namespace Envoy
#include "contrib/hyperscan/matching/input_matchers/source/config.h"

#include "envoy/registry/registry.h"

#include "source/common/protobuf/utility.h"

#ifndef HYPERSCAN_DISABLED
#include "contrib/hyperscan/matching/input_matchers/source/matcher.h"
#endif

namespace Envoy {
namespace Extensions {
namespace Matching {
namespace InputMatchers {
namespace Hyperscan {

Envoy::Matcher::InputMatcherFactoryCb
Config::createInputMatcherFactoryCb(const Protobuf::Message& config,
                                    Server::Configuration::ServerFactoryContext& factory_context) {
  const auto hyperscan_config = MessageUtil::downcastAndValidate<
      const envoy::extensions::matching::input_matchers::hyperscan::v3alpha::Hyperscan&>(
      config, factory_context.messageValidationVisitor());

#ifdef HYPERSCAN_DISABLED
  throw EnvoyException("X86_64 architecture is required for Hyperscan.");
#else
  // Hyperscan's API requires vectors of expressions, flags and IDs for matching database
  // compilation.
  return [hyperscan_config, &factory_context]() {
    int size = hyperscan_config.regexes().size();
    std::vector<const char*> expressions;
    std::vector<unsigned int> flags;
    std::vector<unsigned int> ids;
    expressions.reserve(size);
    flags.reserve(size);
    ids.reserve(size);
    for (const auto& regex : hyperscan_config.regexes()) {
      expressions.push_back(regex.regex().c_str());
      unsigned int flag = 0;
      if (regex.caseless()) {
        flag |= HS_FLAG_CASELESS;
      }
      if (regex.dot_all()) {
        flag |= HS_FLAG_DOTALL;
      }
      if (regex.multiline()) {
        flag |= HS_FLAG_MULTILINE;
      }
      if (regex.allow_empty()) {
        flag |= HS_FLAG_ALLOWEMPTY;
      }
      if (regex.utf8()) {
        flag |= HS_FLAG_UTF8;
        if (regex.ucp()) {
          flag |= HS_FLAG_UCP;
        }
      }
      if (regex.combination()) {
        flag |= HS_FLAG_COMBINATION;
      }
      if (regex.quiet()) {
        flag |= HS_FLAG_QUIET;
      }
      flags.push_back(flag);
      ids.push_back(regex.id());
    }

    return std::make_unique<Matcher>(expressions, flags, ids,
                                     factory_context.mainThreadDispatcher(),
                                     factory_context.threadLocal(), false);
  };
#endif
}

REGISTER_FACTORY(Config, Envoy::Matcher::InputMatcherFactory);

} // namespace Hyperscan
} // namespace InputMatchers
} // namespace Matching
} // namespace Extensions
} // namespace Envoy
#ifndef HYPERSCAN_DISABLED
#include "test/integration/base_integration_test.h"
#include "test/test_common/utility.h"

#include "contrib/hyperscan/regex_engines/source/config.h"
#include "gtest/gtest.h"

namespace Envoy {
namespace Extensions {
namespace Regex {
namespace Hyperscan {

class HyperscanRegexEngineIntegrationTest
    : public testing::TestWithParam<Network::Address::IpVersion>,
      public BaseIntegrationTest {
public:
  HyperscanRegexEngineIntegrationTest() : BaseIntegrationTest(GetParam(), config()) {}

  static std::string config() {
    return absl::StrCat(ConfigHelper::baseConfigNoListeners(), R"EOF(
default_regex_engine:
  name: envoy.regex_engines.hyperscan
  typed_config:
    '@type': type.googleapis.com/envoy.extensions.regex_engines.hyperscan.v3alpha.Hyperscan
    )EOF");
  }
};

INSTANTIATE_TEST_SUITE_P(IpVersions, HyperscanRegexEngineIntegrationTest,
                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
                         TestUtility::ipTestParamsToString);

// Verify that matcher can be populate successfully.
TEST_P(HyperscanRegexEngineIntegrationTest, Hyperscan) {
  initialize();

  envoy::type::matcher::v3::RegexMatcher matcher;
  *matcher.mutable_regex() = "^/asdf/.+";

  EXPECT_NO_THROW(Envoy::Regex::Utility::parseRegex(matcher));
};

} // namespace Hyperscan
} // namespace Regex
} // namespace Extensions
} // namespace Envoy
#endif
#include "test/mocks/server/factory_context.h"

#include "contrib/hyperscan/regex_engines/source/config.h"
#include "gtest/gtest.h"

namespace Envoy {
namespace Extensions {
namespace Regex {
namespace Hyperscan {

class ConfigTest : public ::testing::Test {
protected:
  void setup() {
    envoy::extensions::regex_engines::hyperscan::v3alpha::Hyperscan config;
    Config factory;
    engine_ = factory.createEngine(config, context_);
  }

  NiceMock<Server::Configuration::MockServerFactoryContext> context_;
  Envoy::Regex::EnginePtr engine_;
};

#ifdef HYPERSCAN_DISABLED
// Verify that incompatible architecture will cause a throw.
TEST_F(ConfigTest, IncompatibleArchitecture) {
  EXPECT_THROW_WITH_MESSAGE(setup(), EnvoyException,
                            "X86_64 architecture is required for Hyperscan.");
}
#else
// Verify that matching will be performed successfully.
TEST_F(ConfigTest, Regex) {
  setup();

  Envoy::Regex::CompiledMatcherPtr matcher = engine_->matcher("^/asdf/.+");

  EXPECT_TRUE(matcher->match("/asdf/1"));
  EXPECT_FALSE(matcher->match("/ASDF/1"));
};
#endif

} // namespace Hyperscan
} // namespace Regex
} // namespace Extensions
} // namespace Envoy
#ifndef HYPERSCAN_DISABLED
#include "source/common/thread_local/thread_local_impl.h"

#include "test/mocks/event/mocks.h"
#include "test/test_common/utility.h"

#include "contrib/hyperscan/regex_engines/source/regex.h"
#include "gtest/gtest.h"

namespace Envoy {
namespace Extensions {
namespace Regex {
namespace Hyperscan {

class EngineTest : public ::testing::Test {
protected:
  void setup() { engine_ = std::make_shared<HyperscanEngine>(dispatcher_, instance_); }

  void TearDown() override {
    instance_.shutdownGlobalThreading();
    ::testing::Test::TearDown();
  }

  Event::MockDispatcher dispatcher_;
  ThreadLocal::InstanceImpl instance_;
  std::shared_ptr<HyperscanEngine> engine_;
};

// Verify that the matcher can be populate successfully.
TEST_F(EngineTest, Matcher) {
  setup();

  EXPECT_NO_THROW(engine_->matcher("^/asdf/.+"));
}

} // namespace Hyperscan
} // namespace Regex
} // namespace Extensions
} // namespace Envoy
#endif
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_test",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_test(
    name = "config_test",
    srcs = ["config_test.cc"],
    deps = [
        "//contrib/hyperscan/regex_engines/source:config",
        "//test/mocks/server:factory_context_mocks",
    ],
)

envoy_cc_test(
    name = "regex_test",
    srcs = ["regex_test.cc"],
    deps = [
        "//contrib/hyperscan/regex_engines/source:regex_lib",
        "//source/common/thread_local:thread_local_lib",
        "//test/mocks/event:event_mocks",
        "//test/mocks/server:factory_context_mocks",
    ],
)

envoy_cc_test(
    name = "integration_test",
    srcs = ["integration_test.cc"],
    deps = [
        "//contrib/hyperscan/regex_engines/source:config",
        "//test/integration:integration_lib",
    ],
)
#pragma once

#include "envoy/common/regex.h"

#include "contrib/envoy/extensions/regex_engines/hyperscan/v3alpha/hyperscan.pb.h"
#include "contrib/envoy/extensions/regex_engines/hyperscan/v3alpha/hyperscan.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace Regex {
namespace Hyperscan {

class Config : public Envoy::Regex::EngineFactory {
public:
  // Regex::EngineFactory
  Envoy::Regex::EnginePtr
  createEngine(const Protobuf::Message& config,
               Server::Configuration::ServerFactoryContext& server_factory_context) override;

  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<envoy::extensions::regex_engines::hyperscan::v3alpha::Hyperscan>();
  }
  std::string name() const override { return "envoy.regex_engines.hyperscan"; };
};

} // namespace Hyperscan
} // namespace Regex
} // namespace Extensions
} // namespace Envoy
#include "contrib/hyperscan/regex_engines/source/regex.h"

namespace Envoy {
namespace Extensions {
namespace Regex {
namespace Hyperscan {

HyperscanEngine::HyperscanEngine(Event::Dispatcher& dispatcher, ThreadLocal::SlotAllocator& tls)
    : dispatcher_(dispatcher), tls_(tls) {}

Envoy::Regex::CompiledMatcherPtr HyperscanEngine::matcher(const std::string& regex) const {
  std::vector<const char*> expressions{regex.c_str()};
  std::vector<unsigned int> flags{HS_FLAG_UTF8};
  std::vector<unsigned int> ids{0};

  return std::make_unique<Matching::InputMatchers::Hyperscan::Matcher>(expressions, flags, ids,
                                                                       dispatcher_, tls_, true);
}

} // namespace Hyperscan
} // namespace Regex
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/common/regex.h"

#include "contrib/hyperscan/matching/input_matchers/source/matcher.h"

namespace Envoy {
namespace Extensions {
namespace Regex {
namespace Hyperscan {

class HyperscanEngine : public Envoy::Regex::Engine {
public:
  explicit HyperscanEngine(Event::Dispatcher& dispatcher, ThreadLocal::SlotAllocator& tls);
  Envoy::Regex::CompiledMatcherPtr matcher(const std::string& regex) const override;

private:
  Event::Dispatcher& dispatcher_;
  ThreadLocal::SlotAllocator& tls_;
};

} // namespace Hyperscan
} // namespace Regex
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_library(
    name = "regex_lib",
    srcs = ["regex.cc"],
    hdrs = ["regex.h"],
    deps = [
        "//envoy/common:regex_interface",
    ] + select({
        "//bazel:linux_x86_64": [
            "//contrib/hyperscan/matching/input_matchers/source:hyperscan_matcher_lib",
        ],
        "//bazel:linux_aarch64": [
            "//contrib/hyperscan/matching/input_matchers/source:vectorscan_matcher_lib",
        ],
    }),
)

envoy_cc_contrib_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    defines = select({
        "//bazel:linux_x86_64": [],
        "//bazel:linux_aarch64": [],
        "//conditions:default": [
            "HYPERSCAN_DISABLED=1",
        ],
    }),
    deps = [
        "//envoy/common:regex_interface",
        "@envoy_api//contrib/envoy/extensions/regex_engines/hyperscan/v3alpha:pkg_cc_proto",
    ] + select({
        "//bazel:linux_x86_64": [
            ":regex_lib",
        ],
        "//bazel:linux_aarch64": [
            ":regex_lib",
        ],
        "//conditions:default": [
        ],
    }),
)
#include "contrib/hyperscan/regex_engines/source/config.h"

#ifndef HYPERSCAN_DISABLED
#include "contrib/hyperscan/regex_engines/source/regex.h"
#endif

namespace Envoy {
namespace Extensions {
namespace Regex {
namespace Hyperscan {

Envoy::Regex::EnginePtr
Config::createEngine(const Protobuf::Message& config,
                     Server::Configuration::ServerFactoryContext& server_factory_context) {
  const auto hyperscan = MessageUtil::downcastAndValidate<
      const envoy::extensions::regex_engines::hyperscan::v3alpha::Hyperscan&>(
      config, server_factory_context.messageValidationVisitor());
#ifdef HYPERSCAN_DISABLED
  throw EnvoyException("X86_64 architecture is required for Hyperscan.");
#else
  return std::make_shared<HyperscanEngine>(server_factory_context.mainThreadDispatcher(),
                                           server_factory_context.threadLocal());
#endif
}

REGISTER_FACTORY(Config, Envoy::Regex::EngineFactory);

} // namespace Hyperscan
} // namespace Regex
} // namespace Extensions
} // namespace Envoy
#include <memory>

#include "source/common/buffer/buffer_impl.h"

#include "test/common/stats/stat_test_utility.h"
#include "test/mocks/network/mocks.h"
#include "test/mocks/server/factory_context.h"
#include "test/test_common/printers.h"

#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.h"
#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.validate.h"
#include "contrib/sip_proxy/filters/network/source/app_exception_impl.h"
#include "contrib/sip_proxy/filters/network/source/config.h"
#include "contrib/sip_proxy/filters/network/source/conn_manager.h"
#include "contrib/sip_proxy/filters/network/source/encoder.h"
#include "contrib/sip_proxy/filters/network/test/mocks.h"
#include "contrib/sip_proxy/filters/network/test/utility.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using testing::_;
using testing::NiceMock;
using testing::Return;

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

class TestConfigImpl : public ConfigImpl {
public:
  TestConfigImpl(envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy proto_config,
                 Server::Configuration::MockFactoryContext& context,
                 SipFilters::DecoderFilterSharedPtr decoder_filter, SipFilterStats& stats)
      : ConfigImpl(proto_config, context), decoder_filter_(decoder_filter), stats_(stats) {}

  // ConfigImpl
  SipFilterStats& stats() override { return stats_; }

  SipFilters::DecoderFilterSharedPtr custom_filter_;
  SipFilters::DecoderFilterSharedPtr decoder_filter_;
  SipFilterStats& stats_;
};

class SipConnectionManagerTest : public testing::Test {
public:
  SipConnectionManagerTest()
      : stats_(SipFilterStats::generateStats("test.", *store_.rootScope())),
        transaction_infos_(std::make_shared<Router::TransactionInfos>()) {}
  ~SipConnectionManagerTest() override {
    filter_callbacks_.connection_.dispatcher_.clearDeferredDeleteList();
  }

  void initializeFilter() { initializeFilter(""); }

  void initializeFilter(const std::string& yaml) {
    // Destroy any existing filter first.
    filter_ = nullptr;

    for (const auto& counter : store_.counters()) {
      counter->reset();
    }

    if (yaml.empty()) {
      proto_config_.set_stat_prefix("test");
    } else {
      TestUtility::loadFromYaml(yaml, proto_config_);
      TestUtility::validate(proto_config_);
    }

    proto_config_.set_stat_prefix("test");

    decoder_filter_ = std::make_shared<NiceMock<SipFilters::MockDecoderFilter>>();

    config_ = std::make_unique<TestConfigImpl>(proto_config_, context_, decoder_filter_, stats_);
    EXPECT_EQ(config_->settings()->transactionTimeout(), std::chrono::milliseconds(32000));
    if (custom_filter_) {
      config_->custom_filter_ = custom_filter_;
    }

    EXPECT_CALL(context_, getTransportSocketFactoryContext())
        .WillRepeatedly(testing::ReturnRef(factory_context_));
    EXPECT_CALL(factory_context_.server_context_, localInfo())
        .WillRepeatedly(testing::ReturnRef(local_info_));
    ON_CALL(random_, random()).WillByDefault(Return(42));
    filter_ = std::make_unique<ConnectionManager>(
        *config_, random_, filter_callbacks_.connection_.dispatcher_.timeSource(), context_,
        transaction_infos_);
    filter_->initializeReadFilterCallbacks(filter_callbacks_);
    filter_->onNewConnection();

    // NOP currently.
    filter_->onAboveWriteBufferHighWatermark();
    filter_->onBelowWriteBufferLowWatermark();
  }

  void
  sendLocalReply(Envoy::Extensions::NetworkFilters::SipProxy::DirectResponse::ResponseType type) {
    const std::string yaml = R"EOF(
stat_prefix: egress
route_config:
  name: local_route
  routes:
  - match:
      domain: "pcsf-cfed.cncs.svc.cluster.local"
      header: ""
      parameter: "x-suri"
    route:
      cluster: "test"
settings:
  transaction_timeout: 32s
  local_services:
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : transport
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : x-suri
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : host
)EOF";
    initializeFilter(yaml);
    MessageMetadata metadata;
    const MockDirectResponse response;
    EXPECT_CALL(response, encode(_, _)).WillRepeatedly(Return(type));
    filter_->sendLocalReply(metadata, response, true);
  }

  void upstreamDataTest() {
    const std::string yaml = R"EOF(
stat_prefix: egress
route_config:
  name: local_route
  routes:
  - match:
      domain: "pcsf-cfed.cncs.svc.cluster.local"
      header: ""
      parameter: "x-suri"
    route:
      cluster: "test"
settings:
  transaction_timeout: 32s
  local_services:
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : transport
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : x-suri
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : host
)EOF";
    initializeFilter(yaml);

    const std::string SIP_INVITE_WRONG_CONTENT_LENGTH =
        "INVITE sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
        "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
        "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
        "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
        "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
        "CSeq: 1 INVITE\x0d\x0a"
        "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
        "Supported: 100rel\x0d\x0a"
        "Route: "
        "<sip:+16959000000:15306;role=anch;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060lr;"
        "transport=udp>\x0d\x0a"
        "P-Asserted-Identity: <sip:User.0001@tas01.defult.svc.cluster.local>\x0d\x0a"
        "Allow: UPDATE,INVITE,ACK,CANCEL,BYE,PRACK,REFER,MESSAGE,INFO\x0d\x0a"
        "Max-Forwards: 70\x0d\x0a"
        "Content-Type: application/sdp\x0d\x0a"
        "Content-Length:  300\x0d\x0a"
        "\x0d\x0a"
        "v=0\x0d\x0a"
        "o=PCTEL 256 2 IN IP4 11.0.0.10\x0d\x0a"
        "c=IN IP4 11.0.0.10\x0d\x0a"
        "m=audio 4030 RTP/AVP 0 8\x0d\x0a"
        "a=rtpmap:0 PCMU/8000\x0d\x0a"
        "a=rtpmap:8 PCMU/8000\x0d\x0a";

    buffer_.add(SIP_INVITE_WRONG_CONTENT_LENGTH);

    // The "Content-Length" is larger to make reassemble do not call complete()
    filter_->decoder_->reassemble(buffer_);
    filter_->decoder_->metadata_ = std::make_shared<MessageMetadata>(buffer_.toString());
    filter_->decoder_->decode();
    ConnectionManager::ActiveTransPtr trans =
        std::make_unique<ConnectionManager::ActiveTrans>(*filter_, filter_->decoder_->metadata());
    trans->startUpstreamResponse();
    trans->upstreamData(filter_->decoder_->metadata_);

    // TransportBegin
    struct MockResponseDecoderTransportBegin : public ConnectionManager::ResponseDecoder {
      MockResponseDecoderTransportBegin(ConnectionManager::ActiveTrans& parent)
          : ConnectionManager::ResponseDecoder(parent) {}
      FilterStatus transportBegin(MessageMetadataSharedPtr) override {
        return FilterStatus::StopIteration;
      }
    };
    MockResponseDecoderTransportBegin decoder_transportBegin(*trans);
    trans->response_decoder_ =
        std::make_unique<MockResponseDecoderTransportBegin>(decoder_transportBegin);
    trans->upstreamData(filter_->decoder_->metadata_);

    // MessageBegin
    struct MockResponseDecoderMessageBegin : public ConnectionManager::ResponseDecoder {
      MockResponseDecoderMessageBegin(ConnectionManager::ActiveTrans& parent)
          : ConnectionManager::ResponseDecoder(parent) {}
      FilterStatus messageBegin(MessageMetadataSharedPtr) override {
        return FilterStatus::StopIteration;
      }
    };
    MockResponseDecoderMessageBegin decoder_messageBegin(*trans);
    trans->response_decoder_ =
        std::make_unique<MockResponseDecoderMessageBegin>(decoder_messageBegin);
    trans->upstreamData(filter_->decoder_->metadata_);

    // MessageEnd
    struct MockResponseDecoderMessageEnd : public ConnectionManager::ResponseDecoder {
      MockResponseDecoderMessageEnd(ConnectionManager::ActiveTrans& parent)
          : ConnectionManager::ResponseDecoder(parent) {}
      FilterStatus messageEnd() override { return FilterStatus::StopIteration; }
    };
    MockResponseDecoderMessageEnd decoder_messageEnd(*trans);
    trans->response_decoder_ = std::make_unique<MockResponseDecoderMessageEnd>(decoder_messageEnd);
    trans->upstreamData(filter_->decoder_->metadata_);
    EXPECT_NE(nullptr, trans->connection());

    // TransportEnd
    struct MockResponseDecoderTransportEnd : public ConnectionManager::ResponseDecoder {
      MockResponseDecoderTransportEnd(ConnectionManager::ActiveTrans& parent)
          : ConnectionManager::ResponseDecoder(parent) {}
      FilterStatus transportEnd() override { return FilterStatus::StopIteration; }
    };
    MockResponseDecoderTransportEnd decoder_transportEnd(*trans);
    trans->response_decoder_ =
        std::make_unique<MockResponseDecoderTransportEnd>(decoder_transportEnd);
    trans->upstreamData(filter_->decoder_->metadata_);
    filter_->continueHandling(filter_->decoder_->metadata_,
                              filter_->newDecoderEventHandler(filter_->decoder_->metadata()));

    // AppException
    struct MockResponseDecoderAppException : public ConnectionManager::ResponseDecoder {
      MockResponseDecoderAppException(ConnectionManager::ActiveTrans& parent)
          : ConnectionManager::ResponseDecoder(parent) {}
      FilterStatus transportBegin(MessageMetadataSharedPtr) override {
        throw AppException(AppExceptionType::ProtocolError, "MockResponseDecoderAppException");
      }
    };
    MockResponseDecoderAppException decoder_appException(*trans);
    trans->response_decoder_ =
        std::make_unique<MockResponseDecoderAppException>(decoder_appException);
    try {
      trans->upstreamData(filter_->decoder_->metadata_);
    } catch (const EnvoyException& ex) {
      filter_->stats_.response_exception_.inc();
      EXPECT_EQ(1U, filter_->stats_.response_exception_.value());
    }

    // EnvoyException
    struct MockResponseDecoderEnvoyException : public ConnectionManager::ResponseDecoder {
      MockResponseDecoderEnvoyException(ConnectionManager::ActiveTrans& parent)
          : ConnectionManager::ResponseDecoder(parent) {}
      FilterStatus transportBegin(MessageMetadataSharedPtr) override {
        throw EnvoyException("MockResponseDecoderEnvoyException");
      }
    };
    MockResponseDecoderEnvoyException decoder_envoyException(*trans);
    trans->response_decoder_ =
        std::make_unique<MockResponseDecoderEnvoyException>(decoder_envoyException);
    try {
      trans->upstreamData(filter_->decoder_->metadata_);
    } catch (const EnvoyException& ex) {
      filter_->stats_.response_exception_.inc();
      EXPECT_EQ(2U, filter_->stats_.response_exception_.value());
    }

    // transportEnd throw envoyException
    filter_->decoder_->reassemble(buffer_);
    filter_->decoder_->metadata_ = std::make_shared<MessageMetadata>(buffer_.toString());
    filter_->decoder_->decode();
    filter_->read_callbacks_->connection().setDelayedCloseTimeout(std::chrono::milliseconds(1));
    filter_->read_callbacks_->connection().close(Network::ConnectionCloseType::NoFlush);
    ConnectionManager::ActiveTransPtr trans1 =
        std::make_unique<ConnectionManager::ActiveTrans>(*filter_, filter_->decoder_->metadata());
    try {
      ConnectionManager::ResponseDecoder response_decoder(*trans1);
      response_decoder.newDecoderEventHandler(filter_->decoder_->metadata());
      // transportEnd throw envoyException
      response_decoder.onData(filter_->decoder_->metadata());
    } catch (const EnvoyException& ex) {
      filter_->stats_.response_exception_.inc();
      EXPECT_EQ(4U, filter_->stats_.response_exception_.value());
    }

    // end_stream = false
    ConnectionManager::ActiveTransPtr trans2 =
        std::make_unique<ConnectionManager::ActiveTrans>(*filter_, filter_->decoder_->metadata());
    trans2->sendLocalReply(AppException(AppExceptionType::ProtocolError, "End_stream is false"),
                           false);

    // route() with metadata=nullptr;
    ConnectionManager::ActiveTransPtr trans3 =
        std::make_unique<ConnectionManager::ActiveTrans>(*filter_, filter_->decoder_->metadata());
    trans3->metadata_ = nullptr;
    EXPECT_EQ(nullptr, trans3->route());

    trans3->resetDownstreamConnection();
  }

  void resetAllTransTest(bool local_reset) {
    // int before = stats_.cx_destroy_local_with_active_rq_;
    const std::string yaml = R"EOF(
stat_prefix: egress
route_config:
  name: local_route
  routes:
  - match:
      domain: "pcsf-cfed.cncs.svc.cluster.local"
      header: "Route"
      parameter: "x-suri"
    route:
      cluster: "test"
settings:
  transaction_timeout: 32s
  local_services:
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : transport
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : x-suri
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : host
)EOF";
    initializeFilter(yaml);

    const std::string SIP_ACK_FULL =
        "ACK sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
        "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
        "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
        "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
        "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
        "CSeq: 1 ACK\x0d\x0a"
        "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
        "Supported: 100rel\x0d\x0a"
        "Route: "
        "<sip:+16959000000:15306;role=anch;lr;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;"
        "transport=udp>\x0d\x0a"
        "P-Asserted-Identity: <sip:User.0001@tas01.defult.svc.cluster.local>\x0d\x0a"
        "Allow: UPDATE,INVITE,ACK,CANCEL,BYE,PRACK,REFER,MESSAGE,INFO\x0d\x0a"
        "Max-Forwards: 70\x0d\x0a"
        "Content-Type: application/sdp\x0d\x0a"
        "Content-Length:  127\x0d\x0a"
        "\x0d\x0a";
    buffer_.add(SIP_ACK_FULL);

    filter_->decoder_->reassemble(buffer_);
    filter_->decoder_->metadata_ = std::make_shared<MessageMetadata>(buffer_.toString());
    filter_->decoder_->decode();

    MessageMetadataSharedPtr metadata = filter_->decoder_->metadata_;
    std::string&& k = std::string(metadata->transactionId().value());
    ConnectionManager::ActiveTransPtr new_trans =
        std::make_unique<ConnectionManager::ActiveTrans>(*filter_, metadata);
    new_trans->createFilterChain();
    filter_->transactions_.emplace(k, std::move(new_trans));
    filter_->newDecoderEventHandler(metadata);
    filter_->resetAllTrans(local_reset);
  }

  void resumeResponseTest() {
    const std::string yaml = R"EOF(
stat_prefix: egress
route_config:
  name: local_route
  routes:
  - match:
      domain: "pcsf-cfed.cncs.svc.cluster.local"
      header: "Route"
      parameter: "x-suri"
    route:
      cluster: "test"
settings:
  transaction_timeout: 32s
  local_services:
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : transport
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : x-suri
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : host
)EOF";
    initializeFilter(yaml);

    const std::string SIP_ACK_FULL =
        "ACK sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
        "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
        "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
        "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
        "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
        "CSeq: 1 ACK\x0d\x0a"
        "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
        "Supported: 100rel\x0d\x0a"
        "Route: "
        "<sip:+16959000000:15306;role=anch;lr;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;"
        "transport=udp>\x0d\x0a"
        "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
        "P-Asserted-Identity: <sip:User.0001@tas01.defult.svc.cluster.local>\x0d\x0a"
        "Allow: UPDATE,INVITE,ACK,CANCEL,BYE,PRACK,REFER,MESSAGE,INFO\x0d\x0a"
        "Max-Forwards: 70\x0d\x0a"
        "Content-Type: application/sdp\x0d\x0a"
        "Content-Length:  127\x0d\x0a"
        "\x0d\x0a";
    buffer_.add(SIP_ACK_FULL);

    filter_->decoder_->reassemble(buffer_);
    filter_->decoder_->metadata_ = std::make_shared<MessageMetadata>(buffer_.toString());
    filter_->decoder_->decode();

    MessageMetadataSharedPtr metadata = filter_->decoder_->metadata_;
    ConnectionManager::ActiveTransPtr new_trans =
        std::make_unique<ConnectionManager::ActiveTrans>(*filter_, metadata);

    new_trans->filter_action_ = [&](DecoderEventHandler* filter) -> FilterStatus {
      UNREFERENCED_PARAMETER(filter);
      new_trans->local_response_sent_ = true;
      return FilterStatus::StopIteration;
    };

    std::list<ConnectionManager::ActiveTransDecoderFilterPtr> decoder_filter_list;
    ConnectionManager::ActiveTransDecoderFilterPtr wrapper =
        std::make_unique<ConnectionManager::ActiveTransDecoderFilter>(*new_trans, decoder_filter_);
    decoder_filter_->setDecoderFilterCallbacks(*wrapper);
    LinkedList::moveIntoListBack(std::move(wrapper), decoder_filter_list);

    std::shared_ptr<SipFilters::MockDecoderFilter> decoder_filter_1 =
        std::make_shared<NiceMock<SipFilters::MockDecoderFilter>>();
    ConnectionManager::ActiveTransDecoderFilterPtr wrapper2 =
        std::make_unique<ConnectionManager::ActiveTransDecoderFilter>(*new_trans, decoder_filter_1);
    LinkedList::moveIntoListBack(std::move(wrapper2), decoder_filter_list);

    new_trans->applyDecoderFilters((*(decoder_filter_list.begin())).get());

    // Other ActiveTransDecoderFilter  function cover
    ConnectionManager::ActiveTransDecoderFilterPtr decoder =
        std::make_unique<ConnectionManager::ActiveTransDecoderFilter>(*new_trans, decoder_filter_);
    EXPECT_EQ(decoder->streamId(), new_trans->streamId());
    EXPECT_EQ(decoder->connection(), new_trans->connection());
    decoder->startUpstreamResponse();
    decoder->streamInfo();
    decoder->upstreamData(metadata);
    decoder->resetDownstreamConnection();
    filter_->transactions_.emplace(std::string(metadata->transactionId().value()),
                                   std::move(new_trans));
    decoder->onReset();
  }

  NiceMock<Server::Configuration::MockFactoryContext> context_;
  NiceMock<Server::Configuration::MockTransportSocketFactoryContext> factory_context_;
  NiceMock<LocalInfo::MockLocalInfo> local_info_;
  std::shared_ptr<SipFilters::MockDecoderFilter> decoder_filter_;
  Stats::TestUtil::TestStore store_;
  SipFilterStats stats_;
  envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy proto_config_;

  std::unique_ptr<TestConfigImpl> config_;

  Buffer::OwnedImpl buffer_;
  Buffer::OwnedImpl write_buffer_;
  NiceMock<Network::MockReadFilterCallbacks> filter_callbacks_;
  NiceMock<Random::MockRandomGenerator> random_;
  std::unique_ptr<ConnectionManager> filter_;
  std::shared_ptr<Router::TransactionInfos> transaction_infos_;
  SipFilters::DecoderFilterSharedPtr custom_filter_;
  MessageMetadataSharedPtr metadata_;
};

TEST_F(SipConnectionManagerTest, OnDataHandlesSipCall) {
  const std::string yaml = R"EOF(
stat_prefix: egress
route_config:
  name: local_route
  routes:
  - match:
      domain: "pcsf-cfed.cncs.svc.cluster.local"
      header: "Route"
      parameter: "x-suri"
    route:
      cluster: "test"
settings:
  transaction_timeout: 32s
  local_services:
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : transport
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : x-suri
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : host
)EOF";
  initializeFilter(yaml);

  const std::string SIP_INVITE_FULL =
      "INVITE sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.11:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "CSeq: 1 INVITE\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "Supported: 100rel\x0d\x0a"
      "Route: "
      "<sip:+16959000000:15306;role=anch;lr;transport=udp;x-suri=sip:pcsf-cfed.cncs.svc.cluster."
      "local:5060>\x0d\x0a"
      "P-Asserted-Identity: <sip:User.0001@tas01.defult.svc.cluster.local>\x0d\x0a"
      "Allow: UPDATE,INVITE,ACK,CANCEL,BYE,PRACK,REFER,MESSAGE,INFO\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Type: application/sdp\x0d\x0a"
      "Content-Length:  127\x0d\x0a"
      "\x0d\x0a"
      "v=0\x0d\x0a"
      "o=PCTEL 256 2 IN IP4 11.0.0.10\x0d\x0a"
      "c=IN IP4 11.0.0.10\x0d\x0a"
      "m=audio 4030 RTP/AVP 0 8\x0d\x0a"
      "a=rtpmap:0 PCMU/8000\x0d\x0a"
      "a=rtpmap:8 PCMU/8000\x0d\x0a";

  buffer_.add(SIP_INVITE_FULL);

  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);
  EXPECT_EQ(filter_->onData(buffer_, true), Network::FilterStatus::StopIteration);
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());

  const std::string SIP_ACK_FULL =
      "ACK sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "CSeq: 1 ACK\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "Supported: 100rel\x0d\x0a"
      "Route: "
      "<sip:+16959000000:15306;role=anch;lr;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;"
      "transport=udp>\x0d\x0a"
      "P-Asserted-Identity: <sip:User.0001@tas01.defult.svc.cluster.local>\x0d\x0a"
      "Allow: UPDATE,INVITE,ACK,CANCEL,BYE,PRACK,REFER,MESSAGE,INFO\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Type: application/sdp\x0d\x0a"
      "Content-Length:  127\x0d\x0a"
      "\x0d\x0a";
  write_buffer_.add(SIP_ACK_FULL);
  EXPECT_EQ(filter_->onData(write_buffer_, false), Network::FilterStatus::StopIteration);
}

TEST_F(SipConnectionManagerTest, OnDataHandlesSipCallDefaultMatch) {
  const std::string yaml = R"EOF(
stat_prefix: egress
route_config:
  name: local_route
  routes:
  - match:
      domain: "pcsf-cfed.cncs.svc.cluster.local"
    route:
      cluster: "test"
settings:
  transaction_timeout: 32s
  local_services:
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : transport
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : x-suri
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : host
)EOF";
  initializeFilter(yaml);

  const std::string SIP_INVITE_FULL =
      "INVITE sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.11:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "CSeq: 1 INVITE\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "Supported: 100rel\x0d\x0a"
      "Route: "
      "<sip:pcsf-cfed.cncs.svc.cluster.local;role=anch;lr;transport=udp;x-suri=sip:pcsf-cfed.cncs."
      "svc.cluster.local:5060>\x0d\x0a"
      "P-Asserted-Identity: <sip:User.0001@tas01.defult.svc.cluster.local>\x0d\x0a"
      "Allow: UPDATE,INVITE,ACK,CANCEL,BYE,PRACK,REFER,MESSAGE,INFO\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Type: application/sdp\x0d\x0a"
      "Content-Length:  127\x0d\x0a"
      "\x0d\x0a"
      "v=0\x0d\x0a"
      "o=PCTEL 256 2 IN IP4 11.0.0.10\x0d\x0a"
      "c=IN IP4 11.0.0.10\x0d\x0a"
      "m=audio 4030 RTP/AVP 0 8\x0d\x0a"
      "a=rtpmap:0 PCMU/8000\x0d\x0a"
      "a=rtpmap:8 PCMU/8000\x0d\x0a";

  buffer_.add(SIP_INVITE_FULL);

  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipConnectionManagerTest, OnDataHandlesSipCallEndStream) {
  const std::string yaml = R"EOF(
stat_prefix: egress
route_config:
  name: local_route
  routes:
  - match:
      domain: "pcsf-cfed.cncs.svc.cluster.local"
      header: "Record-Route"
      parameter: "x-suri"
    route:
      cluster: "test"
settings:
  transaction_timeout: 32s
  local_services:
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : transport
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : x-suri
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : host
)EOF";
  initializeFilter(yaml);

  const std::string SIP_INVITE_FULL =
      "INVITE sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "CSeq: 1 INVITE\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "Supported: 100rel\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Record-Route: "
      "<sip:+16959000000:15306;role=anch;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;lr;"
      "transport=udp>\x0d\x0a"
      "P-Asserted-Identity: <sip:User.0001@tas01.defult.svc.cluster.local>\x0d\x0a"
      "Allow: UPDATE,INVITE,ACK,CANCEL,BYE,PRACK,REFER,MESSAGE,INFO\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Type: application/sdp\x0d\x0a"
      "Content-Length:  127\x0d\x0a"
      "\x0d\x0a"
      "v=0\x0d\x0a"
      "o=PCTEL 256 2 IN IP4 11.0.0.10\x0d\x0a"
      "c=IN IP4 11.0.0.10\x0d\x0a"
      "m=audio 4030 RTP/AVP 0 8\x0d\x0a"
      "a=rtpmap:0 PCMU/8000\x0d\x0a"
      "a=rtpmap:8 PCMU/8000\x0d\x0a";

  buffer_.add(SIP_INVITE_FULL);

  EXPECT_EQ(filter_->onData(buffer_, true), Network::FilterStatus::StopIteration);
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipConnectionManagerTest, ContinueHandling) {
  initializeFilter();
  filter_->continueHandling("10.0.0.1");
}

TEST_F(SipConnectionManagerTest, SendLocalReply_SuccessReply) {
  sendLocalReply(
      Envoy::Extensions::NetworkFilters::SipProxy::DirectResponse::ResponseType::SuccessReply);
}

TEST_F(SipConnectionManagerTest, SendLocalReply_ErrorReply) {
  sendLocalReply(
      Envoy::Extensions::NetworkFilters::SipProxy::DirectResponse::ResponseType::ErrorReply);
}

TEST_F(SipConnectionManagerTest, SendLocalReply_Exception) {
  sendLocalReply(
      Envoy::Extensions::NetworkFilters::SipProxy::DirectResponse::ResponseType::Exception);
}

TEST_F(SipConnectionManagerTest, UpstreamData) { upstreamDataTest(); }

TEST_F(SipConnectionManagerTest, ResetLocalTrans) {
  resetAllTransTest(true);
  EXPECT_EQ(1U, store_.counter("test.cx_destroy_local_with_active_rq").value());
}

TEST_F(SipConnectionManagerTest, ResetRemoteTrans) {
  resetAllTransTest(false);
  EXPECT_EQ(1U, store_.counter("test.cx_destroy_remote_with_active_rq").value());
}
TEST_F(SipConnectionManagerTest, ResumeResponse) { resumeResponseTest(); }

TEST_F(SipConnectionManagerTest, EncodeInsertOpaque) {
  const std::string SIP_OK200_FULL =
      "SIP/2.0 200 OK\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "CSeq: 1 INVITE\x0d\x0a"
      "Contact: "
      "<sip:User.0001@11.0.0.10:15060;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;transport="
      "TCP>\x0d\x0a"
      "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";

  buffer_.add(SIP_OK200_FULL);

  absl::string_view header =
      "Contact: <sip:User.0001@11.0.0.10:15060;x-suri=sip:pcsf-cfed.cncs.svc.cluster."
      "local:5060;transport=TCP>";
  metadata_ = std::make_shared<MessageMetadata>(buffer_.toString());
  metadata_->addOpaqueOperation(SIP_OK200_FULL.find("Contact: "), header);
  Buffer::OwnedImpl response_buffer;
  metadata_->setEP("127.0.0.1");

  std::shared_ptr<EncoderImpl> encoder = std::make_shared<EncoderImpl>();
  encoder->encode(metadata_, response_buffer);
  EXPECT_EQ(response_buffer.length(), buffer_.length() + strlen(",opaque=\"127.0.0.1\""));
}

TEST_F(SipConnectionManagerTest, EncodeInsert) {
  const std::string SIP_OK200_FULL =
      "SIP/2.0 200 OK\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "CSeq: 1 INVITE\x0d\x0a"
      "Contact: "
      "<sip:User.0001@11.0.0.10:15060;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;transport="
      "TCP>\x0d\x0a"
      "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";

  buffer_.add(SIP_OK200_FULL);

  metadata_ = std::make_shared<MessageMetadata>(buffer_.toString());
  metadata_->setOperation(Operation(OperationType::Insert,
                                    SIP_OK200_FULL.find(";transport=TCP") + strlen(";transport="),
                                    InsertOperationValue(";ep=10.0.0.1")));
  Buffer::OwnedImpl response_buffer;

  std::shared_ptr<EncoderImpl> encoder = std::make_shared<EncoderImpl>();
  encoder->encode(metadata_, response_buffer);
  EXPECT_EQ(response_buffer.length(), buffer_.length() + strlen(";ep=10.0.0.1"));
}

TEST_F(SipConnectionManagerTest, EncodeDelete) {
  const std::string SIP_OK200_FULL =
      "SIP/2.0 200 OK\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "CSeq: 1 INVITE\x0d\x0a"
      "Contact: "
      "<sip:User.0001@11.0.0.10:15060;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;transport="
      "TCP>\x0d\x0a"
      "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";

  buffer_.add(SIP_OK200_FULL);

  metadata_ = std::make_shared<MessageMetadata>(buffer_.toString());
  metadata_->setOperation(Operation(OperationType::Delete, SIP_OK200_FULL.find(";transport="),
                                    DeleteOperationValue(strlen(";transport=TCP"))));
  Buffer::OwnedImpl response_buffer;

  std::shared_ptr<EncoderImpl> encoder = std::make_shared<EncoderImpl>();
  encoder->encode(metadata_, response_buffer);
  EXPECT_EQ(response_buffer.length(), buffer_.length() - strlen(";transport=TCP"));
}

TEST_F(SipConnectionManagerTest, EncodeModify) {
  const std::string SIP_OK200_FULL =
      "SIP/2.0 200 OK\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "CSeq: 1 INVITE\x0d\x0a"
      "Contact: "
      "<sip:User.0001@11.0.0.10:15060;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;transport="
      "TCP>\x0d\x0a"
      "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";

  buffer_.add(SIP_OK200_FULL);

  metadata_ = std::make_shared<MessageMetadata>(buffer_.toString());
  metadata_->setOperation(Operation(OperationType::Modify,
                                    SIP_OK200_FULL.find(";transport=") + strlen(";transport="),
                                    ModifyOperationValue(strlen("TCP"), "SCTP")));
  Buffer::OwnedImpl response_buffer;

  std::shared_ptr<EncoderImpl> encoder = std::make_shared<EncoderImpl>();
  encoder->encode(metadata_, response_buffer);
  EXPECT_EQ(response_buffer.length(), buffer_.length() - strlen("TCP") + strlen("SCTP"));
}

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/sip_proxy/filters/network/test/mocks.h"

#include <memory>

#include "source/common/protobuf/protobuf.h"

#include "gtest/gtest.h"

using testing::_;
using testing::Return;
using testing::ReturnRef;

namespace Envoy {

// Provide a specialization for ProtobufWkt::Struct (for MockFilterConfigFactory)
template <>
void MessageUtil::validate(const ProtobufWkt::Struct&, ProtobufMessage::ValidationVisitor&, bool) {}

namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

MockConfig::MockConfig() = default;
MockConfig::~MockConfig() = default;

MockDecoderCallbacks::MockDecoderCallbacks() = default;
MockDecoderCallbacks::~MockDecoderCallbacks() = default;

MockDecoderEventHandler::MockDecoderEventHandler() {
  ON_CALL(*this, transportBegin(_)).WillByDefault(Return(FilterStatus::Continue));
  ON_CALL(*this, transportEnd()).WillByDefault(Return(FilterStatus::Continue));
  ON_CALL(*this, messageBegin(_)).WillByDefault(Return(FilterStatus::Continue));
  ON_CALL(*this, messageEnd()).WillByDefault(Return(FilterStatus::Continue));
}
MockDecoderEventHandler::~MockDecoderEventHandler() = default;

MockDirectResponse::MockDirectResponse() = default;
MockDirectResponse::~MockDirectResponse() = default;

namespace SipFilters {

MockDecoderFilter::MockDecoderFilter() {
  ON_CALL(*this, transportBegin(_)).WillByDefault(Return(FilterStatus::Continue));
  ON_CALL(*this, transportEnd()).WillByDefault(Return(FilterStatus::Continue));
  ON_CALL(*this, messageBegin(_)).WillByDefault(Return(FilterStatus::Continue));
  ON_CALL(*this, messageEnd()).WillByDefault(Return(FilterStatus::Continue));
}
MockDecoderFilter::~MockDecoderFilter() = default;

MockDecoderFilterCallbacks::MockDecoderFilterCallbacks()
    : stats_(SipFilterStats::generateStats("test", *store_.rootScope())) {

  ON_CALL(*this, streamId()).WillByDefault(Return(stream_id_));
  ON_CALL(*this, transactionInfos()).WillByDefault(Return(transaction_infos_));
  ON_CALL(*this, streamInfo()).WillByDefault(ReturnRef(connection_.stream_info_));
  ON_CALL(*this, stats()).WillByDefault(ReturnRef(stats_));
}
MockDecoderFilterCallbacks::~MockDecoderFilterCallbacks() = default;

MockFilterConfigFactory::MockFilterConfigFactory() : name_("envoy.filters.sip.mock_filter") {
  mock_filter_ = std::make_shared<NiceMock<MockDecoderFilter>>();
}

MockFilterConfigFactory::~MockFilterConfigFactory() = default;

FilterFactoryCb MockFilterConfigFactory::createFilterFactoryFromProto(
    const Protobuf::Message& proto_config, const std::string& stats_prefix,
    Server::Configuration::FactoryContext& context) {
  UNREFERENCED_PARAMETER(context);

  config_struct_ = dynamic_cast<const ProtobufWkt::Struct&>(proto_config);
  config_stat_prefix_ = stats_prefix;

  return [this](FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addDecoderFilter(mock_filter_);
  };
}

} // namespace SipFilters
//
namespace Router {

MockRouteEntry::MockRouteEntry() {
  ON_CALL(*this, clusterName()).WillByDefault(ReturnRef(cluster_name_));
}
MockRouteEntry::~MockRouteEntry() = default;

MockRoute::MockRoute() { ON_CALL(*this, routeEntry()).WillByDefault(Return(&route_entry_)); }
MockRoute::~MockRoute() = default;

} // namespace Router

MockConnectionManager::~MockConnectionManager() = default;

MockTrafficRoutingAssistantHandler::MockTrafficRoutingAssistantHandler(
    ConnectionManager& parent, Event::Dispatcher& dispatcher,
    const envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceConfig& config,
    Server::Configuration::FactoryContext& context, StreamInfo::StreamInfoImpl& stream_info)
    : TrafficRoutingAssistantHandler(parent, dispatcher, config, context, stream_info) {
  ON_CALL(*this, retrieveTrafficRoutingAssistant(_, _, _, _, _))
      .WillByDefault(
          Invoke([&](const std::string&, const std::string&, const absl::optional<TraContextMap>,
                     SipFilters::DecoderFilterCallbacks&, std::string& host) -> QueryStatus {
            host = "10.0.0.11";
            return QueryStatus::Continue;
          }));
}

MockTrafficRoutingAssistantHandler::~MockTrafficRoutingAssistantHandler() = default;

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "source/common/buffer/buffer_impl.h"

#include "contrib/sip_proxy/filters/network/source/app_exception_impl.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

TEST(AppExceptionImplTest, CopyConstructor) {
  AppException app_ex(AppExceptionType::InternalError, "msg");
  AppException copy(app_ex);

  EXPECT_EQ(app_ex.type_, copy.type_);
  EXPECT_STREQ("msg", copy.what());
}

TEST(AppExceptionImplTest, EncodeWithoutNecessaryHeaders) {
  AppException app_ex(AppExceptionType::InternalError, "msg");
  MessageMetadata metadata;
  Buffer::OwnedImpl buffer;
  app_ex.encode(metadata, buffer);
}

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include <memory>

#include "test/mocks/server/factory_context.h"
#include "test/test_common/registry.h"

#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.h"
#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.validate.h"
#include "contrib/sip_proxy/filters/network/source/config.h"
#include "contrib/sip_proxy/filters/network/source/filters/factory_base.h"
#include "contrib/sip_proxy/filters/network/test/mocks.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using testing::_;
using testing::Return;

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

namespace {

envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy
parseSipProxyFromYaml(const std::string& yaml) {
  envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy sip_proxy;
  TestUtility::loadFromYaml(yaml, sip_proxy);
  return sip_proxy;
}
} // namespace

class SipFilterConfigTestBase {
public:
  void testConfig(envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy& config) {
    Network::FilterFactoryCb cb;
    EXPECT_NO_THROW({ cb = factory_.createFilterFactoryFromProto(config, context_); });
    EXPECT_TRUE(factory_.isTerminalFilterByProto(config, context_.serverFactoryContext()));

    Network::MockConnection connection;
    EXPECT_CALL(connection, addReadFilter(_));
    cb(connection);
  }

  NiceMock<Server::Configuration::MockFactoryContext> context_;
  SipProxyFilterConfigFactory factory_;
};

class SipFilterConfigTest : public testing::Test, public SipFilterConfigTestBase {};

TEST_F(SipFilterConfigTest, ValidateFail) {
  EXPECT_THROW(factory_.createFilterFactoryFromProto(
                   envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy(), context_),
               ProtoValidationException);
}

TEST_F(SipFilterConfigTest, ValidProtoConfiguration) {
  envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy config{};
  config.set_stat_prefix("my_stat_prefix");

  testConfig(config);
}

TEST_F(SipFilterConfigTest, SipProxyWithEmptyProto) {
  envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy config =
      *dynamic_cast<envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy*>(
          factory_.createEmptyConfigProto().get());
  config.set_stat_prefix("my_stat_prefix");

  testConfig(config);
}

// Test config with an invalid cluster_header.
TEST_F(SipFilterConfigTest, RouterConfigWithValidCluster) {
  const std::string yaml = R"EOF(
stat_prefix: sip
route_config:
  name: local_route
  routes:
    match:
      domain: A
    route:
      cluster: A
sip_filters:
  - name: envoy.filters.sip.router
    typed_config:
      "@type": type.googleapis.com/envoy.extensions.filters.network.sip_proxy.router.v3alpha.Router
)EOF";

  envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy config =
      parseSipProxyFromYaml(yaml);
  std::string cluster = "A";
  config.mutable_route_config()->mutable_routes()->at(0).mutable_route()->set_cluster(cluster);
  EXPECT_NO_THROW({ factory_.createFilterFactoryFromProto(config, context_); });
}

// Test config with an explicitly defined router filter.
TEST_F(SipFilterConfigTest, SipProxyWithExplicitRouterConfig) {
  const std::string yaml = R"EOF(
stat_prefix: sip
route_config:
  name: local_route
sip_filters:
  - name: envoy.filters.sip.router
    typed_config:
      "@type": type.googleapis.com/envoy.extensions.filters.network.sip_proxy.router.v3alpha.Router
)EOF";

  envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy config =
      parseSipProxyFromYaml(yaml);
  testConfig(config);
}

// Test config with an unknown filter.
TEST_F(SipFilterConfigTest, SipProxyWithUnknownFilter) {
  const std::string yaml = R"EOF(
stat_prefix: sip
route_config:
  name: local_route
sip_filters:
  - name: no_such_filter
  - name: envoy.filters.sip.router
    typed_config:
      "@type": type.googleapis.com/envoy.extensions.filters.network.sip_proxy.router.v3alpha.Router
)EOF";

  envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy config =
      parseSipProxyFromYaml(yaml);

  EXPECT_THROW_WITH_REGEX(factory_.createFilterFactoryFromProto(config, context_), EnvoyException,
                          "no_such_filter");
}

// Test config with multiple filters.
TEST_F(SipFilterConfigTest, SipProxyWithMultipleFilters) {
  const std::string yaml = R"EOF(
stat_prefix: ingress
route_config:
  name: local_route
sip_filters:
  - name: envoy.filters.sip.mock_filter
    typed_config:
      "@type": type.googleapis.com/google.protobuf.Struct
      value:
        key: value
  - name: envoy.filters.sip.router
    typed_config:
      "@type": type.googleapis.com/envoy.extensions.filters.network.sip_proxy.router.v3alpha.Router
settings:
  transaction_timeout: 32s
  local_services:
  - domain: pcsf-cfed.cncs.svc.cluster.local
)EOF";

  SipFilters::MockFilterConfigFactory factory;
  Registry::InjectFactory<SipFilters::NamedSipFilterConfigFactory> registry(factory);

  envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy config =
      parseSipProxyFromYaml(yaml);
  testConfig(config);

  EXPECT_EQ(1, factory.config_struct_.fields_size());
  EXPECT_EQ("value", factory.config_struct_.fields().at("key").string_value());
  EXPECT_EQ("sip.ingress.", factory.config_stat_prefix_);
}

// Test SipProtocolOptions
TEST_F(SipFilterConfigTest, SipProtocolOptions) {
  const std::string yaml = R"EOF(
session_affinity: true
registration_affinity: true
customized_affinity:
  entries:
  - key_name: test
    subscribe: true
    query: true
  - key_name: test1
  stop_load_balance: false
)EOF";

  envoy::extensions::filters::network::sip_proxy::v3alpha::SipProtocolOptions config;
  TestUtility::loadFromYaml(yaml, config);

  NiceMock<Server::Configuration::MockFactoryContext> context;
  const auto options = std::make_shared<ProtocolOptionsConfigImpl>(config);
  EXPECT_CALL(
      *context.server_factory_context_.cluster_manager_.thread_local_cluster_.cluster_.info_,
      extensionProtocolOptions(_))
      .WillRepeatedly(Return(options));

  EXPECT_EQ(true, options->sessionAffinity());
  EXPECT_EQ(true, options->registrationAffinity());
}

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include <chrono>
#include <memory>

#include "source/common/buffer/buffer_impl.h"

#include "test/common/stats/stat_test_utility.h"
#include "test/mocks/network/mocks.h"
#include "test/mocks/server/factory_context.h"
#include "test/test_common/printers.h"

#include "contrib/envoy/extensions/filters/network/sip_proxy/tra/v3alpha/tra.pb.h"
#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.h"
#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.validate.h"
#include "contrib/sip_proxy/filters/network/source/app_exception_impl.h"
#include "contrib/sip_proxy/filters/network/source/config.h"
#include "contrib/sip_proxy/filters/network/source/conn_manager.h"
#include "contrib/sip_proxy/filters/network/source/tra/tra_impl.h"
#include "contrib/sip_proxy/filters/network/test/mocks.h"
#include "contrib/sip_proxy/filters/network/test/utility.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using testing::NiceMock;
using testing::Return;
using testing::ReturnRef;

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

class SipTraTest : public testing::Test {
public:
  SipTraTest() : stream_info_(time_source_, nullptr) {}
  std::shared_ptr<SipProxy::MockTrafficRoutingAssistantHandlerDeep> initTraHandler() {
    std::string tra_yaml = R"EOF(
               grpc_service:
                 envoy_grpc:
                   cluster_name: tra_service
               timeout: 2s
               transport_api_version: V3
)EOF";

    auto tra_config = std::make_shared<
        envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceConfig>();
    TestUtility::loadFromYaml(tra_yaml, *tra_config);

    SipFilterStats stat = SipFilterStats::generateStats("test.", *store_.rootScope());
    auto config = std::make_shared<NiceMock<MockConfig>>();
    EXPECT_CALL(*config, stats()).WillRepeatedly(ReturnRef(stat));
    auto context = std::make_shared<NiceMock<Server::Configuration::MockFactoryContext>>();
    filter_ = std::make_shared<NiceMock<MockConnectionManager>>(*config, random_, time_source_,
                                                                *context, nullptr);

    auto tra_handler = std::make_shared<NiceMock<SipProxy::MockTrafficRoutingAssistantHandlerDeep>>(
        *filter_, dispatcher_, *tra_config, *context, stream_info_);

    auto async_client = std::make_shared<testing::NiceMock<Grpc::MockAsyncClient>>();

    EXPECT_CALL(*async_client, sendRaw(_, _, _, _, _, _))
        .WillRepeatedly(Return(async_client->async_request_.get()));

    async_stream_ = std::make_unique<testing::NiceMock<Grpc::MockAsyncStream>>();
    EXPECT_CALL(*async_client, startRaw(_, _, _, _)).WillRepeatedly(Return(async_stream_.get()));

    auto grpc_client = std::make_unique<TrafficRoutingAssistant::GrpcClientImpl>(
        async_client, dispatcher_, std::chrono::milliseconds(2000));
    tra_client_ = std::move(grpc_client);
    EXPECT_CALL(*tra_handler, traClient()).WillRepeatedly(ReturnRef(tra_client_));
    return tra_handler;
  }

  NiceMock<Event::MockDispatcher> dispatcher_;
  NiceMock<MockTimeSystem> time_source_;
  Tracing::MockSpan span_;
  Stats::TestUtil::TestStore store_;
  NiceMock<Random::MockRandomGenerator> random_;
  StreamInfo::StreamInfoImpl stream_info_;
  std::unique_ptr<testing::NiceMock<Grpc::MockAsyncStream>> async_stream_;
  TrafficRoutingAssistant::ClientPtr tra_client_;
  std::shared_ptr<ConnectionManager> filter_;
};

TEST_F(SipTraTest, TraUpdate) {
  auto tra_handler = initTraHandler();
  tra_handler->updateTrafficRoutingAssistant("lskpmc", "S2F1", "10.0.0.1", absl::nullopt);
}

TEST_F(SipTraTest, TraUpdateWithSIPContext) {
  auto tra_handler = initTraHandler();
  MessageMetadataSharedPtr metadata = std::make_shared<MessageMetadata>("");
  metadata->setMethodType(MethodType::Register);
  metadata->addMsgHeader(HeaderType::From, "user@sip.com");
  tra_handler->updateTrafficRoutingAssistant("lskpmc", "S2F1", "10.0.0.1", metadata->traContext());
}

TEST_F(SipTraTest, TraRetrieveContinue) {
  auto tra_handler = initTraHandler();
  tra_handler->updateTrafficRoutingAssistant("lskpmc", "S1F1", "10.0.0.1", absl::nullopt);

  NiceMock<SipFilters::MockDecoderFilterCallbacks> callbacks;
  std::string host = "";
  EXPECT_EQ(QueryStatus::Continue, tra_handler->retrieveTrafficRoutingAssistant(
                                       "lskpmc", "S1F1", absl::nullopt, callbacks, host));
  EXPECT_EQ(host, "10.0.0.1");
}

TEST_F(SipTraTest, TraRetrievePending) {
  auto tra_handler = initTraHandler();
  NiceMock<SipFilters::MockDecoderFilterCallbacks> callbacks;

  MessageMetadataSharedPtr metadata = std::make_shared<MessageMetadata>("");
  metadata->setMethodType(MethodType::Register);
  metadata->addMsgHeader(HeaderType::From, "user@sip.com");
  metadata->affinity().emplace_back("Route", "lskpmc", "", true, true);
  metadata->resetAffinityIteration();
  EXPECT_CALL(callbacks, metadata()).WillRepeatedly(Return(metadata));
  std::string host = "";
  EXPECT_EQ(QueryStatus::Pending, tra_handler->retrieveTrafficRoutingAssistant(
                                      "lskpmc", "S1F1", metadata->traContext(), callbacks, host));
  EXPECT_EQ(host, "");
}

TEST_F(SipTraTest, TraRetrieveStop) {
  auto tra_handler = initTraHandler();
  NiceMock<SipFilters::MockDecoderFilterCallbacks> callbacks;

  MessageMetadataSharedPtr metadata = std::make_shared<MessageMetadata>("");
  metadata->setMethodType(MethodType::Register);
  metadata->addMsgHeader(HeaderType::From, "user@sip.com");
  metadata->affinity().emplace_back("Route", "lskpmc", "", false, true);
  metadata->resetAffinityIteration();
  EXPECT_CALL(callbacks, metadata()).WillRepeatedly(Return(metadata));
  std::string host = "10.0.0.1";
  EXPECT_EQ(QueryStatus::Stop, tra_handler->retrieveTrafficRoutingAssistant(
                                   "lskpmc", "S1F1", metadata->traContext(), callbacks, host));
}

TEST_F(SipTraTest, TraCompleteUpdateRsp) {
  auto tra_handler = initTraHandler();
  tra_handler->complete(TrafficRoutingAssistant::ResponseType::UpdateResp, "", "");
}

TEST_F(SipTraTest, TraCompleteCreateRsp) {
  auto tra_handler = initTraHandler();
  tra_handler->complete(TrafficRoutingAssistant::ResponseType::CreateResp, "", "");
}

TEST_F(SipTraTest, TraCompleteDeleteRsp) {
  auto tra_handler = initTraHandler();
  tra_handler->complete(TrafficRoutingAssistant::ResponseType::DeleteResp, "", "");
}

TEST_F(SipTraTest, TraCompleteRetrieveRsp) {
  auto tra_handler = initTraHandler();
  envoy::extensions::filters::network::sip_proxy::tra::v3alpha::RetrieveResponse
      retrive_response_config;
  std::string retrieveRsp_yaml = R"EOF(
             data: {"S1F1":"10.0.0.1"}
)EOF";
  TestUtility::loadFromYaml(retrieveRsp_yaml, retrive_response_config);

  tra_handler->complete(TrafficRoutingAssistant::ResponseType::RetrieveResp, "lskpmc",
                        retrive_response_config);
}

TEST_F(SipTraTest, TraCompleteSubscribeRsp) {
  auto tra_handler = initTraHandler();
  envoy::extensions::filters::network::sip_proxy::tra::v3alpha::SubscribeResponse
      subscribe_response_config;
  std::string subscribeRsp_yaml = R"EOF(
             data: {"S2F1":"10.0.0.1"}
)EOF";
  TestUtility::loadFromYaml(subscribeRsp_yaml, subscribe_response_config);

  tra_handler->complete(TrafficRoutingAssistant::ResponseType::SubscribeResp, "lskpmc",
                        subscribe_response_config);
}

TEST_F(SipTraTest, TraDoSubscribe) {
  auto tra_handler = initTraHandler();
  envoy::extensions::filters::network::sip_proxy::v3alpha::CustomizedAffinity affinity_config;
  std::string affinity_yaml = R"EOF(
            entries:
            - key_name: lskpmc
              query: true
              subscribe: true
            - key_name: ep
              query: false
              subscribe: false
)EOF";
  TestUtility::loadFromYaml(affinity_yaml, affinity_config);
  tra_handler->doSubscribe(affinity_config);
}

TEST_F(SipTraTest, TraDelete) {
  auto tra_handler = initTraHandler();
  tra_handler->deleteTrafficRoutingAssistant("lskpmc", "S1F1", absl::nullopt);
}

TEST_F(SipTraTest, TraDeleteWithSIPContext) {
  auto tra_handler = initTraHandler();
  MessageMetadataSharedPtr metadata = std::make_shared<MessageMetadata>("");
  metadata->setMethodType(MethodType::Bye);
  metadata->addMsgHeader(HeaderType::From, "user@sip.com");
  tra_handler->deleteTrafficRoutingAssistant("lskpmc", "S1F1", metadata->traContext());
}

TEST_F(SipTraTest, TraSubscribe) {
  auto tra_handler = initTraHandler();
  tra_handler->subscribeTrafficRoutingAssistant("lskpmc");
}

TEST_F(SipTraTest, GrpcClientOnSuccessRetrieveRsp) {
  envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse
      service_response_config;
  std::string serviceRsp_yaml = R"EOF(
            type: lskpmc
            ret: 0
            reason: success
            retrieve_response:
              data: {"S1F1": "10.0.0.1"}
)EOF";
  TestUtility::loadFromYaml(serviceRsp_yaml, service_response_config);

  std::unique_ptr<envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>
      response = std::make_unique<
          envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>(
          service_response_config);

  auto grpc_client = TrafficRoutingAssistant::GrpcClientImpl(nullptr, dispatcher_, absl::nullopt);
  NiceMock<SipProxy::MockRequestCallbacks> request_callbacks;
  grpc_client.setRequestCallbacks(request_callbacks);
  grpc_client.onSuccess(std::move(response), span_);
}

TEST_F(SipTraTest, GrpcClientOnSuccessCreateRsp) {
  envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse
      service_response_config;
  std::string serviceRsp_yaml = R"EOF(
            type: lskpmc
            ret: 0
            reason: success
)EOF";
  TestUtility::loadFromYaml(serviceRsp_yaml, service_response_config);

  auto create_response =
      new envoy::extensions::filters::network::sip_proxy::tra::v3alpha::CreateResponse();
  service_response_config.set_allocated_create_response(create_response);
  std::unique_ptr<envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>
      response = std::make_unique<
          envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>(
          service_response_config);

  auto grpc_client = TrafficRoutingAssistant::GrpcClientImpl(nullptr, dispatcher_, absl::nullopt);
  NiceMock<SipProxy::MockRequestCallbacks> request_callbacks;
  grpc_client.setRequestCallbacks(request_callbacks);
  grpc_client.onSuccess(std::move(response), span_);
}

TEST_F(SipTraTest, GrpcClientOnSuccessUpdateRsp) {
  envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse
      service_response_config;
  std::string serviceRsp_yaml = R"EOF(
            type: lskpmc
            ret: 0
            reason: success
)EOF";
  TestUtility::loadFromYaml(serviceRsp_yaml, service_response_config);

  auto update_response =
      new envoy::extensions::filters::network::sip_proxy::tra::v3alpha::UpdateResponse();
  service_response_config.set_allocated_update_response(update_response);
  auto response = std::make_unique<
      envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>(
      service_response_config);

  auto grpc_client = TrafficRoutingAssistant::GrpcClientImpl(nullptr, dispatcher_, absl::nullopt);
  NiceMock<SipProxy::MockRequestCallbacks> request_callbacks;
  grpc_client.setRequestCallbacks(request_callbacks);
  grpc_client.onSuccess(std::move(response), span_);
}

TEST_F(SipTraTest, GrpcClientOnSuccessDeleteRsp) {
  envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse
      service_response_config;
  std::string serviceRsp_yaml = R"EOF(
            type: lskpmc
            ret: 0
            reason: success
)EOF";
  TestUtility::loadFromYaml(serviceRsp_yaml, service_response_config);

  auto delete_response =
      new envoy::extensions::filters::network::sip_proxy::tra::v3alpha::DeleteResponse();
  service_response_config.set_allocated_delete_response(delete_response);
  auto response = std::make_unique<
      envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>(
      service_response_config);

  auto grpc_client = TrafficRoutingAssistant::GrpcClientImpl(nullptr, dispatcher_, absl::nullopt);
  NiceMock<SipProxy::MockRequestCallbacks> request_callbacks;
  grpc_client.setRequestCallbacks(request_callbacks);
  grpc_client.onSuccess(std::move(response), span_);
}

TEST_F(SipTraTest, GrpcClientOnReceiveMessage) {
  std::unique_ptr<envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>
      response = std::make_unique<
          envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>();

  auto grpc_client = TrafficRoutingAssistant::GrpcClientImpl(nullptr, dispatcher_, absl::nullopt);
  NiceMock<SipProxy::MockRequestCallbacks> request_callbacks;
  grpc_client.setRequestCallbacks(request_callbacks);
  grpc_client.onReceiveMessage(std::move(response));
}

TEST_F(SipTraTest, GrpcClientOnFailure) {
  Grpc::Status::GrpcStatus status = Grpc::Status::WellKnownGrpcStatus::Unknown;

  auto grpc_client = TrafficRoutingAssistant::GrpcClientImpl(nullptr, dispatcher_, absl::nullopt);
  NiceMock<SipProxy::MockRequestCallbacks> request_callbacks;
  grpc_client.setRequestCallbacks(request_callbacks);
  grpc_client.onFailure(status, "", span_);
}

TEST_F(SipTraTest, Misc) {
  auto async_client = std::make_shared<testing::NiceMock<Grpc::MockAsyncClient>>();
  Grpc::RawAsyncRequestCallbacks* request_cb;
  Grpc::RawAsyncStreamCallbacks* stream_cb;

  EXPECT_CALL(*async_client, sendRaw(_, _, _, _, _, _))
      .WillRepeatedly(Invoke([&](absl::string_view, absl::string_view, Buffer::InstancePtr&&,
                                 Grpc::RawAsyncRequestCallbacks& callbacks, Tracing::Span&,
                                 const Http::AsyncClient::RequestOptions&) {
        request_cb = &callbacks;
        return async_client->async_request_.get();
      }));

  async_stream_ = std::make_unique<testing::NiceMock<Grpc::MockAsyncStream>>();
  EXPECT_CALL(*async_client, startRaw(_, _, _, _))
      .WillRepeatedly(
          Invoke([&](absl::string_view, absl::string_view, Grpc::RawAsyncStreamCallbacks& callbacks,
                     const Http::AsyncClient::StreamOptions&) {
            stream_cb = &callbacks;
            return async_stream_.get();
          }));

  auto grpc_client = TrafficRoutingAssistant::GrpcClientImpl(async_client, dispatcher_,
                                                             std::chrono::milliseconds(2000));
  NiceMock<SipProxy::MockRequestCallbacks> request_callbacks;
  grpc_client.setRequestCallbacks(request_callbacks);

  absl::flat_hash_map<std::string, std::string> data;
  data.emplace(std::make_pair("S1F1", "10.0.0.1"));
  grpc_client.createTrafficRoutingAssistant("lskpmc", data, absl::nullopt, span_, stream_info_);

  Http::TestRequestHeaderMapImpl request_headers;
  request_cb->onCreateInitialMetadata(request_headers);
  request_cb->onSuccessRaw(std::make_unique<Buffer::OwnedImpl>(""), span_);

  Grpc::Status::GrpcStatus status = Grpc::Status::WellKnownGrpcStatus::Unknown;
  request_cb->onFailure(status, "", span_);

  grpc_client.subscribeTrafficRoutingAssistant("lskpmc", span_, stream_info_);

  Http::TestRequestHeaderMapImpl request_headers2;
  stream_cb->onCreateInitialMetadata(request_headers2);

  Http::ResponseHeaderMapPtr response_headers = std::make_unique<Http::TestResponseHeaderMapImpl>();
  stream_cb->onReceiveInitialMetadata(std::move(response_headers));

  Http::ResponseTrailerMapPtr response_trailers =
      std::make_unique<Http::TestResponseTrailerMapImpl>();
  stream_cb->onReceiveTrailingMetadata(std::move(response_trailers));
  stream_cb->onReceiveMessageRaw(std::make_unique<Buffer::OwnedImpl>(""));
  stream_cb->onRemoteClose(status, "");
}

TEST_F(SipTraTest, TraGetTraContextFromMetadata) {
  MessageMetadataSharedPtr metadata = std::make_shared<MessageMetadata>("");
  metadata->setMethodType(MethodType::Register);
  metadata->addMsgHeader(HeaderType::From, "user@sip.com");

  auto context = metadata->traContext();
  EXPECT_EQ(context["from_header"], "user@sip.com");
  EXPECT_EQ(context["method_type"], "REGISTER");

  auto context2 = metadata->traContext();
  EXPECT_EQ(context2, context);
}

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include <chrono>
#include <type_traits>

#include "envoy/tcp/conn_pool.h"

#include "source/common/buffer/buffer_impl.h"
#include "source/common/stream_info/stream_info_impl.h"

#include "test/mocks/network/mocks.h"
#include "test/mocks/server/factory_context.h"
#include "test/mocks/upstream/host.h"
#include "test/test_common/printers.h"
#include "test/test_common/registry.h"
#include "test/test_common/test_time.h"

#include "contrib/sip_proxy/filters/network/source/app_exception_impl.h"
#include "contrib/sip_proxy/filters/network/source/config.h"
#include "contrib/sip_proxy/filters/network/source/router/config.h"
#include "contrib/sip_proxy/filters/network/source/router/router_impl.h"
#include "contrib/sip_proxy/filters/network/source/sip.h"
#include "contrib/sip_proxy/filters/network/test/mocks.h"
#include "contrib/sip_proxy/filters/network/test/utility.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using testing::_;
using testing::Eq;
using testing::Invoke;
using testing::NiceMock;
using testing::Return;
using testing::ReturnRef;

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace Router {

class SipRouterTest : public testing::Test {
public:
  SipRouterTest()
      : router_filter_config_(std::make_shared<NiceMock<MockRouterFilterConfig>>()),
        router_stats_(RouterFilterConfigImpl::generateStats("test", *store_.rootScope())){};
  ~SipRouterTest() override { delete (filter_); }

  void initializeTrans(const std::string& sip_protocol_options_yaml = "",
                       const std::string& sip_proxy_yaml = "") {

    if (sip_proxy_yaml.empty()) {
      std::string sip_proxy_yaml1 = R"EOF(
           stat_prefix: egress_sip
           route_config:
             routes:
             - match:
                domain: "icscf-internal.cncs.svc.cluster.local"
                header: "Route"
                parameter: "x-suri"
               route:
                cluster: fake_cluster
             - match:
                domain: "scscf-internal.cncs.svc.cluster.local"
                header: "Route"
                parameter: "x-suri"
               route:
                cluster: fake_cluster2
           settings:
             transaction_timeout: 32s
             local_services:
             - domain: "pcsf-cfed.cncs.svc.cluster.local"
               parameter: "x-suri"
             tra_service_config:
               grpc_service:
                 envoy_grpc:
                   cluster_name: tra_service
               timeout: 2s
               transport_api_version: V3
)EOF";
      TestUtility::loadFromYaml(sip_proxy_yaml1, sip_proxy_config_);
    } else {
      TestUtility::loadFromYaml(sip_proxy_yaml, sip_proxy_config_);
    }

    if (sip_protocol_options_yaml.empty()) {
      const std::string sip_protocol_options_yaml1 = R"EOF(
        session_affinity: true
        registration_affinity: true
        customized_affinity:
          entries:
          - key_name: lskpmc
            query: true
            subscribe: true
          - key_name: ep
            query: false
            subscribe: false
)EOF";
      TestUtility::loadFromYaml(sip_protocol_options_yaml1, sip_protocol_options_config_);
    } else {
      TestUtility::loadFromYaml(sip_protocol_options_yaml, sip_protocol_options_config_);
    }

    const auto options = std::make_shared<ProtocolOptionsConfigImpl>(sip_protocol_options_config_);
    EXPECT_CALL(
        *context_.server_factory_context_.cluster_manager_.thread_local_cluster_.cluster_.info_,
        extensionProtocolOptions(_))
        .WillRepeatedly(Return(options));

    EXPECT_CALL(context_, getTransportSocketFactoryContext())
        .WillRepeatedly(testing::ReturnRef(factory_context_));
    EXPECT_CALL(factory_context_.server_context_, localInfo())
        .WillRepeatedly(testing::ReturnRef(local_info_));

    transaction_infos_ = std::make_shared<TransactionInfos>();
    context_.server_factory_context_.cluster_manager_.initializeThreadLocalClusters(
        {cluster_name_});

    StreamInfo::StreamInfoImpl stream_info{time_source_, nullptr};
    SipFilterStats stat = SipFilterStats::generateStats("test.", *store_.rootScope());
    EXPECT_CALL(config_, stats()).WillRepeatedly(ReturnRef(stat));

    filter_ =
        new NiceMock<MockConnectionManager>(config_, random_, time_source_, context_, nullptr);
    sip_settings_ = std::make_shared<SipSettings>(sip_proxy_config_.settings());

    EXPECT_CALL(*filter_, settings()).WillRepeatedly(Return(sip_settings_));
    tra_handler_ = std::make_shared<NiceMock<SipProxy::MockTrafficRoutingAssistantHandler>>(
        *filter_, dispatcher_, sip_proxy_config_.settings().tra_service_config(), context_,
        stream_info);
  }

  void initializeRouter() {
    route_ = new NiceMock<MockRoute>();
    route_ptr_.reset(route_);

    EXPECT_CALL(*router_filter_config_, stats()).WillRepeatedly(ReturnRef(router_stats_));
    router_ = std::make_unique<Router>(router_filter_config_,
                                       context_.server_factory_context_.clusterManager(), context_);

    EXPECT_EQ(nullptr, router_->downstreamConnection());

    EXPECT_CALL(callbacks_, settings()).WillRepeatedly(Return(sip_settings_));
    EXPECT_CALL(callbacks_, transactionInfos()).WillOnce(Return(transaction_infos_));
    EXPECT_CALL(callbacks_, traHandler()).WillRepeatedly(Return(tra_handler_));
    router_->setDecoderFilterCallbacks(callbacks_);
  }

  void initializeMetadata(MsgType msg_type, MethodType method = MethodType::Invite,
                          bool set_destination = true) {

    metadata_ = std::make_shared<MessageMetadata>();
    metadata_->setMethodType(method);
    metadata_->setMsgType(msg_type);
    metadata_->setTransactionId("<branch=cluster>");
    metadata_->setEP("10.0.0.1");
    metadata_->affinity().emplace_back("Route", "ep", "ep", false, false);
    metadata_->addMsgHeader(
        HeaderType::Route,
        "Route: "
        "<sip:test@pcsf-cfed.cncs.svc.cluster.local;role=anch;lr;transport=udp;x-suri="
        "sip:scscf-internal.cncs.svc.cluster.local:5060;ep=10.0.0.1>");
    metadata_->addMsgHeader(HeaderType::From, "User.0001@10.0.0.1:5060");
    metadata_->resetAffinityIteration();
    if (set_destination) {
      metadata_->setDestination("10.0.0.1");
    }
  }

  void initializeTransaction() {
    auto transaction_info_ptr = std::make_shared<TransactionInfo>(
        cluster_name_, thread_local_, static_cast<std::chrono::seconds>(2));
    transaction_info_ptr->init();
    transaction_infos_->emplace(cluster_name_, transaction_info_ptr);
  }

  void startRequest(FilterStatus status = FilterStatus::StopIteration) {
    EXPECT_CALL(callbacks_, route()).WillRepeatedly(Return(route_ptr_));
    EXPECT_CALL(*route_, routeEntry()).WillRepeatedly(Return(&route_entry_));
    EXPECT_CALL(route_entry_, clusterName()).WillRepeatedly(ReturnRef(cluster_name_));
    EXPECT_EQ(FilterStatus::Continue, router_->transportBegin(metadata_));

    EXPECT_EQ(status, router_->messageBegin(metadata_));
  }

  void connectUpstream() {
    EXPECT_CALL(*context_.server_factory_context_.cluster_manager_.thread_local_cluster_
                     .tcp_conn_pool_.connection_data_,
                addUpstreamCallbacks(_))
        .WillOnce(Invoke([&](Tcp::ConnectionPool::UpstreamCallbacks& cb) -> void {
          upstream_callbacks_ = &cb;
        }));

    conn_state_.reset();
    EXPECT_CALL(*context_.server_factory_context_.cluster_manager_.thread_local_cluster_
                     .tcp_conn_pool_.connection_data_,
                connectionState())
        .WillRepeatedly(
            Invoke([&]() -> Tcp::ConnectionPool::ConnectionState* { return conn_state_.get(); }));
    context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_
        .poolReady(upstream_connection_);

    EXPECT_NE(nullptr, upstream_callbacks_);
  }

  void startRequestWithExistingConnection(MsgType msg_type,
                                          MethodType method = MethodType::Invite) {
    initializeMetadata(msg_type, method);
    EXPECT_EQ(FilterStatus::Continue, router_->transportBegin({}));

    EXPECT_CALL(route_entry_, clusterName()).WillRepeatedly(ReturnRef(cluster_name_));

    EXPECT_EQ(FilterStatus::Continue, router_->messageBegin(metadata_));
    EXPECT_NE(nullptr, upstream_callbacks_);
  }

  void completeRequest() {
    EXPECT_EQ(FilterStatus::Continue, router_->messageEnd());
    EXPECT_EQ(FilterStatus::Continue, router_->transportEnd());
  }

  void returnResponse(MsgType msg_type = MsgType::Response) {
    Buffer::OwnedImpl buffer;

    const std::string SIP_OK200_FULL =
        "SIP/2.0 200 OK\x0d\x0a"
        "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
        "CSeq: 1 INVITE\x0d\x0a"
        "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
        "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
        "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
        "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
        "Service-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
        "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=cluster\x0d\x0a"
        "Path: "
        "<sip:10.177.8.232;x-fbi=cfed;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;inst-ip=192."
        "169.110.53;lr;ottag=ue_term;bidx=563242011197570;access-type=ADSL;x-alu-prset-id>\x0d\x0a"
        "P-Nokia-Cookie-IP-Mapping: S1F1=10.0.0.1\x0d\x0a"
        "Content-Length:  0\x0d\x0a"
        "\x0d\x0a";
    buffer.add(SIP_OK200_FULL);

    initializeMetadata(msg_type, MethodType::Ok200, false);

    EXPECT_CALL(*tra_handler_, retrieveTrafficRoutingAssistant(_, _, _, _, _))
        .WillRepeatedly(
            Invoke([&](const std::string&, const std::string&, const absl::optional<TraContextMap>,
                       SipFilters::DecoderFilterCallbacks&, std::string& host) -> QueryStatus {
              host = "10.0.0.11";
              return QueryStatus::Pending;
            }));
    upstream_callbacks_->onUpstreamData(buffer, false);
  }

  void returnResponseNoActiveTrans(MsgType msg_type = MsgType::Response) {
    Buffer::OwnedImpl buffer;

    const std::string SIP_OK200_FULL =
        "SIP/2.0 200 OK\x0d\x0a"
        "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
        "CSeq: 1 INVITE\x0d\x0a"
        "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
        "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
        "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
        "Service-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
        "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=111\x0d\x0a"
        "Path: "
        "<sip:10.177.8.232;x-fbi=cfed;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;inst-ip=192."
        "169.110.53;lr;ottag=ue_term;bidx=563242011197570;access-type=ADSL;x-alu-prset-id>\x0d\x0a"
        "Content-Length:  0\x0d\x0a"
        "\x0d\x0a";
    buffer.add(SIP_OK200_FULL);

    initializeMetadata(msg_type, MethodType::Ok200, false);

    metadata_->setTransactionId("");
    upstream_callbacks_->onUpstreamData(buffer, false);
  }

  void returnResponseNoTransId(MsgType msg_type = MsgType::Response) {
    Buffer::OwnedImpl buffer;

    const std::string SIP_OK200_FULL =
        "SIP/2.0 200 OK\x0d\x0a"
        "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
        "CSeq: 1 INVITE\x0d\x0a"
        "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
        "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
        "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
        "Service-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
        "Via: SIP/2.0/TCP 11.0.0.10:15060;\x0d\x0a"
        "Path: "
        "<sip:10.177.8.232;x-fbi=cfed;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;inst-ip=192."
        "169.110.53;lr;ottag=ue_term;bidx=563242011197570;access-type=ADSL;x-alu-prset-id>\x0d\x0a"
        "Content-Length:  0\x0d\x0a"
        "\x0d\x0a";
    buffer.add(SIP_OK200_FULL);

    initializeMetadata(msg_type, MethodType::Ok200, false);

    metadata_->setTransactionId("");
    upstream_callbacks_->onUpstreamData(buffer, false);
  }

  void destroyRouter() {
    router_->onDestroy();
    router_.reset();
  }
  void destroyRouterOutofRange() {
    // std::out_of_range Exception
    EXPECT_CALL(callbacks_, transactionId())
        .Times(2)
        .WillOnce(Return("test"))
        .WillOnce(Return("test1"));

    router_->onDestroy();
    router_.reset();
  }

  envoy::extensions::filters::network::sip_proxy::v3alpha::SipProtocolOptions
      sip_protocol_options_config_;
  envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy sip_proxy_config_;
  NiceMock<Server::Configuration::MockFactoryContext> context_;
  NiceMock<Network::MockClientConnection> connection_;
  NiceMock<StreamInfo::MockStreamInfo> streamInfo_;
  NiceMock<Event::MockDispatcher> dispatcher_;
  NiceMock<MockTimeSystem> time_source_;
  NiceMock<SipFilters::MockDecoderFilterCallbacks> callbacks_;
  NiceMock<MockRoute>* route_{};
  NiceMock<MockRouteEntry> route_entry_;
  NiceMock<Server::Configuration::MockTransportSocketFactoryContext> factory_context_;
  NiceMock<LocalInfo::MockLocalInfo> local_info_;
  NiceMock<Upstream::MockHostDescription>* host_{};
  Tcp::ConnectionPool::ConnectionStatePtr conn_state_;
  Buffer::OwnedImpl buffer_;
  NiceMock<ThreadLocal::MockInstance> thread_local_;
  NiceMock<MockConnectionManager>* filter_{};
  NiceMock<MockConfig> config_;
  NiceMock<Random::MockRandomGenerator> random_;
  Stats::TestUtil::TestStore store_;

  std::shared_ptr<NiceMock<MockRouterFilterConfig>> router_filter_config_;
  RouterStats router_stats_;

  std::shared_ptr<TransactionInfos> transaction_infos_;
  std::shared_ptr<SipSettings> sip_settings_;

  RouteConstSharedPtr route_ptr_;
  std::unique_ptr<Router> router_;

  std::shared_ptr<SipProxy::MockTrafficRoutingAssistantHandler> tra_handler_;

  std::string cluster_name_{"fake_cluster"};

  MsgType msg_type_{MsgType::Request};
  MessageMetadataSharedPtr metadata_;

  Tcp::ConnectionPool::UpstreamCallbacks* upstream_callbacks_{};
  NiceMock<Network::MockClientConnection> upstream_connection_;
};

TEST_F(SipRouterTest, CustomizedAffinity) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();

  initializeMetadata(MsgType::Request);
  metadata_->setPCookieIpMap({"S1F1", "10.0.0.1"});

  startRequest();
  connectUpstream();
  completeRequest();
  returnResponseNoTransId();
  EXPECT_CALL(callbacks_, transactionId()).WillRepeatedly(Return("test"));
  destroyRouter();
}

TEST_F(SipRouterTest, SessionAffinity) {
  const std::string sip_protocol_options_yaml = R"EOF(
        session_affinity: true
        registration_affinity: true
)EOF";
  initializeTrans(sip_protocol_options_yaml);
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);
  startRequest();
  connectUpstream();
  completeRequest();
  returnResponse();
  EXPECT_CALL(callbacks_, transactionId()).WillRepeatedly(Return("test"));
  destroyRouter();
}

TEST_F(SipRouterTest, SendAnotherMsgInConnectedUpstreamRequest) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);
  startRequest();
  connectUpstream();
  completeRequest();
  returnResponseNoActiveTrans();

  EXPECT_EQ(FilterStatus::Continue, router_->transportBegin(metadata_));
  EXPECT_EQ(FilterStatus::Continue, router_->messageBegin(metadata_));
}

TEST_F(SipRouterTest, NoTcpConnPool) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);
  EXPECT_CALL(context_.server_factory_context_.cluster_manager_.thread_local_cluster_,
              tcpConnPool(_, _))
      .WillOnce(Return(absl::nullopt));
  try {
    startRequest(FilterStatus::Continue);
  } catch (const AppException& ex) {
    EXPECT_EQ(1U, store_.counterFromString("test.no_healthy_upstream").value());
  }
}

TEST_F(SipRouterTest, NoTcpConnPoolEmptyDest) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);
  metadata_->addMsgHeader(HeaderType::Route,
                          "Route: "
                          "<sip:test@pcsf-cfed.cncs.svc.cluster.local;role=anch;lr;transport=udp;"
                          "x-suri=sip:scscf-internal.cncs.svc.cluster.local:5060>");
  metadata_->affinity().emplace_back("Route", "ep", "ep", false, false);
  metadata_->resetAffinityIteration();

  EXPECT_CALL(context_.server_factory_context_.cluster_manager_.thread_local_cluster_,
              tcpConnPool(_, _))
      .WillOnce(Return(absl::nullopt));
  try {
    startRequest(FilterStatus::Continue);
  } catch (const AppException& ex) {
    EXPECT_EQ(1U, store_.counterFromString("test.no_healthy_upstream").value());
  }
}

TEST_F(SipRouterTest, QueryPending) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);
  metadata_->addMsgHeader(HeaderType::Route,
                          "Route: "
                          "<sip:test@pcsf-cfed.cncs.svc.cluster.local;role=anch;lr;transport=udp;"
                          "x-suri=sip:scscf-internal.cncs.svc.cluster.local:5060>");
  metadata_->affinity().emplace_back("Route", "lskpmc", "S1F1", false, false);
  metadata_->resetAffinityIteration();
  EXPECT_CALL(*tra_handler_, retrieveTrafficRoutingAssistant(_, _, _, _, _))
      .WillRepeatedly(
          Invoke([&](const std::string&, const std::string&, const absl::optional<TraContextMap>,
                     SipFilters::DecoderFilterCallbacks&, std::string& host) -> QueryStatus {
            host = "10.0.0.11";
            return QueryStatus::Pending;
          }));
  startRequest();
}

TEST_F(SipRouterTest, QueryStop) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request, MethodType::Invite, false);
  metadata_->affinity().clear();
  metadata_->affinity().emplace_back("Route", "lskpmc", "S1F1", false, false);
  metadata_->resetAffinityIteration();
  EXPECT_CALL(*tra_handler_, retrieveTrafficRoutingAssistant(_, _, _, _, _))
      .WillRepeatedly(
          Invoke([&](const std::string&, const std::string&, const absl::optional<TraContextMap>,
                     SipFilters::DecoderFilterCallbacks&, std::string& host) -> QueryStatus {
            host = "";
            return QueryStatus::Stop;
          }));
  startRequest(FilterStatus::Continue);
}

TEST_F(SipRouterTest, SendAnotherMsgInConnectingUpstreamRequest) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);
  startRequest();

  EXPECT_EQ(FilterStatus::StopIteration, router_->messageBegin(metadata_));
}

TEST_F(SipRouterTest, CallNoRoute) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);
  metadata_->affinity().clear();

  EXPECT_CALL(callbacks_, route()).WillOnce(Return(nullptr));
  try {
    EXPECT_EQ(FilterStatus::StopIteration, router_->transportBegin(metadata_));
  } catch (const AppException& ex) {
    EXPECT_EQ(1U, store_.counterFromString("test.route_missing").value());
  }

  destroyRouterOutofRange();
}

TEST_F(SipRouterTest, CallNoCluster) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);
  metadata_->affinity().clear();

  EXPECT_CALL(callbacks_, route()).WillOnce(Return(route_ptr_));
  EXPECT_CALL(*route_, routeEntry()).WillOnce(Return(&route_entry_));
  EXPECT_CALL(route_entry_, clusterName()).WillRepeatedly(ReturnRef(cluster_name_));
  EXPECT_CALL(context_.server_factory_context_.cluster_manager_,
              getThreadLocalCluster(Eq(cluster_name_)))
      .WillOnce(Return(nullptr));

  try {
    EXPECT_EQ(FilterStatus::StopIteration, router_->transportBegin(metadata_));
  } catch (const AppException& ex) {
    EXPECT_EQ(1U, store_.counterFromString("test.unknown_cluster").value());
  }

  destroyRouter();
}

TEST_F(SipRouterTest, ClusterMaintenanceMode) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);

  EXPECT_CALL(callbacks_, route()).WillOnce(Return(route_ptr_));
  EXPECT_CALL(*route_, routeEntry()).WillOnce(Return(&route_entry_));
  EXPECT_CALL(route_entry_, clusterName()).WillRepeatedly(ReturnRef(cluster_name_));
  EXPECT_CALL(
      *context_.server_factory_context_.cluster_manager_.thread_local_cluster_.cluster_.info_,
      maintenanceMode())
      .WillOnce(Return(true));

  try {
    EXPECT_EQ(FilterStatus::StopIteration, router_->transportBegin(metadata_));
  } catch (const AppException& ex) {
    EXPECT_EQ(1U, store_.counterFromString("test.upstream_rq_maintenance_mode").value());
  }
  destroyRouter();
}

TEST_F(SipRouterTest, NoHost) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);

  EXPECT_CALL(callbacks_, route()).WillOnce(Return(route_ptr_));
  EXPECT_CALL(*route_, routeEntry()).WillOnce(Return(&route_entry_));
  EXPECT_CALL(route_entry_, clusterName()).WillOnce(ReturnRef(cluster_name_));
  EXPECT_EQ(FilterStatus::Continue, router_->transportBegin(metadata_));

  EXPECT_CALL(
      context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_,
      host())
      .WillOnce(Return(nullptr));
  EXPECT_EQ(FilterStatus::Continue, router_->messageBegin(metadata_));
  destroyRouter();
}

TEST_F(SipRouterTest, DestNotEqualToHost) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request, MethodType::Invite, false);

  EXPECT_CALL(callbacks_, route()).WillOnce(Return(route_ptr_));
  EXPECT_CALL(*route_, routeEntry()).WillOnce(Return(&route_entry_));
  EXPECT_CALL(route_entry_, clusterName()).WillOnce(ReturnRef(cluster_name_));
  EXPECT_EQ(FilterStatus::Continue, router_->transportBegin(metadata_));

  metadata_->listHeader(HeaderType::Route).clear();
  metadata_->addMsgHeader(
      HeaderType::Route,
      "Route: "
      "<sip:test@pcsf-cfed.cncs.svc.cluster.local;role=anch;lr;transport=udp;x-suri="
      "sip:scscf-internal.cncs.svc.cluster.local:5060;ep=192.168.0.1>");

  metadata_->resetAffinityIteration();

  EXPECT_EQ(FilterStatus::Continue, router_->messageBegin(metadata_));
  destroyRouter();
}

TEST_F(SipRouterTest, CallWithExistingConnection) {
  const std::string sip_protocol_options_yaml = R"EOF(
        session_affinity: true
        registration_affinity: true
)EOF";
  initializeTrans(sip_protocol_options_yaml);
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);
  startRequest();
  connectUpstream();
  completeRequest();
  returnResponse();

  auto& transaction_info_ptr = (*transaction_infos_)[cluster_name_];
  transaction_info_ptr->getUpstreamRequest("10.0.0.1")
      ->setConnectionState(ConnectionState::NotConnected);

  metadata_->affinity().emplace_back("Route", "ep", "ep", false, false);
  metadata_->resetAffinityIteration();

  EXPECT_CALL(
      context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_,
      newConnection(_))
      .WillOnce(
          Invoke([&](Tcp::ConnectionPool::Callbacks& cb) -> Tcp::ConnectionPool::Cancellable* {
            context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_
                .newConnectionImpl(cb);
            context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_
                .poolReady(upstream_connection_);
            return nullptr;
          }));
  EXPECT_EQ(FilterStatus::Continue, router_->messageBegin(metadata_));
  destroyRouter();
}

TEST_F(SipRouterTest, CallWithExistingConnectionDefaultLoadBalance) {
  const std::string sip_protocol_options_yaml = R"EOF(
        session_affinity: true
        registration_affinity: true
)EOF";
  initializeTrans(sip_protocol_options_yaml);
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);
  startRequest();
  connectUpstream();
  completeRequest();
  returnResponse();

  auto& transaction_info_ptr = (*transaction_infos_)[cluster_name_];
  transaction_info_ptr->getUpstreamRequest("10.0.0.1")
      ->setConnectionState(ConnectionState::NotConnected);

  // initializeMetadata(MsgType::Request);
  metadata_->resetDestination();

  EXPECT_CALL(
      context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_,
      newConnection(_))
      .WillOnce(
          Invoke([&](Tcp::ConnectionPool::Callbacks& cb) -> Tcp::ConnectionPool::Cancellable* {
            context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_
                .newConnectionImpl(cb);
            context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_
                .poolReady(upstream_connection_);
            return nullptr;
          }));
  EXPECT_EQ(FilterStatus::Continue, router_->messageBegin(metadata_));
  destroyRouter();
}

TEST_F(SipRouterTest, PoolFailure) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Response);
  startRequest();
  context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_
      .poolFailure(ConnectionPool::PoolFailureReason::RemoteConnectionFailure);
}

TEST_F(SipRouterTest, NextAffinityAfterPoolFailure) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Response);
  startRequest();
  metadata_->affinity().emplace_back("Route", "ep", "ep", false, false);
  metadata_->resetAffinityIteration();
  context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_
      .poolFailure(ConnectionPool::PoolFailureReason::RemoteConnectionFailure);
}

TEST_F(SipRouterTest, NewConnectionFailure) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  EXPECT_CALL(
      context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_,
      newConnection(_))
      .WillOnce(
          Invoke([&](Tcp::ConnectionPool::Callbacks& cb) -> Tcp::ConnectionPool::Cancellable* {
            context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_
                .newConnectionImpl(cb);
            context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_
                .poolReady(upstream_connection_);
            return nullptr;
          }));
  initializeMetadata(MsgType::Response);
  startRequest(FilterStatus::Continue);
}

TEST_F(SipRouterTest, UpstreamCloseMidResponse) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);
  startRequest();
  connectUpstream();

  upstream_callbacks_->onEvent(Network::ConnectionEvent::LocalClose);
  upstream_callbacks_->onEvent(Network::ConnectionEvent::RemoteClose);
  upstream_callbacks_->onEvent(static_cast<Network::ConnectionEvent>(9999));
}

TEST_F(SipRouterTest, RouteEntryImplBase) {
  const envoy::extensions::filters::network::sip_proxy::v3alpha::Route route;
  GeneralRouteEntryImpl* base = new GeneralRouteEntryImpl(route);
  EXPECT_EQ("", base->clusterName());
  EXPECT_EQ(base, base->routeEntry());
  EXPECT_EQ(nullptr, base->metadataMatchCriteria());
}

TEST_F(SipRouterTest, RouteMatch) {
  const std::string yaml = R"EOF(
             routes:
             - match:
                domain: "icscf-internal.cncs.svc.cluster.local"
                header: "Route"
                parameter: "x-suri"
               route:
                cluster: fake_cluster
             - match:
                domain: "scscf-internal.cncs.svc.cluster.local"
                header: "Route"
                parameter: "x-suri"
               route:
                cluster: fake_cluster2
)EOF";

  envoy::extensions::filters::network::sip_proxy::v3alpha::RouteConfiguration config;
  TestUtility::loadFromYaml(yaml, config);

  initializeMetadata(MsgType::Request);
  auto matcher_ptr = std::make_shared<RouteMatcher>(config);

  // Match domain
  metadata_->addMsgHeader(
      HeaderType::Route,
      "Route: "
      "<sip:test@pcsf-cfed.cncs.svc.cluster.local;role=anch;lr;transport=udp;x-suri="
      "sip:scscf-internal.cncs.svc.cluster.local:5060>");

  EXPECT_NE(nullptr, matcher_ptr->route(*metadata_));
}

TEST_F(SipRouterTest, RouteEmptyDomain) {

  const std::string yaml = R"EOF(
             routes:
             - match:
                domain: ""
                header: "Route"
                parameter: "x-suri"
               route:
                cluster: fake_cluster
)EOF";

  envoy::extensions::filters::network::sip_proxy::v3alpha::RouteConfiguration config;
  TestUtility::loadFromYaml(yaml, config);

  initializeMetadata(MsgType::Request);
  auto matcher_ptr = std::make_shared<RouteMatcher>(config);

  // Match domain
  metadata_->addMsgHeader(
      HeaderType::Route,
      "Route: "
      "<sip:test@pcsf-cfed.cncs.svc.cluster.local;role=anch;lr;transport=udp;x-suri="
      "sip:scscf-internal.cncs.svc.cluster.local:5060>");

  EXPECT_EQ(nullptr, matcher_ptr->route(*metadata_));
}

TEST_F(SipRouterTest, RouteDefaultDomain) {

  const std::string yaml = R"EOF(
             routes:
             - match:
                domain: "pcsf-cfed.cncs.svc.cluster.local"
                header: "Route"
                parameter: "x-suri"
               route:
                cluster: fake_cluster
)EOF";

  envoy::extensions::filters::network::sip_proxy::v3alpha::RouteConfiguration config;
  TestUtility::loadFromYaml(yaml, config);

  initializeMetadata(MsgType::Request);
  auto matcher_ptr = std::make_shared<RouteMatcher>(config);

  // Match domain
  metadata_->addMsgHeader(
      HeaderType::Route,
      "Route: "
      "<sip:test@pcsf-cfed.cncs.svc.cluster.local;role=anch;lr;transport=udp;x-suri="
      "sip:scscf-internal.cncs.svc.cluster.local:5060>");

  EXPECT_EQ(nullptr, matcher_ptr->route(*metadata_));
}

TEST_F(SipRouterTest, RouteEmptyHeader) {

  const std::string yaml = R"EOF(
             routes:
             - match:
                domain: "scscf-internal.cncs.svc.cluster.local"
                header: ""
                parameter: "x-suri"
               route:
                cluster: fake_cluster
)EOF";

  envoy::extensions::filters::network::sip_proxy::v3alpha::RouteConfiguration config;
  TestUtility::loadFromYaml(yaml, config);

  initializeMetadata(MsgType::Request);
  auto matcher_ptr = std::make_shared<RouteMatcher>(config);

  // Match domain
  metadata_->addMsgHeader(
      HeaderType::Route,
      "Route: "
      "<sip:test@pcsf-cfed.cncs.svc.cluster.local;role=anch;lr;transport=udp;x-suri="
      "sip:scscf-internal.cncs.svc.cluster.local:5060>");

  EXPECT_NE(nullptr, matcher_ptr->route(*metadata_));
}

TEST_F(SipRouterTest, RouteNoRouteHeaderUsingTopLine) {

  const std::string yaml = R"EOF(
             routes:
             - match:
                domain: "scscf-internal.cncs.svc.cluster.local"
                header: "Route"
                parameter: "x-suri"
               route:
                cluster: fake_cluster
)EOF";

  envoy::extensions::filters::network::sip_proxy::v3alpha::RouteConfiguration config;
  TestUtility::loadFromYaml(yaml, config);

  initializeMetadata(MsgType::Request);
  auto matcher_ptr = std::make_shared<RouteMatcher>(config);

  // Match domain
  metadata_->addMsgHeader(HeaderType::TopLine,
                          "INVITE sip:User.0000@scscf-internal.cncs.svc.cluster.local;ep=127.0.0.1 "
                          "SIP/2.0\x0d\x0a");

  EXPECT_NE(nullptr, matcher_ptr->route(*metadata_));
}

TEST_F(SipRouterTest, RouteUsingEmptyTopLine) {

  const std::string yaml = R"EOF(
             routes:
             - match:
                domain: "scscf-internal.cncs.svc.cluster.local"
                header: "Route"
                parameter: "x-suri"
               route:
                cluster: fake_cluster
)EOF";

  envoy::extensions::filters::network::sip_proxy::v3alpha::RouteConfiguration config;
  TestUtility::loadFromYaml(yaml, config);

  initializeMetadata(MsgType::Request);
  metadata_->listHeader(HeaderType::Route).clear();
  auto matcher_ptr = std::make_shared<RouteMatcher>(config);

  EXPECT_EQ(nullptr, matcher_ptr->route(*metadata_));
}

TEST_F(SipRouterTest, RouteUsingEmptyRecordRoute) {

  const std::string yaml = R"EOF(
             routes:
             - match:
                domain: "scscf-internal.cncs.svc.cluster.local"
                header: "Record-Route"
                parameter: "x-suri"
               route:
                cluster: fake_cluster
)EOF";

  envoy::extensions::filters::network::sip_proxy::v3alpha::RouteConfiguration config;
  TestUtility::loadFromYaml(yaml, config);

  initializeMetadata(MsgType::Request);
  auto matcher_ptr = std::make_shared<RouteMatcher>(config);

  EXPECT_EQ(nullptr, matcher_ptr->route(*metadata_));
}

TEST_F(SipRouterTest, RouteHeaderHostDomain) {

  const std::string yaml = R"EOF(
             routes:
             - match:
                domain: "pcsf-cfed.cncs.svc.cluster.local"
                header: "Route"
                parameter: "host"
               route:
                cluster: fake_cluster
)EOF";

  envoy::extensions::filters::network::sip_proxy::v3alpha::RouteConfiguration config;
  TestUtility::loadFromYaml(yaml, config);

  initializeMetadata(MsgType::Request);
  auto matcher_ptr = std::make_shared<RouteMatcher>(config);

  // Match domain
  metadata_->addMsgHeader(
      HeaderType::Route,
      "Route: "
      "<sip:test@pcsf-cfed.cncs.svc.cluster.local;role=anch;lr;transport=udp;x-suri="
      "sip:scscf-internal.cncs.svc.cluster.local:5060>");

  EXPECT_NE(nullptr, matcher_ptr->route(*metadata_));
}

TEST_F(SipRouterTest, RouteHeaderWildcardDomain) {

  const std::string yaml = R"EOF(
             routes:
             - match:
                domain: "*"
                header: "Route"
                parameter: "host"
               route:
                cluster: fake_cluster
)EOF";

  envoy::extensions::filters::network::sip_proxy::v3alpha::RouteConfiguration config;
  TestUtility::loadFromYaml(yaml, config);

  initializeMetadata(MsgType::Request);
  auto matcher_ptr = std::make_shared<RouteMatcher>(config);

  // Match domain
  metadata_->addMsgHeader(
      HeaderType::Route,
      "Route: "
      "<sip:test@pcsf-cfed.cncs.svc.cluster.local;role=anch;lr;transport=udp;x-suri="
      "sip:scscf-internal.cncs.svc.cluster.local:5060>");

  EXPECT_NE(nullptr, matcher_ptr->route(*metadata_));
}

TEST_F(SipRouterTest, Audit) {
  initializeTrans();
  initializeRouter();
  initializeTransaction();
  initializeMetadata(MsgType::Request);
  startRequest();

  auto& transaction_info_ptr = (*transaction_infos_)[cluster_name_];
  EXPECT_NE(nullptr, transaction_info_ptr);
  std::shared_ptr<UpstreamRequest> upstream_request_ptr =
      transaction_info_ptr->getUpstreamRequest("10.0.0.1");
  EXPECT_NE(nullptr, upstream_request_ptr);

  std::shared_ptr<TransactionInfoItem> item =
      std::make_shared<TransactionInfoItem>(&callbacks_, upstream_request_ptr);
  std::shared_ptr<TransactionInfoItem> itemToDelete =
      std::make_shared<TransactionInfoItem>(&callbacks_, upstream_request_ptr);
  itemToDelete->toDelete();
  ThreadLocalTransactionInfo threadInfo(transaction_info_ptr, dispatcher_,
                                        std::chrono::milliseconds(0));
  threadInfo.transaction_info_map_.emplace(cluster_name_, item);
  threadInfo.transaction_info_map_.emplace("test1", itemToDelete);
  threadInfo.auditTimerAction();
}

} // namespace Router
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include <memory>
#include <string>

#include "envoy/router/router.h"

#include "test/mocks/grpc/mocks.h"
#include "test/mocks/network/mocks.h"
#include "test/mocks/stream_info/mocks.h"
#include "test/test_common/printers.h"

#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.h"
#include "contrib/sip_proxy/filters/network/source/conn_manager.h"
#include "contrib/sip_proxy/filters/network/source/conn_state.h"
#include "contrib/sip_proxy/filters/network/source/decoder_events.h"
#include "contrib/sip_proxy/filters/network/source/filters/factory_base.h"
#include "contrib/sip_proxy/filters/network/source/filters/filter.h"
#include "contrib/sip_proxy/filters/network/source/metadata.h"
#include "contrib/sip_proxy/filters/network/source/router/router.h"
#include "gmock/gmock.h"

using testing::NiceMock;

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

class MockConfig : public Config {
public:
  MockConfig();
  ~MockConfig() override;

  // SipProxy::Config
  MOCK_METHOD(SipFilters::FilterChainFactory&, filterFactory, ());
  MOCK_METHOD(SipFilterStats&, stats, ());
  MOCK_METHOD(Router::Config&, routerConfig, ());
  MOCK_METHOD(std::shared_ptr<SipSettings>, settings, ());
};

class MockRouterFilterConfig : public Router::RouterFilterConfig {
public:
  // Router::RouterFilterConfig
  MOCK_METHOD(Router::RouterStats&, stats, ());
};

class MockDecoderEventHandler : public DecoderEventHandler {
public:
  MockDecoderEventHandler();
  ~MockDecoderEventHandler() override;

  // SipProxy::DecoderEventHandler
  MOCK_METHOD(FilterStatus, transportBegin, (MessageMetadataSharedPtr metadata));
  MOCK_METHOD(FilterStatus, transportEnd, ());
  MOCK_METHOD(FilterStatus, messageBegin, (MessageMetadataSharedPtr metadata));
  MOCK_METHOD(FilterStatus, messageEnd, ());
};

class MockDecoderCallbacks : public DecoderCallbacks {
public:
  MockDecoderCallbacks();
  ~MockDecoderCallbacks() override;

  MOCK_METHOD(DecoderEventHandler&, newDecoderEventHandler, (MessageMetadataSharedPtr));
  MOCK_METHOD(std::shared_ptr<SipProxy::SipSettings>, settings, (), (const));

  std::shared_ptr<SipProxy::SipSettings> settings_;
};

class MockDirectResponse : public DirectResponse {
public:
  MockDirectResponse();
  ~MockDirectResponse() override;

  // SipProxy::DirectResponse
  MOCK_METHOD(DirectResponse::ResponseType, encode,
              (MessageMetadata & metadata, Buffer::Instance& buffer), (const));
};

namespace Router {
class MockRoute;
} // namespace Router

namespace SipFilters {

class MockDecoderFilter : public DecoderFilter {
public:
  MockDecoderFilter();
  ~MockDecoderFilter() override;

  // SipProxy::SipFilters::DecoderFilter
  MOCK_METHOD(void, onDestroy, ());
  MOCK_METHOD(void, setDecoderFilterCallbacks, (DecoderFilterCallbacks & callbacks));
  MOCK_METHOD(bool, passthroughSupported, (), (const));

  // SipProxy::DecoderEventHandler
  MOCK_METHOD(FilterStatus, passthroughData, (Buffer::Instance & data));
  MOCK_METHOD(FilterStatus, transportBegin, (MessageMetadataSharedPtr metadata));
  MOCK_METHOD(FilterStatus, transportEnd, ());
  MOCK_METHOD(FilterStatus, messageBegin, (MessageMetadataSharedPtr metadata));
  MOCK_METHOD(FilterStatus, messageEnd, ());
};

class MockDecoderFilterCallbacks : public DecoderFilterCallbacks {
public:
  MockDecoderFilterCallbacks();
  ~MockDecoderFilterCallbacks() override;

  // SipProxy::SipFilters::DecoderFilterCallbacks
  MOCK_METHOD(uint64_t, streamId, (), (const));
  MOCK_METHOD(std::string, transactionId, (), (const));
  MOCK_METHOD(const Network::Connection*, connection, (), (const));
  MOCK_METHOD(Router::RouteConstSharedPtr, route, ());
  MOCK_METHOD(Event::Dispatcher&, dispatcher, ());
  MOCK_METHOD(void, sendLocalReply, (const DirectResponse&, bool));
  MOCK_METHOD(void, startUpstreamResponse, ());
  MOCK_METHOD(ResponseStatus, upstreamData, (MessageMetadataSharedPtr));
  MOCK_METHOD(void, resetDownstreamConnection, ());
  MOCK_METHOD(StreamInfo::StreamInfo&, streamInfo, ());
  MOCK_METHOD(std::shared_ptr<Router::TransactionInfos>, transactionInfos, ());
  MOCK_METHOD(std::shared_ptr<SipProxy::SipSettings>, settings, (), (const));
  MOCK_METHOD(std::shared_ptr<SipProxy::TrafficRoutingAssistantHandler>, traHandler, ());
  MOCK_METHOD(void, onReset, ());
  MOCK_METHOD(void, pushIntoPendingList,
              (const std::string&, const std::string&, SipFilters::DecoderFilterCallbacks&,
               std::function<void(void)>));
  MOCK_METHOD(void, onResponseHandleForPendingList,
              (const std::string&, const std::string&,
               std::function<void(MessageMetadataSharedPtr, DecoderEventHandler&)>));
  MOCK_METHOD(void, eraseActiveTransFromPendingList, (std::string&));
  MOCK_METHOD(void, continueHandling, (const std::string&, bool));
  MOCK_METHOD(MessageMetadataSharedPtr, metadata, ());
  MOCK_METHOD(SipFilterStats&, stats, ());

  uint64_t stream_id_{1};
  std::string transaction_id_{"test"};
  NiceMock<Network::MockConnection> connection_;
  std::shared_ptr<Router::MockRoute> route_;
  std::shared_ptr<Router::TransactionInfos> transaction_infos_;
  Stats::TestUtil::TestStore store_;
  SipFilterStats stats_;
};

class MockFilterConfigFactory : public NamedSipFilterConfigFactory {
public:
  MockFilterConfigFactory();
  ~MockFilterConfigFactory() override;

  FilterFactoryCb
  createFilterFactoryFromProto(const Protobuf::Message& proto_config,
                               const std::string& stats_prefix,
                               Server::Configuration::FactoryContext& context) override;

  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<ProtobufWkt::Struct>();
  }

  std::string name() const override { return name_; }

  ProtobufWkt::Struct config_struct_;
  std::string config_stat_prefix_;

private:
  std::shared_ptr<MockDecoderFilter> mock_filter_;
  const std::string name_;
};

} // namespace SipFilters

namespace Router {

class MockRouteEntry : public RouteEntry {
public:
  MockRouteEntry();
  ~MockRouteEntry() override;

  // SipProxy::Router::RouteEntry
  MOCK_METHOD(const std::string&, clusterName, (), (const));
  MOCK_METHOD(const Envoy::Router::MetadataMatchCriteria*, metadataMatchCriteria, (), (const));
  std::string cluster_name_{"fake_cluster"};
};

class MockRoute : public Route {
public:
  MockRoute();
  ~MockRoute() override;

  // SipProxy::Router::Route
  MOCK_METHOD(const RouteEntry*, routeEntry, (), (const));

  NiceMock<MockRouteEntry> route_entry_;
};
} // namespace Router

class MockTrafficRoutingAssistantHandler : public TrafficRoutingAssistantHandler {
public:
  MockTrafficRoutingAssistantHandler(
      ConnectionManager& parent, Event::Dispatcher& dispatcher,
      const envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceConfig& config,
      Server::Configuration::FactoryContext& context, StreamInfo::StreamInfoImpl& stream_info);
  MOCK_METHOD(void, updateTrafficRoutingAssistant,
              (const std::string&, const std::string&, const std::string&,
               const absl::optional<TraContextMap>),
              ());
  MOCK_METHOD(QueryStatus, retrieveTrafficRoutingAssistant,
              (const std::string&, const std::string&, const absl::optional<TraContextMap>,
               SipFilters::DecoderFilterCallbacks&, std::string&),
              ());
  MOCK_METHOD(void, deleteTrafficRoutingAssistant,
              (const std::string&, const std::string&, const absl::optional<TraContextMap>), ());
  MOCK_METHOD(void, subscribeTrafficRoutingAssistant, (const std::string&), ());
  MOCK_METHOD(void, doSubscribe,
              (const envoy::extensions::filters::network::sip_proxy::v3alpha::CustomizedAffinity),
              ());

  // TODO(wbpcode): mock this method will cause the clang-tidy error. To avoid this error and
  // updating the source code, we will not mock this method for now. It is OK because this method is
  // not used in the unit test. If someone wants to mock this method, please update the source code
  // to avoid using the absl::any.
  void complete(const TrafficRoutingAssistant::ResponseType&, const std::string&,
                const absl::any&) override {}

  ~MockTrafficRoutingAssistantHandler() override;
};

class MockConnectionManager : public ConnectionManager {
public:
  MockConnectionManager(Config& config, Random::RandomGenerator& random_generator,
                        TimeSource& time_system, Server::Configuration::FactoryContext& context,
                        std::shared_ptr<Router::TransactionInfos> transaction_infos)
      : ConnectionManager(config, random_generator, time_system, context, transaction_infos) {}

  ~MockConnectionManager() override;

  MOCK_METHOD(std::shared_ptr<TrafficRoutingAssistantHandler>, traHandler, ());
  MOCK_METHOD(std::shared_ptr<SipSettings>, settings, (), (const));
};

class MockTrafficRoutingAssistantHandlerDeep : public TrafficRoutingAssistantHandler {
public:
  MockTrafficRoutingAssistantHandlerDeep(
      ConnectionManager& parent, Event::Dispatcher& dispatcher,
      const envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceConfig& config,
      Server::Configuration::FactoryContext& context, StreamInfo::StreamInfoImpl& stream_info)
      : TrafficRoutingAssistantHandler(parent, dispatcher, config, context, stream_info) {}
  MOCK_METHOD(TrafficRoutingAssistant::ClientPtr&, traClient, (), (override));
};

class MockRequestCallbacks : public TrafficRoutingAssistant::RequestCallbacks {
public:
  // TODO(wbpcode): mock this method will cause the clang-tidy error. To avoid this error and
  // updating the source code, we will not mock this method for now. It is OK because this method is
  // not used in the unit test. If someone wants to mock this method, please update the source code
  // to avoid using the absl::any.
  void complete(const TrafficRoutingAssistant::ResponseType&, const std::string&,
                const absl::any&) override {}
};

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_mock",
    "envoy_cc_test",
    "envoy_cc_test_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_mock(
    name = "mocks",
    srcs = ["mocks.cc"],
    hdrs = ["mocks.h"],
    deps = [
        "//contrib/sip_proxy/filters/network/source:conn_manager_lib",
        "//contrib/sip_proxy/filters/network/source:conn_state_lib",
        "//contrib/sip_proxy/filters/network/source:utility_interface",
        "//contrib/sip_proxy/filters/network/source/filters:factory_base_lib",
        "//contrib/sip_proxy/filters/network/source/filters:filter_interface",
        "//contrib/sip_proxy/filters/network/source/router:router_interface",
        "//test/mocks/grpc:grpc_mocks",
        "//test/mocks/network:network_mocks",
        "//test/mocks/stream_info:stream_info_mocks",
        "//test/test_common:printers_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_test_library(
    name = "utility_lib",
    hdrs = ["utility.h"],
    deps = [
        "//contrib/sip_proxy/filters/network/source:sip_lib",
        "//source/common/buffer:buffer_lib",
        "//source/common/common:byte_order_lib",
        "//test/common/buffer:utility_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_test(
    name = "app_exception_impl_test",
    srcs = ["app_exception_impl_test.cc"],
    deps = [
        "//contrib/sip_proxy/filters/network/source:app_exception_lib",
        "//test/test_common:printers_lib",
        "//test/test_common:utility_lib",
    ],
)

envoy_cc_test(
    name = "config_test",
    srcs = ["config_test.cc"],
    deps = [
        ":mocks",
        "//contrib/sip_proxy/filters/network/source:config",
        "//contrib/sip_proxy/filters/network/source/router:config",
        "//test/mocks/server:factory_context_mocks",
        "//test/test_common:registry_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_test(
    name = "conn_manager_test",
    srcs = ["conn_manager_test.cc"],
    deps = [
        ":mocks",
        ":utility_lib",
        "//contrib/sip_proxy/filters/network/source:config",
        "//contrib/sip_proxy/filters/network/source:conn_manager_lib",
        "//contrib/sip_proxy/filters/network/source:decoder_lib",
        "//contrib/sip_proxy/filters/network/source/filters:filter_interface",
        "//contrib/sip_proxy/filters/network/source/router:config",
        "//contrib/sip_proxy/filters/network/source/router:router_interface",
        "//test/mocks/network:network_mocks",
        "//test/mocks/server:factory_context_mocks",
        "//test/test_common:printers_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_test(
    name = "tra_test",
    srcs = ["tra_test.cc"],
    deps = [
        ":mocks",
        ":utility_lib",
        "//contrib/sip_proxy/filters/network/source:config",
        "//contrib/sip_proxy/filters/network/source:conn_manager_lib",
        "//contrib/sip_proxy/filters/network/source/filters:filter_interface",
        "//contrib/sip_proxy/filters/network/source/router:config",
        "//contrib/sip_proxy/filters/network/source/router:router_interface",
        "//contrib/sip_proxy/filters/network/source/tra:tra_lib",
        "//test/mocks/network:network_mocks",
        "//test/mocks/server:factory_context_mocks",
        "//test/test_common:printers_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/tra/v3alpha:pkg_cc_proto",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_test(
    name = "decoder_test",
    srcs = ["decoder_test.cc"],
    deps = [
        ":mocks",
        ":utility_lib",
        "//contrib/sip_proxy/filters/network/source:app_exception_lib",
        "//contrib/sip_proxy/filters/network/source:config",
        "//contrib/sip_proxy/filters/network/source:conn_manager_lib",
        "//contrib/sip_proxy/filters/network/source:decoder_lib",
        "//contrib/sip_proxy/filters/network/source/filters:filter_interface",
        "//contrib/sip_proxy/filters/network/source/router:config",
        "//contrib/sip_proxy/filters/network/source/router:router_interface",
        "//test/mocks/network:network_mocks",
        "//test/mocks/server:factory_context_mocks",
        "//test/test_common:printers_lib",
        "//test/test_common:utility_lib",
    ],
)

envoy_cc_test(
    name = "router_test",
    srcs = ["router_test.cc"],
    deps = [
        ":mocks",
        ":utility_lib",
        "//contrib/sip_proxy/filters/network/source:app_exception_lib",
        "//contrib/sip_proxy/filters/network/source:config",
        "//contrib/sip_proxy/filters/network/source/router:config",
        "//contrib/sip_proxy/filters/network/source/router:router_lib",
        "//test/mocks/network:network_mocks",
        "//test/mocks/server:factory_context_mocks",
        "//test/mocks/upstream:host_mocks",
        "//test/test_common:printers_lib",
        "//test/test_common:registry_lib",
    ],
)

envoy_cc_test(
    name = "cache_manager_test",
    srcs = ["cache_manager_test.cc"],
    deps = [
        "//contrib/sip_proxy/filters/network/source:utility_interface",
        "//test/test_common:printers_lib",
        "//test/test_common:utility_lib",
    ],
)
#pragma once

#include <initializer_list>

#include "source/common/buffer/buffer_impl.h"
#include "source/common/common/byte_order.h"

#include "test/common/buffer/utility.h"

#include "absl/strings/ascii.h"
#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.h"
#include "contrib/sip_proxy/filters/network/source/sip.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace {

using Envoy::Buffer::addRepeated; // NOLINT(misc-unused-using-decls)
using Envoy::Buffer::addSeq;      // NOLINT(misc-unused-using-decls)

MATCHER_P2(HasAppException, t, m, "") {
  if (!arg.hasAppException()) {
    *result_listener << "has no exception";
    return false;
  }

  if (arg.appExceptionType() != t) {
    *result_listener << "has exception with type " << static_cast<int>(arg.appExceptionType());
    return false;
  }

  if (std::string(m) != arg.appExceptionMessage()) {
    *result_listener << "has exception with message " << arg.appExceptionMessage();
    return false;
  }

  return true;
}

} // namespace
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/sip_proxy/filters/network/source/utility.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

TEST(CacheManagerTest, FindTypeNotExist) {
  auto cache_manager = CacheManager<std::string, std::string, std::string>();
  auto result = cache_manager.at("empty", "empty");
  EXPECT_EQ(absl::nullopt, result);
  EXPECT_EQ(false, cache_manager.contains("empty", "empty"));
}

TEST(CacheManagerTest, FindKeyNotExist) {
  auto cache_manager = CacheManager<std::string, std::string, std::string>();
  cache_manager.initCache("lskpmc", 12);
  cache_manager.insertCache("lskpmc", "S3F2", "192.168.0.1");
  auto result = cache_manager.at("lskpmc", "fake");
  EXPECT_EQ(absl::nullopt, result);
  EXPECT_EQ(true, cache_manager.contains("lskpmc", "S3F2"));
  EXPECT_EQ(false, cache_manager.contains("lskpmc", "fake"));
}

TEST(CacheManagerTest, FindKeyExist) {
  auto cache_manager = CacheManager<std::string, std::string, std::string>();
  cache_manager.insertCache("lskpmc", "S3F2", "192.168.0.1");
  auto result = cache_manager.at("lskpmc", "S3F2");
  EXPECT_EQ("192.168.0.1", result.value().get());
  EXPECT_EQ(true, cache_manager.contains("lskpmc", "S3F2"));
}

TEST(CacheManagerTest, CacheSizeExceed) {
  auto cache_manager = CacheManager<std::string, std::string, std::string>();
  cache_manager.initCache("lskpmc", 2);
  cache_manager.insertCache("lskpmc", "S3F1", "192.168.0.1");
  cache_manager.insertCache("lskpmc", "S3F2", "192.168.0.1");
  cache_manager.insertCache("lskpmc", "S3F3", "192.168.0.1");

  EXPECT_EQ(2, cache_manager["lskpmc"].size());
}

TEST(CacheManagerTest, CacheReplacement) {
  auto cache_manager = CacheManager<std::string, std::string, std::string>();
  cache_manager.initCache("lskpmc", 2);
  cache_manager.insertCache("lskpmc", "S3F1", "192.168.0.1");
  cache_manager.insertCache("lskpmc", "S3F2", "192.168.0.1");
  cache_manager.insertCache("lskpmc", "S3F2", "192.168.0.2");

  EXPECT_EQ(2, cache_manager["lskpmc"].size());
  auto result = cache_manager.at("lskpmc", "S3F2");
  EXPECT_EQ("192.168.0.2", result.value().get());
}

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "source/common/buffer/buffer_impl.h"

#include "test/mocks/network/mocks.h"
#include "test/mocks/server/factory_context.h"
#include "test/test_common/printers.h"
#include "test/test_common/utility.h"

#include "absl/strings/string_view.h"
#include "contrib/sip_proxy/filters/network/source/app_exception_impl.h"
#include "contrib/sip_proxy/filters/network/source/config.h"
#include "contrib/sip_proxy/filters/network/source/conn_manager.h"
#include "contrib/sip_proxy/filters/network/source/decoder.h"
#include "contrib/sip_proxy/filters/network/source/encoder.h"
#include "contrib/sip_proxy/filters/network/test/mocks.h"
#include "contrib/sip_proxy/filters/network/test/utility.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using testing::NiceMock;
using testing::Return;

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

class TestConfigImpl : public ConfigImpl {
public:
  TestConfigImpl(envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy proto_config,
                 Server::Configuration::MockFactoryContext& context,
                 SipFilters::DecoderFilterSharedPtr decoder_filter, SipFilterStats& stats)
      : ConfigImpl(proto_config, context), decoder_filter_(decoder_filter), stats_(stats) {}

  // ConfigImpl
  SipFilterStats& stats() override { return stats_; }
  void createFilterChain(SipFilters::FilterChainFactoryCallbacks& callbacks) override {
    if (custom_filter_) {
      callbacks.addDecoderFilter(custom_filter_);
    }
    callbacks.addDecoderFilter(decoder_filter_);
  }

  SipFilters::DecoderFilterSharedPtr custom_filter_;
  SipFilters::DecoderFilterSharedPtr decoder_filter_;
  SipFilterStats& stats_;
};

class SipDecoderTest : public testing::Test {
public:
  SipDecoderTest()
      : stats_(SipFilterStats::generateStats("test.", *store_.rootScope())),
        transaction_infos_(std::make_shared<Router::TransactionInfos>()) {}
  ~SipDecoderTest() override {
    filter_callbacks_.connection_.dispatcher_.clearDeferredDeleteList();
  }

  void initializeFilter() { initializeFilter(""); }

  void initializeFilter(const std::string& yaml) {
    // Destroy any existing filter first.
    filter_ = nullptr;

    for (const auto& counter : store_.counters()) {
      counter->reset();
    }

    if (yaml.empty()) {
      proto_config_.set_stat_prefix("test");
    } else {
      TestUtility::loadFromYaml(yaml, proto_config_);
      TestUtility::validate(proto_config_);
    }

    proto_config_.set_stat_prefix("test");

    decoder_filter_ = std::make_shared<NiceMock<SipFilters::MockDecoderFilter>>();

    config_ = std::make_unique<TestConfigImpl>(proto_config_, context_, decoder_filter_, stats_);
    if (custom_filter_) {
      config_->custom_filter_ = custom_filter_;
    }

    ON_CALL(random_, random()).WillByDefault(Return(42));
    filter_ = std::make_unique<ConnectionManager>(
        *config_, random_, filter_callbacks_.connection_.dispatcher_.timeSource(), context_,
        transaction_infos_);
    filter_->initializeReadFilterCallbacks(filter_callbacks_);
    filter_->onNewConnection();

    // NOP currently.
    filter_->onAboveWriteBufferHighWatermark();
    filter_->onBelowWriteBufferLowWatermark();
  }

  void headerHandlerTest() {
    MockDecoderCallbacks callback;
    Decoder decoder(callback);
    decoder.setCurrentHeader(HeaderType::Via);
    Decoder::REGISTERHandler msgHandler(decoder);
    Decoder::HeaderHandler headerHandler(msgHandler);
    EXPECT_EQ(HeaderType::Via, headerHandler.currentHeader());

    DecoderStateMachine::DecoderStatus status(State::MessageBegin);
  }

  NiceMock<Server::Configuration::MockFactoryContext> context_;
  std::shared_ptr<SipFilters::MockDecoderFilter> decoder_filter_;
  Stats::TestUtil::TestStore store_;
  SipFilterStats stats_;
  envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy proto_config_;

  std::unique_ptr<TestConfigImpl> config_;

  Buffer::OwnedImpl buffer_;
  Buffer::OwnedImpl write_buffer_;
  NiceMock<Network::MockReadFilterCallbacks> filter_callbacks_;
  NiceMock<Random::MockRandomGenerator> random_;
  std::unique_ptr<ConnectionManager> filter_;
  std::shared_ptr<Router::TransactionInfos> transaction_infos_;
  SipFilters::DecoderFilterSharedPtr custom_filter_;
};

const std::string yaml = R"EOF(
stat_prefix: egress
route_config:
  name: local_route
  routes:
  - match:
      domain: "test"
    route:
      cluster: "test"
settings:
  transaction_timeout: 32s
  local_services:
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : transport
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : x-suri
  - domain: pcsf-cfed.cncs.svc.cluster.local
    parameter : host
)EOF";

TEST_F(SipDecoderTest, DecodeINVITE) {
  initializeFilter(yaml);

  const std::string SIP_INVITE_FULL =
      "INVITE sip:User.0000@tas01.defult.svc.cluster.local;ep=127.0.0.1 SIP/2.0\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Route: "
      "<sip:+16959000000:15306;role=anch;lr;transport=udp;x-suri=sip:pcsf-cfed.cncs.svc.cluster."
      "local:5060>\x0d\x0a"
      "Record-Route: "
      "<sip:+16959000000:15306;role=anch;lr;transport=udp;x-suri=sip:pcsf-cfed.cncs.svc.cluster."
      "local:5060>\x0d\x0a"
      "Service-Route: "
      "<sip:test@pcsf-cfed.cncs.svc.cluster.local;role=anch;lr;transport=udp;x-suri=sip:scsf-cfed."
      "cncs.svc.cluster.local:5060>\x0d\x0a"
      "Path: "
      "<sip:10.177.8.232;x-fbi=cfed;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;inst-ip=192."
      "169.110.53;lr;ottag=ue_term;bidx=563242011197570;access-type=ADSL;x-alu-prset-id>\x0d\x0a"
      "CSeq: 1 INVITE\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "P-Charging-Vector: orig-ioi=ims.com;term-ioi= ims.com\x0d\x0a"
      "P-Charging-Vector: orig-ioi=ims1.com;term-ioi= ims1.com\x0d\x0a"
      "P-Charging-Function-Addresses: ccf=0.0.0.0\x0d\x0a"
      "P-Nokia-Cookie-IP-Mapping: S1F1=10.0.0.1\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";

  buffer_.add(SIP_INVITE_FULL);
  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  Buffer::OwnedImpl response_buffer;

  EXPECT_EQ(1U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, DecodeRegister) {
  initializeFilter(yaml);

  const std::string SIP_REGISTER_FULL =
      "REGISTER sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "CSeq: 1 REGISTER\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "Expires: 7200\x0d\x0a"
      "Supported: 100rel,timer\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "Require: Path\x0d\x0a"
      "Path: "
      "<sip:10.177.8.232;x-fbi=cfed;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;inst-ip=192."
      "169.110.53;lr;ottag=ue_term;bidx=563242011197570;access-type=ADSL;x-alu-prset-id>\x0d\x0a"
      "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Service-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Authorization: Digest username=\"tc05sub1@cncs.nokialab.com\", realm=\"cncs.nokialab.com\", "
      "nonce=\"436dbd0f60a52adc2DPadc43f91c774b51ac4cad614258c43cf9df\", algorithm=MD5, "
      "uri=\"sip:10.30.29.47\", response=\"c4f3c2fccdca9c5febc66d4226b5afae\", nc=01201201, "
      "cnonce=\"123456\", qop=auth\x0d\x0a"
      "Authorization: Digest username=\"tc05sub1@cncs.nokialab.com\", realm=\"cncs.nokialab.com\", "
      "nonce=\"436dbd0f60a52adc2DPadc43f91c774b51ac4cad614258c43cf9df\", algorithm=MD5, "
      "uri=\"sip:10.30.29.47\", response=\"c4f3c2fccdca9c5febc66d4226b5afae\", nc=01201201, "
      "cnonce=\"123456\", qop=auth, opaque=\"127.0.0.1\"\x0d\x0a"
      "Authorization: Digest username=\"tc05sub1@cncs.nokialab.com\", realm=\"cncs.nokialab.com\", "
      "nonce=\"436dbd0f60a52adc2DPadc43f91c774b51ac4cad614258c43cf9df\", algorithm=MD5, "
      "uri=\"sip:10.30.29.47\", response=\"c4f3c2fccdca9c5febc66d4226b5afae\", nc=01201201, "
      "cnonce=\"123456\", qop=auth, opaque=\"127.0.0.1\x0d\x0a"
      "P-Nokia-Cookie-IP-Mapping: S1F1=10.0.0.1\x0d\x0a"
      "\x0d\x0a";

  buffer_.add(SIP_REGISTER_FULL);
  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  EXPECT_EQ(1U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, DecodeOK200) {
  initializeFilter(yaml);

  const std::string SIP_OK200_FULL =
      "SIP/2.0 200 OK\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "CSeq: 1 INVITE\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Service-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "Path: "
      "<sip:10.177.8.232;x-fbi=cfed;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;inst-ip=192."
      "169.110.53;lr;ottag=ue_term;bidx=563242011197570;access-type=ADSL;x-alu-prset-id>\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_OK200_FULL);
  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  const std::string SIP_OK200_REGISTER =
      "SIP/2.0 200 OK\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "CSeq: 1 Register\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Service-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_OK200_REGISTER);
  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  EXPECT_EQ(2U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, DecodeOK200EmptyHeader) {
  initializeFilter(yaml);

  const std::string SIP_OK200_EMPTY_HEADER =
      "SIP/2.0 200 OK\x0d\x0a"
      "Via:SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "From:<sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "To:<sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "Call-ID:1-3193@11.0.0.10\x0d\x0a"
      "CSeq:100 REGISTER\x0d\x0a"
      "Session-ID:fdc85ff600804114a90b50e04de2b988;remote=b74c76b50080450dabd12317fb6b8aa7\x0d\x0a"
      "User-Agent:test-client-v1.1\x0d\x0a"
      "Supported:\x0d\x0a"
      "Contact:<sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "Content-Length:0\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_OK200_EMPTY_HEADER);
  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  EXPECT_EQ(1U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, DecodeOK200DifferentHeaderFormats) {
  initializeFilter(yaml);

  const std::string SIP_OK200_DIFF_HEADER_FORMATS =
      "SIP/2.0 200 OK\x0d\x0a"
      "Via:             SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "From          :<sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "To      :           <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "Call-ID:1-3193@11.0.0.10\x0d\x0a"
      "CSeq: 100 REGISTER\x0d\x0a"
      "Session-ID:   fdc85ff600804114ae04de2b988;remote=b74c76b50050dabd12317fb6b8aa7\x0d\x0a"
      "User-Agent  :    test-client-v1.1\x0d\x0a"
      "Supported   :\x0d\x0a"
      "Contact  :  <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "Content-Length: 0\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_OK200_DIFF_HEADER_FORMATS);
  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  EXPECT_EQ(1U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, DecodeGeneral) {
  initializeFilter(yaml);

  const std::string SIP_CANCEL_FULL =
      "CANCEL sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp;ep=cfed>\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp;ep=cfed>\x0d\x0a"
      "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "CSeq: 1 CANCEL\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "Path: "
      "<sip:10.177.8.232;x-fbi=cfed;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;inst-ip=192."
      "169.110.53;lr;ottag=ue_term;bidx=563242011197570;access-type=ADSL;x-alu-prset-id>\x0d\x0a"
      "P-Nokia-Cookie-IP-Mapping: S1F1=10.0.0.1\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";

  buffer_.add(SIP_CANCEL_FULL);
  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  EXPECT_EQ(1U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, DecodeSUBSCRIBE) {
  initializeFilter(yaml);

  const std::string SIP_SUBSCRIBE_FULL =
      "SUBSCRIBE sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp;ep=cfed>\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "CSeq: 2 SUBSCRIBE\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "P-Nokia-Cookie-IP-Mapping: S1F1=10.0.0.1\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "Event: feature-status-exchange\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_SUBSCRIBE_FULL);
  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  const std::string SIP_SUBSCRIBE_REG =
      "SUBSCRIBE sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp;ep=cfed>\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "CSeq: 2 SUBSCRIBE\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "Event: reg\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_SUBSCRIBE_REG);
  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  EXPECT_EQ(2U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, DecodeFAILURE4XX) {
  initializeFilter(yaml);

  const std::string SIP_FAILURE4XX_FULL =
      "SIP/2.0 401 Unauthorized\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>\x0d\x0a"
      "Via: SIP/2.0/TCP "
      "192.169.110.15:5060;branch=z9hG4bK1f6eb66cd87d2ae67c4b8a69d67c4f7e60a522a8-0-b-"
      "60a52adb349a8674\x0d\x0a"
      "Via: SIP/2.0/UDP 127.0.0.1;branch=z9hG4bK_0002_34-139705093266412;lsstag=pt-1.12\x0d\x0a"
      "Via: SIP/2.0/UDP 10.30.29.58:38612;received=10.30.29.58;branch=z9hG4bK1434\x0d\x0a"
      "From: <sip:tc05sub1@cncs.nokialab.com>;tag=587215\x0d\x0a"
      "To: <sip:tc05sub1@cncs.nokialab.com>;tag=182294901\x0d\x0a"
      "Call-ID: tc05sub1-1@10.30.29.58-38612\x0d\x0a"
      "CSeq: 6 REGISTER\x0d\x0a"
      "P-Charging-Vector: icid-value=\"PCSF:1-cfed-0-1-0000000060a52adb-000000000000000b\"\x0d\x0a"
      "WWW-Authenticate: Digest "
      "realm=\"cncs.nokialab.com\",nonce="
      "\"436dbd0f60a52adc2DPadc43f91c774b51ac4cad614258c43cf9df\",algorithm=MD5,qop="
      "\"auth\"\x0d\x0a"
      "WWW-Authenticate: Digest "
      "realm=\"cncs.nokialab.com\",nonce="
      "\"436dbd0f60a52adc2DPadc43f91c774b51ac4cad614258c43cf9df\",algorithm=MD5,qop=\"auth\","
      "opaque=\"127.0.0.1\"\x0d\x0a"
      "WWW-Authenticate: Digest "
      "realm=\"cncs.nokialab.com\",nonce="
      "\"436dbd0f60a52adc2DPadc43f91c774b51ac4cad614258c43cf9df\",algorithm=MD5,qop=\"auth\","
      "opaque=\"127.0.0.1\x0d\x0a"
      "P-Nokia-Cookie-IP-Mapping: S1F1=10.0.0.1\x0d\x0a"
      "Content-Length: 0\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_FAILURE4XX_FULL);
  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  EXPECT_EQ(1U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, DecodeEMPTY) {
  initializeFilter(yaml);

  const std::string SIP_EMPTY = "\x0d\x0a";
  buffer_.add(SIP_EMPTY);
  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  const std::string SIP_WRONG_METHOD_TYPE =
      "WRONGMETHOD sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "CSeq: 2 SUBSCRIBE\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>;tag=1\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_WRONG_METHOD_TYPE);

  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  const std::string SIP_NO_CONTENT_LENGTH =
      "ACK sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "CSeq: 2 ACK\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>;tag=1\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_NO_CONTENT_LENGTH);

  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  const std::string SIP_CONTENT_LENGTH_ZERO =
      "ACK sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "CSeq: 2 ACK\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>;tag=1\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Length:  -1\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_NO_CONTENT_LENGTH);

  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);

  EXPECT_EQ(1U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, DecodeAck) {
  initializeFilter(yaml);

  const std::string SIP_ACK_FULL =
      "ACK sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "CSeq: 2 ACK\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>;tag=1\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_ACK_FULL);

  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);
  EXPECT_EQ(1U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, DecodeBYE) {
  initializeFilter(yaml);

  const std::string SIP_BYE_FULL =
      "BYE sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "CSeq: 2 BYE\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>;tag=1\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_BYE_FULL);

  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);
  EXPECT_EQ(1U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, DecodeUPDATE) {
  initializeFilter(yaml);

  const std::string SIP_UPDATE_FULL =
      "UPDATE sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "CSeq: 2 UPDATE\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>;tag=1\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_UPDATE_FULL);

  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);
  EXPECT_EQ(1U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, DecodeREFER) {
  initializeFilter(yaml);

  const std::string SIP_REFER_FULL =
      "REFER sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "CSeq: 2 REFER\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>;tag=1\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_REFER_FULL);

  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);
  EXPECT_EQ(1U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, DecodeNOTIFY) {
  initializeFilter(yaml);

  const std::string SIP_NOTIFY_FULL =
      "NOTIFY sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0\x0d\x0a"
      "Call-ID: 1-3193@11.0.0.10\x0d\x0a"
      "Via: SIP/2.0/TCP 11.0.0.10:15060;branch=z9hG4bK-3193-1-0\x0d\x0a"
      "To: <sip:User.0000@tas01.defult.svc.cluster.local>\x0d\x0a"
      "From: <sip:User.0001@tas01.defult.svc.cluster.local>;tag=1\x0d\x0a"
      "Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "CSeq: 1 NOTIFY\x0d\x0a"
      "Contact: <sip:User.0001@11.0.0.10:15060;transport=TCP>;tag=1\x0d\x0a"
      "Record-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Service-Route: <sip:+16959000000:15306;role=anch;lr;transport=udp>\x0d\x0a"
      "Path: "
      "<sip:10.177.8.232;x-fbi=cfed;x-suri=sip:pcsf-cfed.cncs.svc.cluster.local:5060;inst-ip=192."
      "169.110.53;lr;ottag=ue_term;bidx=563242011197570;access-type=ADSL;x-alu-prset-id>\x0d\x0a"
      "P-Nokia-Cookie-IP-Mapping: S1F1=10.0.0.1\x0d\x0a"
      "Max-Forwards: 70\x0d\x0a"
      "Content-Length:  0\x0d\x0a"
      "\x0d\x0a";
  buffer_.add(SIP_NOTIFY_FULL);

  EXPECT_EQ(filter_->onData(buffer_, false), Network::FilterStatus::StopIteration);
  EXPECT_EQ(1U, store_.counter("test.request").value());
  EXPECT_EQ(1U, stats_.request_active_.value());
  EXPECT_EQ(0U, store_.counter("test.response").value());
}

TEST_F(SipDecoderTest, HeaderTest) {
  StateNameValues stateNameValues_;
  EXPECT_EQ("Done", stateNameValues_.name(State::Done));
}

TEST_F(SipDecoderTest, HeaderHandlerTest) { headerHandlerTest(); }

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/config/typed_config.h"
#include "envoy/server/filter_config.h"

#include "source/common/common/macros.h"
#include "source/common/protobuf/protobuf.h"

#include "contrib/sip_proxy/filters/network/source/filters/filter.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace SipFilters {

/**
 * Implemented by each Sip filter and registered via Registry::registerFactory or the
 * convenience class RegisterFactory.
 */
class NamedSipFilterConfigFactory : public Envoy::Config::TypedFactory {
public:
  ~NamedSipFilterConfigFactory() override = default;

  /**
   * Create a particular sip filter factory implementation. If the implementation is unable to
   * produce a factory with the provided parameters, it should throw an EnvoyException in the case
   * of general error. The returned callback should always be initialized.
   * @param config supplies the configuration for the filter
   * @param stat_prefix prefix for stat logging
   * @param context supplies the filter's context.
   * @return FilterFactoryCb the factory creation function.
   */
  virtual FilterFactoryCb
  createFilterFactoryFromProto(const Protobuf::Message& config, const std::string& stat_prefix,
                               Server::Configuration::FactoryContext& context) PURE;

  std::string category() const override { return "envoy.sip_proxy.filters"; }
};

} // namespace SipFilters
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "source/common/protobuf/utility.h"

#include "contrib/sip_proxy/filters/network/source/filters/filter_config.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace SipFilters {

template <class ConfigProto> class FactoryBase : public NamedSipFilterConfigFactory {
public:
  FilterFactoryCb
  createFilterFactoryFromProto(const Protobuf::Message& proto_config,
                               const std::string& stats_prefix,
                               Server::Configuration::FactoryContext& context) override {
    return createFilterFactoryFromProtoTyped(MessageUtil::downcastAndValidate<const ConfigProto&>(
                                                 proto_config, context.messageValidationVisitor()),
                                             stats_prefix, context);
  }

  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<ConfigProto>();
  }

  std::string name() const override { return name_; }

protected:
  FactoryBase(const std::string& name) : name_(name) {}

private:
  virtual FilterFactoryCb
  createFilterFactoryFromProtoTyped(const ConfigProto& proto_config,
                                    const std::string& stats_prefix,
                                    Server::Configuration::FactoryContext& context) PURE;

  const std::string name_;
};

} // namespace SipFilters
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "contrib/sip_proxy/filters/network/source/filters/filter.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace SipFilters {

/**
 * Pass through Sip decoder filter. Continue at each decoding state within the series of
 * transitions.
 */
class PassThroughDecoderFilter : public DecoderFilter {
public:
  // SipDecoderFilter
  void onDestroy() override {}

  void setDecoderFilterCallbacks(DecoderFilterCallbacks& callbacks) override {
    decoder_callbacks_ = &callbacks;
  };

  // Sip Decoder State Machine
  SipProxy::FilterStatus transportBegin(SipProxy::MessageMetadataSharedPtr) override {
    return SipProxy::FilterStatus::Continue;
  }

  SipProxy::FilterStatus transportEnd() override { return SipProxy::FilterStatus::Continue; }

  SipProxy::FilterStatus messageBegin(SipProxy::MessageMetadataSharedPtr) override {
    return SipProxy::FilterStatus::Continue;
  }

  SipProxy::FilterStatus messageEnd() override { return SipProxy::FilterStatus::Continue; }

protected:
  DecoderFilterCallbacks* decoder_callbacks_{};
};

} // namespace SipFilters
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_library(
    name = "filter_config_interface",
    hdrs = ["filter_config.h"],
    deps = [
        ":filter_interface",
        "//envoy/config:typed_config_interface",
        "//envoy/server:filter_config_interface",
        "//source/common/common:macros",
        "//source/common/protobuf:cc_wkt_protos",
    ],
)

envoy_cc_library(
    name = "factory_base_lib",
    hdrs = ["factory_base.h"],
    deps = [
        ":filter_config_interface",
        "//source/common/protobuf:utility_lib",
    ],
)

envoy_cc_library(
    name = "filter_interface",
    hdrs = ["filter.h"],
    deps = [
        "//contrib/sip_proxy/filters/network/source:decoder_events_lib",
        "//contrib/sip_proxy/filters/network/source:sip_lib",
        "//contrib/sip_proxy/filters/network/source:stats_lib",
        "//contrib/sip_proxy/filters/network/source:utility_interface",
        "//contrib/sip_proxy/filters/network/source/router:router_interface",
        "//contrib/sip_proxy/filters/network/source/tra:tra_lib",
        "//envoy/buffer:buffer_interface",
        "//envoy/network:connection_interface",
        "//envoy/stream_info:stream_info_interface",
    ],
)

envoy_cc_library(
    name = "well_known_names",
    hdrs = ["well_known_names.h"],
    deps = [
        "//source/common/singleton:const_singleton",
    ],
)

envoy_cc_library(
    name = "pass_through_filter_lib",
    hdrs = ["pass_through_filter.h"],
    deps = [
        ":filter_interface",
    ],
)
#pragma once

#include "envoy/buffer/buffer.h"
#include "envoy/network/connection.h"
#include "envoy/stream_info/stream_info.h"

#include "contrib/sip_proxy/filters/network/source/decoder_events.h"
#include "contrib/sip_proxy/filters/network/source/router/router.h"
#include "contrib/sip_proxy/filters/network/source/sip.h"
#include "contrib/sip_proxy/filters/network/source/stats.h"
#include "contrib/sip_proxy/filters/network/source/tra/tra.h"
#include "contrib/sip_proxy/filters/network/source/utility.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
class TrafficRoutingAssistantHandler;
namespace SipFilters {

enum class ResponseStatus {
  MoreData = 0, // The upstream response requires more data.
  Complete = 1, // The upstream response is complete.
  Reset = 2,    // The upstream response is invalid and its connection must be reset.
};

/**
 * Decoder filter callbacks add additional callbacks.
 */
class DecoderFilterCallbacks : public SipProxy::PendingListHandler {
public:
  ~DecoderFilterCallbacks() override = default;

  /**
   * @return uint64_t the ID of the originating stream for logging purposes.
   */
  virtual uint64_t streamId() const PURE;

  /**
   * @return string the ID of the transaction.
   */
  virtual std::string transactionId() const PURE;

  /**
   * @return const Network::Connection* the originating connection, or nullptr if there is none.
   */
  virtual const Network::Connection* connection() const PURE;

  /**
   * @return RouteConstSharedPtr the route for the current request.
   */
  virtual Router::RouteConstSharedPtr route() PURE;

  virtual SipFilterStats& stats() PURE;

  /**
   * Create a locally generated response using the provided response object.
   * @param response DirectResponse the response to send to the downstream client
   * @param end_stream if true, the downstream connection should be closed after this response
   */
  virtual void sendLocalReply(const SipProxy::DirectResponse& response, bool end_stream) PURE;

  /**
   * Indicates the start of an upstream response. May only be called once.
   * @param transport the transport used by the upstream response
   * @param protocol the protocol used by the upstream response
   */
  virtual void startUpstreamResponse() PURE;

  /**
   * Called with upstream response data.
   * @param data supplies the upstream's data
   * @return ResponseStatus indicating if the upstream response requires more data, is complete,
   *         or if an error occurred requiring the upstream connection to be reset.
   */
  virtual ResponseStatus upstreamData(MessageMetadataSharedPtr metadata) PURE;

  /**
   * Reset the downstream connection.
   */
  virtual void resetDownstreamConnection() PURE;

  /**
   * @return StreamInfo for logging purposes.
   */
  virtual StreamInfo::StreamInfo& streamInfo() PURE;

  virtual std::shared_ptr<Router::TransactionInfos> transactionInfos() PURE;
  virtual std::shared_ptr<SipProxy::SipSettings> settings() const PURE;
  virtual std::shared_ptr<SipProxy::TrafficRoutingAssistantHandler> traHandler() PURE;
  virtual void onReset() PURE;
  virtual void continueHandling(const std::string& key, bool try_next_affinity) PURE;
  virtual MessageMetadataSharedPtr metadata() PURE;
};

/**
 * Decoder filter interface.
 */
class DecoderFilter : public virtual DecoderEventHandler {
public:
  ~DecoderFilter() override = default;

  /**
   * This routine is called prior to a filter being destroyed. This may happen after normal stream
   * finish (both downstream and upstream) or due to reset. Every filter is responsible for making
   * sure that any async events are cleaned up in the context of this routine. This includes timers,
   * network calls, etc. The reason there is an onDestroy() method vs. doing this type of cleanup
   * in the destructor is due to the deferred deletion model that Envoy uses to avoid stack unwind
   * complications. Filters must not invoke either encoder or decoder filter callbacks after having
   * onDestroy() invoked.
   */
  virtual void onDestroy() PURE;

  /**
   * Called by the connection manager once to initialize the filter decoder callbacks that the
   * filter should use. Callbacks will not be invoked by the filter after onDestroy() is called.
   */
  virtual void setDecoderFilterCallbacks(DecoderFilterCallbacks& callbacks) PURE;
};

using DecoderFilterSharedPtr = std::shared_ptr<DecoderFilter>;

/**
 * These callbacks are provided by the connection manager to the factory so that the factory can
 * build the filter chain in an application specific way.
 */
class FilterChainFactoryCallbacks {
public:
  virtual ~FilterChainFactoryCallbacks() = default;

  /**
   * Add a decoder filter that is used when reading connection data.
   * @param filter supplies the filter to add.
   */
  virtual void addDecoderFilter(DecoderFilterSharedPtr filter) PURE;
};

/**
 * This function is used to wrap the creation of a Sip filter chain for new connections as they
 * come in. Filter factories create the function at configuration initialization time, and then
 * they are used at runtime.
 * @param callbacks supplies the callbacks for the stream to install filters to. Typically the
 * function will install a single filter, but it's technically possibly to install more than one
 * if desired.
 */
using FilterFactoryCb = std::function<void(FilterChainFactoryCallbacks& callbacks)>;

/**
 * A FilterChainFactory is used by a connection manager to create a Sip level filter chain when
 * a new connection is created. Typically it would be implemented by a configuration engine that
 * would install a set of filters that are able to process an application scenario on top of a
 * stream of Sip requests.
 */
class FilterChainFactory {
public:
  virtual ~FilterChainFactory() = default;

  /**
   * Called when a new Sip stream is created on the connection.
   * @param callbacks supplies the "sink" that is used for actually creating the filter chain. @see
   *                  FilterChainFactoryCallbacks.
   */
  virtual void createFilterChain(FilterChainFactoryCallbacks& callbacks) PURE;
};

} // namespace SipFilters
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include <string>

#include "source/common/singleton/const_singleton.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace SipFilters {

/**
 * Well-known http filter names.
 * NOTE: New filters should use the well known name: envoy.filters.sip.name.
 */
class SipFilterNameValues {
public:
  // Router filter
  const std::string ROUTER = "envoy.filters.sip.router";
  const std::string SipProxy = "envoy.filters.network.sip_proxy";
};

using SipFilterNames = ConstSingleton<SipFilterNameValues>;

} // namespace SipFilters

// const std::string SipProxy = "envoy.filters.network.sip_proxy";

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/tcp/conn_pool.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

enum class ConnectionState {
  NotConnected,
  Connecting,
  Connected,
};

/** Not used
 * SipConnectionState tracks sip-related connection state for pooled
 * connections.
 */
// class SipConnectionState : public Tcp::ConnectionPool::ConnectionState {
// public:
//  SipConnectionState(SipProxy::ConnectionState state, int32_t initial_sequence_id = 0)
//      : state_(state), next_sequence_id_(initial_sequence_id) {}
//
//  /**
//   * @return int32_t the next Sip sequence id to use for this connection.
//   */
//  int32_t nextSequenceId() {
//    if (next_sequence_id_ == std::numeric_limits<int32_t>::max()) {
//      next_sequence_id_ = 0;
//      return std::numeric_limits<int32_t>::max();
//    }
//
//    return next_sequence_id_++;
//  }
//
//  SipProxy::ConnectionState state() { return state_; }
//
// private:
//  SipProxy::ConnectionState state_;
//  int32_t next_sequence_id_;
//};

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "contrib/sip_proxy/filters/network/source/metadata.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

enum class QueryStatus {
  // Do grpc query
  Pending,

  // Existed in local cache
  Continue,

  // Not existed in local cache and not do grpc query
  Stop
};

enum class FilterStatus {
  // Continue filter chain iteration.
  Continue,

  // Stop iterating over filters in the filter chain.
  StopIteration
};

class DecoderEventHandler {
public:
  virtual ~DecoderEventHandler() = default;

  /**
   * Indicates the start of a Sip transport frame was detected. Unframed transports generate
   * simulated start messages.
   * @param metadata MessageMetadataSharedPtr describing as much as is currently known about the
   *                                          message
   */
  virtual FilterStatus transportBegin(MessageMetadataSharedPtr metadata) PURE;

  /**
   * Indicates the end of a Sip transport frame was detected. Unframed transport generate
   * simulated complete messages.
   */
  virtual FilterStatus transportEnd() PURE;

  /**
   * Indicates that the start of a Sip protocol message was detected.
   * @param metadata MessageMetadataSharedPtr describing the message
   * @return FilterStatus to indicate if filter chain iteration should continue
   */
  virtual FilterStatus messageBegin(MessageMetadataSharedPtr metadata) PURE;

  /**
   * Indicates that the end of a Sip protocol message was detected.
   * @return FilterStatus to indicate if filter chain iteration should continue
   */
  virtual FilterStatus messageEnd() PURE;
};

using DecoderEventHandlerSharedPtr = std::shared_ptr<DecoderEventHandler>;

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/sip_proxy/filters/network/source/tra/tra_impl.h"

#include "envoy/config/core/v3/grpc_service.pb.h"
#include "envoy/stats/scope.h"

#include "source/common/common/assert.h"
#include "source/common/http/header_map_impl.h"
#include "source/common/http/headers.h"
#include "source/common/protobuf/protobuf.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace TrafficRoutingAssistant {

GrpcClientImpl::GrpcClientImpl(const Grpc::RawAsyncClientSharedPtr& async_client,
                               Event::Dispatcher& dispatcher,
                               const absl::optional<std::chrono::milliseconds>& timeout)
    : async_client_(async_client), dispatcher_(dispatcher), timeout_(timeout) {}

GrpcClientImpl::~GrpcClientImpl() {
  while (!request_callbacks_.empty()) {
    request_callbacks_.front()->request_->cancel();
    request_callbacks_.front()->cleanup();
  }

  while (!stream_callbacks_.empty()) {
    stream_callbacks_.front()->stream_.resetStream();
    stream_callbacks_.front()->cleanup();
  }
}

void GrpcClientImpl::setRequestCallbacks(RequestCallbacks& callbacks) {
  // ASSERT(callbacks_ == nullptr);
  callbacks_ = &callbacks;
}

void GrpcClientImpl::createTrafficRoutingAssistant(
    const std::string& type, const absl::flat_hash_map<std::string, std::string>& data,
    const absl::optional<TraContextMap> context, Tracing::Span& parent_span,
    const StreamInfo::StreamInfo& stream_info) {

  envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceRequest request;
  request.set_type(type);

  for (auto& item : data) {
    (*request.mutable_create_request()->mutable_data())[item.first] = item.second;
  }

  if (context.has_value()) {
    for (auto& item : context.value()) {
      (*request.mutable_create_request()->mutable_context())[item.first] = item.second;
    }
  }

  return sendRequest("envoy.extensions.filters.network.sip_proxy.tra.v3alpha.TraService.Create",
                     request, parent_span, stream_info);
}

void GrpcClientImpl::updateTrafficRoutingAssistant(
    const std::string& type, const absl::flat_hash_map<std::string, std::string>& data,
    const absl::optional<TraContextMap> context, Tracing::Span& parent_span,
    const StreamInfo::StreamInfo& stream_info) {
  envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceRequest request;
  request.set_type(type);

  for (auto& item : data) {
    (*request.mutable_update_request()->mutable_data())[item.first] = item.second;
  }

  if (context.has_value()) {
    for (auto& item : context.value()) {
      (*request.mutable_update_request()->mutable_context())[item.first] = item.second;
    }
  }

  return sendRequest("envoy.extensions.filters.network.sip_proxy.tra.v3alpha.TraService.Update",
                     request, parent_span, stream_info);
}

void GrpcClientImpl::retrieveTrafficRoutingAssistant(const std::string& type,
                                                     const std::string& key,
                                                     const absl::optional<TraContextMap> context,
                                                     Tracing::Span& parent_span,
                                                     const StreamInfo::StreamInfo& stream_info) {

  envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceRequest request;
  request.set_type(type);
  request.mutable_retrieve_request()->set_key(key);

  if (context.has_value()) {
    for (auto& item : context.value()) {
      (*request.mutable_retrieve_request()->mutable_context())[item.first] = item.second;
    }
  }

  return sendRequest("envoy.extensions.filters.network.sip_proxy.tra.v3alpha.TraService.Retrieve",
                     request, parent_span, stream_info);
}

void GrpcClientImpl::deleteTrafficRoutingAssistant(const std::string& type, const std::string& key,
                                                   const absl::optional<TraContextMap> context,
                                                   Tracing::Span& parent_span,
                                                   const StreamInfo::StreamInfo& stream_info) {

  envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceRequest request;
  request.set_type(type);
  request.mutable_delete_request()->set_key(key);

  if (context.has_value()) {
    for (auto& item : context.value()) {
      (*request.mutable_delete_request()->mutable_context())[item.first] = item.second;
    }
  }

  return sendRequest("envoy.extensions.filters.network.sip_proxy.tra.v3alpha.TraService.Delete",
                     request, parent_span, stream_info);
}

void GrpcClientImpl::subscribeTrafficRoutingAssistant(const std::string& type,
                                                      Tracing::Span& parent_span,
                                                      const StreamInfo::StreamInfo& stream_info) {
  envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceRequest request;

  request.set_type(type);
  request.mutable_subscribe_request();

  const auto& service_method = *Protobuf::DescriptorPool::generated_pool()->FindMethodByName(
      "envoy.extensions.filters.network.sip_proxy.tra.v3alpha.TraService.Subscribe");
  std::unique_ptr<AsyncStreamCallbacks> callback = std::make_unique<AsyncStreamCallbacks>(*this);
  callback->stream_ = async_client_->start(service_method, *callback,
                                           Http::AsyncClient::StreamOptions().setParentContext(
                                               Http::AsyncClient::ParentContext{&stream_info}));
  if (callback->stream_ == nullptr) {
    onFailure(Grpc::Status::WellKnownGrpcStatus::Unavailable,
              "Unable to establish new stream to tra server", parent_span);
    return;
  }
  LinkedList::moveIntoList(std::move(callback), stream_callbacks_);
}

void GrpcClientImpl::sendRequest(
    const std::string& method,
    envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceRequest& request,
    Tracing::Span& parent_span, const StreamInfo::StreamInfo& stream_info) {

  const auto& service_method =
      *Protobuf::DescriptorPool::generated_pool()->FindMethodByName(method);
  std::unique_ptr<AsyncRequestCallbacks> callback = std::make_unique<AsyncRequestCallbacks>(*this);
  callback->request_ =
      async_client_->send(service_method, request, *callback, parent_span,
                          Http::AsyncClient::RequestOptions().setTimeout(timeout_).setParentContext(
                              Http::AsyncClient::ParentContext{&stream_info}));
  if (callback->request_ != nullptr) {
    LinkedList::moveIntoList(std::move(callback), request_callbacks_);
  }

  // Already invoke `onFailure` asynchronously, no need to call it explicitly here.
}

void GrpcClientImpl::onSuccess(
    std::unique_ptr<
        envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>&&
        response,
    Tracing::Span& span) {

  UNREFERENCED_PARAMETER(span);
  if (response->has_create_response()) {
    callbacks_->complete(ResponseType::CreateResp, response->type(), response->create_response());
  } else if (response->has_update_response()) {
    callbacks_->complete(ResponseType::UpdateResp, response->type(), response->update_response());
  } else if (response->has_retrieve_response()) {
    callbacks_->complete(ResponseType::RetrieveResp, response->type(),
                         response->retrieve_response());
  } else if (response->has_delete_response()) {
    callbacks_->complete(ResponseType::DeleteResp, response->type(), response->delete_response());
  }
  // callbacks_ = nullptr;
}

void GrpcClientImpl::onFailure(Grpc::Status::GrpcStatus status, const std::string& message,
                               Tracing::Span&) {
  ASSERT(status != Grpc::Status::WellKnownGrpcStatus::Ok);
  ENVOY_LOG(error, "GrpcClientImpl Failure {} {}", message, status);
  // callbacks_->complete(ResponseType::FailureResp, "", absl::any());
  // callbacks_ = nullptr;
}

void GrpcClientImpl::onReceiveMessage(
    std::unique_ptr<
        envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>&&
        message) {
  callbacks_->complete(ResponseType::SubscribeResp, message->type(), message->subscribe_response());
  // callbacks_ = nullptr;
}

ClientPtr traClient(Event::Dispatcher& dispatcher, Server::Configuration::FactoryContext& context,
                    const envoy::config::core::v3::GrpcService& grpc_service,
                    const std::chrono::milliseconds timeout) {
  // TODO(ramaraochavali): register client to singleton when GrpcClientImpl supports concurrent
  // requests.
  return std::make_unique<SipProxy::TrafficRoutingAssistant::GrpcClientImpl>(
      context.serverFactoryContext()
          .clusterManager()
          .grpcAsyncClientManager()
          .getOrCreateRawAsyncClient(grpc_service, context.scope(), true),
      dispatcher, timeout);
}

} // namespace TrafficRoutingAssistant
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/config/core/v3/grpc_service.pb.h"
#include "envoy/grpc/async_client.h"
#include "envoy/grpc/async_client_manager.h"
#include "envoy/server/filter_config.h"
#include "envoy/stats/scope.h"
#include "envoy/tracing/tracer.h"
#include "envoy/upstream/cluster_manager.h"

#include "source/common/common/linked_object.h"
#include "source/common/common/logger.h"
#include "source/common/common/macros.h"
#include "source/common/grpc/typed_async_client.h"
#include "source/common/singleton/const_singleton.h"

#include "contrib/envoy/extensions/filters/network/sip_proxy/tra/v3alpha/tra.pb.h"
#include "contrib/envoy/extensions/filters/network/sip_proxy/tra/v3alpha/tra.pb.validate.h"
#include "contrib/sip_proxy/filters/network/source/tra/tra.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace TrafficRoutingAssistant {

using TrafficRoutingAssistantAsyncRequestCallbacks = Grpc::AsyncRequestCallbacks<
    envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>;
using TrafficRoutingAssistantAsyncStreamCallbacks = Grpc::AsyncStreamCallbacks<
    envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>;

// TODO: We should have only one client per thread, but today we create one per filter stack.
// This will require support for more than one outstanding request per client.
class GrpcClientImpl : public Client,
                       public TrafficRoutingAssistantAsyncRequestCallbacks,
                       public TrafficRoutingAssistantAsyncStreamCallbacks,
                       public Logger::Loggable<Logger::Id::filter> {
public:
  GrpcClientImpl(const Grpc::RawAsyncClientSharedPtr& async_client, Event::Dispatcher& dispatcher,
                 const absl::optional<std::chrono::milliseconds>& timeout);
  ~GrpcClientImpl() override;

  // Extensions::NetworkFilters::SipProxy::TrafficRoutingAssistant::Client
  void setRequestCallbacks(RequestCallbacks& callbacks) override;
  void createTrafficRoutingAssistant(const std::string& type,
                                     const absl::flat_hash_map<std::string, std::string>& data,
                                     const absl::optional<TraContextMap> context,
                                     Tracing::Span& parent_span,
                                     const StreamInfo::StreamInfo& stream_info) override;
  void updateTrafficRoutingAssistant(const std::string& type,
                                     const absl::flat_hash_map<std::string, std::string>& data,
                                     const absl::optional<TraContextMap> context,
                                     Tracing::Span& parent_span,
                                     const StreamInfo::StreamInfo& stream_info) override;
  void retrieveTrafficRoutingAssistant(const std::string& type, const std::string& key,
                                       const absl::optional<TraContextMap> context,
                                       Tracing::Span& parent_span,
                                       const StreamInfo::StreamInfo& stream_info) override;
  void deleteTrafficRoutingAssistant(const std::string& type, const std::string& key,
                                     const absl::optional<TraContextMap> context,
                                     Tracing::Span& parent_span,
                                     const StreamInfo::StreamInfo& stream_info) override;
  void subscribeTrafficRoutingAssistant(const std::string& type, Tracing::Span& parent_span,
                                        const StreamInfo::StreamInfo& stream_info) override;

  // Grpc::AsyncRequestCallbacks
  void onCreateInitialMetadata(Http::RequestHeaderMap&) override {}
  void
  onSuccess(std::unique_ptr<
                envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>&&
                response,
            Tracing::Span& span) override;
  void onFailure(Grpc::Status::GrpcStatus status, const std::string& message,
                 Tracing::Span& span) override;

  // Grpc::AsyncStreamCallbacks
  void onReceiveMessage(
      std::unique_ptr<
          envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>&&
          message) override;
  void onReceiveInitialMetadata(Http::ResponseHeaderMapPtr&& metadata) override {
    UNREFERENCED_PARAMETER(metadata);
  }
  void onReceiveTrailingMetadata(Http::ResponseTrailerMapPtr&& metadata) override {
    UNREFERENCED_PARAMETER(metadata);
  };
  void onRemoteClose(Grpc::Status::GrpcStatus status, const std::string& message) override {
    UNREFERENCED_PARAMETER(status);
    UNREFERENCED_PARAMETER(message);
  };

private:
  void sendRequest(
      const std::string& method,
      envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceRequest& request,
      Tracing::Span& parent_span, const StreamInfo::StreamInfo& stream_info);

private:
  class AsyncRequestCallbacks
      : public Grpc::AsyncRequestCallbacks<
            envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>,
        public Event::DeferredDeletable,
        public LinkedObject<AsyncRequestCallbacks> {
  public:
    AsyncRequestCallbacks(GrpcClientImpl& parent) : parent_(parent) {}

    // Grpc::AsyncRequestCallbacks
    void onCreateInitialMetadata(Http::RequestHeaderMap& data) override {
      return parent_.onCreateInitialMetadata(data);
    }
    void onSuccess(
        std::unique_ptr<
            envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>&&
            response,
        Tracing::Span& span) override {
      parent_.onSuccess(std::move(response), span);
      cleanup();
    }
    void onFailure(Grpc::Status::GrpcStatus status, const std::string& message,
                   Tracing::Span& span) override {
      parent_.onFailure(status, message, span);
      cleanup();
    }

    void cleanup() {
      if (LinkedObject<AsyncRequestCallbacks>::inserted()) {
        ASSERT(parent_.dispatcher_.isThreadSafe());
        parent_.dispatcher_.deferredDelete(
            LinkedObject<AsyncRequestCallbacks>::removeFromList(parent_.request_callbacks_));
      }
    }

    Grpc::AsyncRequest* request_{};
    GrpcClientImpl& parent_;
  };

  class AsyncStreamCallbacks
      : public Grpc::AsyncStreamCallbacks<
            envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>,
        public Event::DeferredDeletable,
        public LinkedObject<AsyncStreamCallbacks> {
  public:
    AsyncStreamCallbacks(GrpcClientImpl& parent) : parent_(parent) {}

    // Grpc::AsyncStreamCallbacks
    void onCreateInitialMetadata(Http::RequestHeaderMap& data) override {
      return parent_.onCreateInitialMetadata(data);
    }
    void onReceiveMessage(
        std::unique_ptr<
            envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>&&
            message) override {
      parent_.onReceiveMessage(std::move(message));
    }
    void onReceiveInitialMetadata(Http::ResponseHeaderMapPtr&& metadata) override {
      return parent_.onReceiveInitialMetadata(std::move(metadata));
    }
    void onReceiveTrailingMetadata(Http::ResponseTrailerMapPtr&& metadata) override {
      return parent_.onReceiveTrailingMetadata(std::move(metadata));
    };
    void onRemoteClose(Grpc::Status::GrpcStatus status, const std::string& message) override {
      parent_.onRemoteClose(status, message);
      cleanup();
    };

    void cleanup() {
      if (LinkedObject<AsyncStreamCallbacks>::inserted()) {
        ASSERT(parent_.dispatcher_.isThreadSafe());
        parent_.dispatcher_.deferredDelete(
            LinkedObject<AsyncStreamCallbacks>::removeFromList(parent_.stream_callbacks_));
      }
    }

    Grpc::AsyncStream<
        envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceRequest>
        stream_{};
    GrpcClientImpl& parent_;
  };

  RequestCallbacks* callbacks_{};
  Grpc::AsyncClient<
      envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceRequest,
      envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceResponse>
      async_client_;
  Event::Dispatcher& dispatcher_;
  absl::optional<std::chrono::milliseconds> timeout_;

  std::list<std::unique_ptr<AsyncRequestCallbacks>> request_callbacks_;
  std::list<std::unique_ptr<AsyncStreamCallbacks>> stream_callbacks_;
};

/**
 * Builds the Tra client.
 */
ClientPtr traClient(Event::Dispatcher& dispatcher, Server::Configuration::FactoryContext& context,
                    const envoy::config::core::v3::GrpcService& grpc_service,
                    const std::chrono::milliseconds timeout);

} // namespace TrafficRoutingAssistant
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/common/pure.h"
#include "envoy/singleton/manager.h"
#include "envoy/stream_info/stream_info.h"
#include "envoy/tracing/tracer.h"

#include "absl/container/flat_hash_map.h"
#include "absl/types/any.h"
#include "absl/types/optional.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace TrafficRoutingAssistant {

using TraContextMap = absl::flat_hash_map<std::string, std::string>;

enum class ResponseType {
  CreateResp,
  UpdateResp,
  RetrieveResp,
  DeleteResp,
  SubscribeResp,
  FailureResp,
};

/**
 * Async callbacks used during grpc calls.
 */
class RequestCallbacks {
public:
  virtual ~RequestCallbacks() = default;

  virtual void complete(const ResponseType& type, const std::string& message_type,
                        const absl::any& resp) PURE;
};

/**
 * A client used to query a centralized TRA service.
 */
class Client {
public:
  virtual ~Client() = default;

  virtual void setRequestCallbacks(RequestCallbacks& callbacks) PURE;
  virtual void createTrafficRoutingAssistant(
      const std::string& type, const absl::flat_hash_map<std::string, std::string>& data,
      const absl::optional<TraContextMap> context, Tracing::Span& parent_span,
      const StreamInfo::StreamInfo& stream_info) PURE;
  virtual void updateTrafficRoutingAssistant(
      const std::string& type, const absl::flat_hash_map<std::string, std::string>& data,
      const absl::optional<TraContextMap> context, Tracing::Span& parent_span,
      const StreamInfo::StreamInfo& stream_info) PURE;
  virtual void retrieveTrafficRoutingAssistant(const std::string& type, const std::string& key,
                                               const absl::optional<TraContextMap> context,
                                               Tracing::Span& parent_span,
                                               const StreamInfo::StreamInfo& stream_info) PURE;
  virtual void deleteTrafficRoutingAssistant(const std::string& type, const std::string& key,
                                             const absl::optional<TraContextMap> context,
                                             Tracing::Span& parent_span,
                                             const StreamInfo::StreamInfo& stream_info) PURE;
  virtual void subscribeTrafficRoutingAssistant(const std::string& type, Tracing::Span& parent_span,
                                                const StreamInfo::StreamInfo& stream_info) PURE;
};

using ClientPtr = std::unique_ptr<Client>;

} // namespace TrafficRoutingAssistant
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_contrib_extension(
    name = "tra_lib",
    srcs = ["tra_impl.cc"],
    hdrs = ["tra_impl.h"],
    deps = [
        ":tra_client_interface",
        "//envoy/grpc:async_client_interface",
        "//envoy/grpc:async_client_manager_interface",
        "//envoy/server:filter_config_interface",
        "//envoy/upstream:cluster_manager_interface",
        "//source/common/common:assert_lib",
        "//source/common/common:linked_object",
        "//source/common/common:minimal_logger_lib",
        "//source/common/grpc:typed_async_client_lib",
        "//source/common/http:headers_lib",
        "//source/common/protobuf",
        "//source/common/tracing:http_tracer_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/tra/v3alpha:pkg_cc_proto",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "tra_client_interface",
    hdrs = ["tra.h"],
    external_deps = [
        "abseil_optional",
        "abseil_any",
    ],
    deps = [
        "//envoy/singleton:manager_interface",
        "//envoy/tracing:tracer_interface",
        "//source/common/stats:symbol_table_lib",
    ],
)
#pragma once

#include "source/extensions/filters/network/common/factory_base.h"

#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.h"
#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.validate.h"
#include "contrib/sip_proxy/filters/network/source/conn_manager.h"
#include "contrib/sip_proxy/filters/network/source/filters/filter.h"
#include "contrib/sip_proxy/filters/network/source/filters/well_known_names.h"
#include "contrib/sip_proxy/filters/network/source/router/router_impl.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

/**
 * Provides Sip-specific cluster options.
 */
class ProtocolOptionsConfigImpl : public ProtocolOptionsConfig {
public:
  ProtocolOptionsConfigImpl(
      const envoy::extensions::filters::network::sip_proxy::v3alpha::SipProtocolOptions&
          proto_config);

  bool sessionAffinity() const override;
  bool registrationAffinity() const override;
  const envoy::extensions::filters::network::sip_proxy::v3alpha::CustomizedAffinity&
  customizedAffinity() const override;

private:
  bool session_affinity_;
  bool registration_affinity_;
  const envoy::extensions::filters::network::sip_proxy::v3alpha::CustomizedAffinity
      customized_affinity_;
};

/**
 * Config registration for the sip proxy filter. @see NamedNetworkFilterConfigFactory.
 */
class SipProxyFilterConfigFactory
    : public Common::FactoryBase<
          envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy,
          envoy::extensions::filters::network::sip_proxy::v3alpha::SipProtocolOptions> {
public:
  SipProxyFilterConfigFactory() : FactoryBase(SipFilters::SipFilterNames::get().SipProxy, true) {}

private:
  Network::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy& proto_config,
      Server::Configuration::FactoryContext& context) override;
  Upstream::ProtocolOptionsConfigConstSharedPtr createProtocolOptionsTyped(
      const envoy::extensions::filters::network::sip_proxy::v3alpha::SipProtocolOptions&
          proto_config,
      Server::Configuration::ProtocolOptionsFactoryContext&) override {
    return std::make_shared<ProtocolOptionsConfigImpl>(proto_config);
  }
};

class ConfigImpl : public Config,
                   public Router::Config,
                   public SipFilters::FilterChainFactory,
                   Logger::Loggable<Logger::Id::config> {
public:
  ConfigImpl(const envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy& config,
             Server::Configuration::FactoryContext& context);

  // SipFilters::FilterChainFactory
  void createFilterChain(SipFilters::FilterChainFactoryCallbacks& callbacks) override;

  // Router::Config
  Router::RouteConstSharedPtr route(MessageMetadata& metadata) const override {
    return route_matcher_->route(metadata);
  }

  // Config
  SipFilterStats& stats() override { return stats_; }
  SipFilters::FilterChainFactory& filterFactory() override { return *this; }
  Router::Config& routerConfig() override { return *this; }
  std::shared_ptr<SipSettings> settings() override { return settings_; }

  // Settings
private:
  void processFilter(
      const envoy::extensions::filters::network::sip_proxy::v3alpha::SipFilter& proto_config);

  Server::Configuration::FactoryContext& context_;
  const std::string stats_prefix_;
  SipFilterStats stats_;
  std::unique_ptr<Router::RouteMatcher> route_matcher_;

  std::list<SipFilters::FilterFactoryCb> filter_factories_;

  std::shared_ptr<SipSettings> settings_;
};

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "source/common/buffer/buffer_impl.h"

#include "contrib/sip_proxy/filters/network/source/filters/filter.h"
#include "contrib/sip_proxy/filters/network/source/utility.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

class StateNameValues {
public:
  static const std::string& name(State state) {
    size_t i = static_cast<size_t>(state);
    ASSERT(i < names().size());
    return names()[i];
  }

private:
  static const std::vector<std::string>& names() {
    CONSTRUCT_ON_FIRST_USE(std::vector<std::string>, {ALL_PROTOCOL_STATES(GENERATE_STRING)});
  }
};

/**
 * DecoderStateMachine is the Sip message state machine
 */
class DecoderStateMachine : public Logger::Loggable<Logger::Id::filter> {
public:
  DecoderStateMachine(MessageMetadataSharedPtr& metadata, DecoderEventHandler& handler)
      : metadata_(metadata), handler_(handler) {}

  /**
   * Consumes as much data from the configured Buffer as possible and executes
   * the decoding state machine.
   * Once the Done state is reached, further invocations of run return
   * immediately with Done.
   *
   * @param buffer a buffer containing the remaining data to be processed
   * @return State returns with State::Done
   */
  State run();

private:
  friend class SipDecoderTest;
  struct DecoderStatus {
    DecoderStatus(State next_state) : next_state_(next_state){};
    DecoderStatus(State next_state, FilterStatus filter_status)
        : next_state_(next_state), filter_status_(filter_status){};

    State next_state_;
    absl::optional<FilterStatus> filter_status_;
  };

  DecoderStatus transportBegin();
  DecoderStatus messageBegin();
  DecoderStatus messageEnd();
  DecoderStatus transportEnd();

  // handleState delegates to the appropriate method based on state_.
  DecoderStatus handleState();

  MessageMetadataSharedPtr metadata_;
  DecoderEventHandler& handler_;
};

using DecoderStateMachinePtr = std::unique_ptr<DecoderStateMachine>;

class DecoderCallbacks {
public:
  virtual ~DecoderCallbacks() = default;

  /**
   * @return DecoderEventHandler& a new DecoderEventHandler for a message.
   */
  virtual DecoderEventHandler& newDecoderEventHandler(MessageMetadataSharedPtr metadata) PURE;
  virtual std::shared_ptr<SipSettings> settings() const PURE;
};

/**
 * Decoder encapsulates a configured Transport and Protocol and provides the
 * ability to decode Sip messages.
 */
class Decoder : public Logger::Loggable<Logger::Id::filter> {
public:
  Decoder(DecoderCallbacks& callbacks);

  /**
   * Drains data from the given buffer while executing a state machine over the
   * data.
   *
   * @param data a Buffer containing Sip protocol data
   * @return FilterStatus::StopIteration when waiting for filter continuation,
   *             Continue otherwise.
   * @throw EnvoyException on Sip protocol errors
   */
  FilterStatus onData(Buffer::Instance& data, bool continue_handling = false);

  std::shared_ptr<SipSettings> settings() { return callbacks_.settings(); };

  MessageMetadataSharedPtr metadata() { return metadata_; }

  void restore(MessageMetadataSharedPtr metadata, DecoderEventHandler& decoder_event_handler) {
    complete();
    metadata_ = metadata;
    request_ = std::make_unique<ActiveRequest>(decoder_event_handler);
    state_machine_ = std::make_unique<DecoderStateMachine>(metadata_, request_->handler_);
  }

  void complete();

private:
  friend class SipConnectionManagerTest;
  friend class SipDecoderTest;
  struct ActiveRequest {
    ActiveRequest(DecoderEventHandler& handler) : handler_(handler) {}

    DecoderEventHandler& handler_;
  };
  using ActiveRequestPtr = std::unique_ptr<ActiveRequest>;

  int reassemble(Buffer::Instance& data);

  /**
   * After the data reassembled, parse the data and handle them
   * @param data string
   * @param length actual length of data, data.length() may less
   *               than length when other data after data.
   */
  FilterStatus onDataReady(Buffer::Instance& data);

  int decode();

private:
  HeaderType currentHeader() { return current_header_; }
  size_t rawOffset() { return raw_offset_; }
  void setCurrentHeader(HeaderType data) { current_header_ = data; }

  bool isFirstVia() { return first_via_; }
  void setFirstVia(bool flag) { first_via_ = flag; }
  bool isFirstRoute() { return first_route_; }
  void setFirstRoute(bool flag) { first_route_ = flag; }
  bool isFirstRecordRoute() { return first_record_route_; }
  void setFirstRecordRoute(bool flag) { first_record_route_ = flag; }
  bool isFirstServiceRoute() { return first_service_route_; }
  void setFirstServiceRoute(bool flag) { first_service_route_ = flag; }

  auto sipHeaderType(absl::string_view sip_line);
  MsgType sipMsgType(absl::string_view top_line);
  MethodType sipMethod(absl::string_view top_line);

  static absl::string_view domain(absl::string_view sip_header, HeaderType header_type);
  static void getParamFromHeader(absl::string_view header, MessageMetadataSharedPtr metadata);

  HeaderType current_header_{HeaderType::TopLine};
  size_t raw_offset_{0};

  bool first_via_{true};
  bool first_route_{true};
  bool first_record_route_{true};
  bool first_service_route_{true};

  class MessageHandler;
  class HeaderHandler {
  public:
    HeaderHandler(MessageHandler& parent);
    virtual ~HeaderHandler() = default;

    virtual int processVia(absl::string_view& header);
    virtual int processContact(absl::string_view& header);
    virtual int processPath(absl::string_view& header);
    virtual int processRoute(absl::string_view& header);
    virtual int processRecordRoute(absl::string_view& header);
    virtual int processServiceRoute(absl::string_view& header);
    virtual int processWwwAuth(absl::string_view& header);
    virtual int processAuth(absl::string_view& header);
    virtual int processPCookieIPMap(absl::string_view& header);

    MessageMetadataSharedPtr metadata() { return parent_.metadata(); }

    HeaderType currentHeader() { return parent_.currentHeader(); }
    size_t rawOffset() { return parent_.rawOffset(); }
    bool isFirstVia() { return parent_.isFirstVia(); }
    bool isFirstRoute() { return parent_.isFirstRoute(); }
    bool isFirstRecordRoute() { return parent_.isFirstRecordRoute(); }
    bool isFirstServiceRoute() { return parent_.isFirstServiceRoute(); }
    void setFirstVia(bool flag) { parent_.setFirstVia(flag); }
    void setFirstRoute(bool flag) { parent_.setFirstRoute(flag); }
    void setFirstRecordRoute(bool flag) { parent_.setFirstRecordRoute(flag); }
    void setFirstServiceRoute(bool flag) { parent_.setFirstServiceRoute(flag); }

    MessageHandler& parent_;
  };

  class MessageHandler {
  public:
    MessageHandler(std::shared_ptr<HeaderHandler> handler, Decoder& parent)
        : parent_(parent), handler_(std::move(handler)) {}
    virtual ~MessageHandler() = default;

    virtual void parseHeader(HeaderType& type, absl::string_view& header) PURE;

    MessageMetadataSharedPtr metadata() { return parent_.metadata(); }
    HeaderType currentHeader() { return parent_.currentHeader(); }
    size_t rawOffset() { return parent_.rawOffset(); }
    bool isFirstVia() { return parent_.isFirstVia(); }
    bool isFirstRoute() { return parent_.isFirstRoute(); }
    bool isFirstRecordRoute() { return parent_.isFirstRecordRoute(); }
    bool isFirstServiceRoute() { return parent_.isFirstServiceRoute(); }
    void setFirstVia(bool flag) { parent_.setFirstVia(flag); }
    void setFirstRoute(bool flag) { parent_.setFirstRoute(flag); }
    void setFirstRecordRoute(bool flag) { parent_.setFirstRecordRoute(flag); }
    void setFirstServiceRoute(bool flag) { parent_.setFirstServiceRoute(flag); }

    Decoder& parent_;

  protected:
    std::shared_ptr<HeaderHandler> handler_;
  };

  class REGISTERHeaderHandler : public HeaderHandler {
  public:
    using HeaderHandler::HeaderHandler;
  };

  class INVITEHeaderHandler : public HeaderHandler {
  public:
    using HeaderHandler::HeaderHandler;
  };

  class OK200HeaderHandler : public HeaderHandler {
  public:
    using HeaderHandler::HeaderHandler;
  };

  class GeneralHeaderHandler : public HeaderHandler {
  public:
    using HeaderHandler::HeaderHandler;
  };

  class SUBSCRIBEHeaderHandler : public HeaderHandler {
  public:
    using HeaderHandler::HeaderHandler;
  };

  class FAILURE4XXHeaderHandler : public HeaderHandler {
  public:
    using HeaderHandler::HeaderHandler;
  };

  class REGISTERHandler : public MessageHandler {
  public:
    REGISTERHandler(Decoder& parent)
        : MessageHandler(std::make_shared<REGISTERHeaderHandler>(*this), parent) {}
    ~REGISTERHandler() override = default;

    void parseHeader(HeaderType& type, absl::string_view& header) override;
  };

  class INVITEHandler : public MessageHandler {
  public:
    INVITEHandler(Decoder& parent)
        : MessageHandler(std::make_shared<INVITEHeaderHandler>(*this), parent) {}
    ~INVITEHandler() override = default;

    void parseHeader(HeaderType& type, absl::string_view& header) override;
  };

  class OK200Handler : public MessageHandler {
  public:
    OK200Handler(Decoder& parent)
        : MessageHandler(std::make_shared<OK200HeaderHandler>(*this), parent) {}
    ~OK200Handler() override = default;

    void parseHeader(HeaderType& type, absl::string_view& header) override;
  };

  // This is used to handle ACK/BYE/CANCEL
  class GeneralHandler : public MessageHandler {
  public:
    GeneralHandler(Decoder& parent)
        : MessageHandler(std::make_shared<GeneralHeaderHandler>(*this), parent) {}
    ~GeneralHandler() override = default;

    void parseHeader(HeaderType& type, absl::string_view& header) override;
  };

  class SUBSCRIBEHandler : public MessageHandler {
  public:
    SUBSCRIBEHandler(Decoder& parent)
        : MessageHandler(std::make_shared<SUBSCRIBEHeaderHandler>(*this), parent) {}
    ~SUBSCRIBEHandler() override = default;
    void parseHeader(HeaderType& type, absl::string_view& header) override;
  };

  // This is used to handle Other Message
  class OthersHandler : public MessageHandler {
  public:
    OthersHandler(Decoder& parent)
        : MessageHandler(std::make_shared<HeaderHandler>(*this), parent) {}
    ~OthersHandler() override = default;

    void parseHeader(HeaderType& type, absl::string_view& header) override;
  };

  class FAILURE4XXHandler : public MessageHandler {
  public:
    FAILURE4XXHandler(Decoder& parent)
        : MessageHandler(std::make_shared<HeaderHandler>(*this), parent) {}
    ~FAILURE4XXHandler() override = default;

    void parseHeader(HeaderType& type, absl::string_view& header) override;
  };

  class MessageFactory {
  public:
    static std::shared_ptr<MessageHandler> create(MethodType type, Decoder& parent);
  };

  DecoderCallbacks& callbacks_;
  ActiveRequestPtr request_;
  MessageMetadataSharedPtr metadata_;
  DecoderStateMachinePtr state_machine_;
};

using DecoderPtr = std::unique_ptr<Decoder>;

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/common/pure.h"
#include "envoy/common/random_generator.h"
#include "envoy/event/deferred_deletable.h"
#include "envoy/network/connection.h"
#include "envoy/network/filter.h"
#include "envoy/stats/timespan.h"
#include "envoy/upstream/upstream.h"

#include "source/common/buffer/buffer_impl.h"
#include "source/common/common/linked_object.h"
#include "source/common/common/logger.h"
#include "source/common/config/utility.h"
#include "source/common/stats/timespan_impl.h"
#include "source/common/stream_info/stream_info_impl.h"
#include "source/common/tracing/http_tracer_impl.h"

#include "absl/types/any.h"
#include "contrib/sip_proxy/filters/network/source/decoder.h"
#include "contrib/sip_proxy/filters/network/source/filters/filter.h"
#include "contrib/sip_proxy/filters/network/source/stats.h"
#include "contrib/sip_proxy/filters/network/source/tra/tra_impl.h"
#include "contrib/sip_proxy/filters/network/source/utility.h"
#include "metadata.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

/**
 * Config is a configuration interface for ConnectionManager.
 */
class SipSettings;
class Config {
public:
  virtual ~Config() = default;

  virtual SipFilters::FilterChainFactory& filterFactory() PURE;
  virtual SipFilterStats& stats() PURE;
  virtual Router::Config& routerConfig() PURE;
  virtual std::shared_ptr<SipSettings> settings() PURE;
};

/**
 * Extends Upstream::ProtocolOptionsConfig with Sip-specific cluster options.
 */
class ProtocolOptionsConfig : public Upstream::ProtocolOptionsConfig {
public:
  ~ProtocolOptionsConfig() override = default;

  virtual bool sessionAffinity() const PURE;
  virtual bool registrationAffinity() const PURE;
  virtual const envoy::extensions::filters::network::sip_proxy::v3alpha::CustomizedAffinity&
  customizedAffinity() const PURE;
};

class ConnectionManager;
class TrafficRoutingAssistantHandler : public TrafficRoutingAssistant::RequestCallbacks,
                                       public Logger::Loggable<Logger::Id::filter> {
public:
  TrafficRoutingAssistantHandler(
      ConnectionManager& parent, Event::Dispatcher& dispatcher,
      const envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceConfig& config,
      Server::Configuration::FactoryContext& context, StreamInfo::StreamInfoImpl& stream_info);

  virtual void updateTrafficRoutingAssistant(const std::string& type, const std::string& key,
                                             const std::string& val,
                                             const absl::optional<TraContextMap> context);
  virtual QueryStatus retrieveTrafficRoutingAssistant(
      const std::string& type, const std::string& key, const absl::optional<TraContextMap> context,
      SipFilters::DecoderFilterCallbacks& activetrans, std::string& host);
  virtual void deleteTrafficRoutingAssistant(const std::string& type, const std::string& key,
                                             const absl::optional<TraContextMap> context);
  virtual void subscribeTrafficRoutingAssistant(const std::string& type);
  void complete(const TrafficRoutingAssistant::ResponseType& type, const std::string& message_type,
                const absl::any& resp) override;
  void
  doSubscribe(const envoy::extensions::filters::network::sip_proxy::v3alpha::CustomizedAffinity&
                  customized_affinity);

private:
  virtual TrafficRoutingAssistant::ClientPtr& traClient() { return tra_client_; }

  ConnectionManager& parent_;
  CacheManager<std::string, std::string, std::string> cache_manager_;
  TrafficRoutingAssistant::ClientPtr tra_client_;
  StreamInfo::StreamInfoImpl stream_info_;
  std::map<std::string, bool> is_subscribe_map_;
};

/**
 * ConnectionManager is a Network::Filter that will perform Sip request handling on a connection.
 */
class ConnectionManager : public Network::ReadFilter,
                          public Network::ConnectionCallbacks,
                          public DecoderCallbacks,
                          public PendingListHandler,
                          Logger::Loggable<Logger::Id::connection> {
public:
  ConnectionManager(Config& config, Random::RandomGenerator& random_generator,
                    TimeSource& time_system, Server::Configuration::FactoryContext& context,
                    std::shared_ptr<Router::TransactionInfos> transaction_infos);
  ~ConnectionManager() override;

  // Network::ReadFilter
  Network::FilterStatus onData(Buffer::Instance& data, bool end_stream) override;
  Network::FilterStatus onNewConnection() override { return Network::FilterStatus::Continue; }
  void initializeReadFilterCallbacks(Network::ReadFilterCallbacks&) override;

  // Network::ConnectionCallbacks
  void onEvent(Network::ConnectionEvent) override;
  void onAboveWriteBufferHighWatermark() override {}
  void onBelowWriteBufferLowWatermark() override {}

  // DecoderCallbacks
  DecoderEventHandler& newDecoderEventHandler(MessageMetadataSharedPtr metadata) override;

  std::shared_ptr<SipSettings> settings() const override { return config_.settings(); }

  void continueHandling(const std::string& key, bool try_next_affinity = false);
  void continueHandling(MessageMetadataSharedPtr metadata,
                        DecoderEventHandler& decoder_event_handler);
  std::shared_ptr<TrafficRoutingAssistantHandler> traHandler() { return this->tra_handler_; }

  // PendingListHandler
  void pushIntoPendingList(const std::string& type, const std::string& key,
                           SipFilters::DecoderFilterCallbacks& activetrans,
                           std::function<void(void)> func) override {
    return pending_list_.pushIntoPendingList(type, key, activetrans, func);
  }
  void onResponseHandleForPendingList(
      const std::string& type, const std::string& key,
      std::function<void(MessageMetadataSharedPtr metadata, DecoderEventHandler&)> func) override {
    return pending_list_.onResponseHandleForPendingList(type, key, func);
  }
  void eraseActiveTransFromPendingList(std::string& transaction_id) override {
    return pending_list_.eraseActiveTransFromPendingList(transaction_id);
  }

private:
  friend class SipConnectionManagerTest;
  struct ActiveTrans;

  struct ResponseDecoder : public DecoderCallbacks, public DecoderEventHandler {
    ResponseDecoder(ActiveTrans& parent) : parent_(parent) {}

    bool onData(MessageMetadataSharedPtr metadata);

    // DecoderEventHandler
    FilterStatus messageBegin(MessageMetadataSharedPtr metadata) override;
    FilterStatus messageEnd() override;
    FilterStatus transportBegin(MessageMetadataSharedPtr metadata) override {
      UNREFERENCED_PARAMETER(metadata);
      return FilterStatus::Continue;
    }
    FilterStatus transportEnd() override;

    // DecoderCallbacks
    DecoderEventHandler& newDecoderEventHandler(MessageMetadataSharedPtr metadata) override {
      UNREFERENCED_PARAMETER(metadata);
      return *this;
    }

    std::shared_ptr<SipSettings> settings() const override { return parent_.parent_.settings(); }

    std::shared_ptr<TrafficRoutingAssistantHandler> traHandler() {
      return parent_.parent_.tra_handler_;
    }

    ActiveTrans& parent_;
    MessageMetadataSharedPtr metadata_;
  };
  using ResponseDecoderPtr = std::unique_ptr<ResponseDecoder>;

  // Wraps a DecoderFilter and acts as the DecoderFilterCallbacks for the filter, enabling filter
  // chain continuation.
  struct ActiveTransDecoderFilter : public SipFilters::DecoderFilterCallbacks,
                                    LinkedObject<ActiveTransDecoderFilter> {
    ActiveTransDecoderFilter(ActiveTrans& parent, SipFilters::DecoderFilterSharedPtr filter)
        : parent_(parent), handle_(filter) {}

    // SipFilters::DecoderFilterCallbacks
    uint64_t streamId() const override { return parent_.streamId(); }
    std::string transactionId() const override { return parent_.transactionId(); }
    const Network::Connection* connection() const override { return parent_.connection(); }
    Router::RouteConstSharedPtr route() override { return parent_.route(); }
    SipFilterStats& stats() override { return parent_.stats(); }
    void sendLocalReply(const DirectResponse& response, bool end_stream) override {
      parent_.sendLocalReply(response, end_stream);
    }
    void startUpstreamResponse() override { parent_.startUpstreamResponse(); }
    SipFilters::ResponseStatus upstreamData(MessageMetadataSharedPtr metadata) override {
      return parent_.upstreamData(metadata);
    }
    void resetDownstreamConnection() override { parent_.resetDownstreamConnection(); }
    StreamInfo::StreamInfo& streamInfo() override { return parent_.streamInfo(); }
    std::shared_ptr<Router::TransactionInfos> transactionInfos() override {
      return parent_.transactionInfos();
    }
    std::shared_ptr<SipSettings> settings() const override { return parent_.settings(); }
    std::shared_ptr<TrafficRoutingAssistantHandler> traHandler() override {
      return parent_.traHandler();
    }
    void onReset() override { return parent_.onReset(); }

    void continueHandling(const std::string& key, bool try_next_affinity) override {
      return parent_.continueHandling(key, try_next_affinity);
    }
    MessageMetadataSharedPtr metadata() override { return parent_.metadata(); }

    // PendingListHandler
    void pushIntoPendingList(const std::string& type, const std::string& key,
                             SipFilters::DecoderFilterCallbacks& activetrans,
                             std::function<void(void)> func) override {
      UNREFERENCED_PARAMETER(type);
      UNREFERENCED_PARAMETER(key);
      UNREFERENCED_PARAMETER(activetrans);
      UNREFERENCED_PARAMETER(func);
    }
    void onResponseHandleForPendingList(
        const std::string& type, const std::string& key,
        std::function<void(MessageMetadataSharedPtr, DecoderEventHandler&)> func) override {
      UNREFERENCED_PARAMETER(type);
      UNREFERENCED_PARAMETER(key);
      UNREFERENCED_PARAMETER(func);
    }
    void eraseActiveTransFromPendingList(std::string& transaction_id) override {
      UNREFERENCED_PARAMETER(transaction_id);
    }

    ActiveTrans& parent_;
    SipFilters::DecoderFilterSharedPtr handle_;
  };
  using ActiveTransDecoderFilterPtr = std::unique_ptr<ActiveTransDecoderFilter>;

  // ActiveTrans tracks request/response pairs.
  struct ActiveTrans : LinkedObject<ActiveTrans>,
                       public Event::DeferredDeletable,
                       public DecoderEventHandler,
                       public SipFilters::DecoderFilterCallbacks,
                       public SipFilters::FilterChainFactoryCallbacks {
    ActiveTrans(ConnectionManager& parent, MessageMetadataSharedPtr metadata)
        : parent_(parent), request_timer_(new Stats::HistogramCompletableTimespanImpl(
                               parent_.stats_.request_time_ms_, parent_.time_source_)),
          stream_id_(parent_.random_generator_.random()),
          transaction_id_(metadata->transactionId().value()),
          stream_info_(parent_.time_source_,
                       parent_.read_callbacks_->connection().connectionInfoProviderSharedPtr()),
          metadata_(metadata) {
      parent.stats_.request_active_.inc();
    }
    ~ActiveTrans() override {
      request_timer_->complete();
      parent_.stats_.request_active_.dec();

      parent_.eraseActiveTransFromPendingList(transaction_id_);
      for (auto& filter : decoder_filters_) {
        filter->handle_->onDestroy();
      }
    }

    // DecoderEventHandler
    FilterStatus transportBegin(MessageMetadataSharedPtr metadata) override;
    FilterStatus transportEnd() override;
    FilterStatus messageBegin(MessageMetadataSharedPtr metadata) override;
    FilterStatus messageEnd() override;

    // PendingListHandler
    void pushIntoPendingList(const std::string& type, const std::string& key,
                             SipFilters::DecoderFilterCallbacks& activetrans,
                             std::function<void(void)> func) override {
      return parent_.pushIntoPendingList(type, key, activetrans, func);
    }
    void onResponseHandleForPendingList(
        const std::string& type, const std::string& key,
        std::function<void(MessageMetadataSharedPtr metadata, DecoderEventHandler&)> func)
        override {
      return parent_.onResponseHandleForPendingList(type, key, func);
    }
    void eraseActiveTransFromPendingList(std::string& transaction_id) override {
      return parent_.eraseActiveTransFromPendingList(transaction_id);
    }

    // SipFilters::DecoderFilterCallbacks
    uint64_t streamId() const override { return stream_id_; }
    std::string transactionId() const override { return transaction_id_; }
    const Network::Connection* connection() const override;
    Router::RouteConstSharedPtr route() override;
    SipFilterStats& stats() override { return parent_.stats_; }
    void sendLocalReply(const DirectResponse& response, bool end_stream) override;
    void startUpstreamResponse() override;
    SipFilters::ResponseStatus upstreamData(MessageMetadataSharedPtr metadata) override;
    void resetDownstreamConnection() override;
    StreamInfo::StreamInfo& streamInfo() override { return stream_info_; }

    std::shared_ptr<Router::TransactionInfos> transactionInfos() override {
      return parent_.transaction_infos_;
    }
    std::shared_ptr<SipSettings> settings() const override { return parent_.config_.settings(); }
    void onReset() override;
    std::shared_ptr<TrafficRoutingAssistantHandler> traHandler() override {
      return parent_.tra_handler_;
    }
    void continueHandling(const std::string& key, bool try_next_affinity) override {
      return parent_.continueHandling(key, try_next_affinity);
    }

    // Sip::FilterChainFactoryCallbacks
    void addDecoderFilter(SipFilters::DecoderFilterSharedPtr filter) override {
      ActiveTransDecoderFilterPtr wrapper =
          std::make_unique<ActiveTransDecoderFilter>(*this, filter);
      filter->setDecoderFilterCallbacks(wrapper->parent_);
      LinkedList::moveIntoListBack(std::move(wrapper), decoder_filters_);
    }

    FilterStatus applyDecoderFilters(ActiveTransDecoderFilter* filter);
    void finalizeRequest();

    void createFilterChain();
    void onError(const std::string& what);
    MessageMetadataSharedPtr metadata() override { return metadata_; }
    bool localResponseSent() { return local_response_sent_; }
    void setLocalResponseSent(bool local_response_sent) {
      local_response_sent_ = local_response_sent;
    }

    ConnectionManager& parent_;
    Stats::TimespanPtr request_timer_;
    uint64_t stream_id_;
    std::string transaction_id_;
    StreamInfo::StreamInfoImpl stream_info_;
    MessageMetadataSharedPtr metadata_;
    std::list<ActiveTransDecoderFilterPtr> decoder_filters_;
    ResponseDecoderPtr response_decoder_;
    absl::optional<Router::RouteConstSharedPtr> cached_route_;

    std::function<FilterStatus(DecoderEventHandler*)> filter_action_;

    absl::any filter_context_;
    bool local_response_sent_{false};

    /* Used by Router */
    std::shared_ptr<Router::TransactionInfos> transaction_infos_;
  };

  using ActiveTransPtr = std::unique_ptr<ActiveTrans>;

  void dispatch();
  void sendLocalReply(MessageMetadata& metadata, const DirectResponse& response, bool end_stream);
  void setLocalResponseSent(absl::string_view transaction_id);
  void doDeferredTransDestroy(ActiveTrans& trans);
  void resetAllTrans(bool local_reset);

  Config& config_;
  SipFilterStats& stats_;

  Network::ReadFilterCallbacks* read_callbacks_{};

  DecoderPtr decoder_;
  absl::flat_hash_map<std::string, ActiveTransPtr> transactions_;
  Buffer::OwnedImpl request_buffer_;
  Random::RandomGenerator& random_generator_;
  TimeSource& time_source_;
  Server::Configuration::FactoryContext& context_;

  std::shared_ptr<TrafficRoutingAssistantHandler> tra_handler_;

  // This is used in Router, put here to pass to Router
  std::shared_ptr<Router::TransactionInfos> transaction_infos_;
  PendingList pending_list_;
};

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "source/common/singleton/const_singleton.h"

#include "absl/container/flat_hash_map.h"
#include "absl/strings/string_view.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

enum HeaderType {
  TopLine,
  CallId,
  Via,
  To,
  From,
  Route,
  Contact,
  RRoute,
  Cseq,
  Path,
  Event,
  SRoute,
  WAuth,
  Auth,
  PCookieIPMap,
  Other,
  InvalidFormat,
  HeaderMaxNum
};

enum class MsgType { Request, Response, ErrorMsg };

enum MethodType {
  Invite,
  Register,
  Update,
  Refer,
  Subscribe,
  Notify,
  Ack,
  Bye,
  Cancel,
  Ok200,
  Failure4xx,
  OtherMethod,
  NullMethod
};

enum class AppExceptionType {
  Unknown = 0,
  UnknownMethod = 1,
  InvalidMessageType = 2,
  WrongMethodName = 3,
  BadSequenceId = 4,
  MissingResult = 5,
  InternalError = 6,
  ProtocolError = 7,
  InvalidTransform = 8,
  InvalidProtocol = 9,
  UnsupportedClientType = 10,
  LoadShedding = 11,
  Timeout = 12,
  InjectedFailure = 13,
  ChecksumMismatch = 14,
  Interruption = 15,
};

class HeaderTypeMap {
public:
  HeaderType str2Header(const absl::string_view& header) const {
    if (const auto& result = sip_header_type_map_.find(header);
        result != sip_header_type_map_.end()) {
      return result->second;
    } else {
      return HeaderType::Other;
    }
  }

  HeaderType str2Header(const std::string& header) const {
    if (const auto& result = sip_header_type_map_.find(header);
        result != sip_header_type_map_.end()) {
      return result->second;
    } else {
      return HeaderType::Other;
    }
  }

private:
  const absl::flat_hash_map<absl::string_view, HeaderType> sip_header_type_map_{
      {"Call-ID", HeaderType::CallId},
      {"Via", HeaderType::Via},
      {"To", HeaderType::To},
      {"From", HeaderType::From},
      {"Contact", HeaderType::Contact},
      {"Record-Route", HeaderType::RRoute},
      {"CSeq", HeaderType::Cseq},
      {"Route", HeaderType::Route},
      {"Path", HeaderType::Path},
      {"Event", HeaderType::Event},
      {"Service-Route", HeaderType::SRoute},
      {"WWW-Authenticate", HeaderType::WAuth},
      {"Authorization", HeaderType::Auth},
      {"TopLine", HeaderType::TopLine},
      {"P-Nokia-Cookie-IP-Mapping", HeaderType::PCookieIPMap}};
};

using HeaderTypes = ConstSingleton<HeaderTypeMap>;
extern std::vector<std::string> methodStr;

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "source/common/common/logger.h"

#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.h"
#include "contrib/sip_proxy/filters/network/source/operation.h"
#include "contrib/sip_proxy/filters/network/source/sip.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

#define ALL_PROTOCOL_STATES(FUNCTION)                                                              \
  FUNCTION(StopIteration)                                                                          \
  FUNCTION(TransportBegin)                                                                         \
  FUNCTION(MessageBegin)                                                                           \
  FUNCTION(MessageEnd)                                                                             \
  FUNCTION(TransportEnd)                                                                           \
  FUNCTION(HandleAffinity)                                                                         \
  FUNCTION(Done)

using TraContextMap = absl::flat_hash_map<std::string, std::string>;

/**
 * ProtocolState represents a set of states used in a state machine to decode
 * Sip requests and responses.
 */
enum class State { ALL_PROTOCOL_STATES(GENERATE_ENUM) };

class SipHeader : public Logger::Loggable<Logger::Id::filter> {
public:
  SipHeader(HeaderType type, absl::string_view value) : type_(type), raw_text_(value) {}
  void parseHeader();

  bool empty() const { return raw_text_.empty(); }

  // "text" as the special param for raw_text_
  bool hasParam(absl::string_view param) const {
    if (param == "text") {
      return true;
    }

    for (auto& p : params_) {
      if (p.first == param) {
        return true;
      }
    }
    return false;
  }

  // "text" as the special param for raw_text_
  absl::string_view param(absl::string_view param) const {
    for (const auto& p : params_) {
      if (p.first == param) {
        return p.second;
      }
    }
    return "";
  }

  absl::string_view text() const { return raw_text_; }

  HeaderType type_;
  absl::string_view raw_text_;
  std::vector<std::pair<absl::string_view, absl::string_view>> params_;
};

class AffinityEntry {
public:
  AffinityEntry(const std::string& header, const std::string& type, const std::string& key,
                bool query, bool subscribe)
      : header_(header), type_(type), key_(key), query_(query), subscribe_(subscribe) {}

  std::string& header() { return header_; }
  std::string& type() { return type_; }
  std::string& key() { return key_; }
  bool query() { return query_; }
  bool subscribe() { return subscribe_; }

private:
  std::string header_;
  std::string type_;
  std::string key_;
  bool query_;
  bool subscribe_;
};

/**
 * MessageMetadata encapsulates metadata about Sip messages. The various fields are considered
 * optional. Unless otherwise noted, accessor methods throw absl::bad_optional_access if the
 * corresponding value has not been set.
 */
class MessageMetadata : public Logger::Loggable<Logger::Id::filter> {
public:
  MessageMetadata() = default;
  MessageMetadata(std::string&& raw_msg) : raw_msg_(std::move(raw_msg)) {}

  /**
   * The whole SIP message is stored in metadata raw_msg, it is initialized when construct metadata.
   */
  std::string& rawMsg() { return raw_msg_; }

  MsgType msgType() { return msg_type_; }
  void setMsgType(MsgType data) { msg_type_ = data; }

  MethodType methodType() { return method_type_; }
  void setMethodType(MethodType data) { method_type_ = data; }

  absl::optional<absl::string_view> ep() { return ep_; }
  void setEP(absl::string_view data) { ep_ = data; }

  absl::optional<absl::string_view> opaque() { return opaque_; }
  void setOpaque(absl::string_view data) { opaque_ = data; }

  std::vector<Operation>& operationList() { return operation_list_; }
  void setOperation(Operation op) { operation_list_.emplace_back(op); }

#if 1
  // TODO Only used for NOKIA customized affinity. should be deleted later.
  absl::optional<std::pair<std::string, std::string>> pCookieIpMap() { return p_cookie_ip_map_; }
  void setPCookieIpMap(std::pair<std::string, std::string>&& data) { p_cookie_ip_map_ = data; }
#endif

  absl::optional<absl::string_view> transactionId() { return transaction_id_; }
  /**
   * @param data full SIP header
   */
  void setTransactionId(absl::string_view data);

  std::string destination() { return destination_; }
  void setDestination(std::string destination) { destination_ = destination; }
  void resetDestination() { destination_.clear(); }

  bool stopLoadBalance() { return stop_load_balance_; };
  void setStopLoadBalance(bool stop_load_balance) { stop_load_balance_ = stop_load_balance; };

  State state() { return state_; };
  void setState(State state) { state_ = state; };

  std::vector<AffinityEntry>& affinity() { return affinity_; }
  void resetAffinityIteration() { affinity_iteration_ = affinity_.begin(); }
  std::vector<AffinityEntry>::iterator& affinityIteration() { return affinity_iteration_; };
  std::vector<AffinityEntry>::iterator& nextAffinityIteration() {
    // When try next affinity, destination set by pervious one become invalid, should be cleared.
    resetDestination();

    if (affinity_iteration_ != affinity_.end()) {
      return ++affinity_iteration_;
    } else {
      return affinity_iteration_;
    }
  };

  void addEPOperation(
      size_t raw_offset, absl::string_view& header, HeaderType type,
      const std::vector<envoy::extensions::filters::network::sip_proxy::v3alpha::LocalService>&
          local_services);
  void addOpaqueOperation(size_t raw_offset, absl::string_view& header);
  void deleteInstipOperation(size_t raw_offset, absl::string_view& header);

  void addMsgHeader(HeaderType type, absl::string_view value);

  absl::string_view getDomainFromHeaderParameter(HeaderType type, const std::string& parameter);

  void parseHeader(HeaderType type, unsigned short index = 0) {
    return headers_[type][index].parseHeader();
  }

  // TODO how to combine the interface of header and listHeader?
  SipHeader header(HeaderType type, unsigned int index = 0) {
    if (index >= headers_[type].size()) {
      return SipHeader{type, ""};
    }
    return headers_[type].at(index);
  }

  std::vector<SipHeader>& listHeader(HeaderType type) { return headers_[type]; }

  TraContextMap& traContext() {
    if (tra_context_map_.empty()) {
      auto fromHeader = listHeader(HeaderType::From).front().text();
      tra_context_map_.emplace(std::make_pair("method_type", methodStr[methodType()]));
      tra_context_map_.emplace(std::make_pair("from_header", fromHeader));
    }
    return tra_context_map_;
  }

private:
  MsgType msg_type_;
  MethodType method_type_;
  std::vector<std::vector<SipHeader>> headers_{HeaderType::HeaderMaxNum};

  std::vector<Operation> operation_list_;
  absl::optional<absl::string_view> ep_{};
  absl::optional<absl::string_view> opaque_{};

  absl::optional<std::pair<std::string, std::string>> p_cookie_ip_map_{};

  absl::optional<absl::string_view> transaction_id_{};

  std::string destination_{};

  std::vector<AffinityEntry> affinity_{};
  std::vector<AffinityEntry>::iterator affinity_iteration_{affinity_.begin()};

  std::string raw_msg_{};
  State state_{State::TransportBegin};
  bool stop_load_balance_{};

  TraContextMap tra_context_map_{};

  bool isDomainMatched(
      HeaderType type,
      const std::vector<envoy::extensions::filters::network::sip_proxy::v3alpha::LocalService>&
          local_services) {
    for (auto& service : local_services) {
      if (service.parameter().empty() || service.domain().empty()) {
        // no default value
        continue;
      }
      if (service.domain() == getDomainFromHeaderParameter(type, service.parameter())) {
        return true;
      }
    }
    return false;
  }
};

using MessageMetadataSharedPtr = std::shared_ptr<MessageMetadata>;

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/sip_proxy/filters/network/source/utility.h"

#include "contrib/sip_proxy/filters/network/source/filters/filter.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

void PendingList::pushIntoPendingList(const std::string& type, const std::string& key,
                                      SipFilters::DecoderFilterCallbacks& activetrans,
                                      std::function<void(void)> func) {
  ENVOY_LOG(debug, "PUSH {}-{} {} into PendigList", type, key, activetrans.transactionId());
  if (activetrans.metadata()->affinityIteration() != activetrans.metadata()->affinity().end() &&
      type == activetrans.metadata()->affinityIteration()->type()) {
    if (pending_list_[type + key].empty()) {
      // need to do tra query
      func();
    }
    pending_list_[type + key].emplace_back(activetrans);
  } else {
    // handle connection
    func();
    pending_list_[type + key].emplace_back(activetrans);
  }
}

// TODO this should be enhanced to save index in hash table keyed with
// transaction_id to improve search performance
void PendingList::eraseActiveTransFromPendingList(std::string& transaction_id) {
  ENVOY_LOG(debug, "ERASE {} from PendigList", transaction_id);
  for (auto& item : pending_list_) {
    for (auto it = item.second.begin(); it != item.second.end();) {
      if ((*it).get().transactionId() == transaction_id) {
        // TODO timeout handle this transaction, need send 408 timeout
        //
        it = item.second.erase(it);
      } else {
        ++it;
      }
    }
  }
}

void PendingList::onResponseHandleForPendingList(
    const std::string& type, const std::string& key,
    std::function<void(MessageMetadataSharedPtr, DecoderEventHandler&)> func) {
  auto mylist = pending_list_[type + key];
  for (auto& activetrans_ref : mylist) {
    func(activetrans_ref.get().metadata(),
         dynamic_cast<DecoderEventHandler&>(activetrans_ref.get()));
  }

  pending_list_[type + key].clear();
}
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/buffer/buffer.h"

#include "contrib/sip_proxy/filters/network/source/metadata.h"
#include "contrib/sip_proxy/filters/network/source/sip.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
class Encoder : public Logger::Loggable<Logger::Id::filter> {
public:
  virtual ~Encoder() = default;
  virtual void encode(const MessageMetadataSharedPtr& metadata, Buffer::Instance& out) PURE;
};

class EncoderImpl : public Encoder {
public:
  void encode(const MessageMetadataSharedPtr& metadata, Buffer::Instance& out) override;
};

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/sip_proxy/filters/network/source/encoder.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

void EncoderImpl::encode(const MessageMetadataSharedPtr& metadata, Buffer::Instance& out) {
  std::string output = "";
  std::string& raw_msg = metadata->rawMsg();
  std::sort(metadata->operationList().begin(), metadata->operationList().end());

  size_t previous_position = 0;
  for (auto& operation : metadata->operationList()) {
    switch (operation.type_) {
    case OperationType::Insert: {
      std::string value = absl::get<InsertOperationValue>(operation.value_).value_;
      if (value == ";ep=" || value == ",opaque=") {
        if (metadata->ep().has_value() && metadata->ep().value().length() > 0) {
          output += raw_msg.substr(previous_position, operation.position_ - previous_position);
          previous_position = operation.position_;

          output += absl::get<InsertOperationValue>(operation.value_).value_;
          if (value == ",opaque=") {
            output += "\"";
          }
          output += std::string(metadata->ep().value());
          if (value == ",opaque=") {
            output += "\"";
          }
        }
      } else {
        output += raw_msg.substr(previous_position, operation.position_ - previous_position);
        previous_position = operation.position_;

        output += absl::get<InsertOperationValue>(operation.value_).value_;
      }
      break;
    }
    case OperationType::Modify:
      output += raw_msg.substr(previous_position, operation.position_ - previous_position);
      previous_position = operation.position_;

      output += absl::get<ModifyOperationValue>(operation.value_).dest_;
      previous_position += absl::get<ModifyOperationValue>(operation.value_).src_length_;
      break;
    case OperationType::Delete:
      output += raw_msg.substr(previous_position, operation.position_ - previous_position);
      previous_position = operation.position_;

      previous_position += absl::get<DeleteOperationValue>(operation.value_).length_;
      break;
    default:
      break;
    }
  }

  output += raw_msg.substr(previous_position);
  out.add(output);
}

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/sip_proxy/filters/network/source/app_exception_impl.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

DirectResponse::ResponseType AppException::encode(MessageMetadata& metadata,
                                                  Buffer::Instance& buffer) const {
  std::stringstream output;

  // Top line
  output << "SIP/2.0 503 Service Unavailable\r\n";

  // To
  if (!metadata.header(HeaderType::To).empty()) {
    metadata.parseHeader(HeaderType::To);
    auto to = metadata.header(HeaderType::To);
    output << fmt::format("To: {}", to.text());

    if (!to.hasParam("tag")) {

      // We could simply use the time of day as a tag; however, that is not unique
      // enough. So, let's perturb the time of day with a salt to get a better
      // unique number. The salt I am using here is the summation of each
      // character of the proxy's IP address
      output << ";tag=";
      if (metadata.ep().has_value() && metadata.ep().value().length() > 0) {
        output << fmt::format("{}-", metadata.ep().value());
      }
      std::time_t t;
      long s = 0;
      t = time(&t);
      s = std::labs(t - s);
      output << fmt::format("{}", s);
    }
    output << "\r\n";
  } else {
    ENVOY_LOG(error, "No \"To\" in received message");
  }

  // From
  if (!metadata.header(HeaderType::From).empty()) {
    output << fmt::format("From: {}\r\n", metadata.header(HeaderType::From).text());
  } else {
    ENVOY_LOG(error, "No \"From\" in received message");
  }

  // Call-ID
  if (!metadata.header(HeaderType::CallId).empty()) {
    output << fmt::format("Call-ID: {}\r\n", metadata.header(HeaderType::CallId).text());
  } else {
    ENVOY_LOG(error, "No \"Call-ID\" in received message");
  }

  // Via
  for (const auto& via : metadata.listHeader(HeaderType::Via)) {
    output << fmt::format("Via: {}\r\n", via.text());
  }

  // CSeq
  if (!metadata.header(HeaderType::Cseq).empty()) {
    output << fmt::format("CSeq: {}\r\n", metadata.header(HeaderType::Cseq).text());
  } else {
    ENVOY_LOG(error, "No \"Cseq\" in received message");
  }

  // Failed Reason
  output << fmt::format("Reason: {}\r\n", what());

  // Content-length
  output << "Content-Length: 0\r\n";

  // End
  output << "\r\n";

  buffer.add(output.str());

  return DirectResponse::ResponseType::Exception;
}

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_library(
    name = "app_exception_lib",
    srcs = ["app_exception_impl.cc"],
    hdrs = ["app_exception_impl.h"],
    deps = [
        ":sip_lib",
        ":utility_interface",
        "//envoy/buffer:buffer_interface",
    ],
)

envoy_cc_contrib_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    deps = [
        ":app_exception_lib",
        ":conn_manager_lib",
        ":decoder_lib",
        ":utility_interface",
        "//contrib/sip_proxy/filters/network/source/filters:filter_config_interface",
        "//contrib/sip_proxy/filters/network/source/filters:well_known_names",
        "//contrib/sip_proxy/filters/network/source/router:router_lib",
        "//envoy/registry",
        "//source/common/config:utility_lib",
        "//source/extensions/filters/network/common:factory_base_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/router/v3alpha:pkg_cc_proto",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "conn_manager_lib",
    srcs = ["conn_manager.cc"],
    hdrs = ["conn_manager.h"],
    external_deps = ["abseil_any"],
    deps = [
        ":app_exception_lib",
        ":decoder_lib",
        ":encoder_lib",
        ":stats_lib",
        ":utility_lib",
        "//contrib/sip_proxy/filters/network/source/router:router_interface",
        "//contrib/sip_proxy/filters/network/source/tra:tra_lib",
        "//envoy/event:deferred_deletable",
        "//envoy/event:dispatcher_interface",
        "//envoy/network:connection_interface",
        "//envoy/network:filter_interface",
        "//envoy/stats:stats_interface",
        "//envoy/stats:timespan_interface",
        "//source/common/buffer:buffer_lib",
        "//source/common/common:assert_lib",
        "//source/common/common:linked_object",
        "//source/common/common:logger_lib",
        "//source/common/network:filter_lib",
        "//source/common/stats:timespan_lib",
        "//source/common/stream_info:stream_info_lib",
        "//source/common/tracing:http_tracer_lib",
    ],
)

envoy_cc_library(
    name = "decoder_events_lib",
    hdrs = ["decoder_events.h"],
    deps = [
        ":metadata_lib",
        ":sip_lib",
    ],
)

envoy_cc_library(
    name = "decoder_lib",
    srcs = ["decoder.cc"],
    hdrs = ["decoder.h"],
    deps = [
        ":app_exception_lib",
        ":stats_lib",
        ":utility_interface",
        "//contrib/sip_proxy/filters/network/source/filters:filter_interface",
        "//source/common/buffer:buffer_lib",
    ],
)

envoy_cc_library(
    name = "encoder_lib",
    srcs = ["encoder.cc"],
    hdrs = ["encoder.h"],
    deps = [
        ":app_exception_lib",
        ":stats_lib",
        ":utility_interface",
        "//contrib/sip_proxy/filters/network/source/filters:filter_interface",
        "//source/common/buffer:buffer_lib",
    ],
)

envoy_cc_library(
    name = "metadata_lib",
    srcs = ["metadata.cc"],
    hdrs = [
        "metadata.h",
        "operation.h",
    ],
    external_deps = ["abseil_optional"],
    deps = [
        ":sip_lib",
        "//envoy/buffer:buffer_interface",
        "//source/common/common:macros",
        "//source/common/http:header_map_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "utility_lib",
    srcs = ["utility.cc"],
    deps = [
        ":utility_interface",
        "//contrib/sip_proxy/filters/network/source/filters:filter_interface",
        "//envoy/server:factory_context_interface",
        "//envoy/server:transport_socket_config_interface",
    ],
)

envoy_cc_library(
    name = "utility_interface",
    hdrs = [
        "utility.h",
    ],
    external_deps = ["abseil_optional"],
    deps = [
        ":decoder_events_lib",
        ":metadata_lib",
        ":sip_lib",
        "//envoy/buffer:buffer_interface",
        "//envoy/config:typed_config_interface",
        "//envoy/registry",
        "//source/common/common:assert_lib",
        "//source/common/config:utility_lib",
        "//source/common/protobuf",
        "//source/common/singleton:const_singleton",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/tra/v3alpha:pkg_cc_proto",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "stats_lib",
    hdrs = ["stats.h"],
    deps = [
        ":sip_lib",
        "//envoy/stats:stats_interface",
        "//envoy/stats:stats_macros",
    ],
)

envoy_cc_library(
    name = "conn_state_lib",
    hdrs = ["conn_state.h"],
    deps = [
        "//envoy/tcp:conn_pool_interface",
    ],
)

envoy_cc_library(
    name = "sip_lib",
    hdrs = ["sip.h"],
    deps = [
        "//source/common/common:assert_lib",
        "//source/common/singleton:const_singleton",
    ],
)
#pragma once

#include <string>

#include "absl/types/variant.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

enum class OperationType {
  Invalid = 0,
  Insert = 1,
  Delete = 2,
  Modify = 3,
  Query = 4, // not used yet.
};

struct InsertOperationValue {
  InsertOperationValue(std::string&& value) : value_(value) {}
  std::string value_;
};
struct DeleteOperationValue {
  DeleteOperationValue(size_t length) : length_(length) {}
  size_t length_;
};
struct ModifyOperationValue {
  ModifyOperationValue(size_t src_length, std::string&& dest)
      : src_length_(src_length), dest_(dest) {}
  size_t src_length_;
  std::string dest_;
};

class Operation {
public:
  Operation(OperationType type, size_t position,
            absl::variant<InsertOperationValue, DeleteOperationValue, ModifyOperationValue> value)
      : type_(type), position_(position), value_(value) {}

  // constexpr bool operator<(const Operation& other) { return this->position_ < other.position_; }
  // constexpr bool operator>(const Operation& other) { return this->position_ > other.position_; }
  // constexpr bool operator==(const Operation& other) { return this->position_ == other.position_;
  // } constexpr bool operator!=(const Operation& other) { return this->position_ !=
  // other.position_; } constexpr bool operator<=(const Operation& other) { return this->position_
  // <= other.position_; } constexpr bool operator>=(const Operation& other) { return
  // this->position_ >= other.position_; } constexpr bool operator<=>(Operation &other) { return
  // this->position_ <=> other.position_; }

  // private:
  OperationType type_;
  size_t position_;
  absl::variant<InsertOperationValue, DeleteOperationValue, ModifyOperationValue> value_;
};

static constexpr bool operator<(const Operation& o1, const Operation& o2) {
  return o1.position_ < o2.position_;
}

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include <cstddef>

#include "envoy/buffer/buffer.h"
#include "envoy/server/factory_context.h"
#include "envoy/server/transport_socket_config.h"

#include "source/common/protobuf/protobuf.h"

#include "contrib/envoy/extensions/filters/network/sip_proxy/tra/v3alpha/tra.pb.h"
#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.h"
#include "contrib/sip_proxy/filters/network/source/decoder_events.h"
#include "contrib/sip_proxy/filters/network/source/metadata.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace SipFilters {
class DecoderFilterCallbacks;
}

class SipSettings {
public:
  SipSettings(
      std::chrono::milliseconds transaction_timeout,
      const Protobuf::RepeatedPtrField<
          envoy::extensions::filters::network::sip_proxy::v3alpha::LocalService>& local_services,
      const envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceConfig&
          tra_service_config,
      bool operate_via)
      : transaction_timeout_(transaction_timeout), tra_service_config_(tra_service_config),
        operate_via_(operate_via) {
    UNREFERENCED_PARAMETER(operate_via_);

    for (const auto& service : local_services) {
      local_services_.emplace_back(service);
    }
  }

  SipSettings(
      envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy::SipSettings sip_settings) {
    transaction_timeout_ = static_cast<std::chrono::milliseconds>(
        PROTOBUF_GET_MS_OR_DEFAULT(sip_settings, transaction_timeout, 32000));
    tra_service_config_ = sip_settings.tra_service_config();
    operate_via_ = sip_settings.operate_via();
    for (const auto& service : sip_settings.local_services()) {
      local_services_.emplace_back(service);
    }
  }

  std::chrono::milliseconds transactionTimeout() { return transaction_timeout_; }
  std::vector<envoy::extensions::filters::network::sip_proxy::v3alpha::LocalService>&
  localServices() {
    return local_services_;
  }
  envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceConfig&
  traServiceConfig() {
    return tra_service_config_;
  }

private:
  std::chrono::milliseconds transaction_timeout_;

  std::vector<envoy::extensions::filters::network::sip_proxy::v3alpha::LocalService>
      local_services_;
  envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceConfig
      tra_service_config_;
  bool operate_via_;
};

/**
 * A DirectResponse manipulates a Protocol to directly create a Sip response message.
 */
class DirectResponse {
public:
  virtual ~DirectResponse() = default;

  enum class ResponseType {
    // DirectResponse encodes MessageType::Reply with success payload
    SuccessReply,

    // DirectResponse encodes MessageType::Reply with an exception payload
    ErrorReply,

    // DirectResponse encodes MessageType::Exception
    Exception,
  };

  /**
   * Encodes the response via the given Protocol.
   * @param metadata the MessageMetadata for the request that generated this response
   * @param proto the Protocol to be used for message encoding
   * @param buffer the Buffer into which the message should be encoded
   * @return ResponseType indicating whether the message is a successful or error reply or an
   *         exception
   */
  virtual ResponseType encode(MessageMetadata& metadata, Buffer::Instance& buffer) const PURE;
};

/**
 * In order to handle TRA retrieve async, introduce PendingList to hold current message.
 * described as below:
 *
 * --> tra_query_request
 *     --> has local cache
 *         --> pending_list[base_uri] has value
 *             --> hold current message into pending_list with base_uri as key
 *         --> pending_list[base_uri] no value
 *             --> do tra query
 *             --> hold current message into pending_list with base_uri as key
 *     --> no  local cache
 *         --> full_uri as key
 *         --> hold current message into pending_list;
 *
 * --> tra_query_response_arrived
 *     --> handle all messages in same query
 *         --> continue_to_handle
 */
class PendingList : public Logger::Loggable<Logger::Id::filter> {
public:
  PendingList() = default;

  void pushIntoPendingList(const std::string& type, const std::string& key,
                           SipFilters::DecoderFilterCallbacks& activetrans,
                           std::function<void(void)> func);

  // TODO this should be enhanced to save index in hash table keyed with
  // transaction_id to improve search performance
  void eraseActiveTransFromPendingList(std::string& transaction_id);

  void onResponseHandleForPendingList(
      const std::string& type, const std::string& key,
      std::function<void(MessageMetadataSharedPtr, DecoderEventHandler&)> func);

private:
  absl::flat_hash_map<std::string,
                      std::list<std::reference_wrapper<SipFilters::DecoderFilterCallbacks>>>
      pending_list_;
};

class PendingListHandler {
public:
  virtual ~PendingListHandler() = default;
  virtual void pushIntoPendingList(const std::string& type, const std::string& key,
                                   SipFilters::DecoderFilterCallbacks& activetrans,
                                   std::function<void(void)> func) PURE;
  virtual void onResponseHandleForPendingList(
      const std::string& type, const std::string& key,
      std::function<void(MessageMetadataSharedPtr, DecoderEventHandler&)> func) PURE;
  virtual void eraseActiveTransFromPendingList(std::string& transaction_id) PURE;
};

class Utility {
public:
  static const std::string& localAddress(Server::Configuration::FactoryContext& context) {
    return context.getTransportSocketFactoryContext()
        .serverFactoryContext()
        .localInfo()
        .address()
        ->ip()
        ->addressAsString();
  }
};

/**
 * flat_hash_map with size limitation.
 * @tparam max_size: the maximum size of the hash map, default is 1024.
 */
template <typename K, typename V> class Cache {
public:
  Cache(unsigned int max_size = 1024)
      : max_size_(max_size), ring_buffer_(max_size_), it_(ring_buffer_.begin()) {}

  Cache(const Cache&) = delete;
  Cache(const Cache&&) = delete;
  Cache& operator=(const Cache&) = delete;
  virtual ~Cache() = default;

  void emplace(const K& key, const V& value) {
    auto it = cache_.find(key);
    if (it != cache_.cend()) {
      if (it_ != it->second.it_) {
        ring_buffer_.erase(it->second.it_);
        auto new_it = ring_buffer_.insert(it_, key);
        it->second.it_ = new_it;
      }
      it->second.value_ = value;
    } else {
      if (!it_->empty()) {
        cache_.erase(*it_);
      }

      *it_ = key;

      Data d{value, it_};
      cache_.emplace(key, d);

      ++it_;
    }

    if (it_ == ring_buffer_.end()) {
      it_ = ring_buffer_.begin();
    }
  }

  bool contains(const K& key) { return cache_.find(key) != cache_.end(); }

  OptRef<V> at(const K& key) {
    auto it = cache_.find(key);
    if (it != cache_.cend()) {
      return OptRef<V>{it->second.value_};
    }
    return {};
  }

  void erase(const K& key) {
    auto it = cache_.find(key);
    if (it != cache_.cend()) {
      *(it->second.it_) = "";
      cache_.erase(it);
    }
  }

  size_t size() { return cache_.size(); }

private:
  struct Data {
    V value_;
    typename std::list<K>::iterator it_;
  };

  unsigned int max_size_;
  std::map<K, Data> cache_;
  std::list<K> ring_buffer_;
  typename std::list<K>::iterator it_;
};

template <typename T, typename K, typename V> class CacheManager {
public:
  /**
   * @brief Construct a new Cache Manager object
   *
   * @param max_size: the maximum size of each cache type, default is 1024.
   */
  CacheManager(unsigned int max_size = 1024) : max_size_(max_size) {}

  void initCache(const T& type, unsigned int max_size = 1024) { caches_.emplace(type, max_size); }

  void insertCache(const T& type, const K& key, const V& value) {
    auto it = caches_.find(type);
    if (it != caches_.end()) {
      it->second.emplace(key, value);
    } else {
      auto it_new = caches_.emplace(type, max_size_);
      it_new.first->second.emplace(key, value);
    }
  }

  bool contains(const T& type, const K& key) {
    auto it = caches_.find(type);
    if (it != caches_.cend()) {
      return it->second.contains(key);
    }
    return false;
  }

  OptRef<V> at(const T& type, const K& key) {
    auto it_type = caches_.find(type);
    if (it_type != caches_.cend()) {
      return OptRef<V>{it_type->second.at(key)};
    }
    return {};
  }

  void erase(const T& type, const K& key) {
    auto it_type = caches_.find(type);
    if (it_type != caches_.cend()) {
      return it_type->second.erase(key);
    }
  }

  Cache<K, V>& operator[](const T& type) { return caches_[type]; }

private:
  // Maximum size of each cache type.
  unsigned int max_size_;
  std::map<T, Cache<K, V>> caches_;
};

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/common/exception.h"

#include "contrib/sip_proxy/filters/network/source/metadata.h"
#include "contrib/sip_proxy/filters/network/source/sip.h"
#include "contrib/sip_proxy/filters/network/source/utility.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

struct AppException : public EnvoyException,
                      public DirectResponse,
                      Logger::Loggable<Logger::Id::connection> {
  AppException(AppExceptionType type, const std::string& what)
      : EnvoyException(what), type_(type) {}
  AppException(const AppException& ex) : EnvoyException(ex.what()), type_(ex.type_) {}

  ResponseType encode(MessageMetadata& metadata, Buffer::Instance& buffer) const override;

  const AppExceptionType type_;
};

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/sip_proxy/filters/network/source/decoder.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

DecoderStateMachine::DecoderStatus DecoderStateMachine::transportBegin() {
  metadata_->setState(State::MessageBegin);
  return {State::MessageBegin, handler_.transportBegin(metadata_)};
}

DecoderStateMachine::DecoderStatus DecoderStateMachine::messageBegin() {
  metadata_->setState(State::MessageEnd);
  return {State::MessageEnd, handler_.messageBegin(metadata_)};
}

DecoderStateMachine::DecoderStatus DecoderStateMachine::messageEnd() {
  metadata_->setState(State::TransportEnd);
  return {State::TransportEnd, handler_.messageEnd()};
}

DecoderStateMachine::DecoderStatus DecoderStateMachine::transportEnd() {
  metadata_->setState(State::Done);
  return {State::Done, handler_.transportEnd()};
}

DecoderStateMachine::DecoderStatus DecoderStateMachine::handleState() {
  switch (metadata_->state()) {
  case State::TransportBegin:
    return transportBegin();
  case State::MessageBegin:
    return messageBegin();
  case State::MessageEnd:
    return messageEnd();
  case State::TransportEnd:
    return transportEnd();
  case State::HandleAffinity:
    return messageBegin();
  default:
    /**
     * test failed report "panic:     not reached" if reach here
     */
    PANIC("not reached");
  }
}

State DecoderStateMachine::run() {
  while (metadata_->state() != State::Done) {
    ENVOY_LOG(trace, "sip: state {}", StateNameValues::name(metadata_->state()));

    DecoderStatus s = handleState();

    ASSERT(s.filter_status_.has_value());
    if (s.filter_status_.value() == FilterStatus::StopIteration) {
      return State::StopIteration;
    }
  }

  return metadata_->state();
}

Decoder::Decoder(DecoderCallbacks& callbacks) : callbacks_(callbacks) {}

void Decoder::complete() {
  request_.reset();
  metadata_.reset();
  state_machine_ = nullptr;

  current_header_ = HeaderType::TopLine;
  raw_offset_ = 0;

  first_via_ = true;
  first_route_ = true;
  first_record_route_ = true;
  first_service_route_ = true;
}

FilterStatus Decoder::onData(Buffer::Instance& data, bool continue_handling) {
  if (continue_handling) {
    // means previous handling suspended, continue handling last request
    state_machine_->run();
    complete();
  } else {
    reassemble(data);
  }
  return FilterStatus::StopIteration;
}

int Decoder::reassemble(Buffer::Instance& data) {
  // ENVOY_LOG(trace, "received --> {}\n{}", data.length(), data.toString());

  Buffer::Instance& remaining_data = data;

  int ret = 0;
  size_t clen = 0;         // Content-Length value
  size_t full_msg_len = 0; // Length of the entire message

  while (remaining_data.length() != 0) {
    ssize_t content_pos = remaining_data.search("\n\r\n", strlen("\n\r\n"), 0);
    if (content_pos != -1) {
      // Get the Content-Length header value so that we can find
      // out the full message length.
      content_pos += strlen("\n\r\n"); // move to the line after the CRLF line.

      ssize_t content_length_start =
          remaining_data.search("Content-Length:", strlen("Content-Length:"), 0, content_pos);
      if (content_length_start == -1) {
        break;
      }

      ssize_t content_length_end = remaining_data.search(
          "\r\n", strlen("\r\n"), content_length_start + strlen("Content-Length:"), content_pos);

      // The "\n\r\n" is always included in remaining_data, so could not return -1
      // if (content_length_end == -1) {
      //   break;
      // }

      char len[10]{}; // temporary storage
      remaining_data.copyOut(content_length_start + strlen("Content-Length:"),
                             content_length_end - content_length_start - strlen("Content-Length:"),
                             len);

      clen = std::atoi(len);

      // atoi return value >= 0, could not < 0
      // if (clen < static_cast<size_t>(0)) {
      //   break;
      // }

      full_msg_len = content_pos + clen;
    }

    // Check for partial message received.
    if ((full_msg_len == 0) || (full_msg_len > remaining_data.length())) {
      break;
    } else {
      // We have a full SIP message; put it on the dispatch queue.
      Buffer::OwnedImpl message{};
      message.move(remaining_data, full_msg_len);
      onDataReady(message);

      // Even the handle of current sip message hasn't finished(async handle),
      // we use string of this buffer, so it can be drain safely.
      message.drain(message.length());
      full_msg_len = 0;
    }
  } // End of while (remaining_data_len > 0)

  return ret;
}

FilterStatus Decoder::onDataReady(Buffer::Instance& data) {
  ENVOY_LOG(debug, "SIP onDataReady {}\n{}", data.length(), data.toString());

  metadata_ = std::make_shared<MessageMetadata>(data.toString());

  decode();

  request_ = std::make_unique<ActiveRequest>(callbacks_.newDecoderEventHandler(metadata_));
  state_machine_ = std::make_unique<DecoderStateMachine>(metadata_, request_->handler_);
  State rv = state_machine_->run();

  if (rv == State::Done) {
    // complete();
  }
  complete();

  return FilterStatus::StopIteration;
}

auto Decoder::sipHeaderType(absl::string_view sip_line) {
  // XXX StringUtil::trim has poor performance
  auto delimiter_index = sip_line.find_first_of(':');
  auto header_type_str = sip_line.substr(0, delimiter_index);
  auto header_value = StringUtil::trim(sip_line.substr(delimiter_index + strlen(":")));
  return std::tuple<HeaderType, absl::string_view>{HeaderTypes::get().str2Header(header_type_str),
                                                   header_value};
}

MsgType Decoder::sipMsgType(absl::string_view top_line) {
  if (top_line.find("SIP/2.0 ") == absl::string_view::npos) {
    return MsgType::Request;
  } else {
    return MsgType::Response;
  }
}

MethodType Decoder::sipMethod(absl::string_view top_line) {
  if (top_line.find("INVITE") != absl::string_view::npos) {
    return MethodType::Invite;
  } else if (top_line.find("CANCEL") != absl::string_view::npos) {
    return MethodType::Cancel;
  } else if (top_line.find("REGISTER") != absl::string_view::npos) {
    return MethodType::Register;
  } else if (top_line.find("REFER") != absl::string_view::npos) {
    return MethodType::Refer;
  } else if (top_line.find("UPDATE") != absl::string_view::npos) {
    return MethodType::Update;
  } else if (top_line.find("SUBSCRIBE") != absl::string_view::npos) {
    return MethodType::Subscribe;
  } else if (top_line.find("NOTIFY") != absl::string_view::npos) {
    return MethodType::Notify;
  } else if (top_line.find("ACK") != absl::string_view::npos) {
    return MethodType::Ack;
  } else if (top_line.find("BYE") != absl::string_view::npos) {
    return MethodType::Bye;
  } else if (top_line.find("2.0 200") != absl::string_view::npos) {
    return MethodType::Ok200;
  } else if (top_line.find("2.0 4") != absl::string_view::npos) {
    return MethodType::Failure4xx;
  } else {
    return MethodType::OtherMethod;
  }
}

Decoder::HeaderHandler::HeaderHandler(MessageHandler& parent) : parent_(parent) {}

int Decoder::HeaderHandler::processPath(absl::string_view& header) {
  metadata()->deleteInstipOperation(rawOffset(), header);
  metadata()->addEPOperation(rawOffset(), header, HeaderType::Path,
                             parent_.parent_.settings()->localServices());
  return 0;
}

int Decoder::HeaderHandler::processRoute(absl::string_view& header) {
  UNREFERENCED_PARAMETER(header);
  if (!isFirstRoute()) {
    return 0;
  }
  setFirstRoute(false);
  return 0;
}

int Decoder::HeaderHandler::processRecordRoute(absl::string_view& header) {
  if (!isFirstRecordRoute()) {
    return 0;
  }

  setFirstRecordRoute(false);

  metadata()->addEPOperation(rawOffset(), header, HeaderType::RRoute,
                             parent_.parent_.settings()->localServices());
  return 0;
}

int Decoder::HeaderHandler::processWwwAuth(absl::string_view& header) {
  metadata()->addOpaqueOperation(rawOffset(), header);
  return 0;
}

int Decoder::HeaderHandler::processAuth(absl::string_view& header) {
  auto loc = header.find("opaque=");
  if (loc == absl::string_view::npos) {
    return 0;
  }
  // has ""
  auto start = loc + strlen("opaque=\"");
  auto end = header.find('\"', start);
  if (end == absl::string_view::npos) {
    return 0;
  }

  metadata()->setOpaque(header.substr(start, end - start));
  return 0;
}

int Decoder::HeaderHandler::processPCookieIPMap(absl::string_view& header) {
  auto loc = header.find('=');
  if (loc == absl::string_view::npos) {
    return 0;
  }
  auto lskpmc =
      header.substr(header.find(": ") + strlen(": "), loc - header.find(": ") - strlen(": "));
  auto ip = header.substr(loc + 1, header.length() - loc - 1);

  metadata()->setPCookieIpMap(std::make_pair(std::string(lskpmc), std::string(ip)));
  metadata()->setOperation(Operation(OperationType::Delete, rawOffset(),
                                     DeleteOperationValue(header.length() + strlen("\r\n"))));
  return 0;
}

int Decoder::HeaderHandler::processContact(absl::string_view& header) {
  metadata()->deleteInstipOperation(rawOffset(), header);
  metadata()->addEPOperation(rawOffset(), header, HeaderType::Contact,
                             parent_.parent_.settings()->localServices());
  return 0;
}

int Decoder::HeaderHandler::processServiceRoute(absl::string_view& header) {
  if (!isFirstServiceRoute()) {
    return 0;
  }
  setFirstServiceRoute(false);

  metadata()->addEPOperation(rawOffset(), header, HeaderType::SRoute,
                             parent_.parent_.settings()->localServices());
  return 0;
}

void Decoder::REGISTERHandler::parseHeader(HeaderType& type, absl::string_view& header) {
  switch (type) {
  case HeaderType::Route:
    handler_->processRoute(header);
    break;
  case HeaderType::Via:
    handler_->processVia(header);
    break;
  case HeaderType::Contact:
    handler_->processContact(header);
    break;
  case HeaderType::Path:
    handler_->processPath(header);
    break;
  case HeaderType::RRoute:
    handler_->processRecordRoute(header);
    break;
  case HeaderType::SRoute:
    handler_->processServiceRoute(header);
    break;
  case HeaderType::Auth:
    handler_->processAuth(header);
    break;
  case HeaderType::PCookieIPMap:
    handler_->processPCookieIPMap(header);
    break;
  default:
    break;
  }
}

void Decoder::INVITEHandler::parseHeader(HeaderType& type, absl::string_view& header) {
  switch (type) {
  case HeaderType::Via:
    handler_->processVia(header);
    break;
  case HeaderType::Route:
    handler_->processRoute(header);
    break;
  case HeaderType::RRoute:
    handler_->processRecordRoute(header);
    break;
  case HeaderType::SRoute:
    handler_->processServiceRoute(header);
    break;
  case HeaderType::Path:
    handler_->processPath(header);
    break;
  case HeaderType::Contact:
    handler_->processContact(header);
    break;
  case HeaderType::PCookieIPMap:
    handler_->processPCookieIPMap(header);
    break;
  default:
    break;
  }
}

void Decoder::OK200Handler::parseHeader(HeaderType& type, absl::string_view& header) {
  switch (type) {
  case HeaderType::Contact:
    handler_->processContact(header);
    break;
  case HeaderType::RRoute:
    handler_->processRecordRoute(header);
    break;
  case HeaderType::Via:
    handler_->processVia(header);
    break;
  case HeaderType::Path:
    handler_->processPath(header);
    break;
  case HeaderType::SRoute:
    handler_->processServiceRoute(header);
    break;
  case HeaderType::PCookieIPMap:
    handler_->processPCookieIPMap(header);
    break;
  default:
    break;
  }
}

void Decoder::GeneralHandler::parseHeader(HeaderType& type, absl::string_view& header) {
  switch (type) {
  case HeaderType::Route:
    handler_->processRoute(header);
    break;
  case HeaderType::Via:
    handler_->processVia(header);
    break;
  case HeaderType::Contact:
    handler_->processContact(header);
    break;
  case HeaderType::Path:
    handler_->processPath(header);
    break;
  case HeaderType::RRoute:
    handler_->processRecordRoute(header);
    break;
  case HeaderType::PCookieIPMap:
    handler_->processPCookieIPMap(header);
    break;
  default:
    break;
  }
}

void Decoder::SUBSCRIBEHandler::parseHeader(HeaderType& type, absl::string_view& header) {
  switch (type) {
  case HeaderType::Route:
    handler_->processRoute(header);
    break;
  case HeaderType::Via:
    handler_->processVia(header);
    break;
  case HeaderType::Contact:
    handler_->processContact(header);
    break;
  case HeaderType::RRoute:
    handler_->processRecordRoute(header);
    break;
  case HeaderType::PCookieIPMap:
    handler_->processPCookieIPMap(header);
    break;
  default:
    break;
  }
}

void Decoder::FAILURE4XXHandler::parseHeader(HeaderType& type, absl::string_view& header) {
  switch (type) {
  case HeaderType::WAuth:
    handler_->processWwwAuth(header);
    break;
  case HeaderType::Via:
    handler_->processVia(header);
    break;
  case HeaderType::PCookieIPMap:
    handler_->processPCookieIPMap(header);
    break;
  default:
    break;
  }
}

void Decoder::OthersHandler::parseHeader(HeaderType& type, absl::string_view& header) {
  switch (type) {
  case HeaderType::Via:
    handler_->processVia(header);
    break;
  case HeaderType::Contact:
    handler_->processContact(header);
    break;
  case HeaderType::Path:
    handler_->processPath(header);
    break;
  case HeaderType::RRoute:
    handler_->processRecordRoute(header);
    break;
  case HeaderType::SRoute:
    handler_->processServiceRoute(header);
    break;
  case HeaderType::PCookieIPMap:
    handler_->processPCookieIPMap(header);
    break;
  default:
    break;
  }
}

std::shared_ptr<Decoder::MessageHandler> Decoder::MessageFactory::create(MethodType type,
                                                                         Decoder& parent) {
  switch (type) {
  case MethodType::Invite:
    return std::make_shared<INVITEHandler>(parent);
  case MethodType::Ok200:
    return std::make_shared<OK200Handler>(parent);
  case MethodType::Register:
    return std::make_shared<REGISTERHandler>(parent);
  case MethodType::Subscribe:
    return std::make_shared<SUBSCRIBEHandler>(parent);
  case MethodType::Failure4xx:
    return std::make_shared<FAILURE4XXHandler>(parent);
  case MethodType::Ack:
  case MethodType::Bye:
  case MethodType::Cancel:
    return std::make_shared<GeneralHandler>(parent);
  default:
    return std::make_shared<OthersHandler>(parent);
  }
}

int Decoder::decode() {
  auto& metadata = metadata_;
  absl::string_view msg = absl::string_view(metadata->rawMsg());

  std::shared_ptr<MessageHandler> handler;

  while (!msg.empty()) {
    std::string::size_type crlf = msg.find("\r\n");
    // After message reassemble, this condition could not be true
    // if (crlf == absl::string_view::npos) {
    //   break;
    // }

    if (current_header_ == HeaderType::TopLine) {
      // Sip Request Line
      absl::string_view sip_line = msg.substr(0, crlf);

      metadata->addMsgHeader(HeaderType::TopLine, sip_line);
      metadata->setMsgType(sipMsgType(sip_line));
      metadata->setMethodType(sipMethod(sip_line));
      current_header_ = HeaderType::Other;

      handler = MessageFactory::create(metadata->methodType(), *this);

    } else {
      // Normal Header Line
      absl::string_view sip_line = msg.substr(0, crlf);
      auto [current_header, header_value] = sipHeaderType(sip_line);
      current_header_ = current_header;

      if (current_header == HeaderType::Other) {
        metadata->addMsgHeader(current_header, sip_line);
      } else {
        metadata->addMsgHeader(current_header, header_value);
      }
      handler->parseHeader(current_header, sip_line);
    }

    msg = msg.substr(crlf + strlen("\r\n"));
    raw_offset_ += crlf + strlen("\r\n");

#if __cplusplus > 201703L
    if (msg.starts_with("\r\n")) {
#else
    if (msg[0] == '\r' && msg[1] == '\n') {
#endif
      break;
    }
  }
  return 0;
}

int Decoder::HeaderHandler::processVia(absl::string_view& header) {
  if (!isFirstVia()) {
    return 0;
  }

  metadata()->setTransactionId(header);

  setFirstVia(false);
  return 0;
}

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/stats/scope.h"
#include "envoy/stats/stats_macros.h"

#include "contrib/sip_proxy/filters/network/source/sip.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

enum SipMethodStatsSuffix {
  RequestReceived,
  RequestProxied,
  ResponseReceived,
  ResponseProxied,
  NullSuffix
};

#define SIP_METHOD_COUNTER_CONSTRUCT(method, postfix)                                              \
  POOL_COUNTER_PREFIX(scope, prefix)(method_##postfix)

#define SIP_METHOD_COUNTER(method, postfix)                                                        \
  sip_method_counter_vector_[method * SipMethodStatsPostfix::NullPosfix + postfix]

/**
 * All sip filter stats. @see stats_macros.h
 */
#define ALL_SIP_FILTER_STATS(COUNTER, GAUGE, HISTOGRAM)                                            \
  COUNTER(cx_destroy_local_with_active_rq)                                                         \
  COUNTER(cx_destroy_remote_with_active_rq)                                                        \
  COUNTER(request)                                                                                 \
  COUNTER(response)                                                                                \
  COUNTER(response_error)                                                                          \
  COUNTER(response_exception)                                                                      \
  COUNTER(response_reply)                                                                          \
  COUNTER(response_success)                                                                        \
  COUNTER(response_local_generated)                                                                \
  GAUGE(request_active, Accumulate)                                                                \
  HISTOGRAM(request_time_ms, Milliseconds)

/**
 * Struct definition for all sip proxy stats. @see stats_macros.h
 */
struct SipFilterStats {
  ALL_SIP_FILTER_STATS(GENERATE_COUNTER_STRUCT, GENERATE_GAUGE_STRUCT, GENERATE_HISTOGRAM_STRUCT)

  static SipFilterStats generateStats(const std::string& prefix, Stats::Scope& scope) {

    std::unique_ptr<Stats::StatNamePool> pool =
        std::make_unique<Stats::StatNamePool>((scope.symbolTable()));

    std::vector<Envoy::Stats::Counter*> sip_method_counter_vector(
        static_cast<unsigned int>(MethodType::NullMethod) *
        static_cast<unsigned int>(SipMethodStatsSuffix::NullSuffix));

    for (int i = MethodType::Invite; i != MethodType::NullMethod; ++i) {
      auto method_str = methodStr[i];
      sip_method_counter_vector[i * SipMethodStatsSuffix::NullSuffix +
                                SipMethodStatsSuffix::RequestReceived] =
          &scope.counterFromStatName(
              pool->add(Envoy::statPrefixJoin(prefix, method_str + "_request_received")));
      sip_method_counter_vector[i * SipMethodStatsSuffix::NullSuffix +
                                SipMethodStatsSuffix::RequestProxied] =
          &scope.counterFromStatName(
              pool->add(Envoy::statPrefixJoin(prefix, method_str + "_request_proxied")));
      sip_method_counter_vector[i * SipMethodStatsSuffix::NullSuffix +
                                SipMethodStatsSuffix::ResponseReceived] =
          &scope.counterFromStatName(
              pool->add(Envoy::statPrefixJoin(prefix, method_str + "_response_received")));
      sip_method_counter_vector[i * SipMethodStatsSuffix::NullSuffix +
                                SipMethodStatsSuffix::ResponseProxied] =
          &scope.counterFromStatName(
              pool->add(Envoy::statPrefixJoin(prefix, method_str + "_response_proxied")));
    }

    return SipFilterStats{
        ALL_SIP_FILTER_STATS(POOL_COUNTER_PREFIX(scope, prefix), POOL_GAUGE_PREFIX(scope, prefix),
                             POOL_HISTOGRAM_PREFIX(scope, prefix)) sip_method_counter_vector,
        scope, std::move(pool)};
  }

  Envoy::Stats::Counter& sipMethodCounter(MethodType method, SipMethodStatsSuffix suffix) {
    return *sip_method_counter_vector_[static_cast<int>(method) * SipMethodStatsSuffix::NullSuffix +
                                       suffix];
  }

  std::vector<Envoy::Stats::Counter*> sip_method_counter_vector_;
  Stats::Scope& scope_;
  std::unique_ptr<Stats::StatNamePool> pool_;
};

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/sip_proxy/filters/network/source/conn_manager.h"

#include "envoy/common/exception.h"
#include "envoy/event/dispatcher.h"

#include "source/common/tracing/http_tracer_impl.h"

#include "contrib/sip_proxy/filters/network/source/app_exception_impl.h"
#include "contrib/sip_proxy/filters/network/source/encoder.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

TrafficRoutingAssistantHandler::TrafficRoutingAssistantHandler(
    ConnectionManager& parent, Event::Dispatcher& dispatcher,
    const envoy::extensions::filters::network::sip_proxy::tra::v3alpha::TraServiceConfig& config,
    Server::Configuration::FactoryContext& context, StreamInfo::StreamInfoImpl& stream_info)
    : parent_(parent), stream_info_(std::move(stream_info)) {

  if (config.has_grpc_service()) {
    const std::chrono::milliseconds timeout =
        std::chrono::milliseconds(PROTOBUF_GET_MS_OR_DEFAULT(config, timeout, 2000));
    tra_client_ =
        TrafficRoutingAssistant::traClient(dispatcher, context, config.grpc_service(), timeout);
    tra_client_->setRequestCallbacks(*this);
  }
}

void TrafficRoutingAssistantHandler::updateTrafficRoutingAssistant(
    const std::string& type, const std::string& key, const std::string& val,
    const absl::optional<TraContextMap> context) {

  bool should_update_tra = true;

  auto cached_value = cache_manager_.at(type, key);
  if (cached_value.has_value() && cached_value.value().get() == val) {
    should_update_tra = false;
  }

  if (should_update_tra) {
    cache_manager_.insertCache(type, key, val);
    if (traClient()) {
      traClient()->updateTrafficRoutingAssistant(
          type, absl::flat_hash_map<std::string, std::string>{std::make_pair(key, val)}, context,
          Tracing::NullSpan::instance(), stream_info_);
    }
  }
}

QueryStatus TrafficRoutingAssistantHandler::retrieveTrafficRoutingAssistant(
    const std::string& type, const std::string& key, const absl::optional<TraContextMap> context,
    SipFilters::DecoderFilterCallbacks& activetrans, std::string& host) {

  host = {};

  auto cached_value = cache_manager_.at(type, key);
  if (cached_value.has_value()) {
    host = cached_value.value().get();
    return QueryStatus::Continue;
  }

  if (activetrans.metadata()->affinityIteration()->query()) {
    if (traClient()) {
      parent_.pushIntoPendingList(type, key, activetrans, [&]() {
        traClient()->retrieveTrafficRoutingAssistant(type, key, context,
                                                     Tracing::NullSpan::instance(), stream_info_);
      });
      return QueryStatus::Pending;
    }
  }
  return QueryStatus::Stop;
}

void TrafficRoutingAssistantHandler::deleteTrafficRoutingAssistant(
    const std::string& type, const std::string& key, const absl::optional<TraContextMap> context) {
  cache_manager_.erase(type, key);
  if (traClient()) {
    traClient()->deleteTrafficRoutingAssistant(type, key, context, Tracing::NullSpan::instance(),
                                               stream_info_);
  }
}

void TrafficRoutingAssistantHandler::subscribeTrafficRoutingAssistant(const std::string& type) {
  if (traClient()) {
    traClient()->subscribeTrafficRoutingAssistant(type, Tracing::NullSpan::instance(),
                                                  stream_info_);
  }
}

void TrafficRoutingAssistantHandler::complete(const TrafficRoutingAssistant::ResponseType& type,
                                              const std::string& message_type,
                                              const absl::any& resp) {
  switch (type) {
  case TrafficRoutingAssistant::ResponseType::CreateResp: {
    ENVOY_LOG(trace, "TRA === CreateResp");
    break;
  }
  case TrafficRoutingAssistant::ResponseType::UpdateResp: {
    ENVOY_LOG(trace, "TRA === UpdateResp");
    break;
  }
  case TrafficRoutingAssistant::ResponseType::RetrieveResp: {
    auto resp_data =
        absl::any_cast<
            envoy::extensions::filters::network::sip_proxy::tra::v3alpha::RetrieveResponse>(resp)
            .data();
    for (const auto& item : resp_data) {
      ENVOY_LOG(trace, "TRA === RetrieveResp {} {}={}", message_type, item.first, item.second);
      if (!item.second.empty()) {
        parent_.onResponseHandleForPendingList(
            message_type, item.first,
            [&](MessageMetadataSharedPtr metadata, DecoderEventHandler& decoder_event_handler) {
              // TODO For x-skey case, no need to add to local cache. This will be controlled by
              // config cache->add_query_to_cache.
              if (message_type != "x-skey") {
                cache_manager_.insertCache(message_type, item.first, item.second);
              }
              metadata->setDestination(item.second);
              return parent_.continueHandling(metadata, decoder_event_handler);
            });
      }

      // If the wrong response received, then try next affinity
      parent_.onResponseHandleForPendingList(
          message_type, item.first,
          [&](MessageMetadataSharedPtr metadata, DecoderEventHandler& decoder_event_handler) {
            metadata->nextAffinityIteration();
            parent_.continueHandling(metadata, decoder_event_handler);
          });
    }

    break;
  }
  case TrafficRoutingAssistant::ResponseType::DeleteResp: {
    ENVOY_LOG(trace, "TRA === DeleteResp");
    break;
  }
  case TrafficRoutingAssistant::ResponseType::SubscribeResp: {
    ENVOY_LOG(trace, "TRA === SubscribeResp");
    auto data =
        absl::any_cast<
            envoy::extensions::filters::network::sip_proxy::tra::v3alpha::SubscribeResponse>(resp)
            .data();
    for (auto& item : data) {
      ENVOY_LOG(debug, "TRA UPDATE {}: {}={}", message_type, item.first, item.second);
      cache_manager_.insertCache(message_type, item.first, item.second);
    }
    break;
  }
  case TrafficRoutingAssistant::ResponseType::FailureResp: {
    ENVOY_LOG(trace, "TRA === FailureResp");
    break;
  }
  default:
    break;
  }
}

void TrafficRoutingAssistantHandler::doSubscribe(
    const envoy::extensions::filters::network::sip_proxy::v3alpha::CustomizedAffinity&
        customized_affinity) {
  for (const auto& aff : customized_affinity.entries()) {
    if (aff.subscribe() == true &&
        is_subscribe_map_.find(aff.key_name()) == is_subscribe_map_.end()) {
      subscribeTrafficRoutingAssistant(aff.key_name());
      is_subscribe_map_[aff.key_name()] = true;
    }

    if (aff.cache().max_cache_item() > 0) {
      cache_manager_.initCache(aff.key_name(), aff.cache().max_cache_item());
    }
  }
}

ConnectionManager::ConnectionManager(Config& config, Random::RandomGenerator& random_generator,
                                     TimeSource& time_source,
                                     Server::Configuration::FactoryContext& context,
                                     std::shared_ptr<Router::TransactionInfos> transaction_infos)
    : config_(config), stats_(config_.stats()), decoder_(std::make_unique<Decoder>(*this)),
      random_generator_(random_generator), time_source_(time_source), context_(context),
      transaction_infos_(transaction_infos) {}

ConnectionManager::~ConnectionManager() = default;

Network::FilterStatus ConnectionManager::onData(Buffer::Instance& data, bool end_stream) {
  ENVOY_CONN_LOG(
      debug, "sip proxy received data {} --> {} bytes {}", read_callbacks_->connection(),
      read_callbacks_->connection().connectionInfoProvider().remoteAddress()->asStringView(),
      read_callbacks_->connection().connectionInfoProvider().localAddress()->asStringView(),
      data.length());
  request_buffer_.move(data);
  dispatch();

  if (end_stream) {
    ENVOY_CONN_LOG(info, "downstream half-closed", read_callbacks_->connection());

    resetAllTrans(false);
    read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);
  }

  return Network::FilterStatus::StopIteration;
}

void ConnectionManager::continueHandling(const std::string& key, bool try_next_affinity) {
  onResponseHandleForPendingList(
      "connection_pending", key,
      [&](MessageMetadataSharedPtr metadata, DecoderEventHandler& decoder_event_handler) {
        if (try_next_affinity) {
          metadata->nextAffinityIteration();
          if (metadata->affinityIteration() != metadata->affinity().end()) {
            metadata->setState(State::HandleAffinity);
            continueHandling(metadata, decoder_event_handler);
          } else {
            // When onPoolFailure, continueHandling with try_next_affinity, but there is no next
            // affinity, need throw exception and response with 503.
            auto ex = AppException(AppExceptionType::InternalError,
                                   fmt::format("envoy can't establish connection to {}", key));
            sendLocalReply(*(metadata), ex, false);
            setLocalResponseSent(metadata->transactionId().value());

            decoder_->complete();
          }
        } else {
          continueHandling(metadata, decoder_event_handler);
        }
      });
}

void ConnectionManager::continueHandling(MessageMetadataSharedPtr metadata,
                                         DecoderEventHandler& decoder_event_handler) {
  try {
    decoder_->restore(metadata, decoder_event_handler);
    decoder_->onData(request_buffer_, true);
  } catch (const AppException& ex) {
    ENVOY_LOG(debug, "sip application exception: {}", ex.what());
    sendLocalReply(*(decoder_->metadata()), ex, false);
    setLocalResponseSent(decoder_->metadata()->transactionId().value());

    decoder_->complete();
  } catch (const EnvoyException& ex) {
    ENVOY_CONN_LOG(debug, "sip error: {}", read_callbacks_->connection(), ex.what());

    // Still unaware how to handle this, just close the connection
    read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);
  }
}

void ConnectionManager::dispatch() {
  try {
    decoder_->onData(request_buffer_);
  } catch (const AppException& ex) {
    ENVOY_LOG(debug, "sip application exception: {}", ex.what());
    sendLocalReply(*(decoder_->metadata()), ex, false);
    setLocalResponseSent(decoder_->metadata()->transactionId().value());

    decoder_->complete();
  } catch (const EnvoyException& ex) {
    ENVOY_CONN_LOG(debug, "sip error: {}", read_callbacks_->connection(), ex.what());

    // Still unaware how to handle this, just close the connection
    read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);
  }
}

void ConnectionManager::sendLocalReply(MessageMetadata& metadata, const DirectResponse& response,
                                       bool end_stream) {
  if (read_callbacks_->connection().state() == Network::Connection::State::Closed) {
    ENVOY_LOG(debug, "Connection state is closed");
    return;
  }

  Buffer::OwnedImpl buffer;

  metadata.setEP(Utility::localAddress(context_));
  const DirectResponse::ResponseType result = response.encode(metadata, buffer);

  ENVOY_CONN_LOG(
      debug, "send local reply {} --> {} bytes {}\n{}", read_callbacks_->connection(),
      read_callbacks_->connection().connectionInfoProvider().localAddress()->asStringView(),
      read_callbacks_->connection().connectionInfoProvider().remoteAddress()->asStringView(),
      buffer.length(), buffer.toString());

  read_callbacks_->connection().write(buffer, end_stream);
  if (end_stream) {
    read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);
  }

  switch (result) {
  case DirectResponse::ResponseType::SuccessReply:
    stats_.response_success_.inc();
    break;
  case DirectResponse::ResponseType::ErrorReply:
    stats_.response_error_.inc();
    break;
  case DirectResponse::ResponseType::Exception:
    stats_.response_exception_.inc();
    break;
  default:
    PANIC("not reached");
  }
  stats_.response_local_generated_.inc();
}

void ConnectionManager::setLocalResponseSent(absl::string_view transaction_id) {
  if (transactions_.find(transaction_id) != transactions_.end()) {
    transactions_[transaction_id]->setLocalResponseSent(true);
  }
}

void ConnectionManager::doDeferredTransDestroy(ConnectionManager::ActiveTrans& trans) {
  read_callbacks_->connection().dispatcher().deferredDelete(
      std::move(transactions_.at(trans.transactionId())));
  transactions_.erase(trans.transactionId());
}

void ConnectionManager::resetAllTrans(bool local_reset) {
  ENVOY_LOG(info, "active_trans to be deleted {}", transactions_.size());
  for (auto it = transactions_.cbegin(); it != transactions_.cend();) {
    if (local_reset) {
      ENVOY_CONN_LOG(debug, "local close with active request", read_callbacks_->connection());
      stats_.cx_destroy_local_with_active_rq_.inc();
    } else {
      ENVOY_CONN_LOG(debug, "remote close with active request", read_callbacks_->connection());
      stats_.cx_destroy_remote_with_active_rq_.inc();
    }

    (it++)->second->onReset();
  }
}

void ConnectionManager::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) {
  read_callbacks_ = &callbacks;

  read_callbacks_->connection().addConnectionCallbacks(*this);
  read_callbacks_->connection().enableHalfClose(true);

  auto stream_info = StreamInfo::StreamInfoImpl(
      time_source_, read_callbacks_->connection().connectionInfoProviderSharedPtr());
  tra_handler_ = std::make_shared<TrafficRoutingAssistantHandler>(
      *this, read_callbacks_->connection().dispatcher(), config_.settings()->traServiceConfig(),
      context_, stream_info);
}

void ConnectionManager::onEvent(Network::ConnectionEvent event) {
  ENVOY_CONN_LOG(info, "received event {}", read_callbacks_->connection(), static_cast<int>(event));
  resetAllTrans(event == Network::ConnectionEvent::LocalClose);
}

DecoderEventHandler& ConnectionManager::newDecoderEventHandler(MessageMetadataSharedPtr metadata) {
  stats_.sipMethodCounter(metadata->methodType(), SipMethodStatsSuffix::RequestReceived).inc();

  std::string&& k = std::string(metadata->transactionId().value());
  // if (metadata->methodType() == MethodType::Ack) {
  if (transactions_.find(k) != transactions_.end()) {
    // ACK_4XX metadata will updated later.
    return *transactions_.at(k);
  }
  // }

  ActiveTransPtr new_trans = std::make_unique<ActiveTrans>(*this, metadata);
  new_trans->createFilterChain();
  transactions_.emplace(k, std::move(new_trans));

  return *transactions_.at(k);
}

bool ConnectionManager::ResponseDecoder::onData(MessageMetadataSharedPtr metadata) {
  metadata_ = metadata;
  if (auto status = transportBegin(metadata_); status == FilterStatus::StopIteration) {
    return true;
  }

  if (auto status = messageBegin(metadata_); status == FilterStatus::StopIteration) {
    return true;
  }

  if (auto status = messageEnd(); status == FilterStatus::StopIteration) {
    return true;
  }

  if (auto status = transportEnd(); status == FilterStatus::StopIteration) {
    return true;
  }

  return true;
}

FilterStatus ConnectionManager::ResponseDecoder::messageBegin(MessageMetadataSharedPtr metadata) {
  UNREFERENCED_PARAMETER(metadata);
  return FilterStatus::Continue;
}

FilterStatus ConnectionManager::ResponseDecoder::messageEnd() { return FilterStatus::Continue; }

FilterStatus ConnectionManager::ResponseDecoder::transportEnd() {
  ASSERT(metadata_ != nullptr);

  ConnectionManager& cm = parent_.parent_;

  if (cm.read_callbacks_->connection().state() == Network::Connection::State::Closed) {
    throw EnvoyException("downstream connection is closed");
  }

  Buffer::OwnedImpl buffer;

  metadata_->setEP(Utility::localAddress(cm.context_));
  std::shared_ptr<Encoder> encoder = std::make_shared<EncoderImpl>();

  encoder->encode(metadata_, buffer);

  ENVOY_STREAM_LOG(debug, "send response {}\n{}", parent_, buffer.length(), buffer.toString());
  cm.read_callbacks_->connection().write(buffer, false);

  cm.stats_.response_.inc();
  cm.stats_.sipMethodCounter(metadata_->methodType(), SipMethodStatsSuffix::ResponseProxied).inc();

  return FilterStatus::Continue;
}

FilterStatus ConnectionManager::ActiveTrans::applyDecoderFilters(ActiveTransDecoderFilter* filter) {
  ASSERT(filter_action_ != nullptr);

  if (!local_response_sent_) {
    std::list<ActiveTransDecoderFilterPtr>::iterator entry;
    if (!filter) {
      entry = decoder_filters_.begin();
    } else {
      entry = std::next(filter->entry());
    }

    for (; entry != decoder_filters_.end(); entry++) {
      const FilterStatus status = filter_action_((*entry)->handle_.get());
      if (local_response_sent_) {
        // The filter called sendLocalReply: stop processing filters and return
        // FilterStatus::Continue irrespective of the current result.
        break;
      }

      if (status != FilterStatus::Continue) {
        return status;
      }
    }
  }

  filter_action_ = nullptr;
  filter_context_.reset();

  return FilterStatus::Continue;
}

FilterStatus ConnectionManager::ActiveTrans::transportBegin(MessageMetadataSharedPtr metadata) {
  if (local_response_sent_) {
    ENVOY_LOG(debug, "Message after local 503 message, return directly");
    return FilterStatus::StopIteration;
  }

  metadata_ = metadata;
  filter_context_ = metadata;
  filter_action_ = [this](DecoderEventHandler* filter) -> FilterStatus {
    MessageMetadataSharedPtr metadata = absl::any_cast<MessageMetadataSharedPtr>(filter_context_);
    return filter->transportBegin(metadata);
  };

  return applyDecoderFilters(nullptr);
}

FilterStatus ConnectionManager::ActiveTrans::transportEnd() {
  ASSERT(metadata_ != nullptr);
  parent_.stats_.request_.inc();

  FilterStatus status;
  filter_action_ = [](DecoderEventHandler* filter) -> FilterStatus {
    return filter->transportEnd();
  };

  status = applyDecoderFilters(nullptr);
  if (status == FilterStatus::StopIteration) {
    return status;
  }

  finalizeRequest();

  return status;
}

void ConnectionManager::ActiveTrans::finalizeRequest() {}

FilterStatus ConnectionManager::ActiveTrans::messageBegin(MessageMetadataSharedPtr metadata) {
  filter_context_ = metadata;
  filter_action_ = [this](DecoderEventHandler* filter) -> FilterStatus {
    MessageMetadataSharedPtr metadata = absl::any_cast<MessageMetadataSharedPtr>(filter_context_);
    return filter->messageBegin(metadata);
  };

  return applyDecoderFilters(nullptr);
}

FilterStatus ConnectionManager::ActiveTrans::messageEnd() {
  filter_action_ = [](DecoderEventHandler* filter) -> FilterStatus { return filter->messageEnd(); };
  return applyDecoderFilters(nullptr);
}

void ConnectionManager::ActiveTrans::createFilterChain() {
  parent_.config_.filterFactory().createFilterChain(*this);
}

void ConnectionManager::ActiveTrans::onReset() { parent_.doDeferredTransDestroy(*this); }

void ConnectionManager::ActiveTrans::onError(const std::string& what) {
  if (metadata_) {
    sendLocalReply(AppException(AppExceptionType::ProtocolError, what), false);
    return;
  }

  parent_.doDeferredTransDestroy(*this);
  parent_.read_callbacks_->connection().close(Network::ConnectionCloseType::NoFlush);
}

const Network::Connection* ConnectionManager::ActiveTrans::connection() const {
  return &parent_.read_callbacks_->connection();
}

Router::RouteConstSharedPtr ConnectionManager::ActiveTrans::route() {
  if (!cached_route_) {
    if (metadata_ != nullptr) {
      Router::RouteConstSharedPtr route = parent_.config_.routerConfig().route(*metadata_);
      cached_route_ = std::move(route);
    } else {
      cached_route_ = nullptr;
    }
  }

  return cached_route_.value();
}

void ConnectionManager::ActiveTrans::sendLocalReply(const DirectResponse& response,
                                                    bool end_stream) {
  parent_.sendLocalReply(*metadata_, response, end_stream);

  if (end_stream) {
    return;
  }

  // Consume any remaining request data from the downstream.
  local_response_sent_ = true;
}

void ConnectionManager::ActiveTrans::startUpstreamResponse() {
  response_decoder_ = std::make_unique<ResponseDecoder>(*this);
}

SipFilters::ResponseStatus
ConnectionManager::ActiveTrans::upstreamData(MessageMetadataSharedPtr metadata) {
  ASSERT(response_decoder_ != nullptr);

  try {
    if (response_decoder_->onData(metadata)) {
      // Completed upstream response.
      // parent_.doDeferredRpcDestroy(*this);
      return SipFilters::ResponseStatus::Complete;
    }
    return SipFilters::ResponseStatus::MoreData;
  } catch (const AppException& ex) {
    ENVOY_LOG(error, "sip response application error: {}", ex.what());

    sendLocalReply(ex, false);
    return SipFilters::ResponseStatus::Reset;
  } catch (const EnvoyException& ex) {
    ENVOY_CONN_LOG(error, "sip response error: {}", parent_.read_callbacks_->connection(),
                   ex.what());

    onError(ex.what());
    return SipFilters::ResponseStatus::Reset;
  }
}

void ConnectionManager::ActiveTrans::resetDownstreamConnection() {
  parent_.read_callbacks_->connection().close(Network::ConnectionCloseType::NoFlush);
}

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/sip_proxy/filters/network/source/metadata.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

std::vector<std::string> methodStr{"INVITE", "REGISTER", "UPDATE", "REFER", "SUBSCRIBE", "NOTIFY",
                                   "ACK",    "BYE",      "CANCEL", "OK",    "FAILURE",   "NULL"};

void SipHeader::parseHeader() {
  if (!params_.empty()) {
    // Already parsed
    return;
  }

  std::size_t pos = 0;
  absl::string_view& header = raw_text_;
  bool isHost = true;

  // Has "SIP/2.0" in top line
  // Eg: INVITE sip:User.0000@tas01.defult.svc.cluster.local SIP/2.0
  if (std::size_t found = header.find(" SIP"); found != absl::string_view::npos) {
    header = header.substr(0, found);
  }
  // Has message Type in header
  // Eg: Route: <sip:test@cncs.svc.cluster.local;role=anch;lr;transport=udp>
  if (std::size_t found = header.find(": "); found != absl::string_view::npos) {
    header = header.substr(found + 2);
  }
  if (std::size_t found = header.find('<'); found != absl::string_view::npos) {
    header = header.substr(found + 1);
  }

  while (std::size_t found = header.find_first_of(";>", pos)) {
    absl::string_view str;
    if (found == absl::string_view::npos) {
      str = header.substr(pos);
    } else {
      str = header.substr(pos, found - pos);
    }

    std::size_t value_pos = str.find('=');
    if (value_pos == absl::string_view::npos) {
      // First as host
      if (isHost) {
        if (str.find("sip:") != absl::string_view::npos) {
          str = str.substr(std::strlen("sip:"));
        }

        if (!str.empty()) {
          std::size_t at = str.find('@');
          if (at != absl::string_view::npos) {
            str = str.substr(at + 1);
          }
        }

        if (!str.empty()) {
          std::size_t comma = str.find(':');
          if (comma != absl::string_view::npos) {
            str = str.substr(0, comma);
          }
        }
        params_.emplace_back(std::make_pair("host", str));
        isHost = false;
      }
    } else {
      auto param = str.substr(0, value_pos);
      value_pos += 1;
      auto value = str.substr(value_pos);
      if (!param.empty() && !value.empty()) {
        if (value.find("sip:") != absl::string_view::npos) {
          value = value.substr(std::strlen("sip:"));
        }

        if (!value.empty()) {
          std::size_t comma = value.find(':');
          if (comma != absl::string_view::npos) {
            value = value.substr(0, comma);
          }
        }

        if (!value.empty()) {
          if (param == "opaque") {
            auto value_view = header.substr(header.find(value), value.length());
            params_.emplace_back(std::make_pair("ep", value_view));
          } else {
            auto param_view = header.substr(header.find(param), param.length());
            auto value_view = header.substr(header.find(value), value.length());
            params_.emplace_back(std::make_pair(param_view, value_view));
          }
        }
      }
    }

    if (found == absl::string_view::npos) {
      break;
    }
    pos = found + 1;
  }
}

// input is the full SIP header
void MessageMetadata::setTransactionId(absl::string_view data) {
  auto start_index = data.find("branch=");
  if (start_index == absl::string_view::npos) {
    return;
  }
  start_index += strlen("branch=");

  auto end_index = data.find_first_of(" ,;>", start_index);
  if (end_index == absl::string_view::npos) {
    end_index = data.size();
  }
  transaction_id_ = data.substr(start_index, end_index - start_index);
}

void MessageMetadata::addEPOperation(
    size_t raw_offset, absl::string_view& header, HeaderType type,
    const std::vector<envoy::extensions::filters::network::sip_proxy::v3alpha::LocalService>&
        local_services) {
  if (header.find(";ep=") != absl::string_view::npos) {
    // already have ep
    return;
  }

  auto pos = header.find('>');
  if (pos == absl::string_view::npos) {
    // no url
    return;
  }

  // is domain matched
  if (!isDomainMatched(type, local_services)) {
    ENVOY_LOG(trace, "header {} domain is not equal to local_services domain, don't add EP.",
              header);
    return;
  }

  ENVOY_LOG(trace, "header {} domain is equal to local_services domain, add EP.", header);

  setOperation(Operation(OperationType::Insert, raw_offset + pos, InsertOperationValue(";ep=")));
}

void MessageMetadata::addOpaqueOperation(size_t raw_offset, absl::string_view& header) {
  if (header.find(",opaque=") != absl::string_view::npos) {
    // already has opaque
    return;
  }
  auto pos = header.length();
  setOperation(
      Operation(OperationType::Insert, raw_offset + pos, InsertOperationValue(",opaque=")));
}

void MessageMetadata::deleteInstipOperation(size_t raw_offset, absl::string_view& header) {
  // Delete inst-ip and remove "sip:" in x-suri
  if (auto pos = header.find(";inst-ip="); pos != absl::string_view::npos) {
    setOperation(
        Operation(OperationType::Delete, raw_offset + pos,
                  DeleteOperationValue(
                      header.substr(pos, header.find_first_of(";>", pos + 1) - pos).size())));
    auto xsuri = header.find("x-suri=sip:");
    if (xsuri != absl::string_view::npos) {
      setOperation(Operation(OperationType::Delete, raw_offset + xsuri + strlen("x-suri="),
                             DeleteOperationValue(4)));
    }
  }
}

void MessageMetadata::addMsgHeader(HeaderType type, absl::string_view value) {
  switch (type) {
  case HeaderType::TopLine:
    headers_[type].emplace_back(SipHeader(type, value));
    break;
  case HeaderType::Other:
    // TODO
    break;
  default:
    if (type <= HeaderType::TopLine || type >= HeaderType::Other) {
      ENVOY_LOG(error, "Wrong HeaderType {}, should be in [{},{}]", type, HeaderType::TopLine,
                HeaderType::Other);
      return;
    }
    headers_[type].emplace_back(SipHeader(type, value));
  }
}

absl::string_view MessageMetadata::getDomainFromHeaderParameter(HeaderType type,
                                                                const std::string& parameter) {
  parseHeader(type);
  if ((parameter.empty() || !header(type).hasParam(parameter)) && header(type).hasParam("host")) {
    return header(type).param("host");
  }
  if (header(type).hasParam(parameter)) {
    return header(type).param(parameter);
  }
  return "";
}

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/sip_proxy/filters/network/source/config.h"

#include "contrib/envoy/extensions/filters/network/sip_proxy/router/v3alpha/router.pb.h"
#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.h"
#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.pb.validate.h"
#include "contrib/sip_proxy/filters/network/source/decoder.h"
#include "contrib/sip_proxy/filters/network/source/filters/filter_config.h"
#include "contrib/sip_proxy/filters/network/source/filters/well_known_names.h"
#include "contrib/sip_proxy/filters/network/source/router/router_impl.h"
#include "contrib/sip_proxy/filters/network/source/stats.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {

namespace {
inline void
addUniqueClusters(absl::flat_hash_set<std::string>& clusters,
                  const envoy::extensions::filters::network::sip_proxy::v3alpha::Route& route) {
  clusters.emplace(route.route().cluster());
}
} // namespace

ProtocolOptionsConfigImpl::ProtocolOptionsConfigImpl(
    const envoy::extensions::filters::network::sip_proxy::v3alpha::SipProtocolOptions& config)
    : session_affinity_(config.session_affinity()),
      registration_affinity_(config.registration_affinity()),
      customized_affinity_(config.customized_affinity()) {}

bool ProtocolOptionsConfigImpl::sessionAffinity() const { return session_affinity_; }
bool ProtocolOptionsConfigImpl::registrationAffinity() const { return registration_affinity_; }
const envoy::extensions::filters::network::sip_proxy::v3alpha::CustomizedAffinity&
ProtocolOptionsConfigImpl::customizedAffinity() const {
  return customized_affinity_;
}

Network::FilterFactoryCb SipProxyFilterConfigFactory::createFilterFactoryFromProtoTyped(
    const envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy& proto_config,
    Server::Configuration::FactoryContext& context) {
  std::shared_ptr<Config> filter_config(new ConfigImpl(proto_config, context));

  absl::flat_hash_set<std::string> unique_clusters;
  for (auto& route : proto_config.route_config().routes()) {
    addUniqueClusters(unique_clusters, route);
  }

  /**
   * ConnPool::InstanceImpl contains ThreadLocalObject ThreadLocalPool which only can be
   * instantiated on main thread. so construct ConnPool::InstanceImpl here.
   */
  auto transaction_infos = std::make_shared<Router::TransactionInfos>();
  for (auto& cluster : unique_clusters) {
    Stats::ScopeSharedPtr stats_scope =
        context.scope().createScope(fmt::format("cluster.{}.sip_cluster", cluster));
    auto transaction_info_ptr = std::make_shared<Router::TransactionInfo>(
        cluster, context.serverFactoryContext().threadLocal(),
        static_cast<std::chrono::milliseconds>(
            PROTOBUF_GET_MS_OR_DEFAULT(proto_config.settings(), transaction_timeout, 32000)));
    transaction_info_ptr->init();
    transaction_infos->emplace(cluster, transaction_info_ptr);
  }

  return
      [filter_config, &context, transaction_infos](Network::FilterManager& filter_manager) -> void {
        filter_manager.addReadFilter(std::make_shared<ConnectionManager>(
            *filter_config, context.serverFactoryContext().api().randomGenerator(),
            context.serverFactoryContext().mainThreadDispatcher().timeSource(), context,
            transaction_infos));
      };
}

/**
 * Static registration for the sip filter. @see RegisterFactory.
 */
REGISTER_FACTORY(SipProxyFilterConfigFactory,
                 Server::Configuration::NamedNetworkFilterConfigFactory);

ConfigImpl::ConfigImpl(
    const envoy::extensions::filters::network::sip_proxy::v3alpha::SipProxy& config,
    Server::Configuration::FactoryContext& context)
    : context_(context), stats_prefix_(fmt::format("sip.{}.", config.stat_prefix())),
      stats_(SipFilterStats::generateStats(stats_prefix_, context_.scope())),
      route_matcher_(new Router::RouteMatcher(config.route_config())),
      settings_(std::make_shared<SipSettings>(
          static_cast<std::chrono::milliseconds>(
              PROTOBUF_GET_MS_OR_DEFAULT(config.settings(), transaction_timeout, 32000)),
          config.settings().local_services(), config.settings().tra_service_config(),
          config.settings().operate_via())) {

  if (config.sip_filters().empty()) {
    ENVOY_LOG(debug, "using default router filter");

    envoy::extensions::filters::network::sip_proxy::v3alpha::SipFilter router;
    envoy::extensions::filters::network::sip_proxy::router::v3alpha::Router default_router;
    router.set_name(SipFilters::SipFilterNames::get().ROUTER);
    router.mutable_typed_config()->PackFrom(default_router);
    processFilter(router);
  } else {
    for (const auto& filter : config.sip_filters()) {
      processFilter(filter);
    }
  }
}

void ConfigImpl::createFilterChain(SipFilters::FilterChainFactoryCallbacks& callbacks) {
  for (const SipFilters::FilterFactoryCb& factory : filter_factories_) {
    factory(callbacks);
  }
}

void ConfigImpl::processFilter(
    const envoy::extensions::filters::network::sip_proxy::v3alpha::SipFilter& proto_config) {
  const std::string& string_name = proto_config.name();

  ENVOY_LOG(debug, "    sip filter #{}", filter_factories_.size());
  ENVOY_LOG(debug, "      name: {}", string_name);
  ENVOY_LOG(debug, "    config: {}",
            MessageUtil::getJsonStringFromMessageOrError(
                static_cast<const Protobuf::Message&>(proto_config.typed_config())));
  auto& factory =
      Envoy::Config::Utility::getAndCheckFactory<SipFilters::NamedSipFilterConfigFactory>(
          proto_config);

  ProtobufTypes::MessagePtr message = Envoy::Config::Utility::translateAnyToFactoryConfig(
      proto_config.typed_config(), context_.messageValidationVisitor(), factory);
  SipFilters::FilterFactoryCb callback =
      factory.createFilterFactoryFromProto(*message, stats_prefix_, context_);

  filter_factories_.push_back(callback);
}

} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/sip_proxy/filters/network/source/router/router_impl.h"

#include "envoy/upstream/cluster_manager.h"

#include "source/common/common/logger.h"
#include "source/common/common/utility.h"
#include "source/common/network/address_impl.h"
#include "source/common/router/metadatamatchcriteria_impl.h"
#include "source/common/tracing/http_tracer_impl.h"

#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/route.pb.h"
#include "contrib/sip_proxy/filters/network/source/app_exception_impl.h"
#include "contrib/sip_proxy/filters/network/source/conn_manager.h"
#include "contrib/sip_proxy/filters/network/source/encoder.h"
#include "contrib/sip_proxy/filters/network/source/filters/well_known_names.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace Router {

RouteEntryImplBase::RouteEntryImplBase(
    const envoy::extensions::filters::network::sip_proxy::v3alpha::Route& route)
    : cluster_name_(route.route().cluster()) {}

const std::string& RouteEntryImplBase::clusterName() const { return cluster_name_; }

const RouteEntry* RouteEntryImplBase::routeEntry() const { return this; }

RouteConstSharedPtr RouteEntryImplBase::clusterEntry(const MessageMetadata& metadata) const {
  UNREFERENCED_PARAMETER(metadata);
  return shared_from_this();
}

GeneralRouteEntryImpl::GeneralRouteEntryImpl(
    const envoy::extensions::filters::network::sip_proxy::v3alpha::Route& route)
    : RouteEntryImplBase(route), domain_(route.match().domain()), header_(route.match().header()),
      parameter_(route.match().parameter()) {}

RouteConstSharedPtr GeneralRouteEntryImpl::matches(MessageMetadata& metadata) const {
  absl::string_view header = "";
  // Default is route
  HeaderType type = HeaderType::Route;

  if (domain_.empty()) {
    return nullptr;
  }

  type = Envoy::Extensions::NetworkFilters::SipProxy::HeaderTypes::get().str2Header(header_);

  if (type == HeaderType::Other) {
    // Default is Route
    type = HeaderType::Route;
  }

  header = metadata.header(type).text();
  if (header.empty()) {
    if (type == HeaderType::Route) {
      if (metadata.header(HeaderType::TopLine).empty()) {
        ENVOY_LOG(error, "No route and r-uri");
        return nullptr;
      }
      header = metadata.header(HeaderType::TopLine).text();
      ENVOY_LOG(debug, "No route, r-uri {} is used ", header);
      type = HeaderType::TopLine;
    } else {
      ENVOY_LOG(debug, "header {} is empty", header_);
      return nullptr;
    }
  }

  if (domain_ == "*") {
    ENVOY_LOG(trace, "Route matched with domain: {}", domain_);
    return clusterEntry(metadata);
  }

  auto domain = metadata.getDomainFromHeaderParameter(type, parameter_);

  if (domain_ == domain) {
    ENVOY_LOG(trace, "Route matched with header: {}, parameter: {} and domain: {}", header_,
              parameter_, domain_);
    return clusterEntry(metadata);
  }

  return nullptr;
}

RouteMatcher::RouteMatcher(
    const envoy::extensions::filters::network::sip_proxy::v3alpha::RouteConfiguration& config) {
  using envoy::extensions::filters::network::sip_proxy::v3alpha::RouteMatch;

  for (const auto& route : config.routes()) {
    switch (route.match().match_specifier_case()) {
    case RouteMatch::MatchSpecifierCase::kDomain:
      routes_.emplace_back(new GeneralRouteEntryImpl(route));
      break;
    default:
      PANIC("not reached");
    }
  }
}

RouteConstSharedPtr RouteMatcher::route(MessageMetadata& metadata) const {
  for (const auto& route : routes_) {
    RouteConstSharedPtr route_entry = route->matches(metadata);
    if (nullptr != route_entry) {
      return route_entry;
    }
  }

  return nullptr;
}

void Router::onDestroy() {
  if (!callbacks_->transactionId().empty()) {
    for (auto& kv : *transaction_infos_) {
      auto transaction_info = kv.second;
      transaction_info->deleteTransaction(callbacks_->transactionId());
    }
  }

  if (upstream_request_) {
    upstream_request_->delDecoderFilterCallbacks(*callbacks_);
  }
}

void Router::setDecoderFilterCallbacks(SipFilters::DecoderFilterCallbacks& callbacks) {
  callbacks_ = &callbacks;
  transaction_infos_ = callbacks_->transactionInfos();
  settings_ = callbacks_->settings();
}

QueryStatus Router::handleCustomizedAffinity(const std::string& header, const std::string& type,
                                             const std::string& key,
                                             MessageMetadataSharedPtr metadata) {
  std::string host;
  QueryStatus ret = QueryStatus::Stop;

  auto handle_no_query = [&]() {
    auto header_type = HeaderType::Route;

    if (metadata->header(HeaderType::Route).empty()) {
      header_type = HeaderType::TopLine;
    }

    if (!header.empty()) {
      header_type = HeaderTypes::get().str2Header(header);
    }

    metadata->parseHeader(header_type);
    if (metadata->header(header_type).hasParam(type)) {
      host = std::string(metadata->header(header_type).param(type));
    }

    if (!host.empty()) {
      return QueryStatus::Continue;
    } else {
      return QueryStatus::Stop;
    }
  };

  if (type == "ep") {
    // For REGISTER, ep comes from Authorization header with opaque, and opaque is set when parse
    // Authorization
    if (metadata->methodType() == MethodType::Register && metadata->opaque().has_value()) {
      host = std::string(metadata->opaque().value());
    } else {
      // Handler other Requests except REGISTER
      ret = handle_no_query();
    }
  } else if (type == "text") {
    auto header_type = HeaderTypes::get().str2Header(header);

    ret = callbacks_->traHandler()->retrieveTrafficRoutingAssistant(
        header, std::string(metadata->header(header_type).text()), metadata->traContext(),
        *callbacks_, host);
  } else if (!(metadata->affinityIteration()->query())) {
    // query == false, eg. inst-ip=192.168.0.1, use value as host;
    // query == true, eg. lskpmc=S2F3, use value as key to query local cache or TRA.
    ret = handle_no_query();
  } else {
    ret = callbacks_->traHandler()->retrieveTrafficRoutingAssistant(
        type, key, metadata->traContext(), *callbacks_, host);
  }

  if (QueryStatus::Continue == ret) {
    metadata->setDestination(host);
    ENVOY_LOG(debug, "Set destination from local cache {} {} {} = {}", header, type, key,
              metadata->destination());
  }
  return ret;
}

FilterStatus Router::handleAffinity() {
  auto& metadata = metadata_;
  std::string host;

  // ONLY used for NOKIA P-Cookie-IP-Mapping
  if (metadata->pCookieIpMap().has_value()) {
    auto [key, val] = metadata->pCookieIpMap().value();
    ENVOY_LOG(trace, "update p-cookie-ip-map {}={}", key, val);
    callbacks_->traHandler()->updateTrafficRoutingAssistant("lskpmc", key, val, absl::nullopt);
  }

  const std::shared_ptr<const ProtocolOptionsConfig> options =
      cluster_->extensionProtocolOptionsTyped<ProtocolOptionsConfig>(
          SipFilters::SipFilterNames::get().SipProxy);

  if (options == nullptr || metadata->msgType() == MsgType::Response) {
    return FilterStatus::Continue;
  }

  // Do subscribe
  callbacks_->traHandler()->doSubscribe(options->customizedAffinity());

  if (metadata->affinity().empty()) {
    metadata->setStopLoadBalance(options->customizedAffinity().stop_load_balance());

    if (!options->customizedAffinity().entries().empty()) {
      for (const auto& aff : options->customizedAffinity().entries()) {
        // default header is Route, TOP-URI also used as Route
        HeaderType header = HeaderType::Route;
        if (!aff.header().empty()) {
          header = HeaderTypes::get().str2Header(aff.header());
          if (header == HeaderType::Other) {
            ENVOY_LOG(error, "header {} is not supported", aff.header());
            continue;
          }
        }
        auto type = aff.key_name();

        absl::string_view key = "";

        if (type == "text") {
          key = metadata->header(header).text();
        } else if (type == "ep") {
          key = "ep";
        } else {
          // If the header is Route, and the value is empty, then use the top-uri
          if ((header == HeaderType::Route) && (metadata->header(HeaderType::Route).empty())) {
            header = HeaderType::TopLine;
          }

          metadata->parseHeader(header);
          if (metadata->header(header).hasParam(type)) {
            key = metadata->header(header).param(type);
          }
        }

        if (!key.empty()) {
          metadata->affinity().emplace_back(aff.header(), type, std::string(key), aff.query(),
                                            aff.subscribe());
        }
      }
    } else if (metadata->methodType() != MethodType::Register && options->sessionAffinity()) {
      metadata->setStopLoadBalance(false);

      if (metadata->header(HeaderType::Route).empty()) {
        if (!metadata->header(HeaderType::TopLine).empty()) {
          metadata->parseHeader(HeaderType::TopLine);
          if (metadata->header(HeaderType::TopLine).hasParam("ep")) {
            metadata->affinity().emplace_back("Route", "ep", "ep", false, false);
          }
        }
      } else {
        metadata->parseHeader(HeaderType::Route);
        if (metadata->header(HeaderType::Route).hasParam("ep")) {
          metadata->affinity().emplace_back("Route", "ep", "ep", false, false);
        }
      }
    } else if (metadata->methodType() == MethodType::Register && options->registrationAffinity()) {
      metadata->setStopLoadBalance(false);

      // For REGISTER, opaque is set when parse Authorization, opaque works as same as ep
      if (metadata->opaque().has_value()) {
        metadata->affinity().emplace_back("Route", "ep", "ep", false, false);
      }
    }

    // NOTE: After constructed metadata->affinity(), must invoke
    // metadata->resetAffinityIteration() to set the iterator correctly. otherwise
    // affinityIteration can't point to the changed affinity correctly.
    metadata->resetAffinityIteration();
  }

  return FilterStatus::Continue;
}

FilterStatus Router::transportBegin(MessageMetadataSharedPtr metadata) {
  metadata_ = metadata;

  if (upstream_request_ != nullptr) {
    return FilterStatus::Continue;
  }

  metadata_ = metadata;
  route_ = callbacks_->route();
  if (!route_) {
    ENVOY_STREAM_LOG(debug, "no route matched", *callbacks_);
    stats_.route_missing_.inc();
    throw AppException(AppExceptionType::UnknownMethod, "envoy no match route found");
  }

  route_entry_ = route_->routeEntry();
  const std::string& cluster_name = route_entry_->clusterName();

  Upstream::ThreadLocalCluster* cluster = cluster_manager_.getThreadLocalCluster(cluster_name);
  if (!cluster) {
    ENVOY_STREAM_LOG(debug, "unknown cluster '{}'", *callbacks_, cluster_name);
    stats_.unknown_cluster_.inc();
    throw AppException(AppExceptionType::InternalError,
                       fmt::format("unknown cluster '{}'", cluster_name));
  }
  thread_local_cluster_ = cluster;

  cluster_ = cluster->info();
  ENVOY_STREAM_LOG(debug, "cluster '{}' matched", *callbacks_, cluster_name);

  if (cluster_->maintenanceMode()) {
    stats_.upstream_rq_maintenance_mode_.inc();
    throw AppException(AppExceptionType::InternalError,
                       fmt::format("maintenance mode for cluster '{}'", cluster_name));
  }

  handleAffinity();

  return FilterStatus::Continue;
}

FilterStatus Router::transportEnd() { return FilterStatus::Continue; }

FilterStatus
Router::messageHandlerWithLoadBalancer(std::shared_ptr<TransactionInfo> transaction_info,
                                       MessageMetadataSharedPtr metadata, std::string dest,
                                       bool& lb_ret) {
  auto conn_pool = thread_local_cluster_->tcpConnPool(Upstream::ResourcePriority::Default, this);
  if (!conn_pool) {
    stats_.no_healthy_upstream_.inc();
    if (dest.empty()) {
      throw AppException(AppExceptionType::InternalError,
                         fmt::format("envoy no healthy upstream endpoint during load balance"));
    } else {
      throw AppException(AppExceptionType::InternalError,
                         fmt::format("envoy no healthy upstream endpoint during affinity"));
    }
  }

  Upstream::HostDescriptionConstSharedPtr host = conn_pool->host();
  if (!host) {
    return FilterStatus::StopIteration;
  }

  // check the host ip is equal to dest. If false, then return StopIteration
  // if this function return StopIteration, then continue with next affinity
  if (!dest.empty() && dest != host->address()->ip()->addressAsString()) {
    ENVOY_LOG(info, "LB selected host {} is not equal to predefined dest {}",
              host->address()->ip()->addressAsString(), dest);
    return FilterStatus::StopIteration;
  }

  if (auto upstream_request =
          transaction_info->getUpstreamRequest(host->address()->ip()->addressAsString());
      upstream_request != nullptr) {
    // There is action connection, reuse it.
    upstream_request_ = upstream_request;
    upstream_request_->setDecoderFilterCallbacks(*callbacks_);
    upstream_request_->setMetadata(metadata);
    ENVOY_STREAM_LOG(debug, "reuse upstream request for {}", *callbacks_,
                     host->address()->ip()->addressAsString());

    transaction_info->insertTransaction(std::string(metadata->transactionId().value()), callbacks_,
                                        upstream_request_);
  } else {
    upstream_request_ = std::make_shared<UpstreamRequest>(
        std::make_shared<Upstream::TcpPoolData>(*conn_pool), transaction_info);
    upstream_request_->setDecoderFilterCallbacks(*callbacks_);
    upstream_request_->setMetadata(metadata);
    transaction_info->insertUpstreamRequest(host->address()->ip()->addressAsString(),
                                            upstream_request_);
    ENVOY_STREAM_LOG(debug, "create new upstream request {}", *callbacks_,
                     host->address()->ip()->addressAsString());

    transaction_info->insertTransaction(std::string(metadata->transactionId().value()), callbacks_,
                                        upstream_request_);
  }

  lb_ret = true;
  return upstream_request_->start();
}

FilterStatus Router::messageBegin(MessageMetadataSharedPtr metadata) {
  bool upstream_request_started = false;

  // ACK_4XX reuse
  if (upstream_request_ != nullptr &&
      upstream_request_->connectionState() == ConnectionState::Connected) {
    return FilterStatus::Continue;
  }

  auto& transaction_info = (*transaction_infos_)[cluster_->name()];

  if (!metadata->affinity().empty() &&
      metadata->affinityIteration() != metadata->affinity().end()) {
    std::string host;

    ENVOY_STREAM_LOG(debug, "handle affinity of header:{} type:{} key:{}", *callbacks_,
                     metadata->affinityIteration()->header(), metadata->affinityIteration()->type(),
                     metadata->affinityIteration()->key());

    if (!metadata->destination().empty()) {
      // TRA query get result, and set destintion.
      host = metadata->destination();
      ENVOY_STREAM_LOG(debug, "has already set destination {} from affinity", *callbacks_, host);
    } else {
      auto handle_ret = handleCustomizedAffinity(metadata->affinityIteration()->header(),
                                                 metadata->affinityIteration()->type(),
                                                 metadata->affinityIteration()->key(), metadata);

      if (QueryStatus::Continue == handle_ret) {
        // has already get the destination from affinity
        host = metadata->destination();
        ENVOY_STREAM_LOG(debug, "has already get destination {} from affinity", *callbacks_, host);
      } else if (QueryStatus::Pending == handle_ret) {
        ENVOY_STREAM_LOG(debug, "do remote query for {}", *callbacks_,
                         metadata->affinityIteration()->key());
        // Need to wait remote query response,
        // after response back, still back with current affinity
        metadata->setState(State::HandleAffinity);
        return FilterStatus::StopIteration;
      } else {
        ENVOY_STREAM_LOG(debug, "no existing destintion for {}", *callbacks_,
                         metadata->affinityIteration()->key());
        // Need to try next affinity
        metadata->nextAffinityIteration();
        metadata->setState(State::HandleAffinity);
        return FilterStatus::Continue;
      }
    }

    // Already get destintion for current affinity, try to get or create new connection for this
    // destination. If this destintion is invalid, try next affinity.
    if (auto upstream_request = transaction_info->getUpstreamRequest(std::string(host));
        upstream_request != nullptr) {
      // There is action connection, reuse it.
      ENVOY_STREAM_LOG(trace, "reuse upstream request from {}", *callbacks_, host);
      upstream_request_ = upstream_request;
      upstream_request_->setMetadata(metadata);
      upstream_request_->setDecoderFilterCallbacks(*callbacks_);

      transaction_info->insertTransaction(std::string(metadata->transactionId().value()),
                                          callbacks_, upstream_request_);
      ENVOY_STREAM_LOG(trace, "call upstream_request_->start()", *callbacks_);
      // Continue: continue to messageEnd, StopIteration: continue to next affinity
      if (FilterStatus::StopIteration == upstream_request_->start()) {
        // Defer to handle in upstream request onPoolReady or onPoolFailure
        ENVOY_LOG(trace, "sip: state {}", StateNameValues::name(metadata_->state()));
        return FilterStatus::StopIteration;
      }
      return FilterStatus::Continue;
    }

    ENVOY_STREAM_LOG(trace, "no destination preset select with load balancer host= {}", *callbacks_,
                     host);

    upstream_request_started = false;
    auto ret =
        messageHandlerWithLoadBalancer(transaction_info, metadata, host, upstream_request_started);
    if (upstream_request_started && ret == FilterStatus::StopIteration) {
      // Defer to handle in upstream request onPoolReady or onPoolFailure
      return FilterStatus::StopIteration;
    } else if (upstream_request_started && ret == FilterStatus::Continue) {
      return FilterStatus::Continue;
    } else {
      // continue to next affinity
      metadata->setState(State::HandleAffinity);
      ENVOY_LOG(trace, "sip: state {}", StateNameValues::name(metadata_->state()));
      metadata->nextAffinityIteration();
      return FilterStatus::Continue;
    }
  } else {
    metadata->resetDestination();
    if (!metadata->stopLoadBalance()) {
      ENVOY_STREAM_LOG(debug, "no destination from affinity, do load balance", *callbacks_);
      return messageHandlerWithLoadBalancer(transaction_info, metadata, "",
                                            upstream_request_started);
    } else {
      ENVOY_STREAM_LOG(debug, "no destination and stop load balance", *callbacks_);
      throw AppException(AppExceptionType::UnknownMethod, "envoy no endpoint found");
      return FilterStatus::StopIteration;
    }
  }
}

FilterStatus Router::messageEnd() {
  Buffer::OwnedImpl transport_buffer;

  // set EP/Opaque, used in upstream
  ENVOY_STREAM_LOG(debug, "set EP {}", *callbacks_, Utility::localAddress(context_));
  metadata_->setEP(Utility::localAddress(context_));

  std::shared_ptr<Encoder> encoder = std::make_shared<EncoderImpl>();
  encoder->encode(metadata_, transport_buffer);

  ENVOY_STREAM_LOG(debug, "send buffer : {} bytes\n{}", *callbacks_, transport_buffer.length(),
                   transport_buffer.toString());

  callbacks_->stats()
      .sipMethodCounter(metadata_->methodType(), SipMethodStatsSuffix::RequestProxied)
      .inc();
  upstream_request_->write(transport_buffer, false);
  return FilterStatus::Continue;
}

const Network::Connection* Router::downstreamConnection() const {
  if (callbacks_ != nullptr) {
    return callbacks_->connection();
  }

  return nullptr;
}

void Router::cleanup() { upstream_request_.reset(); }

UpstreamRequest::UpstreamRequest(std::shared_ptr<Upstream::TcpPoolData> pool,
                                 std::shared_ptr<TransactionInfo> transaction_info)
    : conn_pool_(pool), transaction_info_(transaction_info) {}

UpstreamRequest::~UpstreamRequest() {
  if (conn_pool_handle_) {
    conn_pool_handle_->cancel(Tcp::ConnectionPool::CancelPolicy::Default);
  }
}

FilterStatus UpstreamRequest::start() {
  if (!callbacks_) {
    ENVOY_LOG(info, "There is no callback");
    return FilterStatus::StopIteration;
  }

  if (conn_state_ == ConnectionState::Connecting) {
    callbacks_->pushIntoPendingList("connection_pending", conn_pool_->host()->address()->asString(),
                                    *callbacks_, []() {});
    return FilterStatus::StopIteration;
  } else if (conn_state_ == ConnectionState::Connected) {
    return FilterStatus::Continue;
  }

  ENVOY_LOG(trace, "start connecting {}", conn_pool_->host()->address()->asString());
  conn_state_ = ConnectionState::Connecting;

  Tcp::ConnectionPool::Cancellable* handle = conn_pool_->newConnection(*this);
  if (handle) {
    // Pause while we wait for a connection.
    conn_pool_handle_ = handle;
    callbacks_->pushIntoPendingList("connection_pending", conn_pool_->host()->address()->asString(),
                                    *callbacks_, []() {});
    return FilterStatus::StopIteration;
  }

  if (upstream_host_ == nullptr) {
    return FilterStatus::StopIteration;
  }

  return FilterStatus::Continue;
}

void UpstreamRequest::releaseConnection(const bool close) {
  if (conn_pool_handle_) {
    conn_pool_handle_->cancel(Tcp::ConnectionPool::CancelPolicy::Default);
    conn_pool_handle_ = nullptr;
  }

  conn_state_ = ConnectionState::NotConnected;

  // The event triggered by close will also release this connection so clear conn_data_ before
  // closing.
  auto conn_data = std::move(conn_data_);
  if (close && conn_data != nullptr) {
    conn_data->connection().close(Network::ConnectionCloseType::NoFlush);
  }
}

void UpstreamRequest::resetStream() { releaseConnection(true); }

void UpstreamRequest::onPoolFailure(ConnectionPool::PoolFailureReason reason, absl::string_view,
                                    Upstream::HostDescriptionConstSharedPtr host) {
  ENVOY_LOG(info, "on pool failure {} reason {}", host->address()->ip()->addressAsString(),
            static_cast<int>(reason));
  conn_state_ = ConnectionState::NotConnected;
  conn_pool_handle_ = nullptr;

  // Once onPoolFailure, this instance is invalid, can't be reused.
  transaction_info_->deleteUpstreamRequest(host->address()->ip()->addressAsString());

  if (callbacks_) {
    callbacks_->continueHandling(host->address()->asString(), true);
  }

  // Mimic an upstream reset.
  onUpstreamHostSelected(host);
}

void UpstreamRequest::onPoolReady(Tcp::ConnectionPool::ConnectionDataPtr&& conn_data,
                                  Upstream::HostDescriptionConstSharedPtr host) {

  ENVOY_LOG(trace, "onPoolReady");
  bool continue_handling = conn_pool_handle_ != nullptr;

  conn_data_ = std::move(conn_data);

  onUpstreamHostSelected(host);
  conn_data_->addUpstreamCallbacks(*this);
  conn_pool_handle_ = nullptr;

  setConnectionState(ConnectionState::Connected);

  if (continue_handling) {
    if (callbacks_) {
      callbacks_->continueHandling(host->address()->asString(), false);
    }
  }
}

void UpstreamRequest::onUpstreamHostSelected(Upstream::HostDescriptionConstSharedPtr host) {
  upstream_host_ = host;
}

void UpstreamRequest::onResetStream(ConnectionPool::PoolFailureReason reason) {
  switch (reason) {
  case ConnectionPool::PoolFailureReason::Overflow:
    throw AppException(AppExceptionType::InternalError,
                       "sip upstream request: too many connections");
    break;
  case ConnectionPool::PoolFailureReason::LocalConnectionFailure:
    // Should only happen if we closed the connection, due to an error condition, in which case
    // we've already handled any possible downstream response.
    // callbacks_->resetDownstreamConnection();
    break;
  case ConnectionPool::PoolFailureReason::RemoteConnectionFailure:
  case ConnectionPool::PoolFailureReason::Timeout:
    // TODO(zuercher): distinguish between these cases where appropriate (particularly timeout)
    // if (!response_started_) {
    //  callbacks_->sendLocalReply(
    //      AppException(
    //          AppExceptionType::InternalError,
    //          fmt::format("connection failure '{}'", (upstream_host_ != nullptr)
    //                                                     ? upstream_host_->address()->asString()
    //                                                     : "to upstream")),
    //      true);
    //  return;
    //}

    // Error occurred after a partial response, propagate the reset to the downstream.
    // callbacks_->resetDownstreamConnection();
    break;
  default:
    PANIC("not reached");
  }
}

SipFilters::DecoderFilterCallbacks* UpstreamRequest::getTransaction(std::string&& transaction_id) {
  if (transaction_info_->hasTransaction(transaction_id)) {
    return transaction_info_->getTransaction(std::move(transaction_id)).activeTrans();
  } else {
    return nullptr;
  }
}

// Tcp::ConnectionPool::UpstreamCallbacks
void UpstreamRequest::onUpstreamData(Buffer::Instance& data, bool end_stream) {
  UNREFERENCED_PARAMETER(end_stream);
  ENVOY_LOG(debug, "sip proxy received resp {} --> {} bytes {}",
            conn_data_->connection().connectionInfoProvider().remoteAddress()->asStringView(),
            conn_data_->connection().connectionInfoProvider().localAddress()->asStringView(),
            data.length());

  upstream_buffer_.move(data);
  auto response_decoder = std::make_unique<ResponseDecoder>(*this);
  response_decoder->onData(upstream_buffer_);
}

void UpstreamRequest::onEvent(Network::ConnectionEvent event) {
  ENVOY_LOG(info, "received upstream event {}", static_cast<int>(event));
  switch (event) {
  case Network::ConnectionEvent::RemoteClose:
    ENVOY_LOG(debug, "upstream remote close");
    break;
  case Network::ConnectionEvent::LocalClose:
    ENVOY_LOG(debug, "upstream local close");
    break;
  default:
    // Connected and ConnectedZeroRtt is consumed by the connection pool.
    return;
  }

  transaction_info_->deleteUpstreamRequest(upstream_host_->address()->ip()->addressAsString());
  releaseConnection(false);
}

void UpstreamRequest::setDecoderFilterCallbacks(SipFilters::DecoderFilterCallbacks& callbacks) {
  callbacks_ = &callbacks;
}

void UpstreamRequest::delDecoderFilterCallbacks(SipFilters::DecoderFilterCallbacks& callbacks) {
  if (callbacks_ == &callbacks) {
    callbacks_ = nullptr;
  }
}

bool ResponseDecoder::onData(Buffer::Instance& data) {
  decoder_->onData(data);
  return true;
}

FilterStatus ResponseDecoder::transportBegin(MessageMetadataSharedPtr metadata) {
  ENVOY_LOG(trace, "ResponseDecoder\n{}", metadata->rawMsg());
  if (metadata->transactionId().has_value()) {
    auto transaction_id = metadata->transactionId().value();

    auto active_trans = parent_.getTransaction(std::string(transaction_id));
    if (active_trans) {
      // ONLY used for NOKIA P-Cookie-IP-Mapping
      if (metadata->pCookieIpMap().has_value()) {
        auto [key, val] = metadata->pCookieIpMap().value();
        ENVOY_LOG(trace, "update p-cookie-ip-map {}={}", key, val);
        active_trans->traHandler()->updateTrafficRoutingAssistant("lskpmc", key, val,
                                                                  absl::nullopt);
      }

      active_trans->startUpstreamResponse();
      active_trans->upstreamData(metadata);
    } else {
      ENVOY_LOG(debug, "no active trans selected {}\n{}", transaction_id, metadata->rawMsg());
      return FilterStatus::StopIteration;
    }
  } else {
    ENVOY_LOG(debug, "no active trans selected \n{}", metadata->rawMsg());
    return FilterStatus::StopIteration;
  }

  return FilterStatus::Continue;
}

DecoderEventHandler& ResponseDecoder::newDecoderEventHandler(MessageMetadataSharedPtr metadata) {
  parent_.decoderFilterCallbacks()
      .stats()
      .sipMethodCounter(metadata->methodType(), SipMethodStatsSuffix::ResponseReceived)
      .inc();
  return *this;
}

std::shared_ptr<SipSettings> ResponseDecoder::settings() const { return parent_.settings(); }

} // namespace Router
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "contrib/envoy/extensions/filters/network/sip_proxy/router/v3alpha/router.pb.h"
#include "contrib/envoy/extensions/filters/network/sip_proxy/router/v3alpha/router.pb.validate.h"
#include "contrib/sip_proxy/filters/network/source/filters/factory_base.h"
#include "contrib/sip_proxy/filters/network/source/filters/well_known_names.h"
#include "contrib/sip_proxy/filters/network/source/router/router.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace Router {

class RouterFilterConfigImpl : public RouterFilterConfig {
public:
  RouterFilterConfigImpl(
      const envoy::extensions::filters::network::sip_proxy::router::v3alpha::Router& config,
      const std::string& stat_prefix, Server::Configuration::FactoryContext& context)
      : stats_(generateStats(stat_prefix, context.scope())) {
    UNREFERENCED_PARAMETER(config);
  }

  RouterStats& stats() override { return stats_; }

  static RouterStats generateStats(const std::string& prefix, Stats::Scope& scope) {
    return RouterStats{ALL_SIP_ROUTER_STATS(POOL_COUNTER_PREFIX(scope, prefix),
                                            POOL_GAUGE_PREFIX(scope, prefix),
                                            POOL_HISTOGRAM_PREFIX(scope, prefix))};
  }

private:
  RouterStats stats_;
};

class RouterFilterConfigFactory
    : public SipFilters::FactoryBase<
          envoy::extensions::filters::network::sip_proxy::router::v3alpha::Router> {
public:
  RouterFilterConfigFactory() : FactoryBase(SipFilters::SipFilterNames::get().ROUTER) {}

private:
  SipFilters::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoy::extensions::filters::network::sip_proxy::router::v3alpha::Router& proto_config,
      const std::string& stat_prefix, Server::Configuration::FactoryContext& context) override;
};

} // namespace Router
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_contrib_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    deps = [
        ":router_interface",
        ":router_lib",
        "//contrib/sip_proxy/filters/network/source/filters:factory_base_lib",
        "//contrib/sip_proxy/filters/network/source/filters:filter_config_interface",
        "//contrib/sip_proxy/filters/network/source/filters:well_known_names",
        "//envoy/registry",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/router/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "router_interface",
    hdrs = ["router.h"],
    external_deps = ["abseil_optional"],
    deps = [
        "//contrib/sip_proxy/filters/network/source:metadata_lib",
        "//envoy/router:router_interface",
    ],
)

envoy_cc_library(
    name = "router_lib",
    srcs = ["router_impl.cc"],
    hdrs = ["router_impl.h"],
    deps = [
        ":router_interface",
        "//contrib/sip_proxy/filters/network/source:app_exception_lib",
        "//contrib/sip_proxy/filters/network/source:conn_manager_lib",
        "//contrib/sip_proxy/filters/network/source:conn_state_lib",
        "//contrib/sip_proxy/filters/network/source:decoder_lib",
        "//contrib/sip_proxy/filters/network/source:encoder_lib",
        "//contrib/sip_proxy/filters/network/source:utility_interface",
        "//contrib/sip_proxy/filters/network/source/filters:factory_base_lib",
        "//contrib/sip_proxy/filters/network/source/filters:filter_interface",
        "//contrib/sip_proxy/filters/network/source/filters:well_known_names",
        "//contrib/sip_proxy/filters/network/source/tra:tra_lib",
        "//envoy/tcp:conn_pool_interface",
        "//envoy/upstream:cluster_manager_interface",
        "//envoy/upstream:load_balancer_interface",
        "//envoy/upstream:thread_local_cluster_interface",
        "//source/common/common:logger_lib",
        "//source/common/http:header_utility_lib",
        "//source/common/router:metadatamatchcriteria_lib",
        "//source/common/upstream:load_balancer_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/tra/v3alpha:pkg_cc_proto",
        "@envoy_api//contrib/envoy/extensions/filters/network/sip_proxy/v3alpha:pkg_cc_proto",
    ],
)
#pragma once

#include "envoy/router/router.h"
#include "envoy/stats/scope.h"
#include "envoy/stats/stats_macros.h"
#include "envoy/tcp/conn_pool.h"
#include "envoy/thread_local/thread_local.h"
#include "envoy/upstream/load_balancer.h"
#include "envoy/upstream/thread_local_cluster.h"

#include "source/common/common/logger.h"
#include "source/common/common/macros.h"
#include "source/common/http/header_utility.h"
#include "source/common/tracing/http_tracer_impl.h"
#include "source/common/upstream/load_balancer_impl.h"

#include "contrib/envoy/extensions/filters/network/sip_proxy/tra/v3alpha/tra.pb.h"
#include "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/route.pb.h"
#include "contrib/sip_proxy/filters/network/source/conn_state.h"
#include "contrib/sip_proxy/filters/network/source/decoder.h"
#include "contrib/sip_proxy/filters/network/source/decoder_events.h"
#include "contrib/sip_proxy/filters/network/source/filters/factory_base.h"
#include "contrib/sip_proxy/filters/network/source/filters/filter.h"
#include "contrib/sip_proxy/filters/network/source/router/router.h"
#include "contrib/sip_proxy/filters/network/source/utility.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace Router {

class RouteEntryImplBase : public RouteEntry,
                           public Route,
                           public std::enable_shared_from_this<RouteEntryImplBase>,
                           public Logger::Loggable<Logger::Id::filter> {
public:
  RouteEntryImplBase(const envoy::extensions::filters::network::sip_proxy::v3alpha::Route& route);

  // Router::RouteEntry
  const std::string& clusterName() const override;
  const Envoy::Router::MetadataMatchCriteria* metadataMatchCriteria() const override {
    return metadata_match_criteria_.get();
  }

  // Router::Route
  const RouteEntry* routeEntry() const override;

  virtual RouteConstSharedPtr matches(MessageMetadata& metadata) const PURE;

protected:
  RouteConstSharedPtr clusterEntry(const MessageMetadata& metadata) const;
  bool headersMatch(const Http::HeaderMap& headers) const;

private:
  const std::string cluster_name_;
  Envoy::Router::MetadataMatchCriteriaConstPtr metadata_match_criteria_;
};

using RouteEntryImplBaseConstSharedPtr = std::shared_ptr<const RouteEntryImplBase>;

// match domain from route header or request_uri, this is the more general way
class GeneralRouteEntryImpl : public RouteEntryImplBase {
public:
  GeneralRouteEntryImpl(
      const envoy::extensions::filters::network::sip_proxy::v3alpha::Route& route);

  // RouteEntryImplBase
  RouteConstSharedPtr matches(MessageMetadata& metadata) const override;

private:
  const std::string domain_;
  const std::string header_;
  const std::string parameter_;
};

class RouteMatcher : public Logger::Loggable<Logger::Id::filter> {
public:
  RouteMatcher(const envoy::extensions::filters::network::sip_proxy::v3alpha::RouteConfiguration&);

  RouteConstSharedPtr route(MessageMetadata& metadata) const;

private:
  std::vector<RouteEntryImplBaseConstSharedPtr> routes_;
};

class UpstreamRequest;
class TransactionInfoItem : public Logger::Loggable<Logger::Id::filter> {
public:
  TransactionInfoItem(SipFilters::DecoderFilterCallbacks* active_trans,
                      std::shared_ptr<UpstreamRequest> upstream_request)
      : active_trans_(active_trans), upstream_request_(upstream_request) {}

  ~TransactionInfoItem() = default;

  void resetTrans() { active_trans_->onReset(); }

  void appendMessageList(std::shared_ptr<MessageMetadata> message) { messages_.push_back(message); }

  SipFilters::DecoderFilterCallbacks* activeTrans() const { return active_trans_; }
  std::shared_ptr<UpstreamRequest> upstreamRequest() const { return upstream_request_; }

  SystemTime timestamp() const { return this->active_trans_->streamInfo().startTime(); }
  void toDelete() { deleted_ = true; }
  bool deleted() { return deleted_; }

private:
  std::list<std::shared_ptr<MessageMetadata>> messages_;
  SipFilters::DecoderFilterCallbacks* active_trans_;
  std::shared_ptr<UpstreamRequest> upstream_request_;
  std::chrono::system_clock::time_point timestamp_;
  bool deleted_{false};
};

struct ThreadLocalTransactionInfo : public ThreadLocal::ThreadLocalObject,
                                    public Logger::Loggable<Logger::Id::filter> {
  ThreadLocalTransactionInfo(std::shared_ptr<TransactionInfo> parent, Event::Dispatcher& dispatcher,
                             std::chrono::milliseconds transaction_timeout)
      : parent_(parent), dispatcher_(dispatcher), transaction_timeout_(transaction_timeout) {
    audit_timer_ = dispatcher.createTimer([this]() -> void { auditTimerAction(); });
    audit_timer_->enableTimer(std::chrono::seconds(2));
  }
  absl::flat_hash_map<std::string, std::shared_ptr<TransactionInfoItem>> transaction_info_map_{};
  absl::flat_hash_map<std::string, std::shared_ptr<UpstreamRequest>> upstream_request_map_{};

  std::shared_ptr<TransactionInfo> parent_;
  Event::Dispatcher& dispatcher_;
  Event::TimerPtr audit_timer_;
  std::chrono::milliseconds transaction_timeout_;

  void auditTimerAction() {
    const auto p1 = dispatcher_.timeSource().systemTime();
    for (auto it = transaction_info_map_.cbegin(); it != transaction_info_map_.cend();) {
      if (it->second->deleted()) {
        transaction_info_map_.erase(it++);
        continue;
      }

      auto diff =
          std::chrono::duration_cast<std::chrono::milliseconds>(p1 - it->second->timestamp());
      if (diff.count() >= transaction_timeout_.count()) {
        it->second->resetTrans();
        // transaction_info_map_.erase(it++);
      }

      ++it;
      // In single thread, this condition should be cover in line 160
      // And Envoy should be single thread
      // if (it->second->deleted()) {
      //   transaction_info_map_.erase(it++);
      // } else {
      //   ++it;
      // }
    }
    audit_timer_->enableTimer(std::chrono::seconds(2));
  }
};

class TransactionInfo : public std::enable_shared_from_this<TransactionInfo>,
                        Logger::Loggable<Logger::Id::connection> {
public:
  TransactionInfo(const std::string& cluster_name, ThreadLocal::SlotAllocator& tls,
                  std::chrono::milliseconds transaction_timeout)
      : cluster_name_(cluster_name), tls_(tls.allocateSlot()),
        transaction_timeout_(transaction_timeout) {}

  void init() {
    // Note: `this` and `cluster_name` have a a lifetime of the filter.
    // That may be shorter than the tls callback if the listener is torn down shortly after it is
    // created. We use a weak pointer to make sure this object outlives the tls callbacks.
    std::weak_ptr<TransactionInfo> this_weak_ptr = this->shared_from_this();
    tls_->set(
        [this_weak_ptr](Event::Dispatcher& dispatcher) -> ThreadLocal::ThreadLocalObjectSharedPtr {
          if (auto this_shared_ptr = this_weak_ptr.lock()) {
            return std::make_shared<ThreadLocalTransactionInfo>(
                this_shared_ptr, dispatcher, this_shared_ptr->transaction_timeout_);
          }
          return nullptr;
        });

    (void)cluster_name_;
  }
  ~TransactionInfo() = default;

  void insertTransaction(std::string&& transaction_id,
                         SipFilters::DecoderFilterCallbacks* active_trans,
                         std::shared_ptr<UpstreamRequest> upstream_request) {
    if (hasTransaction(transaction_id)) {
      return;
    }

    tls_->getTyped<ThreadLocalTransactionInfo>().transaction_info_map_.emplace(std::make_pair(
        transaction_id, std::make_shared<TransactionInfoItem>(active_trans, upstream_request)));
  }

  void deleteTransaction(std::string&& transaction_id) {
    if (hasTransaction(transaction_id)) {
      tls_->getTyped<ThreadLocalTransactionInfo>()
          .transaction_info_map_.at(transaction_id)
          ->toDelete();
    }
  }

  bool hasTransaction(std::string& transaction_id) {
    return tls_->getTyped<ThreadLocalTransactionInfo>().transaction_info_map_.find(
               transaction_id) !=
           tls_->getTyped<ThreadLocalTransactionInfo>().transaction_info_map_.end();
  }

  TransactionInfoItem& getTransaction(std::string&& transaction_id) {
    return *(tls_->getTyped<ThreadLocalTransactionInfo>().transaction_info_map_.at(transaction_id));
  }

  void insertUpstreamRequest(const std::string& host,
                             std::shared_ptr<UpstreamRequest> upstream_request) {
    tls_->getTyped<ThreadLocalTransactionInfo>().upstream_request_map_.emplace(
        std::make_pair(host, upstream_request));
  }

  std::shared_ptr<UpstreamRequest> getUpstreamRequest(const std::string& host) {
    auto ret = tls_->getTyped<ThreadLocalTransactionInfo>().upstream_request_map_.find(host);
    if (ret != tls_->getTyped<ThreadLocalTransactionInfo>().upstream_request_map_.end()) {
      return ret->second;
    } else {
      return nullptr;
    }
  }

  void deleteUpstreamRequest(const std::string& host) {
    tls_->getTyped<ThreadLocalTransactionInfo>().upstream_request_map_.erase(host);
  }

private:
  const std::string cluster_name_;
  ThreadLocal::SlotPtr tls_;
  std::chrono::milliseconds transaction_timeout_;
};

class Router : public Upstream::LoadBalancerContextBase,
               public virtual DecoderEventHandler,
               public SipFilters::DecoderFilter,
               Logger::Loggable<Logger::Id::connection> {
public:
  Router(std::shared_ptr<RouterFilterConfig> config, Upstream::ClusterManager& cluster_manager,
         Server::Configuration::FactoryContext& context)
      : cluster_manager_(cluster_manager), stats_(config->stats()), context_(context) {}

  // SipFilters::DecoderFilter
  void onDestroy() override;
  void setDecoderFilterCallbacks(SipFilters::DecoderFilterCallbacks& callbacks) override;

  // DecoderEventHandler
  FilterStatus transportBegin(MessageMetadataSharedPtr metadata) override;
  FilterStatus transportEnd() override;
  FilterStatus messageBegin(MessageMetadataSharedPtr metadata) override;
  FilterStatus messageEnd() override;

  // Upstream::LoadBalancerContext
  const Network::Connection* downstreamConnection() const override;
  const Envoy::Router::MetadataMatchCriteria* metadataMatchCriteria() override {
    if (route_entry_) {
      return route_entry_->metadataMatchCriteria();
    }
    return nullptr;
  }

  bool shouldSelectAnotherHost(const Upstream::Host& host) override {
    if (metadata_->destination().empty()) {
      return false;
    }
    return host.address()->ip()->addressAsString() != metadata_->destination();
  }

private:
  void cleanup();
  FilterStatus handleAffinity();
  FilterStatus messageHandlerWithLoadBalancer(std::shared_ptr<TransactionInfo> transaction_info,
                                              MessageMetadataSharedPtr metadata, std::string dest,
                                              bool& lb_ret);

  QueryStatus handleCustomizedAffinity(const std::string& header, const std::string& type,
                                       const std::string& key, MessageMetadataSharedPtr metadata);

  Upstream::ClusterManager& cluster_manager_;
  RouterStats& stats_;

  RouteConstSharedPtr route_{};
  const RouteEntry* route_entry_{};
  MessageMetadataSharedPtr metadata_{};

  std::shared_ptr<UpstreamRequest> upstream_request_;
  SipFilters::DecoderFilterCallbacks* callbacks_{};
  Upstream::ClusterInfoConstSharedPtr cluster_;
  Upstream::ThreadLocalCluster* thread_local_cluster_;
  std::shared_ptr<TransactionInfos> transaction_infos_{};
  std::shared_ptr<SipSettings> settings_;
  Server::Configuration::FactoryContext& context_;
};

class ResponseDecoder : public DecoderCallbacks,
                        public DecoderEventHandler,
                        public Logger::Loggable<Logger::Id::filter> {
public:
  ResponseDecoder(UpstreamRequest& parent)
      : parent_(parent), decoder_(std::make_unique<Decoder>(*this)) {}
  ~ResponseDecoder() override = default;
  bool onData(Buffer::Instance& data);

  // DecoderEventHandler
  FilterStatus messageBegin(MessageMetadataSharedPtr metadata) override {
    UNREFERENCED_PARAMETER(metadata);
    return FilterStatus::Continue;
  }
  FilterStatus messageEnd() override { return FilterStatus::Continue; };
  FilterStatus transportBegin(MessageMetadataSharedPtr metadata) override;
  FilterStatus transportEnd() override { return FilterStatus::Continue; }

  // DecoderCallbacks
  DecoderEventHandler& newDecoderEventHandler(MessageMetadataSharedPtr metadata) override;
  std::shared_ptr<SipSettings> settings() const override;

private:
  UpstreamRequest& parent_;
  DecoderPtr decoder_;
};

using ResponseDecoderPtr = std::unique_ptr<ResponseDecoder>;

class UpstreamRequest : public Tcp::ConnectionPool::Callbacks,
                        public Tcp::ConnectionPool::UpstreamCallbacks,
                        public std::enable_shared_from_this<UpstreamRequest>,
                        public Logger::Loggable<Logger::Id::connection> {
public:
  UpstreamRequest(std::shared_ptr<Upstream::TcpPoolData> pool_data,
                  std::shared_ptr<TransactionInfo> transaction_info);
  ~UpstreamRequest() override;
  FilterStatus start();
  void resetStream();
  void releaseConnection(bool close);

  SipFilters::DecoderFilterCallbacks* getTransaction(std::string&& transaction_id);

  // Tcp::ConnectionPool::Callbacks
  void onPoolFailure(ConnectionPool::PoolFailureReason reason,
                     absl::string_view transport_failure_reason,
                     Upstream::HostDescriptionConstSharedPtr host) override;
  void onPoolReady(Tcp::ConnectionPool::ConnectionDataPtr&& conn,
                   Upstream::HostDescriptionConstSharedPtr host) override;

  void onUpstreamHostSelected(Upstream::HostDescriptionConstSharedPtr host);
  void onResetStream(ConnectionPool::PoolFailureReason reason);

  // Tcp::ConnectionPool::UpstreamCallbacks
  void onUpstreamData(Buffer::Instance& data, bool end_stream) override;
  void onEvent(Network::ConnectionEvent event) override;
  void onAboveWriteBufferHighWatermark() override {}
  void onBelowWriteBufferLowWatermark() override {}

  void setDecoderFilterCallbacks(SipFilters::DecoderFilterCallbacks& callbacks);
  void delDecoderFilterCallbacks(SipFilters::DecoderFilterCallbacks& callbacks);
  SipFilters::DecoderFilterCallbacks& decoderFilterCallbacks() { return *callbacks_; }

  ConnectionState connectionState() { return conn_state_; }
  void setConnectionState(ConnectionState state) { conn_state_ = state; }
  void write(Buffer::Instance& data, bool end_stream) {
    return conn_data_->connection().write(data, end_stream);
  }

  std::shared_ptr<TransactionInfo> transactionInfo() { return transaction_info_; }
  void setMetadata(MessageMetadataSharedPtr metadata) { metadata_ = metadata; }
  MessageMetadataSharedPtr metadata() { return metadata_; }

  std::shared_ptr<SipSettings> settings() { return callbacks_->settings(); }

private:
  std::shared_ptr<Upstream::TcpPoolData> conn_pool_;

  Tcp::ConnectionPool::Cancellable* conn_pool_handle_{};
  Tcp::ConnectionPool::ConnectionDataPtr conn_data_;
  Upstream::HostDescriptionConstSharedPtr upstream_host_;
  ConnectionState conn_state_{ConnectionState::NotConnected};

  std::shared_ptr<TransactionInfo> transaction_info_;
  SipFilters::DecoderFilterCallbacks* callbacks_{};
  MessageMetadataSharedPtr metadata_;
  Buffer::OwnedImpl upstream_buffer_;
};

} // namespace Router
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/router/router.h"

#include "contrib/sip_proxy/filters/network/source/metadata.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace Router {

class TransactionInfo;
using TransactionInfos = std::map<std::string, std::shared_ptr<TransactionInfo>>;

/**
 * RouteEntry is an individual resolved route entry.
 */
class RouteEntry {
public:
  virtual ~RouteEntry() = default;

  /**
   * @return const std::string& the upstream cluster that owns the route.
   */
  virtual const std::string& clusterName() const PURE;

  /**
   * @return MetadataMatchCriteria* the metadata that a subset load balancer should match when
   * selecting an upstream host
   */
  virtual const Envoy::Router::MetadataMatchCriteria* metadataMatchCriteria() const PURE;
};

/**
 * Route holds the RouteEntry for a request.
 */
class Route {
public:
  virtual ~Route() = default;

  /**
   * @return the route entry or nullptr if there is no matching route for the request.
   */
  virtual const RouteEntry* routeEntry() const PURE;
};

using RouteConstSharedPtr = std::shared_ptr<const Route>;

/**
 * The router configuration.
 */
class Config {
public:
  virtual ~Config() = default;

  /**
   * Based on the incoming Sip request transport and/or protocol data, determine the target
   * route for the request.
   * @param metadata MessageMetadata for the message to route
   * @param random_value uint64_t used to select cluster affinity
   * @return the route or nullptr if there is no matching route for the request.
   */
  virtual RouteConstSharedPtr route(MessageMetadata& metadata) const PURE;
};

using ConfigConstSharedPtr = std::shared_ptr<const Config>;

#define ALL_SIP_ROUTER_STATS(COUNTER, GAUGE, HISTOGRAM)                                            \
  COUNTER(route_missing)                                                                           \
  COUNTER(unknown_cluster)                                                                         \
  COUNTER(upstream_rq_maintenance_mode)                                                            \
  COUNTER(no_healthy_upstream)

struct RouterStats {
  ALL_SIP_ROUTER_STATS(GENERATE_COUNTER_STRUCT, GENERATE_GAUGE_STRUCT, GENERATE_HISTOGRAM_STRUCT)
};

/**
 * The router filter configuration
 */
class RouterFilterConfig {
public:
  virtual ~RouterFilterConfig() = default;

  virtual RouterStats& stats() PURE;
};

} // namespace Router
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/sip_proxy/filters/network/source/router/config.h"

#include "envoy/registry/registry.h"

#include "contrib/envoy/extensions/filters/network/sip_proxy/router/v3alpha/router.pb.h"
#include "contrib/envoy/extensions/filters/network/sip_proxy/router/v3alpha/router.pb.validate.h"
#include "contrib/sip_proxy/filters/network/source/router/router_impl.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace SipProxy {
namespace Router {

SipFilters::FilterFactoryCb RouterFilterConfigFactory::createFilterFactoryFromProtoTyped(
    const envoy::extensions::filters::network::sip_proxy::router::v3alpha::Router& proto_config,
    const std::string& stat_prefix, Server::Configuration::FactoryContext& context) {
  UNREFERENCED_PARAMETER(proto_config);

  std::shared_ptr<RouterFilterConfig> config(
      new RouterFilterConfigImpl(proto_config, stat_prefix, context));

  return [config, &context,
          stat_prefix](SipFilters::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addDecoderFilter(
        std::make_shared<Router>(config, context.serverFactoryContext().clusterManager(), context));
  };
}

/**
 * Static registration for the router filter. @see RegisterFactory.
 */
REGISTER_FACTORY(RouterFilterConfigFactory, SipFilters::NamedSipFilterConfigFactory);

} // namespace Router
} // namespace SipProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "source/common/buffer/buffer_impl.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin_resp.h"
#include "gtest/gtest.h"
#include "mysql_test_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

constexpr int MYSQL_UT_LAST_ID = 0;
constexpr int MYSQL_UT_SERVER_OK = 0;
constexpr int MYSQL_UT_SERVER_WARNINGS = 0x0001;

class MySQLCLoginRespTest : public testing::Test {
public:
  static OkMessage& getOkMessage() { return ok_; }
  static ErrMessage& getErrMessage() { return err_; }
  static AuthSwitchMessage& getOldAuthSwitchMessage() { return old_auth_switch_; }
  static AuthSwitchMessage& getAuthSwitchMessage() { return auth_switch_; }
  static AuthMoreMessage& getAuthMoreMessage() { return auth_more_; }

private:
  static OkMessage initOkMessage() {
    OkMessage ok{};
    ok.setAffectedRows(1);
    ok.setLastInsertId(MYSQL_UT_LAST_ID);
    ok.setServerStatus(MYSQL_UT_SERVER_OK);
    ok.setWarnings(MYSQL_UT_SERVER_WARNINGS);
    ok.setInfo(MySQLTestUtils::getInfo());
    return ok;
  }
  static ErrMessage initErrMessage() {
    ErrMessage err{};
    err.setErrorCode(MYSQL_ERROR_CODE);
    err.setSqlStateMarker('#');
    err.setSqlState(MySQLTestUtils::getSqlState());
    err.setErrorMessage(MySQLTestUtils::getErrorMessage());
    return err;
  }
  static AuthSwitchMessage initOldAuthSwitchMessage() {
    AuthSwitchMessage auth_switch{};
    auth_switch.setIsOldAuthSwitch(true);
    return auth_switch;
  }
  static AuthSwitchMessage initAuthSwitchMessage() {
    AuthSwitchMessage auth_switch{};
    auth_switch.setAuthPluginName(MySQLTestUtils::getAuthPluginName());
    auth_switch.setAuthPluginData(MySQLTestUtils::getAuthPluginData20());
    return auth_switch;
  }
  static AuthMoreMessage initAuthMoreMessage() {
    AuthMoreMessage auth_more{};
    auth_more.setAuthMoreData(MySQLTestUtils::getAuthPluginData20());
    return auth_more;
  }

private:
  static OkMessage ok_;
  static ErrMessage err_;
  static AuthSwitchMessage auth_switch_;
  static AuthSwitchMessage old_auth_switch_;
  static AuthMoreMessage auth_more_;
};

OkMessage MySQLCLoginRespTest::ok_ = MySQLCLoginRespTest::initOkMessage();
ErrMessage MySQLCLoginRespTest::err_ = MySQLCLoginRespTest::initErrMessage();
AuthSwitchMessage MySQLCLoginRespTest::auth_switch_ = MySQLCLoginRespTest::initAuthSwitchMessage();
AuthSwitchMessage MySQLCLoginRespTest::old_auth_switch_ =
    MySQLCLoginRespTest::initOldAuthSwitchMessage();
AuthMoreMessage MySQLCLoginRespTest::auth_more_ = MySQLCLoginRespTest::initAuthMoreMessage();

/*
 * Test the MYSQL Server Login Response OK message parser:
 * - message is encoded using the OkMessage class
 * - message is decoded using the OkMessage class
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginOkEncDec) {
  OkMessage& mysql_loginok_encode = MySQLCLoginRespTest::getOkMessage();

  Buffer::OwnedImpl decode_data;
  mysql_loginok_encode.encode(decode_data);

  OkMessage mysql_loginok_decode{};
  mysql_loginok_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_loginok_decode.getAffectedRows(), mysql_loginok_encode.getAffectedRows());
  EXPECT_EQ(mysql_loginok_decode.getLastInsertId(), mysql_loginok_encode.getLastInsertId());
  EXPECT_EQ(mysql_loginok_decode.getServerStatus(), mysql_loginok_encode.getServerStatus());
  EXPECT_EQ(mysql_loginok_decode.getWarnings(), mysql_loginok_encode.getWarnings());
  EXPECT_EQ(mysql_loginok_decode.getInfo(), mysql_loginok_encode.getInfo());
}

/*
 * Test the MYSQL Server Login Response Err message parser:
 * - message is encoded using the ErrMessage class
 * - message is decoded using the ErrMessage class
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginErrEncDec) {
  ErrMessage& mysql_loginerr_encode = MySQLCLoginRespTest::getErrMessage();
  Buffer::OwnedImpl decode_data;
  mysql_loginerr_encode.encode(decode_data);

  ErrMessage mysql_loginerr_decode{};
  mysql_loginerr_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_loginerr_decode.getSqlStateMarker(), mysql_loginerr_encode.getSqlStateMarker());
  EXPECT_EQ(mysql_loginerr_decode.getSqlState(), mysql_loginerr_encode.getSqlState());
  EXPECT_EQ(mysql_loginerr_decode.getErrorCode(), mysql_loginerr_encode.getErrorCode());
  EXPECT_EQ(mysql_loginerr_decode.getErrorMessage(), mysql_loginerr_encode.getErrorMessage());
}

/*
 * Test the MYSQL Server Login Old Auth Switch message parser:
 * - message is encoded using the AuthSwitchMessage class
 * - message is decoded using the AuthSwitchMessage class
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginOldClientLoginResponseAuthSwitch) {
  AuthSwitchMessage& mysql_old_auth_switch_encode = MySQLCLoginRespTest::getOldAuthSwitchMessage();

  Buffer::OwnedImpl decode_data;
  mysql_old_auth_switch_encode.encode(decode_data);

  AuthSwitchMessage mysql_old_auth_switch_decode{};
  mysql_old_auth_switch_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_old_auth_switch_decode.getAuthPluginData(),
            mysql_old_auth_switch_encode.getAuthPluginData());
  EXPECT_EQ(mysql_old_auth_switch_decode.getAuthPluginName(),
            mysql_old_auth_switch_encode.getAuthPluginName());
}

/*
 * Test the MYSQL Server Login Auth Switch message parser:
 * - message is encoded using the AuthSwitchMessage class
 * - message is decoded using the AuthSwitchMessage class
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginClientLoginResponseAuthSwitch) {
  AuthSwitchMessage& mysql_auth_switch_encode(MySQLCLoginRespTest::getAuthSwitchMessage());
  Buffer::OwnedImpl decode_data;
  mysql_auth_switch_encode.encode(decode_data);

  AuthSwitchMessage mysql_auth_switch_decode{};
  mysql_auth_switch_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_auth_switch_decode.getAuthPluginData(),
            mysql_auth_switch_encode.getAuthPluginData());
  EXPECT_EQ(mysql_auth_switch_decode.getAuthPluginName(),
            mysql_auth_switch_encode.getAuthPluginName());
}

/*
 * Test the MYSQL Server Login Auth More message parser:
 * - message is encoded using the AuthMoreMessage class
 * - message is decoded using the AuthMoreMessage class
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginAuthMore) {
  AuthMoreMessage& mysql_auth_more_encode(MySQLCLoginRespTest::getAuthMoreMessage());

  Buffer::OwnedImpl decode_data;
  mysql_auth_more_encode.encode(decode_data);

  AuthMoreMessage mysql_auth_more_decode{};
  mysql_auth_more_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_auth_more_decode.getAuthMoreData(), mysql_auth_more_encode.getAuthMoreData());
}

/*
 * Negative Test the MYSQL Server Login OK message parser:
 * - incomplete response code
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginOkIncompleteRespCode) {
  OkMessage mysql_loginok_encode = MySQLCLoginRespTest::getOkMessage();

  Buffer::OwnedImpl decode_data;

  OkMessage mysql_loginok_decode{};
  mysql_loginok_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_loginok_decode.getRespCode(), MYSQL_RESP_OK);
}

/*
 * Negative Test the MYSQL Server Login OK message parser:
 * - incomplete affected rows
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginOkIncompleteAffectedRows) {
  OkMessage& mysql_loginok_encode = MySQLCLoginRespTest::getOkMessage();

  Buffer::OwnedImpl buffer;
  mysql_loginok_encode.encode(buffer);

  int incomplete_len = sizeof(uint8_t);
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  OkMessage mysql_loginok_decode{};
  mysql_loginok_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_loginok_decode.getRespCode(), mysql_loginok_encode.getRespCode());
}

/*
 * Negative Test the MYSQL Server Login OK message parser:
 * - incomplete Client Login OK last insert id
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginOkIncompleteLastInsertId) {
  OkMessage& mysql_loginok_encode = MySQLCLoginRespTest::getOkMessage();

  Buffer::OwnedImpl buffer;
  mysql_loginok_encode.encode(buffer);

  int incomplete_len = sizeof(uint8_t) + MySQLTestUtils::sizeOfLengthEncodeInteger(
                                             mysql_loginok_encode.getAffectedRows());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  OkMessage mysql_loginok_decode{};
  mysql_loginok_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_loginok_decode.getRespCode(), mysql_loginok_encode.getRespCode());
  EXPECT_EQ(mysql_loginok_decode.getAffectedRows(), mysql_loginok_encode.getAffectedRows());
}

/*
 * Negative Test the MYSQL Server Login OK message parser:
 * - incomplete server status
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginOkIncompleteServerStatus) {
  OkMessage& mysql_loginok_encode = MySQLCLoginRespTest::getOkMessage();

  Buffer::OwnedImpl buffer;
  mysql_loginok_encode.encode(buffer);

  int incomplete_len =
      sizeof(uint8_t) +
      MySQLTestUtils::sizeOfLengthEncodeInteger(mysql_loginok_encode.getAffectedRows()) +
      MySQLTestUtils::sizeOfLengthEncodeInteger(mysql_loginok_encode.getLastInsertId());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  OkMessage mysql_loginok_decode{};
  mysql_loginok_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_loginok_decode.getRespCode(), mysql_loginok_encode.getRespCode());
  EXPECT_EQ(mysql_loginok_decode.getAffectedRows(), mysql_loginok_encode.getAffectedRows());
  EXPECT_EQ(mysql_loginok_decode.getLastInsertId(), mysql_loginok_encode.getLastInsertId());
  EXPECT_EQ(mysql_loginok_decode.getServerStatus(), 0);
}

/*
 * Negative Test the MYSQL Server Login OK message parser:
 * - incomplete warnings
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginOkIncompleteWarnings) {
  OkMessage& mysql_loginok_encode = MySQLCLoginRespTest::getOkMessage();
  Buffer::OwnedImpl buffer;
  mysql_loginok_encode.encode(buffer);

  int incomplete_len =
      sizeof(uint8_t) +
      MySQLTestUtils::sizeOfLengthEncodeInteger(mysql_loginok_encode.getAffectedRows()) +
      MySQLTestUtils::sizeOfLengthEncodeInteger(mysql_loginok_encode.getLastInsertId()) +
      sizeof(mysql_loginok_encode.getServerStatus());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  OkMessage mysql_loginok_decode{};
  mysql_loginok_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_loginok_decode.getRespCode(), mysql_loginok_encode.getRespCode());
  EXPECT_EQ(mysql_loginok_decode.getAffectedRows(), mysql_loginok_encode.getAffectedRows());
  EXPECT_EQ(mysql_loginok_decode.getLastInsertId(), mysql_loginok_encode.getLastInsertId());
  EXPECT_EQ(mysql_loginok_decode.getServerStatus(), mysql_loginok_encode.getServerStatus());
  EXPECT_EQ(mysql_loginok_decode.getWarnings(), 0);
}

/*
 * Negative Test the MYSQL Server Login OK message parser:
 * - incomplete info
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginOkIncompleteInfo) {
  OkMessage& mysql_loginok_encode = MySQLCLoginRespTest::getOkMessage();
  Buffer::OwnedImpl buffer;
  mysql_loginok_encode.encode(buffer);

  int incomplete_len =
      sizeof(uint8_t) +
      MySQLTestUtils::sizeOfLengthEncodeInteger(mysql_loginok_encode.getAffectedRows()) +
      MySQLTestUtils::sizeOfLengthEncodeInteger(mysql_loginok_encode.getLastInsertId()) +
      sizeof(mysql_loginok_encode.getServerStatus()) + sizeof(mysql_loginok_encode.getWarnings()) +
      mysql_loginok_encode.getInfo().size() + 1;

  OkMessage mysql_loginok_decode{};
  mysql_loginok_decode.decode(buffer, CHALLENGE_SEQ_NUM, incomplete_len);
  EXPECT_EQ(mysql_loginok_decode.getRespCode(), mysql_loginok_encode.getRespCode());
  EXPECT_EQ(mysql_loginok_decode.getAffectedRows(), mysql_loginok_encode.getAffectedRows());
  EXPECT_EQ(mysql_loginok_decode.getLastInsertId(), mysql_loginok_encode.getLastInsertId());
  EXPECT_EQ(mysql_loginok_decode.getServerStatus(), mysql_loginok_encode.getServerStatus());
  EXPECT_EQ(mysql_loginok_decode.getWarnings(), mysql_loginok_encode.getWarnings());
  EXPECT_EQ(mysql_loginok_decode.getInfo(), "");
}

/*
 * Negative Test the MYSQL Server Login Err message parser:
 * - incomplete response code
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginErrIncompleteRespCode) {
  Buffer::OwnedImpl decode_data;

  ErrMessage mysql_loginerr_decode{};
  mysql_loginerr_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_loginerr_decode.getRespCode(), MYSQL_RESP_ERR);
}

/*
 * Negative Test the MYSQL Server Login ERR message parser:
 * - incomplete error code
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginErrIncompleteErrorcode) {
  ErrMessage& mysql_loginerr_encode = MySQLCLoginRespTest::getErrMessage();
  Buffer::OwnedImpl buffer;
  mysql_loginerr_encode.encode(buffer);

  int incomplete_len = sizeof(uint8_t);
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ErrMessage mysql_loginerr_decode{};
  mysql_loginerr_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_loginerr_decode.getRespCode(), mysql_loginerr_encode.getRespCode());
  EXPECT_EQ(mysql_loginerr_decode.getErrorCode(), 0);
}

/*
 * Negative Test the MYSQL Server Login ERR message parser:
 * - incomplete sql state marker
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginErrIncompleteStateMarker) {
  ErrMessage& mysql_loginerr_encode = MySQLCLoginRespTest::getErrMessage();
  Buffer::OwnedImpl buffer;
  mysql_loginerr_encode.encode(buffer);

  int incomplete_len = sizeof(uint8_t) + sizeof(mysql_loginerr_encode.getErrorCode());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ErrMessage mysql_loginerr_decode{};
  mysql_loginerr_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_loginerr_decode.getRespCode(), mysql_loginerr_encode.getRespCode());
  EXPECT_EQ(mysql_loginerr_decode.getErrorCode(), mysql_loginerr_encode.getErrorCode());
  EXPECT_EQ(mysql_loginerr_decode.getSqlStateMarker(), 0);
}

/*
 * Negative Test the MYSQL Server Login ERR message parser:
 * - incomplete sql state
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginErrIncompleteSqlState) {
  ErrMessage& mysql_loginerr_encode = MySQLCLoginRespTest::getErrMessage();
  Buffer::OwnedImpl buffer;
  mysql_loginerr_encode.encode(buffer);

  int incomplete_len = sizeof(uint8_t) + sizeof(mysql_loginerr_encode.getErrorCode()) +
                       sizeof(mysql_loginerr_encode.getSqlStateMarker());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ErrMessage mysql_loginerr_decode{};
  mysql_loginerr_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_loginerr_decode.getRespCode(), mysql_loginerr_encode.getRespCode());
  EXPECT_EQ(mysql_loginerr_decode.getErrorCode(), mysql_loginerr_encode.getErrorCode());
  EXPECT_EQ(mysql_loginerr_decode.getSqlStateMarker(), mysql_loginerr_encode.getSqlStateMarker());
  EXPECT_EQ(mysql_loginerr_decode.getSqlState(), "");
}

/*
 * Negative Test the MYSQL Server Login ERR message parser:
 * - incomplete error message
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginErrIncompleteErrorMessage) {
  ErrMessage& mysql_loginerr_encode = MySQLCLoginRespTest::getErrMessage();
  Buffer::OwnedImpl buffer;
  mysql_loginerr_encode.setErrorMessage(MySQLTestUtils::getErrorMessage());
  mysql_loginerr_encode.encode(buffer);

  int incomplete_len = sizeof(uint8_t) + sizeof(mysql_loginerr_encode.getErrorCode()) +
                       sizeof(mysql_loginerr_encode.getSqlStateMarker()) +
                       mysql_loginerr_encode.getSqlState().size() +
                       mysql_loginerr_encode.getErrorMessage().size() + 1;

  ErrMessage mysql_loginerr_decode{};
  mysql_loginerr_decode.decode(buffer, CHALLENGE_SEQ_NUM, incomplete_len);
  EXPECT_EQ(mysql_loginerr_decode.getRespCode(), mysql_loginerr_encode.getRespCode());
  EXPECT_EQ(mysql_loginerr_decode.getErrorCode(), mysql_loginerr_encode.getErrorCode());
  EXPECT_EQ(mysql_loginerr_decode.getSqlStateMarker(), mysql_loginerr_encode.getSqlStateMarker());
  EXPECT_EQ(mysql_loginerr_decode.getSqlState(), mysql_loginerr_encode.getSqlState());
  EXPECT_EQ(mysql_loginerr_decode.getErrorMessage(), "");
}

/*
 * Negative Test the MYSQL Server Login Auth Switch message parser:
 * - incomplete response code
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginAuthSwitchIncompleteRespCode) {
  Buffer::OwnedImpl decode_data;

  AuthSwitchMessage mysql_login_auth_switch_decode{};
  mysql_login_auth_switch_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_login_auth_switch_decode.getRespCode(), MYSQL_RESP_AUTH_SWITCH);
}

/*
 * Negative Test the MYSQL Server Login ERR message parser:
 * - incomplete auth plugin name
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginAuthSwitchIncompletePluginName) {
  AuthSwitchMessage& mysql_login_auth_switch_encode = MySQLCLoginRespTest::getAuthSwitchMessage();
  Buffer::OwnedImpl buffer;
  mysql_login_auth_switch_encode.encode(buffer);

  int incomplete_len =
      sizeof(uint8_t) + mysql_login_auth_switch_encode.getAuthPluginName().size() - 1;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  AuthSwitchMessage mysql_login_auth_switch_decode{};
  mysql_login_auth_switch_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_login_auth_switch_decode.getRespCode(),
            mysql_login_auth_switch_encode.getRespCode());
  EXPECT_EQ(mysql_login_auth_switch_decode.getAuthPluginName(), "");
}

/*
 * Negative Test the MYSQL Server Login Auth Switch message parser:
 * - incomplete auth plugin data
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginAuthSwitchIncompletePluginData) {
  AuthSwitchMessage& mysql_login_auth_switch_encode = MySQLCLoginRespTest::getAuthSwitchMessage();
  Buffer::OwnedImpl buffer;
  mysql_login_auth_switch_encode.encode(buffer);

  AuthSwitchMessage mysql_login_auth_switch_decode{};
  mysql_login_auth_switch_decode.decode(buffer, CHALLENGE_SEQ_NUM, buffer.length() + 1);
  EXPECT_EQ(mysql_login_auth_switch_decode.getRespCode(),
            mysql_login_auth_switch_encode.getRespCode());
  EXPECT_EQ(mysql_login_auth_switch_decode.getAuthPluginName(),
            mysql_login_auth_switch_encode.getAuthPluginName());
  EXPECT_EQ(mysql_login_auth_switch_decode.getAuthPluginData().size(), 0);
}

/*
 * Negative Test the MYSQL Server Auth More message parser:
 * - incomplete response code
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginAuthMoreIncompleteRespCode) {
  Buffer::OwnedImpl decode_data;

  AuthMoreMessage mysql_login_auth_more_decode{};
  mysql_login_auth_more_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_login_auth_more_decode.getRespCode(), MYSQL_RESP_MORE);
}

/*
 * Negative Test the MYSQL Server Auth More message parser:
 * - incomplete auth plugin name
 */
TEST_F(MySQLCLoginRespTest, MySQLLoginAuthMoreIncompletePluginData) {
  AuthMoreMessage& mysql_login_auth_more_encode = MySQLCLoginRespTest::getAuthMoreMessage();

  Buffer::OwnedImpl buffer;
  mysql_login_auth_more_encode.encode(buffer);

  int incomplete_len = sizeof(uint8_t) + mysql_login_auth_more_encode.getAuthMoreData().size() + 1;

  AuthMoreMessage mysql_login_auth_more_decode{};
  mysql_login_auth_more_decode.decode(buffer, CHALLENGE_SEQ_NUM, incomplete_len);
  EXPECT_EQ(mysql_login_auth_more_decode.getRespCode(), mysql_login_auth_more_encode.getRespCode());
  EXPECT_EQ(mysql_login_auth_more_decode.getAuthMoreData().size(), 0);
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "mysql_test_utils.h"

#include "source/common/buffer/buffer_impl.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin_resp.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_greeting.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_switch_resp.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

std::string MySQLTestUtils::encodeServerGreeting(int protocol) {
  ServerGreeting mysql_greet_encode{};
  mysql_greet_encode.setProtocol(protocol);
  std::string ver(MySQLTestUtils::getVersion());
  mysql_greet_encode.setVersion(ver);
  mysql_greet_encode.setThreadId(MYSQL_THREAD_ID);
  mysql_greet_encode.setAuthPluginData(getAuthPluginData8());
  mysql_greet_encode.setServerCap(MYSQL_SERVER_CAPAB);
  mysql_greet_encode.setServerCharset(MYSQL_SERVER_LANGUAGE);
  mysql_greet_encode.setServerStatus(MYSQL_SERVER_STATUS);
  mysql_greet_encode.setExtServerCap(MYSQL_SERVER_EXT_CAPAB);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);
  BufferHelper::encodeHdr(buffer, GREETING_SEQ_NUM);
  return buffer.toString();
}

std::string MySQLTestUtils::encodeClientLogin(uint16_t client_cap, std::string user, uint8_t seq) {
  ClientLogin mysql_clogin_encode{};
  mysql_clogin_encode.setClientCap(client_cap);
  mysql_clogin_encode.setExtendedClientCap(MYSQL_EXT_CLIENT_CAPAB);
  mysql_clogin_encode.setMaxPacket(MYSQL_MAX_PACKET);
  mysql_clogin_encode.setCharset(MYSQL_CHARSET);
  mysql_clogin_encode.setUsername(user);
  mysql_clogin_encode.setAuthResp(getAuthPluginData8());
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);
  BufferHelper::encodeHdr(buffer, seq);
  return buffer.toString();
}

std::string MySQLTestUtils::encodeClientLoginResp(uint8_t srv_resp, uint8_t it, uint8_t seq_force) {

  ClientLoginResponse* mysql_login_resp_encode = nullptr;
  auto encodeToString = [it, seq_force, &mysql_login_resp_encode]() {
    ASSERT(mysql_login_resp_encode != nullptr);
    uint8_t seq = CHALLENGE_RESP_SEQ_NUM + 2 * it;
    if (seq_force > 0) {
      seq = seq_force;
    }
    Buffer::OwnedImpl buffer;
    mysql_login_resp_encode->encode(buffer);
    BufferHelper::encodeHdr(buffer, seq);
    return buffer.toString();
  };
  switch (srv_resp) {
  case MYSQL_RESP_OK: {
    OkMessage ok{};
    mysql_login_resp_encode = &ok;
    ok.setAffectedRows(MYSQL_SM_AFFECTED_ROWS);
    ok.setLastInsertId(MYSQL_SM_LAST_ID);
    ok.setServerStatus(MYSQL_SM_SERVER_OK);
    ok.setWarnings(MYSQL_SM_SERVER_WARNINGS);
    return encodeToString();
  }
  case MYSQL_RESP_ERR: {
    ErrMessage err{};
    mysql_login_resp_encode = &err;
    err.setErrorCode(MYSQL_ERROR_CODE);
    err.setSqlStateMarker('#');
    err.setSqlState(MySQLTestUtils::getSqlState());
    err.setErrorMessage(MySQLTestUtils::getErrorMessage());
    return encodeToString();
  }
  case MYSQL_RESP_AUTH_SWITCH: {
    AuthSwitchMessage auth_switch{};
    mysql_login_resp_encode = &auth_switch;
    auth_switch.setIsOldAuthSwitch(false);
    auth_switch.setAuthPluginData(MySQLTestUtils::getAuthPluginData20());
    auth_switch.setAuthPluginName(MySQLTestUtils::getAuthPluginName());
    return encodeToString();
  }
  case MYSQL_RESP_MORE: {
    AuthMoreMessage auth_more{};
    mysql_login_resp_encode = &auth_more;
    auth_more.setAuthMoreData(MySQLTestUtils::getAuthPluginData20());
    return encodeToString();
  }
  default: {
    AuthMoreMessage unknown{};
    mysql_login_resp_encode = &unknown;
    unknown.setRespCode(srv_resp);
    return encodeToString();
  }
  }
}

std::string MySQLTestUtils::encodeAuthSwitchResp() {
  ClientSwitchResponse mysql_switch_resp_encode{};
  mysql_switch_resp_encode.setAuthPluginResp(getAuthPluginData20());
  Buffer::OwnedImpl buffer;
  mysql_switch_resp_encode.encode(buffer);
  BufferHelper::encodeHdr(buffer, AUTH_SWITH_RESP_SEQ);
  return buffer.toString();
}

// encode message for specific packet_len
std::string MySQLTestUtils::encodeMessage(uint32_t packet_len, uint8_t it, uint8_t seq_force) {
  Buffer::OwnedImpl buffer;
  std::string res(packet_len, '0');
  buffer.add(res);
  uint8_t seq = CHALLENGE_RESP_SEQ_NUM + 2 * it;
  if (seq_force > 0) {
    seq = seq_force;
  }
  BufferHelper::encodeHdr(buffer, seq);
  return buffer.toString();
}

int MySQLTestUtils::bytesOfConnAtrributeLength(
    const std::vector<std::pair<std::string, std::string>>& conn_attrs) {
  int64_t total_len = 0;
  for (const auto& kv : conn_attrs) {
    total_len += sizeOfLengthEncodeInteger(kv.first.length());
    total_len += kv.first.length();
    total_len += sizeOfLengthEncodeInteger(kv.second.length());
    total_len += kv.second.length();
  }
  return sizeOfLengthEncodeInteger(total_len);
}

int MySQLTestUtils::sizeOfLengthEncodeInteger(uint64_t val) {
  if (val < 251) {
    return sizeof(uint8_t);
  } else if (val < (1 << 16)) {
    return sizeof(uint8_t) + sizeof(uint16_t);
  } else if (val < (1 << 24)) {
    return sizeof(uint8_t) + sizeof(uint8_t) * 3;
  } else {
    return sizeof(uint8_t) + sizeof(uint64_t);
  }
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "source/common/buffer/buffer_impl.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_greeting.h"
#include "gtest/gtest.h"
#include "mysql_test_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

class MySQLGreetTest : public testing::Test {
public:
  ServerGreeting getV9Greet() const {
    ServerGreeting mysql_greet_encode{};
    mysql_greet_encode.setProtocol(MYSQL_PROTOCOL_9);
    mysql_greet_encode.setVersion(MySQLTestUtils::getVersion());
    mysql_greet_encode.setThreadId(MYSQL_THREAD_ID);
    mysql_greet_encode.setAuthPluginData(MySQLTestUtils::getAuthPluginData8());
    return mysql_greet_encode;
  }
  ServerGreeting getV10Greet(uint16_t base_cap, uint16_t ext_cap) const {
    ServerGreeting mysql_greet_encode{};
    mysql_greet_encode.setProtocol(MYSQL_PROTOCOL_10);
    mysql_greet_encode.setVersion(MySQLTestUtils::getVersion());
    mysql_greet_encode.setThreadId(MYSQL_THREAD_ID);
    mysql_greet_encode.setAuthPluginData(MySQLTestUtils::getAuthPluginData20());
    mysql_greet_encode.setBaseServerCap(base_cap);
    mysql_greet_encode.setExtServerCap(ext_cap);
    mysql_greet_encode.setServerStatus(MYSQL_SERVER_STATUS);
    mysql_greet_encode.setServerCharset(MYSQL_CHARSET);
    mysql_greet_encode.setAuthPluginName(MySQLTestUtils::getAuthPluginName());
    return mysql_greet_encode;
  }
  ServerGreeting getV10Greet(uint32_t cap) const { return getV10Greet(cap & 0xffff, cap >> 16); }
};

TEST_F(MySQLGreetTest, MySQLServerChallengeV9EncDec) {
  ServerGreeting mysql_greet_encode = getV9Greet();
  Buffer::OwnedImpl data;
  mysql_greet_encode.encode(data);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(data, GREETING_SEQ_NUM, data.length());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getServerCap(), mysql_greet_encode.getServerCap());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getExtServerCap(), mysql_greet_encode.getExtServerCap());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData(), mysql_greet_encode.getAuthPluginData());
}

/*
 * Test the MYSQL Greeting message V10:
 * - message is encoded using the ServerGreeting class
 * - message is decoded using the ServerGreeting class
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeV10EncDec) {
  ServerGreeting mysql_greet_encode = getV10Greet(0);
  Buffer::OwnedImpl decode_data;
  mysql_greet_encode.encode(decode_data);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData(), mysql_greet_encode.getAuthPluginData());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData1(), mysql_greet_encode.getAuthPluginData1());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData2().size(), 0);
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getServerStatus(), mysql_greet_encode.getServerStatus());
  EXPECT_EQ(mysql_greet_decode.getServerCap(), mysql_greet_encode.getServerCap());
  EXPECT_EQ(mysql_greet_decode.getServerCharset(), mysql_greet_encode.getServerCharset());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getExtServerCap(), mysql_greet_encode.getExtServerCap());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginName(), "");
}

/*
 * Negative Testing: Server Greetings v10 Incomplete
 * - incomplete protocol
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeIncompleteProtocol) {
  ServerGreeting mysql_greet_encode = getV10Greet(0);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len = 0;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), 0);
}

/*
 * Negative Testing: Server Greetings v10 Incomplete
 * - incomplete version
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeIncompleteVersion) {
  ServerGreeting mysql_greet_encode = getV10Greet(0);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_greet_encode.getProtocol());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getVersion(), "");
}

/*
 * Negative Testing: Server Greetings v10 Incomplete
 * - incomplete thread_id
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeIncompleteThreadId) {
  ServerGreeting mysql_greet_encode = getV10Greet(0);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_greet_encode.getProtocol()) + mysql_greet_encode.getVersion().size() + 1;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), 0);
}

/*
 * Negative Testing: Server Greetings v10 Incomplete
 * - incomplete auth_plugin_data
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeIncompleteSalt) {
  ServerGreeting mysql_greet_encode = getV10Greet(0);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_greet_encode.getProtocol()) +
                       mysql_greet_encode.getVersion().size() + 1 +
                       sizeof(mysql_greet_encode.getThreadId());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData().size(), 0);
}

/*
 * Negative Testing: Server Greetings v10 Incomplete
 * - incomplete filler
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeIncompleteFiller) {
  ServerGreeting mysql_greet_encode = getV10Greet(0);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_greet_encode.getProtocol()) + mysql_greet_encode.getVersion().size() + 1 +
      sizeof(mysql_greet_encode.getThreadId()) + mysql_greet_encode.getAuthPluginData1().size();
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData1(), mysql_greet_encode.getAuthPluginData1());
}

/*
 * Negative Testing: Server Greetings v10 Incomplete
 * - incomplete Server Capabilities
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeIncompleteServerCap) {
  ServerGreeting mysql_greet_encode = getV10Greet(MYSQL_SERVER_CAPAB, 0);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_greet_encode.getProtocol()) + mysql_greet_encode.getVersion().size() + 1 +
      sizeof(mysql_greet_encode.getThreadId()) + mysql_greet_encode.getAuthPluginData1().size() + 1;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData(), mysql_greet_encode.getAuthPluginData());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), 0);
}

/*
 * Negative Testing: Server Greetings v10 Incomplete
 * - incomplete Server Charset
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeIncompleteServerCharset) {
  ServerGreeting mysql_greet_encode = getV10Greet(MYSQL_SERVER_CAPAB, 0);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_greet_encode.getProtocol()) + mysql_greet_encode.getVersion().size() + 1 +
      sizeof(mysql_greet_encode.getThreadId()) + mysql_greet_encode.getAuthPluginData1().size() +
      1 + sizeof(mysql_greet_encode.getBaseServerCap());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData(), mysql_greet_encode.getAuthPluginData());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getServerCharset(), 0);
}

/*
 * Negative Testing: Server Greetings Incomplete
 * - incomplete Server Status
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeIncompleteServerStatus) {
  ServerGreeting mysql_greet_encode = getV10Greet(MYSQL_SERVER_CAPAB, 0);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_greet_encode.getProtocol()) + mysql_greet_encode.getVersion().size() + 1 +
      sizeof(mysql_greet_encode.getThreadId()) + mysql_greet_encode.getAuthPluginData1().size() +
      1 + sizeof(mysql_greet_encode.getBaseServerCap()) +
      sizeof(mysql_greet_encode.getServerCharset());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData(), mysql_greet_encode.getAuthPluginData());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getServerCharset(), mysql_greet_encode.getServerCharset());
  EXPECT_EQ(mysql_greet_decode.getServerStatus(), 0);
}

/*
 * Negative Testing: Server Greetings v10 Incomplete
 * - incomplete extended Server Capabilities
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeIncompleteExtServerCap) {
  ServerGreeting mysql_greet_encode = getV10Greet(MYSQL_SERVER_CAPAB, MYSQL_SERVER_EXT_CAPAB);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_greet_encode.getProtocol()) + mysql_greet_encode.getVersion().size() + 1 +
      sizeof(mysql_greet_encode.getThreadId()) + mysql_greet_encode.getAuthPluginData1().size() +
      1 + sizeof(mysql_greet_encode.getBaseServerCap()) +
      sizeof(mysql_greet_encode.getServerCharset()) + sizeof(mysql_greet_encode.getServerStatus());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData(), mysql_greet_encode.getAuthPluginData());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getServerCharset(), mysql_greet_encode.getServerCharset());
  EXPECT_EQ(mysql_greet_decode.getServerStatus(), mysql_greet_encode.getServerStatus());
  EXPECT_EQ(mysql_greet_decode.getExtServerCap(), 0);
}

/*
 * Negative Testing: Server Greetings v10 Incomplete
 * - incomplete extended Server Capabilities
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeIncompleteAuthPluginDataLen) {
  ServerGreeting mysql_greet_encode = getV10Greet(0);
  mysql_greet_encode.setAuthPluginData1(MySQLTestUtils::getAuthPluginData8());
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_greet_encode.getProtocol()) + mysql_greet_encode.getVersion().size() + 1 +
      sizeof(mysql_greet_encode.getThreadId()) + mysql_greet_encode.getAuthPluginData1().size() +
      1 + sizeof(mysql_greet_encode.getBaseServerCap()) +
      sizeof(mysql_greet_encode.getServerCharset()) + sizeof(mysql_greet_encode.getServerStatus()) +
      sizeof(mysql_greet_encode.getExtServerCap());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData(), mysql_greet_encode.getAuthPluginData());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getServerCharset(), mysql_greet_encode.getServerCharset());
  EXPECT_EQ(mysql_greet_decode.getServerStatus(), mysql_greet_encode.getServerStatus());
  EXPECT_EQ(mysql_greet_decode.getExtServerCap(), 0);
}

/*
 * Testing: Server Greetings Protocol 10 Server Capabilities with auth plugin data flag
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeP10ServerCapAuthPlugin) {
  ServerGreeting mysql_greet_encode = getV10Greet(MYSQL_SERVER_CAP_AUTH_PLUGIN);

  Buffer::OwnedImpl decode_data;
  mysql_greet_encode.encode(decode_data);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData(), mysql_greet_encode.getAuthPluginData());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData1(), mysql_greet_encode.getAuthPluginData1());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData2(), mysql_greet_encode.getAuthPluginData2());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getServerCharset(), mysql_greet_encode.getServerCharset());
  EXPECT_EQ(mysql_greet_decode.getServerStatus(), mysql_greet_encode.getServerStatus());
  EXPECT_EQ(mysql_greet_decode.getServerCap(), mysql_greet_encode.getServerCap());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getExtServerCap(), mysql_greet_encode.getExtServerCap());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginName(), mysql_greet_encode.getAuthPluginName());
}

/*
 * Testing: Server Greetings Protocol 10 Server Capabilities with auth plugin data flag incomplete
 * - incomplete of reserved bytes
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeP10ServerAuthPluginInCompleteReserved) {
  ServerGreeting mysql_greet_encode = getV10Greet(MYSQL_SERVER_CAP_AUTH_PLUGIN);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_greet_encode.getProtocol()) + mysql_greet_encode.getVersion().size() + 1 +
      sizeof(mysql_greet_encode.getThreadId()) + mysql_greet_encode.getAuthPluginData1().size() +
      1 + sizeof(mysql_greet_encode.getBaseServerCap()) +
      sizeof(mysql_greet_encode.getServerCharset()) + sizeof(mysql_greet_encode.getServerStatus()) +
      sizeof(mysql_greet_encode.getExtServerCap()) + 1;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData1(), mysql_greet_encode.getAuthPluginData1());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData2().size(), 0);
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getServerCharset(), mysql_greet_encode.getServerCharset());

  EXPECT_EQ(mysql_greet_decode.getServerStatus(), mysql_greet_encode.getServerStatus());
  EXPECT_EQ(mysql_greet_decode.getServerCap(), mysql_greet_encode.getServerCap());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getExtServerCap(), mysql_greet_encode.getExtServerCap());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginName(), "");
}

/*
 * Testing: Server Greetings Protocol 10 Server Capabilities with auth plugin data flag incomplete
 * - incomplete of auth-plugin-data2
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeP10ServerAuthPluginInCompleteAuthData2) {
  ServerGreeting mysql_greet_encode = getV10Greet(MYSQL_SERVER_CAP_AUTH_PLUGIN);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_greet_encode.getProtocol()) + mysql_greet_encode.getVersion().size() + 1 +
      sizeof(mysql_greet_encode.getThreadId()) + mysql_greet_encode.getAuthPluginData1().size() +
      1 + sizeof(mysql_greet_encode.getBaseServerCap()) +
      sizeof(mysql_greet_encode.getServerCharset()) + sizeof(mysql_greet_encode.getServerStatus()) +
      sizeof(mysql_greet_encode.getExtServerCap()) + 1 + 10;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData1(), mysql_greet_encode.getAuthPluginData1());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData2().size(), 0);
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getServerCharset(), mysql_greet_encode.getServerCharset());

  EXPECT_EQ(mysql_greet_decode.getServerStatus(), mysql_greet_encode.getServerStatus());
  EXPECT_EQ(mysql_greet_decode.getServerCap(), mysql_greet_encode.getServerCap());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getExtServerCap(), mysql_greet_encode.getExtServerCap());
}

/*
 * Testing: Server Greetings Protocol 10 Server Capabilities with auth plugin data flag incomplete
 * - incomplete of skipped bytes
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeP10ServerAuthPluginInCompleteSkippedBytes) {
  ServerGreeting mysql_greet_encode = getV10Greet(MYSQL_SERVER_CAP_AUTH_PLUGIN);
  mysql_greet_encode.setAuthPluginData2(MySQLTestUtils::getAuthPluginData8());
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_greet_encode.getProtocol()) + mysql_greet_encode.getVersion().size() + 1 +
      sizeof(mysql_greet_encode.getThreadId()) + mysql_greet_encode.getAuthPluginData1().size() +
      1 + sizeof(mysql_greet_encode.getBaseServerCap()) +
      sizeof(mysql_greet_encode.getServerCharset()) + sizeof(mysql_greet_encode.getServerStatus()) +
      sizeof(mysql_greet_encode.getExtServerCap()) + 1 + 10 +
      mysql_greet_encode.getAuthPluginData2().size();
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData1(), mysql_greet_encode.getAuthPluginData1());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getServerCharset(), mysql_greet_encode.getServerCharset());

  EXPECT_EQ(mysql_greet_decode.getServerStatus(), mysql_greet_encode.getServerStatus());
  EXPECT_EQ(mysql_greet_decode.getServerCap(), mysql_greet_encode.getServerCap());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getExtServerCap(), mysql_greet_encode.getExtServerCap());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData2(), mysql_greet_encode.getAuthPluginData2());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginName(), "");
}

/*
 * Testing: Server Greetings Protocol 10 Server Capabilities with auth plugin data flag incomplete
 * - incomplete of auth plugin name
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeP10ServerAuthPluginInCompleteAuthPluginName) {
  ServerGreeting mysql_greet_encode = getV10Greet(MYSQL_SERVER_CAP_AUTH_PLUGIN);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_greet_encode.getProtocol()) + mysql_greet_encode.getVersion().size() + 1 +
      sizeof(mysql_greet_encode.getThreadId()) + mysql_greet_encode.getAuthPluginData1().size() +
      1 + sizeof(mysql_greet_encode.getBaseServerCap()) +
      sizeof(mysql_greet_encode.getServerCharset()) + sizeof(mysql_greet_encode.getServerStatus()) +
      sizeof(mysql_greet_encode.getExtServerCap()) + 1 + 10 +
      mysql_greet_encode.getAuthPluginData2().size();
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData1(), mysql_greet_encode.getAuthPluginData1());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData2(), mysql_greet_encode.getAuthPluginData2());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getServerStatus(), mysql_greet_encode.getServerStatus());
  EXPECT_EQ(mysql_greet_decode.getServerCap(), mysql_greet_encode.getServerCap());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getExtServerCap(), mysql_greet_encode.getExtServerCap());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginName(), "");
}

/*
 * Testing: Server Greetings Protocol 10 Server Capabilities with security connection flag
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeP10ServerCapSecurityConnection) {
  ServerGreeting mysql_greet_encode = getV10Greet(MYSQL_SERVER_SECURE_CONNECTION);

  Buffer::OwnedImpl decode_data;
  mysql_greet_encode.encode(decode_data);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData(), mysql_greet_encode.getAuthPluginData());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData1(), mysql_greet_encode.getAuthPluginData1());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData2(), mysql_greet_encode.getAuthPluginData2());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getServerCharset(), mysql_greet_encode.getServerCharset());
  EXPECT_EQ(mysql_greet_decode.getServerStatus(), mysql_greet_encode.getServerStatus());
  EXPECT_EQ(mysql_greet_decode.getServerCap(), mysql_greet_encode.getServerCap());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getExtServerCap(), mysql_greet_encode.getExtServerCap());
}

/*
 * Testing: Server Greetings Protocol 10 Server Capabilities with security connection flag
 * - incomplete of auth-plugin-data2
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeP10ServerSecurityConnectionInCompleteData2) {
  ServerGreeting mysql_greet_encode = getV10Greet(MYSQL_SERVER_SECURE_CONNECTION);
  mysql_greet_encode.setServerStatus(MYSQL_SERVER_STATUS);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_greet_encode.getProtocol()) + mysql_greet_encode.getVersion().size() + 1 +
      sizeof(mysql_greet_encode.getThreadId()) + mysql_greet_encode.getAuthPluginData1().size() +
      1 + sizeof(mysql_greet_encode.getBaseServerCap()) +
      sizeof(mysql_greet_encode.getServerCharset()) + sizeof(mysql_greet_encode.getServerStatus()) +
      sizeof(mysql_greet_encode.getExtServerCap()) + 1 + 10;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData1(), mysql_greet_encode.getAuthPluginData1());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData2().size(), 0);
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getServerCharset(), mysql_greet_encode.getServerCharset());

  EXPECT_EQ(mysql_greet_decode.getServerStatus(), mysql_greet_encode.getServerStatus());
  EXPECT_EQ(mysql_greet_decode.getServerCap(), mysql_greet_encode.getServerCap());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getExtServerCap(), mysql_greet_encode.getExtServerCap());
}

/*
 * Testing: Server Greetings Protocol 10 Server Capabilities with security connection flag
 * - incomplete of eof
 */
TEST_F(MySQLGreetTest, MySQLServerChallengeP10ServerSecurityConnectionIncompleteEof) {
  ServerGreeting mysql_greet_encode = getV10Greet(MYSQL_SERVER_SECURE_CONNECTION);
  mysql_greet_encode.setServerStatus(MYSQL_SERVER_STATUS);
  Buffer::OwnedImpl buffer;
  mysql_greet_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_greet_encode.getProtocol()) + mysql_greet_encode.getVersion().size() + 1 +
      sizeof(mysql_greet_encode.getThreadId()) + mysql_greet_encode.getAuthPluginData1().size() +
      1 + sizeof(mysql_greet_encode.getBaseServerCap()) +
      sizeof(mysql_greet_encode.getServerCharset()) + sizeof(mysql_greet_encode.getServerStatus()) +
      sizeof(mysql_greet_encode.getExtServerCap()) + 1 + 10 +
      mysql_greet_encode.getAuthPluginData2().size();
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ServerGreeting mysql_greet_decode{};
  mysql_greet_decode.decode(decode_data, GREETING_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData1(), mysql_greet_encode.getAuthPluginData1());
  EXPECT_EQ(mysql_greet_decode.getAuthPluginData2(), mysql_greet_encode.getAuthPluginData2());
  EXPECT_EQ(mysql_greet_decode.getVersion(), mysql_greet_encode.getVersion());
  EXPECT_EQ(mysql_greet_decode.getProtocol(), mysql_greet_encode.getProtocol());
  EXPECT_EQ(mysql_greet_decode.getThreadId(), mysql_greet_encode.getThreadId());
  EXPECT_EQ(mysql_greet_decode.getServerCharset(), mysql_greet_encode.getServerCharset());

  EXPECT_EQ(mysql_greet_decode.getServerStatus(), mysql_greet_encode.getServerStatus());
  EXPECT_EQ(mysql_greet_decode.getServerCap(), mysql_greet_encode.getServerCap());
  EXPECT_EQ(mysql_greet_decode.getBaseServerCap(), mysql_greet_encode.getBaseServerCap());
  EXPECT_EQ(mysql_greet_decode.getExtServerCap(), mysql_greet_encode.getExtServerCap());
}
} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "source/common/buffer/buffer_impl.h"

#include "test/mocks/network/mocks.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_filter.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_utils.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "mysql_test_utils.h"

using testing::NiceMock;

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

constexpr int SESSIONS = 5;

class MySQLFilterTest : public testing::Test, public MySQLTestUtils {
public:
  MySQLFilterTest() { ENVOY_LOG_MISC(info, "test"); }

  void initialize() {
    config_ = std::make_shared<MySQLFilterConfig>(stat_prefix_, scope_);
    filter_ = std::make_unique<MySQLFilter>(config_);
    filter_->initializeReadFilterCallbacks(filter_callbacks_);
  }

  MySQLFilterConfigSharedPtr config_;
  std::unique_ptr<MySQLFilter> filter_;
  Stats::IsolatedStoreImpl store_;
  Stats::Scope& scope_{*store_.rootScope()};
  std::string stat_prefix_{"test."};
  NiceMock<Network::MockReadFilterCallbacks> filter_callbacks_;
};

// Test New Session counter increment
TEST_F(MySQLFilterTest, NewSessionStatsTest) {
  initialize();

  for (int idx = 0; idx < SESSIONS; idx++) {
    EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  }
  EXPECT_EQ(SESSIONS, config_->stats().sessions_.value());
}

// Test that the filter falls back to tcp proxy if it cant decode
TEST_F(MySQLFilterTest, MySqlFallbackToTcpProxy) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(" "));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(1UL, config_->stats().decoder_errors_.value());

  Buffer::InstancePtr more_data(new Buffer::OwnedImpl("scooby doo - part 2!"));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*more_data, false));
}

/**
 * Test MySQL Handshake with protocol version 41
 * SM: greeting(p=10) -> challenge-req(v41) -> serv-resp-ok
 */
TEST_F(MySQLFilterTest, MySqlHandshake41OkTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(CLIENT_PROTOCOL_41, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp41, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));
  EXPECT_EQ(MySQLSession::State::Req, filter_->getSession().getState());
}

/**
 * Test MySQL Handshake with partial messages.
 * SM: greeting(p=10) -> challenge-req(v41) -> serv-resp-ok
 */
TEST_F(MySQLFilterTest, MySqlHandshake41PartialMessagesTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);

  Buffer::InstancePtr greet_data_part_1(
      new Buffer::OwnedImpl(greeting_data.substr(0, greeting_data.length() / 2)));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*greet_data_part_1, false));
  EXPECT_EQ(MySQLSession::State::Init, filter_->getSession().getState());

  Buffer::InstancePtr greet_data_part_2(
      new Buffer::OwnedImpl(greeting_data.substr(greeting_data.length() / 2)));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*greet_data_part_2, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(CLIENT_PROTOCOL_41, "user1", CHALLENGE_SEQ_NUM);

  Buffer::InstancePtr client_login_data_part_1(
      new Buffer::OwnedImpl(clogin_data.substr(0, clogin_data.length() / 2)));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue,
            filter_->onData(*client_login_data_part_1, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  Buffer::InstancePtr client_login_data_part_2(
      new Buffer::OwnedImpl(clogin_data.substr(clogin_data.length() / 2)));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue,
            filter_->onData(*client_login_data_part_2, false));
  EXPECT_EQ(MySQLSession::State::ChallengeResp41, filter_->getSession().getState());
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK);

  Buffer::InstancePtr server_resp_data_part_1(
      new Buffer::OwnedImpl(srv_resp_data.substr(0, srv_resp_data.length() / 2)));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue,
            filter_->onWrite(*server_resp_data_part_1, false));
  EXPECT_EQ(MySQLSession::State::ChallengeResp41, filter_->getSession().getState());

  Buffer::InstancePtr server_resp_data_part_2(
      new Buffer::OwnedImpl(srv_resp_data.substr(srv_resp_data.length() / 2)));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue,
            filter_->onWrite(*server_resp_data_part_2, false));
  EXPECT_EQ(MySQLSession::State::Req, filter_->getSession().getState());
}

/**
 * Test that the filter falls back to tcp proxy if it cant decode partial messages.
 */
TEST_F(MySQLFilterTest, MySqlFallbackPartialMessagesTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);

  Buffer::InstancePtr greet_data_part_1(
      new Buffer::OwnedImpl(greeting_data.substr(0, greeting_data.length() / 2)));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*greet_data_part_1, false));
  EXPECT_EQ(MySQLSession::State::Init, filter_->getSession().getState());

  Buffer::InstancePtr corrupt_data(new Buffer::OwnedImpl(" "));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*corrupt_data, false));
  EXPECT_EQ(1UL, config_->stats().decoder_errors_.value());

  Buffer::InstancePtr greet_data_part_2(
      new Buffer::OwnedImpl(greeting_data.substr(greeting_data.length() / 2)));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onWrite(*greet_data_part_2, false));
  EXPECT_EQ(MySQLSession::State::Init, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(CLIENT_PROTOCOL_41, "user1", CHALLENGE_SEQ_NUM);

  Buffer::InstancePtr client_login_data_part_1(
      new Buffer::OwnedImpl(clogin_data.substr(0, clogin_data.length() / 2)));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue,
            filter_->onData(*client_login_data_part_1, false));
  EXPECT_EQ(MySQLSession::State::Init, filter_->getSession().getState());

  Buffer::InstancePtr client_login_data_part_2(
      new Buffer::OwnedImpl(clogin_data.substr(clogin_data.length() / 2)));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue,
            filter_->onData(*client_login_data_part_2, false));
  EXPECT_EQ(MySQLSession::State::Init, filter_->getSession().getState());
  EXPECT_EQ(0UL, config_->stats().login_attempts_.value());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK);

  Buffer::InstancePtr server_resp_data_part_1(
      new Buffer::OwnedImpl(srv_resp_data.substr(0, srv_resp_data.length() / 2)));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue,
            filter_->onWrite(*server_resp_data_part_1, false));
  EXPECT_EQ(MySQLSession::State::Init, filter_->getSession().getState());

  Buffer::InstancePtr server_resp_data_part_2(
      new Buffer::OwnedImpl(srv_resp_data.substr(srv_resp_data.length() / 2)));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue,
            filter_->onWrite(*server_resp_data_part_2, false));
  EXPECT_EQ(MySQLSession::State::Init, filter_->getSession().getState());
}

/**
 * Test MySQL Handshake with protocol version 41
 * Server responds with Error
 * SM: greeting(p=10) -> challenge-req(v41) -> serv-resp-err
 */
TEST_F(MySQLFilterTest, MySqlHandshake41ErrTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(CLIENT_PROTOCOL_41, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp41, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_ERR);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));
  EXPECT_EQ(1UL, config_->stats().login_failures_.value());
  EXPECT_EQ(MySQLSession::State::Error, filter_->getSession().getState());
}

/**
 * Test MySQL Handshake with protocol version 41
 * Server responds with Error
 * SM: greeting(p=10) -> challenge-req(v41) -> serv-resp-more
 */
TEST_F(MySQLFilterTest, MySqlHandshake41AuthMoreTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(CLIENT_PROTOCOL_41, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp41, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_MORE);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));
  EXPECT_EQ(MySQLSession::State::NotHandled, filter_->getSession().getState());
}

/**
 * Test MySQL Handshake with protocol version 320
 * SM: greeting(p=10) -> challenge-req(v320) -> serv-resp-ok
 */
TEST_F(MySQLFilterTest, MySqlHandshake320OkTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));
  EXPECT_EQ(MySQLSession::State::Req, filter_->getSession().getState());
}

/**
 * Test MySQL Handshake with protocol version 320
 * SM: greeting(p=10) -> challenge-req(v320) -> incomplete response code
 */
TEST_F(MySQLFilterTest, MySqlHandshake320OkTestIncomplete) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string srv_resp_data = encodeMessage(0);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));
  EXPECT_EQ(MySQLSession::State::NotHandled, filter_->getSession().getState());
}

/**
 * Test MySQL Handshake with protocol version 320
 * Server responds with Error
 * SM: greeting(p=10) -> challenge-req(v320) -> serv-resp-err
 */
TEST_F(MySQLFilterTest, MySqlHandshake320ErrTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_ERR);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));
  EXPECT_EQ(1UL, config_->stats().login_failures_.value());
  EXPECT_EQ(MySQLSession::State::Error, filter_->getSession().getState());
}

/**
 * Test MySQL Handshake with SSL Request
 * State-machine moves to SSL-Pass-Through
 * SM: greeting(p=10) -> challenge-req(v320) -> SSL_PT
 */
TEST_F(MySQLFilterTest, MySqlHandshakeSSLTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data =
      encodeClientLogin(CLIENT_SSL | CLIENT_PROTOCOL_41, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(1UL, config_->stats().upgraded_to_ssl_.value());
  EXPECT_EQ(MySQLSession::State::SslPt, filter_->getSession().getState());

  Buffer::OwnedImpl query_create_index("!@#$encr$#@!");
  BufferHelper::encodeHdr(query_create_index, 2);
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(query_create_index, false));
  EXPECT_EQ(MySQLSession::State::SslPt, filter_->getSession().getState());
}

/**
 * Test MySQL Handshake with protocol version 320
 * Server responds with Auth Switch
 * SM: greeting(p=10) -> challenge-req(v320) -> serv-resp-auth-switch ->
 * -> auth_switch_resp -> serv-resp-ok
 */
TEST_F(MySQLFilterTest, MySqlHandshake320AuthSwitchTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_AUTH_SWITCH);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));

  std::string auth_switch_resp = encodeAuthSwitchResp();
  Buffer::InstancePtr client_switch_resp(new Buffer::OwnedImpl(auth_switch_resp));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_switch_resp, false));
  EXPECT_EQ(MySQLSession::State::AuthSwitchMore, filter_->getSession().getState());

  std::string srv_resp_ok_data = encodeClientLoginResp(MYSQL_RESP_OK, 1);
  Buffer::InstancePtr server_resp_ok_data(new Buffer::OwnedImpl(srv_resp_ok_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_ok_data, false));
  EXPECT_EQ(MySQLSession::State::Req, filter_->getSession().getState());
}

/**
 * Test MySQL Handshake with protocol version 320
 * Server responds with Auth Switch
 * SM: greeting(p=10) -> challenge-req(v320) -> serv-resp-auth-switch ->
 * -> auth_switch_resp -> serv-resp-auth-switch[error state]
 */
TEST_F(MySQLFilterTest, MySqlHandshake320AuthSwitchAuthSwitchTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_AUTH_SWITCH);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));

  std::string auth_switch_resp = encodeAuthSwitchResp();
  Buffer::InstancePtr client_switch_resp(new Buffer::OwnedImpl(auth_switch_resp));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_switch_resp, false));
  EXPECT_EQ(MySQLSession::State::AuthSwitchMore, filter_->getSession().getState());

  std::string srv_resp_ok_data = encodeClientLoginResp(MYSQL_RESP_AUTH_SWITCH, 1);
  Buffer::InstancePtr server_resp_ok_data(new Buffer::OwnedImpl(srv_resp_ok_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_ok_data, false));
  EXPECT_EQ(MySQLSession::State::NotHandled, filter_->getSession().getState());
}

/**
 * Test MySQL Handshake with protocol version 320
 * Server responds with Auth Switch and error
 * SM: greeting(p=10) -> challenge-req(v320) -> serv-resp-auth-switch ->
 * -> auth_switch_resp -> serv-resp-err
 */
TEST_F(MySQLFilterTest, MySqlHandshake320AuthSwitchErrTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_AUTH_SWITCH);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));

  std::string auth_switch_resp = encodeAuthSwitchResp();
  Buffer::InstancePtr client_switch_resp(new Buffer::OwnedImpl(auth_switch_resp));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_switch_resp, false));
  EXPECT_EQ(MySQLSession::State::AuthSwitchMore, filter_->getSession().getState());

  std::string srv_resp_ok_data = encodeClientLoginResp(MYSQL_RESP_ERR, 1);
  Buffer::InstancePtr server_resp_ok_data(new Buffer::OwnedImpl(srv_resp_ok_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_ok_data, false));
  EXPECT_EQ(MySQLSession::State::Resync, filter_->getSession().getState());

  Command mysql_cmd_encode{};
  mysql_cmd_encode.setCmd(Command::Cmd::Query);
  std::string query = "CREATE DATABASE mysqldb";
  mysql_cmd_encode.setData(query);
  Buffer::OwnedImpl client_query_data;

  mysql_cmd_encode.encode(client_query_data);
  BufferHelper::encodeHdr(client_query_data, 0);
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(client_query_data, false));
  EXPECT_EQ(MySQLSession::State::ReqResp, filter_->getSession().getState());
  EXPECT_EQ(1UL, config_->stats().queries_parsed_.value());
}

/**
 * Test MySQL Handshake with protocol version 320
 * Server responds with Auth Switch and error
 * SM: greeting(p=10) -> challenge-req(v320) -> serv-resp-auth-switch ->
 * -> auth_switch_resp -> incomplete response code
 */
TEST_F(MySQLFilterTest, MySqlHandshake320AuthSwitchIncompleteRespcode) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_AUTH_SWITCH);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));

  std::string auth_switch_resp = encodeAuthSwitchResp();
  Buffer::InstancePtr client_switch_resp(new Buffer::OwnedImpl(auth_switch_resp));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_switch_resp, false));
  EXPECT_EQ(MySQLSession::State::AuthSwitchMore, filter_->getSession().getState());

  std::string srv_resp_ok_data = encodeMessage(0, 1);
  Buffer::InstancePtr server_resp_ok_data(new Buffer::OwnedImpl(srv_resp_ok_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_ok_data, false));
  EXPECT_EQ(MySQLSession::State::NotHandled, filter_->getSession().getState());
}

/**
 * Resync Test failure MySQL Handshake with protocol version 320
 * Server responds with Auth Switch and error
 * SM: greeting(p=10) -> challenge-req(v320) -> serv-resp-auth-switch ->
 * -> auth_switch_resp -> serv-resp-err -> Resync fails
 */
TEST_F(MySQLFilterTest, MySqlHandshake320AuthSwitchErrFailResync) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_AUTH_SWITCH);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));

  std::string auth_switch_resp = encodeAuthSwitchResp();
  Buffer::InstancePtr client_switch_resp(new Buffer::OwnedImpl(auth_switch_resp));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_switch_resp, false));
  EXPECT_EQ(MySQLSession::State::AuthSwitchMore, filter_->getSession().getState());

  std::string srv_resp_ok_data = encodeClientLoginResp(MYSQL_RESP_ERR, 1);
  Buffer::InstancePtr server_resp_ok_data(new Buffer::OwnedImpl(srv_resp_ok_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_ok_data, false));
  EXPECT_EQ(MySQLSession::State::Resync, filter_->getSession().getState());

  Command mysql_cmd_encode{};
  mysql_cmd_encode.setCmd(Command::Cmd::Query);
  std::string query = "CREATE DATABASE mysqldb";
  mysql_cmd_encode.setData(query);
  Buffer::OwnedImpl client_query_data;
  mysql_cmd_encode.encode(client_query_data);
  BufferHelper::encodeHdr(client_query_data, 5);
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(client_query_data, false));
  EXPECT_EQ(MySQLSession::State::Resync, filter_->getSession().getState());
}

/**
 * Negative Testing MySQL Handshake with protocol version 320
 * Server responds with Auth Switch More
 * SM: greeting(p=10) -> challenge-req(v320) -> serv-resp-auth-switch ->
 * -> auth_switch_resp -> serv-resp-auth-switch-more
 */
TEST_F(MySQLFilterTest, MySqlHandshake320AuthSwitchMoreandMore) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_AUTH_SWITCH);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));

  std::string auth_switch_resp = encodeAuthSwitchResp();
  Buffer::InstancePtr client_switch_resp(new Buffer::OwnedImpl(auth_switch_resp));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_switch_resp, false));
  EXPECT_EQ(MySQLSession::State::AuthSwitchMore, filter_->getSession().getState());

  std::string srv_resp_ok_data = encodeClientLoginResp(MYSQL_RESP_MORE, 1);
  Buffer::InstancePtr server_resp_ok_data(new Buffer::OwnedImpl(srv_resp_ok_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_ok_data, false));
  EXPECT_EQ(MySQLSession::State::AuthSwitchResp, filter_->getSession().getState());
}

/**
 * Negative Testing MySQL Handshake with protocol version 320
 * Server responds with unhandled code
 * SM: greeting(p=10) -> challenge-req(v320) -> serv-resp-auth-switch ->
 * -> auth_switch_resp -> serv-resp-unhandled
 */
TEST_F(MySQLFilterTest, MySqlHandshake320AuthSwitchMoreandUnhandled) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_AUTH_SWITCH);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));

  std::string auth_switch_resp = encodeAuthSwitchResp();
  Buffer::InstancePtr client_switch_resp(new Buffer::OwnedImpl(auth_switch_resp));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_switch_resp, false));
  EXPECT_EQ(MySQLSession::State::AuthSwitchMore, filter_->getSession().getState());

  std::string srv_resp_ok_data = encodeClientLoginResp(0x32, 1);
  Buffer::InstancePtr server_resp_ok_data(new Buffer::OwnedImpl(srv_resp_ok_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_ok_data, false));
  EXPECT_EQ(MySQLSession::State::NotHandled, filter_->getSession().getState());
}

/**
 * Negative sequence
 * Test MySQL Handshake with protocol version 41
 * - send 2 back-to-back Greeting message (duplicated message)
 * -> expect filter to ignore the second.
 */
TEST_F(MySQLFilterTest, MySqlHandshake41Ok2GreetTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string greeting_data2 = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data2(new Buffer::OwnedImpl(greeting_data2));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data2, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());
  EXPECT_EQ(1UL, config_->stats().protocol_errors_.value());

  std::string clogin_data = encodeClientLogin(CLIENT_PROTOCOL_41, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(2UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp41, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));
  EXPECT_EQ(MySQLSession::State::Req, filter_->getSession().getState());
}

/**
 * Negative sequence
 * Test MySQL Handshake with protocol version 41
 * - send 2 back-to-back Challenge messages.
 * -> expect the filter to ignore the second
 */
TEST_F(MySQLFilterTest, MySqlHandshake41Ok2CloginTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(CLIENT_PROTOCOL_41, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp41, filter_->getSession().getState());

  std::string clogin_data2 = encodeClientLogin(CLIENT_PROTOCOL_41, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data2(new Buffer::OwnedImpl(clogin_data2));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data2, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp41, filter_->getSession().getState());
  EXPECT_EQ(1UL, config_->stats().protocol_errors_.value());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));
  EXPECT_EQ(MySQLSession::State::Req, filter_->getSession().getState());
}

/**
 * Negative sequence
 * Test MySQL Handshake with protocol version 41
 * - send out or order challenge and greeting messages.
 * -> expect the filter to ignore the challenge,
 *    since greeting was not seen
 */
TEST_F(MySQLFilterTest, MySqlHandshake41OkOOOLoginTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string clogin_data = encodeClientLogin(CLIENT_PROTOCOL_41, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(MySQLSession::State::Init, filter_->getSession().getState());
  EXPECT_EQ(1UL, config_->stats().protocol_errors_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());
}

/**
 * Negative sequence
 * Test MySQL Handshake with protocol version 41
 * - send out or order challenge and greeting messages
 *   followed by login ok
 * -> expect the filter to ignore initial challenge as well as
 *    serverOK because out of order
 */
TEST_F(MySQLFilterTest, MySqlHandshake41OkOOOFullLoginTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string clogin_data = encodeClientLogin(CLIENT_PROTOCOL_41, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(MySQLSession::State::Init, filter_->getSession().getState());
  EXPECT_EQ(1UL, config_->stats().protocol_errors_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());
  EXPECT_EQ(2UL, config_->stats().protocol_errors_.value());
}

/**
 * Negative sequence
 * Test MySQL Handshake with protocol version 41
 * - send greeting messages followed by login ok
 * -> expect filter to ignore serverOK, because it has not
 *    processed Challenge message
 */
TEST_F(MySQLFilterTest, MySqlHandshake41OkGreetingLoginOKTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());
  EXPECT_EQ(1UL, config_->stats_.protocol_errors_.value());
}

/**
 * Negative Testing
 * Test MySQL Handshake with protocol version 320
 * and wrong Client Login Sequence number
 */
TEST_F(MySQLFilterTest, MySqlHandshake320WrongCloginSeqTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", 2);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());
}

/**
 * Negative Testing
 * Test MySQL Handshake with protocol version 320
 * Server responds with Auth Switch wrong sequence
 * -> expect filter to ignore auth-switch message
 *    because of wrong seq.
 */
TEST_F(MySQLFilterTest, MySqlHandshake320AuthSwitchWrongSeqTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string auth_switch_resp = encodeAuthSwitchResp();
  Buffer::InstancePtr client_switch_resp(new Buffer::OwnedImpl(auth_switch_resp));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_switch_resp, false));
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_AUTH_SWITCH);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));
  EXPECT_EQ(MySQLSession::State::AuthSwitchResp, filter_->getSession().getState());

  std::string srv_resp_ok_data = encodeClientLoginResp(MYSQL_RESP_OK, 1);
  Buffer::InstancePtr server_resp_ok_data(new Buffer::OwnedImpl(srv_resp_ok_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_ok_data, false));
  EXPECT_EQ(MySQLSession::State::AuthSwitchResp, filter_->getSession().getState());
}

/**
 * Negative Testing
 * Test MySQL Handshake with protocol version 320
 * Server responds with unexpected code
 * -> expect filter to set state to not handled
 */
TEST_F(MySQLFilterTest, MySqlHandshake320WrongServerRespCode) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string srv_resp_ok_data = encodeClientLoginResp(0x53, 0);
  Buffer::InstancePtr server_resp_ok_data(new Buffer::OwnedImpl(srv_resp_ok_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_ok_data, false));
  EXPECT_EQ(MySQLSession::State::NotHandled, filter_->getSession().getState());

  Buffer::OwnedImpl client_query_data;
  BufferHelper::encodeHdr(client_query_data, 3);
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(client_query_data, false));
  EXPECT_EQ(MySQLSession::State::NotHandled, filter_->getSession().getState());
}

/**
 * Negative Testing
 * Invalid Mysql Pkt Hdr
 * -> expect filter to set state to not handled
 */
TEST_F(MySQLFilterTest, MySqlWrongHdrPkt) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(0, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp320, filter_->getSession().getState());

  std::string srv_resp_ok_data = encodeClientLoginResp(0x53, 0);
  Buffer::InstancePtr server_resp_ok_data(new Buffer::OwnedImpl(srv_resp_ok_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_ok_data, false));
  EXPECT_EQ(MySQLSession::State::NotHandled, filter_->getSession().getState());

  Buffer::OwnedImpl client_query_data("123");
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(client_query_data, false));
  EXPECT_EQ(MySQLSession::State::NotHandled, filter_->getSession().getState());
}

/*
 * Test Mysql query handler, after handshake completes
 * SM: greeting(p=10) -> challenge-req(v41) -> serv-resp-ok ->
 * -> Query-request -> Query-response
 * validate counters and state-machine
 */
TEST_F(MySQLFilterTest, MySqlLoginAndQueryTest) {
  initialize();

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onNewConnection());
  EXPECT_EQ(1UL, config_->stats().sessions_.value());

  std::string greeting_data = encodeServerGreeting(MYSQL_PROTOCOL_10);
  Buffer::InstancePtr greet_data(new Buffer::OwnedImpl(greeting_data));

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*greet_data, false));
  EXPECT_EQ(MySQLSession::State::ChallengeReq, filter_->getSession().getState());

  std::string clogin_data = encodeClientLogin(CLIENT_PROTOCOL_41, "user1", CHALLENGE_SEQ_NUM);
  Buffer::InstancePtr client_login_data(new Buffer::OwnedImpl(clogin_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*client_login_data, false));
  EXPECT_EQ(1UL, config_->stats().login_attempts_.value());
  EXPECT_EQ(MySQLSession::State::ChallengeResp41, filter_->getSession().getState());

  std::string srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK);
  Buffer::InstancePtr server_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*server_resp_data, false));
  EXPECT_EQ(MySQLSession::State::Req, filter_->getSession().getState());

  Command mysql_cmd_encode{};
  mysql_cmd_encode.setCmd(Command::Cmd::Query);
  std::string query = "CREATE DATABASE mysqldb";
  mysql_cmd_encode.setData(query);

  Buffer::OwnedImpl client_query_data;
  mysql_cmd_encode.encode(client_query_data);
  BufferHelper::encodeHdr(client_query_data, 0);
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(client_query_data, false));
  EXPECT_EQ(MySQLSession::State::ReqResp, filter_->getSession().getState());
  EXPECT_EQ(1UL, config_->stats().queries_parsed_.value());

  srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK, 0, 1);
  Buffer::InstancePtr request_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*request_resp_data, false));
  EXPECT_EQ(MySQLSession::State::ReqResp, filter_->getSession().getState());

  mysql_cmd_encode.setCmd(Command::Cmd::Query);
  query = "show databases";
  mysql_cmd_encode.setData(query);

  Buffer::OwnedImpl query_show;
  mysql_cmd_encode.encode(query_show);
  BufferHelper::encodeHdr(query_show, 0);
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(query_show, false));
  EXPECT_EQ(MySQLSession::State::ReqResp, filter_->getSession().getState());
  EXPECT_EQ(2UL, config_->stats().queries_parsed_.value());

  srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK, 0, 1);
  Buffer::InstancePtr show_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*show_resp_data, false));
  EXPECT_EQ(MySQLSession::State::ReqResp, filter_->getSession().getState());

  mysql_cmd_encode.setCmd(Command::Cmd::Query);
  query = "CREATE TABLE students (name TEXT, student_number INTEGER, city TEXT)";
  mysql_cmd_encode.setData(query);

  Buffer::OwnedImpl query_create;
  mysql_cmd_encode.encode(query_create);
  BufferHelper::encodeHdr(query_create, 0);

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(query_create, false));
  EXPECT_EQ(MySQLSession::State::ReqResp, filter_->getSession().getState());
  EXPECT_EQ(3UL, config_->stats().queries_parsed_.value());

  srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK, 0, 1);
  Buffer::InstancePtr create_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*create_resp_data, false));
  EXPECT_EQ(MySQLSession::State::ReqResp, filter_->getSession().getState());

  mysql_cmd_encode.setCmd(Command::Cmd::Query);
  query = "CREATE index index1";
  mysql_cmd_encode.setData(query);

  Buffer::OwnedImpl query_create_index;
  mysql_cmd_encode.encode(query_create_index);
  BufferHelper::encodeHdr(query_create_index, 0);

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(query_create_index, false));
  EXPECT_EQ(MySQLSession::State::ReqResp, filter_->getSession().getState());
  EXPECT_EQ(3UL, config_->stats().queries_parsed_.value());

  srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK, 0, 1);
  Buffer::InstancePtr create_index_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue,
            filter_->onData(*create_index_resp_data, false));
  EXPECT_EQ(MySQLSession::State::ReqResp, filter_->getSession().getState());

  mysql_cmd_encode.setCmd(Command::Cmd::FieldList);
  query = "";
  mysql_cmd_encode.setData(query);

  Buffer::OwnedImpl cmd_field_list;
  mysql_cmd_encode.encode(cmd_field_list);
  BufferHelper::encodeHdr(cmd_field_list, 0);

  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(cmd_field_list, false));
  EXPECT_EQ(MySQLSession::State::ReqResp, filter_->getSession().getState());
  EXPECT_EQ(3UL, config_->stats().queries_parsed_.value());

  srv_resp_data = encodeClientLoginResp(MYSQL_RESP_OK, 0, 1);
  Buffer::InstancePtr field_list_resp_data(new Buffer::OwnedImpl(srv_resp_data));
  EXPECT_EQ(Envoy::Network::FilterStatus::Continue, filter_->onData(*field_list_resp_data, false));
  EXPECT_EQ(MySQLSession::State::ReqResp, filter_->getSession().getState());
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include <functional>

#include "source/common/buffer/buffer_impl.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_utils.h"
#include "gtest/gtest.h"
#include "mysql_test_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

namespace {
ClientLogin initClientLogin() {
  ClientLogin mysql_clogin_encode{};
  mysql_clogin_encode.setMaxPacket(MYSQL_MAX_PACKET);
  mysql_clogin_encode.setCharset(MYSQL_CHARSET);
  mysql_clogin_encode.setUsername("user1");
  mysql_clogin_encode.setAuthResp(MySQLTestUtils::getAuthResp8());
  mysql_clogin_encode.setDb(MySQLTestUtils::getDb());
  mysql_clogin_encode.setAuthPluginName(MySQLTestUtils::getAuthPluginName());
  mysql_clogin_encode.addConnectionAttribute({"key", "val"});
  return mysql_clogin_encode;
}
}; // namespace

class MySQLCLoginTest : public testing::Test {
public:
  static ClientLogin& getClientLogin(uint16_t base_cap, uint16_t ext_cap) {
    client_login.setBaseClientCap(base_cap);
    client_login.setExtendedClientCap(ext_cap);
    return client_login;
  }
  static ClientLogin& getClientLogin(uint32_t cap) {
    return getClientLogin(cap & 0xffff, cap >> 16);
  }

private:
  static ClientLogin client_login;
};

ClientLogin MySQLCLoginTest::client_login = initClientLogin();
/*
 * Test the MYSQL Client Login 41 message parser:
 * - message is encoded using the ClientLogin class
 *   - CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA set
 * - message is decoded using the ClientLogin class
 */
TEST_F(MySQLCLoginTest, MySQLClLoginV41PluginAuthEncDec) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(
      CLIENT_CONNECT_WITH_DB | CLIENT_PROTOCOL_41 | CLIENT_PLUGIN_AUTH);

  Buffer::OwnedImpl decode_data;
  mysql_clogin_encode.encode(decode_data);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isConnectWithDb());
  EXPECT_EQ(mysql_clogin_decode.isResponse41(), true);
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getBaseClientCap(), mysql_clogin_encode.getBaseClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), mysql_clogin_encode.getCharset());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp(), mysql_clogin_encode.getAuthResp());
  EXPECT_EQ(mysql_clogin_decode.getDb(), mysql_clogin_encode.getDb());
  EXPECT_EQ(mysql_clogin_decode.getAuthPluginName(), mysql_clogin_encode.getAuthPluginName());
}

/*
 * Test the MYSQL Client Login 41 message parser:
 * - message is encoded using the ClientLogin class
 *   - CLIENT_SECURE_CONNECTION set
 * - message is decoded using the ClientLogin class
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41SecureConnEncDec) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(
      CLIENT_CONNECT_WITH_DB | CLIENT_PROTOCOL_41 | CLIENT_SECURE_CONNECTION);

  Buffer::OwnedImpl decode_data;
  mysql_clogin_encode.encode(decode_data);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isConnectWithDb());
  EXPECT_TRUE(mysql_clogin_decode.isClientSecureConnection());
  EXPECT_EQ(mysql_clogin_decode.isResponse41(), true);
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getBaseClientCap(), mysql_clogin_encode.getBaseClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), mysql_clogin_encode.getCharset());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp(), mysql_clogin_encode.getAuthResp());
  EXPECT_EQ(mysql_clogin_decode.getDb(), mysql_clogin_encode.getDb());
  EXPECT_EQ(mysql_clogin_decode.getAuthPluginName(), "");
}

/*
 * Test the MYSQL Client Login 41 message parser when CLIENT_SECURE_CONNECTION set
 * - Incomplete auth len
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41SecureConnIncompleteAuthLen) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(
      CLIENT_CONNECT_WITH_DB | CLIENT_PROTOCOL_41 | CLIENT_SECURE_CONNECTION);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getClientCap()) +
                       sizeof(mysql_clogin_encode.getMaxPacket()) +
                       sizeof(mysql_clogin_encode.getCharset()) + UNSET_BYTES +
                       mysql_clogin_encode.getUsername().size() + 1;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);
  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isConnectWithDb());
  EXPECT_TRUE(mysql_clogin_decode.isClientSecureConnection());
  EXPECT_EQ(mysql_clogin_decode.isResponse41(), true);
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getBaseClientCap(), mysql_clogin_encode.getBaseClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), mysql_clogin_encode.getCharset());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp().size(), 0);
}

/*
 * Test the MYSQL Client Login 41 message parser when CLIENT_SECURE_CONNECTION set
 * - Incomplete auth resp
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41SecureConnIncompleteAuthResp) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(
      CLIENT_CONNECT_WITH_DB | CLIENT_PROTOCOL_41 | CLIENT_SECURE_CONNECTION);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getClientCap()) +
                       sizeof(mysql_clogin_encode.getMaxPacket()) +
                       sizeof(mysql_clogin_encode.getCharset()) + UNSET_BYTES +
                       mysql_clogin_encode.getUsername().size() + 1 + 1;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);
  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isConnectWithDb());
  EXPECT_TRUE(mysql_clogin_decode.isClientSecureConnection());
  EXPECT_EQ(mysql_clogin_decode.isResponse41(), true);
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getBaseClientCap(), mysql_clogin_encode.getBaseClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), mysql_clogin_encode.getCharset());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp().size(), 0);
}

/*
 * Test the MYSQL Client Login 41 message parser
 * - Incomplete auth resp
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41IncompleteAuthResp) {
  ClientLogin& mysql_clogin_encode =
      MySQLCLoginTest::getClientLogin(CLIENT_CONNECT_WITH_DB | CLIENT_PROTOCOL_41);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getClientCap()) +
                       sizeof(mysql_clogin_encode.getMaxPacket()) +
                       sizeof(mysql_clogin_encode.getCharset()) + UNSET_BYTES +
                       mysql_clogin_encode.getUsername().size() + 1;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);
  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isConnectWithDb());
  EXPECT_EQ(mysql_clogin_decode.isResponse41(), true);
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getBaseClientCap(), mysql_clogin_encode.getBaseClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), mysql_clogin_encode.getCharset());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp().size(), 0);
}

/*
 * Test the MYSQL Client Login 41 message parser without CLIENT_CONNECT_WITH_DB:
 * - message is encoded using the ClientLogin class
 * - message is decoded using the ClientLogin class
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41EncDec) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(
      CLIENT_PROTOCOL_41 | CLIENT_CONNECT_WITH_DB | CLIENT_CONNECT_ATTRS);
  Buffer::OwnedImpl decode_data;
  mysql_clogin_encode.encode(decode_data);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isConnectWithDb());
  EXPECT_EQ(mysql_clogin_decode.isResponse41(), true);
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getBaseClientCap(), mysql_clogin_encode.getBaseClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), mysql_clogin_encode.getCharset());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp(), mysql_clogin_encode.getAuthResp());
  EXPECT_EQ(mysql_clogin_decode.getConnectionAttribute(),
            mysql_clogin_encode.getConnectionAttribute());
  EXPECT_TRUE(mysql_clogin_decode.getAuthPluginName().empty());
}

/*
 * Test the MYSQL Client Login 320 message parser:
 * - message is encoded using the ClientLogin class
 * - message is decoded using the ClientLogin class
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin320EncDec) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(0);

  Buffer::OwnedImpl decode_data;
  mysql_clogin_encode.encode(decode_data);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_clogin_decode.isResponse320(), true);
  EXPECT_EQ(mysql_clogin_decode.getBaseClientCap(), mysql_clogin_encode.getBaseClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp(), mysql_clogin_encode.getAuthResp());

  EXPECT_EQ(mysql_clogin_decode.getAuthPluginName(), "");
  EXPECT_EQ(mysql_clogin_decode.getDb(), "");
  EXPECT_EQ(mysql_clogin_decode.getCharset(), 0);
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), 0);
}

TEST_F(MySQLCLoginTest, MySQLParseLengthEncodedInteger) {
  Buffer::OwnedImpl buffer;
  {
    // encode 2 byte value
    buffer.drain(buffer.length());
    uint64_t input_val = 5;
    uint64_t output_val = 0;
    BufferHelper::addUint8(buffer, LENENCODINT_2BYTES);
    BufferHelper::addUint16(buffer, input_val);
    EXPECT_EQ(BufferHelper::readLengthEncodedInteger(buffer, output_val), DecodeStatus::Success);
    EXPECT_EQ(input_val, output_val);
  }
  {
    // encode 3 byte value
    buffer.drain(buffer.length());
    uint64_t input_val = 5;
    uint64_t output_val = 0;
    BufferHelper::addUint8(buffer, LENENCODINT_3BYTES);
    BufferHelper::addUint16(buffer, input_val);
    BufferHelper::addUint8(buffer, 0);
    EXPECT_EQ(BufferHelper::readLengthEncodedInteger(buffer, output_val), DecodeStatus::Success);
    EXPECT_EQ(input_val, output_val);
  }

  {
    // encode 8 byte value
    buffer.drain(buffer.length());
    uint64_t input_val = 5;
    uint64_t output_val = 0;
    BufferHelper::addUint8(buffer, LENENCODINT_8BYTES);
    BufferHelper::addUint32(buffer, input_val);
    BufferHelper::addUint32(buffer, 0);
    EXPECT_EQ(BufferHelper::readLengthEncodedInteger(buffer, output_val), DecodeStatus::Success);
    EXPECT_EQ(input_val, output_val);
  }

  {
    // encode invalid length header
    buffer.drain(buffer.length());
    uint64_t input_val = 5;
    uint64_t output_val = 0;
    BufferHelper::addUint8(buffer, 0xff);
    BufferHelper::addUint32(buffer, input_val);
    EXPECT_EQ(BufferHelper::readLengthEncodedInteger(buffer, output_val), DecodeStatus::Failure);
  }
  {
    // encode and decode length encoded integer
    uint64_t input_vals[4] = {
        5,
        251 + 5,
        (1 << 16) + 5,
        (1 << 24) + 5,
    };
    for (uint64_t& input_val : input_vals) {
      buffer.drain(buffer.length());
      uint64_t output_val = 0;
      BufferHelper::addLengthEncodedInteger(buffer, input_val);
      BufferHelper::readLengthEncodedInteger(buffer, output_val);
      EXPECT_EQ(input_val, output_val);
    }
  }
  {
    // encode decode uint24
    buffer.drain(buffer.length());
    uint32_t val = 0xfffefd;
    BufferHelper::addUint32(buffer, val);
    uint32_t res = 0;
    BufferHelper::readUint24(buffer, res);
    EXPECT_EQ(val, res);
  }
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete base client cap
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41IncompleteBaseClientCap) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(CLIENT_PROTOCOL_41);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int client_cap_len = sizeof(uint8_t);
  Buffer::OwnedImpl decode_data(buffer.toString().data(), client_cap_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_clogin_decode.getBaseClientCap(), 0);
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete ext client cap
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41IncompleteExtClientCap) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(CLIENT_PROTOCOL_41);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int client_cap_len = sizeof(uint16_t);
  Buffer::OwnedImpl decode_data(buffer.toString().data(), client_cap_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_clogin_decode.getBaseClientCap(), mysql_clogin_decode.getBaseClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), 0);
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete header at Max Packet
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41IncompleteMaxPacket) {
  ClientLogin& mysql_clogin_encode =
      MySQLCLoginTest::getClientLogin(CLIENT_PROTOCOL_41 | CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getClientCap());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isClientAuthLenClData());

  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getBaseClientCap(), mysql_clogin_encode.getBaseClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), 0);
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete header at Charset
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41IncompleteCharset) {
  ClientLogin& mysql_clogin_encode =
      MySQLCLoginTest::getClientLogin(CLIENT_PROTOCOL_41 | CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_clogin_encode.getClientCap()) + sizeof(mysql_clogin_encode.getMaxPacket());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isClientAuthLenClData());

  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), 0);
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete header at Unset bytes
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41IncompleteUnsetBytes) {
  ClientLogin& mysql_clogin_encode =
      MySQLCLoginTest::getClientLogin(CLIENT_PROTOCOL_41 | CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getClientCap()) +
                       sizeof(mysql_clogin_encode.getMaxPacket()) +
                       sizeof(mysql_clogin_encode.getCharset());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isClientAuthLenClData());

  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), mysql_clogin_encode.getCharset());
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete header at username
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41IncompleteUser) {
  ClientLogin& mysql_clogin_encode =
      MySQLCLoginTest::getClientLogin(CLIENT_PROTOCOL_41 | CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getClientCap()) +
                       sizeof(mysql_clogin_encode.getMaxPacket()) +
                       sizeof(mysql_clogin_encode.getCharset()) + UNSET_BYTES;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isClientAuthLenClData());

  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), mysql_clogin_encode.getCharset());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), "");
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete header at auth data length
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41IncompleteAuthLen) {
  ClientLogin& mysql_clogin_encode =
      MySQLCLoginTest::getClientLogin(CLIENT_PROTOCOL_41 | CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getClientCap()) +
                       sizeof(mysql_clogin_encode.getMaxPacket()) +
                       sizeof(mysql_clogin_encode.getCharset()) + UNSET_BYTES +
                       mysql_clogin_encode.getUsername().size() + 1;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isClientAuthLenClData());
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), mysql_clogin_encode.getCharset());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp().size(), 0);
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete header at auth response
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41IncompleteAuthPasswd) {
  ClientLogin& mysql_clogin_encode =
      MySQLCLoginTest::getClientLogin(CLIENT_PROTOCOL_41 | CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_clogin_encode.getClientCap()) + sizeof(mysql_clogin_encode.getMaxPacket()) +
      sizeof(mysql_clogin_encode.getCharset()) + UNSET_BYTES +
      mysql_clogin_encode.getUsername().size() + 1 +
      MySQLTestUtils::sizeOfLengthEncodeInteger(mysql_clogin_encode.getAuthResp().size());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  ;
  EXPECT_TRUE(mysql_clogin_decode.isClientAuthLenClData());

  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), mysql_clogin_encode.getCharset());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp().size(), 0);
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete header at db name
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41IncompleteDbName) {
  ClientLogin& mysql_clogin_encode =
      MySQLCLoginTest::getClientLogin(CLIENT_PROTOCOL_41 | CLIENT_CONNECT_WITH_DB);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_clogin_encode.getClientCap()) + sizeof(mysql_clogin_encode.getMaxPacket()) +
      sizeof(mysql_clogin_encode.getCharset()) + UNSET_BYTES +
      mysql_clogin_encode.getUsername().size() + 1 + mysql_clogin_encode.getAuthResp().size() + 1;

  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);
  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isConnectWithDb());
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), mysql_clogin_encode.getCharset());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp(), mysql_clogin_encode.getAuthResp());
  EXPECT_EQ(mysql_clogin_decode.getDb(), "");
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete header at auth plugin name
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin41IncompleteAuthPluginName) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(
      CLIENT_PROTOCOL_41 | CLIENT_CONNECT_WITH_DB | CLIENT_PLUGIN_AUTH);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_clogin_encode.getClientCap()) + sizeof(mysql_clogin_encode.getMaxPacket()) +
      sizeof(mysql_clogin_encode.getCharset()) + UNSET_BYTES +
      mysql_clogin_encode.getUsername().size() + 1 + mysql_clogin_encode.getAuthResp().size() + 1 +
      mysql_clogin_encode.getDb().size() + 1;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isConnectWithDb());

  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), mysql_clogin_encode.getCharset());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp(), mysql_clogin_encode.getAuthResp());
  EXPECT_EQ(mysql_clogin_decode.getDb(), mysql_clogin_encode.getDb());
  EXPECT_EQ(mysql_clogin_decode.getAuthPluginName(), "");
}

class MySQL41LoginConnAttrTest : public MySQLCLoginTest {
public:
  MySQL41LoginConnAttrTest() {
    login_encode_ = MySQLCLoginTest::getClientLogin(CLIENT_PROTOCOL_41 | CLIENT_CONNECT_WITH_DB |
                                                    CLIENT_PLUGIN_AUTH | CLIENT_CONNECT_ATTRS);
    incomplete_base_len_ =
        sizeof(login_encode_.getClientCap()) + sizeof(login_encode_.getMaxPacket()) +
        sizeof(login_encode_.getCharset()) + UNSET_BYTES + login_encode_.getUsername().size() + 1 +
        login_encode_.getAuthResp().size() + 1 + login_encode_.getDb().size() + 1 +
        login_encode_.getAuthPluginName().length() + 1;
  }

  void prepareLoginDecode(int delta_len = 0) {
    Buffer::OwnedImpl buffer;
    login_encode_.encode(buffer);
    int incomplete_len = incomplete_base_len_ + delta_len;
    Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

    login_decode_.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  }

  void checkLoginDecode(const std::function<void()>& additional_check = nullptr) {
    EXPECT_TRUE(login_decode_.isConnectWithDb());
    EXPECT_EQ(login_decode_.getClientCap(), login_encode_.getClientCap());
    EXPECT_EQ(login_decode_.getExtendedClientCap(), login_decode_.getExtendedClientCap());
    EXPECT_EQ(login_decode_.getMaxPacket(), login_encode_.getMaxPacket());
    EXPECT_EQ(login_decode_.getCharset(), login_encode_.getCharset());
    EXPECT_EQ(login_decode_.getUsername(), login_encode_.getUsername());
    EXPECT_EQ(login_decode_.getAuthResp(), login_encode_.getAuthResp());
    EXPECT_EQ(login_decode_.getDb(), login_encode_.getDb());
    EXPECT_EQ(login_decode_.getAuthPluginName(), login_encode_.getAuthPluginName());
    if (additional_check != nullptr) {
      additional_check();
    }
  }
  const ClientLogin& loginEncode() const { return login_encode_; }
  const ClientLogin& loginDecode() const { return login_decode_; }

private:
  ClientLogin login_encode_;
  ClientLogin login_decode_;
  int incomplete_base_len_;
};

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete total length of connection attributions
 */
TEST_F(MySQL41LoginConnAttrTest, MySQLClientLogin41IncompleteConnAttrLength) {
  prepareLoginDecode();
  checkLoginDecode([&]() { EXPECT_EQ(loginDecode().getConnectionAttribute().size(), 0); });
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete length of connection attribution key
 */
TEST_F(MySQL41LoginConnAttrTest, MySQLClientLogin41IncompleteConnAttrKeyLength) {
  prepareLoginDecode(
      MySQLTestUtils::bytesOfConnAtrributeLength(loginEncode().getConnectionAttribute()));

  checkLoginDecode([&]() { EXPECT_EQ(loginDecode().getConnectionAttribute().size(), 0); });
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete connection attribution key
 */
TEST_F(MySQL41LoginConnAttrTest, MySQLClientLogin41IncompleteConnAttrKey) {
  prepareLoginDecode(
      MySQLTestUtils::bytesOfConnAtrributeLength(loginEncode().getConnectionAttribute()) +
      MySQLTestUtils::sizeOfLengthEncodeInteger(
          loginEncode().getConnectionAttribute()[0].first.length()));
  checkLoginDecode([&]() { EXPECT_EQ(loginDecode().getConnectionAttribute().size(), 0); });
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete length of connection attribution val
 */
TEST_F(MySQL41LoginConnAttrTest, MySQLClientLogin41IncompleteConnAttrValLength) {
  prepareLoginDecode(
      MySQLTestUtils::bytesOfConnAtrributeLength(loginEncode().getConnectionAttribute()) +
      MySQLTestUtils::sizeOfLengthEncodeInteger(
          loginEncode().getConnectionAttribute()[0].first.length()) +
      loginEncode().getConnectionAttribute()[0].first.length());
  checkLoginDecode([&]() { EXPECT_EQ(loginDecode().getConnectionAttribute().size(), 0); });
}

/*
 * Negative Test the MYSQL Client Login 41 message parser:
 * Incomplete connection attribution val
 */
TEST_F(MySQL41LoginConnAttrTest, MySQLClientLogin41IncompleteConnAttrVal) {
  prepareLoginDecode(
      MySQLTestUtils::bytesOfConnAtrributeLength(loginEncode().getConnectionAttribute()) +
      MySQLTestUtils::sizeOfLengthEncodeInteger(
          loginEncode().getConnectionAttribute()[0].first.length()) +
      loginEncode().getConnectionAttribute()[0].first.length() +
      MySQLTestUtils::sizeOfLengthEncodeInteger(
          loginEncode().getConnectionAttribute()[0].second.length()));
  checkLoginDecode([&]() { EXPECT_EQ(loginDecode().getConnectionAttribute().size(), 0); });
}

/*
 * Negative Test the MYSQL Client 320 login message parser:
 * Incomplete header at cap
 */
TEST_F(MySQLCLoginTest, MySQLClient320LoginIncompleteClientCap) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(CLIENT_CONNECT_WITH_DB);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = 0;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), 0);
}

/*
 * Negative Test the MYSQL Client 320 login message parser:
 * Incomplete max packet
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin320IncompleteMaxPacketSize) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(0);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getBaseClientCap());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), 0);
}

/*
 * Negative Test the MYSQL Client login 320 message parser:
 * Incomplete username
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin320IncompleteUsername) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(0);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getBaseClientCap()) + sizeof(uint8_t) * 3;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), "");
}

/*
 * Negative Test the MYSQL Client login 320 message parser:
 * Incomplete auth response
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin320IncompleteAuthResp) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(0);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getBaseClientCap()) + sizeof(uint8_t) * 3 +
                       mysql_clogin_encode.getUsername().size() + 1;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp().size(), 0);
}

/*
 * Negative Test the MYSQL Client login 320 with CLIENT_CONNECT_WITH_DB message parser:
 * Incomplete auth response
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin320WithDbIncompleteAuthResp) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(CLIENT_CONNECT_WITH_DB);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getBaseClientCap()) + sizeof(uint8_t) * 3 +
                       mysql_clogin_encode.getUsername().size() + 1;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isConnectWithDb());

  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp().size(), 0);
}

/*
 * Negative Test the MYSQL Client login 320 with CLIENT_CONNECT_WITH_DB message parser:
 * Incomplete db name
 */
TEST_F(MySQLCLoginTest, MySQLClientLogin320WithDbIncompleteDb) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(CLIENT_CONNECT_WITH_DB);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getBaseClientCap()) + sizeof(uint8_t) * 3 +
                       mysql_clogin_encode.getUsername().size() + 1 +
                       mysql_clogin_encode.getAuthResp().size() + 1;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isConnectWithDb());
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getUsername(), mysql_clogin_encode.getUsername());
  EXPECT_EQ(mysql_clogin_decode.getAuthResp(), mysql_clogin_encode.getAuthResp());
  EXPECT_EQ(mysql_clogin_decode.getDb(), "");
}

/*
 * Test the MYSQL Client Login SSL message parser:
 * - message is encoded using the ClientLogin class
 * - message is decoded using the ClientLogin class
 */
TEST_F(MySQLCLoginTest, MySQLClientLoginSSLEncDec) {
  ClientLogin& mysql_clogin_encode =
      MySQLCLoginTest::getClientLogin(CLIENT_SSL | CLIENT_PROTOCOL_41 | CLIENT_PLUGIN_AUTH);
  ;

  Buffer::OwnedImpl decode_data;
  mysql_clogin_encode.encode(decode_data);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_clogin_decode.isSSLRequest(), true);
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
}

/*
 * Negative Test the MYSQL Client login SSL message parser:
 * Incomplete cap flag
 */
TEST_F(MySQLCLoginTest, MySQLClientLoginSslIncompleteCap) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(CLIENT_SSL);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getClientCap()) - 1;
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), 0);
}

/*
 * Negative Test the MYSQL Client login SSL message parser:
 * Incomplete max packet
 */
TEST_F(MySQLCLoginTest, MySQLClientLoginSslIncompleteMaxPacket) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(CLIENT_SSL);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getClientCap());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_TRUE(mysql_clogin_decode.isSSLRequest());
  EXPECT_EQ(mysql_clogin_decode.getExtendedClientCap(), mysql_clogin_encode.getExtendedClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), 0);
}

/*
 * Negative Test the MYSQL Client login SSL message parser:
 * Incomplete character set
 */
TEST_F(MySQLCLoginTest, MySQLClientLoginSslIncompleteCharset) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(CLIENT_SSL);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len =
      sizeof(mysql_clogin_encode.getClientCap()) + sizeof(mysql_clogin_encode.getMaxPacket());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), 0);
}

/*
 * Negative Test the MYSQL Client login SSL message parser:
 * Incomplete reserved
 */
TEST_F(MySQLCLoginTest, MySQLClientLoginSslIncompleteReserved) {
  ClientLogin& mysql_clogin_encode = MySQLCLoginTest::getClientLogin(CLIENT_SSL);
  Buffer::OwnedImpl buffer;
  mysql_clogin_encode.encode(buffer);

  int incomplete_len = sizeof(mysql_clogin_encode.getClientCap()) +
                       sizeof(mysql_clogin_encode.getMaxPacket()) +
                       sizeof(mysql_clogin_encode.getCharset());
  Buffer::OwnedImpl decode_data(buffer.toString().data(), incomplete_len);

  ClientLogin mysql_clogin_decode{};
  mysql_clogin_decode.decode(decode_data, CHALLENGE_SEQ_NUM, decode_data.length());
  EXPECT_EQ(mysql_clogin_decode.getClientCap(), mysql_clogin_encode.getClientCap());
  EXPECT_EQ(mysql_clogin_decode.getMaxPacket(), mysql_clogin_encode.getMaxPacket());
  EXPECT_EQ(mysql_clogin_decode.getCharset(), mysql_clogin_encode.getCharset());
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once
#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "fmt/format.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

constexpr int MYSQL_VER_MAJOR = 5;
constexpr int MYSQL_VER_MINOR = 0;
constexpr int MYSQL_VER_VAR = 54;
constexpr int MYSQL_SM_LAST_ID = 0;
constexpr int MYSQL_SM_SERVER_OK = 0;
constexpr int MYSQL_SM_SERVER_WARNINGS = 0x0001;
constexpr int MYSQL_SM_AFFECTED_ROWS = 1;
constexpr int CLIENT_NUM = 10;
constexpr int PARALLEL_SESSIONS = 4;
constexpr uint32_t MYSQL_SERVER_CAP_AUTH_PLUGIN = 0x00080000;
constexpr uint32_t MYSQL_SERVER_SECURE_CONNECTION = 0x00008000;
constexpr uint16_t MYSQL_ERROR_CODE = MYSQL_CR_AUTH_PLUGIN_ERR;

class MySQLTestUtils {

public:
  static std::vector<uint8_t> getAuthPluginData8() { return getAuthResp8(); }
  static std::vector<uint8_t> getAuthPluginData20() { return getAuthResp20(); }
  static std::vector<uint8_t> getAuthResp8() { return std::vector<uint8_t>(8, 0xff); }
  static std::vector<uint8_t> getAuthResp20() { return std::vector<uint8_t>(20, 0xff); }
  static std::string getVersion() {
    return fmt::format("{0}.{1}.{2}", MYSQL_VER_MAJOR, MYSQL_VER_MINOR, MYSQL_VER_VAR);
  }
  static std::string getSqlState() { return "HY000"; }
  static std::string getErrorMessage() { return "auth failed"; }
  static std::string getAuthPluginName() { return "mysql_native_password"; }
  static std::string getDb() { return "mysql.db"; }
  static std::string getCommandResponse() { return "command response"; }
  static std::string getInfo() { return "info"; }
  static int
  bytesOfConnAtrributeLength(const std::vector<std::pair<std::string, std::string>>& conn);
  static int sizeOfLengthEncodeInteger(uint64_t val);

  std::string encodeServerGreeting(int protocol);
  std::string encodeClientLogin(uint16_t client_cap, std::string user, uint8_t seq);
  std::string encodeClientLoginResp(uint8_t srv_resp, uint8_t it = 0, uint8_t seq_force = 0);
  std::string encodeAuthSwitchResp();

  std::string encodeMessage(uint32_t packet_len, uint8_t it = 0, uint8_t seq_force = 0);
};
} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_switch_resp.h"
#include "gtest/gtest.h"
#include "mysql_test_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

TEST(MySQLAuthSwithRespTest, AuthSwithResp) {
  ClientSwitchResponse switch_resp_encode{};
  switch_resp_encode.setAuthPluginResp(MySQLTestUtils::getAuthResp8());
  Buffer::OwnedImpl decode_data;
  switch_resp_encode.encode(decode_data);

  ClientSwitchResponse switch_resp_decode{};
  switch_resp_decode.decode(decode_data, AUTH_SWITH_RESP_SEQ, decode_data.length());
  EXPECT_EQ(switch_resp_encode.getAuthPluginResp(), switch_resp_decode.getAuthPluginResp());
}

TEST(MySQLAuthSwithRespTest, AuthSwithRespErrLengthResp) {
  ClientSwitchResponse switch_resp_encode{};
  switch_resp_encode.setAuthPluginResp(MySQLTestUtils::getAuthResp8());
  Buffer::OwnedImpl buffer;
  switch_resp_encode.encode(buffer);
  Buffer::OwnedImpl decode_data(buffer.toString().data(), 0);
  ClientSwitchResponse switch_resp_decode{};
  switch_resp_decode.decode(decode_data, AUTH_SWITH_RESP_SEQ, -1);
  EXPECT_EQ(switch_resp_decode.getAuthPluginResp().size(), 0);
}
} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "source/common/buffer/buffer_impl.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin_resp.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_command.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_greeting.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_utils.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "include/sqlparser/SQLParser.h"
#include "mysql_test_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

class MySQLCommandTest : public testing::Test, public MySQLTestUtils {
public:
  DecodeStatus encodeQuery(std::string query, hsql::SQLParserResult& result) {
    Command mysql_cmd_encode{};
    Command mysql_cmd_decode{};
    uint8_t seq = 0u;
    uint32_t len;
    mysql_cmd_encode.setCmd(Command::Cmd::Query);
    mysql_cmd_encode.setData(query);

    Buffer::OwnedImpl decode_data;
    mysql_cmd_encode.encode(decode_data);
    BufferHelper::encodeHdr(decode_data, 0);

    if (BufferHelper::peekHdr(decode_data, len, seq) != DecodeStatus::Success) {
      return DecodeStatus::Failure;
    }
    BufferHelper::consumeHdr(decode_data);
    if (mysql_cmd_decode.decode(decode_data, seq, len) != DecodeStatus::Success) {
      return DecodeStatus::Failure;
    }
    hsql::SQLParser::parse(mysql_cmd_decode.getData(), &result);
    return DecodeStatus::Success;
  }

  enum TestResource {
    TABLE,
    DB,
    SCHEMA,
    EVENT,
    INDEX,
  };

  const std::string SPACE = " ";
  const std::string FROM = "FROM ";
  const std::string INTO = "INTO ";
  const std::string IF_EXISTS = "IF EXISTS ";
  const std::string IF_NOT_EXISTS = "IF NOT EXISTS ";

  std::string buildShow(std::string resource) {
    std::string command("SHOW ");
    command.append(resource);
    return command;
  }

  std::string buildUse(std::string db) {
    std::string command("USE ");
    command.append(db);
    return command;
  }

  // CREATE table
  std::string buildCreate(enum TestResource res, std::string option, bool if_not_exists,
                          std::string res_name, std::string value) {
    std::string command("CREATE ");
    if (!option.empty()) {
      command.append(option);
      command.append(SPACE);
    }
    switch (res) {
    case TABLE:
      command.append("TABLE ");
      break;
    case DB:
      command.append("DATABASE ");
      break;
    case EVENT:
      command.append("EVENT ");
      break;
    case INDEX:
      command.append("INDEX ");
      break;
    default:
      return command;
    }
    if (if_not_exists) {
      command.append(IF_NOT_EXISTS);
    }
    command.append(res_name);
    command.append(SPACE);
    command.append(value);
    return command;
  }

  // ALTER a resource
  std::string buildAlter(enum TestResource res, std::string res_name, std::string values) {
    std::string command("ALTER ");
    switch (res) {
    case TABLE:
      command.append("TABLE ");
      break;
    case DB:
      command.append("DATABASE ");
      break;
    case SCHEMA:
      command.append("SCHEMA ");
      break;
    default:
      return command;
    }
    command.append(res_name);
    command.append(SPACE);
    command.append(values);
    return command;
  }

  // UPDATE
  std::string buildUpdate(std::string table, std::string option, std::string set_value) {
    std::string command("UPDATE ");
    command.append(option);
    command.append(SPACE);
    command.append(table);
    command.append(SPACE);
    command.append(set_value);
    return command;
  }

  // DROP Resource
  std::string buildDrop(enum TestResource res, bool if_exists, std::string res_name) {
    std::string command("DROP ");
    switch (res) {
    case TABLE:
      command.append("TABLE ");
      break;
    case DB:
      command.append("DATABASE ");
      break;
    case EVENT:
      command.append("SCHEMA ");
      break;
    default:
      return command;
    }
    if (if_exists) {
      command.append(IF_EXISTS);
    }
    command.append(res_name);
    return command;
  }

  //"INSERT INTO <table> ...
  std::string buildInsert(std::string option, bool into, std::string table, std::string values) {
    std::string command("INSERT ");
    if (!option.empty()) {
      command.append(option);
      command.append(SPACE);
    }
    if (into) {
      command.append(INTO);
    }
    command.append(table);
    command.append(SPACE);
    command.append(values);
    return command;
  }

  // DELETE FROM <table> ...
  std::string buildDelete(std::string option, std::string table, std::string values) {
    std::string command("DELETE ");
    command.append(option);
    command.append(SPACE);
    command.append(FROM);
    command.append(table);
    command.append(SPACE);
    command.append(values);
    return command;
  }

  // SELECT FROM <table> ...
  std::string buildSelect(std::string select_fields, std::string table, std::string where_clause) {
    std::string command("SELECT ");
    command.append(select_fields);
    command.append(SPACE);
    command.append(FROM);
    command.append(table);
    command.append(SPACE);
    command.append(where_clause);
    return command;
  }

  void expectStatementTypeAndTableAccessMap(const hsql::SQLParserResult& result,
                                            hsql::StatementType statement_type,
                                            const hsql::TableAccessMap& expected_table_access_map) {
    EXPECT_TRUE(result.isValid());
    EXPECT_EQ(1UL, result.size());
    EXPECT_EQ(statement_type, result.getStatement(0)->type());
    hsql::TableAccessMap table_access_map;
    if (expected_table_access_map.empty() && (statement_type == hsql::StatementType::kStmtShow)) {
      return;
    }
    result.getStatement(0)->tablesAccessed(table_access_map);
    EXPECT_EQ(table_access_map, expected_table_access_map);
  }
};

/*
 * Tests query: "show databases"
 */
TEST_F(MySQLCommandTest, MySQLTest1) {
  std::string command = buildShow("databases");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtShow, {});
}

/*
 * Tests query: "show tables"
 */
TEST_F(MySQLCommandTest, MySQLTest2) {
  std::string command = buildShow("tables");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtShow, {});
}

/*
 * "CREATE table IF NOT EXISTS <table>"
 */
TEST_F(MySQLCommandTest, MySQLTest3) {
  std::string table = "table1";
  std::string value = "(Usr VARCHAR(40),Count INT);";
  std::string command = buildCreate(TestResource::TABLE, "", true, table, value);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtCreate,
                                       {{table, {"create"}}});
}

/*
 * Tests query with optional cmd and quotes:
 * "CREATE table IF NOT EXISTS <table>"
 */
TEST_F(MySQLCommandTest, MySQLTest4) {
  std::string table = "\"table1\"";
  std::string value = "(Usr VARCHAR(40),Count INT);";
  hsql::SQLParserResult result;
  std::string command = buildCreate(TestResource::TABLE, "", true, table, value);
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtCreate,
                                       {{"table1", {"create"}}});
}

/*
 * Tests query with optional cmd and backticks:
 * "CREATE table IF NOT EXISTS <table>"
 */
TEST_F(MySQLCommandTest, MySQLTest5) {
  std::string table = "`table1`";
  std::string value = "(Usr VARCHAR(40),Count INT);";
  std::string command = buildCreate(TestResource::TABLE, "", true, table, value);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtCreate,
                                       {{"table1", {"create"}}});
}

/*
 * Tests query with optional cmd:
 * "CREATE table IF NOT EXISTS <table_name_with_spaces>"
 */
TEST_F(MySQLCommandTest, MySQLTest6) {
  std::string table = "\"table 1\"";
  std::string value = "(Usr VARCHAR(40),Count INT);";
  hsql::SQLParserResult result;
  std::string command = buildCreate(TestResource::TABLE, "", true, table, value);
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtCreate,
                                       {{"table 1", {"create"}}});
}

/*
 * Tests query with optional cmd:
 * "CREATE table IF NOT EXISTS <table_name_with_2_spaces>"
 */
TEST_F(MySQLCommandTest, MySQLTest7) {
  std::string table = "`table number 1`";
  std::string value = "(Usr VARCHAR(40),Count INT);";
  std::string command = buildCreate(TestResource::TABLE, "", true, table, value);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtCreate,
                                       {{"table number 1", {"create"}}});
}

/*
 * Test query with optional cmd:
 * "CREATE table IF NOT EXISTS <table_name_with_multi_spaces>"
 */
TEST_F(MySQLCommandTest, MySQLTest8) {
  std::string table = "`my sql table number 1`";
  std::string value = "(Usr VARCHAR(40),Count INT);";
  std::string command = buildCreate(TestResource::TABLE, "", true, table, value);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtCreate,
                                       {{"my sql table number 1", {"create"}}});
}

/*
 * Test query with optional cmd and backticks name delimiters
 * "CREATE table IF NOT EXISTS <table_name_with_multi_spaces_backticks>"
 */
TEST_F(MySQLCommandTest, MySQLTest9) {
  std::string table = "`my sql table number 1`";
  std::string value = "(Usr VARCHAR(40),Count INT);";
  std::string command = buildCreate(TestResource::TABLE, "", true, table, value);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtCreate,
                                       {{"my sql table number 1", {"create"}}});
}

/*
 * Test query: "CREATE table <table>"
 */
TEST_F(MySQLCommandTest, MySQLTest10) {
  std::string table = "table1";
  std::string value = "(Usr VARCHAR(40),Count INT);";
  std::string command = buildCreate(TestResource::TABLE, "", false, table, value);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtCreate,
                                       {{table, {"create"}}});
}

/*
 * Negative Test query: "CREATE <table>"
 */
TEST_F(MySQLCommandTest, MySQLTest11) {
  std::string table = "table1";
  std::string command = "CREATE ";
  command.append(table);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  EXPECT_EQ(false, result.isValid());
}

/*
 * Test query with optional cmd:
 * "CREATE TEMPORARY table <table>"
 */
TEST_F(MySQLCommandTest, MySQLTest12) {
  std::string table = "table1";
  std::string value = "(Usr VARCHAR(40),Count INT);";
  std::string command = buildCreate(TestResource::TABLE, "TEMPORARY", false, table, value);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtCreate,
                                       {{"table1", {"create"}}});
}

/*
 * Test query: "CREATE DATABASE <DB>"
 */
TEST_F(MySQLCommandTest, MySQLTest13) {
  std::string db = "mysqldb";
  std::string command = buildCreate(TestResource::DB, "", false, db, "");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtCreate, {});
}

/*
 * Test query with optional cmd:
 * "CREATE DATABASE IF NOT EXISTS <DB>"
 */
TEST_F(MySQLCommandTest, MySQLTest14) {
  std::string db = "mysqldb";
  std::string command = buildCreate(TestResource::DB, "", true, db, "");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtCreate, {});
}

/*
 * Test query: "CREATE EVENT <event>"
 */
TEST_F(MySQLCommandTest, MySQLTest15) {
  std::string event = "event1";
  std::string command = buildCreate(TestResource::EVENT, "", false, event, "");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  EXPECT_EQ(false, result.isValid());
}

/*
 * Test query: "ALTER DATABASE <DB> CHARACTER SET charset_name"
 */
TEST_F(MySQLCommandTest, MySQLTest16) {
  std::string db = "mysqldb";
  std::string command = buildAlter(TestResource::DB, db, "CHARACTER SET charset_name");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtAlter, {});
}

/*
 * Test query: "ALTER DATABASE <DB> default CHARACTER SET charset_name"
 */
TEST_F(MySQLCommandTest, MySQLTest17) {
  std::string db = "mysqldb";
  std::string command = buildAlter(TestResource::DB, db, "default CHARACTER SET charset_name");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtAlter, {});
}

/*
 * Test query: "ALTER DATABASE <DB> default CHARACTER SET = charset_name"
 */
TEST_F(MySQLCommandTest, MySQLTest18) {
  std::string db = "mysqldb";
  std::string command = buildAlter(TestResource::DB, db, "default CHARACTER SET = charset_name");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtAlter, {});
}

/*
 * Test query: "ALTER SCHEMA <DB> default CHARACTER SET = charset_name"
 */
TEST_F(MySQLCommandTest, MySQLTest19) {
  std::string db = "mysqldb";
  std::string command =
      buildAlter(TestResource::SCHEMA, db, "default CHARACTER SET = charset_name");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtAlter, {});
}

/*
 * Test query: "ALTER TABLE <table> add column Id varchar (20)"
 */
TEST_F(MySQLCommandTest, MySQLTest20) {
  std::string table = "table1";
  std::string command = buildAlter(TestResource::TABLE, table, "add column Id varchar (20)");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtAlter,
                                       {{table, {"alter"}}});
}

/*
 * Test query: "DROP DATABASE <DB>"
 */
TEST_F(MySQLCommandTest, MySQLTest21) {
  std::string db = "mysqldb";
  std::string command = buildDrop(TestResource::DB, false, db);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtDrop, {});
}

/*
 * Test query with optional cmd:
 * "DROP DATABASE IF EXISTS <DB>"
 */
TEST_F(MySQLCommandTest, MySQLTest22) {
  std::string db = "mysqldb";
  std::string command = buildDrop(TestResource::DB, true, db);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtDrop, {});
}

/*
 * Test query with optional cmd:
 * "DROP TABLE IF EXISTS <Table>"
 */
TEST_F(MySQLCommandTest, MySQLTest23) {
  std::string table = "table1";
  std::string command = buildDrop(TestResource::TABLE, true, table);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtDrop, {{table, {"drop"}}});
}

/*
 * Test query INSERT:
 * "INSERT INTO <table> (Usr, Count) VALUES ('allsp2', 3)"
 */
TEST_F(MySQLCommandTest, MySQLTest24) {
  std::string table = "table1";
  std::string command = buildInsert("", true, table, " (Usr, Count) VALUES ('allsp2', 3)");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtInsert,
                                       {{table, {"insert"}}});
}

/*
 * Test query INSERT with optional parameters:
 * "INSERT LOW_PRIORITY INTO <table> (Usr, Count) VALUES ('allsp2', 3)"
 */
TEST_F(MySQLCommandTest, MySQLTest25) {
  std::string table = "table1";
  std::string command =
      buildInsert("LOW_PRIORITY", true, table, " (Usr, Count) VALUES ('allsp2', 3)");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtInsert,
                                       {{table, {"insert"}}});
}

/*
 * Test query INSERT with optional parameters:
 * "INSERT IGNORE INTO <table> (Usr, Count) VALUES ('allsp2', 3)"
 */
TEST_F(MySQLCommandTest, MySQLTest26) {
  std::string table = "table1";
  std::string command = buildInsert("IGNORE", true, table, " (Usr, Count) VALUES ('allsp2', 3)");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtInsert,
                                       {{table, {"insert"}}});
}

/*
 * Test query DELETE:
 * "DELETE FROM <table> (Usr, Count) VALUES ('allsp2', 3)"
 */
TEST_F(MySQLCommandTest, MySQLTest27) {
  std::string table = "table1";
  std::string command = buildDelete("", table, "WHERE Count > 3");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtDelete,
                                       {{table, {"delete"}}});
}

/*
 * Test query DELETE with optional parameters:
 * "DELETE LOW_PRIORITY FROM <table> (Usr, Count) VALUES ('allsp2', 3)"
 */
TEST_F(MySQLCommandTest, MySQLTest28) {
  std::string table = "table1";
  std::string command = buildDelete("LOW_PRIORITY", table, "WHERE Count > 3");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtDelete,
                                       {{table, {"delete"}}});
}

/*
 * Test query DELETE with optional parameters:
 * "DELETE QUICK FROM <table> (Usr, Count) VALUES ('allsp2', 3)"
 */
TEST_F(MySQLCommandTest, MySQLTest29) {
  std::string table = "table1";
  std::string command = buildDelete("QUICK", table, "WHERE Count > 3");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtDelete,
                                       {{table, {"delete"}}});
}

/*
 * Test query DELETE with optional parameters:
 * "DELETE QUICK FROM <table> (Usr, Count) VALUES ('allsp2', 3)"
 */
TEST_F(MySQLCommandTest, MySQLTest30) {
  std::string table = "table1";
  std::string command = buildDelete("IGNORE", table, "WHERE Count > 3");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtDelete,
                                       {{table, {"delete"}}});
}

/*
 * Test query SELECT:
 * "SELECT * FROM <table> ProductDetails WHERE Count = 1"
 */
TEST_F(MySQLCommandTest, MySQLTest31) {
  std::string table = "table1";
  std::string command = buildSelect("*", table, "WHERE Count = 1");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtSelect,
                                       {{table, {"select"}}});
}

/*
 * Test query SELECT:
 * "SELECT FROM <table> ProductDetails WHERE Count = 1"
 */
TEST_F(MySQLCommandTest, MySQLTest32) {
  std::string table = "table1";
  std::string command = buildSelect("Product.category", table, "WHERE Count = 1");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtSelect,
                                       {{table, {"select"}}, {"Product", {"unknown"}}});
}

/*
 * Test query SELECT:
 * "SELECT DISTINCT Usr FROM <table>"
 */
TEST_F(MySQLCommandTest, MySQLTest33) {
  std::string table = "table1";
  std::string command = buildSelect("DISTINCT Usr", table, "");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtSelect,
                                       {{table, {"select"}}});
}

/*
 * Test query SELECT:
 * "SELECT Usr,Count FROM <table> ORDER BY Count DESC"
 */
TEST_F(MySQLCommandTest, MySQLTest34) {
  std::string table = "table1";
  std::string command = buildSelect("Usr,Count", table, "ORDER BY Count DESC");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtSelect,
                                       {{table, {"select"}}});
}

/*
 * Test query SELECT:
 * "SELECT Usr,Count FROM <table> ORDER BY Count DESC"
 */
TEST_F(MySQLCommandTest, MySQLTest35) {
  std::string table = "table1";
  std::string command = buildSelect("Usr,Count", table, "ORDER BY Count DESC");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtSelect,
                                       {{table, {"select"}}});
}

/*
 * Negative Test query: SELECT
 */
TEST_F(MySQLCommandTest, MySQLTest36) {
  std::string command = buildSelect("", "", "");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  EXPECT_EQ(false, result.isValid());
}

/*
 * Test query: SELECT no FROM
 */
TEST_F(MySQLCommandTest, MySQLTest37) {
  std::string command = buildSelect("USr,Count", "", "");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  EXPECT_EQ(false, result.isValid());
}

/*
 * Test correlated queries: INSERT, SELECT
 */
TEST_F(MySQLCommandTest, MySQLTest38) {
  // SPELLCHECKER(off)
  std::string table1 = "table1";
  std::string table2 = "table2";
  std::string ins_command = buildInsert("", true, table1, "");
  std::string sel_command = buildSelect("*", table2, "" /*"WHERE tbl_temp1.fld_order_id > 100"*/);
  ins_command.append(sel_command);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(ins_command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtInsert,
                                       {{table1, {"insert"}}, {table2, {"select"}}});
  // SPELLCHECKER(on)
}

/*
 * Test not correlated queries: INSERT, SELECT
 */
TEST_F(MySQLCommandTest, MySQLTest39) {
  std::string table1 = "table1";
  std::string table2 = "table2";
  std::string ins_command = buildInsert("", true, table1, "");
  std::string sel_command = buildSelect("tbl_temp1.fld_order_id", table2, "");
  ins_command.append(sel_command);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(ins_command, result));
  expectStatementTypeAndTableAccessMap(
      result, hsql::StatementType::kStmtInsert,
      {{"tbl_temp1", {"unknown"}}, {"table2", {"select"}}, {"table1", {"insert"}}});
}

/*
 * Negative Test query: INSERT, Wrong SELECT
 */
TEST_F(MySQLCommandTest, MySQLTest40) {
  std::string table1 = "table1";
  std::string table2 = "table2";
  std::string ins_command = "INSERT INTO ";
  std::string ins_command2 = " (fld_id) ";
  std::string sel_command =
      buildSelect("tbl_temp1.fld_order_id", table1, "WHERE tbl_temp1.fld_order_id > 100;");
  ins_command.append(table1);
  ins_command.append(ins_command2);
  ins_command.append(sel_command);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(ins_command, result));
  EXPECT_EQ(true, result.isValid());
  EXPECT_EQ(1UL, result.size());
}

/*
 * Test query: UPDATE
 */
TEST_F(MySQLCommandTest, MySQLTest41) {
  std::string table = "table1";
  std::string command = buildUpdate(table, "", "SET col1 = col1 + 1");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtUpdate,
                                       {{table, {"update"}}});
}

/*
 * Test query: UPDATE
 */
TEST_F(MySQLCommandTest, MySQLTest42) {
  std::string table = "table1";
  std::string command = buildUpdate(table, "LOW_PRIORITY", "SET col1 = col1 + 1");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtUpdate,
                                       {{table, {"update"}}});
}

/*
 * Test query: UPDATE
 */
TEST_F(MySQLCommandTest, MySQLTest43) {
  std::string table = "table1";
  std::string command = buildUpdate(table, "IGNORE", "SET col1 = col1 + 1");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtUpdate,
                                       {{table, {"update"}}});
}

/*
 * Test query: UPDATE
 */
TEST_F(MySQLCommandTest, MySQLTest44) {
  std::string table = "table1";
  std::string command = buildUpdate(table, "LOW_PRIORITY IGNORE", "SET col1 = col1 + 1");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtUpdate,
                                       {{table, {"update"}}});
}

/*
 * Test correlated queries: UPDATE, SELECT
 */
TEST_F(MySQLCommandTest, MySQLTest45) {
  std::string table1 = "table1";
  std::string table2 = "table2";
  std::string command = buildUpdate(table1, "", "set column1=");
  std::string command2 = buildSelect("columnX", table2, ")");
  command.append("(");
  command.append(command2);
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtUpdate,
                                       {{table1, {"update"}}, {table2, {"select"}}});
}

/*
 * Test query: SELECT
 */
TEST_F(MySQLCommandTest, MySQLTest46) {
  std::string table = "table1";
  std::string command = buildSelect("12 AS a, a ", table, "GROUP BY a;");
  hsql::SQLParserResult result;
  EXPECT_EQ(DecodeStatus::Success, encodeQuery(command, result));
  expectStatementTypeAndTableAccessMap(result, hsql::StatementType::kStmtSelect,
                                       {{table, {"select"}}});
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "source/common/buffer/buffer_impl.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec_command.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_utils.h"
#include "gtest/gtest.h"
#include "mysql_test_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

TEST(MySQLCodecTest, MySQLCommandError) {
  Buffer::InstancePtr decode_data(new Buffer::OwnedImpl(""));
  Command mysql_cmd_decode{};
  decode_data->drain(4);
  mysql_cmd_decode.decode(*decode_data, 0, 0);
  EXPECT_EQ(mysql_cmd_decode.getCmd(), Command::Cmd::Null);
}

TEST(MySQLCodecTest, MySQLCommandInitDb) {
  Command mysql_cmd_encode{};
  mysql_cmd_encode.setCmd(Command::Cmd::InitDb);
  std::string db = "mysqlDB";
  mysql_cmd_encode.setDb(db);
  Buffer::OwnedImpl decode_data;
  mysql_cmd_encode.encode(decode_data);

  BufferHelper::encodeHdr(decode_data, 0);

  Command mysql_cmd_decode{};
  decode_data.drain(4);
  mysql_cmd_decode.decode(decode_data, 0, db.length() + 1);
  EXPECT_EQ(mysql_cmd_decode.getDb(), db);
}

TEST(MySQLCodecTest, MySQLCommandCreateDb) {
  Command mysql_cmd_encode{};
  mysql_cmd_encode.setCmd(Command::Cmd::CreateDb);
  std::string db = "mysqlDB";
  mysql_cmd_encode.setDb(db);
  Buffer::OwnedImpl decode_data;
  mysql_cmd_encode.encode(decode_data);

  BufferHelper::encodeHdr(decode_data, 0);

  Command mysql_cmd_decode{};
  decode_data.drain(4);
  mysql_cmd_decode.decode(decode_data, 0, db.length() + 1);
  EXPECT_EQ(mysql_cmd_decode.getDb(), db);
}

TEST(MySQLCodecTest, MySQLCommandDropDb) {
  Command mysql_cmd_encode{};
  mysql_cmd_encode.setCmd(Command::Cmd::DropDb);
  std::string db = "mysqlDB";
  mysql_cmd_encode.setDb(db);
  Buffer::OwnedImpl decode_data;
  mysql_cmd_encode.encode(decode_data);

  BufferHelper::encodeHdr(decode_data, 0);

  Command mysql_cmd_decode{};
  decode_data.drain(4);
  mysql_cmd_decode.decode(decode_data, 0, db.length() + 1);
  EXPECT_EQ(mysql_cmd_decode.getDb(), db);
}

TEST(MySQLCodecTest, MySQLCommandOther) {
  Command mysql_cmd_encode{};
  mysql_cmd_encode.setCmd(Command::Cmd::FieldList);
  Buffer::OwnedImpl decode_data;
  mysql_cmd_encode.encode(decode_data);
  BufferHelper::encodeHdr(decode_data, 0);

  Command mysql_cmd_decode{};
  decode_data.drain(4);
  mysql_cmd_decode.decode(decode_data, 0, 0);
  EXPECT_EQ(mysql_cmd_decode.getCmd(), Command::Cmd::FieldList);
}

TEST(MySQLCodecTest, MySQLCommandResp) {
  CommandResponse mysql_cmd_resp_encode{};
  mysql_cmd_resp_encode.setData(MySQLTestUtils::getCommandResponse());
  Buffer::OwnedImpl decode_data;
  mysql_cmd_resp_encode.encode(decode_data);
  CommandResponse mysql_cmd_resp_decode{};
  mysql_cmd_resp_decode.decode(decode_data, 0, decode_data.length());
  EXPECT_EQ(mysql_cmd_resp_decode.getData(), mysql_cmd_resp_encode.getData());
}

TEST(MySQLCodecTest, MySQLCommandRespIncompleteData) {
  CommandResponse mysql_cmd_resp_encode{};
  mysql_cmd_resp_encode.setData(MySQLTestUtils::getCommandResponse());
  Buffer::OwnedImpl decode_data;
  CommandResponse mysql_cmd_resp_decode{};
  mysql_cmd_resp_decode.decode(decode_data, 0, decode_data.length() + 1);
  EXPECT_EQ(mysql_cmd_resp_decode.getData(), "");
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_test",
    "envoy_cc_test_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_test_library(
    name = "mysql_test_utils_lib",
    srcs = ["mysql_test_utils.cc"],
    hdrs = ["mysql_test_utils.h"],
    deps = [
        "//contrib/mysql_proxy/filters/network/source:codec_lib",
    ],
)

envoy_cc_test(
    name = "mysql_codec_tests",
    srcs = [
        "mysql_codec_test.cc",
    ],
    deps = [
        ":mysql_test_utils_lib",
        "//contrib/mysql_proxy/filters/network/source:codec_lib",
    ],
)

envoy_cc_test(
    name = "mysql_greet_tests",
    srcs = [
        "mysql_greet_test.cc",
    ],
    deps = [
        ":mysql_test_utils_lib",
        "//contrib/mysql_proxy/filters/network/source:codec_lib",
    ],
)

envoy_cc_test(
    name = "mysql_auth_switch_resp_tests",
    srcs = [
        "mysql_auth_switch_resp_test.cc",
    ],
    deps = [
        ":mysql_test_utils_lib",
        "//contrib/mysql_proxy/filters/network/source:codec_lib",
    ],
)

envoy_cc_test(
    name = "mysql_clogin_tests",
    srcs = [
        "mysql_clogin_test.cc",
    ],
    deps = [
        ":mysql_test_utils_lib",
        "//contrib/mysql_proxy/filters/network/source:codec_lib",
    ],
)

envoy_cc_test(
    name = "mysql_clogin_resp_tests",
    srcs = [
        "mysql_clogin_resp_test.cc",
    ],
    deps = [
        ":mysql_test_utils_lib",
        "//contrib/mysql_proxy/filters/network/source:codec_lib",
    ],
)

envoy_cc_test(
    name = "mysql_filter_tests",
    srcs = [
        "mysql_filter_test.cc",
    ],
    deps = [
        ":mysql_test_utils_lib",
        "//contrib/mysql_proxy/filters/network/source:config",
        "//test/mocks/network:network_mocks",
    ],
)

envoy_cc_test(
    name = "mysql_integration_test",
    srcs = [
        "mysql_integration_test.cc",
    ],
    data = [
        "mysql_test_config.yaml",
    ],
    deps = [
        ":mysql_test_utils_lib",
        "//contrib/mysql_proxy/filters/network/source:config",
        "//contrib/mysql_proxy/filters/network/source:filter_lib",
        "//source/common/tcp_proxy",
        "//source/extensions/filters/network/tcp_proxy:config",
        "//test/integration:integration_lib",
    ],
)

envoy_cc_test(
    name = "mysql_command_tests",
    srcs = [
        "mysql_command_test.cc",
    ],
    data = ["mysql_test_config.yaml"],
    external_deps = ["sqlparser"],
    deps = [
        ":mysql_test_utils_lib",
        "//contrib/mysql_proxy/filters/network/source:codec_lib",
        "//contrib/mysql_proxy/filters/network/source:config",
        "//source/common/tcp_proxy",
        "//source/extensions/filters/network/tcp_proxy:config",
        "//test/integration:integration_lib",
    ],
)
admin:
  access_log:
  - name: envoy.access_loggers.file
    typed_config:
      "@type": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog
      path: "{}"
  address:
    socket_address:
      address: "{}"
      port_value: 0
static_resources:
  clusters:
    name: cluster_0
    connect_timeout: 2s
    load_assignment:
      cluster_name: cluster_0
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: "{}"
                port_value: 0
  listeners:
    name: listener_0
    address:
      socket_address:
        address: "{}"
        port_value: 0
    filter_chains:
    - filters:
      - name: mysql
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.mysql_proxy.v3.MySQLProxy
          stat_prefix: mysql_stats
      - name: tcp
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
          stat_prefix: tcp_stats
          cluster: cluster_0
#include "test/integration/fake_upstream.h"
#include "test/integration/integration.h"
#include "test/integration/utility.h"
#include "test/mocks/network/mocks.h"
#include "test/test_common/network_utility.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin_resp.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_greeting.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_switch_resp.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "mysql_test_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

constexpr int SESSIONS = 5;

class MySQLIntegrationTest : public testing::TestWithParam<Network::Address::IpVersion>,
                             public MySQLTestUtils,
                             public BaseIntegrationTest {
  std::string mysqlConfig() {
    return fmt::format(TestEnvironment::readFileToStringForTest(TestEnvironment::runfilesPath(
                           "contrib/mysql_proxy/filters/network/test/mysql_test_config.yaml")),
                       Platform::null_device_path,
                       Network::Test::getLoopbackAddressString(GetParam()),
                       Network::Test::getLoopbackAddressString(GetParam()),
                       Network::Test::getAnyAddressString(GetParam()));
  }

public:
  MySQLIntegrationTest() : BaseIntegrationTest(GetParam(), mysqlConfig()) {
    skip_tag_extraction_rule_check_ = true;
  };

  void SetUp() override { BaseIntegrationTest::initialize(); }
};

INSTANTIATE_TEST_SUITE_P(IpVersions, MySQLIntegrationTest,
                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()));

/**
 * NewSession Test:
 * Attempt a New Session and verify it is received by mysql onNewConnection.
 */
TEST_P(MySQLIntegrationTest, MySQLStatsNewSessionTest) {
  for (int idx = 0; idx < SESSIONS; idx++) {
    IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort("listener_0"));
    FakeRawConnectionPtr fake_upstream_connection;
    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection));

    tcp_client->close();
    ASSERT_TRUE(fake_upstream_connection->waitForDisconnect());
  }

  test_server_->waitForCounterGe("mysql.mysql_stats.sessions", SESSIONS);
}

/**
 * Login Test:
 * Attempt a mysql login and verify it is processed by the filter:
 * Verify counters:
 * - correct number of attempts
 * - no failures
 */
TEST_P(MySQLIntegrationTest, MySQLLoginTest) {
  std::string str;
  std::string rcvd_data;
  std::string user = "user1";

  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort("listener_0"));
  FakeRawConnectionPtr fake_upstream_connection;
  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection));

  // greeting
  std::string greeting = encodeServerGreeting(MYSQL_PROTOCOL_10);
  ASSERT_TRUE(fake_upstream_connection->write(greeting));

  str.append(greeting);
  tcp_client->waitForData(str, true);

  // Client username/password and capabilities
  std::string login = encodeClientLogin(CLIENT_PROTOCOL_41, user, CHALLENGE_SEQ_NUM);
  ASSERT_TRUE(tcp_client->write(login));
  ASSERT_TRUE(fake_upstream_connection->waitForData(login.length(), &rcvd_data));
  EXPECT_EQ(login, rcvd_data);

  // Server response OK to username/password
  std::string loginok = encodeClientLoginResp(MYSQL_RESP_OK);
  ASSERT_TRUE(fake_upstream_connection->write(loginok));

  str.append(loginok);
  tcp_client->waitForData(str, true);

  tcp_client->close();
  ASSERT_TRUE(fake_upstream_connection->waitForDisconnect());

  test_server_->waitForCounterGe("mysql.mysql_stats.login_attempts", 1);
  EXPECT_EQ(test_server_->counter("mysql.mysql_stats.login_failures")->value(), 0);
}

/**
 * Multiple Connections Login Test:
 * Attempt a mysql login and verify it is processed by the filter:
 * Verify counters:
 * - correct number of attempts
 * - no failures
 */
// TODO(https://github.com/envoyproxy/envoy/issues/30852) enable
TEST_P(MySQLIntegrationTest, DISABLED_MySQLUnitTestMultiClientsLoop) {
  int idx;
  std::string rcvd_data;

  for (idx = 0; idx < CLIENT_NUM; idx++) {
    std::string str;
    std::string user("user");
    user.append(std::to_string(idx));

    IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort("listener_0"));
    FakeRawConnectionPtr fake_upstream_connection;
    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection));

    // greeting
    std::string greeting = encodeServerGreeting(MYSQL_PROTOCOL_10);
    ASSERT_TRUE(fake_upstream_connection->write(greeting));

    str.append(greeting);
    tcp_client->waitForData(str, true);

    // Client username/password and capabilities
    std::string login = encodeClientLogin(CLIENT_PROTOCOL_41, user, CHALLENGE_SEQ_NUM);
    ASSERT_TRUE(tcp_client->write(login));
    ASSERT_TRUE(fake_upstream_connection->waitForData(login.length(), &rcvd_data));
    EXPECT_EQ(login, rcvd_data);

    // Server response OK to username/password
    std::string loginok = encodeClientLoginResp(MYSQL_RESP_OK);
    ASSERT_TRUE(fake_upstream_connection->write(loginok));

    str.append(loginok);
    tcp_client->waitForData(str, true);

    tcp_client->close();
    ASSERT_TRUE(fake_upstream_connection->waitForDisconnect());
  }

  // Verify counters: CLIENT_NUM login attempts, no failures
  test_server_->waitForCounterGe("mysql.mysql_stats.login_attempts", CLIENT_NUM);
  EXPECT_EQ(test_server_->counter("mysql.mysql_stats.login_attempts")->value(), CLIENT_NUM);
  EXPECT_EQ(test_server_->counter("mysql.mysql_stats.login_failures")->value(), 0);
}

/**
 * Login Test:
 * Attempt a mysql login and verify it is processed by the filter:
 * Verify counters:
 * - correct number of attempts
 * - correct number of failures
 */
TEST_P(MySQLIntegrationTest, MySQLLoginFailTest) {
  std::string str;
  std::string rcvd_data;
  std::string user = "user1";

  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort("listener_0"));
  FakeRawConnectionPtr fake_upstream_connection;
  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection));

  // greeting
  std::string greeting = encodeServerGreeting(MYSQL_PROTOCOL_10);
  ASSERT_TRUE(fake_upstream_connection->write(greeting));

  str.append(greeting);
  tcp_client->waitForData(str, true);

  // Client username/password and capabilities
  std::string login = encodeClientLogin(CLIENT_PROTOCOL_41, user, CHALLENGE_SEQ_NUM);
  ASSERT_TRUE(tcp_client->write(login));
  ASSERT_TRUE(fake_upstream_connection->waitForData(login.length(), &rcvd_data));
  EXPECT_EQ(login, rcvd_data);

  // Server response Error to username/password
  std::string loginerr = encodeClientLoginResp(MYSQL_RESP_ERR);
  ASSERT_TRUE(fake_upstream_connection->write(loginerr));

  str.append(loginerr);
  tcp_client->waitForData(str, true);

  tcp_client->close();
  ASSERT_TRUE(fake_upstream_connection->waitForDisconnect());

  test_server_->waitForCounterGe("mysql.mysql_stats.login_attempts", 1);
  EXPECT_EQ(test_server_->counter("mysql.mysql_stats.login_failures")->value(), 1);
}

/**
 * Login Test:
 * Attempt a mysql login and verify it is processed by the filter:
 * Verify counters:
 * - correct number of attempts
 * - correct number of upgraded_to_ssl
 */
TEST_P(MySQLIntegrationTest, MySQLLoginSslTest) {
  std::string str;
  std::string rcvd_data;
  std::string user = "user1";

  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort("listener_0"));
  FakeRawConnectionPtr fake_upstream_connection;
  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection));

  // greeting
  std::string greeting = encodeServerGreeting(MYSQL_PROTOCOL_10);
  ASSERT_TRUE(fake_upstream_connection->write(greeting));

  str.append(greeting);
  tcp_client->waitForData(str, true);

  // Client ssl upgrade request
  std::string login = encodeClientLogin(CLIENT_SSL, user, CHALLENGE_SEQ_NUM);
  ASSERT_TRUE(tcp_client->write(login));
  ASSERT_TRUE(fake_upstream_connection->waitForData(login.length(), &rcvd_data));
  EXPECT_EQ(login, rcvd_data);

  // after ssl upgrade request, the decoder will stop parse.

  // Server response Error to username/password
  std::string loginerr = encodeClientLoginResp(MYSQL_RESP_ERR);
  ASSERT_TRUE(fake_upstream_connection->write(loginerr));

  str.append(loginerr);
  tcp_client->waitForData(str, true);

  tcp_client->close();
  ASSERT_TRUE(fake_upstream_connection->waitForDisconnect());

  EXPECT_EQ(test_server_->counter("mysql.mysql_stats.login_attempts")->value(), 1);
  EXPECT_EQ(test_server_->counter("mysql.mysql_stats.upgraded_to_ssl")->value(), 1);
  EXPECT_EQ(test_server_->counter("mysql.mysql_stats.login_failures")->value(), 0);
}

/**
 * Login Test:
 * Attempt a mysql login and verify it is processed by the filter:
 * Verify counters:
 * - correct number of attempts
 * - correct number of failures
 * - correct number of auth switch requests
 */
TEST_P(MySQLIntegrationTest, MySQLLoginAuthSwitchTest) {
  std::string downstream_buffer;
  std::string upstream_buffer;
  std::string rcvd_data;
  std::string user = "user1";

  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort("listener_0"));
  FakeRawConnectionPtr fake_upstream_connection;
  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection));

  // greeting
  std::string greeting = encodeServerGreeting(MYSQL_PROTOCOL_10);
  ASSERT_TRUE(fake_upstream_connection->write(greeting));

  downstream_buffer.append(greeting);
  tcp_client->waitForData(downstream_buffer, true);

  // Client username/password and capabilities
  std::string login = encodeClientLogin(CLIENT_PROTOCOL_41, user, CHALLENGE_SEQ_NUM);
  upstream_buffer.append(login);
  ASSERT_TRUE(tcp_client->write(login));
  ASSERT_TRUE(fake_upstream_connection->waitForData(login.length(), &rcvd_data));
  EXPECT_EQ(upstream_buffer, rcvd_data);

  // Server response Auth Switch
  std::string auth_switch = encodeClientLoginResp(MYSQL_RESP_AUTH_SWITCH);
  ASSERT_TRUE(fake_upstream_connection->write(auth_switch));

  downstream_buffer.append(auth_switch);
  tcp_client->waitForData(downstream_buffer, true);

  // Client auth switch resp
  std::string auth_switch_resp = encodeAuthSwitchResp();
  upstream_buffer.append(auth_switch_resp);
  ASSERT_TRUE(tcp_client->write(auth_switch_resp));
  std::string data;
  ASSERT_TRUE(fake_upstream_connection->waitForData(upstream_buffer.length(), &data));
  EXPECT_EQ(upstream_buffer, data);

  // Server response OK to username/password
  std::string loginok = encodeClientLoginResp(MYSQL_RESP_OK);
  ASSERT_TRUE(fake_upstream_connection->write(loginok));

  downstream_buffer.append(loginok);
  tcp_client->waitForData(downstream_buffer, true);

  tcp_client->close();
  ASSERT_TRUE(fake_upstream_connection->waitForDisconnect());

  EXPECT_EQ(test_server_->counter("mysql.mysql_stats.login_attempts")->value(), 1);
  EXPECT_EQ(test_server_->counter("mysql.mysql_stats.login_failures")->value(), 0);
  EXPECT_EQ(test_server_->counter("mysql.mysql_stats.auth_switch_request")->value(), 1);
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/mysql_proxy/filters/network/source/mysql_utils.h"

#include "envoy/common/exception.h"

#include "source/common/buffer/buffer_impl.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

void BufferHelper::addUint8(Buffer::Instance& buffer, uint8_t val) {
  buffer.writeLEInt<uint8_t>(val);
}

void BufferHelper::addUint16(Buffer::Instance& buffer, uint16_t val) {
  buffer.writeLEInt<uint16_t>(val);
}

void BufferHelper::addUint24(Buffer::Instance& buffer, uint32_t val) {
  buffer.writeLEInt<uint32_t, sizeof(uint8_t) * 3>(val);
}

void BufferHelper::addUint32(Buffer::Instance& buffer, uint32_t val) {
  buffer.writeLEInt<uint32_t>(val);
}

// Implementation of MySQL lenenc encoder based on
// https://dev.mysql.com/doc/internals/en/integer.html#packet-Protocol::FixedLengthInteger
void BufferHelper::addLengthEncodedInteger(Buffer::Instance& buffer, uint64_t val) {
  if (val < 251) {
    buffer.writeLEInt<uint8_t>(val);
  } else if (val < (1 << 16)) {
    buffer.writeLEInt<uint8_t>(0xfc);
    buffer.writeLEInt<uint16_t>(val);
  } else if (val < (1 << 24)) {
    buffer.writeLEInt<uint8_t>(0xfd);
    buffer.writeLEInt<uint64_t, sizeof(uint8_t) * 3>(val);
  } else {
    buffer.writeLEInt<uint8_t>(0xfe);
    buffer.writeLEInt<uint64_t>(val);
  }
}

void BufferHelper::addBytes(Buffer::Instance& buffer, const char* str, int size) {
  buffer.add(str, size);
}

void BufferHelper::encodeHdr(Buffer::Instance& pkg, uint8_t seq) {
  // the pkg buffer should only contain one package data
  uint32_t header = (seq << 24) | (pkg.length() & MYSQL_HDR_PKT_SIZE_MASK);
  Buffer::OwnedImpl buffer;
  addUint32(buffer, header);
  pkg.prepend(buffer);
}

bool BufferHelper::endOfBuffer(Buffer::Instance& buffer) { return buffer.length() == 0; }

DecodeStatus BufferHelper::readUint8(Buffer::Instance& buffer, uint8_t& val) {
  try {
    val = buffer.peekLEInt<uint8_t>(0);
    buffer.drain(sizeof(uint8_t));
    return DecodeStatus::Success;
  } catch (EnvoyException& e) {
    // buffer underflow
    return DecodeStatus::Failure;
  }
}

DecodeStatus BufferHelper::readUint16(Buffer::Instance& buffer, uint16_t& val) {
  try {
    val = buffer.peekLEInt<uint16_t>(0);
    buffer.drain(sizeof(uint16_t));
    return DecodeStatus::Success;
  } catch (EnvoyException& e) {
    // buffer underflow
    return DecodeStatus::Failure;
  }
}

DecodeStatus BufferHelper::readUint24(Buffer::Instance& buffer, uint32_t& val) {
  try {
    val = buffer.peekLEInt<uint32_t, sizeof(uint8_t) * 3>(0);
    buffer.drain(sizeof(uint8_t) * 3);
    return DecodeStatus::Success;
  } catch (EnvoyException& e) {
    // buffer underflow
    return DecodeStatus::Failure;
  }
}

DecodeStatus BufferHelper::readUint32(Buffer::Instance& buffer, uint32_t& val) {
  try {
    val = buffer.peekLEInt<uint32_t>(0);
    buffer.drain(sizeof(uint32_t));
    return DecodeStatus::Success;
  } catch (EnvoyException& e) {
    // buffer underflow
    return DecodeStatus::Failure;
  }
}

// Implementation of MySQL lenenc encoder based on
// https://dev.mysql.com/doc/internals/en/integer.html#packet-Protocol::LengthEncodedInteger
DecodeStatus BufferHelper::readLengthEncodedInteger(Buffer::Instance& buffer, uint64_t& val) {
  uint8_t byte_val = 0;
  if (readUint8(buffer, byte_val) == DecodeStatus::Failure) {
    return DecodeStatus::Failure;
  }
  if (byte_val < LENENCODINT_1BYTE) {
    val = byte_val;
    return DecodeStatus::Success;
  }

  try {
    if (byte_val == LENENCODINT_2BYTES) {
      val = buffer.peekLEInt<uint64_t, sizeof(uint16_t)>(0);
      buffer.drain(sizeof(uint16_t));
    } else if (byte_val == LENENCODINT_3BYTES) {
      val = buffer.peekLEInt<uint64_t, sizeof(uint8_t) * 3>(0);
      buffer.drain(sizeof(uint8_t) * 3);
    } else if (byte_val == LENENCODINT_8BYTES) {
      val = buffer.peekLEInt<uint64_t>(0);
      buffer.drain(sizeof(uint64_t));
    } else {
      return DecodeStatus::Failure;
    }
  } catch (EnvoyException& e) {
    // buffer underflow
    return DecodeStatus::Failure;
  }

  return DecodeStatus::Success;
}

DecodeStatus BufferHelper::skipBytes(Buffer::Instance& buffer, size_t skip_bytes) {
  if (buffer.length() < skip_bytes) {
    return DecodeStatus::Failure;
  }
  buffer.drain(skip_bytes);
  return DecodeStatus::Success;
}

DecodeStatus BufferHelper::readString(Buffer::Instance& buffer, std::string& str) {
  char end = MYSQL_STR_END;
  ssize_t index = buffer.search(&end, sizeof(end), 0);
  if (index == -1) {
    return DecodeStatus::Failure;
  }
  str.assign(static_cast<char*>(buffer.linearize(index)), index);
  buffer.drain(index + 1);
  return DecodeStatus::Success;
}

DecodeStatus BufferHelper::readVector(Buffer::Instance& buffer, std::vector<uint8_t>& str) {
  char end = MYSQL_STR_END;
  ssize_t index = buffer.search(&end, sizeof(end), 0);
  if (index == -1) {
    return DecodeStatus::Failure;
  }
  auto arr = reinterpret_cast<uint8_t*>(buffer.linearize(index));
  str.assign(arr, arr + index);
  buffer.drain(index + 1);
  return DecodeStatus::Success;
}

DecodeStatus BufferHelper::readStringBySize(Buffer::Instance& buffer, size_t len,
                                            std::string& str) {
  if (buffer.length() < len) {
    return DecodeStatus::Failure;
  }
  str.assign(static_cast<char*>(buffer.linearize(len)), len);
  buffer.drain(len);
  return DecodeStatus::Success;
}

DecodeStatus BufferHelper::readVectorBySize(Buffer::Instance& buffer, size_t len,
                                            std::vector<uint8_t>& data) {
  if (buffer.length() < len) {
    return DecodeStatus::Failure;
  }
  uint8_t* arr = reinterpret_cast<uint8_t*>(buffer.linearize(len));
  data.assign(&arr[0], &arr[len]);
  buffer.drain(len);
  return DecodeStatus::Success;
}

DecodeStatus BufferHelper::peekUint32(Buffer::Instance& buffer, uint32_t& val) {
  try {
    val = buffer.peekLEInt<uint32_t>(0);
    return DecodeStatus::Success;
  } catch (EnvoyException& e) {
    return DecodeStatus::Failure;
  }
}

DecodeStatus BufferHelper::peekUint8(Buffer::Instance& buffer, uint8_t& val) {
  try {
    val = buffer.peekLEInt<uint8_t>(0);
    return DecodeStatus::Success;
  } catch (EnvoyException& e) {
    return DecodeStatus::Failure;
  }
}

void BufferHelper::consumeHdr(Buffer::Instance& buffer) { buffer.drain(sizeof(uint32_t)); }

DecodeStatus BufferHelper::peekHdr(Buffer::Instance& buffer, uint32_t& len, uint8_t& seq) {
  uint32_t val = 0;
  if (peekUint32(buffer, val) != DecodeStatus::Success) {
    return DecodeStatus::Failure;
  }
  seq = htobe32(val) & MYSQL_HDR_SEQ_MASK;
  len = val & MYSQL_HDR_PKT_SIZE_MASK;
  ENVOY_LOG(trace, "mysql_proxy: MYSQL-hdrseq {}, len {}", seq, len);
  return DecodeStatus::Success;
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/mysql_proxy/filters/network/source/mysql_filter.h"

#include "envoy/config/core/v3/base.pb.h"

#include "source/common/buffer/buffer_impl.h"
#include "source/common/common/assert.h"
#include "source/common/common/logger.h"
#include "source/extensions/filters/network/well_known_names.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin_resp.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_decoder_impl.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

MySQLFilterConfig::MySQLFilterConfig(const std::string& stat_prefix, Stats::Scope& scope)
    : scope_(scope), stats_(generateStats(stat_prefix, scope)) {}

MySQLFilter::MySQLFilter(MySQLFilterConfigSharedPtr config) : config_(std::move(config)) {}

void MySQLFilter::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) {
  read_callbacks_ = &callbacks;
}

Network::FilterStatus MySQLFilter::onData(Buffer::Instance& data, bool) {
  // Safety measure just to make sure that if we have a decoding error we keep going and lose stats.
  // This can be removed once we are more confident of this code.
  if (sniffing_) {
    read_buffer_.add(data);
    doDecode(read_buffer_);
  }
  return Network::FilterStatus::Continue;
}

Network::FilterStatus MySQLFilter::onWrite(Buffer::Instance& data, bool) {
  // Safety measure just to make sure that if we have a decoding error we keep going and lose stats.
  // This can be removed once we are more confident of this code.
  if (sniffing_) {
    write_buffer_.add(data);
    doDecode(write_buffer_);
  }
  return Network::FilterStatus::Continue;
}

void MySQLFilter::doDecode(Buffer::Instance& buffer) {
  // Clear dynamic metadata.
  envoy::config::core::v3::Metadata& dynamic_metadata =
      read_callbacks_->connection().streamInfo().dynamicMetadata();
  auto& metadata =
      (*dynamic_metadata.mutable_filter_metadata())[NetworkFilterNames::get().MySQLProxy];
  metadata.mutable_fields()->clear();

  if (!decoder_) {
    decoder_ = createDecoder(*this);
  }

  try {
    decoder_->onData(buffer);
  } catch (EnvoyException& e) {
    ENVOY_LOG(info, "mysql_proxy: decoding error: {}", e.what());
    config_->stats_.decoder_errors_.inc();
    sniffing_ = false;
    read_buffer_.drain(read_buffer_.length());
    write_buffer_.drain(write_buffer_.length());
  }
}

DecoderPtr MySQLFilter::createDecoder(DecoderCallbacks& callbacks) {
  return std::make_unique<DecoderImpl>(callbacks);
}

void MySQLFilter::onProtocolError() { config_->stats_.protocol_errors_.inc(); }

void MySQLFilter::onNewMessage(MySQLSession::State state) {
  if (state == MySQLSession::State::ChallengeReq) {
    config_->stats_.login_attempts_.inc();
  }
}

void MySQLFilter::onClientLogin(ClientLogin& client_login) {
  if (client_login.isSSLRequest()) {
    config_->stats_.upgraded_to_ssl_.inc();
  }
}

void MySQLFilter::onClientLoginResponse(ClientLoginResponse& client_login_resp) {
  if (client_login_resp.getRespCode() == MYSQL_RESP_AUTH_SWITCH) {
    config_->stats_.auth_switch_request_.inc();
  } else if (client_login_resp.getRespCode() == MYSQL_RESP_ERR) {
    config_->stats_.login_failures_.inc();
  }
}

void MySQLFilter::onMoreClientLoginResponse(ClientLoginResponse& client_login_resp) {
  if (client_login_resp.getRespCode() == MYSQL_RESP_ERR) {
    config_->stats_.login_failures_.inc();
  }
}

void MySQLFilter::onCommand(Command& command) {
  if (!command.isQuery()) {
    return;
  }

  // Parse a given query
  envoy::config::core::v3::Metadata& dynamic_metadata =
      read_callbacks_->connection().streamInfo().dynamicMetadata();
  ProtobufWkt::Struct metadata(
      (*dynamic_metadata.mutable_filter_metadata())[NetworkFilterNames::get().MySQLProxy]);

  auto result = Common::SQLUtils::SQLUtils::setMetadata(command.getData(),
                                                        decoder_->getAttributes(), metadata);

  ENVOY_CONN_LOG(trace, "mysql_proxy: query processed {}, result {}, cmd type {}",
                 read_callbacks_->connection(), command.getData(), result,
                 static_cast<int>(command.getCmd()));

  if (!result) {
    config_->stats_.queries_parse_error_.inc();
    return;
  }
  config_->stats_.queries_parsed_.inc();

  read_callbacks_->connection().streamInfo().setDynamicMetadata(
      NetworkFilterNames::get().MySQLProxy, metadata);
}

Network::FilterStatus MySQLFilter::onNewConnection() {
  config_->stats_.sessions_.inc();
  return Network::FilterStatus::Continue;
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once
#include "envoy/buffer/buffer.h"

#include "source/common/buffer/buffer_impl.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

constexpr int UNSET_BYTES = 23;
class ClientLogin : public MySQLCodec {
public:
  // MySQLCodec
  DecodeStatus parseMessage(Buffer::Instance& buffer, uint32_t len) override;
  void encode(Buffer::Instance&) const override;

  uint32_t getClientCap() const { return client_cap_; }
  uint16_t getBaseClientCap() const { return client_cap_ & 0xffff; }
  uint16_t getExtendedClientCap() const { return client_cap_ >> 16; }
  uint32_t getMaxPacket() const { return max_packet_; }
  uint8_t getCharset() const { return charset_; }
  const std::string& getUsername() const { return username_; }
  const std::vector<uint8_t>& getAuthResp() const { return auth_resp_; }
  const std::string& getDb() const { return db_; }
  const std::string& getAuthPluginName() const { return auth_plugin_name_; }
  const std::vector<std::pair<std::string, std::string>>& getConnectionAttribute() const {
    return conn_attr_;
  }
  bool isResponse41() const;
  bool isResponse320() const;
  bool isSSLRequest() const;
  bool isConnectWithDb() const;
  bool isClientAuthLenClData() const;
  bool isClientSecureConnection() const;
  void setClientCap(uint32_t client_cap);
  void setBaseClientCap(uint16_t base_cap);
  void setExtendedClientCap(uint16_t ext_cap);
  void setMaxPacket(uint32_t max_packet);
  void setCharset(uint8_t charset);
  void setUsername(const std::string& username);
  void setAuthResp(const std::vector<uint8_t>& auth_resp);
  void setDb(const std::string& db);
  void setAuthPluginName(const std::string& auth_plugin_name);
  void addConnectionAttribute(const std::pair<std::string, std::string>&);

private:
  DecodeStatus parseResponseSsl(Buffer::Instance& buffer);
  DecodeStatus parseResponse41(Buffer::Instance& buffer);
  DecodeStatus parseResponse320(Buffer::Instance& buffer, uint32_t);
  void encodeResponseSsl(Buffer::Instance& out) const;
  void encodeResponse41(Buffer::Instance& out) const;
  void encodeResponse320(Buffer::Instance& out) const;

  uint32_t client_cap_{0};
  uint32_t max_packet_{0};
  uint8_t charset_{0};
  std::string username_;
  std::vector<uint8_t> auth_resp_;
  std::string db_;
  std::string auth_plugin_name_;
  std::vector<std::pair<std::string, std::string>> conn_attr_;
};

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "contrib/common/sqlutils/source/sqlutils.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin_resp.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_command.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_greeting.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_switch_resp.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_session.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

/**
 * General callbacks for dispatching decoded MySQL messages to a sink.
 */
class DecoderCallbacks {
public:
  virtual ~DecoderCallbacks() = default;

  virtual void onProtocolError() PURE;
  virtual void onNewMessage(MySQLSession::State) PURE;
  virtual void onServerGreeting(ServerGreeting&) PURE;
  virtual void onClientLogin(ClientLogin&) PURE;
  virtual void onClientLoginResponse(ClientLoginResponse&) PURE;
  virtual void onClientSwitchResponse(ClientSwitchResponse&) PURE;
  virtual void onMoreClientLoginResponse(ClientLoginResponse&) PURE;
  virtual void onCommand(Command&) PURE;
  virtual void onCommandResponse(CommandResponse&) PURE;
};

/**
 * MySQL message decoder.
 */
class Decoder {
public:
  virtual ~Decoder() = default;

  virtual void onData(Buffer::Instance& data) PURE;
  virtual MySQLSession& getSession() PURE;

  const Extensions::Common::SQLUtils::SQLUtils::DecoderAttributes& getAttributes() const {
    return attributes_;
  }

protected:
  // Decoder attributes.
  Extensions::Common::SQLUtils::SQLUtils::DecoderAttributes attributes_;
};

using DecoderPtr = std::unique_ptr<Decoder>;

class DecoderFactory {
public:
  virtual ~DecoderFactory() = default;
  virtual DecoderPtr create(DecoderCallbacks& callbacks) PURE;
};

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once
#include "contrib/mysql_proxy/filters/network/source/mysql_decoder.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

class DecoderImpl : public Decoder, public Logger::Loggable<Logger::Id::filter> {
public:
  DecoderImpl(DecoderCallbacks& callbacks) : callbacks_(callbacks) {}

  // MySQLProxy::Decoder
  void onData(Buffer::Instance& data) override;
  MySQLSession& getSession() override { return session_; }

private:
  bool decode(Buffer::Instance& data);
  void parseMessage(Buffer::Instance& message, uint8_t seq, uint32_t len);

  DecoderCallbacks& callbacks_;
  MySQLSession session_;
};

class DecoderFactoryImpl : public DecoderFactory {
public:
  DecoderPtr create(DecoderCallbacks& callbacks) override;
  static DecoderFactoryImpl instance_;
};

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/common/platform.h"

#include "source/common/buffer/buffer_impl.h"
#include "source/common/common/logger.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

constexpr uint16_t MYSQL_MAX_STR_SIZE = 256;
constexpr uint16_t MYSQL_PKT_SIZE = 1500;
constexpr uint8_t MYSQL_HDR_SIZE = 4;
constexpr uint8_t MYSQL_PROTOCOL_9 = 9;
constexpr uint8_t MYSQL_PROTOCOL_10 = 10;
constexpr uint8_t MYSQL_PKT_0 = 0;
constexpr uint8_t MYSQL_UNAME_PKT_NUM = 1;
constexpr uint32_t MYSQL_HDR_PKT_SIZE_MASK = 0x00FFFFFF;
constexpr uint32_t MYSQL_HDR_SEQ_MASK = 0x000000FF;
constexpr uint8_t MYSQL_LOGIN_RESP_PKT_NUM = 2;
constexpr uint8_t MYSQL_REQUEST_PKT_NUM = 0;
constexpr uint8_t MYSQL_RESPONSE_PKT_NUM = 1;
constexpr uint16_t MAX_MYSQL_QUERY_STRING = 256;
constexpr uint16_t MAX_MYSQL_USER_STRING = 256;
constexpr uint8_t MIN_RESPONSE_PAYLOAD = 5;
constexpr uint8_t MYSQL_MAX_USER_LEN = 32;
constexpr uint8_t MYSQL_MAX_PASSWD_LEN = 32;

constexpr uint8_t MYSQL_RESP_OK = 0x00;
constexpr uint8_t MYSQL_RESP_MORE = 0x01;
constexpr uint8_t MYSQL_RESP_AUTH_SWITCH = 0xfe;
constexpr uint8_t MYSQL_RESP_ERR = 0xff;

constexpr uint8_t EOF_MARKER = 0xfe;
constexpr uint8_t ERR_MARKER = 0xff;

constexpr uint8_t CLIENT_CAP_FLD = 2;
constexpr uint8_t EXT_CLIENT_CAP_FLD = 2;
constexpr uint8_t MAX_PKT_FLD = 4;
constexpr uint8_t CHARSET_FLD = 1;
constexpr uint8_t UNAME_RSVD_STR = 23;

constexpr uint8_t FILLER_1_SIZE = 1;
constexpr uint8_t FILLER_2_SIZE = 2;
constexpr uint8_t FILLER_3_SIZE = 3;
constexpr uint8_t MYSQL_DEFAULT = 4;
constexpr uint8_t CHARACTER_SET_SIZE = 2;

constexpr uint8_t MAX_TABLE_COLUMNS = 64;
constexpr uint8_t MAX_TABLE_ROWS = 128;

constexpr uint8_t LAYOUT_CTLG = 0;
constexpr uint8_t LAYOUT_DB = 1;
constexpr uint8_t LAYOUT_TBL = 2;
constexpr uint8_t LAYOUT_ORG_TBL = 3;
constexpr uint8_t LAYOUT_NAME = 4;
constexpr uint8_t LAYOUT_ORG_NAME = 5;
constexpr uint8_t MYSQL_CATALOG_LAYOUT = 6;
constexpr uint8_t MULTI_CLIENT = 10;
constexpr uint8_t LOGIN_OK_SEQ = 2;
constexpr uint8_t GREETING_SEQ_NUM = 0;
constexpr uint8_t CHALLENGE_SEQ_NUM = 1;
constexpr uint8_t CHALLENGE_RESP_SEQ_NUM = 2;
constexpr uint8_t AUTH_SWITH_RESP_SEQ = 3;
constexpr uint32_t MYSQL_THREAD_ID = 0x5e;
constexpr uint16_t MYSQL_SERVER_CAPAB = 0x0101;
constexpr uint8_t MYSQL_SERVER_LANGUAGE = 0x21;
constexpr uint16_t MYSQL_SERVER_STATUS = 0x0200;
constexpr uint16_t MYSQL_SERVER_EXT_CAPAB = 0x0200;
constexpr uint16_t MYSQL_EXT_CLIENT_CAPAB = 0x0300;

constexpr uint32_t CLIENT_PLUGIN_AUTH = 0x00080000;
constexpr uint32_t CLIENT_SECURE_CONNECTION = 0x8000;
constexpr uint32_t CLIENT_LONG_PASSWORD = 0x00000001;
constexpr uint32_t CLIENT_TRANSACTIONS = 0x00002000;
constexpr uint32_t CLIENT_LOCAL_FILES = 0x00000080;
constexpr uint32_t CLIENT_MULTI_STATEMENTS = 0x00010000;
constexpr uint32_t CLIENT_LONG_FLAG = 0x00000004;
constexpr uint32_t CLIENT_IGNORE_SIGPIPE = 4096;
constexpr uint32_t CLIENT_INTERACTIVE = 1024;
constexpr uint32_t CLIENT_FOUND_ROWS = 0x00000002;
constexpr uint32_t CLIENT_IGNORE_SPACE = 256;
constexpr uint32_t CLIENT_PROTOCOL_41 = 0x00000200;
constexpr uint32_t CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA = 0x00200000;
constexpr uint32_t CLIENT_CONNECT_WITH_DB = 0x00000008;
constexpr uint32_t CLIENT_CONNECT_ATTRS = 0x00100000;
constexpr uint32_t CLIENT_SSL = 0x00000800;
constexpr uint16_t MYSQL_EXT_CL_PLUGIN_AUTH = 0x8;
constexpr uint32_t MYSQL_MAX_PACKET = 0x00000001;
constexpr uint8_t MYSQL_CHARSET = 0x21;
constexpr uint8_t DEFAULT_MYSQL_CHARSET = 45; // utf8mb4
constexpr uint16_t DEFALUT_MYSQL_SERVER_STATUS = 2;
constexpr uint8_t MYSQL_SQL_STATE_LEN = 5;
constexpr int NATIVE_PSSWORD_HASH_LENGTH = 20;
constexpr int OLD_PASSWORD_HASH_LENGTH = 8;

constexpr uint8_t LENENCODINT_1BYTE = 0xfb;
constexpr uint8_t LENENCODINT_2BYTES = 0xfc;
constexpr uint8_t LENENCODINT_3BYTES = 0xfd;
constexpr uint8_t LENENCODINT_8BYTES = 0xfe;

constexpr uint32_t DEFAULT_MAX_PACKET_SIZE = (1 << 24) - 1; // 16M-1
constexpr uint8_t MIN_PROTOCOL_VERSION = 10;

constexpr char MYSQL_STR_END = '\0';

// error code
constexpr uint16_t MYSQL_CR_AUTH_PLUGIN_ERR = 2061;
constexpr uint16_t ER_USERNAME = 1468;
constexpr uint16_t ER_NOT_SUPPORTED_AUTH_MODE = 1251;
constexpr uint16_t ER_PASSWORD_NO_MATCH = 1133;
constexpr uint16_t ER_NET_PACKETS_OUT_OF_ORDER = 1156;
constexpr uint16_t ER_PASSWD_LENGTH = 1372;
constexpr uint16_t ER_ACCESS_DENIED_ERROR = 1045;
constexpr uint16_t ER_ER_BAD_DB_ERROR = 1049;
constexpr uint8_t MYSQL_SQL_STATE_MARKER = '#';

enum DecodeStatus : uint8_t {
  Success = 0,
  Failure = 1,
};

class MySQLCodec : public Logger::Loggable<Logger::Id::filter> {
public:
  enum class PktType {
    MysqlRequest = 0,
    MysqlResponse = 1,
  };

  virtual ~MySQLCodec() = default;

  uint8_t getSeq() const { return seq_; }
  void setSeq(uint8_t seq) { seq_ = seq; }

  DecodeStatus decode(Buffer::Instance& data, uint8_t seq, uint32_t len) {
    seq_ = seq;
    return parseMessage(data, len);
  }

protected:
  friend class MySQLTestUtils;
  virtual DecodeStatus parseMessage(Buffer::Instance& data, uint32_t len) PURE;
  virtual void encode(Buffer::Instance& out) const PURE;
  uint8_t seq_;
};

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "source/extensions/filters/network/common/factory_base.h"
#include "source/extensions/filters/network/well_known_names.h"

#include "contrib/envoy/extensions/filters/network/mysql_proxy/v3/mysql_proxy.pb.h"
#include "contrib/envoy/extensions/filters/network/mysql_proxy/v3/mysql_proxy.pb.validate.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_filter.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

/**
 * Config registration for the MySQL proxy filter.
 */
class MySQLConfigFactory
    : public Common::FactoryBase<envoy::extensions::filters::network::mysql_proxy::v3::MySQLProxy> {
public:
  MySQLConfigFactory() : FactoryBase(NetworkFilterNames::get().MySQLProxy) {}

private:
  Network::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoy::extensions::filters::network::mysql_proxy::v3::MySQLProxy& proto_config,
      Server::Configuration::FactoryContext& context) override;
};

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_greeting.h"

#include "envoy/buffer/buffer.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

void ServerGreeting::setProtocol(uint8_t protocol) { protocol_ = protocol; }

void ServerGreeting::setVersion(const std::string& version) { version_.assign(version); }

void ServerGreeting::setThreadId(uint32_t thread_id) { thread_id_ = thread_id; }

void ServerGreeting::setAuthPluginData(const std::vector<uint8_t>& data) {
  if (data.size() <= 8) {
    auth_plugin_data1_ = data;
    return;
  }
  auth_plugin_data1_.assign(data.data(), data.data() + 8);
  auth_plugin_data2_.assign(data.data() + 8, data.data() + data.size());
}

void ServerGreeting::setAuthPluginData1(const std::vector<uint8_t>& data) {
  auth_plugin_data1_ = data;
}

void ServerGreeting::setAuthPluginData2(const std::vector<uint8_t>& data) {
  auth_plugin_data2_ = data;
}

void ServerGreeting::setServerCap(uint32_t server_cap) { server_cap_ = server_cap; }

void ServerGreeting::setBaseServerCap(uint16_t base_server_cap) {
  server_cap_ &= 0xffffffff00000000;
  server_cap_ |= base_server_cap;
}

void ServerGreeting::setExtServerCap(uint16_t ext_server_cap) {
  uint32_t ext = ext_server_cap;
  server_cap_ &= 0x00000000ffffffff;
  server_cap_ |= (ext << 16);
}

void ServerGreeting::setServerCharset(uint8_t server_charset) { server_charset_ = server_charset; }

void ServerGreeting::setServerStatus(uint16_t server_status) { server_status_ = server_status; }

void ServerGreeting::setAuthPluginName(const std::string& name) { auth_plugin_name_ = name; }

DecodeStatus ServerGreeting::parseMessage(Buffer::Instance& buffer, uint32_t) {
  // https://github.com/mysql/mysql-proxy/blob/ca6ad61af9088147a568a079c44d0d322f5bee59/src/network-mysqld-packet.c#L1171
  if (BufferHelper::readUint8(buffer, protocol_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing protocol in mysql greeting msg");
    return DecodeStatus::Failure;
  }
  if (BufferHelper::readString(buffer, version_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing version in mysql greeting msg");
    return DecodeStatus::Failure;
  }
  if (BufferHelper::readUint32(buffer, thread_id_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing thread_id in mysql greeting msg");
    return DecodeStatus::Failure;
  }
  // read auth plugin data part 1, which is 8 byte.
  if (BufferHelper::readVectorBySize(buffer, 8, auth_plugin_data1_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing auth_plugin_data1 in mysql greeting msg");
    return DecodeStatus::Failure;
  }
  if (BufferHelper::skipBytes(buffer, 1) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error skipping bytes in mysql greeting msg");

    return DecodeStatus::Failure;
  }
  if (protocol_ == MYSQL_PROTOCOL_9) {
    return DecodeStatus::Success;
  }

  uint16_t base_server_cap = 0;
  if (BufferHelper::readUint16(buffer, base_server_cap) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing cap flag[lower 2 bytes] of mysql greeting msg");
    return DecodeStatus::Failure;
  }
  setBaseServerCap(base_server_cap);

  if (BufferHelper::readUint8(buffer, server_charset_) != DecodeStatus::Success) {
    // HandshakeV10 can terminate after Server Capabilities
    return DecodeStatus::Success;
  }
  if (BufferHelper::readUint16(buffer, server_status_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing server status of mysql greeting msg");
    return DecodeStatus::Failure;
  }
  uint16_t ext_server_cap = 0;
  if (BufferHelper::readUint16(buffer, ext_server_cap) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing cap flag[higher 2 bytes] of mysql greeting msg");
    return DecodeStatus::Failure;
  }
  setExtServerCap(ext_server_cap);
  uint8_t auth_plugin_data_len = 0;
  if (BufferHelper::readUint8(buffer, auth_plugin_data_len) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing length of auth plugin data of mysql greeting msg");
    return DecodeStatus::Failure;
  }
  if (BufferHelper::skipBytes(buffer, 10) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing reserved bytes of mysql greeting msg");
    return DecodeStatus::Failure;
  }
  if (server_cap_ & CLIENT_PLUGIN_AUTH) {
    int auth_plugin_data_len2 = 0;
    if (auth_plugin_data_len > 8) {
      auth_plugin_data_len2 = auth_plugin_data_len - 8;
    }
    if (BufferHelper::readVectorBySize(buffer, auth_plugin_data_len2, auth_plugin_data2_) !=
        DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when parsing auth_plugin_data2 in mysql greeting msg");
      return DecodeStatus::Failure;
    }
    int skiped_bytes = 13 - (13 > auth_plugin_data_len2 ? auth_plugin_data_len2 : 13);
    if (BufferHelper::skipBytes(buffer, skiped_bytes) != DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when skipping bytes in mysql greeting msg");
      return DecodeStatus::Failure;
    }
    if (BufferHelper::readString(buffer, auth_plugin_name_) != DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when parsing auth_plugin_name in mysql greeting msg");
      return DecodeStatus::Failure;
    }
  } else if (server_cap_ & CLIENT_SECURE_CONNECTION) {
    if (BufferHelper::readVectorBySize(buffer, 12, auth_plugin_data2_) != DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when parsing auth_plugin_data2 in mysql greeting msg");
      return DecodeStatus::Failure;
    }
    if (BufferHelper::skipBytes(buffer, 1) != DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when skipping byte in mysql greeting msg");
      return DecodeStatus::Failure;
    }
  }

  // final check
  auto auth_plugin_len = auth_plugin_data1_.size() + auth_plugin_data2_.size();
  if (server_cap_ & CLIENT_PLUGIN_AUTH) {
    if (auth_plugin_len != auth_plugin_data_len) {
      ENVOY_LOG(debug, "error when final check failure of mysql greeting msg");
      return DecodeStatus::Failure;
    }
  } else if (server_cap_ & CLIENT_SECURE_CONNECTION) {
    if (auth_plugin_len != 20 && auth_plugin_data_len != 0) {
      ENVOY_LOG(debug, "error when final check failure of mysql greeting msg");
      return DecodeStatus::Failure;
    }
  }
  return DecodeStatus::Success;
}

void ServerGreeting::encode(Buffer::Instance& out) const {
  // https://github.com/mysql/mysql-proxy/blob/ca6ad61af9088147a568a079c44d0d322f5bee59/src/network-mysqld-packet.c#L1339
  uint8_t enc_end_string = 0;
  BufferHelper::addUint8(out, protocol_);
  BufferHelper::addString(out, version_);
  BufferHelper::addUint8(out, enc_end_string);
  BufferHelper::addUint32(out, thread_id_);
  BufferHelper::addVector(out, auth_plugin_data1_);
  BufferHelper::addUint8(out, enc_end_string);
  if (protocol_ == MYSQL_PROTOCOL_9) {
    return;
  }
  BufferHelper::addUint16(out, getBaseServerCap());
  BufferHelper::addUint8(out, server_charset_);
  BufferHelper::addUint16(out, server_status_);
  BufferHelper::addUint16(out, getExtServerCap());

  if (server_cap_ & CLIENT_PLUGIN_AUTH) {
    BufferHelper::addUint8(out, auth_plugin_data2_.size() + auth_plugin_data1_.size());
  } else {
    BufferHelper::addUint8(out, 0);
  }
  // reserved
  for (int i = 0; i < 10; i++) {
    BufferHelper::addUint8(out, 0);
  }
  auto auth_data = auth_plugin_data2_;
  if (server_cap_ & CLIENT_PLUGIN_AUTH) {
    auth_data.resize(13);
    BufferHelper::addVector(out, auth_data);
    BufferHelper::addString(out, auth_plugin_name_);
    BufferHelper::addUint8(out, enc_end_string);
  } else if (server_cap_ & CLIENT_SECURE_CONNECTION) {
    auth_data.resize(12);
    BufferHelper::addVector(out, auth_plugin_data2_);
    BufferHelper::addUint8(out, enc_end_string);
  }
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/mysql_proxy/filters/network/source/mysql_config.h"

#include <string>

#include "envoy/registry/registry.h"
#include "envoy/server/filter_config.h"

#include "source/common/common/logger.h"

#include "contrib/envoy/extensions/filters/network/mysql_proxy/v3/mysql_proxy.pb.h"
#include "contrib/envoy/extensions/filters/network/mysql_proxy/v3/mysql_proxy.pb.validate.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_filter.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

/**
 * Config registration for the MySQL proxy filter. @see NamedNetworkFilterConfigFactory.
 */
Network::FilterFactoryCb
NetworkFilters::MySQLProxy::MySQLConfigFactory::createFilterFactoryFromProtoTyped(
    const envoy::extensions::filters::network::mysql_proxy::v3::MySQLProxy& proto_config,
    Server::Configuration::FactoryContext& context) {

  ASSERT(!proto_config.stat_prefix().empty());

  const std::string stat_prefix = fmt::format("mysql.{}", proto_config.stat_prefix());

  MySQLFilterConfigSharedPtr filter_config(
      std::make_shared<MySQLFilterConfig>(stat_prefix, context.scope()));
  return [filter_config](Network::FilterManager& filter_manager) -> void {
    filter_manager.addFilter(std::make_shared<MySQLFilter>(filter_config));
  };
}

/**
 * Static registration for the MySQL proxy filter. @see RegisterFactory.
 */
REGISTER_FACTORY(MySQLConfigFactory, Server::Configuration::NamedNetworkFilterConfigFactory);

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/mysql_proxy/filters/network/source/mysql_decoder_impl.h"

#include "source/common/common/logger.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin_resp.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

void DecoderImpl::parseMessage(Buffer::Instance& message, uint8_t seq, uint32_t len) {
  ENVOY_LOG(trace, "mysql_proxy: parsing message, seq {}, len {}", seq, len);
  // Run the MySQL state machine
  switch (session_.getState()) {
  case MySQLSession::State::Init: {
    // Expect Server Challenge packet
    ServerGreeting greeting;
    greeting.decode(message, seq, len);
    session_.setState(MySQLSession::State::ChallengeReq);
    callbacks_.onServerGreeting(greeting);
    break;
  }
  case MySQLSession::State::ChallengeReq: {
    // Process Client Handshake Response
    ClientLogin client_login{};
    client_login.decode(message, seq, len);
    if (client_login.isSSLRequest()) {
      session_.setState(MySQLSession::State::SslPt);
    } else if (client_login.isResponse41()) {
      session_.setState(MySQLSession::State::ChallengeResp41);
    } else {
      session_.setState(MySQLSession::State::ChallengeResp320);
    }
    callbacks_.onClientLogin(client_login);
    break;
  }
  case MySQLSession::State::SslPt:
    // just consume
    message.drain(len);
    break;
  case MySQLSession::State::ChallengeResp41:
  case MySQLSession::State::ChallengeResp320: {
    uint8_t resp_code;
    if (BufferHelper::peekUint8(message, resp_code) != DecodeStatus::Success) {
      session_.setState(MySQLSession::State::NotHandled);
      break;
    }
    std::unique_ptr<ClientLoginResponse> msg;
    MySQLSession::State state = MySQLSession::State::NotHandled;
    switch (resp_code) {
    case MYSQL_RESP_OK: {
      msg = std::make_unique<OkMessage>();
      state = MySQLSession::State::Req;
      // reset seq# when entering the REQ state
      session_.setExpectedSeq(MYSQL_REQUEST_PKT_NUM);
      break;
    }
    case MYSQL_RESP_AUTH_SWITCH: {
      msg = std::make_unique<AuthSwitchMessage>();
      state = MySQLSession::State::AuthSwitchResp;
      break;
    }
    case MYSQL_RESP_ERR: {
      msg = std::make_unique<ErrMessage>();
      state = MySQLSession::State::Error;
      break;
    }
    case MYSQL_RESP_MORE: {
      msg = std::make_unique<AuthMoreMessage>();
      break;
    }
    default:
      session_.setState(state);
      return;
    }
    msg->decode(message, seq, len);
    session_.setState(state);
    callbacks_.onClientLoginResponse(*msg);
    break;
  }

  case MySQLSession::State::AuthSwitchResp: {
    ClientSwitchResponse client_switch_resp{};
    client_switch_resp.decode(message, seq, len);
    session_.setState(MySQLSession::State::AuthSwitchMore);
    callbacks_.onClientSwitchResponse(client_switch_resp);
    break;
  }

  case MySQLSession::State::AuthSwitchMore: {
    uint8_t resp_code;
    if (BufferHelper::peekUint8(message, resp_code) != DecodeStatus::Success) {
      session_.setState(MySQLSession::State::NotHandled);
      break;
    }
    std::unique_ptr<ClientLoginResponse> msg;
    MySQLSession::State state = MySQLSession::State::NotHandled;
    switch (resp_code) {
    case MYSQL_RESP_OK: {
      msg = std::make_unique<OkMessage>();
      state = MySQLSession::State::Req;
      session_.setExpectedSeq(MYSQL_REQUEST_PKT_NUM);
      break;
    }
    case MYSQL_RESP_MORE: {
      msg = std::make_unique<AuthMoreMessage>();
      state = MySQLSession::State::AuthSwitchResp;
      break;
    }
    case MYSQL_RESP_ERR: {
      msg = std::make_unique<ErrMessage>();
      // stop parsing auth req/response, attempt to resync in command state
      state = MySQLSession::State::Resync;
      session_.setExpectedSeq(MYSQL_REQUEST_PKT_NUM);
      break;
    }
    case MYSQL_RESP_AUTH_SWITCH: {
      msg = std::make_unique<AuthSwitchMessage>();
      break;
    }
    default:
      session_.setState(state);
      return;
    }
    msg->decode(message, seq, len);
    session_.setState(state);
    callbacks_.onMoreClientLoginResponse(*msg);
    break;
  }

  case MySQLSession::State::Resync: {
    // re-sync to MYSQL_REQ state
    // expected seq check succeeded, no need to verify
    session_.setState(MySQLSession::State::Req);
    FALLTHRU;
  }

  // Process Command
  case MySQLSession::State::Req: {
    Command command{};
    command.decode(message, seq, len);
    session_.setState(MySQLSession::State::ReqResp);
    callbacks_.onCommand(command);
    break;
  }

  // Process Command Response
  case MySQLSession::State::ReqResp: {
    CommandResponse command_resp{};
    command_resp.decode(message, seq, len);
    callbacks_.onCommandResponse(command_resp);
    break;
  }

  case MySQLSession::State::Error:
  case MySQLSession::State::NotHandled:
  default:
    break;
  }

  ENVOY_LOG(trace, "mysql_proxy: msg parsed, session in state {}",
            static_cast<int>(session_.getState()));
}

bool DecoderImpl::decode(Buffer::Instance& data) {
  ENVOY_LOG(trace, "mysql_proxy: decoding {} bytes", data.length());
  uint32_t len = 0;
  uint8_t seq = 0;

  // ignore ssl message
  if (session_.getState() == MySQLSession::State::SslPt) {
    data.drain(data.length());
    return true;
  }

  if (BufferHelper::peekHdr(data, len, seq) != DecodeStatus::Success) {
    throw EnvoyException("error parsing mysql packet header");
  }
  ENVOY_LOG(trace, "mysql_proxy: seq {}, len {}", seq, len);
  // If message is split over multiple packets, hold off until the entire message is available.
  // Consider the size of the header here as it's not consumed yet.
  if (sizeof(uint32_t) + len > data.length()) {
    return false;
  }

  BufferHelper::consumeHdr(data); // Consume the header once the message is fully available.
  callbacks_.onNewMessage(session_.getState());

  // Ignore duplicate and out-of-sync packets.
  if (seq != session_.getExpectedSeq()) {
    // case when server response is over, and client send req
    if (session_.getState() == MySQLSession::State::ReqResp && seq == MYSQL_REQUEST_PKT_NUM) {
      session_.setExpectedSeq(MYSQL_REQUEST_PKT_NUM);
      session_.setState(MySQLSession::State::Req);
    } else {
      ENVOY_LOG(info, "mysql_proxy: ignoring out-of-sync packet");
      callbacks_.onProtocolError();
      data.drain(len); // Ensure that the whole message was consumed
      return true;
    }
  }
  session_.setExpectedSeq(seq + 1);

  const ssize_t data_len = data.length();
  parseMessage(data, seq, len);
  const ssize_t consumed_len = data_len - data.length();
  data.drain(len - consumed_len); // Ensure that the whole message was consumed

  ENVOY_LOG(trace, "mysql_proxy: {} bytes remaining in buffer", data.length());
  return true;
}

void DecoderImpl::onData(Buffer::Instance& data) {
  // TODO(venilnoronha): handle messages over 16 mb. See
  // https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_basic_packets.html#sect_protocol_basic_packets_sending_mt_16mb.
  while (!BufferHelper::endOfBuffer(data) && decode(data)) {
  }
}

DecoderFactoryImpl DecoderFactoryImpl::instance_;

DecoderPtr DecoderFactoryImpl::create(DecoderCallbacks& callbacks) {
  return std::make_unique<DecoderImpl>(callbacks);
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/access_log/access_log.h"
#include "envoy/network/connection.h"
#include "envoy/network/filter.h"
#include "envoy/stats/scope.h"
#include "envoy/stats/stats.h"
#include "envoy/stats/stats_macros.h"

#include "source/common/common/logger.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin_resp.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_command.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_greeting.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_switch_resp.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_decoder.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_session.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

/**
 * All MySQL proxy stats. @see stats_macros.h
 */
#define ALL_MYSQL_PROXY_STATS(COUNTER)                                                             \
  COUNTER(sessions)                                                                                \
  COUNTER(login_attempts)                                                                          \
  COUNTER(login_failures)                                                                          \
  COUNTER(decoder_errors)                                                                          \
  COUNTER(protocol_errors)                                                                         \
  COUNTER(upgraded_to_ssl)                                                                         \
  COUNTER(auth_switch_request)                                                                     \
  COUNTER(queries_parsed)                                                                          \
  COUNTER(queries_parse_error)

/**
 * Struct definition for all MySQL proxy stats. @see stats_macros.h
 */
struct MySQLProxyStats {
  ALL_MYSQL_PROXY_STATS(GENERATE_COUNTER_STRUCT)
};

/**
 * Configuration for the MySQL proxy filter.
 */
class MySQLFilterConfig {
public:
  MySQLFilterConfig(const std::string& stat_prefix, Stats::Scope& scope);

  const MySQLProxyStats& stats() { return stats_; }

  Stats::Scope& scope_;
  MySQLProxyStats stats_;

private:
  MySQLProxyStats generateStats(const std::string& prefix, Stats::Scope& scope) {
    return MySQLProxyStats{ALL_MYSQL_PROXY_STATS(POOL_COUNTER_PREFIX(scope, prefix))};
  }
};

using MySQLFilterConfigSharedPtr = std::shared_ptr<MySQLFilterConfig>;

/**
 * Implementation of MySQL proxy filter.
 */
class MySQLFilter : public Network::Filter, DecoderCallbacks, Logger::Loggable<Logger::Id::filter> {
public:
  MySQLFilter(MySQLFilterConfigSharedPtr config);
  ~MySQLFilter() override = default;

  // Network::ReadFilter
  Network::FilterStatus onData(Buffer::Instance& data, bool end_stream) override;
  Network::FilterStatus onNewConnection() override;
  void initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) override;

  // Network::WriteFilter
  Network::FilterStatus onWrite(Buffer::Instance& data, bool end_stream) override;

  // MySQLProxy::DecoderCallback
  void onProtocolError() override;
  void onNewMessage(MySQLSession::State state) override;
  void onServerGreeting(ServerGreeting&) override{};
  void onClientLogin(ClientLogin& message) override;
  void onClientLoginResponse(ClientLoginResponse& message) override;
  void onClientSwitchResponse(ClientSwitchResponse&) override{};
  void onMoreClientLoginResponse(ClientLoginResponse& message) override;
  void onCommand(Command& message) override;
  void onCommandResponse(CommandResponse&) override{};

  void doDecode(Buffer::Instance& buffer);
  DecoderPtr createDecoder(DecoderCallbacks& callbacks);
  MySQLSession& getSession() { return decoder_->getSession(); }

private:
  Network::ReadFilterCallbacks* read_callbacks_{};
  MySQLFilterConfigSharedPtr config_;
  Buffer::OwnedImpl read_buffer_;
  Buffer::OwnedImpl write_buffer_;
  std::unique_ptr<Decoder> decoder_;
  bool sniffing_{true};
};

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_switch_resp.h"

#include "envoy/buffer/buffer.h"

#include "source/common/common/logger.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

DecodeStatus ClientSwitchResponse::parseMessage(Buffer::Instance& buffer, uint32_t remain_len) {
  if (BufferHelper::readVectorBySize(buffer, remain_len, auth_plugin_resp_) !=
      DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing auth plugin data of client switch response");
    return DecodeStatus::Failure;
  }
  return DecodeStatus::Success;
}

void ClientSwitchResponse::encode(Buffer::Instance& out) const {
  BufferHelper::addVector(out, auth_plugin_resp_);
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin.h"

#include "source/common/buffer/buffer_impl.h"
#include "source/common/common/logger.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

void ClientLogin::setClientCap(uint32_t client_cap) { client_cap_ = client_cap; }

void ClientLogin::setBaseClientCap(uint16_t base_cap) {
  client_cap_ &= 0xffffffff00000000;
  client_cap_ = client_cap_ | base_cap;
}

void ClientLogin::setExtendedClientCap(uint16_t extended_client_cap) {
  uint32_t ext = extended_client_cap;
  client_cap_ &= 0x00000000ffffffff;
  client_cap_ = client_cap_ | (ext << 16);
}

void ClientLogin::setMaxPacket(uint32_t max_packet) { max_packet_ = max_packet; }

void ClientLogin::setCharset(uint8_t charset) { charset_ = charset; }

void ClientLogin::setUsername(const std::string& username) {
  if (username.length() <= MYSQL_MAX_USER_LEN) {
    username_.assign(username);
  }
}

void ClientLogin::setDb(const std::string& db) { db_ = db; }

void ClientLogin::setAuthResp(const std::vector<uint8_t>& auth_resp) { auth_resp_ = auth_resp; }

void ClientLogin::setAuthPluginName(const std::string& auth_plugin_name) {
  auth_plugin_name_ = auth_plugin_name;
}

bool ClientLogin::isResponse41() const { return client_cap_ & CLIENT_PROTOCOL_41; }

bool ClientLogin::isResponse320() const { return !(client_cap_ & CLIENT_PROTOCOL_41); }

bool ClientLogin::isSSLRequest() const { return client_cap_ & CLIENT_SSL; }

bool ClientLogin::isConnectWithDb() const { return client_cap_ & CLIENT_CONNECT_WITH_DB; }

bool ClientLogin::isClientAuthLenClData() const {
  return client_cap_ & CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA;
}

bool ClientLogin::isClientSecureConnection() const {
  return client_cap_ & CLIENT_SECURE_CONNECTION;
}

void ClientLogin::addConnectionAttribute(const std::pair<std::string, std::string>& attr) {
  conn_attr_.emplace_back(attr);
}

DecodeStatus ClientLogin::parseMessage(Buffer::Instance& buffer, uint32_t len) {
  /* 4.0 uses 2 bytes, 4.1+ uses 4 bytes, but the proto-flag is in the lower 2
   * bytes */
  uint16_t base_cap;
  if (BufferHelper::readUint16(buffer, base_cap) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing cap flag[lower 2 byte] of client login message");
    return DecodeStatus::Failure;
  }
  setBaseClientCap(base_cap);
  if (base_cap & CLIENT_SSL) {
    return parseResponseSsl(buffer);
  }
  if (base_cap & CLIENT_PROTOCOL_41) {
    return parseResponse41(buffer);
  }
  return parseResponse320(buffer, len - sizeof(base_cap));
}

DecodeStatus ClientLogin::parseResponseSsl(Buffer::Instance& buffer) {
  uint16_t ext_cap;
  if (BufferHelper::readUint16(buffer, ext_cap) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing cap flag of client ssl message");
    return DecodeStatus::Failure;
  }
  setExtendedClientCap(ext_cap);
  if (BufferHelper::readUint32(buffer, max_packet_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing max packet length of client ssl message");
    return DecodeStatus::Failure;
  }
  if (BufferHelper::readUint8(buffer, charset_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing character of client ssl message");
    return DecodeStatus::Failure;
  }
  if (BufferHelper::skipBytes(buffer, UNSET_BYTES) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing reserved bytes of client ssl message");
    return DecodeStatus::Failure;
  }
  return DecodeStatus::Success;
}

DecodeStatus ClientLogin::parseResponse41(Buffer::Instance& buffer) {
  int total = buffer.length();
  uint16_t ext_cap;
  if (BufferHelper::readUint16(buffer, ext_cap) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing client cap flag of client login message");
    return DecodeStatus::Failure;
  }
  setExtendedClientCap(ext_cap);
  if (BufferHelper::readUint32(buffer, max_packet_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing max packet length of client login message");
    return DecodeStatus::Failure;
  }
  if (BufferHelper::readUint8(buffer, charset_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing charset of client login message");
    return DecodeStatus::Failure;
  }
  if (BufferHelper::skipBytes(buffer, UNSET_BYTES) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when skipping bytes of client login message");
    return DecodeStatus::Failure;
  }
  if (BufferHelper::readString(buffer, username_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing username of client login message");
    return DecodeStatus::Failure;
  }
  if (client_cap_ & CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA) {
    uint64_t auth_len;
    if (BufferHelper::readLengthEncodedInteger(buffer, auth_len) != DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when parsing length of auth response of client login message");
      return DecodeStatus::Failure;
    }
    if (BufferHelper::readVectorBySize(buffer, auth_len, auth_resp_) != DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when parsing auth response of client login message");
      return DecodeStatus::Failure;
    }
  } else if (client_cap_ & CLIENT_SECURE_CONNECTION) {
    uint8_t auth_len;
    if (BufferHelper::readUint8(buffer, auth_len) != DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when parsing length of auth response of client login message");
      return DecodeStatus::Failure;
    }
    if (BufferHelper::readVectorBySize(buffer, auth_len, auth_resp_) != DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when parsing auth response of client login message");
      return DecodeStatus::Failure;
    }
  } else {
    if (BufferHelper::readVector(buffer, auth_resp_) != DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when parsing auth response of client login message");
      return DecodeStatus::Failure;
    }
  }

  if ((client_cap_ & CLIENT_CONNECT_WITH_DB) &&
      (BufferHelper::readString(buffer, db_) != DecodeStatus::Success)) {
    ENVOY_LOG(debug, "error when parsing db name of client login message");
    return DecodeStatus::Failure;
  }
  if ((client_cap_ & CLIENT_PLUGIN_AUTH) &&
      (BufferHelper::readString(buffer, auth_plugin_name_) != DecodeStatus::Success)) {
    ENVOY_LOG(debug, "error when parsing auth plugin name of client login message");
    return DecodeStatus::Failure;
  }
  if (client_cap_ & CLIENT_CONNECT_ATTRS) {
    // length of all key value pairs
    uint64_t kvs_len;
    if (BufferHelper::readLengthEncodedInteger(buffer, kvs_len) != DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when parsing length of all key-values in connection attributes of "
                       "client login message");
      return DecodeStatus::Failure;
    }
    while (kvs_len > 0) {
      uint64_t str_len;
      uint64_t prev_len = buffer.length();
      if (BufferHelper::readLengthEncodedInteger(buffer, str_len) != DecodeStatus::Success) {
        ENVOY_LOG(debug, "error when parsing total length of connection attribute key in "
                         "connection attributes of "
                         "client login message");
        return DecodeStatus::Failure;
      }
      std::string key;
      if (BufferHelper::readStringBySize(buffer, str_len, key) != DecodeStatus::Success) {
        ENVOY_LOG(debug, "error when parsing connection attribute key in connection attributes of "
                         "client login message");
        return DecodeStatus::Failure;
      }
      if (BufferHelper::readLengthEncodedInteger(buffer, str_len) != DecodeStatus::Success) {
        ENVOY_LOG(
            debug,
            "error when parsing length of connection attribute value in connection attributes of "
            "client login message");
        return DecodeStatus::Failure;
      }
      std::string val;
      if (BufferHelper::readStringBySize(buffer, str_len, val) != DecodeStatus::Success) {
        ENVOY_LOG(debug, "error when parsing connection attribute val in connection attributes of "
                         "client login message");
        return DecodeStatus::Failure;
      }
      conn_attr_.emplace_back(std::make_pair(std::move(key), std::move(val)));
      kvs_len -= prev_len - buffer.length();
    }
  }
  ENVOY_LOG(debug, "parsed client login protocol 41, consumed len {}, remain len {}",
            total - buffer.length(), buffer.length());
  return DecodeStatus::Success;
}

DecodeStatus ClientLogin::parseResponse320(Buffer::Instance& buffer, uint32_t remain_len) {
  int origin_len = buffer.length();
  if (BufferHelper::readUint24(buffer, max_packet_) != DecodeStatus::Success) {

    ENVOY_LOG(debug, "error when parsing max packet length of client login message");
    return DecodeStatus::Failure;
  }
  if (BufferHelper::readString(buffer, username_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing username of client login message");
    return DecodeStatus::Failure;
  }
  if (client_cap_ & CLIENT_CONNECT_WITH_DB) {
    if (BufferHelper::readVector(buffer, auth_resp_) != DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when parsing auth response of client login message");
      return DecodeStatus::Failure;
    }
    if (BufferHelper::readString(buffer, db_) != DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when parsing db name of client login message");
      return DecodeStatus::Failure;
    }
  } else {
    int consumed_len = origin_len - buffer.length();
    if (BufferHelper::readVectorBySize(buffer, remain_len - consumed_len, auth_resp_) !=
        DecodeStatus::Success) {
      ENVOY_LOG(debug, "error when parsing auth response of client login message");
      return DecodeStatus::Failure;
    }
  }
  return DecodeStatus::Success;
}

void ClientLogin::encode(Buffer::Instance& out) const {
  if (client_cap_ & CLIENT_SSL) {
    encodeResponseSsl(out);
    return;
  }
  if (client_cap_ & CLIENT_PROTOCOL_41) {
    encodeResponse41(out);
    return;
  }
  encodeResponse320(out);
}

void ClientLogin::encodeResponseSsl(Buffer::Instance& out) const {
  BufferHelper::addUint32(out, client_cap_);
  BufferHelper::addUint32(out, max_packet_);
  BufferHelper::addUint8(out, charset_);
  for (int i = 0; i < UNSET_BYTES; i++) {
    BufferHelper::addUint8(out, 0);
  }
}

void ClientLogin::encodeResponse41(Buffer::Instance& out) const {
  uint8_t enc_end_string = 0;
  BufferHelper::addUint32(out, client_cap_);
  BufferHelper::addUint32(out, max_packet_);
  BufferHelper::addUint8(out, charset_);
  for (int i = 0; i < UNSET_BYTES; i++) {
    BufferHelper::addUint8(out, 0);
  }
  BufferHelper::addString(out, username_);
  BufferHelper::addUint8(out, enc_end_string);
  if (client_cap_ & CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA) {
    BufferHelper::addLengthEncodedInteger(out, auth_resp_.size());
    BufferHelper::addVector(out, auth_resp_);
  } else if (client_cap_ & CLIENT_SECURE_CONNECTION) {
    BufferHelper::addUint8(out, auth_resp_.size());
    BufferHelper::addVector(out, auth_resp_);
  } else {
    BufferHelper::addVector(out, auth_resp_);
    BufferHelper::addUint8(out, enc_end_string);
  }
  if (client_cap_ & CLIENT_CONNECT_WITH_DB) {
    BufferHelper::addString(out, db_);
    BufferHelper::addUint8(out, enc_end_string);
  }
  if (client_cap_ & CLIENT_PLUGIN_AUTH) {
    BufferHelper::addString(out, auth_plugin_name_);
    BufferHelper::addUint8(out, enc_end_string);
  }
  if (client_cap_ & CLIENT_CONNECT_ATTRS) {
    Buffer::OwnedImpl conn_attr;
    for (const auto& kv : conn_attr_) {
      BufferHelper::addLengthEncodedInteger(conn_attr, kv.first.length());
      BufferHelper::addString(conn_attr, kv.first);
      BufferHelper::addLengthEncodedInteger(conn_attr, kv.second.length());
      BufferHelper::addString(conn_attr, kv.second);
    }
    BufferHelper::addLengthEncodedInteger(out, conn_attr.length());
    out.move(conn_attr);
  }
}

void ClientLogin::encodeResponse320(Buffer::Instance& out) const {
  uint8_t enc_end_string = 0;
  BufferHelper::addUint16(out, getBaseClientCap());
  BufferHelper::addUint24(out, max_packet_);
  BufferHelper::addString(out, username_);
  BufferHelper::addUint8(out, enc_end_string);
  if (client_cap_ & CLIENT_CONNECT_WITH_DB) {
    BufferHelper::addVector(out, auth_resp_);
    BufferHelper::addUint8(out, enc_end_string);
    BufferHelper::addString(out, db_);
    BufferHelper::addUint8(out, enc_end_string);
  } else {
    BufferHelper::addVector(out, auth_resp_);
  }
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once
#include "source/common/buffer/buffer_impl.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

class ServerGreeting : public MySQLCodec {
public:
  // MySQLCodec
  DecodeStatus parseMessage(Buffer::Instance& buffer, uint32_t len) override;
  void encode(Buffer::Instance&) const override;

  uint8_t getProtocol() const { return protocol_; }
  const std::string& getVersion() const { return version_; }
  uint32_t getThreadId() const { return thread_id_; }
  const std::vector<uint8_t>& getAuthPluginData1() const { return auth_plugin_data1_; }
  const std::vector<uint8_t>& getAuthPluginData2() const { return auth_plugin_data2_; }
  std::vector<uint8_t> getAuthPluginData() const {
    if ((server_cap_ & CLIENT_PLUGIN_AUTH) || (server_cap_ & CLIENT_SECURE_CONNECTION)) {
      auto res = auth_plugin_data1_;
      res.insert(res.end(), auth_plugin_data2_.begin(), auth_plugin_data2_.end());
      return res;
    }
    return auth_plugin_data1_;
  }
  uint8_t getServerCharset() const { return server_charset_; }
  uint16_t getServerStatus() const { return server_status_; }
  uint32_t getServerCap() const { return server_cap_; }
  uint16_t getBaseServerCap() const { return server_cap_ & 0xffff; }
  uint16_t getExtServerCap() const { return server_cap_ >> 16; }
  const std::string& getAuthPluginName() const { return auth_plugin_name_; }

  void setProtocol(uint8_t protocol);
  void setVersion(const std::string& version);
  void setThreadId(uint32_t thread_id);
  void setServerCap(uint32_t server_cap);
  void setBaseServerCap(uint16_t base_server_cap);
  void setExtServerCap(uint16_t ext_server_cap);
  void setAuthPluginName(const std::string& name);
  void setAuthPluginData(const std::vector<uint8_t>& salt);
  void setAuthPluginData1(const std::vector<uint8_t>& salt);
  void setAuthPluginData2(const std::vector<uint8_t>& salt);
  void setServerCharset(uint8_t server_language);
  void setServerStatus(uint16_t server_status);

private:
  DecodeStatus check() const;

private:
  uint8_t protocol_{0};
  std::string version_;
  uint32_t thread_id_{0};
  std::vector<uint8_t> auth_plugin_data1_;
  std::vector<uint8_t> auth_plugin_data2_;
  uint32_t server_cap_{0};
  uint8_t server_charset_{0};
  uint16_t server_status_{0};
  std::string auth_plugin_name_;
};

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

# MySQL proxy L7 network filter.
# Public docs: https://envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/mysql_proxy_filter

envoy_cc_library(
    name = "filter_lib",
    srcs = [
        "mysql_filter.cc",
    ],
    hdrs = [
        "mysql_filter.h",
    ],
    deps = [
        ":codec_lib",
        ":decoder_lib",
        "//envoy/network:filter_interface",
        "//envoy/server:filter_config_interface",
        "//envoy/stats:stats_interface",
        "//envoy/stats:stats_macros",
        "//source/common/network:filter_lib",
        "//source/extensions/filters/network:well_known_names",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "codec_lib",
    srcs = [
        "mysql_codec_clogin.cc",
        "mysql_codec_clogin_resp.cc",
        "mysql_codec_command.cc",
        "mysql_codec_greeting.cc",
        "mysql_codec_switch_resp.cc",
    ],
    hdrs = [
        "mysql_codec_clogin.h",
        "mysql_codec_clogin_resp.h",
        "mysql_codec_command.h",
        "mysql_codec_greeting.h",
        "mysql_codec_switch_resp.h",
        "mysql_session.h",
    ],
    deps = [
        ":codec_interface",
        ":util_lib",
        "//contrib/common/sqlutils/source:sqlutils_lib",
        "//source/common/buffer:buffer_lib",
    ],
)

envoy_cc_library(
    name = "decoder_interface",
    hdrs = ["mysql_decoder.h"],
    deps = [
        ":codec_lib",
    ],
)

envoy_cc_library(
    name = "codec_interface",
    hdrs = ["mysql_codec.h"],
    deps = [
        "//source/common/buffer:buffer_lib",
    ],
)

envoy_cc_library(
    name = "util_lib",
    srcs = ["mysql_utils.cc"],
    hdrs = ["mysql_utils.h"],
    deps = [
        ":codec_interface",
        "//source/common/buffer:buffer_lib",
    ],
)

envoy_cc_library(
    name = "config_interface",
    hdrs = ["mysql_config.h"],
    deps = [
        "//source/extensions/filters/network:well_known_names",
        "//source/extensions/filters/network/common:factory_base_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/mysql_proxy/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "decoder_lib",
    srcs = ["mysql_decoder_impl.cc"],
    hdrs = ["mysql_decoder_impl.h"],
    deps = [
        ":decoder_interface",
    ],
)

envoy_cc_contrib_extension(
    name = "config",
    srcs = ["mysql_config.cc"],
    hdrs = ["mysql_config.h"],
    deps = [
        ":filter_lib",
        "//source/extensions/filters/network:well_known_names",
        "//source/extensions/filters/network/common:factory_base_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/mysql_proxy/v3:pkg_cc_proto",
    ],
)
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_command.h"

#include "envoy/buffer/buffer.h"

#include "source/common/common/logger.h"
#include "source/common/common/macros.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

Command::Cmd Command::parseCmd(Buffer::Instance& data) {
  uint8_t cmd;
  if (BufferHelper::readUint8(data, cmd) != DecodeStatus::Success) {
    return Command::Cmd::Null;
  }
  return static_cast<Command::Cmd>(cmd);
}

void Command::setCmd(Command::Cmd cmd) { cmd_ = cmd; }

void Command::setDb(const std::string& db) { db_ = db; }

DecodeStatus Command::parseMessage(Buffer::Instance& buffer, uint32_t len) {
  Command::Cmd cmd = parseCmd(buffer);
  setCmd(cmd);
  if (cmd == Command::Cmd::Null) {
    return DecodeStatus::Failure;
  }

  switch (cmd) {
  case Command::Cmd::InitDb:
  case Command::Cmd::CreateDb:
  case Command::Cmd::DropDb: {
    std::string db;
    BufferHelper::readStringBySize(buffer, len - 1, db);
    setDb(db);
    break;
  }
  case Command::Cmd::Query:
    is_query_ = true;
    FALLTHRU;
  default:
    BufferHelper::readStringBySize(buffer, len - 1, data_);
    break;
  }
  return DecodeStatus::Success;
}

void Command::setData(const std::string& data) { data_.assign(data); }

void Command::encode(Buffer::Instance& out) const {
  BufferHelper::addUint8(out, static_cast<int>(cmd_));
  switch (cmd_) {
  case Command::Cmd::InitDb:
  case Command::Cmd::CreateDb:
  case Command::Cmd::DropDb: {
    BufferHelper::addString(out, db_);
    break;
  }
  default:
    BufferHelper::addString(out, data_);
    break;
  }
}

DecodeStatus CommandResponse::parseMessage(Buffer::Instance& buffer, uint32_t len) {
  if (BufferHelper::readStringBySize(buffer, len, data_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error when parsing command response");
    return DecodeStatus::Failure;
  }
  return DecodeStatus::Success;
}

void CommandResponse::encode(Buffer::Instance& out) const { BufferHelper::addString(out, data_); }

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/buffer/buffer.h"
#include "envoy/common/platform.h"

#include "source/common/buffer/buffer_impl.h"
#include "source/common/common/byte_order.h"
#include "source/common/common/logger.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

/**
 * IO helpers for reading/writing MySQL data from/to a buffer.
 * MySQL uses unsigned integer values in Little Endian format only.
 */
class BufferHelper : public Logger::Loggable<Logger::Id::filter> {
public:
  static void addUint8(Buffer::Instance& buffer, uint8_t val);
  static void addUint16(Buffer::Instance& buffer, uint16_t val);
  static void addUint24(Buffer::Instance& buffer, uint32_t val);
  static void addUint32(Buffer::Instance& buffer, uint32_t val);
  static void addLengthEncodedInteger(Buffer::Instance& buffer, uint64_t val);
  static void addBytes(Buffer::Instance& buffer, const char* data, int size);
  static void addString(Buffer::Instance& buffer, const std::string& str) {
    addBytes(buffer, str.data(), str.size());
  }
  static void addVector(Buffer::Instance& buffer, const std::vector<uint8_t>& data) {
    addBytes(buffer, reinterpret_cast<const char*>(data.data()), data.size());
  }
  static void encodeHdr(Buffer::Instance& pkg, uint8_t seq);
  static bool endOfBuffer(Buffer::Instance& buffer);
  static DecodeStatus readUint8(Buffer::Instance& buffer, uint8_t& val);
  static DecodeStatus readUint16(Buffer::Instance& buffer, uint16_t& val);
  static DecodeStatus readUint24(Buffer::Instance& buffer, uint32_t& val);
  static DecodeStatus readUint32(Buffer::Instance& buffer, uint32_t& val);
  static DecodeStatus readLengthEncodedInteger(Buffer::Instance& buffer, uint64_t& val);
  static DecodeStatus skipBytes(Buffer::Instance& buffer, size_t skip_bytes);
  static DecodeStatus readString(Buffer::Instance& buffer, std::string& str);
  static DecodeStatus readVector(Buffer::Instance& buffer, std::vector<uint8_t>& data);
  static DecodeStatus readStringBySize(Buffer::Instance& buffer, size_t len, std::string& str);
  static DecodeStatus readVectorBySize(Buffer::Instance& buffer, size_t len,
                                       std::vector<uint8_t>& vec);
  static DecodeStatus readAll(Buffer::Instance& buffer, std::string& str);
  static DecodeStatus peekUint32(Buffer::Instance& buffer, uint32_t& val);
  static DecodeStatus peekUint8(Buffer::Instance& buffer, uint8_t& val);
  static void consumeHdr(Buffer::Instance& buffer);
  static DecodeStatus peekHdr(Buffer::Instance& buffer, uint32_t& len, uint8_t& seq);
};

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin_resp.h"

#include "envoy/buffer/buffer.h"

#include "source/common/common/assert.h"
#include "source/common/common/logger.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_utils.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

// https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::AuthSwitchRequest
DecodeStatus AuthSwitchMessage::parseMessage(Buffer::Instance& buffer, uint32_t remain_len) {
  int origin_len = buffer.length();
  if (BufferHelper::readUint8(buffer, resp_code_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing resp code of auth switch msg");
    return DecodeStatus::Failure;
  }
  ASSERT(resp_code_ == MYSQL_RESP_AUTH_SWITCH);
  // OldAuthSwitchRequest
  if (BufferHelper::endOfBuffer(buffer)) {
    setIsOldAuthSwitch(true);
    return DecodeStatus::Success;
  }
  if (BufferHelper::readString(buffer, auth_plugin_name_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing auth plugin name mysql Login response msg");
    return DecodeStatus::Failure;
  }
  int consumed_len = origin_len - buffer.length();
  if (BufferHelper::readVectorBySize(buffer, remain_len - consumed_len, auth_plugin_data_) !=
      DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing auth plugin data code of auth switch msg");

    return DecodeStatus::Failure;
  }
  setIsOldAuthSwitch(false);
  return DecodeStatus::Success;
}

// https://dev.mysql.com/doc/internals/en/packet-OK_Packet.html
DecodeStatus OkMessage::parseMessage(Buffer::Instance& buffer, uint32_t len) {
  uint32_t init_len = buffer.length();
  if (BufferHelper::readUint8(buffer, resp_code_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing resp code of ok msg");
    return DecodeStatus::Failure;
  }
  ASSERT(resp_code_ == MYSQL_RESP_OK);
  if (BufferHelper::readLengthEncodedInteger(buffer, affected_rows_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing affected_rows of  ok msg");
    return DecodeStatus::Failure;
  }
  if (BufferHelper::readLengthEncodedInteger(buffer, last_insert_id_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing last_insert_id of ok msg");
    return DecodeStatus::Failure;
  }

  if (BufferHelper::readUint16(buffer, status_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing status of ok msg");
    return DecodeStatus::Failure;
  }
  // the exist of warning field is determined by server cap flag, but a decoder can not know the
  // cap flag, so just assume the CLIENT_PROTOCOL_41 is always set. ref
  // https://github.com/mysql/mysql-connector-j/blob/release/8.0/src/main/protocol-impl/java/com/mysql/cj/protocol/a/result/OkPacket.java#L48
  if (BufferHelper::readUint16(buffer, warnings_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing warnings of ok msg");
    return DecodeStatus::Failure;
  }
  uint32_t consumed_len = init_len - buffer.length();
  // The tail might contain debug base on cap flag and status flag, but just consume all
  if (BufferHelper::readStringBySize(buffer, len - consumed_len, info_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing debug of ok msg");
    return DecodeStatus::Failure;
  }
  return DecodeStatus::Success;
}

// https://dev.mysql.com/doc/internals/en/packet-ERR_Packet.html
DecodeStatus ErrMessage::parseMessage(Buffer::Instance& buffer, uint32_t remain_len) {
  int origin_len = buffer.length();
  if (BufferHelper::readUint8(buffer, resp_code_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing resp code of error msg");
    return DecodeStatus::Failure;
  }
  ASSERT(resp_code_ == MYSQL_RESP_ERR);
  if (BufferHelper::readUint16(buffer, error_code_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing error code of error msg");
    return DecodeStatus::Failure;
  }
  if (BufferHelper::readUint8(buffer, marker_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing sql state marker of error msg");
    return DecodeStatus::Failure;
  }
  if (BufferHelper::readStringBySize(buffer, MYSQL_SQL_STATE_LEN, sql_state_) !=
      DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing sql state of error msg");
    return DecodeStatus::Failure;
  }
  int consumed_len = origin_len - buffer.length();
  if (BufferHelper::readStringBySize(buffer, remain_len - consumed_len, error_message_) !=
      DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing error message of error msg");
    return DecodeStatus::Failure;
  }
  return DecodeStatus::Success;
}

// https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::AuthMoreData
DecodeStatus AuthMoreMessage::parseMessage(Buffer::Instance& buffer, uint32_t remain_len) {
  if (BufferHelper::readUint8(buffer, resp_code_) != DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing resp code of auth more msg");
    return DecodeStatus::Failure;
  }
  ASSERT(resp_code_ == MYSQL_RESP_MORE);
  if (BufferHelper::readVectorBySize(buffer, remain_len - sizeof(uint8_t), more_plugin_data_) !=
      DecodeStatus::Success) {
    ENVOY_LOG(debug, "error parsing more plugin data of auth more msg");
    return DecodeStatus::Failure;
  }
  return DecodeStatus::Success;
}

void AuthSwitchMessage::encode(Buffer::Instance& out) const {
  BufferHelper::addUint8(out, resp_code_);
  if (isOldAuthSwitch()) {
    return;
  }
  BufferHelper::addString(out, auth_plugin_name_);
  BufferHelper::addUint8(out, 0);
  BufferHelper::addVector(out, auth_plugin_data_);
}

void OkMessage::encode(Buffer::Instance& out) const {
  BufferHelper::addUint8(out, resp_code_);
  BufferHelper::addLengthEncodedInteger(out, affected_rows_);
  BufferHelper::addLengthEncodedInteger(out, last_insert_id_);
  BufferHelper::addUint16(out, status_);
  BufferHelper::addUint16(out, warnings_);
  BufferHelper::addString(out, info_);
}

void ErrMessage::encode(Buffer::Instance& out) const {
  BufferHelper::addUint8(out, resp_code_);
  BufferHelper::addUint16(out, error_code_);
  BufferHelper::addUint8(out, marker_);
  BufferHelper::addString(out, sql_state_);
  BufferHelper::addString(out, error_message_);
}

void AuthMoreMessage::encode(Buffer::Instance& out) const {
  BufferHelper::addUint8(out, resp_code_);
  BufferHelper::addVector(out, more_plugin_data_);
}

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include <vector>

#include "envoy/buffer/buffer.h"

#include "source/common/buffer/buffer_impl.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"
#include "contrib/mysql_proxy/filters/network/source/mysql_codec_clogin.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

class ClientLoginResponse;
class AuthMoreMessage;
class OkMessage;
class ErrMessage;
class AuthSwitchMessage;
using ClientLoginResponsePtr = std::unique_ptr<ClientLoginResponse>;

// ClientLoginResponse could be
// Protocol::OldAuthSwitchRequest, Protocol::AuthSwitchRequest when server wants switch auth
// method or OK_Packet, ERR_Packet when server auth ok or error
class ClientLoginResponse : public MySQLCodec {
public:
  ClientLoginResponse(uint8_t resp_code) : resp_code_(resp_code) {}
  // MySQLCodec
  uint8_t getRespCode() const { return resp_code_; }
  void setRespCode(uint8_t resp_code) { resp_code_ = resp_code; }

protected:
  uint8_t resp_code_;
};

class AuthMoreMessage : public ClientLoginResponse {
public:
  // ClientLoginResponse
  AuthMoreMessage() : ClientLoginResponse(MYSQL_RESP_MORE) {}
  DecodeStatus parseMessage(Buffer::Instance&, uint32_t) override;
  void encode(Buffer::Instance&) const override;
  const std::vector<uint8_t>& getAuthMoreData() const { return more_plugin_data_; }
  void setAuthMoreData(const std::vector<uint8_t>& data) { more_plugin_data_ = data; }

private:
  std::vector<uint8_t> more_plugin_data_;
};

class AuthSwitchMessage : public ClientLoginResponse {
public:
  AuthSwitchMessage() : ClientLoginResponse(MYSQL_RESP_AUTH_SWITCH) {}
  // ClientLoginResponse
  DecodeStatus parseMessage(Buffer::Instance&, uint32_t) override;
  void encode(Buffer::Instance&) const override;

  bool isOldAuthSwitch() const { return is_old_auth_switch_; }
  const std::vector<uint8_t>& getAuthPluginData() const { return auth_plugin_data_; }
  const std::string& getAuthPluginName() const { return auth_plugin_name_; }
  void setIsOldAuthSwitch(bool old) { is_old_auth_switch_ = old; }
  void setAuthPluginData(const std::vector<uint8_t>& data) { auth_plugin_data_ = data; }
  void setAuthPluginName(const std::string& name) { auth_plugin_name_ = name; }

private:
  bool is_old_auth_switch_{false};
  std::vector<uint8_t> auth_plugin_data_;
  std::string auth_plugin_name_;
};

class OkMessage : public ClientLoginResponse {
public:
  OkMessage() : ClientLoginResponse(MYSQL_RESP_OK) {}
  // ClientLoginResponse
  DecodeStatus parseMessage(Buffer::Instance&, uint32_t) override;
  void encode(Buffer::Instance&) const override;

  void setAffectedRows(uint64_t affected_rows) { affected_rows_ = affected_rows; }
  void setLastInsertId(uint64_t last_insert_id) { last_insert_id_ = last_insert_id; }
  void setServerStatus(uint16_t status) { status_ = status; }
  void setWarnings(uint16_t warnings) { warnings_ = warnings; }
  void setInfo(const std::string& info) { info_ = info; }
  uint64_t getAffectedRows() const { return affected_rows_; }
  uint64_t getLastInsertId() const { return last_insert_id_; }
  uint16_t getServerStatus() const { return status_; }
  uint16_t getWarnings() const { return warnings_; }
  const std::string& getInfo() const { return info_; }

private:
  uint64_t affected_rows_{0};
  uint64_t last_insert_id_{0};
  uint16_t status_{0};
  uint16_t warnings_{0};
  std::string info_;
  std::string session_state_changes_;
};

class ErrMessage : public ClientLoginResponse {
public:
  ErrMessage() : ClientLoginResponse(MYSQL_RESP_ERR) {}
  // ClientLoginResponse
  DecodeStatus parseMessage(Buffer::Instance&, uint32_t) override;
  void encode(Buffer::Instance&) const override;

  void setErrorCode(uint16_t error_code) { error_code_ = error_code; }
  void setSqlStateMarker(uint8_t marker) { marker_ = marker; }
  void setSqlState(const std::string& state) { sql_state_ = state; }
  void setErrorMessage(const std::string& msg) { error_message_ = msg; }
  uint16_t getErrorCode() const { return error_code_; }
  uint8_t getSqlStateMarker() const { return marker_; }
  const std::string& getSqlState() const { return sql_state_; }
  const std::string& getErrorMessage() const { return error_message_; }

private:
  uint8_t marker_{0};
  uint16_t error_code_{0};
  std::string sql_state_;
  std::string error_message_;
};

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once
#include "source/common/common/logger.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

class MySQLSession : Logger::Loggable<Logger::Id::filter> {
public:
  enum class State {
    Init = 0,
    ChallengeReq = 1,
    ChallengeResp41 = 2,
    ChallengeResp320 = 3,
    SslPt = 4,
    AuthSwitchReq = 5,
    AuthSwitchReqOld = 6,
    AuthSwitchResp = 7,
    AuthSwitchMore = 8,
    ReqResp = 9,
    Req = 10,
    Resync = 11,
    NotHandled = 12,
    Error = 13,
  };

  void setState(MySQLSession::State state) { state_ = state; }
  MySQLSession::State getState() { return state_; }
  uint8_t getExpectedSeq() { return expected_seq_; }
  void setExpectedSeq(uint8_t seq) { expected_seq_ = seq; }

private:
  MySQLSession::State state_{State::Init};
  uint8_t expected_seq_{0};
};

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once
#include "envoy/buffer/buffer.h"

#include "source/common/buffer/buffer_impl.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

class Command : public MySQLCodec {
public:
  enum class Cmd {
    Null = -1,
    Sleep = 0,
    Quit = 1,
    InitDb = 2,
    Query = 3,
    FieldList = 4,
    CreateDb = 5,
    DropDb = 6,
    Refresh = 7,
    Shutdown = 8,
    Statistics = 9,
    ProcessInfo = 10,
    Connect = 11,
    ProcessKill = 12,
    Debug = 13,
    Ping = 14,
    Time = 15,
    DelayedInsert = 16,
    ChangeUser = 17,
    Daemon = 29,
    ResetConnection = 31,
  };

  // MySQLCodec
  DecodeStatus parseMessage(Buffer::Instance&, uint32_t len) override;
  void encode(Buffer::Instance&) const override;

  Cmd parseCmd(Buffer::Instance& data);
  Cmd getCmd() const { return cmd_; }
  const std::string& getData() const { return data_; }
  std::string& getDb() { return db_; }
  void setCmd(Cmd cmd);
  void setData(const std::string& data);
  void setDb(const std::string& db);
  void setIsQuery(bool is_query) { is_query_ = is_query; }
  bool isQuery() { return is_query_; }

private:
  Cmd cmd_;
  std::string data_;
  std::string db_;
  bool is_query_;
};

/* CommandResponse has many types. ref https://dev.mysql.com/doc/internals/en/text-protocol.html
 * We just get all data
 */
class CommandResponse : public MySQLCodec {
public:
  // MySQLCodec
  DecodeStatus parseMessage(Buffer::Instance&, uint32_t) override;
  void encode(Buffer::Instance&) const override;
  const std::string& getData() const { return data_; }
  void setData(const std::string& data) { data_ = data; }

private:
  std::string data_;
};

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "source/common/buffer/buffer_impl.h"

#include "contrib/mysql_proxy/filters/network/source/mysql_codec.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace MySQLProxy {

class ClientSwitchResponse : public MySQLCodec {
public:
  // MySQLCodec
  DecodeStatus parseMessage(Buffer::Instance& buffer, uint32_t len) override;
  void encode(Buffer::Instance&) const override;

  void setAuthPluginResp(const std::vector<uint8_t>& auth_plugin_resp) {
    auth_plugin_resp_ = auth_plugin_resp;
  }
  const std::vector<uint8_t>& getAuthPluginResp() const { return auth_plugin_resp_; }

private:
  std::vector<uint8_t> auth_plugin_resp_;
};

} // namespace MySQLProxy
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
When creating an Envoy pull request (PR) the text box will automatically be filled
in with the basic fields from the [pull request template](PULL_REQUEST_TEMPLATE.md). The following
is a more detailed explanation of what should go in each field.

### <a name="title"></a>Title

The title of the PR should brief (one line) noting the subsystem or the aspect this PR applies to and
explaining the overall change. Both the component and the explanation must be lower case. For example:

* ci: update build image to 44d539cb
* docs: fix indent, buffer: add copyOut() method
* router:add x-envoy-overloaded header
* tls: add support for specifying TLS session ticket keys

### <a name="desc"></a>Commit Message

The commit message field should include an explanation of what this PR
does. This will be used as the final commit message that maintainers will use to
populate the commit message when merging. If this PR causes a change in behavior
it should document the behavior before and after. If fixing a bug, please
describe what the original issue is and how the change resolves it. If it is
configuration controlled, it should note how the feature is enabled etc...


### <a name="desc"></a>Additional Description

The additional description field should include information of what this PR does
that may be out of scope for a commit message. This could include additional
information or context useful to reviewers.

### <a name="risk"></a>Risk

Risk Level is one of: Low | Medium | High

Low: Small bug fix or small optional feature.

Medium: New features that are not enabled(for example: new filter). Small-medium
features added to existing components(for example: modification to an existing
filter).

High: Complicated changes such as flow control, rewrites of critical
components, etc.

Note: The above is only a rough guide for choosing a level,
please ask if you have any concerns about the risk of the PR.

### <a name="testing"></a>Testing

The testing section should include an explanation of what testing was done, for example: unit test,
integration, manual testing, etc.

Note: It isnt expected to do all forms of testing, please use your best judgement or ask for
guidance if you are unsure. A good rule of thumb is the riskier the change, the
more comprehensive the testing should be.

### <a name="docs"></a>Documentation

If there are documentation changes, please include a brief description of what they are. Docs
changes may be in [docs/root](docs/root) and/or inline with the API protos. Please write in
N/A if there were no documentation changes.

Any PRs with structural changes to the dataplane should also update the [Life of a
Request](https://www.envoyproxy.io/docs/envoy/latest/intro/life_of_a_request) documentation as appropriate.

### <a name="relnotes"></a>Release notes

If this change is user impacting OR extension developer impacting (filter API, etc.) you **must**
add a release note to the [version history](changelogs/current.yaml) for the
current version. Please include any relevant links. Each release note should be prefixed with the
relevant subsystem in **alphabetical order** (see existing examples as a guide) and include links
to relevant parts of the documentation. Thank you! Please write in N/A if there are no release notes.

### <a name="platform_specific_features"></a>Platform Specific Features

If this change involves any platform specific features (e.g. utilizing OS-specific socket options)
or only implements new features for a limited set of platforms (e.g. Linux amd64 only), please
include an explanation that addresses the reasoning behind this. Please also open a new tracking
issue for each platform this change is not implemented on (and link them in the PR) to enable
maintainers and contributors to triage. Reviewers will look for the change to avoid
`#ifdef <OSNAME>` and rather prefer feature guards to not enable the change on a given platform
using the build system.

### <a name="runtime_guard"></a>Runtime guard

If this PR has a user-visible behavioral change, or otherwise falls under the
guidelines for runtime guarding in the [contributing doc](CONTRIBUTING.md)
it should have a runtime guard, which should be documented both in the release
notes and here in the PR description.

For new feature additions guarded by configs, no-op refactors, docs changes etc.
this field can be disregarded and/or removed.

### <a name="issues"></a>Issues

If this PR fixes an outstanding issue, please add a line of the form:

Fixes #Issue

This will result in the linked issue being automatically closed when the PR is
merged. If you want to associate an issue with a PR without closing the issue,
you may instead just tag the PR with the issue:

\#Issue

### <a name="commit"></a>Commit

If this PR fixes or reverts a buggy commit, please add a line of the form:

Fixes commit #PR

or

Fixes commit SHA

This will allow automated tools to detect tainted commit ranges on the main branch when the PR is
merged.

### <a name="deprecated"></a>Deprecated

If this PR deprecates existing Envoy APIs or code, it should include an update to the deprecated
section of the [version history](changelogs/current.yaml) and a one line note in the
PR description.

If you mark existing APIs or code as deprecated, when the next release is cut, the
deprecation script will create and assign an issue to you for
cleaning up the deprecated code path.

### <a name="api"></a>API Changes

If this PR changes anything in the [api tree](https://github.com/envoyproxy/envoy/tree/main/api),
please read the [API Review
Checklist](https://github.com/envoyproxy/envoy/tree/main/api/review_checklist.md)
and make sure that your changes have addressed all of the considerations listed there.
Any relevant considerations should be documented under "API Considerations" in the PR description.
Envoy
Copyright The Envoy Project Authors

Licensed under Apache License 2.0.  See LICENSE for terms.
date: April 15, 2021

bug_fixes:
- area: http
  change: |
    fixed a crash upon receiving empty HTTP/2 metadata frames. Received empty metadata frames are now counted in the HTTP/2
    codec stat :ref:`metadata_empty_frames <config_http_conn_man_stats_per_codec>`.
- area: http
  change: |
    fixed a remotely exploitable integer overflow via a very large grpc-timeout value causes undefined behavior.
- area: http
  change: |
    reverting a behavioral change where upstream connect timeouts were temporarily treated differently from other connection
    failures. The change back to the original behavior can be temporarily reverted by setting
    ``envoy.reloadable_features.treat_upstream_connect_timeout_as_connect_failure`` to false.
- area: tls
  change: |
    fix a crash when peer sends a TLS Alert with an unknown code.

new_features:
- area: dispatcher
  change: |
    supports a stack of ``Envoy::ScopeTrackedObject`` instead of a single tracked object. This will allow Envoy to dump more
    debug information on crash.
date: February 7, 2023

bug_fixes:
- area: dependency
  change: |
    add boringssl patch to resolve CVE-2023-0286. Note that the FIPS build is not patched/fixed.

new_features:
- area: docker
  change: |
    use new ``nossl`` images for ``distroless`` Docker build.
date: September 29, 2020

changes:
- area: http
  change: |
    fixed CVE-2020-25017. Previously header matching did not match on all headers for non-inline headers. This patch
    changes the default behavior to always logically match on all headers. Multiple individual
    headers will be logically concatenated with ',' similar to what is done with inline headers. This
    makes the behavior effectively consistent. This behavior can be temporary reverted by setting
    the runtime value ``envoy.reloadable_features.http_match_on_all_headers`` to ``false``.

    Targeted fixes have been additionally performed on the following extensions which make them
    consider all duplicate headers by default as a comma concatenated list:

      1. Any extension using CEL matching on headers.
      2. The header to metadata filter.
      3. The JWT filter.
      4. The Lua filter.

    Like primary header matching used in routing, RBAC, etc. this behavior can be disabled by setting
    the runtime value ``envoy.reloadable_features.http_match_on_all_headers`` to false.
- area: http
  change: |
    fixed CVE-2020-25017. The ``setCopy()`` header map API previously only set the first header in the case of duplicate
    non-inline headers. ``setCopy()`` now behaves similarly to the other ``set*()`` APIs and replaces all found
    headers with a single value. This may have had security implications in the extauth filter which
    uses this API. This behavior can be disabled by setting the runtime value
    ``envoy.reloadable_features.http_set_copy_replace_all_headers`` to false.
date: April 17, 2023

behavior_changes:
- area: oauth2
  change: |
    OAuth filter now URL-encodes URL in query parameters. These query parameters are decoded, leaving intact character
    sequences that must remain encoded in URLs. This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.oauth_use_url_encoding`` to ``false``.
- area: admin
  change: |
    Adds a new admin stats format option ``html-active`` to display a periodically updated list of the top most frequently
    changed stats.
- area: build
  change: |
    Moved the tcp, http, and grpc health checkers to extensions. If you use these and override ``extensions_build_config.bzl``
    you will now need to include them explicitly.
- area: http
  change: |
    Validate upstream request header names and values. The new runtime flag
    ``envoy.reloadable_features.validate_upstream_headers`` can be used for revert this behavior.

minor_behavior_changes:
- area: event
  change: |
    ``Event::PostCb`` type changed from ``std::function`` to ``absl::AnyInvocable``. This makes it possible
    to capture ``unique_ptrs`` in dispatcher callbacks. If you have used ``Event::PostCb`` as shorthand for
    ``std::function<void()>`` in a non-post-callback-related context, you will have to change that.
    If you have used ``std::function`` in a mock dispatcher, you will have to change that to ``Event::PostCb``
    and may need to make it moveable. See https://github.com/envoyproxy/envoy/pull/26296 for a variety of
    example fixes.
- area: build
  change: |
    Moved the REST and filesystem config subscripton code into extensions. If you use them for config updates and
    override ``extensions_build_config.bzl`` you will now need to include them explicitly.
- area: quic
  change: |
    Access logging is now deferred to the QUIC ack listener, and roundtrip response time is added as a downstream timing
    metric. New runtime flag ``envoy.reloadable_features.quic_defer_logging_to_ack_listener`` can be used for revert this
    behavior.
- area: healthcheck
  change: |
    If active HC is enabled and a host is ejected by outlier detection, a successful active health check unejects the host
    and consider it healthy. This also clears all the outlier detection counters. This behavior change can be reverted by
    setting ``envoy.reloadable_features_successful_active_health_check_uneject_host`` to ``false``.
- area: local_ratelimit
  change: |
    Tokens from local descriptor's token buckets are burned before tokens from the default token bucket.
- area: http stream
  change: |
    Extended the lifetime of the protocol agnostic stream object to correct discrepancies between what is access logged and
    what occurred with the protocol specific stream. This behavior change can be reverted by setting
    ``envoy_reloadable_features_expand_agnostic_stream_lifetime`` to ``false``.
- area: http2
  change: |
    Request authorities are now validated with a library function from QUICHE rather than nghttp2. This behavior change can
    be reverted by setting ``envoy.reloadable_features.http2_validate_authority_with_quiche`` to ``false``.
- area: lua
  change: |
    Dropped moonjit support.
- area: ext_proc
  change: |
    Make the :ref:`grpc service <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.grpc_service>`
    required.
- area: http2
  change: |
    Metadata is parsed with the QUICHE HPACK library, rather than nghttp2. This behavior change can be reverted by setting
    ``envoy.reloadable_features.http2_decode_metadata_with_quiche`` to ``false``.
- area: upstream
  change: |
    Changed HTTP/1 and HTTP/3 upstream streams not to disable reading (in case where downstream buffer reaches high
    watermark) till the full response headers have been received. This fixes a bug where Envoy upstream timeouts were not
    correctly adjusting to the fact that the response headers have already been sent from upstream. This behavior change can
    be reverted by setting ``envoy.reloadable_features.upstream_wait_for_response_headers_before_disabling_read`` to
    ``false``.
- area: custom response
  change: |
    Changed how the uri for redirect policy is specified. It can now be specified either as a single fully qualified string,
    or by specifying individual components of the uri.
    If ``status_code`` in :ref:`RedirectPolicy <envoy_v3_api_msg_extensions.http.custom_response.redirect_policy.v3.RedirectPolicy>`
    is not specified, Envoy now returns the original response code, instead of the response code returned after redirection
    to the error service.
- area: matchers
  change: |
    Moved all of the network input matchers to extensions. If you use network matchers and override
    extensions_build_config.bzl you will now need to include them explicitly.
- area: access_logs
  change: |
    Using ``%DURATION%`` in access logs will either resolve the total duration of the stream, or mid-stream duration.
    This is useful to track stream duration with periodic access logs.
- area: matchers
  change: |
    Added dynamic metadata to the ``MatchingData`` object to enable writing ``matcher_tree`` input objects that can parse
    provided dynamic metadata.
- area: skywalking
  change: |
    If sw8 header is invalid, skywalking extension will create a new trace context and a null span respectively when
    sampling is enabled and disabled.
- area: http3
  change: |
    Convert HTTP/3 extended connect to/from HTTP/1 upgrade. This behavior change can be reverted by setting
    ``envoy.reloadable_features.use_http3_header_normalisation`` to ``false``.
- area: http
  change: |
    Prohibit route refresh after the response headers have been sent, and clear the cached route table to more
    aggressively free memory. Attempting to refresh or clear the route cache when it is blocked will result in an error. This
    behavior can be reverted by setting runtime flag ``envoy.reloadable_features.prohibit_route_refresh_after_response_headers_sent``
    to ``false``.
- area: ext_authz
  change: |
    ext_authz will add ``x-envoy-auth-failure-mode-allowed`` header when ``failure_mode_allow`` is enable.
    This behavior can be reverted by setting runtime flag
    ``envoy.reloadable_features.http_ext_auth_failure_mode_allow_header_add`` to ``false``.
- area: uhv
  change: |
    Translate backslash to slash in the default header validator. This behavior can be reverted by setting runtime flag
    ``envoy.reloadable_features.uhv_translate_backslash_to_slash`` to ``false``, in which case requests with backslash in path
    are rejected. This setting is only applicable when the Unversal Header Validator is enabled and has no effect otherwise.

bug_fixes:
- area: http
  change: |
    Sanitization of the referer header has been relaxed to allow relative URLs, and also tightened to remove referers
    containing user info or fragment components, as documented here :ref:`here <config_http_conn_man_headers_referer>`. This
    behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.http_allow_partial_urls_in_referer`` to ``false``.
- area: stats
  change: |
    Now updating upstream total connection stats as happy eyeballs connections are created.
- area: eds
  change: |
    Added ``envoy.reloadable_features.multiplex_eds`` to disable EDS multiplexing. EDS multiplexing is enabled by default,
    so that all subscriptions for the same resource type and management server reuse a single channel/mux. When EDS
    multiplexing is disabled each subscription uses a dedicated channel/mux.
- area: router
  change: |
    Fixed the bug that custom tags of the route metadata type are not set for upstream spans.
- area: ext_proc
  change: |
    Ensure the route configuration will be used to overwrite global configuration when processing the local reply.
- area: router
  change: |
    Fixed outlier detection ejections caused by opened circuit breakers.
- area: dependency
  change: |
    Add boringssl patch to resolve CVE-2023-0286. Note that the FIPS build is not patched/fixed.
- area: access log
  change: |
    In JSON logs, port numbers were logged as strings and are now logged as numbers (``%DOWNSTREAM_LOCAL_PORT%``,
    ``%DOWNSTREAM_REMOTE_PORT%``, ``%DOWNSTREAM_DIRECT_REMOTE_PORT%``, ``%UPSTREAM_LOCAL_PORT%``,
    ``%UPSTREAM_REMOTE_PORT%``). This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.format_ports_as_numbers`` to ``false``.
- area: ext_proc
  change: |
    Let ``onData`` always raise ``StopIterationAndWatermark`` when waiting for headers response, to avoid http errors (413 on
    request path, and 500 on response path) when data size goes above high watermark.
- area: http filter
  change: |
    Fix possible illegal memory access in the header_mutaion filter when the request is aborted before the request headers
    are received completely.
- area: upstream
  change: |
    Initialize upstream network read filters via their ``onNewConnection()`` callback once the upstream connection has been
    established even if there is no data available for reading on the new upstream connection. This behavior change can be
    reverted by setting ``envoy.reloadable_features.initialize_upstream_filters`` to ``false``.
- area: ecds
  change: |
    Delay listener activation until after the new ECDS filter configuration is created. Previously, listeners were activated
    with the xDS acceptance before the new extension config is fully processed.
- area: dubbo
  change: |
    Fix a bug that the Dubbo proxy will treat the response with status 80 as a illegal response.
- area: oauth2
  change: |
    Fixed a bug where the Oauth2 filter would crash if it received a redirect URL without a state query param set.
- area: lua
  change: |
    Lua coroutine should not execute after local reply is sent.
- area: grpc
  change: |
    When Envoy was configured to use ext_authz, ext_proc, tap, ratelimit filters, and gRPC access log service and an http header
    with non-UTF-8 data was received, Envoy would generate an invalid protobuf message and send it to the configured service. The
    receiving service would typically generate an error when decoding the protobuf message. For ext_authz that was configured with
    ``failure_mode_allow: true``, the request would have been allowed in this case. For the other services, this could have resulted
    in other unforseen errors such as a lack of visibility into requests (eg request not logged). Envoy will now by default sanitize
    the values sent in gRPC service calls to be valid UTF-8, replacing data that is not valid UTF-8 with a ``!`` character. This
    behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.service_sanitize_non_utf8_strings`` to false.
- area: http
  change: |
    Stop forwarding ``:method`` value which is not a valid token defined in https://www.rfc-editor.org/rfc/rfc9110#section-5.6.2.
    Also, reject ``:method`` and ``:scheme`` headers with multiple values.
- area: http
  change: |
    Fixed a bug where terminating ``CONNECT`` on a preconnected connection could result in session stalls.
- area: http3
  change: |
    Reject pseudo headers violating RFC 9114. Specifically, pseudo-header fields with more than one value for the ``:method``
    (non-``CONNECT``), ``:scheme``, and ``:path``; or pseudo-header fields after regular header fields; or undefined pseudo-headers.
- area: http
  change: |
    Fixed a bug where ``x-envoy-original-path`` was not being sanitized when sent from untrusted users. The header is *only*
    removed when sent from untrusted users, and not also before being sent to an upstream server. This behavioral change can
    be temporarily reverted by setting ``envoy.reloadable_features.sanitize_original_path`` to ``false``.
- area: grpc
  change: |
    The :ref:`connect_grpc_bridge filter <config_http_filters_connect_grpc_bridge>`
    filter now works correctly when the request payload is compressed on a unary buf connect request.

removed_config_or_runtime:
- area: config
  change: |
    Removed ``envoy.reloadable_features.admin_stats_filter_use_re2`` and legacy code paths. removed
    ``envoy.reloadable_features.combine_sds_requests`` and legacy code paths.
- area: dns
  change: |
    Removed ``envoy.reloadable_features.dns_multiple_addresses`` runtime flag and legacy code paths.
- area: router
  change: |
    Removed ``envoy.reloadable_features.get_route_config_factory_by_type`` runtime flag. The flag is no longer needed as the
    behavior is now the default.
- area: http
  change: |
    Removed ``envoy.reloadable_features.http2_delay_keepalive_timeout`` and legacy code paths.
- area: http
  change: |
    Removed ``envoy.reloadable_features.local_ratelimit_match_all_descriptors`` and legacy code paths.
- area: http
  change: |
    Removed ``envoy.reloadable_features.use_rfc_connect`` and legacy code path.
- area: http
  change: |
    Removed ``envoy.reloadable_features.allow_concurrency_for_alpn_pool`` and legacy code path.
- area: http
  change: |
    Removed ``envoy.reloadable_features.lua_respond_with_send_local_reply`` and legacy code path.
- area: http3
  change: |
    Removed ``envoy.reloadable_features.conn_pool_new_stream_with_early_data_and_http3`` and legacy code paths.
- area: http
  change: |
    Removed ``envoy.reloadable_features.http_skip_adding_content_length_to_upgrade`` and legacy code paths.
- area: http3
  change: |
    Removed ``envoy.reloadable_features.http3_sends_early_data`` and legacy code paths.
- area: dns
  change: |
    Removed ``envoy.reloadable_features.cares_accept_nodata`` and legacy code paths.
- area: http3
  change: |
    Removed ``envoy.reloadable_features.postpone_h3_client_connect_to_next_loop`` and legacy code paths.

new_features:
- area: access_log
  change: |
    Enhanced observability into local close for :ref:`%RESPONSE_CODE_DETAILS% <config_http_conn_man_details>`.
- area: access_log
  change: |
    Added upstream/downstream header and wire bytes fields to the grpc access log service proto.
- area: config
  change: |
    Added :ref:`RetryPolicy <envoy_v3_api_msg_config.core.v3.RetryPolicy>` to
    :ref:`EnvoyGrpc <envoy_v3_api_msg_config.core.v3.GrpcService.EnvoyGrpc>` to make
    EnvoyGrpc channel retry backoff timing values configurable.
- area: oauth filter
  change: |
    Extended :ref:`cookie_names <envoy_v3_api_field_extensions.filters.http.oauth2.v3.OAuth2Credentials.cookie_names>` to
    allow overriding (default) cookie names (``IdToken``, ``RefreshToken``) set by the filter.
- area: tracing
  change: |
    Allow :ref:`grpc_service <envoy_v3_api_field_config.trace.v3.OpenTelemetryConfig.grpc_service>` to be optional. This
    enables a means to disable collection of traces.
- area: upstream
  change: |
    Added :ref:`ring hash extension <envoy_v3_api_msg_extensions.load_balancing_policies.ring_hash.v3.RingHash>` to suppport
    the :ref:`load balancer policy <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>`.
- area: upstream
  change: |
    Added :ref:`maglev extension <envoy_v3_api_msg_extensions.load_balancing_policies.maglev.v3.Maglev>` to suppport the
    :ref:`load balancer policy <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>`.
- area: maglev
  change: |
    Added ``envoy.reloadable_features.allow_compact_maglev`` to allow the use of a more compact maglev load balancer
    representation. This can be reverted by setting ``envoy.reloadable_features.allow_compact_maglev`` to false.
- area: router
  change: |
    Support route info in upstream access log.
- area: lua
  change: |
    Added an new option to the options of lua ``httpCall``. This allows to skip adding ``x-forwarded-for`` by setting
    ``{["send_xff"] = false}`` as the ``options``.
- area: ratelimit
  change: |
    Added local rate limit listener filter to enable rate limit before TLS handshake and filter matching.
- area: proxy_protocol
  change: |
    Added the support :ref:`pass_through_tlvs for listener
    <envoy_v3_api_field_extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.pass_through_tlvs>` and
    :ref:`pass_through_tlvs for upsteam <envoy_v3_api_field_config.core.v3.ProxyProtocolConfig.pass_through_tlvs>`. They can
    control which Proxy Protocol V2 TLVs can be passed through by listener and upstream separately.
- area: tcp_proxy
  change: |
    Added support for propagating the response trailers in :ref:`TunnelingConfig
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.propagate_response_trailers>` to
    the downstream info filter state.
- area: sni_dynamic_forward_proxy
  change: |
    Added an option to dynamically set the host used by the SNI dynamic forward proxy filter, by setting a filter state
    object under the key ``envoy.upstream.dynamic_host``.
- area: access_log
  change: |
    Added support for :ref:`%DOWNSTREAM_TRANSPORT_FAILURE_REASON%
    <config_access_log_format_downstream_transport_failure_reason>` as a log command operator about why listener may have
    failed due to a transport socket error, including TLS handshake failures. added the field
    :ref:`downstream_transport_failure_reason
    <envoy_v3_api_field_data.accesslog.v3.AccessLogCommon.downstream_transport_failure_reason>` for common usage as well.
- area: generic_proxy
  change: |
    Added :ref:`tracing support <envoy_v3_api_field_extensions.filters.network.generic_proxy.v3.GenericProxy.tracing>` for
    the generic proxy.
- area: jwt_authn
  change: |
    Added :ref:`failed_status_in_metadata
    <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.failed_status_in_metadata>` to support setting the
    JWT authentication failure status code and message in dynamic metadata.
- area: ext_proc
  change: |
    Added the support :ref:`override_message_timeout
    <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.override_message_timeout>` for the ext_proc server to send
    back a message to Envoy to extend the ext_proc timer. added the field :ref:`max_message_timeout
    <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.max_message_timeout>` for specifying the max
    override_message_timeout could be sent back by the ext_proc server.
- area: http filter
  change: |
    Added :ref:`header mutation http filter <config_http_filters_header_mutation>` which adds the ability to modify request
    and response headers in any position of HTTP filter chain.
- area: matching
  change: |
    Added :ref:`Filter State Input <envoy_v3_api_msg_extensions.matching.common_inputs.network.v3.FilterStateInput>` for
    matching based on filter state objects.
- area: overload manager
  change: |
    Added stat ``overload.refresh_interval_delay`` to track the delay between overload manager resource loop refresh in
    milliseconds.
- area: load shed point
  change: |
    Added load shed point ``envoy.load_shed_points.tcp_listener_accept`` that rejects new tcp connections
    by closing the connection before the new connection accept phase.
- area: http
  change: |
    Make adding ProxyProtocolFilterState in the HCM optional.
- area: sni_dynamic_forward_proxy
  change: |
    Added an option to dynamically set the port used by the SNI dynamic forward proxy filter, by setting a filter state
    object under the key ``envoy.upstream.dynamic_port``.
- area: route
  change: |
    Support dynamic clusters for :ref:`VirtualHost.matcher <envoy_v3_api_field_config.route.v3.VirtualHost.matcher>`.
- area: route
  change: |
    Support route callback after route matches for :ref:`VirtualHost.matcher
    <envoy_v3_api_field_config.route.v3.VirtualHost.matcher>`.
- area: tcp_proxy
  change: |
    Added an option to dynamically disable TCP tunneling even if set in the filter config, by setting a filter state object
    for the key ``envoy.tcp_proxy.disable_tunneling``.
- area: tcp_proxy
  change: |
    Add :ref:`flush access log on connected
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.flush_access_log_on_connected>` to allow recording
    an access log entry on the connection open event. This option does not require periodic access logging enabled, and the
    other way around.
- area: http
  change: |
    Add :ref:`periodic access logging
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.access_log_flush_interval>`
    to http access logs for long-lived requests (Websockets, CONNECT, etc). :ref:`%DURATION%
    <config_access_log_format_duration>` will be empty for mid-request logs. Enabling this may affect access loggers and
    filters that register as access loggers that expect to be called only once.
- area: http
  change: |
    Add :ref:`flush access log on new request
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.flush_access_log_on_new_request>`
    to allow recording an access log entry when a new HTTP request is received by the HTTP connection manager. Details
    related to upstream cluster, such as upstream host, will not be available for this log. This option does not require
    periodic access logging enabled, and the other way around.
- area: redis_health_check
  change: |
    Added :ref:`exists_failure <config_health_checkers_redis>` stat to indicate health check failures caused by EXISTS check
    failure.
- area: redis
  change: |
    Added :ref:`wait_for_warm_on_init <envoy_v3_api_field_config.cluster.v3.Cluster.wait_for_warm_on_init>` support for
    :ref:`Redis Cluster<arch_overview_redis>`.
- area: ext_authz
  change: |
    Added :ref:`include_tls_session <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.include_tls_session>`
    to support sending TLS SNI data as part of CheckRequest for authorization check.
- area: router
  change: |
    Add :ref:`flush upstream log on upstream stream
    <envoy_v3_api_field_extensions.filters.http.router.v3.Router.UpstreamAccessLogOptions.flush_upstream_log_on_upstream_stream>`
    to allow recording an upstream access log entry when a new HTTP request is received, and the upstream stream is created.
    Note that in case a retry is applied for the received request, a start of request upstream access
    log will be recorded for each retry.
- area: tls
  change: |
    Added new field :ref:`signature_algorithms
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsParameters.signature_algorithms>` to set signature
    algorithms.
- area: metrics_service
  change: |
    Added new configuration field :ref:`histogram_emit_mode
    <envoy_v3_api_field_config.metrics.v3.MetricsServiceConfig.histogram_emit_mode>` to configure which stats
    should be emitted for histograms.
- area: http
  change: |
    Added capability for continuing filter chain iteration or send local replies from (decode|encode)Metadata. Additionally,
    reset idle timer on metadata actions.
- area: grpc
  change: |
    Added support for buf connect HTTP GET requests in the
    :ref:`connect_grpc_bridge filter <config_http_filters_connect_grpc_bridge>`.

deprecated:
- area: tcp_proxy
  change: |
    Deprecated (1.25.0) :ref:`access_log_flush_interval
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.access_log_flush_interval>` in favour
    of :ref:`access_log_flush_interval
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.access_log_flush_interval>`.
- area: tcp_proxy
  change: |
    Deprecated (1.25.0) :ref:`flush_access_log_on_connected
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.flush_access_log_on_connected>` in favour
    of :ref:`flush_access_log_on_connected
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.flush_access_log_on_connected>`.
- area: ext_authz
  change: |
    Deprecated (1.25.0) :ref:`ext_authz.v3.AuthorizationRequest.allowed_headers
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationRequest.allowed_headers>` in favour of
    :ref:`ext_authz.v3.ExtAuthz.allowed_headers
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.allowed_headers>`.
- area: http
  change: |
    Deprecated (1.25.0) :ref:`flush access log on new request
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.flush_access_log_on_new_request>`
    in favour of :ref:`flush access log on new request
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.flush_access_log_on_new_request>`.
- area: http
  change: |
    Deprecated (1.25.0) :ref:`periodic access logging
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.access_log_flush_interval>`
    in favour of :ref:`periodic access logging
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.access_log_flush_interval>`.
date: December 2, 2022

bug_fixes:
- area: ci
  change: |
    assorted fixes.
- area: dependencies
  change: |
    update Curl, Kafka, Wasm to mitigate CVEs.
- area: docker
  change: |
    update Docker images (``distroless`` -> ``4b22ca3c6``) to resolve CVE issues in container packages.
date: November 8, 2019

changes:
- area: listener
  change: |
    fixed CVE-2019-18836 by clearing accept filters before connection creation.
date: June 16, 2022

bug_fixes:
- area: ci
  change: |
    fix disk space issue that have prevented publication.
date: December 7, 2020

changes:
- area: listener
  change: |
    fix crash when disabling or re-enabling listeners due to overload while processing LDS updates.
- area: proxy_proto
  change: |
    fixed a bug where network filters would not have the correct downstreamRemoteAddress() when accessed from the
    StreamInfo. This could result in incorrect enforcement of RBAC rules in the RBAC network filter (but not in the RBAC
    HTTP filter), or incorrect access log addresses from tcp_proxy.
- area: tls
  change: |
    fix read resumption after triggering buffer high-watermark and all remaining request/response bytes are stored in the
    SSL connection's internal buffers.
- area: udp
  change: |
    fixed issue in which receiving truncated UDP datagrams would cause Envoy to crash.
- area: vrp
  change: |
    allow supervisord to open its log file.
date: December 3, 2022

bug_fixes:
- area: ci
  change: |
    assorted fixes.
- area: dependencies
  change: |
    update Curl, Kafka, Wasm to mitigate CVEs.
- area: docker
  change: |
    update Docker images (``distroless`` -> ``4b22ca3c6``) to resolve CVE issues in container packages.
date: April 27, 2022

minor_behavior_changes:
- area: cryptomb
  change: |
    remove RSA PKCS1 v1.5 padding support.
- area: perf
  change: |
    ssl contexts are now tracked without scan based garbage collection and greatly improved the performance on secret
    update.
date: April 15, 2020

changes:
- area: http
  change: |
    fixed a crash upon receiving empty HTTP/2 metadata frames. Received empty metadata frames are now counted in the HTTP/2
    codec stat :ref:`metadata_empty_frames <config_http_conn_man_stats_per_codec>`.
- area: http
  change: |
    fixed a remotely exploitable integer overflow via a very large grpc-timeout value causes undefined behavior.
- area: http
  change: |
    fixed bugs in datadog and squash filter's handling of responses with no bodies.
- area: http
  change: |
    fixed URL parsing for HTTP/1.1 fully qualified URLs and connect requests containing IPv6 addresses.
- area: tls
  change: |
    fix detection of the upstream connection close event.
date: April 12, 2023

bug_fixes:
- area: dependency
  change: |
    update Curl -> 8.0.1 to resolve CVE-2023-27535, CVE-2023-27536, CVE-2023-27538.
- area: http
  change: |
    amend the fix for ``x-envoy-original-path`` so it removes the header only at edge.
    Previously this would also remove the header at any Envoy instance upstream of an external request, including an Envoy
    instance that added the header.
date: February 22, 2022

behavior_changes:
- area: dns_filter
  change: |
    :ref:`dns_filter <envoy_v3_api_msg_extensions.filters.udp.dns_filter.v3alpha.DnsFilterConfig>` protobuf fields have been
    renumbered to restore compatibility with Envoy 1.18, breaking compatibility with Envoy 1.19.0 and 1.19.1. The new field
    numbering allows control planes supporting Envoy 1.18 to gracefully upgrade to :ref:`dns_resolution_config
    <envoy_v3_api_field_extensions.filters.udp.dns_filter.v3alpha.DnsFilterConfig.ClientContextConfig.dns_resolution_config>`,
    provided they skip over Envoy 1.19.0 and 1.19.1. Control planes upgrading from Envoy 1.19.0 and 1.19.1 will need to
    vendor the corresponding protobuf definitions to ensure that the renumbered fields have the types expected by those
    releases.

bug_fixes:
- area: data plane
  change: |
    fix crash when internal redirect selects a route configured with direct response or redirect actions.
- area: jwt_authn
  change: |
    fixed the crash when a CONNECT request is sent to JWT filter configured with regex match on the Host header.
- area: listener
  change: |
    fixed an issue on Windows where connections are not handled by all worker threads.
- area: tcp_proxy
  change: |
    fix a crash that occurs when configured for :ref:`upstream tunneling
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.tunneling_config>` and the downstream connection
    disconnects while the the upstream connection or http/2 stream is still being established.
date: April 5, 2019

changes:
- area: access log
  change: |
    added a new flag for upstream retry count exceeded.
- area: access log
  change: |
    added a :ref:`gRPC filter <envoy_api_msg_config.filter.accesslog.v2.GrpcStatusFilter>` to allow filtering on gRPC
    status.
- area: access log
  change: |
    added a new flag for stream idle timeout.
- area: access log
  change: |
    added a new field for upstream transport failure reason in :ref:`file access logger
    <config_access_log_format_upstream_transport_failure_reason>` and :ref:`gRPC access logger
    <envoy_api_field_data.accesslog.v2.AccessLogCommon.upstream_transport_failure_reason>` for HTTP access logs.
- area: access log
  change: |
    added new fields for downstream x509 information (URI sans and subject) to file and gRPC access logger.
- area: admin
  change: |
    the admin server can now be accessed via HTTP/2 (prior knowledge).
- area: admin
  change: |
    changed HTTP response status code from 400 to 405 when attempting to GET a POST-only route (such as /quitquitquit).
- area: buffer
  change: |
    fix vulnerabilities when allocation fails.
- area: build
  change: |
    releases are built with GCC-7 and linked with LLD.
- area: build
  change: |
    dev docker images :ref:`have been split <install_binaries>` from tagged images for easier discoverability in Docker Hub.
    Additionally, we now build images for point releases.
- area: config
  change: |
    added support of using google.protobuf.Any in opaque configs for extensions.
- area: config
  change: |
    logging warnings when deprecated fields are in use.
- area: config
  change: |
    removed deprecated --v2-config-only from command line config.
- area: config
  change: |
    removed deprecated_v1 sds_config from :ref:`Bootstrap config <config_overview_v2_bootstrap>`.
- area: config
  change: |
    removed the deprecated_v1 config option from :ref:`ring hash <envoy_api_msg_Cluster.RingHashLbConfig>`.
- area: config
  change: |
    removed REST_LEGACY as a valid :ref:`ApiType <envoy_api_field_core.ApiConfigSource.api_type>`.
- area: config
  change: |
    finish cluster warming only when a named response i.e. ClusterLoadAssignment associated to the cluster being warmed
    comes in the EDS response. This is a behavioural change from the current implementation where warming of cluster
    completes on missing load assignments also.
- area: config
  change: |
    use Envoy cpuset size to set the default number or worker threads if :option:`--cpuset-threads` is enabled.
- area: config
  change: |
    added support for :ref:`initial_fetch_timeout <envoy_api_field_core.ConfigSource.initial_fetch_timeout>`. The timeout is
    disabled by default.
- area: cors
  change: |
    added :ref:`filter_enabled & shadow_enabled RuntimeFractionalPercent flags <cors-runtime>` to filter.
- area: csrf
  change: |
    added.
- area: ext_authz
  change: |
    added support for buffering request body.
- area: ext_authz
  change: |
    migrated from v2alpha to v2 and improved docs.
- area: ext_authz
  change: |
    added a configurable option to make the gRPC service cross-compatible with V2Alpha. Note that this feature is already
    deprecated. It should be used for a short time, and only when transitioning from alpha to V2 release version.
- area: ext_authz
  change: |
    migrated from v2alpha to v2 and improved the documentation.
- area: ext_authz
  change: |
    authorization request and response configuration has been separated into two distinct objects: :ref:`authorization
    request <envoy_api_field_config.filter.http.ext_authz.v2.HttpService.authorization_request>` and :ref:`authorization
    response <envoy_api_field_config.filter.http.ext_authz.v2.HttpService.authorization_response>`. In addition,
    :ref:`client headers <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_client_headers>` and
    :ref:`upstream headers <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_upstream_headers>`
    replaces the previous ``allowed_authorization_headers-`` object. All the control header lists now support :ref:`string
    matcher <envoy_api_msg_type.matcher.StringMatcher>` instead of standard string.
- area: fault
  change: |
    added the :ref:`max_active_faults <envoy_api_field_config.filter.http.fault.v2.HTTPFault.max_active_faults>` setting, as
    well as :ref:`statistics <config_http_filters_fault_injection_stats>` for the number of active faults and the number of
    faults the overflowed.
- area: fault
  change: |
    added :ref:`response rate limit <envoy_api_field_config.filter.http.fault.v2.HTTPFault.response_rate_limit>` fault
    injection.
- area: fault
  change: |
    added :ref:`HTTP header fault configuration <config_http_filters_fault_injection_http_header>` to the HTTP fault filter.
- area: governance
  change: |
    extending Envoy deprecation policy from 1 release (0-3 months) to 2 releases (3-6 months).
- area: health check
  change: |
    expected response codes in http health checks are now :ref:`configurable
    <envoy_api_msg_core.HealthCheck.HttpHealthCheck>`.
- area: http
  change: |
    added new grpc_http1_reverse_bridge filter for converting gRPC requests into HTTP/1.1 requests.
- area: http
  change: |
    fixed a bug where Content-Length:0 was added to HTTP/1 204 responses.
- area: http
  change: |
    added :ref:`max request headers size
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.max_request_headers_kb>`. The
    default behaviour is unchanged.
- area: http
  change: |
    added modifyDecodingBuffer/modifyEncodingBuffer to allow modifying the buffered request/response data.
- area: http
  change: |
    added encodeComplete/decodeComplete. These are invoked at the end of the stream, after all data has been encoded/decoded
    respectively. Default implementation is a no-op.
- area: outlier_detection
  change: |
    added support for :ref:`outlier detection event protobuf-based logging <arch_overview_outlier_detection_logging>`.
- area: mysql
  change: |
    added a MySQL proxy filter that is capable of parsing SQL queries over MySQL wire protocol. Refer to :ref:`MySQL proxy
    <config_network_filters_mysql_proxy>` for more details.
- area: performance
  change: |
    new buffer implementation (disabled by default; to test it, add "--use-libevent-buffers 0" to the command-line arguments
    when starting Envoy).
- area: jwt_authn
  change: |
    added :ref:`filter_state_rules <envoy_api_field_config.filter.http.jwt_authn.v2alpha.jwtauthentication.rules>` to allow
    specifying requirements from filterState by other filters.
- area: ratelimit
  change: |
    removed deprecated rate limit configuration from bootstrap.
- area: redis
  change: |
    added :ref:`hashtagging
    <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.enable_hashtagging>` to guarantee a
    given key's upstream.
- area: redis
  change: |
    added :ref:`latency stats <config_network_filters_redis_proxy_per_command_stats>` for commands.
- area: redis
  change: |
    added :ref:`success and error stats <config_network_filters_redis_proxy_per_command_stats>` for commands.
- area: redis
  change: |
    migrate hash function for host selection to `MurmurHash2 <https://sites.google.com/site/murmurhash>`_ from std::hash.
    MurmurHash2 is compatible with std::hash in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled on
    Linux and not macOS.
- area: redis
  change: |
    added :ref:`latency_in_micros <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.latency_in_micros>` to
    specify the redis commands stats time unit in microseconds.
- area: router
  change: |
    added ability to configure a :ref:`retry policy <envoy_api_msg_route.RetryPolicy>` at the virtual host level.
- area: router
  change: |
    added reset reason to response body when upstream reset happens. After this change, the response body will be of the
    form ``upstream connect error or disconnect/reset before headers. reset reason:``.
- area: router
  change: |
    added :ref:`rq_reset_after_downstream_response_started <config_http_filters_router_stats>` counter stat to router stats.
- area: router
  change: |
    added per-route configuration of :ref:`internal redirects <envoy_api_field_route.RouteAction.internal_redirect_action>`.
- area: router
  change: |
    removed deprecated route-action level headers_to_add/remove.
- area: router
  change: |
    made :ref:`max retries header <config_http_filters_router_x-envoy-max-retries>` take precedence over the number of
    retries in route and virtual host retry policies.
- area: router
  change: |
    added support for prefix wildcards in :ref:`virtual host domains <envoy_api_field_route.VirtualHost.domains>`.
- area: stats
  change: |
    added support for histograms in prometheus.
- area: stats
  change: |
    added usedonly flag to prometheus stats to only output metrics which have been updated at least once.
- area: stats
  change: |
    added gauges tracking remaining resources before circuit breakers open.
- area: tap
  change: |
    added new alpha :ref:`HTTP tap filter <config_http_filters_tap>`.
- area: tls
  change: |
    enabled TLS 1.3 on the server-side (non-FIPS builds).
- area: upstream
  change: |
    add hash_function to specify the hash function for :ref:`ring hash <envoy_api_msg_Cluster.RingHashLbConfig>` as either
    xxHash or `murmurHash2 <https://sites.google.com/site/murmurhash>`_. MurmurHash2 is compatible with std::hash in GNU
    libstdc++ 3.4.20 or above. This is typically the case when compiled on Linux and not macOS.
- area: upstream
  change: |
    added :ref:`degraded health value <arch_overview_load_balancing_degraded>` which allows routing to certain hosts only
    when there are insufficient healthy hosts available.
- area: upstream
  change: |
    add cluster factory to allow creating and registering :ref:`custom cluster type
    <arch_overview_service_discovery_types_custom>`.
- area: upstream
  change: |
    added a :ref:`circuit breaker <arch_overview_circuit_break_cluster_maximum_connection_pools>` to limit the number of
    concurrent connection pools in use.
- area: tracing
  change: |
    added :ref:`verbose <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.tracing>` to
    support logging annotations on spans.
- area: upstream
  change: |
    added support for host weighting and :ref:`locality weighting <arch_overview_load_balancing_locality_weighted_lb>` in
    the :ref:`ring hash load balancer <arch_overview_load_balancing_types_ring_hash>`, and added a :ref:`maximum_ring_size
    <envoy_api_field_Cluster.RingHashLbConfig.maximum_ring_size>` config parameter to strictly bound the ring size.
- area: zookeeper
  change: |
    added a ZooKeeper proxy filter that parses ZooKeeper messages (requests/responses/events). Refer to :ref:`ZooKeeper
    proxy <config_network_filters_zookeeper_proxy>` for more details.
- area: upstream
  change: |
    added configuration option to select any host when the fallback policy fails.
- area: upstream
  change: |
    stopped incrementing upstream_rq_total for HTTP/1 conn pool when request is circuit broken.

deprecated:
- area: ext_authz
  change: |
    Use of ``use_alpha`` in :ref:`Ext-Authz Authorization Service
    <envoy_api_file_envoy/service/auth/v2/external_auth.proto>` is deprecated. It should be used for a short time, and only
    when transitioning from alpha to V2 release version.
- area: cors
  change: |
    Use of ``enabled`` in ``CorsPolicy``, found in :ref:`route.proto <envoy_api_file_envoy/api/v2/route/route.proto>`. Set
    the ``filter_enabled`` field instead.
- area: fault_delay
  change: |
    Use of the ``type`` field in the ``FaultDelay`` message (found in :ref:`fault.proto
    <envoy_api_file_envoy/config/filter/fault/v2/fault.proto>`) has been deprecated. It was never used and setting it has no
    effect. It will be removed in the following release.
date: June 21, 2018

changes:
- area: access log
  change: |
    added ability to log response trailers.
- area: access log
  change: |
    added ability to format START_TIME.
- area: access log
  change: |
    added ``DYNAMIC_METADATA`` :ref:`access log formatter <config_access_log_format>`.
- area: access log
  change: |
    added :ref:`HeaderFilter <envoy_api_msg_config.filter.accesslog.v2.HeaderFilter>` to filter logs based on request
    headers.
- area: access log
  change: |
    added ``%([1-9])?f`` as one of ``START_TIME`` specifiers to render subseconds.
- area: access log
  change: |
    gRPC Access Log Service (ALS) support added for :ref:`HTTP access logs
    <envoy_api_msg_config.accesslog.v2.HttpGrpcAccessLogConfig>`.
- area: access log
  change: |
    improved WebSocket logging.
- area: admin
  change: |
    added :http:get:`/config_dump` for dumping the current configuration and associated xDS version information (if
    applicable).
- area: admin
  change: |
    added :http:get:`/clusters?format=json` for outputing a JSON-serialized proto detailing the current status of all
    clusters.
- area: admin
  change: |
    added :http:get:`/stats/prometheus` as an alternative endpoint for getting stats in prometheus format.
- area: admin
  change: |
    added :ref:`/runtime_modify endpoint <operations_admin_interface_runtime_modify>` to add or change runtime values.
- area: admin
  change: |
    mutations must be sent as POSTs, rather than GETs. Mutations include: :http:post:`/cpuprofiler`,
    :http:post:`/healthcheck/fail`, :http:post:`/healthcheck/ok`, :http:post:`/logging`, :http:post:`/quitquitquit`,
    :http:post:`/reset_counters`, :http:post:`/runtime_modify?key1=value1&key2=value2&keyN=valueN`.
- area: admin
  change: |
    removed ``/routes`` endpoint; route configs can now be found at the :ref:`/config_dump endpoint
    <operations_admin_interface_config_dump>`.
- area: buffer filter
  change: |
    the buffer filter can be optionally :ref:`disabled
    <envoy_api_field_config.filter.http.buffer.v2.BufferPerRoute.disabled>` or :ref:`overridden
    <envoy_api_field_config.filter.http.buffer.v2.BufferPerRoute.buffer>` with route-local configuration.
- area: cli
  change: |
    added ``--config-yaml`` flag to the Envoy binary. When set its value is interpreted as a yaml representation of the
    bootstrap config and overrides ``--config-path``.
- area: cluster
  change: |
    added :ref:`option <envoy_api_field_Cluster.close_connections_on_host_health_failure>` to close ``tcp_proxy`` upstream
    connections when health checks fail.
- area: cluster
  change: |
    added :ref:`option <envoy_api_field_Cluster.drain_connections_on_host_removal>` to drain connections from hosts after
    they are removed from service discovery, regardless of health status.
- area: cluster
  change: |
    fixed bug preventing the deletion of all endpoints in a priority.
- area: debug
  change: |
    added symbolized stack traces (where supported).
- area: ext-authz filter
  change: |
    added support to raw HTTP authorization.
- area: ext-authz filter
  change: |
    added support to gRPC responses to carry HTTP attributes.
- area: grpc
  change: |
    support added for the full set of :ref:`Google gRPC call credentials
    <envoy_api_msg_core.GrpcService.GoogleGrpc.CallCredentials>`.
- area: gzip filter
  change: |
    added :ref:`stats <gzip-statistics>` to the filter.
- area: gzip filter
  change: |
    sending ``accept-encoding`` header as ``identity`` no longer compresses the payload.
- area: health check
  change: |
    added ability to set :ref:`additional HTTP headers
    <envoy_api_field_core.HealthCheck.HttpHealthCheck.request_headers_to_add>` for HTTP health check.
- area: health check
  change: |
    added support for EDS delivered :ref:`endpoint health status <envoy_api_field_endpoint.LbEndpoint.health_status>`.
- area: health check
  change: |
    added interval overrides for health state transitions from :ref:`healthy to unhealthy
    <envoy_api_field_core.HealthCheck.unhealthy_edge_interval>`, :ref:`unhealthy to healthy
    <envoy_api_field_core.HealthCheck.healthy_edge_interval>` and for subsequent checks on :ref:`unhealthy hosts
    <envoy_api_field_core.HealthCheck.unhealthy_interval>`.
- area: health check
  change: |
    added support for :ref:`custom health check <envoy_api_field_core.HealthCheck.custom_health_check>`.
- area: health check
  change: |
    health check connections can now be configured to use http/2.
- area: health check http filter
  change: |
    added :ref:`generic header matching <envoy_api_field_config.filter.http.health_check.v2.HealthCheck.headers>` to trigger
    health check response. Deprecated the endpoint option.
- area: http
  change: |
    filters can now optionally support :ref:`virtual host <envoy_api_field_route.VirtualHost.per_filter_config>`,
    :ref:`route <envoy_api_field_route.Route.per_filter_config>`, and :ref:`weighted cluster
    <envoy_api_field_route.WeightedCluster.ClusterWeight.per_filter_config>` local configuration.
- area: http
  change: |
    added the ability to pass DNS type Subject Alternative Names of the client certificate in the
    :ref:`v1.7:config_http_conn_man_headers_x-forwarded-client-cert` header.
- area: http
  change: |
    local responses to gRPC requests are now sent as trailers-only gRPC responses instead of plain HTTP responses. Notably
    the HTTP response code is always "200" in this case, and the gRPC error code is carried in "grpc-status" header,
    optionally accompanied with a text message in "grpc-message" header.
- area: http
  change: |
    added support for :ref:`via header
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.via>` append.
- area: http
  change: |
    added a :ref:`configuration option
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.skip_xff_append>` to elide
    ``x-forwarded-for-`` header modifications.
- area: http
  change: |
    fixed a bug in inline headers where ``addCopy`` and ``addViaMove`` didn't add header values when encountering inline
    headers with multiple instances.
- area: listeners
  change: |
    added :ref:`tcp_fast_open_queue_length <envoy_api_field_Listener.tcp_fast_open_queue_length>` option.
- area: listeners
  change: |
    added the ability to match :ref:`FilterChain <envoy_api_msg_listener.FilterChain>` using :ref:`application_protocols
    <envoy_api_field_listener.FilterChainMatch.application_protocols>` (e.g. ALPN for TLS protocol).
- area: listeners
  change: |
    ``sni_domains`` has been deprecated/renamed to :ref:`server_names
    <envoy_api_field_listener.FilterChainMatch.server_names>`.
- area: listeners
  change: |
    removed restriction on all filter chains having identical filters.
- area: load balancer
  change: |
    added :ref:`weighted round robin <arch_overview_load_balancing_types_round_robin>` support. The round robin scheduler
    now respects endpoint weights and also has improved fidelity across picks.
- area: load balancer
  change: |
    :ref:`locality weighted load balancing <arch_overview_load_balancer_subsets>` is now supported.
- area: load balancer
  change: |
    ability to configure zone aware load balancer settings :ref:`through the API
    <envoy_api_field_Cluster.CommonLbConfig.zone_aware_lb_config>`.
- area: load balancer
  change: |
    the :ref:`weighted least request <arch_overview_load_balancing_types_least_request>` load balancing algorithm has been
    improved to have better balance when operating in weighted mode.
- area: logger
  change: |
    added the ability to optionally set the log format via the :option:`--log-format` option.
- area: logger
  change: |
    all :ref:`logging levels <operations_admin_interface_logging>` can be configured at run-time: trace debug info warning
    error critical.
- area: rbac http filter
  change: |
    a :ref:`role-based access control http filter <config_http_filters_rbac>` has been added.
- area: router
  change: |
    the behavior of per-try timeouts have changed in the case where a portion of the response has already been proxied
    downstream when the timeout occurs. Previously, the response would be reset leading to either an HTTP/2 reset or an
    HTTP/1 closed connection and a partial response. Now, the timeout will be ignored and the response will continue to
    proxy up to the global request timeout.
- area: router
  change: |
    changed the behavior of :ref:`source IP routing
    <envoy_api_field_route.RouteAction.HashPolicy.ConnectionProperties.source_ip>` to ignore the source port.
- area: router
  change: |
    added an :ref:`prefix_match <envoy_api_field_route.HeaderMatcher.prefix_match>` match type to explicitly match based on
    the prefix of a header value.
- area: router
  change: |
    added an :ref:`suffix_match <envoy_api_field_route.HeaderMatcher.suffix_match>` match type to explicitly match based on
    the suffix of a header value.
- area: router
  change: |
    added an :ref:`present_match <envoy_api_field_route.HeaderMatcher.present_match>` match type to explicitly match based
    on a header's presence.
- area: router
  change: |
    added an :ref:`invert_match <envoy_api_field_route.HeaderMatcher.invert_match>` config option which supports inverting
    all other match types to match based on headers which are not a desired value.
- area: router
  change: |
    allow :ref:`cookie routing <envoy_api_msg_route.RouteAction.HashPolicy.Cookie>` to generate session cookies.
- area: router
  change: |
    added ``START_TIME`` as one of supported variables in :ref:`header formatters
    <config_http_conn_man_headers_custom_request_headers>`.
- area: router
  change: |
    added a :ref:`max_grpc_timeout <envoy_api_field_route.RouteAction.max_grpc_timeout>` config option to specify the
    maximum allowable value for timeouts decoded from gRPC header field ``grpc-timeout``.
- area: router
  change: |
    added a :ref:`configuration option <envoy_api_field_config.filter.http.router.v2.Router.suppress_envoy_headers>` to
    disable *x-envoy-* header generation.
- area: router
  change: |
    added 'unavailable' to the retriable gRPC status codes that can be specified through :ref:`x-envoy-retry-grpc-on
    <config_http_filters_router_x-envoy-retry-grpc-on>`.
- area: sockets
  change: |
    added :ref:`tap transport socket extension <operations_traffic_capture>` to support recording plain text traffic and
    PCAP generation.
- area: sockets
  change: |
    added ``IP_FREEBIND`` socket option support for :ref:`listeners <envoy_api_field_Listener.freebind>` and upstream
    connections via :ref:`cluster manager wide <envoy_api_field_config.bootstrap.v2.ClusterManager.upstream_bind_config>`
    and :ref:`cluster specific <envoy_api_field_Cluster.upstream_bind_config>` options.
- area: sockets
  change: |
    added ``IP_TRANSPARENT`` socket option support for :ref:`listeners <envoy_api_field_Listener.transparent>`.
- area: sockets
  change: |
    added ``SO_KEEPALIVE`` socket option for upstream connections :ref:`per cluster
    <envoy_api_field_Cluster.upstream_connection_options>`.
- area: stats
  change: |
    added support for histograms.
- area: stats
  change: |
    added :ref:`option to configure the statsd prefix <envoy_api_field_config.metrics.v2.StatsdSink.prefix>`.
- area: stats
  change: |
    updated stats sink interface to flush through a single call.
- area: tls
  change: |
    added support for :ref:`verify_certificate_spki
    <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>`.
- area: tls
  change: |
    added support for multiple :ref:`verify_certificate_hash
    <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` values.
- area: tls
  change: |
    added support for using :ref:`verify_certificate_spki
    <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>` and :ref:`verify_certificate_hash
    <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` without :ref:`trusted_ca
    <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.
- area: tls
  change: |
    added support for allowing expired certificates with :ref:`allow_expired_certificate
    <envoy_api_field_auth.CertificateValidationContext.allow_expired_certificate>`.
- area: tls
  change: |
    added support for :ref:`renegotiation <envoy_api_field_auth.UpstreamTlsContext.allow_renegotiation>` when acting as a
    client.
- area: tls
  change: |
    removed support for legacy SHA-2 CBC cipher suites.
- area: tracing
  change: |
    the sampling decision is now delegated to the tracers, allowing the tracer to decide when and if to use it. For example,
    if the :ref:`x-b3-sampled <config_http_conn_man_headers_x-b3-sampled>` header is supplied with the client request, its
    value will override any sampling decision made by the Envoy proxy.
- area: websocket
  change: |
    support configuring idle_timeout and max_connect_attempts.
- area: upstream
  change: |
    added support for host override for a request in :ref:`Original destination host request header
    <arch_overview_load_balancing_types_original_destination_request_header>`.
- area: header to metadata
  change: |
    added :ref:`HTTP Header to Metadata filter <config_http_filters_header_to_metadata>`.

deprecated:
- area: admin
  change: |
    Admin mutations should be sent as POSTs rather than GETs. HTTP GETs will result in an error status code and will not
    have their intended effect. Prior to 1.7, GETs can be used for admin mutations, but a warning is logged.
- area: rate_limiting
  change: |
    Rate limit service configuration via the ``cluster_name`` field is deprecated. Use ``grpc_service`` instead.
- area: grpc
  change: |
    gRPC service configuration via the ``cluster_names`` field in ``ApiConfigSource`` is deprecated. Use ``grpc_services``
    instead. Prior to 1.7, a warning is logged.
- area: health_checking
  change: |
    Redis health checker configuration via the ``redis_health_check`` field in ``HealthCheck`` is deprecated. Use
    ``custom_health_check`` with name ``envoy.health_checkers.redis`` instead. Prior to 1.7, ``redis_health_check`` can be
    used, but warning is logged.
- area: tls
  change: |
    ``SAN`` is replaced by ``URI`` in the ``x-forwarded-client-cert`` header.
- area: health_checking
  change: |
    The ``endpoint`` field in the http health check filter is deprecated in favor of the ``headers`` field where one can
    specify HeaderMatch objects to match on.
- area: sni
  change: |
    The ``sni_domains`` field in the filter chain match was deprecated/renamed to ``server_names``.
date: July 25, 2023

minor_behavior_changes:
- area: http
  change: |
    Envoy will now lower case scheme values by default. This behaviorial change can be temporarily reverted
    by setting runtime guard ``envoy.reloadable_features.lowercase_scheme`` to ``false``.

bug_fixes:
- area: cors
  change: |
    Fix a use-after-free bug that occurs in the CORS filter if the ``origin`` header is removed between
    request header decoding and response header encoding.

    Fix `CVE-2023-35943 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-mc6h-6j9x-v3gq>`_.
- area: http
  change: |
    Switched Envoy internal scheme checks from case sensitive to case insensitive. This behaviorial change can be temporarily
    reverted by setting runtime guard ``envoy.reloadable_features.handle_uppercase_scheme`` to ``false``.

    Fix `CVE-2023-35944 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-pvgm-7jpg-pw5g>`_.
- area: opentelemetry/grpc/access log
  change: |
    Fixed a bug in the open telemetry access logger. This logger now uses the
    server scope for stats instead of the listener's global scope. This fixes a
    use-after-free that can occur if the listener is drained but the cached
    gRPC access logger uses the listener's global scope for stats.

    Fix `CVE-2023-35942 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-69vr-g55c-v2v4>`_.
- area: oauth2
  change: |
    Fixed a cookie validator bug that HMAC calculation could be same for different payloads.

    This prevents malicious clients from constructing credentials with permanent validity in some specific scenarios.

    Fix `CVE-2023-35941 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-7mhv-gr67-hq55>`_.

new_features:
- area: tls
  change: |
    Added FIPS compliant build for arm64.
date: April 2, 2019

changes:
- area: http
  change: |
    fixed CVE-2019-9900 by rejecting HTTP/1.x headers with embedded NUL characters.
- area: http
  change: |
    fixed CVE-2019-9901 by normalizing HTTP paths prior to routing or L7 data plane processing. This defaults off and is
    configurable via either HTTP connection manager :ref:`normalize_path
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.normalize_path>` or the
    :ref:`runtime <config_http_conn_man_runtime_normalize_path>`.
date: July 13, 2023

bug_fixes:
- area: original_dst
  change: |
    Fixes an issue with the ORIGINAL_DST cluster cleanup timer lifetime, which
    can occur if the cluster is removed while the timer is armed.
- area: http2
  change: |
    Fix memory leak in nghttp2 when scheduled requests are cancelled due to the ``GOAWAY`` frame being received from the
    upstream service. Fix `CVE-2023-35945 <https://nvd.nist.gov/vuln/detail/CVE-2023-35945>`_.
date: December 20, 2018

changes:
- area: access log
  change: |
    added a :ref:`JSON logging mode <config_access_log_format_dictionaries>` to output access logs in JSON format.
- area: access log
  change: |
    added dynamic metadata to access log messages streamed over gRPC.
- area: access log
  change: |
    added ``DOWNSTREAM_CONNECTION_TERMINATION``.
- area: admin
  change: |
    :http:post:`/logging` now responds with 200 while there are no params.
- area: admin
  change: |
    added support for displaying subject alternate names in :ref:`certs <operations_admin_interface_certs>` end point.
- area: admin
  change: |
    added host weight to the :http:get:`/clusters?format=json` end point response.
- area: admin
  change: |
    :http:get:`/server_info` now responds with a JSON object instead of a single string.
- area: admin
  change: |
    :http:get:`/server_info` now exposes what stage of initialization the server is currently in.
- area: admin
  change: |
    added support for displaying command line options in :http:get:`/server_info` end point.
- area: circuit-breaker
  change: |
    added cx_open, rq_pending_open, rq_open and rq_retry_open gauges to expose live state via :ref:`circuit breakers
    statistics <config_cluster_manager_cluster_stats_circuit_breakers>`.
- area: cluster
  change: |
    set a default of 1s for :ref:`option <envoy_api_field_Cluster.CommonLbConfig.update_merge_window>`.
- area: config
  change: |
    removed support for the v1 API.
- area: config
  change: |
    added support for :ref:`rate limiting <envoy_api_msg_core.RateLimitSettings>` discovery request calls.
- area: cors
  change: |
    added :ref:`invalid/valid stats <cors-statistics>` to filter.
- area: ext-authz
  change: |
    added support for providing per route config - optionally disable the filter and provide context extensions.
- area: fault
  change: |
    removed integer percentage support.
- area: grpc-json
  change: |
    added support for :ref:`ignoring query parameters
    <envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.ignored_query_parameters>`.
- area: health check
  change: |
    added :ref:`logging health check failure events <envoy_api_field_core.HealthCheck.always_log_health_check_failures>`.
- area: health check
  change: |
    added ability to set :ref:`authority header value <envoy_api_field_core.HealthCheck.GrpcHealthCheck.authority>` for gRPC
    health check.
- area: http
  change: |
    added HTTP/2 WebSocket proxying via :ref:`extended CONNECT <envoy_api_field_core.Http2ProtocolOptions.allow_connect>`.
- area: http
  change: |
    added limits to the number and length of header modifications in all fields request_headers_to_add and
    response_headers_to_add. These limits are very high and should only be used as a last-resort safeguard.
- area: http
  change: |
    added support for a :ref:`request timeout
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.request_timeout>`. The timeout
    is disabled by default.
- area: http
  change: |
    no longer adding whitespace when appending ``X-Forwarded-For headers``. **Warning**: this is not compatible with 1.7.0
    builds prior to `9d3a4eb4ac44be9f0651fcc7f87ad98c538b01ee <https://github.com/envoyproxy/envoy/pull/3610>`_. See `#3611
    <https://github.com/envoyproxy/envoy/issues/3611>`_ for details.
- area: http
  change: |
    augmented the ``sendLocalReply`` filter API to accept an optional ``GrpcStatus`` value to override the default HTTP to
    gRPC status mapping.
- area: http
  change: |
    no longer close the TCP connection when a HTTP/1 request is retried due to a response with empty body.
- area: http
  change: |
    added support for more gRPC content-type headers in :ref:`gRPC bridge filter <config_http_filters_grpc_bridge>`, like
    application/grpc+proto.
- area: listeners
  change: |
    all listener filters are now governed by the :ref:`listener_filters_timeout
    <envoy_api_field_Listener.listener_filters_timeout>` setting. The hard coded 15s timeout in the :ref:`TLS inspector
    listener filter <config_listener_filters_tls_inspector>` is superseded by this setting.
- area: listeners
  change: |
    added the ability to match :ref:`FilterChain <envoy_api_msg_listener.FilterChain>` using :ref:`source_type
    <envoy_api_field_listener.FilterChainMatch.source_type>`.
- area: load balancer
  change: |
    added a :ref:`configuration <envoy_api_msg_Cluster.LeastRequestLbConfig>` option to specify the number of choices made
    in P2C.
- area: logging
  change: |
    added missing ``[`` in log prefix.
- area: mongo_proxy
  change: |
    added :ref:`dynamic metadata <config_network_filters_mongo_proxy_dynamic_metadata>`.
- area: network
  change: |
    removed the reference to ``FilterState`` in ``Connection`` in favor of ``StreamInfo``.
- area: rate-limit
  change: |
    added :ref:`configuration
    <envoy_api_field_config.filter.http.rate_limit.v2.RateLimit.rate_limited_as_resource_exhausted>` to specify whether the
    ``GrpcStatus`` status returned should be ``RESOURCE_EXHAUSTED`` or ``UNAVAILABLE`` when a gRPC call is rate limited.
- area: rate-limit
  change: |
    removed support for the legacy ratelimit service and made the data-plane-api :ref:`rls.proto
    <envoy_api_file_envoy/service/ratelimit/v2/rls.proto>` based implementation default.
- area: rate-limit
  change: |
    removed the deprecated cluster_name attribute in :ref:`rate limit service configuration
    <envoy_api_file_envoy/config/ratelimit/v2/rls.proto>`.
- area: rate-limit
  change: |
    added :ref:`rate_limit_service <envoy_api_msg_config.filter.http.rate_limit.v2.RateLimit>` configuration to filters.
- area: rbac
  change: |
    added dynamic metadata to the network level filter.
- area: rbac
  change: |
    added support for permission matching by :ref:`requested server name
    <envoy_api_field_config.rbac.v2alpha.permission.requested_server_name>`.
- area: redis
  change: |
    static cluster configuration is no longer required. Redis proxy will work with clusters delivered via CDS.
- area: router
  change: |
    added ability to configure arbitrary :ref:`retriable status codes
    <envoy_api_field_route.routeaction.retrypolicy.retriable_status_codes>`.
- area: router
  change: |
    added ability to set attempt count in upstream requests, see :ref:`virtual host's include request attempt count flag
    <envoy_api_field_route.VirtualHost.include_request_attempt_count>`.
- area: router
  change: |
    added internal :ref:`grpc-retry-on <config_http_filters_router_x-envoy-retry-grpc-on>` policy.
- area: router
  change: |
    added :ref:`scheme_redirect <envoy_api_field_route.RedirectAction.scheme_redirect>` and :ref:`port_redirect
    <envoy_api_field_route.RedirectAction.port_redirect>` to define the respective scheme and port rewriting RedirectAction.
- area: router
  change: |
    when :ref:`max_grpc_timeout <envoy_api_field_route.RouteAction.max_grpc_timeout>` is set, Envoy will now add or update
    the grpc-timeout header to reflect Envoy's expected timeout.
- area: router
  change: |
    per try timeouts now starts when an upstream stream is ready instead of when the request has been fully decoded by
    Envoy.
- area: router
  change: |
    added support for not retrying :ref:`rate limited requests <config_http_filters_router_x-envoy-ratelimited>`. Rate limit
    filter now sets the :ref:`x-envoy-ratelimited <config_http_filters_router_x-envoy-ratelimited>` header so the rate
    limited requests that may have been retried earlier will not be retried with this change.
- area: router
  change: |
    added support for enabling upgrades on a :ref:`per-route <envoy_api_field_route.RouteAction.upgrade_configs>` basis.
- area: router
  change: |
    support configuring a default fraction of mirror traffic via :ref:`runtime_fraction
    <envoy_api_field_route.RouteAction.RequestMirrorPolicy.runtime_key>`.
- area: sandbox
  change: |
    added :ref:`cors sandbox <install_sandboxes_cors>`.
- area: server
  change: |
    added ``SIGINT`` (Ctrl-C) handler to gracefully shutdown Envoy like ``SIGTERM``.
- area: stats
  change: |
    added :ref:`stats_matcher <envoy_api_field_config.metrics.v2.StatsConfig.stats_matcher>` to the bootstrap config for
    granular control of stat instantiation.
- area: stream
  change: |
    renamed the ``RequestInfo`` namespace to ``StreamInfo`` to better match its behaviour within TCP and HTTP
    implementations.
- area: stream
  change: |
    renamed ``perRequestState`` to ``filterState`` in ``StreamInfo``.
- area: stream
  change: |
    added ``downstreamDirectRemoteAddress`` to ``StreamInfo``.
- area: thrift_proxy
  change: |
    introduced thrift rate limiter filter.
- area: tls
  change: |
    added ssl.curves.<curve>, ssl.sigalgs.<sigalg> and ssl.versions.<version> to :ref:`listener metrics
    <config_listener_stats>` to track TLS algorithms and versions in use.
- area: tls
  change: |
    added support for :ref:`client-side session resumption <envoy_api_field_auth.UpstreamTlsContext.max_session_keys>`.
- area: tls
  change: |
    added support for CRLs in :ref:`trusted_ca <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.
- area: tls
  change: |
    added support for :ref:`multiple server TLS certificates <arch_overview_ssl_cert_select>`.
- area: tls
  change: |
    added support for :ref:`password encrypted private keys <envoy_api_field_auth.TlsCertificate.password>`.
- area: tls
  change: |
    added the ability to build :ref:`BoringSSL FIPS <arch_overview_ssl_fips>` using ``--define boringssl=fips`` Bazel
    option.
- area: tls
  change: |
    removed support for ECDSA certificates with curves other than P-256.
- area: tls
  change: |
    removed support for RSA certificates with keys smaller than 2048-bits.
- area: tracing
  change: |
    added support to the Zipkin tracer for the :ref:`b3 <config_http_conn_man_headers_b3>` single header format.
- area: tracing
  change: |
    added support for :ref:`Datadog <arch_overview_tracing>` tracer.
- area: upstream
  change: |
    added :ref:`scale_locality_weight <envoy_api_field_Cluster.LbSubsetConfig.scale_locality_weight>` to enable scaling
    locality weights by number of hosts removed by subset lb predicates.
- area: upstream
  change: |
    changed how load calculation for :ref:`priority levels <arch_overview_load_balancing_priority_levels>` and :ref:`panic
    thresholds <arch_overview_load_balancing_panic_threshold>` interact. As long as normalized total health is 100% panic
    thresholds are disregarded.
- area: upstream
  change: |
    changed the default hash for :ref:`ring hash <envoy_api_msg_Cluster.RingHashLbConfig>` from std::hash to `xxHash
    <https://github.com/Cyan4973/xxHash>`_.
- area: upstream
  change: |
    when using active health checking and STRICT_DNS with several addresses that resolve to the same hosts, Envoy will now
    health check each host independently.

deprecated:
- area: filters
  change: |
    Order of execution of the network write filter chain has been reversed. Prior to this release cycle it was incorrect,
    see `#4599 <https://github.com/envoyproxy/envoy/issues/4599>`_. In the 1.9.0 release cycle we introduced
    ``bugfix_reverse_write_filter_order`` in `lds.proto
    <https://github.com/envoyproxy/envoy/blob/main/api/envoy/api/v2/lds.proto>`_ to temporarily support both old and new
    behaviors. Note this boolean field is deprecated.
- area: filters
  change: |
    Order of execution of the HTTP encoder filter chain has been reversed. Prior to this release cycle it was incorrect, see
    `#4599 <https://github.com/envoyproxy/envoy/issues/4599>`_. In the 1.9.0 release cycle we introduced
    ``bugfix_reverse_encode_order`` in `http_connection_manager.proto
    <https://github.com/envoyproxy/envoy/blob/main/api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto>`_
    to temporarily support both old and new behaviors. Note this boolean field is deprecated.
- area: api
  change: |
    Use of the v1 ``REST_LEGACY`` ``ApiConfigSource`` is deprecated.
- area: load_balancing
  change: |
    Use of std::hash in the ring hash load balancer is deprecated.
- area: rate_limiting
  change: |
    Use of ``rate_limit_service`` configuration in the `bootstrap configuration
    <https://github.com/envoyproxy/envoy/blob/main/api/envoy/config/bootstrap/v2/bootstrap.proto>`_ is deprecated.
- area: routing
  change: |
    Use of ``runtime_key`` in ``RequestMirrorPolicy``, found in `route.proto
    <https://github.com/envoyproxy/envoy/blob/main/api/envoy/api/v2/route/route.proto>`_ is deprecated. Set the
    ``runtime_fraction`` field instead.
- area: hcm
  change: |
    Use of buffer filter ``max_request_time`` is deprecated in favor of the request timeout found in `HttpConnectionManager
    <https://github.com/envoyproxy/envoy/blob/main/api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto>`_.
date: December 4, 2017

changes:
- area: access log
  change: |
    added fields for :ref:`UPSTREAM_LOCAL_ADDRESS and DOWNSTREAM_ADDRESS <config_access_log_format>`.
- area: admin
  change: |
    added :ref:`JSON output <operations_admin_interface_stats>` for stats admin endpoint.
- area: admin
  change: |
    added basic :ref:`Prometheus output <operations_admin_interface_stats>` for stats admin endpoint. Histograms are not
    currently output.
- area: admin
  change: |
    added ``version_info`` to the :ref:`/clusters admin endpoint <operations_admin_interface_clusters>`.
- area: config
  change: |
    the :ref:`v2 API <config_overview_v2>` is now considered production ready.
- area: config
  change: |
    added --v2-config-only CLI flag.
- area: cors
  change: |
    added :ref:`CORS filter <config_http_filters_cors>`.
- area: health check
  change: |
    added :ref:`x-envoy-immediate-health-check-fail <config_http_filters_router_x-envoy-immediate-health-check-fail>` header
    support.
- area: health check
  change: |
    added :ref:`reuse_connection <envoy_api_field_HealthCheck.reuse_connection>` option.
- area: http
  change: |
    added :ref:`per-listener stats <config_http_conn_man_stats_per_listener>`.
- area: http
  change: |
    end-to-end HTTP flow control is now complete across both connections, streams, and filters.
- area: load balancer
  change: |
    added :ref:`subset load balancer <arch_overview_load_balancer_subsets>`.
- area: load balancer
  change: |
    added ring size and hash :ref:`configuration options <envoy_api_msg_Cluster.RingHashLbConfig>`. This used to be
    configurable via runtime. The runtime configuration was deleted without deprecation as we are fairly certain no one is
    using it.
- area: log
  change: |
    added the ability to optionally log to a file instead of stderr via the :option:`--log-path` option.
- area: listeners
  change: |
    added :ref:`drain_type <envoy_api_field_Listener.drain_type>` option.
- area: lua
  change: |
    added experimental :ref:`Lua filter <config_http_filters_lua>`.
- area: mongo filter
  change: |
    added :ref:`fault injection <config_network_filters_mongo_proxy_fault_injection>`.
- area: mongo filter
  change: |
    added :ref:`"drain close" <arch_overview_draining>` support.
- area: outlier detection
  change: |
    added :ref:`HTTP gateway failure type <arch_overview_outlier_detection>`. See `deprecated log
    <https://github.com/envoyproxy/envoy/blob/v1.5.0/DEPRECATED.md>`_ for outlier detection stats deprecations in this
    release.
- area: redis
  change: |
    the :ref:`redis proxy filter <config_network_filters_redis_proxy>` is now considered production ready.
- area: redis
  change: |
    added :ref:`"drain close" <arch_overview_draining>` functionality.
- area: router
  change: |
    added :ref:`x-envoy-overloaded <config_http_filters_router_x-envoy-overloaded>` support.
- area: router
  change: |
    added :ref:`regex <envoy_api_field_RouteMatch.regex>` route matching.
- area: router
  change: |
    added :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>` for upstream requests.
- area: router
  change: |
    added :ref:`downstream IP hashing <envoy_api_field_RouteAction.HashPolicy.connection_properties>` for HTTP ketama
    routing.
- area: router
  change: |
    added :ref:`cookie hashing <envoy_api_msg_RouteAction.HashPolicy.Cookie>`.
- area: router
  change: |
    added :ref:`start_child_span <envoy_api_field_filter.http.Router.start_child_span>` option to create child span for
    egress calls.
- area: router
  change: |
    added optional :ref:`upstream logs <envoy_api_field_filter.http.Router.upstream_log>`.
- area: router
  change: |
    added complete :ref:`custom append/override/remove support <config_http_conn_man_headers_custom_request_headers>` of
    request/response headers.
- area: router
  change: |
    added support to :ref:`specify response code during redirect <envoy_api_field_RedirectAction.response_code>`.
- area: router
  change: |
    added :ref:`configuration <envoy_api_field_RouteAction.cluster_not_found_response_code>` to return either a 404 or 503
    if the upstream cluster does not exist.
- area: runtime
  change: |
    added :ref:`comment capability <config_runtime_comments>`.
- area: server
  change: |
    change default log level (:option:`-l`) to ``info``.
- area: stats
  change: |
    maximum stat/name sizes and maximum number of stats are now variable via the ``--max-obj-name-len`` and ``--max-stats``
    options.
- area: tcp proxy
  change: |
    added :ref:`access logging <envoy_api_field_filter.network.TcpProxy.access_log>`.
- area: tcp proxy
  change: |
    added :ref:`configurable connect retries <envoy_api_field_filter.network.TcpProxy.max_connect_attempts>`.
- area: tcp proxy
  change: |
    enable use of :ref:`outlier detector <arch_overview_outlier_detection>`.
- area: tls
  change: |
    added :ref:`SNI support <faq_how_to_setup_sni>`.
- area: tls
  change: |
    added support for specifying :ref:`TLS session ticket keys <envoy_api_field_DownstreamTlsContext.session_ticket_keys>`.
- area: tls
  change: |
    allow configuration of the :ref:`min <envoy_api_field_TlsParameters.tls_minimum_protocol_version>` and :ref:`max
    <envoy_api_field_TlsParameters.tls_minimum_protocol_version>` TLS protocol versions.
- area: tracing
  change: |
    added :ref:`custom trace span decorators <envoy_api_field_Route.decorator>`.
- area: envoy
  change: |
    Many small bug fixes and performance improvements not listed.

deprecated:
- area: outlier_detection
  change: |
    The outlier detection ``ejections_total`` stats counter has been deprecated and not replaced. Monitor the individual
    ``ejections_detected_*`` counters for the detectors of interest, or ``ejections_enforced_total`` for the total number of
    ejections that actually occurred.
- area: outlier_detection
  change: |
    The outlier detection ``ejections_consecutive_5xx`` stats counter has been deprecated in favour of
    ``ejections_detected_consecutive_5xx`` and ``ejections_enforced_consecutive_5xx``.
- area: outlier_detection
  change: |
    The outlier detection ``ejections_success_rate`` stats counter has been deprecated in favour of
    ``ejections_detected_success_rate`` and ``ejections_enforced_success_rate``.
date: January 15, 2021

changes:
- area: http
  change: |
    fixed URL parsing for HTTP/1.1 fully qualified URLs and connect requests containing IPv6 addresses.
- area: tls
  change: |
    fix detection of the upstream connection close event.
date: August 3, 2018

changes:
- area: upstream
  change: |
    require opt-in to use the :ref:`x-envoy-orignal-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>`
    header for overriding destination address when using the :ref:`Original Destination
    <arch_overview_load_balancing_types_original_destination>` load balancing policy.
date: April 5, 2023

behavior_changes:
- area: http
  change: |
    Validate upstream request header names and values. The new runtime flag
    ``envoy.reloadable_features.validate_upstream_headers`` can be used for revert this behavior.

bug_fixes:
- area: oauth2
  change: |
    fixed a bug where the oauth2 filter would crash if it received a redirect URL without a state query param set.
- area: lua
  change: |
    lua coroutine should not execute after local reply is sent.
- area: grpc
  change: |
    when Envoy was configured to use ext_authz, ext_proc, tap, ratelimit filters, and grpc access log service and an http
    header with non-UTF-8 data was received, Envoy would generate an invalid protobuf message and send it to the configured
    service. The receiving service would typically generate an error when decoding the protobuf message. For ext_authz that
    was configured with ``failure_mode_allow: true``, the request would have been allowed in this case. For the other services,
    this could have resulted in other unforseen errors such as a lack of visibility into requests (eg request not logged). Envoy
    will now by default sanitize the values sent in gRPC service calls to be valid UTF-8, replacing data that is not valid UTF-8
    with a '!' character. This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.service_sanitize_non_utf8_strings`` to false.
- area: http
  change: |
    stop forwarding ``:method`` value which is not a valid token defined in https://www.rfc-editor.org/rfc/rfc9110#section-5.6.2.
    Also, reject ``:method`` and ``:scheme`` headers with multiple values.
- area: http3
  change: |
    reject pseudo headers violating RFC 9114. Specifically, pseudo-header fields with more than one value for the ``:method``
    (non-``CONNECT``), ``:scheme``, and ``:path``; or pseudo-header fields after regular header fields; or undefined
    pseudo-headers.
- area: http
  change: |
    fixed a bug where ``x-envoy-original-path`` was not being sanitized when sent from untrusted users. This behavioral change
    can be temporarily reverted by setting ``envoy.reloadable_features.sanitize_original_path`` to false.
date: December 7, 2020

changes:
- area: listener
  change: |
    fix crash when disabling or re-enabling listeners due to overload while processing LDS updates.
- area: tls
  change: |
    fix read resumption after triggering buffer high-watermark and all remaining request/response bytes are stored in the
    SSL connection's internal buffers.
- area: udp
  change: |
    fixed issue in which receiving truncated UDP datagrams would cause Envoy to crash.
date: October 18, 2023

behavior_changes:
- area: jwt
  change: |
    Changed behavior of the JWT extraction, passing entire token for validation, instead cut him in the non-Base64 character.
    This change can be reverted temporarily by setting the runtime guard ``envoy.reloadable_features.token_passed_entirely`` to ``false``.
- area: eds
  change: |
    Introduced caching of EDS assignments when used with ADS. Prior to this change, Envoy required that EDS assignments were sent
    after an EDS cluster was updated. If no EDS assignment was received for the cluster, it ended up with an empty assignment.
    Following this change, after a cluster update, Envoy waits for an EDS assignment until
    :ref:`initial_fetch_timeout <envoy_v3_api_field_config.core.v3.ConfigSource.initial_fetch_timeout>` times out, and will then apply
    the cached assignment and finish updating the warmed cluster. This change is disabled by default, and can be enabled by setting
    the runtime flag ``envoy.restart_features.use_eds_cache_for_ads`` to ``true``.
- area: http
  change: |
    Introduced a new runtime flag ``envoy.reloadable_features.no_downgrade_to_canonical_name`` to disable the name downgrading in the
    per filter config searching.
    See doc :ref:`Http filter route specific config <arch_overview_http_filters_per_filter_config>` or
    issue https://github.com/envoyproxy/envoy/issues/29461 for more specific detail and examples.
- area: http
  change: |
    Switch from http_parser to BalsaParser for handling HTTP/1.1 traffic. See https://github.com/envoyproxy/envoy/issues/21245 for
    details. This behavioral change can be reverted by setting runtime flag ``envoy.reloadable_features.http1_use_balsa_parser`` to
    ``false``.
- area: udp_proxy
  change: |
    When the UDP proxy has session filters, choosing the upstream host and creating a socket only happens after iterating all
    ``onNewSession()`` calls for all the filters in the chain. Upstream host health check for each downstream datagram does
    not apply when there are session filters, and per-packet load balancing can't be used when there are session filters.
- area: zone-aware routing
  change: |
    Zone-aware routing is now enabled even when the originating and upstream cluster have different numbers of zones.
    Previously, zone-aware routing was disabled in that case and the ``lb_zone_number_differs`` stat on the cluster was incremented.
    This behavioral change can be reverted by setting runtime guard
    ``envoy.reloadable_features.enable_zone_routing_different_zone_counts`` to ``false``.
    Additionally, zone-aware routing now works correctly even when the originating and upstream cluster have different zone sets.
    Previously, zone-aware routing would not route fairly in this case.
    To revert the entire change, set the runtime flag ``envoy.reloadable_features.locality_routing_use_new_routing_logic``
    to ``false`` to get the old behavior and well-tested codepaths, undoing both changes.
- area: UHV
  change: |
    Introduced runtime flag ``envoy.reloadable_features.enable_universal_header_validator`` for toggling Universal Header Validator
    (UHV) on and off.
    The default value is off. This option is currently functional only when the ``ENVOY_ENABLE_UHV`` build flag is enabled.
    See https://github.com/envoyproxy/envoy/issues/10646 for more information about UHV.
- area: http
  change: |
    Add runtime flag ``http.max_requests_per_io_cycle`` for setting the limit on the number of HTTP requests processed
    from a single connection in a single I/O cycle. Requests over this limit are processed in subsequent I/O cycles. This
    mitigates CPU starvation by connections that simultaneously send high number of requests by allowing requests from other
    connections to make progress. This runtime value can be set to 1 in the presence of abusive HTTP/2 or HTTP/3 connections.
    By default this limit is disabled.

minor_behavior_changes:
- area: ext_authz
  change: |
    Removing any query parameter in the presence of repeated query parameter keys no longer drops the repeats.
- area: alternate_protocols_cache_filter
  change: |
    Changed the alternate protocols cache filter to get the cache from cluster config rather than filter config.
    This allows one downstream HTTP filter to be used with multiple clusters with different caches. This change can be
    reverted by setting runtime guard ``envoy.reloadable_features.use_cluster_cache_for_alt_protocols_filter`` to ``false``.
- area: ext_authz
  change: |
    Don't append the local address to ``x-forwarded-for`` header when sending an http (not gRPC) auth request.
    This behavior can be reverted by setting runtime flag
    ``envoy.reloadable_features.ext_authz_http_send_original_xff`` to ``false``.
- area: ext_proc
  change: |
    Envoy will only take
    :ref:`mode_override <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.mode_override>`
    when waiting for the header responses. It will be ignored if it is in other processing states.
- area: outlier detection
  change: |
    Outlier detection will always respect ``max_ejection_percent`` now.
    This behavioral change can be reverted by setting runtime guard
    ``envoy.reloadable_features.check_mep_on_first_eject`` to ``false``.
- area: outlier detection
  change: |
    A node must stay in healthy state for at least one period of
    :ref:`check interval <envoy_v3_api_field_config.cluster.v3.OutlierDetection.interval>` before ejection time multiplier is decremented.
- area: quic
  change: |
    Enable QUICHE request and response headers validation. This behavior can be reverted by setting runtime flag
    ``envoy.reloadable_features.FLAGS_envoy_quic_reloadable_flag_quic_act_upon_invalid_header`` to ``false``.
- area: http oauth2 filter
  change: |
    Change HMAC cookie encoding to base64-encoded only. This change can be reverted temporarily by
    setting the runtime guard ``envoy.reloadable_features.hmac_base64_encoding_only`` to ``false``.
- area: router
  change: |
    Enable copying response_code from the upstream stream_info onto the downstream stream_info.
    This behavior can be reverted by setting runtime guard
    ``envoy.reloadable_features.copy_response_code_to_downstream_stream_info`` to ``false``.
- area: xds
  change: |
    Set the lower bound of :ref:`fill_rate <envoy_v3_api_field_config.core.v3.RateLimitSettings.fill_rate>`
    to once per year. Values lower than once per year will automatically be set to that value.
- area: redis
  change: |
    The redis network filter :ref:`connection_rate_limit_per_sec
    <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.ConnectionRateLimit.connection_rate_limit_per_sec>`
    must be greater than 0. A config that sets this value to 0 will be rejected.
- area: upstream
  change: |
    Deprecate code path of legacy upstream load balancer. Ideally, this is implementation detail changes and should not
    affect users. However, if there is any user who encounters issues, this behavior can be reverted by setting runtime flag
    ``envoy_reloadable_features_convert_legacy_lb_config`` to false.
- area: http
  change: |
    Change the proxy status for ``UpstreamRequestTimeout`` to ``HttpResponseTimeout``.
    It can be disabled by the runtime guard ``envoy.reloadable_features.proxy_status_upstream_request_timeout``.
- area: local_rate_limit
  change: |
    Added new configuration field :ref:`always_consume_default_token_bucket
    <envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.always_consume_default_token_bucket>`
    to allow for setting if default token bucket should be always consumed or only be consumed when there is no matching descriptor.
- area: tls
  change: |
    changed ssl failure reason format in ssl socket for a better handling.
    It can be disabled by the runtime guard ``envoy.reloadable_features.ssl_transport_failure_reason_format``.
- area: tls_inspector
  change: |
    Updated the security posture of the :ref:`TLS inspector listener filter <config_listener_filters_tls_inspector>` to
    robust against untrusted downstreams and upstreams.
- area: router
  change: |
    Enable environment_variable in router direct response.
- area: access_log
  change: |
    When emitting grpc logs, only downstream HTTP filter state was used. Now, both downstream and upstream HTTP filter states
    will be tried to find the keys configured in filter_state_objects_to_log.
- area: http
  change: |
    Abort the HTTP filter chain iteration when the stream is reset by ``resetStream()`` of filter callbacks.
    This behavior can be reverted by setting
    runtime flag ``envoy.reloadable_features.abort_filter_chain_on_stream_reset`` to ``false``.

bug_fixes:
- area: connection limit
  change: |
    Fixed a use-after-free bug in the connection limit filter.
- area: subset load balancer
  change: |
    Fixed a bug where
    :ref:`overprovisioning_factor<envoy_v3_api_field_config.endpoint.v3.ClusterLoadAssignment.Policy.overprovisioning_factor>` and
    :ref:`weighted_priority_health <envoy_v3_api_field_config.endpoint.v3.ClusterLoadAssignment.Policy.weighted_priority_health>`
    values were not respected when subset load balacing was enabled. The default values of ``140`` and ``false`` were always used.
- area: http1
  change: |
    Fixed a bug where HTTP/1.1 requests with ``Connection: close`` header is handled differently if the requested is internally redirected.
    Without internal redirect, the response will also have a ``Connection: close`` header and the connection will be closed after finishing
    that request. Requests with internal redirect should be handled in the same way. This behavior can be reverted by setting runtime
    ``envoy.reloadable_features.http1_connection_close_header_in_redirect`` to ``false``.
- area: redis
  change: |
    Fixed a bug where redis key formatter is using the closed stream because of life time issues.
- area: extension_discovery_service
  change: |
    Fixed a bug causing crash if ECDS is used with upstream HTTP filters.
- area: tls
  change: |
    Fixed a bug where handshake may fail when both private key provider and cert validation are set.
- area: dns
  change: |
    Fixed a bug where when ``respect_dns_ttl`` was set to ``true``, c-ares dns resolver only considered address record for TTL calculation
    while ignoring CNAME records TTL. Now when ``respect_dns_ttl`` is set to ``true`` minimum of all TTL records is considered.
- area: dns
  change: |
    Fixed a bug where dns response was not always conforming `RFC 2181 <https://datatracker.ietf.org/doc/html/rfc2181>`_ for TTL values.
    Previously a malicious user could add a TTL greater than 2^31 - 1, and with c-ares library using 32 bit signed int data type
    would overflow and send a negative TTL.
- area: healthcheck
  change: |
    The default behavior of unejecting outlier-detection-ejected host on successful active health checking can
    be disabled by setting :ref:`outlier_detection.successful_active_health_check_uneject_host
    <envoy_v3_api_field_config.cluster.v3.OutlierDetection.successful_active_health_check_uneject_host>`
    to ``false``. This new configuration flag is a substitute for the removed runtime option
    ``envoy.reloadable_features_successful_active_health_check_uneject_host``.
- area: aws signer
  change: |
    Fixed a bug where expiration timestamp on task roles failed to validate. This causes failure of credential caching which
    results in constant hits to the task role metadata URL.
- area: router check tool
  change: |
    Fixed a bug where the route coverage is not correctly calculated when a route has weighted clusters.
- area: unix domain sockets
  change: |
    Fixed a crash on some versions of macOS when using a listener on a unix-domain socket.
- area: redis
  change: |
    Fixed a bug where redis key with % in the key is failing with a validation error.
- area: tracing
  change: |
    Fixed a bug in the Datadog tracer where Datadog's "operation name" field would contain what should be in the "resource name" field.
- area: http
  change: |
    Close HTTP/2 and HTTP/3 connections that prematurely reset streams. The runtime key
    ``overload.premature_reset_min_stream_lifetime_seconds`` determines the interval where received stream
    reset is considered premature (with 1 second default). The runtime key ``overload.premature_reset_total_stream_count``,
    with the default value of 500, determines the number of requests received from a connection before the check for premature
    resets is applied. The connection is disconnected if more than 50% of resets are premature, or if
    the number of suspect streams is already large enough to guarantee that more than 50% of the streams will be suspect
    upon reaching the total stream threshold (even if all the remaining streams are considered benign).
    Setting the runtime key ``envoy.restart_features.send_goaway_for_premature_rst_streams`` to ``false`` completely disables
    this check.
- area: http
  change: |
    Fixed a bug that could cause metadata to be decoded after a local reply has been triggered.
    Can be disabled by setting ``envoy.reloadable_features.stop_decode_metadata_on_local_reply`` to false.
- area: docker/publishing
  change: |
    Update base images to resolve various glibc vulnerabilities.
- area: xds
  change: |
    Fix a bug where the nonce was not reset after reconnecting to the xDS server, when using State-of-the-World.

removed_config_or_runtime:
- area: listener
  change: |
    Removed ``envoy.reloadable_features.enable_update_listener_socket_options`` runtime flag and legacy code paths.
- area: tcp
  change: |
    Removed runtime key ``envoy.reloadable_features.tcp_pool_idle_timeout``.
- area: http filters
  change: |
    Removed ``envoy_reloadable_features_http_filter_avoid_reentrant_local_reply`` runtime flag and legacy code paths.
- area: tcp_proxy
  change: |
    Removed ``envoy_reloadable_features_finish_reading_on_decode_trailers`` runtime flag and legacy code paths.
- area: dns
  change: |
    Removed ``envoy.restart_features.use_apple_api_for_dns_lookups`` and legacy code paths.
- area: runtime
  change: |
    Removed ``envoy.restart_features.remove_runtime_singleton`` and legacy code paths.
- area: runtime
  change: |
    Removed ``envoy_reloadable_features_append_query_parameters_path_rewriter`` and legacy code paths.
- area: xDS
  change: |
    Removed ``envoy.restart_features.explicit_wildcard_resource`` and legacy code paths.
- area: quic
  change: |
    Removed ``envoy.reloadable_features.reject_require_client_certificate_with_quic`` and legacy code paths.
- area: healthcheck
  change: |
    Removed ``envoy.reloadable_features_successful_active_health_check_uneject_host`` runtime option and
    substituted it with :ref:`outlier_detection.successful_active_health_check_uneject_host
    <envoy_v3_api_field_config.cluster.v3.OutlierDetection.successful_active_health_check_uneject_host>`
    outlier detection configuration flag.
- area: ext_authz
  change: |
    Removed ``envoy.reloadable_features.http_ext_auth_failure_mode_allow_header_add``
    runtime option and substituted it with :ref:`failure_mode_allow_header_add
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.failure_mode_allow_header_add>`
    configuration flag.

new_features:
- area: access_log
  change: |
    Added ``%RESPONSE_FLAGS_LONG%`` substitution string, that will output a pascal case string representing the response flags.
    The output response flags will correspond with ``%RESPONSE_FLAGS%``, only with a long textual string representation.
- area: compression
  change: |
    Added :ref:`remove_accept_encoding_header
    <envoy_v3_api_field_extensions.filters.http.compressor.v3.ResponseDirectionOverrides.remove_accept_encoding_header>`
    for per-route configuration of this value.
- area: config
  change: |
    Added the capability to defer broadcasting of certain cluster (CDS, EDS) to
    worker threads from the main thread. This optimization can save significant
    amount of memory in cases where there are (1) a large number of workers and
    (2) a large amount of config, most of which is unused. This capability is
    guarded by :ref:`enable_deferred_cluster_creation
    <envoy_v3_api_field_config.bootstrap.v3.ClusterManager.enable_deferred_cluster_creation>`.
- area: extension_discovery_service
  change: |
    Added ECDS support for :ref:`downstream network filters <envoy_v3_api_field_config.listener.v3.Filter.config_discovery>`.
- area: ext_proc
  change: |
    Added
    :ref:`disable_immediate_response <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.disable_immediate_response>`
    config API to ignore the
    :ref:`immediate_response <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.immediate_response>`
    message from the external processing server.
- area: access_log
  change: |
    Added a field lookup to ``%FILTER_STATE%`` for objects that have reflection enabled.
- area: http
  change: |
    Added :ref:`Json-To-Metadata filter <envoy_v3_api_msg_extensions.filters.http.json_to_metadata.v3.JsonToMetadata>`.
- area: listener
  change: |
    Added possibility to track global downstream connection limit via :ref:`downstream connections monitor
    <envoy_v3_api_msg_extensions.resource_monitors.downstream_connections.v3.DownstreamConnectionsConfig>` in overload manager.
- area: extension_discovery_service
  change: |
    Added metric ``listener.listener_stat.network_extension_config_missing`` to track closed connections due to missing config.
- area: lua
  change: |
    Added :ref:`downstreamRemoteAddress() <config_http_filters_lua_stream_info_downstream_remote_address>`
    method to the Stream info object API.
- area: quic
  change: |
    Added support for QUIC listener filters with ECDS support reusing the same config API
    :ref:`listener_filters <envoy_v3_api_field_config.listener.v3.Listener.listener_filters>` as TCP does.
- area: oauth2
  change: |
    Added :ref:`use_refresh_token <envoy_v3_api_field_extensions.filters.http.oauth2.v3.OAuth2Config.use_refresh_token>`
    to support updating an access token via a refresh token if that is provided by authorization server.
- area: redis
  change: |
    Added support for ``time`` command (returns a local response).
- area: extension_discovery_service
  change: |
    Added ECDS support for :ref:`upstream network filters <envoy_v3_api_field_config.cluster.v3.Filter.config_discovery>`.
- area: redis
  change: |
    Added support for ``lmove`` command.
- area: upstream
  change: |
    Added :ref:`allow_redundant_keys <envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.Subset.allow_redundant_keys>`
    to suppport redundant keys in request metadata for subset load balancing.
- area: access_logs
  change: |
    Added :ref:`json_format_options <envoy_v3_api_field_config.core.v3.SubstitutionFormatString.json_format_options>` config option to
    support JSON output formatting and the :ref:`sort_properties <envoy_v3_api_field_config.core.v3.JsonFormatOptions.sort_properties>`
    option to print the JSON output with sorted properties.
- area: tap
  change: |
    Added :ref:`custom_sink <envoy_v3_api_field_config.tap.v3.OutputSink.custom_sink>` type to enable writing tap data
    out to a custom sink extension.
- area: tls
  change: |
    Added :ref:`disable_stateful_session_resumption
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.disable_stateful_session_resumption>` config option to
    disable stateful TLS session resumption.
- area: udp_proxy
  change: |
    Added :ref:`session_filters <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.session_filters>` config to
    support optional filters that will run for each upstream UDP session. More information can be found in the UDP proxy documentation.
- area: udp_proxy
  change: |
    Added ``injectDatagramToFilterChain()`` callback to UDP session filters that allows session filters to inject datagrams downstream
    or upstream the filter chain during a filter chain iteration. This can be used, for example, by session filters that are required
    to buffer datagrams due to an asynchronous call.
- area: otlp_stats_sink
  change: |
    Added :ref:`stats prefix option <envoy_v3_api_field_extensions.stat_sinks.open_telemetry.v3.SinkConfig.prefix>`
    to OTLP stats sink that enables adding a static prefix to all stats flushed by this sink.
- area: udp_proxy
  change: |
    Added :ref:`http_capsule <envoy_v3_api_msg_extensions.filters.udp.udp_proxy.session.http_capsule.v3.FilterConfig>` UDP session filter
    that can be used to encapsule or decapsulate UDP datagrams in HTTP, when used for UDP tunneling.
- area: tap
  change: |
    Added :ref:`record_headers_received_time <envoy_v3_api_field_extensions.filters.http.tap.v3.Tap.record_headers_received_time>`
    to control writing request and response headers received time in trace output.
- area: udp_proxy
  change: |
    added :ref:`dynamic_forward_proxy <envoy_v3_api_msg_extensions.filters.udp.udp_proxy.session.dynamic_forward_proxy.v3.FilterConfig>`
    UDP session filter that can be used to have dynamic forward proxy UDP flows, when used in conjunction with another session filter
    that sets required filter state values.
- area: zookeeper
  change: |
    Added support for emitting per opcode request bytes metrics via :ref:`enable_per_opcode_request_bytes_metrics
    <envoy_v3_api_field_extensions.filters.network.zookeeper_proxy.v3.ZooKeeperProxy.enable_per_opcode_request_bytes_metrics>`.
    added support for emitting per opcode response bytes metrics via :ref:`enable_per_opcode_response_bytes_metrics
    <envoy_v3_api_field_extensions.filters.network.zookeeper_proxy.v3.ZooKeeperProxy.enable_per_opcode_response_bytes_metrics>`.
- area: tls
  change: |
    Added fallback :ref:`fallback
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.PrivateKeyProvider.fallback>`
    to support private key provider to fallback to boringssl TLS handshake.
    If the private key provider isn't available (eg. the required hardware capability doesn't existed),
    Envoy will fallback to the BoringSSL default implementation when the fallback is ``true``.
    The default value is ``false``.
- area: tcp
  change: |
    Added the support to detect and send TCP RST for raw buffer socket based connections. This is currently supported on Linux only.
    It can be disabled by the runtime guard ``envoy_reloadable_features_detect_and_raise_rst_tcp_connection``.
- area: upstream
  change: |
    Added the ability to specify a custom upstream local address selector using
    :ref:`local_address_selector <envoy_v3_api_field_config.core.v3.BindConfig.local_address_selector>`.
- area: redis
  change: |
    Added new configuration field :ref:`read_command_policy
    <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.read_command_policy>`
    to specify Envoy should route read commands to another cluster.
- area: tap
  change: |
    Added :ref:`record_downstream_connection <envoy_v3_api_field_extensions.filters.http.tap.v3.Tap.record_downstream_connection>`
    to control writing downstream connection address info in trace output.
- area: tracing
  change: |
    Added :ref:`spawn_upstream_span
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.spawn_upstream_span>`
    to control whether to create separate upstream span for upstream request.
- area: original_dst
  change: |
    added support for the internal listener address recovery using the original destination listener filter.
- area: filters
  change: |
    Added filters to update the filter state for :ref:`the HTTP requests <config_http_filters_set_filter_state>` and
    :ref:`the TCP connections <config_network_filters_set_filter_state>`.
- area: http
  change: |
    Added :ref:`disabled
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.disabled>`
    flag to disable a filter in the filter chain by default. The filter can be enabled explicitly by setting
    valid per filter config in the route configuration.
- area: admin_logging
  change: |
    added support for glob control of fine-grain loggers in admin /logging interface.
- area: geoip
  change: |
    Added support for :ref:`Maxmind geolocation provider <envoy_v3_api_msg_extensions.geoip_providers.maxmind.v3.MaxMindConfig>`.
- area: admin
  change: |
    Added a new ``skip_exit`` query parameter to ``/drain_listeners`` to skip exiting after the drain period.
- area: router
  change: |
    Added ``metadata`` support for :ref:`virtual host <envoy_v3_api_field_config.route.v3.VirtualHost.metadata>` and
    :ref:`route configuration <envoy_v3_api_field_config.route.v3.RouteConfiguration.metadata>`.
- area: tracing
  change: |
    Added support for exporting spans via HTTP on the OpenTelemetry tracer.

deprecated:
- area: tracing
  change: |
    OpenTracing is deprecated and will be removed at version 1.30, since the upstream project has been abandoned.
- area: tracing
  change: |
    Opencensus is deprecated and will be removed at version 1.30, since the upstream project has been abandoned.
- area: tracing
  change: |
    :ref:`start_child_span <envoy_v3_api_field_extensions.filters.http.router.v3.Router.start_child_span>`
    is deprecated by
    :ref:`spawn_upstream_span
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.spawn_upstream_span>`.
    Please use the new field to control whether to create separate upstream span for upstream request.
- area: listener
  change: |
    deprecated runtime key ``overload.global_downstream_max_connections`` in favor of :ref:`downstream connections monitor
    <envoy_v3_api_msg_extensions.resource_monitors.downstream_connections.v3.DownstreamConnectionsConfig>`.
date: June 9, 2022

bug_fixes:
- area: decompression
  change: |
    fixed CVE-2022-29225 due to which decompressors can be zip bombed. Previously decompressors were susceptible to memory
    inflation in takes in which specially crafted payloads could cause a large amount of memory usage by Envoy. The max
    inflation payload size is now limited.  This change can be reverted via the
    ``envoy.reloadable_features.enable_compression_bomb_protection`` runtime flag.
- area: health_check
  change: |
    fixed CVE-2022-29224 which caused a segfault in GrpcHealthCheckerImpl. An attacker-controlled upstream server that is
    health checked using gRPC health checking can crash Envoy via a null pointer dereference in certain circumstances.
- area: oauth
  change: |
    fixed CVE-2022-29226 due to which oauth filter allows trivial bypass. The OAuth filter implementation does not include a
    mechanism for validating access tokens, so by design when the HMAC signed cookie is missing a full authentication flow
    should be triggered. However, the current implementation assumes that access tokens are always validated thus allowing
    access in the presence of any access token attached to the request.
- area: oauth
  change: |
    fixed CVE-2022-29228 due to which oauth filter calls continueDecoding() from within decodeHeaders(). The OAuth filter
    would try to invoke the remaining filters in the chain after emitting a local response, which triggers an ASSERT() in
    newer versions and corrupts memory on earlier versions.
- area: router
  change: |
    fixed CVE-2022-29227 which caused an internal redirect crash for requests with body/trailers. Envoy would previously
    crash in some cases when processing internal redirects for requests with bodies or trailers if the redirect prompts an
    Envoy-generated local reply.
date: February 22, 2022

bug_fixes:
- area: data plane
  change: |
    fix crash when internal redirect selects a route configured with direct response or redirect actions.
- area: jwt_authn
  change: |
    fixed the crash when a CONNECT request is sent to JWT filter configured with regex match on the Host header.
- area: tcp_proxy
  change: |
    fix a crash that occurs when configured for :ref:`upstream tunneling
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.tunneling_config>` and the downstream connection
    disconnects while the the upstream connection or http/2 stream is still being established.
date: October 19, 2022

behavior_changes:
- area: build
  change: |
    official released binary is now built on Ubuntu 20.04, requires glibc >= 2.30.
- area: stats http local_rate_limit
  change: |
    Fixed metric tag extraction so that :ref:`stat_prefix
    <envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.stat_prefix>` is properly extracted. This
    changes the Prometheus name from envoy_http_local_rate_limit_myprefix_rate_limited{} to
    envoy_http_local_rate_limit_rate_limited{envoy_local_http_ratelimit_prefix="myprefix"}.
- area: stats network local_rate_limit
  change: |
    Fixed metric tag extraction so that :ref:`stat_prefix
    <envoy_v3_api_field_extensions.filters.network.local_ratelimit.v3.LocalRateLimit.stat_prefix>` is properly extracted.
    This changes the Prometheus name from envoy_local_rate_limit_myprefix_rate_limited{} to
    envoy_local_rate_limit_rate_limited{envoy_local_ratelimit_prefix="myprefix"}.
- area: http
  change: |
    Envoy no longer adds ``content-length: 0`` header when proxying UPGRADE requests without ``content-length`` and
    ``transfer-encoding`` headers. This behavior change can be reverted by setting the
    ``envoy.reloadable_features.http_skip_adding_content_length_to_upgrade`` runtime flag to false.
- area: tls
  change: |
    Change TLS and QUIC transport sockets to support asynchronous cert validation extension. This behavior change can be
    reverted by setting runtime guard ``envoy.reloadable_features.tls_async_cert_validation`` to false.
- area: gcp_authn
  change: |
    Add GCP Authentication filter which can be used to fetch authentication tokens from Google Compute Engine(GCE) metadata
    server.
- area: http
  change: |
    For HTTP/2 and HTTP/3 codecs, all clients now continue sending data upstream after receiving an end of the server
    stream. This supports the server half-close semantics for TCP tunneling with CONNECT as well as bi-directional streaming
    calls. This behavior change can be reverted by setting the ``envoy.reloadable_features.http_response_half_close``
    runtime flag to false.
- area: original_dst
  change: |
    ORIGINAL_DST cluster will not attempt to remove and drain the stale hosts during cleanup if they are still used by the
    connection pools. For HTTP pools, please set :ref:`idle_timeout <faq_configuration_connection_timeouts>` to limit the
    duration of the upstream connections (the default value is 1h, and the recommended value is 5min). This behavior change
    can be reverted by setting runtime guard ``envoy.reloadable_features.original_dst_rely_on_idle_timeout``.
- area: config
  change: |
    Fixed resource tracking when using the Incremental (Delta-xDS) protocol. The protocol state will be updated after the
    resources are successfully ingested and an ACK is sent. This behavior change can be reverted by setting the
    ``envoy.reloadable_features.delta_xds_subscription_state_tracking_fix`` runtime flag to false.

minor_behavior_changes:
- area: logging
  change: |
    changed the ``UPSTREAM_REMOTE_ADDRESS``, ``UPSTREAM_REMOTE_ADDRESS_WITHOUT_PORT``, and ``UPSTREAM_REMOTE_PORT`` fields
    to log based on the actual upstream connection rather than the upstream host. This fixes a bug where the address
    components were not consistently correct for Happy Eyeballs connections and proxied connections, but also means in cases
    where the host was selected but a connection was not established, the fields will be absent. This change can be
    temporarily reverted by setting the runtime guard ``envoy.reloadable_features.correct_remote_address`` to false.
- area: resource_monitors
  change: |
    changed behavior of the fixed heap monitor to count pages allocated to TCMalloc as free memory if it's not used by
    Envoy. This change can be reverted temporarily by setting the runtime guard
    ``envoy.reloadable_features.do_not_count_mapped_pages_as_free`` to true.
- area: prometheus_stats
  change: |
    removed blank line for being compatible with OpenMetrics.
- area: quic
  change: |
    changed the timing of QUIC connection writing data in response to incoming packets in non-Windowns platforms. This
    change can be reverted by setting runtime guard ``envoy.reloadable_features.quic_defer_send_in_response_to_packet`` to
    false.
- area: original_dst
  change: |
    transparent listener can use original_dst filter without nf_conntrack enabled.
- area: cache_filter
  change: |
    added a completion callback to insertHeaders and insertTrailers in cache interface. Any external cache implementation
    extensions will need to also add this callback, and call it on completion.
- area: udp_proxy
  change: |
    changed behavior of UDP proxy to connect UDP sockets unless ``use_original_src_ip`` is set. This change can be reverted
    by setting runtime guard ``envoy.reloadable_features.udp_proxy_connect`` to false.
- area: local_ratelimit
  change: |
    added :ref:`virtual host level configuration
    <envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.vh_rate_limits>` support for the local
    ratelimit filter.
- area: health_check
  change: |
    support custom health check address via :ref:`health_check_config
    <envoy_v3_api_msg_config.endpoint.v3.endpoint.healthcheckconfig>`.
- area: http
  change: |
    changed shadow requests to more closely behave like the requests they are shadowing. This includes matching the upstream
    logging for the original request, dynamic stats, suppressing Envoy headers, respecting expected request timeout,
    suppressing grpc request failure code stats and strict header checks. This behaviorial change can be temporarily
    reverted by setting runtime guard ``envoy.reloadable_features.closer_shadow_behavior`` to false.
- area: http
  change: |
    changed the filter callback interfaces to make sure that downstream-only functionality is explicit.
- area: http
  change: |
    the upstream remote address is now available to downstream HTTP filters via the ``upstreamRemoteAddress`` function.
- area: stats
  change: |
    Default tag extraction rules were changed for ``worker_id`` extraction. Previously, ``worker_`` was removed from the
    original name during the extraction. This led to the same base stat name for both the per-worker and overall stat. For
    instance, in prometheus stats, the following stats were produced: ::    envoy_listener_downstream_cx_total{} 2.
    envoy_listener_downstream_cx_total{envoy_worker_id="0"} 1.   envoy_listener_downstream_cx_total{envoy_worker_id="1"} 1.
    This resulted in ``sum(envoy_listener_downstream_cx_total)`` producing 4, even though there are only 2 connections. The
    new behavior results in stats such as this: ::    envoy_listener_downstream_cx_total{} 2.
    envoy_listener_worker_downstream_cx_total{envoy_worker_id="0"} 1.
    envoy_listener_worker_downstream_cx_total{envoy_worker_id="1"} 1.
- area: dynamic_forward_proxy
  change: |
    No longer waiting on DNS responses in the dynamic forward proxy filter if upstream proxying is turned on. This
    behaviorial change can be reverted by setting runtime guard
    ``envoy.reloadable_features.skip_dns_lookup_for_proxied_requests`` to false.

bug_fixes:
- area: http
  change: |
    fixed a bug with internal redirects not being performed for drained connections.
- area: jwt_authn
  change: |
    fixed a bug where a negative "exp", "iat", or "nbf" integer in JWT token readed as a large positive value.
- area: grpc_transcoder
  change: |
    fixed a bug where a request with a wrong binding type is not rejected if the request body is empty.
- area: listener
  change: |
    fixed a bug that doesn't handle of an update for a listener with IPv4-mapped address correctly, and that will lead to a
    memory leak.
- area: transport_socket
  change: |
    fixed a bug that prevented the tcp stats to be retrieved when running on kernels different than the kernel where Envoy
    was built.
- area: logger
  change: |
    added the %j and %_ format support for fine-grain loggers to make it consistant with default loggers.
- area: thrift
  change: |
    fixed the routing decision when thrift filters change the value of the cluster header.
- area: router
  change: |
    fixed edge-case interaction between weighted clusters, cluster headers and (request|response)_headers_to_(add|remove).
- area: upstream
  change: |
    fixed a bug where custom transport socket hashes might not be respected by wrapper passthrough sockets. This change can
    be temporarily reverted by setting runtime guard ``envoy.reloadable_features.fix_hash_key`` to false.
- area: tls
  change: |
    fixed a bug where, when runtime guard ``envoy.reloadable_features.tls_async_cert_validation`` is set to false, the wrong
    TLS alerts would sometimes be sent in response to certificate validation failures.

removed_config_or_runtime:
- area: auto_config
  change: |
    removed ``envoy.reloadable_features.correctly_validate_alpn`` and legacy code paths.
- area: grpc
  change: |
    remove ``envoy.reloadable_features.enable_grpc_async_client_cache`` and legacy code paths.
- area: hcm
  change: |
    removed ``envoy.reloadable_features.handle_stream_reset_during_hcm_encoding`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.proxy_120_103`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.http2_allow_capacity_increase_by_settings`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.sanitize_http_header_referer`` and legacy code paths.
- area: lightstep
  change: |
    removed the Lightstep tracer integration, making way for the native OpenTelemetry integration.
- area: listener
  change: |
    removed ``envoy.reloadable_features.internal_address`` and legacy code paths.
- area: router
  change: |
    removed ``envoy.reloadable_features.update_expected_rq_timeout_on_retry`` and legacy code paths.
- area: tracing
  change: |
    removed ``envoy.reloadable_features.update_grpc_response_error_tag`` and legacy code paths.

new_features:
- area: header_formatters
  change: |
    all access log formatters can be used as custom request/response headers. Custom header's syntax is parsed using access
    logger's parser and header values are obtained using access log's substitution formatters. This feature can be reversed
    by setting runtime guard ``envoy.reloadable_features.unified_header_formatter`` to false.
- area: http
  change: |
    made the :ref:`admission control <envoy_v3_api_msg_extensions.filters.http.admission_control.v3.AdmissionControl>` work
    as an upstream HTTP filter.
- area: http
  change: |
    added default-false ``envoy.reloadable_features.http1_use_balsa_parser`` for experimental BalsaParser.
- area: http
  change: |
    added ``envoy.reloadable_features.allow_upstream_filters`` for experimental upstream HTTP filters.
- area: dns_resolver
  change: |
    added DNS stats for c-ares DNS resolver. Detailed documentation is available :ref:`here <arch_overview_dns_resolution>`.
- area: gzip
  change: |
    added support for :ref:`max_inflate_ratio <envoy_v3_api_msg_extensions.compression.gzip.decompressor.v3.Gzip>`.
- area: access_log
  change: |
    added downstream handshake timing to connection streamInfo. Can be accessed by custom access loggers.
- area: build
  change: |
    official released binary is now built on Ubuntu 20.04, requires glibc >= 2.30.
- area: listener
  change: |
    added multiple listening addresses in single listener. :ref:`listener additional addresses
    <envoy_v3_api_field_config.listener.v3.Listener.additional_addresses>`.
- area: load balancer
  change: |
    added a new field to subset load balancer config: :ref:`metadata_fallback_policy
    <envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.metadata_fallback_policy>`.
- area: thrift
  change: |
    added stats for downstream connection close to detect SR drop.
- area: compression
  change: |
    added support for :ref:`choose_first <envoy_v3_api_msg_extensions.filters.http.compressor.v3.Compressor>`.
- area: cors
  change: |
    added support for cors PNA. This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy_reloadable_features_cors_private_network_access`` to false. More details refer to
    https://developer.chrome.com/blog/private-network-access-preflight.
- area: upstream
  change: |
    added a filter state object to control the destination address in :ref:`ORIGINAL_DST clusters
    <arch_overview_load_balancing_types_original_destination_request_header_filter_state>`.
- area: upstream
  change: |
    added a new field :ref:`extra_source_addresses <envoy_v3_api_field_config.core.v3.BindConfig.extra_source_addresses>` to
    the BindConfig, it enables to specify multiple source addresses, and the source address selection is based on target
    host's address' version.
- area: admin
  change: |
    added new :ref:`/heap_dump <operations_admin_interface_heap_dump>` endpoint to dump heap profile of Envoy.
- area: health check
  change: |
    added :ref:`method <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.method>` support to configure http
    health check http method.
- area: health check
  change: |
    added :ref:`thrift health check <envoy_v3_api_msg_extensions.health_checkers.thrift.v3.Thrift>` as a :ref:`custom health
    check <envoy_v3_api_msg_config.core.v3.HealthCheck.CustomHealthCheck>`.
- area: access_log
  change: |
    updated command operator ``%GRPC_STATUS%`` to suppoprt the snake case.
- area: redis
  change: |
    added support for redis transactions.
- area: listener
  change: |
    expose the implementation of :ref:`internal listener <config_internal_listener>` in xDS API.
- area: ratelimit
  change: |
    add support for :ref:`adding response headers
    <envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimit.response_headers_to_add>` to rate-limited responses.
- area: access_log
  change: |
    added support for number values in substitution format string in json_format.
- area: http
  change: |
    added the expected :ref:`receive <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.receive>` payload check
    for HTTP health check. Added :ref:`response_buffer_size
    <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.response_buffer_size>` to configure the maximum HTTP
    health check response buffer size.
- area: lua
  change: |
    added new headers method "setHttp1ReasonPhrase" for lua filter, please see :ref:`lua header wrapper
    <config_http_filters_lua_header_wrapper>`.
- area: lua
  change: |
    added stats for lua filter, please see :ref:`lua filter stats <config_http_filters_lua_stats>`.
- area: subset load balancer
  change: |
    added multiple keys or multiple selectors support for :ref:`single host per subset mode
    <envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.single_host_per_subset>`.
- area: listener
  change: |
    allow network filters other than HTTP Connection Manager to be created for QUIC listeners.
- area: lua
  change: |
    added an alternative function signature to ``httpCall()`` with ``options`` as an argument. This allows to skip sampling
    the produced trace span by setting ``{["trace_sampled"] = false}`` as the ``options``. And this allows to return
    multiple header values for same header name by setting ``{["return_duplicate_headers"] = true}`` as the ``options``.
- area: zipkin
  change: |
    added :ref:`split_spans_for_request <envoy_v3_api_field_config.trace.v3.ZipkinConfig.split_spans_for_request>` to make
    Envoy appear as an independent hop for zipkin tracing.
- area: cluster
  change: |
    added support to override original destination port via setting :ref:`upstream_port_override
    <envoy_v3_api_field_config.cluster.v3.Cluster.OriginalDstLbConfig.upstream_port_override>`.
- area: generic_proxy
  change: |
    added an new network filter :ref:`generic_proxy filter
    <envoy_v3_api_msg_extensions.filters.network.generic_proxy.v3.GenericProxy>`.
- area: redis
  change: |
    added support for quit command to the redis proxy.
- area: tcp_proxy
  change: |
    added support for propagating the response headers in :ref:`TunnelingConfig
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.propagate_response_headers>` to the
    downstream info filter state.
- area: access_log
  change: |
    log ``duration