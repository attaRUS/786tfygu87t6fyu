pxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad
  DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME
  HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==
  -----END CERTIFICATE-----

  ### GoDaddy.com, Inc.

  === /C=US/ST=Arizona/L=Scottsdale/O=GoDaddy.com, Inc./CN=Go Daddy Root Certificate Authority - G2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 0 (0x0)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Sep  1 00:00:00 2009 GMT
              Not After : Dec 31 23:59:59 2037 GMT
          Subject: C=US, ST=Arizona, L=Scottsdale, O=GoDaddy.com, Inc., CN=Go Daddy Root Certificate Authority - G2
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  3A:9A:85:07:10:67:28:B6:EF:F6:BD:05:41:6E:20:C1:94:DA:0F:DE
  SHA1 Fingerprint=47:BE:AB:C9:22:EA:E8:0E:78:78:34:62:A7:9F:45:C2:54:FD:E6:8B
  SHA256 Fingerprint=45:14:0B:32:47:EB:9C:C8:C5:B4:F0:D7:B5:30:91:F7:32:92:08:9E:6E:5A:63:E2:74:9D:D3:AC:A9:19:8E:DA
  -----BEGIN CERTIFICATE-----
  MIIDxTCCAq2gAwIBAgIBADANBgkqhkiG9w0BAQsFADCBgzELMAkGA1UEBhMCVVMx
  EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxGjAYBgNVBAoT
  EUdvRGFkZHkuY29tLCBJbmMuMTEwLwYDVQQDEyhHbyBEYWRkeSBSb290IENlcnRp
  ZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAwMFoXDTM3MTIzMTIz
  NTk1OVowgYMxCzAJBgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6b25hMRMwEQYDVQQH
  EwpTY290dHNkYWxlMRowGAYDVQQKExFHb0RhZGR5LmNvbSwgSW5jLjExMC8GA1UE
  AxMoR28gRGFkZHkgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIw
  DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL9xYgjx+lk09xvJGKP3gElY6SKD
  E6bFIEMBO4Tx5oVJnyfq9oQbTqC023CYxzIBsQU+B07u9PpPL1kwIuerGVZr4oAH
  /PMWdYA5UXvl+TW2dE6pjYIT5LY/qQOD+qK+ihVqf94Lw7YZFAXK6sOoBJQ7Rnwy
  DfMAZiLIjWltNowRGLfTshxgtDj6AozO091GB94KPutdfMh8+7ArU6SSYmlRJQVh
  GkSBjCypQ5Yj36w6gZoOKcUcqeldHraenjAKOc7xiID7S13MMuyFYkMlNAJWJwGR
  tDtwKj9useiciAF9n9T521NtYJ2/LOdYq7hfRvzOxBsDPAnrSTFcaUaz4EcCAwEA
  AaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYE
  FDqahQcQZyi27/a9BUFuIMGU2g/eMA0GCSqGSIb3DQEBCwUAA4IBAQCZ21151fmX
  WWcDYfF+OwYxdS2hII5PZYe096acvNjpL9DbWu7PdIxztDhC2gV7+AJ1uP2lsdeu
  9tfeE8tTEH6KRtGX+rcuKxGrkLAngPnon1rpN5+r5N9ss4UXnT3ZJE95kTXWXwTr
  gIOrmgIttRD02JDHBHNA7XIloKmf7J6raBKZV8aPEjoJpL1E/QYVN8Gb5DKj7Tjo
  2GTzLH4U/ALqn83/B2gX2yKQOC16jdFU8WnjXzPKej17CuPKf1855eJ1usV2GDPO
  LPAvTK33sefOT6jEm0pUBsV/fdUID+Ic/n4XuKxe9tQWskMJDE32p2u0mYRlynqI
  4uJEvlz36hz1
  -----END CERTIFICATE-----

  ### Google Trust Services LLC

  === /C=US/O=Google Trust Services LLC/CN=GTS Root R1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              6e:47:a9:c5:4b:47:0c:0d:ec:33:d0:89:b9:1c:f4:e1
      Signature Algorithm: sha384WithRSAEncryption
          Validity
              Not Before: Jun 22 00:00:00 2016 GMT
              Not After : Jun 22 00:00:00 2036 GMT
          Subject: C=US, O=Google Trust Services LLC, CN=GTS Root R1
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  E4:AF:2B:26:71:1A:2B:48:27:85:2F:52:66:2C:EF:F0:89:13:71:3E
  SHA1 Fingerprint=E1:C9:50:E6:EF:22:F8:4C:56:45:72:8B:92:20:60:D7:D5:A7:A3:E8
  SHA256 Fingerprint=2A:57:54:71:E3:13:40:BC:21:58:1C:BD:2C:F1:3E:15:84:63:20:3E:CE:94:BC:F9:D3:CC:19:6B:F0:9A:54:72
  -----BEGIN CERTIFICATE-----
  MIIFWjCCA0KgAwIBAgIQbkepxUtHDA3sM9CJuRz04TANBgkqhkiG9w0BAQwFADBH
  MQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExM
  QzEUMBIGA1UEAxMLR1RTIFJvb3QgUjEwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIy
  MDAwMDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNl
  cnZpY2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjEwggIiMA0GCSqGSIb3DQEB
  AQUAA4ICDwAwggIKAoICAQC2EQKLHuOhd5s73L+UPreVp0A8of2C+X0yBoJx9vaM
  f/vo27xqLpeXo4xL+Sv2sfnOhB2x+cWX3u+58qPpvBKJXqeqUqv4IyfLpLGcY9vX
  mX7wCl7raKb0xlpHDU0QM+NOsROjyBhsS+z8CZDfnWQpJSMHobTSPS5g4M/SCYe7
  zUjwTcLCeoiKu7rPWRnWr4+wB7CeMfGCwcDfLqZtbBkOtdh+JhpFAz2weaSUKK0P
  fyblqAj+lug8aJRT7oM6iCsVlgmy4HqMLnXWnOunVmSPlk9orj2XwoSPwLxAwAtc
  vfaHszVsrBhQf4TgTM2S0yDpM7xSma8ytSmzJSq0SPly4cpk9+aCEI3oncKKiPo4
  Zor8Y/kB+Xj9e1x3+naH+uzfsQ55lVe0vSbv1gHR6xYKu44LtcXFilWr06zqkUsp
  zBmkMiVOKvFlRNACzqrOSbTqn3yDsEB750Orp2yjj32JgfpMpf/VjsPOS+C12LOO
  Rc92wO1AK/1TD7Cn1TsNsYqiA94xrcx36m97PtbfkSIS5r762DL8EGMUUXLeXdYW
  k70paDPvOmbsB4om3xPXV2V4J95eSRQAogB/mqghtqmxlbCluQ0WEdrHbEg8QOB+
  DVrNVjzRlwW5y0vtOUucxD/SVRNuJLDWcfr0wbrM7Rv1/oFB2ACYPTrIrnqYNxgF
  lQIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV
  HQ4EFgQU5K8rJnEaK0gnhS9SZizv8IkTcT4wDQYJKoZIhvcNAQEMBQADggIBADiW
  Cu49tJYeX++dnAsznyvgyv3SjgofQXSlfKqE1OXyHuY3UjKcC9FhHb8owbZEKTV1
  d5iyfNm9dKyKaOOpMQkpAWBz40d8U6iQSifvS9efk+eCNs6aaAyC58/UEBZvXw6Z
  XPYfcX3v73svfuo21pdwCxXu11xWajOl40k4DLh9+42FpLFZXvRq4d2h9mREruZR
  gyFmxhE+885H7pwoHyXa/6xmld01D1zvICxi/ZG6qcz8WpyTgYMpl0p8WnK0OdC3
  d8t5/Wk6kjftbjhlRn7pYL15iJdfOBL07q9bgsiG1eGZbYwE8na6SfZu6W0eX6Dv
  J4J2QPim01hcDyxC2kLGe4g0x8HYRZvBPsVhHdljUEn2NIVq4BjFbkerQUIpm/Zg
  DdIx02OYI5NaAIFItO/Nis3Jz5nu2Z6qNuFoS3FJFDYoOj0dzpqPJeaAcWErtXvM
  +SUWgeExX6GjfhaknBZqlxi9dnKlC54dNuYvoS++cJEPqOba+MSSQGwlfnuzCdyy
  F62ARPBopY+Udf90WuioAnwMCeKpSwughQtiue+hMZL77/ZRBIls6Kl0obsXs7X9
  SQ98POyDGCBDTtWTurQ0sR8WNh8M5mQ5Fkzc4P4dyKliPUDqysU0ArSuiYgzNdws
  E3PYJ/HQcu51OyLemGhmW/HGY0dVHLqlCFF1pkgl
  -----END CERTIFICATE-----
  === /C=US/O=Google Trust Services LLC/CN=GTS Root R2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              6e:47:a9:c6:5a:b3:e7:20:c5:30:9a:3f:68:52:f2:6f
      Signature Algorithm: sha384WithRSAEncryption
          Validity
              Not Before: Jun 22 00:00:00 2016 GMT
              Not After : Jun 22 00:00:00 2036 GMT
          Subject: C=US, O=Google Trust Services LLC, CN=GTS Root R2
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  BB:FF:CA:8E:23:9F:4F:99:CA:DB:E2:68:A6:A5:15:27:17:1E:D9:0E
  SHA1 Fingerprint=D2:73:96:2A:2A:5E:39:9F:73:3F:E1:C7:1E:64:3F:03:38:34:FC:4D
  SHA256 Fingerprint=C4:5D:7B:B0:8E:6D:67:E6:2E:42:35:11:0B:56:4E:5F:78:FD:92:EF:05:8C:84:0A:EA:4E:64:55:D7:58:5C:60
  -----BEGIN CERTIFICATE-----
  MIIFWjCCA0KgAwIBAgIQbkepxlqz5yDFMJo/aFLybzANBgkqhkiG9w0BAQwFADBH
  MQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExM
  QzEUMBIGA1UEAxMLR1RTIFJvb3QgUjIwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIy
  MDAwMDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNl
  cnZpY2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjIwggIiMA0GCSqGSIb3DQEB
  AQUAA4ICDwAwggIKAoICAQDO3v2m++zsFDQ8BwZabFn3GTXd98GdVarTzTukk3Lv
  CvptnfbwhYBboUhSnznFt+4orO/LdmgUud+tAWyZH8QiHZ/+cnfgLFuv5AS/T3Kg
  GjSY6Dlo7JUle3ah5mm5hRm9iYz+re026nO8/4Piy33B0s5Ks40FnotJk9/BW9Bu
  XvAuMC6C/Pq8tBcKSOWIm8Wba96wyrQD8Nr0kLhlZPdcTK3ofmZemde4wj7I0BOd
  re7kRXuJVfeKH2JShBKzwkCX44ofR5GmdFrS+LFjKBC4swm4VndAoiaYecb+3yXu
  PuWgf9RhD1FLPD+M2uFwdNjCaKH5wQzpoeJ/u1U8dgbuak7MkogwTZq9TwtImoS1
  mKPV+3PBV2HdKFZ1E66HjucMUQkQdYhMvI35ezzUIkgfKtzra7tEscszcTJGr61K
  8YzodDqs5xoic4DSMPclQsciOzsSrZYuxsN2B6ogtzVJV+mSSeh2FnIxZyuWfoqj
  x5RWIr9qS34BIbIjMt/kmkRtWVtd9QCgHJvGeJeNkP+byKq0rxFROV7Z+2et1VsR
  nTKaG73VululycslaVNVJ1zgyjbLiGH7HrfQy+4W+9OmTN6SpdTi3/UGVN4unUu0
  kzCqgc7dGtxRcw1PcOnlthYhGXmy5okLdWTK1au8CcEYof/UVKGFPP0UJAOyh9Ok
  twIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV
  HQ4EFgQUu//KjiOfT5nK2+JopqUVJxce2Q4wDQYJKoZIhvcNAQEMBQADggIBALZp
  8KZ3/p7uC4Gt4cCpx/k1HUCCq+YEtN/L9x0Pg/B+E02NjO7jMyLDOfxA325BS0JT
  vhaI8dI4XsRomRyYUpOM52jtG2pzegVATX9lO9ZY8c6DR2Dj/5epnGB3GFW1fgiT
  z9D2PGcDFWEJ+YF59exTpJ/JjwGLc8R3dtyDovUMSRqodt6Sm2T4syzFJ9MHwAiA
  pJiS4wGWAqoC7o87xdFtCjMwc3i5T1QWvwsHoaRc5svJXISPD+AVdyx+Jn7axEvb
  pxZ3B7DNdehyQtaVhJ2Gg/LkkM0JR9SLA3DaWsYDQvTtN6LwG1BUSw7YhN4ZKJmB
  R64JGz9I0cNv4rBgF/XuIwKl2gBbbZCr7qLpGzvpx0QnRY5rn/WkhLx3+WuXrD5R
  RaIRpsyF7gpo8j5QOHokYh4XIDdtak23CZvJ/KRY9bb7nE4Yu5UC56GtmwfuNmsk
  0jmGwZODUNKBRqhfYlcsu2xkiAhu7xNUX90txGdj08+JN7+dIPT7eoOboB6BAFDC
  5AwiWVIQ7UNWhwD4FFKnHYuTjKJNRn8nxnGbJN7k2oaLDX5rIMHAnuFl2GqjpuiF
  izoHCBy69Y9Vmhh1fuXsgWbRIXOhNUQLgD1bnF5vKheW0YMjiGZt5obicDIvUiLn
  yOd/xCxgXS/Dr55FBcOEArf9LAhST4Ldo/DUhgkC
  -----END CERTIFICATE-----
  === /C=US/O=Google Trust Services LLC/CN=GTS Root R3
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              6e:47:a9:c7:6c:a9:73:24:40:89:0f:03:55:dd:8d:1d
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Jun 22 00:00:00 2016 GMT
              Not After : Jun 22 00:00:00 2036 GMT
          Subject: C=US, O=Google Trust Services LLC, CN=GTS Root R3
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  C1:F1:26:BA:A0:2D:AE:85:81:CF:D3:F1:2A:12:BD:B8:0A:67:FD:BC
  SHA1 Fingerprint=30:D4:24:6F:07:FF:DB:91:89:8A:0B:E9:49:66:11:EB:8C:5E:46:E5
  SHA256 Fingerprint=15:D5:B8:77:46:19:EA:7D:54:CE:1C:A6:D0:B0:C4:03:E0:37:A9:17:F1:31:E8:A0:4E:1E:6B:7A:71:BA:BC:E5
  -----BEGIN CERTIFICATE-----
  MIICDDCCAZGgAwIBAgIQbkepx2ypcyRAiQ8DVd2NHTAKBggqhkjOPQQDAzBHMQsw
  CQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExMQzEU
  MBIGA1UEAxMLR1RTIFJvb3QgUjMwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIyMDAw
  MDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZp
  Y2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjMwdjAQBgcqhkjOPQIBBgUrgQQA
  IgNiAAQfTzOHMymKoYTey8chWEGJ6ladK0uFxh1MJ7x/JlFyb+Kf1qPKzEUURout
  736GjOyxfi//qXGdGIRFBEFVbivqJn+7kAHjSxm65FSWRQmx1WyRRK2EE46ajA2A
  DDL24CejQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
  DgQWBBTB8Sa6oC2uhYHP0/EqEr24Cmf9vDAKBggqhkjOPQQDAwNpADBmAjEAgFuk
  fCPAlaUs3L6JbyO5o91lAFJekazInXJ0glMLfalAvWhgxeG4VDvBNhcl2MG9AjEA
  njWSdIUlUfUk7GRSJFClH9voy8l27OyCbvWFGFPouOOaKaqW04MjyaR7YbPMAuhd
  -----END CERTIFICATE-----
  === /C=US/O=Google Trust Services LLC/CN=GTS Root R4
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              6e:47:a9:c8:8b:94:b6:e8:bb:3b:2a:d8:a2:b2:c1:99
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Jun 22 00:00:00 2016 GMT
              Not After : Jun 22 00:00:00 2036 GMT
          Subject: C=US, O=Google Trust Services LLC, CN=GTS Root R4
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  80:4C:D6:EB:74:FF:49:36:A3:D5:D8:FC:B5:3E:C5:6A:F0:94:1D:8C
  SHA1 Fingerprint=2A:1D:60:27:D9:4A:B1:0A:1C:4D:91:5C:CD:33:A0:CB:3E:2D:54:CB
  SHA256 Fingerprint=71:CC:A5:39:1F:9E:79:4B:04:80:25:30:B3:63:E1:21:DA:8A:30:43:BB:26:66:2F:EA:4D:CA:7F:C9:51:A4:BD
  -----BEGIN CERTIFICATE-----
  MIICCjCCAZGgAwIBAgIQbkepyIuUtui7OyrYorLBmTAKBggqhkjOPQQDAzBHMQsw
  CQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExMQzEU
  MBIGA1UEAxMLR1RTIFJvb3QgUjQwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIyMDAw
  MDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZp
  Y2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjQwdjAQBgcqhkjOPQIBBgUrgQQA
  IgNiAATzdHOnaItgrkO4NcWBMHtLSZ37wWHO5t5GvWvVYRg1rkDdc/eJkTBa6zzu
  hXyiQHY7qca4R9gq55KRanPpsXI5nymfopjTX15YhmUPoYRlBtHci8nHc8iMai/l
  xKvRHYqjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
  DgQWBBSATNbrdP9JNqPV2Py1PsVq8JQdjDAKBggqhkjOPQQDAwNnADBkAjBqUFJ0
  CMRw3J5QdCHojXohw0+WbhXRIjVhLfoIN+4Zba3bssx9BzT1YBkstTTZbyACMANx
  sbqjYAuG7ZoIapVon+Kz4ZNkfF6Tpt95LY2F45TPI11xzPKwTdb+mciUqXWi4w==
  -----END CERTIFICATE-----

  ### GUANG DONG CERTIFICATE AUTHORITY CO.,LTD.

  === /C=CN/O=GUANG DONG CERTIFICATE AUTHORITY CO.,LTD./CN=GDCA TrustAUTH R5 ROOT
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 9009899650740120186 (0x7d0997fef047ea7a)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Nov 26 05:13:15 2014 GMT
              Not After : Dec 31 15:59:59 2040 GMT
          Subject: C=CN, O=GUANG DONG CERTIFICATE AUTHORITY CO.,LTD., CN=GDCA TrustAUTH R5 ROOT
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  E2:C9:40:9F:4D:CE:E8:9A:A1:7C:CF:0E:3F:65:C5:29:88:6A:19:51
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
  SHA1 Fingerprint=0F:36:38:5B:81:1A:25:C3:9B:31:4E:83:CA:E9:34:66:70:CC:74:B4
  SHA256 Fingerprint=BF:FF:8F:D0:44:33:48:7D:6A:8A:A6:0C:1A:29:76:7A:9F:C2:BB:B0:5E:42:0F:71:3A:13:B9:92:89:1D:38:93
  -----BEGIN CERTIFICATE-----
  MIIFiDCCA3CgAwIBAgIIfQmX/vBH6nowDQYJKoZIhvcNAQELBQAwYjELMAkGA1UE
  BhMCQ04xMjAwBgNVBAoMKUdVQU5HIERPTkcgQ0VSVElGSUNBVEUgQVVUSE9SSVRZ
  IENPLixMVEQuMR8wHQYDVQQDDBZHRENBIFRydXN0QVVUSCBSNSBST09UMB4XDTE0
  MTEyNjA1MTMxNVoXDTQwMTIzMTE1NTk1OVowYjELMAkGA1UEBhMCQ04xMjAwBgNV
  BAoMKUdVQU5HIERPTkcgQ0VSVElGSUNBVEUgQVVUSE9SSVRZIENPLixMVEQuMR8w
  HQYDVQQDDBZHRENBIFRydXN0QVVUSCBSNSBST09UMIICIjANBgkqhkiG9w0BAQEF
  AAOCAg8AMIICCgKCAgEA2aMW8Mh0dHeb7zMNOwZ+Vfy1YI92hhJCfVZmPoiC7XJj
  Dp6L3TQsAlFRwxn9WVSEyfFrs0yw6ehGXTjGoqcuEVe6ghWinI9tsJlKCvLriXBj
  TnnEt1u9ol2x8kECK62pOqPseQrsXzrj/e+APK00mxqriCZ7VqKChh/rNYmDf1+u
  KU49tm7srsHwJ5uu4/Ts765/94Y9cnrrpftZTqfrlYwiOXnhLQiPzLyRuEH3FMEj
  qcOtmkVEs7LXLM3GKeJQEK5cy4KOFxg2fZfmiJqwTTQJ9Cy5WmYqsBebnh52nUpm
  MUHfP/vFBu8btn4aRjb3ZGM74zkYI+dndRTVdVeSN72+ahsmUPI2JgaQxXABZG12
  ZuGR224HwGGALrIuL4xwp9E7PLOR5G62xDtw8mySlwnNR30YwPO7ng/Wi64HtloP
  zgsMR6flPri9fcebNaBhlzpBdRfMK5Z3KpIhHtmVdiBnaM8Nvd/WHwlqmuLMc3Gk
  L30SgLdTMEZeS1SZD2fJpcjyIMGC7J0R38IC+xo70e0gmu9lZJIQDSri3nDxGGeC
  jGHeuLzRL5z7D9Ar7Rt2ueQ5Vfj4oR24qoAATILnsn8JuLwwoC8N9VKejveSswoA
  HQBUlwbgsQfZxw9cZX08bVlX5O2ljelAU58VS6Bx9hoh49pwBiFYFIeFd3mqgnkC
  AwEAAaNCMEAwHQYDVR0OBBYEFOLJQJ9NzuiaoXzPDj9lxSmIahlRMA8GA1UdEwEB
  /wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4ICAQDRSVfg
  p8xoWLoBDysZzY2wYUWsEe1jUGn4H3++Fo/9nesLqjJHdtJnJO29fDMylyrHBYZm
  DRd9FBUb1Ov9H5r2XpdptxolpAqzkT9fNqyL7FeoPueBihhXOYV0GkLH6VsTX4/5
  COmSdI31R9KrO9b7eGZONn356ZLpBN79SWP8bfsUcZNnL0dKt7n/HipzcEYwv1ry
  L3ml4Y0M2fmyYzeMN2WFcGpcWwlyua1jPLHd+PwyvzeG5LuOmCd+uh8W4XAR8gPf
  JWIyJyYYMoSf/wA6E7qaTfRPuBRwIrHKK5DOKcFw9C+df/KQHtZa37dG/OaG+svg
  IHZ6uqbL9XzeYqWxi+7egmaKTjowHz+Ay60nugxe19CxVsp3cbK1daFQqUBDF8Io
  2c9Si1vIY9RCPqAzekYu9wogRlR+ak8x8YF+QnQ4ZXMn7sZ8uI7XpTrXmKGcjBBV
  09tL7ECQ8s1uV9JiDnxXk7Gnbc2dg7sq5+W2O3FYrf3RRbxake5TFW/TRQl1brqQ
  XR4EzzffHqhmsYzmIGrv/EhOdJhCrylvLmrH+33RZjEizIYAfmaDDEL0vTSSwxrq
  T8p+ck0LcIymSLumoRT2+1hEmRSuqguTaaApJUqlyyvdimYHFngVV3Eb7PVHhPOe
  MTd61X8kreS8/f3MboPoDKi3QWwH3b08hpcv0g==
  -----END CERTIFICATE-----

  ### Hellenic Academic and Research Institutions Cert. Authority

  === /C=GR/L=Athens/O=Hellenic Academic and Research Institutions Cert. Authority/CN=Hellenic Academic and Research Institutions ECC RootCA 2015
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 0 (0x0)
      Signature Algorithm: ecdsa-with-SHA256
          Validity
              Not Before: Jul  7 10:37:12 2015 GMT
              Not After : Jun 30 10:37:12 2040 GMT
          Subject: C=GR, L=Athens, O=Hellenic Academic and Research Institutions Cert. Authority, CN=Hellenic Academic and Research Institutions ECC RootCA 2015
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  B4:22:0B:82:99:24:01:0E:9C:BB:E4:0E:FD:BF:FB:97:20:93:99:2A
  SHA1 Fingerprint=9F:F1:71:8D:92:D5:9A:F3:7D:74:97:B4:BC:6F:84:68:0B:BA:B6:66
  SHA256 Fingerprint=44:B5:45:AA:8A:25:E6:5A:73:CA:15:DC:27:FC:36:D2:4C:1C:B9:95:3A:06:65:39:B1:15:82:DC:48:7B:48:33
  -----BEGIN CERTIFICATE-----
  MIICwzCCAkqgAwIBAgIBADAKBggqhkjOPQQDAjCBqjELMAkGA1UEBhMCR1IxDzAN
  BgNVBAcTBkF0aGVuczFEMEIGA1UEChM7SGVsbGVuaWMgQWNhZGVtaWMgYW5kIFJl
  c2VhcmNoIEluc3RpdHV0aW9ucyBDZXJ0LiBBdXRob3JpdHkxRDBCBgNVBAMTO0hl
  bGxlbmljIEFjYWRlbWljIGFuZCBSZXNlYXJjaCBJbnN0aXR1dGlvbnMgRUNDIFJv
  b3RDQSAyMDE1MB4XDTE1MDcwNzEwMzcxMloXDTQwMDYzMDEwMzcxMlowgaoxCzAJ
  BgNVBAYTAkdSMQ8wDQYDVQQHEwZBdGhlbnMxRDBCBgNVBAoTO0hlbGxlbmljIEFj
  YWRlbWljIGFuZCBSZXNlYXJjaCBJbnN0aXR1dGlvbnMgQ2VydC4gQXV0aG9yaXR5
  MUQwQgYDVQQDEztIZWxsZW5pYyBBY2FkZW1pYyBhbmQgUmVzZWFyY2ggSW5zdGl0
  dXRpb25zIEVDQyBSb290Q0EgMjAxNTB2MBAGByqGSM49AgEGBSuBBAAiA2IABJKg
  QehLgoRc4vgxEZmGZE4JJS+dQS8KrjVPdJWyUWRrjWvmP3CV8AVER6ZyOFB2lQJa
  jq4onvktTpnvLEhvTCUp6NFxW98dwXU3tNf6e3pCnGoKVlp8aQuqgAkkbH7BRqNC
  MEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFLQi
  C4KZJAEOnLvkDv2/+5cgk5kqMAoGCCqGSM49BAMCA2cAMGQCMGfOFmI4oqxiRaep
  lSTAGiecMjvAwNW6qef4BENThe5SId6d9SWDPp5YSy/XZxMOIQIwBeF1Ad5o7Sof
  TUwJCA3sS61kFyjndc5FZXIhF8siQQ6ME5g4mlRtm8rifOoCWCKR
  -----END CERTIFICATE-----
  === /C=GR/L=Athens/O=Hellenic Academic and Research Institutions Cert. Authority/CN=Hellenic Academic and Research Institutions RootCA 2015
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 0 (0x0)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jul  7 10:11:21 2015 GMT
              Not After : Jun 30 10:11:21 2040 GMT
          Subject: C=GR, L=Athens, O=Hellenic Academic and Research Institutions Cert. Authority, CN=Hellenic Academic and Research Institutions RootCA 2015
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  71:15:67:C8:C8:C9:BD:75:5D:72:D0:38:18:6A:9D:F3:71:24:54:0B
  SHA1 Fingerprint=01:0C:06:95:A6:98:19:14:FF:BF:5F:C6:B0:B6:95:EA:29:E9:12:A6
  SHA256 Fingerprint=A0:40:92:9A:02:CE:53:B4:AC:F4:F2:FF:C6:98:1C:E4:49:6F:75:5E:6D:45:FE:0B:2A:69:2B:CD:52:52:3F:36
  -----BEGIN CERTIFICATE-----
  MIIGCzCCA/OgAwIBAgIBADANBgkqhkiG9w0BAQsFADCBpjELMAkGA1UEBhMCR1Ix
  DzANBgNVBAcTBkF0aGVuczFEMEIGA1UEChM7SGVsbGVuaWMgQWNhZGVtaWMgYW5k
  IFJlc2VhcmNoIEluc3RpdHV0aW9ucyBDZXJ0LiBBdXRob3JpdHkxQDA+BgNVBAMT
  N0hlbGxlbmljIEFjYWRlbWljIGFuZCBSZXNlYXJjaCBJbnN0aXR1dGlvbnMgUm9v
  dENBIDIwMTUwHhcNMTUwNzA3MTAxMTIxWhcNNDAwNjMwMTAxMTIxWjCBpjELMAkG
  A1UEBhMCR1IxDzANBgNVBAcTBkF0aGVuczFEMEIGA1UEChM7SGVsbGVuaWMgQWNh
  ZGVtaWMgYW5kIFJlc2VhcmNoIEluc3RpdHV0aW9ucyBDZXJ0LiBBdXRob3JpdHkx
  QDA+BgNVBAMTN0hlbGxlbmljIEFjYWRlbWljIGFuZCBSZXNlYXJjaCBJbnN0aXR1
  dGlvbnMgUm9vdENBIDIwMTUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoIC
  AQDC+Kk/G4n8PDwEXT2QNrCROnk8ZlrvbTkBSRq0t89/TSNTt5AA4xMqKKYx8ZEA
  4yjsriFBzh/a/X0SWwGDD7mwX5nh8hKDgE0GPt+sr+ehiGsxr/CL0BgzuNtFajT0
  AoAkKAoCFZVedioNmToUW/bLy1O8E00BiDeUJRtCvCLYjqOWXjrZMts+6PAQZe10
  4S+nfK8nNLspfZu2zwnI5dMK/IhlZXQK3HMcXM1AsRzUtoSMTFDPaI6oWa7CJ06C
  ojXdFPQf/7J31Ycvqm59JCfnxssm5uX+Zwdj2EUN3TpZZTlYepKZcj2chF6IIbjV
  9Cz82XBST3i4vTwri5WY9bPRaM8gFH5MXF/ni+X1NYEZN9cRCLdmvtNKzoNXADrD
  gfgXy5I2XdGj2HUb4Ysn6npIQf1FGQatJ5lOwXBH3bWfgVMS5bGMSF0xQxfjjMZ6
  Y5ZLKTBOhE5iGV48zpeQpX8B653g+IuJ3SWYPZK2fu/Z8VFRfS0myGlZYeCsargq
  NhEEelC9MoS+L9xy1dcdFkfkR2YgP/SWxa+OAXqlD3pk9Q0Yh9muiNX6hME6wGko
  LfINaFGq46V3xqSQDqE3izEjR8EJCOtu93ib14L8hCCZSRm2Ekax+0VVFqmjZayc
  Bw/qa9wfLgZy7IaIEuQt218FL+TwA9MmM+eAws1CoRc0CwIDAQABo0IwQDAPBgNV
  HRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUcRVnyMjJvXVd
  ctA4GGqd83EkVAswDQYJKoZIhvcNAQELBQADggIBAHW7bVRLqhBYRjTyYtcWNl0I
  XtVsyIe9tC5G8jH4fOpCtZMWVdyhDBKg2mF+D1hYc2Ryx+hFjtyp8iY/xnmMsVMI
  M4GwVhO+5lFc2JsKT0ucVlMC6U/2DWDqTUJV6HwbISHTGzrMd/K4kPFox/la/vot
  9L/J9UUbzjgQKjeKeaO04wlshYaT/4mWJ3iBj2fjRnRUjtkNaeJK9E10A/+yd+2V
  Z5fkscWrv2oj6NSU4kQoYsRL4vDY4ilrGnB+JGGTe08DMiUNRSQrlrRGar9KC/ea
  j8GsGsVn82800vpzY4zvFrCopEYq+OsS7HK07/grfoxSwIuEVPkvPuNVqNxmsdnh
  X9izjFk0WaSrT2y7HxjbdavYy5LNlDhhDgcGH0tGEPEVvo2FXDtKK4F5D7Rpn0lQ
  l033DlZdwJVqwjbDG2jJ9SrcR5q+ss7FJej6A7na+RZukYT1HCjI/CbM1xyQVqdf
  bzoEvM14iQuODy+jqk+iGxI9FghAD/FGTNeqewjBCvVtJ94Cj8rDtSvK6evIIVM4
  pcw72Hc3MKJP2W/R8kCtQXoXxdZKNYm3QdV8hn9VTYNKpXMgwDqvkPGaJI7ZjnHK
  e7iG2rKPmT4dEw0SEe7Uq/DpFXYC5ODfqiAeW2GFZECpkJcNrVPSWh2HagCXZWK0
  vm9qp/UsQu0yrbYhnr68
  -----END CERTIFICATE-----
  === /C=GR/O=Hellenic Academic and Research Institutions Cert. Authority/CN=Hellenic Academic and Research Institutions RootCA 2011
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 0 (0x0)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Dec  6 13:49:52 2011 GMT
              Not After : Dec  1 13:49:52 2031 GMT
          Subject: C=GR, O=Hellenic Academic and Research Institutions Cert. Authority, CN=Hellenic Academic and Research Institutions RootCA 2011
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage:
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  A6:91:42:FD:13:61:4A:23:9E:08:A4:29:E5:D8:13:04:23:EE:41:25
              X509v3 Name Constraints:
                  Permitted:
                    DNS:.gr
                    DNS:.eu
                    DNS:.edu
                    DNS:.org
                    email:.gr
                    email:.eu
                    email:.edu
                    email:.org

  SHA1 Fingerprint=FE:45:65:9B:79:03:5B:98:A1:61:B5:51:2E:AC:DA:58:09:48:22:4D
  SHA256 Fingerprint=BC:10:4F:15:A4:8B:E7:09:DC:A5:42:A7:E1:D4:B9:DF:6F:05:45:27:E8:02:EA:A9:2D:59:54:44:25:8A:FE:71
  -----BEGIN CERTIFICATE-----
  MIIEMTCCAxmgAwIBAgIBADANBgkqhkiG9w0BAQUFADCBlTELMAkGA1UEBhMCR1Ix
  RDBCBgNVBAoTO0hlbGxlbmljIEFjYWRlbWljIGFuZCBSZXNlYXJjaCBJbnN0aXR1
  dGlvbnMgQ2VydC4gQXV0aG9yaXR5MUAwPgYDVQQDEzdIZWxsZW5pYyBBY2FkZW1p
  YyBhbmQgUmVzZWFyY2ggSW5zdGl0dXRpb25zIFJvb3RDQSAyMDExMB4XDTExMTIw
  NjEzNDk1MloXDTMxMTIwMTEzNDk1MlowgZUxCzAJBgNVBAYTAkdSMUQwQgYDVQQK
  EztIZWxsZW5pYyBBY2FkZW1pYyBhbmQgUmVzZWFyY2ggSW5zdGl0dXRpb25zIENl
  cnQuIEF1dGhvcml0eTFAMD4GA1UEAxM3SGVsbGVuaWMgQWNhZGVtaWMgYW5kIFJl
  c2VhcmNoIEluc3RpdHV0aW9ucyBSb290Q0EgMjAxMTCCASIwDQYJKoZIhvcNAQEB
  BQADggEPADCCAQoCggEBAKlTAOMupvaO+mDYLZU++CwqVE7NuYRhlFhPjz2L5EPz
  dYmNUeTDN9KKiE15HrcS3UN4SoqS5tdI1Q+kOilENbgH9mgdVc04UfCMJDGFr4PJ
  fel3r+0ae50X+bOdOFAPplp5kYCvN66m0zH7tSYJnTxa71HFK9+WXesyHgLacEns
  bgzImjeN9/E2YEsmLIKe0HjzDQ9jpFEw4fkrJxIH2Oq9GGKYsFk3fb7u8yBRQlqD
  75O6aRXxYp2fmTmCobd0LovUxQt7L/DICto9eQqakxylKHJzkUOap9FNhYS5qXSP
  FEDH3N6sQWRstBmbAmNtJGSPRLIl6s5ddAxjMlyNh+UCAwEAAaOBiTCBhjAPBgNV
  HRMBAf8EBTADAQH/MAsGA1UdDwQEAwIBBjAdBgNVHQ4EFgQUppFC/RNhSiOeCKQp
  5dgTBCPuQSUwRwYDVR0eBEAwPqA8MAWCAy5ncjAFggMuZXUwBoIELmVkdTAGggQu
  b3JnMAWBAy5ncjAFgQMuZXUwBoEELmVkdTAGgQQub3JnMA0GCSqGSIb3DQEBBQUA
  A4IBAQAf73lB4XtuP7KMhjdCSk4cNx6NZrokgclPEg8hwAOXhiVtXdMiKahsog2p
  6z0GW5k6x8zDmjR/qw7IThzh+uTczQ2+vyT+bOdrwg3IBp5OjWEopmr95fZi6hg8
  TqBTnbI6nOulnJEWtk2C4AwFSKls9cz4y51JtPACpf1wA+2KIaWuE4ZJwzNzvoc7
  dIsXRSZMFpGD/md9zU1jZ/rzAxKWeAaNsWftjj++n08C9bMJL/NMh98qy5V8Acys
  Nnq/onN694/BtZqhFLKPM58N7yLcZnuEvUUXBj08yrl3NI/K6s8/MT7jiOOASSXI
  l7WdmplNsDz4SgCbZN2fOUvRJ9e4
  -----END CERTIFICATE-----

  ### Hongkong Post

  === /C=HK/O=Hongkong Post/CN=Hongkong Post Root CA 1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 1000 (0x3e8)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: May 15 05:13:14 2003 GMT
              Not After : May 15 04:52:29 2023 GMT
          Subject: C=HK, O=Hongkong Post, CN=Hongkong Post Root CA 1
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE, pathlen:3
              X509v3 Key Usage: critical
                  Digital Signature, Non Repudiation, Certificate Sign, CRL Sign
  SHA1 Fingerprint=D6:DA:A8:20:8D:09:D2:15:4D:24:B5:2F:CB:34:6E:B2:58:B2:8A:58
  SHA256 Fingerprint=F9:E6:7D:33:6C:51:00:2A:C0:54:C6:32:02:2D:66:DD:A2:E7:E3:FF:F1:0A:D0:61:ED:31:D8:BB:B4:10:CF:B2
  -----BEGIN CERTIFICATE-----
  MIIDMDCCAhigAwIBAgICA+gwDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UEBhMCSEsx
  FjAUBgNVBAoTDUhvbmdrb25nIFBvc3QxIDAeBgNVBAMTF0hvbmdrb25nIFBvc3Qg
  Um9vdCBDQSAxMB4XDTAzMDUxNTA1MTMxNFoXDTIzMDUxNTA0NTIyOVowRzELMAkG
  A1UEBhMCSEsxFjAUBgNVBAoTDUhvbmdrb25nIFBvc3QxIDAeBgNVBAMTF0hvbmdr
  b25nIFBvc3QgUm9vdCBDQSAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
  AQEArP84tulmAknjorThkPlAj3n54r15/gK97iSSHSL22oVyaf7XPwnU3ZG1ApzQ
  jVrhVcNQhrkpJsLj2aDxaQMoIIBFIi1WpztUlVYiWR8o3x8gPW2iNr4joLFutbEn
  PzlTCeqrauh0ssJlXI6/fMN4hM2eFvz1Lk8gKgifd/PFHsSaUmYeSF7jEAaPIpjh
  ZY4bXSNmO7ilMlHIhqqhqZ5/dpTCpmy3QfDVyAY45tQM4vM7TG1QjMSDJ8EThFk9
  nnV0ttgCXjqQesBCNnLsak3c78QA3xMYV18meMjWCnl3v/evt3a5pQuEF10Q6m/h
  q5URX208o1xNg1vysxmKgIsLhwIDAQABoyYwJDASBgNVHRMBAf8ECDAGAQH/AgED
  MA4GA1UdDwEB/wQEAwIBxjANBgkqhkiG9w0BAQUFAAOCAQEADkbVPK7ih9legYsC
  mEEIjEy82tvuJxuC52pF7BaLT4Wg87JwvVqWuspube5Gi27nKi6Wsxkz67SfqLI3
  7piol7Yutmcn1KZJ/RyTZXaeQi/cImyaT/JaFTmxcdcrUehtHJjA2Sr0oYJ71clB
  oiMBdDhViw+5LmeiIAQ32pwL0xch4I+XeTRvhEgCIDMb5jREn5Fw9IBehEPCKdJs
  EhTkYY2sEJCehFC78JZvRZ+K88psT/oROhUVRsPNH4NbLUES7VBnQRM9IauUiqpO
  fMGx+6fWtScvl6tu4B3i0RwsH0Ti/L6RoZz71ilTc4afU9hDDl3WY4JxHYB0yvbi
  AmvZWg==
  -----END CERTIFICATE-----
  === /C=HK/ST=Hong Kong/L=Hong Kong/O=Hongkong Post/CN=Hongkong Post Root CA 3
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              08:16:5f:8a:4c:a5:ec:00:c9:93:40:df:c4:c6:ae:23:b8:1c:5a:a4
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jun  3 02:29:46 2017 GMT
              Not After : Jun  3 02:29:46 2042 GMT
          Subject: C=HK, ST=Hong Kong, L=Hong Kong, O=Hongkong Post, CN=Hongkong Post Root CA 3
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Authority Key Identifier:
                  keyid:17:9D:CD:1E:8B:D6:39:2B:70:D3:5C:D4:A0:B8:1F:B0:00:FC:C5:61

              X509v3 Subject Key Identifier:
                  17:9D:CD:1E:8B:D6:39:2B:70:D3:5C:D4:A0:B8:1F:B0:00:FC:C5:61
  SHA1 Fingerprint=58:A2:D0:EC:20:52:81:5B:C1:F3:F8:64:02:24:4E:C2:8E:02:4B:02
  SHA256 Fingerprint=5A:2F:C0:3F:0C:83:B0:90:BB:FA:40:60:4B:09:88:44:6C:76:36:18:3D:F9:84:6E:17:10:1A:44:7F:B8:EF:D6
  -----BEGIN CERTIFICATE-----
  MIIFzzCCA7egAwIBAgIUCBZfikyl7ADJk0DfxMauI7gcWqQwDQYJKoZIhvcNAQEL
  BQAwbzELMAkGA1UEBhMCSEsxEjAQBgNVBAgTCUhvbmcgS29uZzESMBAGA1UEBxMJ
  SG9uZyBLb25nMRYwFAYDVQQKEw1Ib25na29uZyBQb3N0MSAwHgYDVQQDExdIb25n
  a29uZyBQb3N0IFJvb3QgQ0EgMzAeFw0xNzA2MDMwMjI5NDZaFw00MjA2MDMwMjI5
  NDZaMG8xCzAJBgNVBAYTAkhLMRIwEAYDVQQIEwlIb25nIEtvbmcxEjAQBgNVBAcT
  CUhvbmcgS29uZzEWMBQGA1UEChMNSG9uZ2tvbmcgUG9zdDEgMB4GA1UEAxMXSG9u
  Z2tvbmcgUG9zdCBSb290IENBIDMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK
  AoICAQCziNfqzg8gTr7m1gNt7ln8wlffKWihgw4+aMdoWJwcYEuJQwy51BWy7sFO
  dem1p+/l6TWZ5Mwc50tfjTMwIDNT2aa71T4Tjukfh0mtUC1Qyhi+AViiE3CWu4mI
  VoBc+L0sPOFMV4i707mV78vH9toxdCim5lSJ9UExyuUmGs2C4HDaOym71QP1mbpV
  9WTRYA6ziUm4ii8F0oRFKHyPaFASePwLtVPLwpgchKOesL4jpNrcyCse2m5FHomY
  2vkALgbpDDtw1VAliJnLzXNg99X/NWfFobxeq81KuEXryGgeDQ0URhLj0mRiikKY
  vLTGCAj4/ahMZJx2Ab0vqWwzD9g/KLg8aQFChn5pwckGyuV6RmXpwtZQQS4/t+Tt
  bNe/JgERohYpSms0BpDsE9K2+2p20jzt8NYt3eEV7KObLyzJPivkaTv/ciWxNoZb
  x39ri1UbSsUgYT2uy1DhCDq+sI9jQVMwCFk8mB13umOResoQUGC/8Ne8lYePl8X+
  l2oBlKN8W4UdKjk60FSh0Tlxnf0h+bV78OLgAo9uliQlLKAeLKjEiafv7ZkGL7YK
  TE/bosw3Gq9HhS2KX8Q0NEwA/RiTZxPRN+ZItIsGxVd7GYYKecsAyVKvQv83j+Gj
  Hno9UKtjBucVtT+2RTeUN7F+8kjDf8V1/peNRY8apxpyKBpADwIDAQABo2MwYTAP
  BgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAfBgNVHSMEGDAWgBQXnc0e
  i9Y5K3DTXNSguB+wAPzFYTAdBgNVHQ4EFgQUF53NHovWOStw01zUoLgfsAD8xWEw
  DQYJKoZIhvcNAQELBQADggIBAFbVe27mIgHSQpsY1Q7XZiNc4/6gx5LS6ZStS6LG
  7BJ8dNVI0lkUmcDrudHr9EgwW62nV3OZqdPlt9EuWSRY3GguLmLYauRwCy0gUCCk
  MpXRAJi70/33MvJJrsZ64Ee+bs7Lo3I6LWldy8joRTnU+kLBEUx3XZL7av9YROXr
  gZ6voJmtvqkBZss4HTzfQx/0TW60uhdG/H39h4F5ag0zD/ov+BS5gLNdTaqX4fnk
  GMX41TiMJjz98iji7lpJiCzfeT2OnpA8vUFKOt1b9pq0zj8lMH8yfaIDlNDceqFS
  3m6TjRgm/VWsvY+b0s+v54Ysyx8Jb6NvqYTUc79NoXQbTiNg8swOqn+knEwlqLJm
  Ozj/2ZQw9nKEvmhVEA/GcywWaZMH/rFF7buiVWqw2rVKAiUnhde3t4ZEFolsgCs+
  l6mc1X5VTMbeRRAc6uk7nwNT7u56AQIWeNTowr5GdogTPyK7SBIdUgC0An4hGh6c
  JfTzPV4e0hz5sy229zdcxsshTrD3mUcYhcErulWuBurQB7Lcq9CClnXO0lD+mefP
  L5/ndtFhKvshuzHQqp9HpLIiyhY6UFfEW0NnxWViA0kB60PZ2Pierc+xYw5F9KBa
  LJstxabArahH9CdMOA0uG0k7UvToiIMrVCjU8jVStDKDYmlkDJGcn5fqdBb9HxEG
  mpv0
  -----END CERTIFICATE-----

  ### IdenTrust

  === /C=US/O=IdenTrust/CN=IdenTrust Commercial Root CA 1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              0a:01:42:80:00:00:01:45:23:c8:44:b5:00:00:00:02
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jan 16 18:12:23 2014 GMT
              Not After : Jan 16 18:12:23 2034 GMT
          Subject: C=US, O=IdenTrust, CN=IdenTrust Commercial Root CA 1
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  ED:44:19:C0:D3:F0:06:8B:EE:A4:7B:BE:42:E7:26:54:C8:8E:36:76
  SHA1 Fingerprint=DF:71:7E:AA:4A:D9:4E:C9:55:84:99:60:2D:48:DE:5F:BC:F0:3A:25
  SHA256 Fingerprint=5D:56:49:9B:E4:D2:E0:8B:CF:CA:D0:8A:3E:38:72:3D:50:50:3B:DE:70:69:48:E4:2F:55:60:30:19:E5:28:AE
  -----BEGIN CERTIFICATE-----
  MIIFYDCCA0igAwIBAgIQCgFCgAAAAUUjyES1AAAAAjANBgkqhkiG9w0BAQsFADBK
  MQswCQYDVQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MScwJQYDVQQDEx5JZGVu
  VHJ1c3QgQ29tbWVyY2lhbCBSb290IENBIDEwHhcNMTQwMTE2MTgxMjIzWhcNMzQw
  MTE2MTgxMjIzWjBKMQswCQYDVQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MScw
  JQYDVQQDEx5JZGVuVHJ1c3QgQ29tbWVyY2lhbCBSb290IENBIDEwggIiMA0GCSqG
  SIb3DQEBAQUAA4ICDwAwggIKAoICAQCnUBneP5k91DNG8W9RYYKyqU+PZ4ldhNlT
  3Qwo2dfw/66VQ3KZ+bVdfIrBQuExUHTRgQ18zZshq0PirK1ehm7zCYofWjK9ouuU
  +ehcCuz/mNKvcbO0U59Oh++SvL3sTzIwiEsXXlfEU8L2ApeN2WIrvyQfYo3fw7gp
  S0l4PJNgiCL8mdo2yMKi1CxUAGc1bnO/AljwpN3lsKImesrgNqUZFvX9t++uP0D1
  bVoE/c40yiTcdCMbXTMTEl3EASX2MN0CXZ/g1Ue9tOsbobtJSdifWwLziuQkkORi
  T0/Br4sOdBeo0XKIanoBScy0RnnGF7HamB4HWfp1IYVl3ZBWzvurpWCdxJ35UrCL
  vYf5jysjCiN2O/cz4ckA82n5S6LgTrx+kzmEB/dEcH7+B1rlsazRGMzyNeVJSQjK
  Vsk9+w8YfYs7wRPCTY/JTw436R+hDmrfYi7LNQZReSzIJTj0+kuniVyc0uMNOYZK
  dHzVWYfCP04MXFL0PfdSgvHqo6z9STQaKPNBiDoT7uje/5kdX7rL6B7yuVBgwDHT
  c+XvvqDtMwt0viAgxGds8AgDelWAf0ZOlqf0Hj7h9tgJ4TNkK2PXMl6f+cB7D3hv
  l7yTmvmcEpB4eoCHFddydJxVdHixuuFucAS6T6C6aMN7/zHwcz09lCqxC0EOoP5N
  iGVreTO01wIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB
  /zAdBgNVHQ4EFgQU7UQZwNPwBovupHu+QucmVMiONnYwDQYJKoZIhvcNAQELBQAD
  ggIBAA2ukDL2pkt8RHYZYR4nKM1eVO8lvOMIkPkp165oCOGUAFjvLi5+U1KMtlwH
  6oi6mYtQlNeCgN9hCQCTrQ0U5s7B8jeUeLBfnLOic7iPBZM4zY0+sLj7wM+x8uwt
  LRvM7Kqas6pgghstO8OEPVeKlh6cdbjTMM1gCIOQ045U8U1mwF10A0Cj7oV+wh93
  nAbowacYXVKV7cndJZ5t+qntozo00Fl72u1Q8zW/7esUTTHHYPTa8Yec4kjixsU3
  +wYQ+nVZZjFHKdp2mhzpgq7vmrlR94gjmmmVYjzlVYA211QC//G5Xc7UI2/YRYRK
  W2XviQzdFKcgyxilJbQN+QHwotL0AMh0jqEqSI5l2xPE4iUXfeu+h1sXIFRRk0pT
  AwvsXcoz7WL9RccvW9xYoIA55vrX/hMUpu09lEpCdNTDd1lzzY9GvlU47/rokTLq
  l1gEIt44w8y8bckzOmoKaT+gyOpyj4xjhiO9bTyWnpXgSUyqorkqG5w2gXjtw+hG
  4iZZRHUe2XWJUc0QhJ1hYMtd+ZciTY6Y5uN/9lu7rs3KSoFrXgvzUeF0K+l+J6fZ
  mUlO+KWA2yUPHGNiiskzZ2s8EIPGrd6ozRaOjfAHN3Gf8qv8QfXBi+wAN10J5U6A
  7/qxXDgGpRtK4dw4LTzcqx+QGtVKnO7RcGzM7vRX+Bi6hG6H
  -----END CERTIFICATE-----
  === /C=US/O=IdenTrust/CN=IdenTrust Public Sector Root CA 1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              0a:01:42:80:00:00:01:45:23:cf:46:7c:00:00:00:02
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jan 16 17:53:32 2014 GMT
              Not After : Jan 16 17:53:32 2034 GMT
          Subject: C=US, O=IdenTrust, CN=IdenTrust Public Sector Root CA 1
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  E3:71:E0:9E:D8:A7:42:D9:DB:71:91:6B:94:93:EB:C3:A3:D1:14:A3
  SHA1 Fingerprint=BA:29:41:60:77:98:3F:F4:F3:EF:F2:31:05:3B:2E:EA:6D:4D:45:FD
  SHA256 Fingerprint=30:D0:89:5A:9A:44:8A:26:20:91:63:55:22:D1:F5:20:10:B5:86:7A:CA:E1:2C:78:EF:95:8F:D4:F4:38:9F:2F
  -----BEGIN CERTIFICATE-----
  MIIFZjCCA06gAwIBAgIQCgFCgAAAAUUjz0Z8AAAAAjANBgkqhkiG9w0BAQsFADBN
  MQswCQYDVQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MSowKAYDVQQDEyFJZGVu
  VHJ1c3QgUHVibGljIFNlY3RvciBSb290IENBIDEwHhcNMTQwMTE2MTc1MzMyWhcN
  MzQwMTE2MTc1MzMyWjBNMQswCQYDVQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0
  MSowKAYDVQQDEyFJZGVuVHJ1c3QgUHVibGljIFNlY3RvciBSb290IENBIDEwggIi
  MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC2IpT8pEiv6EdrCvsnduTyP4o7
  ekosMSqMjbCpwzFrqHd2hCa2rIFCDQjrVVi7evi8ZX3yoG2LqEfpYnYeEe4IFNGy
  RBb06tD6Hi9e28tzQa68ALBKK0CyrOE7S8ItneShm+waOh7wCLPQ5CQ1B5+ctMlS
  bdsHyo+1W/CD80/HLaXIrcuVIKQxKFdYWuSNG5qrng0M8gozOSI5Cpcu81N3uURF
  /YTLNiCBWS2ab21ISGHKTN9T0a9SvESfqy9rg3LvdYDaBjMbXcjaY8ZNzaxmMc3R
  3j6HEDbhuaR672BQssvKplbgN6+rNBM5Jeg5ZuSYeqoSmJxZZoY+rfGwyj4GD3vw
  EUs3oERte8uojHH01bWRNszwFcYr3lEXsZdMUD2xlVl8BX0tIdUAvwFnol57plzy
  9yLxkA2T26pEUWbMfXYD62qoKjgZl3YNa4ph+bz27nb9cCvdKTz4Ch5bQhyLVi9V
  GxyhLrXHFub4qjySjmm2AcG1hp2JDws4lFTo6tyePSW8Uybt1as5qsVATFSrsrTZ
  2fjXctscvG29ZV/viDUqZi/u9rNl8DONfJhBaUYPQxxp+pu10GFqzcpL2UyQRqsV
  WaFHVCkugyhfHMKiq3IXAAaOReyL4jM9f9oZRORicsPfIsbyVtTdX5Vy7W1f90gD
  W/3FKqD2cyOEEBsB5wIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/
  BAUwAwEB/zAdBgNVHQ4EFgQU43HgntinQtnbcZFrlJPrw6PRFKMwDQYJKoZIhvcN
  AQELBQADggIBAEf63QqwEZE4rU1d9+UOl1QZgkiHVIyqZJnYWv6IAcVYpZmxI1Qj
  t2odIFflAWJBF9MJ23XLblSQdf4an4EKwt3X9wnQW3IV5B4Jaj0z8yGa5hV+rVHV
  DRDtfULAj+7AmgjVQdZcDiFpboBhDhXAuM/FSRJSzL46zNQuOAXeNf0fb7iAaJg9
  TaDKQGXSc3z1i9kKlT/YPyNtGtEqJBnZhbMX73huqVjRI9PHE+1yJX9dsXNw0H8G
  lwmEKYBhHfpe/3OsoOOJuBxxFcbeMX8S3OFtm6/n6J91eEyrRjuazr8FGF1NFTwW
  mhlQBJqymm9li1JfPFgEKCXAZmExfrngdbkaqIHWchezxQMxNRF4eKLg6TCMf4Df
  WN88uieW4oA0beOY02QnrEh+KHdcxiVhJfiFDGX6xDIvpZgF5PgLZxYWxoK4Mhn5
  +bl53B/N66+rDt0b20XkeucC4pVd/GnwU2lhlXV5C15V5jgclKlZM57IcXR5f1GJ
  tshquDDIajjDbp7hNxbqBWJMWxJH7ae0s1hWx0nzfxJoCTFx8G34Tkf71oXuxVhA
  GaQdp/lLQzfcaFpPz+vCZHTetBXZ9FRUGi8c15dxVJCO2SCdUyt/q4/i6jC8UDfv
  8Ue1fXwsBOxonbRJRBD0ckscZOf85muQ3Wl9af0AVqW3rLatt8o+Ae+c
  -----END CERTIFICATE-----

  ### Internet Security Research Group

  === /C=US/O=Internet Security Research Group/CN=ISRG Root X1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              82:10:cf:b0:d2:40:e3:59:44:63:e0:bb:63:82:8b:00
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jun  4 11:04:38 2015 GMT
              Not After : Jun  4 11:04:38 2035 GMT
          Subject: C=US, O=Internet Security Research Group, CN=ISRG Root X1
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  79:B4:59:E6:7B:B6:E5:E4:01:73:80:08:88:C8:1A:58:F6:E9:9B:6E
  SHA1 Fingerprint=CA:BD:2A:79:A1:07:6A:31:F2:1D:25:36:35:CB:03:9D:43:29:A5:E8
  SHA256 Fingerprint=96:BC:EC:06:26:49:76:F3:74:60:77:9A:CF:28:C5:A7:CF:E8:A3:C0:AA:E1:1A:8F:FC:EE:05:C0:BD:DF:08:C6
  -----BEGIN CERTIFICATE-----
  MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw
  TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh
  cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4
  WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu
  ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY
  MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc
  h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+
  0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U
  A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW
  T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH
  B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC
  B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv
  KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn
  OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn
  jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw
  qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI
  rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
  HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq
  hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL
  ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ
  3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK
  NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5
  ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur
  TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC
  jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc
  oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq
  4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA
  mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d
  emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=
  -----END CERTIFICATE-----

  ### IZENPE S.A.

  === /C=ES/O=IZENPE S.A./CN=Izenpe.com
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              b0:b7:5a:16:48:5f:bf:e1:cb:f5:8b:d7:19:e6:7d
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Dec 13 13:08:28 2007 GMT
              Not After : Dec 13 08:27:25 2037 GMT
          Subject: C=ES, O=IZENPE S.A., CN=Izenpe.com
          X509v3 extensions:
              X509v3 Subject Alternative Name:
                  email:info@izenpe.com, DirName:/O=IZENPE S.A. - CIF A01337260-RMerc.Vitoria-Gasteiz T1055 F62 S8/street=Avda del Mediterraneo Etorbidea 14 - 01010 Vitoria-Gasteiz
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  1D:1C:65:0E:A8:F2:25:7B:B4:91:CF:E4:B1:B1:E6:BD:55:74:6C:05
  SHA1 Fingerprint=2F:78:3D:25:52:18:A7:4A:65:39:71:B5:2C:A2:9C:45:15:6F:E9:19
  SHA256 Fingerprint=25:30:CC:8E:98:32:15:02:BA:D9:6F:9B:1F:BA:1B:09:9E:2D:29:9E:0F:45:48:BB:91:4F:36:3B:C0:D4:53:1F
  -----BEGIN CERTIFICATE-----
  MIIF8TCCA9mgAwIBAgIQALC3WhZIX7/hy/WL1xnmfTANBgkqhkiG9w0BAQsFADA4
  MQswCQYDVQQGEwJFUzEUMBIGA1UECgwLSVpFTlBFIFMuQS4xEzARBgNVBAMMCkl6
  ZW5wZS5jb20wHhcNMDcxMjEzMTMwODI4WhcNMzcxMjEzMDgyNzI1WjA4MQswCQYD
  VQQGEwJFUzEUMBIGA1UECgwLSVpFTlBFIFMuQS4xEzARBgNVBAMMCkl6ZW5wZS5j
  b20wggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDJ03rKDx6sp4boFmVq
  scIbRTJxldn+EFvMr+eleQGPicPK8lVx93e+d5TzcqQsRNiekpsUOqHnJJAKClaO
  xdgmlOHZSOEtPtoKct2jmRXagaKH9HtuJneJWK3W6wyyQXpzbm3benhB6QiIEn6H
  LmYRY2xU+zydcsC8Lv/Ct90NduM61/e0aL6i9eOBbsFGb12N4E3GVFWJGjMxCrFX
  uaOKmMPsOzTFlUFpfnXCPCDFYbpRR6AgkJOhkEvzTnyFRVSa0QUmQbC1TR0zvsQD
  yCV8wXDbO/QJLVQnSKwv4cSsPsjLkkxTOTcj7NMB+eAJRE1NZMDhDVqHIrytG6P+
  JrUV86f8hBnp7KGItERphIPzidF0BqnMC9bC3ieFUCbKF7jJeodWLBoBHmy+E60Q
  rLUk9TiRodZL2vG70t5HtfG8gfZZa88ZU+mNFctKy6lvROUbQc/hhqfK0GqfvEyN
  BjNaooXlkDWgYlwWTvDjovoDGrQscbNYLN57C9saD+veIR8GdwYDsMnvmfzAuU8L
  hij+0rnq49qlw0dpEuDb8PYZi+17cNcC1u2HGCgsBCRMd+RIihrGO5rUD8r6ddIB
  QFqNeb+Lz0vPqhbBleStTIo+F5HUsWLlguWABKQDfo2/2n+iD5dPDNMN+9fR5XJ+
  HMh3/1uaD7euBUbl8agW7EekFwIDAQABo4H2MIHzMIGwBgNVHREEgagwgaWBD2lu
  Zm9AaXplbnBlLmNvbaSBkTCBjjFHMEUGA1UECgw+SVpFTlBFIFMuQS4gLSBDSUYg
  QTAxMzM3MjYwLVJNZXJjLlZpdG9yaWEtR2FzdGVpeiBUMTA1NSBGNjIgUzgxQzBB
  BgNVBAkMOkF2ZGEgZGVsIE1lZGl0ZXJyYW5lbyBFdG9yYmlkZWEgMTQgLSAwMTAx
  MCBWaXRvcmlhLUdhc3RlaXowDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC
  AQYwHQYDVR0OBBYEFB0cZQ6o8iV7tJHP5LGx5r1VdGwFMA0GCSqGSIb3DQEBCwUA
  A4ICAQB4pgwWSp9MiDrAyw6lFn2fuUhfGI8NYjb2zRlrrKvV9pF9rnHzP7MOeIWb
  laQnIUdCSnxIOvVFfLMMjlF4rJUT3sb9fbgakEyrkgPH7UIBzg/YsfqikuFgba56
  awmqxinuaElnMIAkejEWOVt+8Rwu3WwJrfIxwYJOubv5vr8qhT/AQKM6WfxZSzwo
  JNu0FXWuDYi6LnPAvViH5ULy617uHjAimcs30cQhbIHsvm0m5hzkQiCeR7Csg1lw
  LDXWrzY0tM07+DKo7+N4ifuNRSzanLh+QBxh5z6ikixL8s36mLYp//Pye6kfLqCT
  VyvehQP5aTfLnnhqBbTFMXiJ7HqnheG5ezzevh55hM6fcA5ZwjUukCox2eRFekGk
  LhObNA5me0mrZJfQRsN5nXJQY6aYWwa9SG3YOYNw6DXwBdGqvOPbyALqfP2C2sJb
  UjWumDqtujWTI6cfSN01RpiyEGjkpTHCClguGYEQyVB1/OpaFs4R1+7vUIgtYf8/
  QnMFlEPVjjxOAToZpR9GTnfQXeWBIiGH/pR9hNiTrdZoQ0iy2+tzJOeRf1SktoA+
  naM8THLCV8Sg1Mw4J87VBp6iSNnpn86CcDaTmjvfliHjWbcM2pE38P1ZWrOZyGls
  QyYBNWNgVYkDOnXYukrZVP/u3oDYLdE41V4tC5h9Pmzb/CaIxw==
  -----END CERTIFICATE-----

  ### Japan Certification Services, Inc.

  === /C=JP/O=Japan Certification Services, Inc./CN=SecureSign RootCA11
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 1 (0x1)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Apr  8 04:56:47 2009 GMT
              Not After : Apr  8 04:56:47 2029 GMT
          Subject: C=JP, O=Japan Certification Services, Inc., CN=SecureSign RootCA11
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  5B:F8:4D:4F:B2:A5:86:D4:3A:D2:F1:63:9A:A0:BE:09:F6:57:B7:DE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=3B:C4:9F:48:F8:F3:73:A0:9C:1E:BD:F8:5B:B1:C3:65:C7:D8:11:B3
  SHA256 Fingerprint=BF:0F:EE:FB:9E:3A:58:1A:D5:F9:E9:DB:75:89:98:57:43:D2:61:08:5C:4D:31:4F:6F:5D:72:59:AA:42:16:12
  -----BEGIN CERTIFICATE-----
  MIIDbTCCAlWgAwIBAgIBATANBgkqhkiG9w0BAQUFADBYMQswCQYDVQQGEwJKUDEr
  MCkGA1UEChMiSmFwYW4gQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcywgSW5jLjEcMBoG
  A1UEAxMTU2VjdXJlU2lnbiBSb290Q0ExMTAeFw0wOTA0MDgwNDU2NDdaFw0yOTA0
  MDgwNDU2NDdaMFgxCzAJBgNVBAYTAkpQMSswKQYDVQQKEyJKYXBhbiBDZXJ0aWZp
  Y2F0aW9uIFNlcnZpY2VzLCBJbmMuMRwwGgYDVQQDExNTZWN1cmVTaWduIFJvb3RD
  QTExMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA/XeqpRyQBTvLTJsz
  i1oURaTnkBbR31fSIRCkF/3frNYfp+TbfPfs37gD2pRY/V1yfIw/XwFndBWW4wI8
  h9uuywGOwvNmxoVF9ALGOrVisq/6nL+k5tSAMJjzDbaTj6nU2DbysPyKyiyhFTOV
  MdrAG/LuYpmGYz+/3ZMqg6h2uRMft85OQoWPIucuGvKVCbIFtUROd6EgvanyTgp9
  UK31BQ1FT0Zx/Sg+U/sE2C3XZR1KG/rPO7AxmjVuyIsG0wCR8pQIZUyxNAYAeoni
  8McDWc/V1uinMrPmmECGxc0nEovMe863ETxiYAcjPitAbpSACW22s293bzUIUPsC
  h8U+iQIDAQABo0IwQDAdBgNVHQ4EFgQUW/hNT7KlhtQ60vFjmqC+CfZXt94wDgYD
  VR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEB
  AKChOBZmLqdWHyGcBvod7bkixTgm2E5P7KN/ed5GIaGHd48HCJqypMWvDzKYC3xm
  KbabfSVSSUOrTC4rbnpwrxYO4wJs+0LmGJ1F2FXI6Dvd5+H0LgscNFxsWEr7jIhQ
  X5Ucv+2rIrVls4W6ng+4reV6G4pQOh29Dbx7VFALuUKvVaAYga1lme++5Jy/xIWr
  QbJUb9wlze144o4MjQlJ3WN7WmmWAiGovVJZ6X01y8hSyn+B/tlr0/cR7SXf+Of5
  pPpyl4RTDaXQMhhRdlkUbA/r7F+AjHVDg8OFmP9Mni0N5HeDk061lgeLKBObjBmN
  QSdJQO7e5iNEOdyhIta6A/I=
  -----END CERTIFICATE-----

  ### Krajowa Izba Rozliczeniowa S.A.

  === /C=PL/O=Krajowa Izba Rozliczeniowa S.A./CN=SZAFIR ROOT CA2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              3e:8a:5d:07:ec:55:d2:32:d5:b7:e3:b6:5f:01:eb:2d:dc:e4:d6:e4
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Oct 19 07:43:30 2015 GMT
              Not After : Oct 19 07:43:30 2035 GMT
          Subject: C=PL, O=Krajowa Izba Rozliczeniowa S.A., CN=SZAFIR ROOT CA2
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  2E:16:A9:4A:18:B5:CB:CC:F5:6F:50:F3:23:5F:F8:5D:E7:AC:F0:C8
  SHA1 Fingerprint=E2:52:FA:95:3F:ED:DB:24:60:BD:6E:28:F3:9C:CC:CF:5E:B3:3F:DE
  SHA256 Fingerprint=A1:33:9D:33:28:1A:0B:56:E5:57:D3:D3:2B:1C:E7:F9:36:7E:B0:94:BD:5F:A7:2A:7E:50:04:C8:DE:D7:CA:FE
  -----BEGIN CERTIFICATE-----
  MIIDcjCCAlqgAwIBAgIUPopdB+xV0jLVt+O2XwHrLdzk1uQwDQYJKoZIhvcNAQEL
  BQAwUTELMAkGA1UEBhMCUEwxKDAmBgNVBAoMH0tyYWpvd2EgSXpiYSBSb3psaWN6
  ZW5pb3dhIFMuQS4xGDAWBgNVBAMMD1NaQUZJUiBST09UIENBMjAeFw0xNTEwMTkw
  NzQzMzBaFw0zNTEwMTkwNzQzMzBaMFExCzAJBgNVBAYTAlBMMSgwJgYDVQQKDB9L
  cmFqb3dhIEl6YmEgUm96bGljemVuaW93YSBTLkEuMRgwFgYDVQQDDA9TWkFGSVIg
  Uk9PVCBDQTIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC3vD5QqEvN
  QLXOYeeWyrSh2gwisPq1e3YAd4wLz32ohswmUeQgPYUM1ljj5/QqGJ3a0a4m7utT
  3PSQ1hNKDJA8w/Ta0o4NkjrcsbH/ON7Dui1fgLkCvUqdGw+0w8LBZwPd3BucPbOw
  3gAeqDRHu5rr/gsUvTaE2g0gv/pby6kWIK05YO4vdbbnl5z5Pv1+TW9NL++IDWr6
  3fE9biCloBK0TXC5ztdyO4mTp4CEHCdJckm1/zuVnsHMyAHs6A6KCpbns6aH5db5
  BSsNl0BwPLqsdVqc1U2dAgrSS5tmS0YHF2Wtn2yIANwiieDhZNRnvDF5YTy7ykHN
  XGoAyDw4jlivAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQD
  AgEGMB0GA1UdDgQWBBQuFqlKGLXLzPVvUPMjX/hd56zwyDANBgkqhkiG9w0BAQsF
  AAOCAQEAtXP4A9xZWx126aMqe5Aosk3AM0+qmrHUuOQn/6mWmc5G4G18TKI4pAZw
  8PRBEew/R40/cof5O/2kbytTAOD/OblqBw7rHRz2onKQy4I9EYKL0rufKq8h5mOG
  nXkZ7/e7DDWQw4rtTw/1zBLZpD67oPwglV9PJi8RI4NOdQcPv5vRtB3pEAT+ymCP
  oky4rc/hkA/NrgrHXXu3UNLUYfrVFdvXn4dRVOul4+vJhaAlIDf7js4MNIThPIGy
  d05DpYhfhmehPea0XGG2Ptv+tyjFogeutcrKjSoS75ftwjCkySp6+/NNIxuZMzSg
  LvWpCz/UXeHPhJ/iGcJfitYgHuNztw==
  -----END CERTIFICATE-----

  ### Microsec Ltd.

  === /C=HU/L=Budapest/O=Microsec Ltd./2.5.4.97=VATHU-23584497/CN=e-Szigno Root CA 2017
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              01:54:48:ef:21:fd:97:59:0d:f5:04:0a
      Signature Algorithm: ecdsa-with-SHA256
          Validity
              Not Before: Aug 22 12:07:06 2017 GMT
              Not After : Aug 22 12:07:06 2042 GMT
          Subject: C=HU, L=Budapest, O=Microsec Ltd./2.5.4.97=VATHU-23584497, CN=e-Szigno Root CA 2017
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  87:11:15:08:D1:AA:C1:78:0C:B1:AF:CE:C6:C9:90:EF:BF:30:04:C0
              X509v3 Authority Key Identifier:
                  keyid:87:11:15:08:D1:AA:C1:78:0C:B1:AF:CE:C6:C9:90:EF:BF:30:04:C0

  SHA1 Fingerprint=89:D4:83:03:4F:9E:9A:48:80:5F:72:37:D4:A9:A6:EF:CB:7C:1F:D1
  SHA256 Fingerprint=BE:B0:0B:30:83:9B:9B:C3:2C:32:E4:44:79:05:95:06:41:F2:64:21:B1:5E:D0:89:19:8B:51:8A:E2:EA:1B:99
  -----BEGIN CERTIFICATE-----
  MIICQDCCAeWgAwIBAgIMAVRI7yH9l1kN9QQKMAoGCCqGSM49BAMCMHExCzAJBgNV
  BAYTAkhVMREwDwYDVQQHDAhCdWRhcGVzdDEWMBQGA1UECgwNTWljcm9zZWMgTHRk
  LjEXMBUGA1UEYQwOVkFUSFUtMjM1ODQ0OTcxHjAcBgNVBAMMFWUtU3ppZ25vIFJv
  b3QgQ0EgMjAxNzAeFw0xNzA4MjIxMjA3MDZaFw00MjA4MjIxMjA3MDZaMHExCzAJ
  BgNVBAYTAkhVMREwDwYDVQQHDAhCdWRhcGVzdDEWMBQGA1UECgwNTWljcm9zZWMg
  THRkLjEXMBUGA1UEYQwOVkFUSFUtMjM1ODQ0OTcxHjAcBgNVBAMMFWUtU3ppZ25v
  IFJvb3QgQ0EgMjAxNzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABJbcPYrYsHtv
  xie+RJCxs1YVe45DJH0ahFnuY2iyxl6H0BVIHqiQrb1TotreOpCmYF9oMrWGQd+H
  Wyx7xf58etqjYzBhMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0G
  A1UdDgQWBBSHERUI0arBeAyxr87GyZDvvzAEwDAfBgNVHSMEGDAWgBSHERUI0arB
  eAyxr87GyZDvvzAEwDAKBggqhkjOPQQDAgNJADBGAiEAtVfd14pVCzbhhkT61Nlo
  jbjcI4qKDdQvfepz7L9NbKgCIQDLpbQS+ue16M9+k/zzNY9vTlp8tLxOsvxyqltZ
  +efcMQ==
  -----END CERTIFICATE-----
  === /C=HU/L=Budapest/O=Microsec Ltd./CN=Microsec e-Szigno Root CA 2009/emailAddress=info@e-szigno.hu
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              c2:7e:43:04:4e:47:3f:19
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jun 16 11:30:18 2009 GMT
              Not After : Dec 30 11:30:18 2029 GMT
          Subject: C=HU, L=Budapest, O=Microsec Ltd., CN=Microsec e-Szigno Root CA 2009/emailAddress=info@e-szigno.hu
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  CB:0F:C6:DF:42:43:CC:3D:CB:B5:48:23:A1:1A:7A:A6:2A:BB:34:68
              X509v3 Authority Key Identifier:
                  keyid:CB:0F:C6:DF:42:43:CC:3D:CB:B5:48:23:A1:1A:7A:A6:2A:BB:34:68

              X509v3 Subject Alternative Name:
                  email:info@e-szigno.hu
  SHA1 Fingerprint=89:DF:74:FE:5C:F4:0F:4A:80:F9:E3:37:7D:54:DA:91:E1:01:31:8E
  SHA256 Fingerprint=3C:5F:81:FE:A5:FA:B8:2C:64:BF:A2:EA:EC:AF:CD:E8:E0:77:FC:86:20:A7:CA:E5:37:16:3D:F3:6E:DB:F3:78
  -----BEGIN CERTIFICATE-----
  MIIECjCCAvKgAwIBAgIJAMJ+QwRORz8ZMA0GCSqGSIb3DQEBCwUAMIGCMQswCQYD
  VQQGEwJIVTERMA8GA1UEBwwIQnVkYXBlc3QxFjAUBgNVBAoMDU1pY3Jvc2VjIEx0
  ZC4xJzAlBgNVBAMMHk1pY3Jvc2VjIGUtU3ppZ25vIFJvb3QgQ0EgMjAwOTEfMB0G
  CSqGSIb3DQEJARYQaW5mb0BlLXN6aWduby5odTAeFw0wOTA2MTYxMTMwMThaFw0y
  OTEyMzAxMTMwMThaMIGCMQswCQYDVQQGEwJIVTERMA8GA1UEBwwIQnVkYXBlc3Qx
  FjAUBgNVBAoMDU1pY3Jvc2VjIEx0ZC4xJzAlBgNVBAMMHk1pY3Jvc2VjIGUtU3pp
  Z25vIFJvb3QgQ0EgMjAwOTEfMB0GCSqGSIb3DQEJARYQaW5mb0BlLXN6aWduby5o
  dTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOn4j/NjrdqG2KfgQvvP
  kd6mJviZpWNwrZuuyjNAfW2WbqEORO7hE52UQlKavXWFdCyoDh2Tthi3jCyoz/tc
  cbna7P7ofo/kLx2yqHWH2Leh5TvPmUpG0IMZfcChEhyVbUr02MelTTMuhTlAdX4U
  fIASmFDHQWe4oIBhVKZsTh/gnQ4H6cm6M+f+wFUoLAKApxn1ntxVUwOXewdI/5n7
  N4okxFnMUBBjjqqpGrCEGob5X7uxUG6k0QrM1XF+H6cbfPVTbiJfyyvm1HxdrtbC
  xkzlBQHZ7Vf8wSN5/PrIJIOV87VqUQHQd9bpEqH5GoP7ghu5sJf0dgYzQ0mg/wu1
  +rUCAwEAAaOBgDB+MA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0G
  A1UdDgQWBBTLD8bfQkPMPcu1SCOhGnqmKrs0aDAfBgNVHSMEGDAWgBTLD8bfQkPM
  Pcu1SCOhGnqmKrs0aDAbBgNVHREEFDASgRBpbmZvQGUtc3ppZ25vLmh1MA0GCSqG
  SIb3DQEBCwUAA4IBAQDJ0Q5eLtXMs3w+y/w9/w0olZMEyL/azXm4Q5DwpL7v8u8h
  mLzU1F0G9u5C7DBsoKqpyvGvivo/C3NqPuouQH4frlRheesuCDfXI/OMn74dseGk
  ddug4lQUsbocKaQY9hK6ohQU4zE1yED/t+AFdlfBHFny+L/k7SViXITwfn4fs775
  tyERzAMBVnCnEJIeGzSBHq2cGsMEPO0CYdYeBvNfOofyK/FFh+U9rNHHV4S9a67c
  2Pm2G2JwCz02yULyMtd6YebS2z3PyKnJm9zbWETXbzivf3jTo60adbocwTZ8jx5t
  HMN1Rq41Bab2XD0h7lbwyYIiLXpUq3DDfSJlgnCW
  -----END CERTIFICATE-----

  ### Microsoft Corporation

  === /C=US/O=Microsoft Corporation/CN=Microsoft ECC Root Certificate Authority 2017
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              66:f2:3d:af:87:de:8b:b1:4a:ea:0c:57:31:01:c2:ec
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Dec 18 23:06:45 2019 GMT
              Not After : Jul 18 23:16:04 2042 GMT
          Subject: C=US, O=Microsoft Corporation, CN=Microsoft ECC Root Certificate Authority 2017
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  C8:CB:99:72:70:52:0C:F8:E6:BE:B2:04:57:29:2A:CF:42:10:ED:35
              1.3.6.1.4.1.311.21.1:
                  ...
  SHA1 Fingerprint=99:9A:64:C3:7F:F4:7D:9F:AB:95:F1:47:69:89:14:60:EE:C4:C3:C5
  SHA256 Fingerprint=35:8D:F3:9D:76:4A:F9:E1:B7:66:E9:C9:72:DF:35:2E:E1:5C:FA:C2:27:AF:6A:D1:D7:0E:8E:4A:6E:DC:BA:02
  -----BEGIN CERTIFICATE-----
  MIICWTCCAd+gAwIBAgIQZvI9r4fei7FK6gxXMQHC7DAKBggqhkjOPQQDAzBlMQsw
  CQYDVQQGEwJVUzEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMTYwNAYD
  VQQDEy1NaWNyb3NvZnQgRUNDIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IDIw
  MTcwHhcNMTkxMjE4MjMwNjQ1WhcNNDIwNzE4MjMxNjA0WjBlMQswCQYDVQQGEwJV
  UzEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMTYwNAYDVQQDEy1NaWNy
  b3NvZnQgRUNDIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IDIwMTcwdjAQBgcq
  hkjOPQIBBgUrgQQAIgNiAATUvD0CQnVBEyPNgASGAlEvaqiBYgtlzPbKnR5vSmZR
  ogPZnZH6thaxjG7efM3beaYvzrvOcS/lpaso7GMEZpn4+vKTEAXhgShC48Zo9OYb
  hGBKia/teQ87zvH2RPUBeMCjVDBSMA4GA1UdDwEB/wQEAwIBhjAPBgNVHRMBAf8E
  BTADAQH/MB0GA1UdDgQWBBTIy5lycFIM+Oa+sgRXKSrPQhDtNTAQBgkrBgEEAYI3
  FQEEAwIBADAKBggqhkjOPQQDAwNoADBlAjBY8k3qDPlfXu5gKcs68tvWMoQZP3zV
  L8KxzJOuULsJMsbG7X7JNpQS5GiFBqIb0C8CMQCZ6Ra0DvpWSNSkMBaReNtUjGUB
  iudQZsIxtzm6uBoiB078a1QWIP8rtedMDE2mT3M=
  -----END CERTIFICATE-----
  === /C=US/O=Microsoft Corporation/CN=Microsoft RSA Root Certificate Authority 2017
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              1e:d3:97:09:5f:d8:b4:b3:47:70:1e:aa:be:7f:45:b3
      Signature Algorithm: sha384WithRSAEncryption
          Validity
              Not Before: Dec 18 22:51:22 2019 GMT
              Not After : Jul 18 23:00:23 2042 GMT
          Subject: C=US, O=Microsoft Corporation, CN=Microsoft RSA Root Certificate Authority 2017
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  09:CB:59:7F:86:B2:70:8F:1A:C3:39:E3:C0:D9:E9:BF:BB:4D:B2:23
              1.3.6.1.4.1.311.21.1:
                  ...
  SHA1 Fingerprint=73:A5:E6:4A:3B:FF:83:16:FF:0E:DC:CC:61:8A:90:6E:4E:AE:4D:74
  SHA256 Fingerprint=C7:41:F7:0F:4B:2A:8D:88:BF:2E:71:C1:41:22:EF:53:EF:10:EB:A0:CF:A5:E6:4C:FA:20:F4:18:85:30:73:E0
  -----BEGIN CERTIFICATE-----
  MIIFqDCCA5CgAwIBAgIQHtOXCV/YtLNHcB6qvn9FszANBgkqhkiG9w0BAQwFADBl
  MQswCQYDVQQGEwJVUzEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMTYw
  NAYDVQQDEy1NaWNyb3NvZnQgUlNBIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5
  IDIwMTcwHhcNMTkxMjE4MjI1MTIyWhcNNDIwNzE4MjMwMDIzWjBlMQswCQYDVQQG
  EwJVUzEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMTYwNAYDVQQDEy1N
  aWNyb3NvZnQgUlNBIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IDIwMTcwggIi
  MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDKW76UM4wplZEWCpW9R2LBifOZ
  Nt9GkMml7Xhqb0eRaPgnZ1AzHaGm++DlQ6OEAlcBXZxIQIJTELy/xztokLaCLeX0
  ZdDMbRnMlfl7rEqUrQ7eS0MdhweSE5CAg2Q1OQT85elss7YfUJQ4ZVBcF0a5toW1
  HLUX6NZFndiyJrDKxHBKrmCk3bPZ7Pw71VdyvD/IybLeS2v4I2wDwAW9lcfNcztm
  gGTjGqwu+UcF8ga2m3P1eDNbx6H7JyqhtJqRjJHTOoI+dkC0zVJhUXAoP8XFWvLJ
  jEm7FFtNyP9nTUwSlq31/niol4fX/V4ggNyhSyL71Imtus5Hl0dVe49FyGcohJUc
  aDDv70ngNXtk55iwlNpNhTs+VcQor1fznhPbRiefHqJeRIOkpcrVE7NLP8TjwuaG
  YaRSMLl6IE9vDzhTyzMMEyuP1pq9KsgtsRx9S1HKR9FIJ3Jdh+vVReZIZZ2vUpC6
  W6IYZVcSn2i51BVrlMRpIpj0M+Dt+VGOQVDJNE92kKz8OMHY4Xu54+OU4UZpyw4K
  UGsTuqwPN1q3ErWQgR5WrlcihtnJ0tHXUeOrO8ZV/R4O03QK0dqq6mm4lyiPSMQH
  +FJDOvTKVTUssKZqwJz58oHhEmrARdlns87/I6KJClTUFLkqqNfs+avNJVgyeY+Q
  W5g5xAgGwax/Dj0ApQIDAQABo1QwUjAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/
  BAUwAwEB/zAdBgNVHQ4EFgQUCctZf4aycI8awznjwNnpv7tNsiMwEAYJKwYBBAGC
  NxUBBAMCAQAwDQYJKoZIhvcNAQEMBQADggIBAKyvPl3CEZaJjqPnktaXFbgToqZC
  LgLNFgVZJ8og6Lq46BrsTaiXVq5lQ7GPAJtSzVXNUzltYkyLDVt8LkS/gxCP81OC
  gMNPOsduET/m4xaRhPtthH80dK2Jp86519efhGSSvpWhrQlTM93uCupKUY5vVau6
  tZRGrox/2KJQJWVggEbbMwSubLWYdFQl3JPk+ONVFT24bcMKpBLBaYVu32TxU5nh
  SnUgnZUP5NbcA/FZGOhHibJXWpS2qdgXKxdJ5XbLwVaZOjex/2kskZGT4d9Mozd2
  TaGf+G0eHdP67Pv0RR0Tbc/3WeUiJ3IrhvNXuzDtJE3cfVa7o7P4NHmJweDyAmH3
  pvwPuxwXC65B2Xy9J6P9LjrRk5Sxcx0ki69bIImtt2dmefU6xqaWM/5TkshGsRGR
  xpl/j8nWZjEgQRCHLQzWwa80mMpkg/sTV9HB8Dx6jKXB/ZUhoHHBk2dxEuqPiApp
  GWSZI1b7rCoucL5mxAyE7+WL85MB+GqQk2dLsmijtWKP6T+MejteD+eMuMZ87zf9
  dOLITzNy4ZQ5bb0Sr74MTnB8G2+NszKTc0QWbej09+CVgI+WXTik9KveCjCHk9hN
  AHFiRSdLOkKEW39lt2c0Ui2cFmuqqNh7o0JMcccMyj6D5KbvtwEwXlGjefVwaaZB
  RA+GsCyRxj3qrg+E
  -----END CERTIFICATE-----

  ### NAVER BUSINESS PLATFORM Corp.

  === /C=KR/O=NAVER BUSINESS PLATFORM Corp./CN=NAVER Global Root Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              01:94:30:1e:a2:0b:dd:f5:c5:33:2a:b1:43:44:71:f8:d6:50:4d:0d
      Signature Algorithm: sha384WithRSAEncryption
          Validity
              Not Before: Aug 18 08:58:42 2017 GMT
              Not After : Aug 18 23:59:59 2037 GMT
          Subject: C=KR, O=NAVER BUSINESS PLATFORM Corp., CN=NAVER Global Root Certification Authority
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  D2:9F:88:DF:A1:CD:2C:BD:EC:F5:3B:01:01:93:33:27:B2:EB:60:4B
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=8F:6B:F2:A9:27:4A:DA:14:A0:C4:F4:8E:61:27:F9:C0:1E:78:5D:D1
  SHA256 Fingerprint=88:F4:38:DC:F8:FF:D1:FA:8F:42:91:15:FF:E5:F8:2A:E1:E0:6E:0C:70:C3:75:FA:AD:71:7B:34:A4:9E:72:65
  -----BEGIN CERTIFICATE-----
  MIIFojCCA4qgAwIBAgIUAZQwHqIL3fXFMyqxQ0Rx+NZQTQ0wDQYJKoZIhvcNAQEM
  BQAwaTELMAkGA1UEBhMCS1IxJjAkBgNVBAoMHU5BVkVSIEJVU0lORVNTIFBMQVRG
  T1JNIENvcnAuMTIwMAYDVQQDDClOQVZFUiBHbG9iYWwgUm9vdCBDZXJ0aWZpY2F0
  aW9uIEF1dGhvcml0eTAeFw0xNzA4MTgwODU4NDJaFw0zNzA4MTgyMzU5NTlaMGkx
  CzAJBgNVBAYTAktSMSYwJAYDVQQKDB1OQVZFUiBCVVNJTkVTUyBQTEFURk9STSBD
  b3JwLjEyMDAGA1UEAwwpTkFWRVIgR2xvYmFsIFJvb3QgQ2VydGlmaWNhdGlvbiBB
  dXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC21PGTXLVA
  iQqrDZBbUGOukJR0F0Vy1ntlWilLp1agS7gvQnXp2XskWjFlqxcX0TM62RHcQDaH
  38dq6SZeWYp34+hInDEW+j6RscrJo+KfziFTowI2MMtSAuXaMl3Dxeb57hHHi8lE
  HoSTGEq0n+USZGnQJoViAbbJAh2+g1G7XNr4rRVqmfeSVPc0W+m/6imBEtRTkZaz
  kVrd/pBzKPswRrXKCAfHcXLJZtM0l/aM9BhK4dA9WkW2aacp+yPOiNgSnABIqKYP
  szuSjXEOdMWLyEz59JuOuDxp7W87UC9Y7cSw0BwbagzivESq2M0UXZR4Yb8Obtoq
  vC8MC3GmsxY/nOb5zJ9TNeIDoKAYv7vxvvTWjIcNQvcGufFt7QSUqP620wbGQGHf
  nZ3zVHbOUzoBppJB7ASjjw2i1QnK1sua8e9DXcCrpUHPXFNwcMmIpi3Ua2FzUCaG
  YQ5fG8Ir4ozVu53BA0K6lNpfqbDKzE0K70dpAy8i+/Eozr9dUGWokG2zdLAIx6yo
  0es+nPxdGoMuK8u180SdOqcXYZaicdNwlhVNt0xz7hlcxVs+Qf6sdWA7G2POAN3a
  CJBitOUt7kinaxeZVL6HSuOpXgRM6xBtVNbv8ejyYhbLgGvtPe31HzClrkvJE+2K
  AQHJuFFYwGY6sWZLxNUxAmLpdIQM201GLQIDAQABo0IwQDAdBgNVHQ4EFgQU0p+I
  36HNLL3s9TsBAZMzJ7LrYEswDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMB
  Af8wDQYJKoZIhvcNAQEMBQADggIBADLKgLOdPVQG3dLSLvCkASELZ0jKbY7gyKoN
  qo0hV4/GPnrK21HUUrPUloSlWGB/5QuOH/XcChWB5Tu2tyIvCZwTFrFsDDUIbatj
  cu3cvuzHV+YwIHHW1xDBE1UBjCpD5EHxzzp6U5LOogMFDTjfArsQLtk70pt6wKGm
  +LUx5vR1yblTmXVHIloUFcd4G7ad6Qz4G3bxhYTeodoS76TiEJd6eN4MUZeoIUCL
  hr0N8F5OSza7OyAfikJW4Qsav3vQIkMsRIz75Sq0bBwcupTgE34h5prCy8VCZLQe
  lHsIJchxzIdFV4XTnyliIoNRlwAYl3dqmJLJfGBs32x9SuRwTMKeuB330DTHD8z7
  p/8Dvq1wkNoL3chtl1+afwkyQf3NosxabUzyqkn+Zvjp2DXrDige7kgvOtB5CTh8
  piKCk5XQA76+AqAF3SAi428diDRgxuYKuQl1C/AH6GmWNcf7I4GOODm4RStDeKLR
  LBT/DShycpWbXgnbiUSYqqFJu3FS8r/2/yehNq+4tneI3TqkbZs0kNwUXTC/t+sX
  5Ie3cdCh13cV1ELX8vMxmV2b3RZtP+oGI/hGoiLtk/bdmuYqh7GYVPEi92tF4+KO
  dh2ajcQGjTa3FPOdVGm3jjzVpG2Tgbet9r1ke8LJaDmgkpzNNIaRkPpkUZ3+/uul
  9XXeifdy
  -----END CERTIFICATE-----

  ### NetLock Kft.

  === /C=HU/L=Budapest/O=NetLock Kft./OU=Tan\xC3\xBAs\xC3\xADtv\xC3\xA1nykiad\xC3\xB3k (Certification Services)/CN=NetLock Arany (Class Gold) F\xC5\x91tan\xC3\xBAs\xC3\xADtv\xC3\xA1ny
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 80544274841616 (0x49412ce40010)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Dec 11 15:08:21 2008 GMT
              Not After : Dec  6 15:08:21 2028 GMT
          Subject: C=HU, L=Budapest, O=NetLock Kft., OU=Tan\xC3\xBAs\xC3\xADtv\xC3\xA1nykiad\xC3\xB3k (Certification Services), CN=NetLock Arany (Class Gold) F\xC5\x91tan\xC3\xBAs\xC3\xADtv\xC3\xA1ny
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE, pathlen:4
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  CC:FA:67:93:F0:B6:B8:D0:A5:C0:1E:F3:53:FD:8C:53:DF:83:D7:96
  SHA1 Fingerprint=06:08:3F:59:3F:15:A1:04:A0:69:A4:6B:A9:03:D0:06:B7:97:09:91
  SHA256 Fingerprint=6C:61:DA:C3:A2:DE:F0:31:50:6B:E0:36:D2:A6:FE:40:19:94:FB:D1:3D:F9:C8:D4:66:59:92:74:C4:46:EC:98
  -----BEGIN CERTIFICATE-----
  MIIEFTCCAv2gAwIBAgIGSUEs5AAQMA0GCSqGSIb3DQEBCwUAMIGnMQswCQYDVQQG
  EwJIVTERMA8GA1UEBwwIQnVkYXBlc3QxFTATBgNVBAoMDE5ldExvY2sgS2Z0LjE3
  MDUGA1UECwwuVGFuw7pzw610dsOhbnlraWFkw7NrIChDZXJ0aWZpY2F0aW9uIFNl
  cnZpY2VzKTE1MDMGA1UEAwwsTmV0TG9jayBBcmFueSAoQ2xhc3MgR29sZCkgRsWR
  dGFuw7pzw610dsOhbnkwHhcNMDgxMjExMTUwODIxWhcNMjgxMjA2MTUwODIxWjCB
  pzELMAkGA1UEBhMCSFUxETAPBgNVBAcMCEJ1ZGFwZXN0MRUwEwYDVQQKDAxOZXRM
  b2NrIEtmdC4xNzA1BgNVBAsMLlRhbsO6c8OtdHbDoW55a2lhZMOzayAoQ2VydGlm
  aWNhdGlvbiBTZXJ2aWNlcykxNTAzBgNVBAMMLE5ldExvY2sgQXJhbnkgKENsYXNz
  IEdvbGQpIEbFkXRhbsO6c8OtdHbDoW55MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
  MIIBCgKCAQEAxCRec75LbRTDofTjl5Bu0jBFHjzuZ9lk4BqKf8owyoPjIMHj9DrT
  lF8afFttvzBPhCf2nx9JvMaZCpDyD/V/Q4Q3Y1GLeqVw/HpYzY6b7cNGbIRwXdrz
  AZAj/E4wqX7hJ2Pn7WQ8oLjJM2P+FpD/sLj916jAwJRDC7bVWaaeVtAkH3B5r9s5
  VA1lddkVQZQBr17s9o3x/61k/iCa11zr/qYfCGSji3ZVrR47KGAuhyXoqq8fxmRG
  ILdwfzzeSNuWU7c5d+Qa4scWhHaXWy+7GRWF+GmF9ZmnqfI0p6m2pgP8b4Y9VHx2
  BJtr+UBdADTHLpl1neWIA6pN+APSQnbAGwIDAKiLo0UwQzASBgNVHRMBAf8ECDAG
  AQH/AgEEMA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUzPpnk/C2uNClwB7zU/2M
  U9+D15YwDQYJKoZIhvcNAQELBQADggEBAKt/7hwWqZw8UQCgwBEIBaeZ5m8BiFRh
  bvG5GK1Krf6BQCOUL/t1fC8oS2IkgYIL9WHxHG64YTjrgfpioTtaYtOUZcTh5m2C
  +C8lcLIhJsFyUR+MLMOEkMNaj7rP9KdlpeuY0fsFskZ1FSNqb4VjMIDw1Z4fKRzC
  bLBQWV2QWzuoDTDPv31/zvGdg73JRm4gpvlhUbohL3u+pRVjodSVh/GeufOJ8z2F
  uLjbvrW5KfnaNwUASZQDhETnv0Mxz3WLJdH0pmT1kvarBes96aULNmLazAZfNou2
  XjG4Kvte9nHfRCaexOYNkbQudZWAUWpLMKawYqGT8ZvYzsRjdT9ZR7E=
  -----END CERTIFICATE-----

  ### Network Solutions L.L.C.

  === /C=US/O=Network Solutions L.L.C./CN=Network Solutions Certificate Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              57:cb:33:6f:c2:5c:16:e6:47:16:17:e3:90:31:68:e0
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Dec  1 00:00:00 2006 GMT
              Not After : Dec 31 23:59:59 2029 GMT
          Subject: C=US, O=Network Solutions L.L.C., CN=Network Solutions Certificate Authority
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  21:30:C9:FB:00:D7:4E:98:DA:87:AA:2A:D0:A7:2E:B1:40:31:A7:4C
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 CRL Distribution Points:

                  Full Name:
                    URI:http://crl.netsolssl.com/NetworkSolutionsCertificateAuthority.crl

  SHA1 Fingerprint=74:F8:A3:C3:EF:E7:B3:90:06:4B:83:90:3C:21:64:60:20:E5:DF:CE
  SHA256 Fingerprint=15:F0:BA:00:A3:AC:7A:F3:AC:88:4C:07:2B:10:11:A0:77:BD:77:C0:97:F4:01:64:B2:F8:59:8A:BD:83:86:0C
  -----BEGIN CERTIFICATE-----
  MIID5jCCAs6gAwIBAgIQV8szb8JcFuZHFhfjkDFo4DANBgkqhkiG9w0BAQUFADBi
  MQswCQYDVQQGEwJVUzEhMB8GA1UEChMYTmV0d29yayBTb2x1dGlvbnMgTC5MLkMu
  MTAwLgYDVQQDEydOZXR3b3JrIFNvbHV0aW9ucyBDZXJ0aWZpY2F0ZSBBdXRob3Jp
  dHkwHhcNMDYxMjAxMDAwMDAwWhcNMjkxMjMxMjM1OTU5WjBiMQswCQYDVQQGEwJV
  UzEhMB8GA1UEChMYTmV0d29yayBTb2x1dGlvbnMgTC5MLkMuMTAwLgYDVQQDEydO
  ZXR3b3JrIFNvbHV0aW9ucyBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggEiMA0GCSqG
  SIb3DQEBAQUAA4IBDwAwggEKAoIBAQDkvH6SMG3G2I4rC7xGzuAnlt7e+foS0zwz
  c7MEL7xxjOWftiJgPl9dzgn/ggwbmlFQGiaJ3dVhXRncEg8tCqJDXRfQNJIg6nPP
  OCwGJgl6cvf6UDL4wpPTaaIjzkGxzOTVHzbRijr4jGPiFFlp7Q3Tf2vouAPlT2rl
  mGNpSAW+Lv8ztumXWWn4Zxmuk2GWRBXTcrA/vGp97Eh/jcOrqnErU2lBUzS1sLnF
  BgrEsEX1QV1uiUV7PTsmjHTC5dLRfbIR1PtYMiKagMnc/Qzpf14Dl847ABSHJ3A4
  qY5usyd2mFHgBeMhqxrVhSI8KbWaFsWAqPS7azCPL0YCorEMIuDTAgMBAAGjgZcw
  gZQwHQYDVR0OBBYEFCEwyfsA106Y2oeqKtCnLrFAMadMMA4GA1UdDwEB/wQEAwIB
  BjAPBgNVHRMBAf8EBTADAQH/MFIGA1UdHwRLMEkwR6BFoEOGQWh0dHA6Ly9jcmwu
  bmV0c29sc3NsLmNvbS9OZXR3b3JrU29sdXRpb25zQ2VydGlmaWNhdGVBdXRob3Jp
  dHkuY3JsMA0GCSqGSIb3DQEBBQUAA4IBAQC7rkvnt1frf6ott3NHhWrB5KUd5Oc8
  6fRZZXe1eltajSU24HqXLjjAV2CDmAaDn7l2em5Q4LqILPxFzBiwmZVRDuwduIj/
  h1AcgsLj4DKAv6ALR8jDMe+ZZzKATxcheQxpXN5eNK4CtSbqUN9/GGUsyfJj4akH
  /nxxH2szJGoeBfcFaMBqEssuXmHLrijTfsK0ZpEmXzwuJF/LWA/rKOyvEZbz3Htv
  wKeI8lN3s2Berq4o2jUsbzRF0ybh3uxbTydrFny9RAQYgrOJeRcQcT16ohZO9QHN
  pGxlaKFJdlxDydi8NmdspZS11My5vWo1ViHe2MPr+8ukYEywVaCge1ey
  -----END CERTIFICATE-----

  ### QuoVadis Limited

  === /C=BM/O=QuoVadis Limited/CN=QuoVadis Root CA 1 G3
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              78:58:5f:2e:ad:2c:19:4b:e3:37:07:35:34:13:28:b5:96:d4:65:93
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jan 12 17:27:44 2012 GMT
              Not After : Jan 12 17:27:44 2042 GMT
          Subject: C=BM, O=QuoVadis Limited, CN=QuoVadis Root CA 1 G3
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  A3:97:D6:F3:5E:A2:10:E1:AB:45:9F:3C:17:64:3C:EE:01:70:9C:CC
  SHA1 Fingerprint=1B:8E:EA:57:96:29:1A:C9:39:EA:B8:0A:81:1A:73:73:C0:93:79:67
  SHA256 Fingerprint=8A:86:6F:D1:B2:76:B5:7E:57:8E:92:1C:65:82:8A:2B:ED:58:E9:F2:F2:88:05:41:34:B7:F1:F4:BF:C9:CC:74
  -----BEGIN CERTIFICATE-----
  MIIFYDCCA0igAwIBAgIUeFhfLq0sGUvjNwc1NBMotZbUZZMwDQYJKoZIhvcNAQEL
  BQAwSDELMAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxHjAc
  BgNVBAMTFVF1b1ZhZGlzIFJvb3QgQ0EgMSBHMzAeFw0xMjAxMTIxNzI3NDRaFw00
  MjAxMTIxNzI3NDRaMEgxCzAJBgNVBAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBM
  aW1pdGVkMR4wHAYDVQQDExVRdW9WYWRpcyBSb290IENBIDEgRzMwggIiMA0GCSqG
  SIb3DQEBAQUAA4ICDwAwggIKAoICAQCgvlAQjunybEC0BJyFuTHK3C3kEakEPBtV
  wedYMB0ktMPvhd6MLOHBPd+C5k+tR4ds7FtJwUrVu4/sh6x/gpqG7D0DmVIB0jWe
  rNrwU8lmPNSsAgHaJNM7qAJGr6Qc4/hzWHa39g6QDbXwz8z6+cZM5cOGMAqNF341
  68Xfuw6cwI2H44g4hWf6Pser4BOcBRiYz5P1sZK0/CPTz9XEJ0ngnjybCKOLXSoh
  4Pw5qlPafX7PGglTvF0FBM+hSo+LdoINofjSxxR3W5A2B4GbPgb6Ul5jxaYA/qXp
  UhtStZI5cgMJYr2wYBZupt0lwgNm3fME0UDiTouG9G/lg6AnhF4EwfWQvTA9xO+o
  abw4m6SkltFi2mnAAZauy8RRNOoMqv8hjlmPSlzkYZqn0ukqeI1RPToV7qJZjqlc
  3sX5kCLliEVx3ZGZbHqfPT2YfF72vhZooF6uCyP8Wg+qInYtyaEQHeTTRCOQiJ/G
  KubX9ZqzWB4vMIkIG1SitZgj7Ah3HJVdYdHLiZxfokqRmu8hqkkWCKi9YSgxyXSt
  hfbZxbGL0eUQMk1fiyA6PEkfM4VZDdvLCXVDaXP7a3F98N/ETH3Goy7IlXnLc6KO
  Tk0k+17kBL5yG6YnLUlamXrXXAkgt3+UuU/xDRxeiEIbEbfnkduebPRq34wGmAOt
  zCjvpUfzUwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB
  BjAdBgNVHQ4EFgQUo5fW816iEOGrRZ88F2Q87gFwnMwwDQYJKoZIhvcNAQELBQAD
  ggIBABj6W3X8PnrHX3fHyt/PX8MSxEBd1DKquGrX1RUVRpgjpeaQWxiZTOOtQqOC
  MTaIzen7xASWSIsBx40Bz1szBpZGZnQdT+3Btrm0DWHMY37XLneMlhwqI2hrhVd2
  cDMT/uFPpiN3GPoajOi9ZcnPP/TJF9zrx7zABC4tRi9pZsMbj/7sPtPKlL92CiUN
  qXsCHKnQO18LwIE6PWThv6ctTr1NxNgpxiIY0MWscgKCP6o6ojoilzHdCGPDdRS5
  YCgtW2jgFqlmgiNR9etT2DGbe+m3nUvriBbP+V04ikkwj+3x6xn0dxoxGE1nVGwv
  b2X52z3sIexe9PSLymBlVNFxZPT5pqOBMzYzcfCkeF9OrYMh3jRJjehZrJ3ydlo2
  8hP0r+AJx2EqbPfgna67hkooby7utHnNkDPDs3b69fBsnQGQ+p6Q9pxyz0fawx/k
  NSBT8lTR32GDpgLiJTjehTItXnOQUl1CxM49S+H5GYQd1aJQzEH7QRTDvdbJWqNj
  ZgKAvQU6O0ec7AAmTPWIUb+oI38YB7AL7YsmoWTTYUrrXJ/es69nA7Mf3W1daWhp
  q1467HxpvMc7hU6eFbm0FU/DlXpY18ls6Wy58yljXrQs8C097Vpl4KlbQMJImYFt
  nh8GKjwStIsPm6Ik8KaN1nrgS7ZklmOVhMJKzRwuJIczYOXD
  -----END CERTIFICATE-----
  === /C=BM/O=QuoVadis Limited/CN=QuoVadis Root CA 2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 1289 (0x509)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Nov 24 18:27:00 2006 GMT
              Not After : Nov 24 18:23:33 2031 GMT
          Subject: C=BM, O=QuoVadis Limited, CN=QuoVadis Root CA 2
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage:
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  1A:84:62:BC:48:4C:33:25:04:D4:EE:D0:F6:03:C4:19:46:D1:94:6B
              X509v3 Authority Key Identifier:
                  keyid:1A:84:62:BC:48:4C:33:25:04:D4:EE:D0:F6:03:C4:19:46:D1:94:6B
                  DirName:/C=BM/O=QuoVadis Limited/CN=QuoVadis Root CA 2
                  serial:05:09

  SHA1 Fingerprint=CA:3A:FB:CF:12:40:36:4B:44:B2:16:20:88:80:48:39:19:93:7C:F7
  SHA256 Fingerprint=85:A0:DD:7D:D7:20:AD:B7:FF:05:F8:3D:54:2B:20:9D:C7:FF:45:28:F7:D6:77:B1:83:89:FE:A5:E5:C4:9E:86
  -----BEGIN CERTIFICATE-----
  MIIFtzCCA5+gAwIBAgICBQkwDQYJKoZIhvcNAQEFBQAwRTELMAkGA1UEBhMCQk0x
  GTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxGzAZBgNVBAMTElF1b1ZhZGlzIFJv
  b3QgQ0EgMjAeFw0wNjExMjQxODI3MDBaFw0zMTExMjQxODIzMzNaMEUxCzAJBgNV
  BAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBMaW1pdGVkMRswGQYDVQQDExJRdW9W
  YWRpcyBSb290IENBIDIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCa
  GMpLlA0ALa8DKYrwD4HIrkwZhR0In6spRIXzL4GtMh6QRr+jhiYaHv5+HBg6XJxg
  Fyo6dIMzMH1hVBHL7avg5tKifvVrbxi3Cgst/ek+7wrGsxDp3MJGF/hd/aTa/55J
  WpzmM+Yklvc/ulsrHHo1wtZn/qtmUIttKGAr79dgw8eTvI02kfN/+NsRE8Scd3bB
  rrcCaoF6qUWD4gXmuVbBlDePSHFjIuwXZQeVikvfj8ZaCuWw419eaxGrDPmF60Tp
  +ARz8un+XJiM9XOva7R+zdRcAitMOeGylZUtQofX1bOQQ7dsE/He3fbE+Ik/0XX1
  ksOR1YqI0JDs3G3eicJlcZaLDQP9nL9bFqyS2+r+eXyt66/3FsvbzSUr5R/7mp/i
  Ucw6UwxI5g69ybR2BlLmEROFcmMDBOAENisgGQLodKcftslWZvB1JdxnwQ5hYIiz
  PtGo/KPaHbDRsSNU30R2be1B2MGyIrZTHN81Hdyhdyox5C315eXbyOD/5YDXC2Og
  /zOhD7osFRXql7PSorW+8oyWHhqPHWykYTe5hnMz15eWniN9gqRMgeKh0bpnX5UH
  oycR7hYQe7xFSkyyBNKr79X9DFHOUGoIMfmR2gyPZFwDwzqLID9ujWc9Otb+fVuI
  yV77zGHcizN300QyNQliBJIWENieJ0f7OyHj+OsdWwIDAQABo4GwMIGtMA8GA1Ud
  EwEB/wQFMAMBAf8wCwYDVR0PBAQDAgEGMB0GA1UdDgQWBBQahGK8SEwzJQTU7tD2
  A8QZRtGUazBuBgNVHSMEZzBlgBQahGK8SEwzJQTU7tD2A8QZRtGUa6FJpEcwRTEL
  MAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxGzAZBgNVBAMT
  ElF1b1ZhZGlzIFJvb3QgQ0EgMoICBQkwDQYJKoZIhvcNAQEFBQADggIBAD4KFk2f
  BluornFdLwUvZ+YTRYPENvbzwCYMDbVHZF34tHLJRqUDGCdViXh9duqWNIAXINzn
  g/iN/Ae42l9NLmeyhP3ZRPx3UIHmfLTJDQtyU/h2BwdBR5YM++CCJpNVjP4iH2Bl
  fF/nJrP3MpCYUNQ3cVX2kiF495V5+vgtJodmVjB3pjd4M1IQWK4/YY7yarHvGH5K
  WWPKjaJW1acvvFYfzznB4vsKqBUsfU16Y8Zsl0Q80m/DShcK+JDSV6IZUaUtl0Ha
  B0+pUNqQjZRG4T7wlP0QADj1O+hA4bRuVhogzG9Yje0uRY/W6ZM/57Es3zrWIozc
  hLsib9D45MY56QSIPMO661V6bYCZJPVsAfv4l7CUW+v90m/xd2gNNWQjrLhVoQPR
  TUIZ3Ph1WVaj+ahJefivDrkRoHy3au000LYmYjgahwz46P0u05B/B5EqHdZ+XIWD
  mbA4CD/pXvk1B+TJYm5Xf6dQlfe6yJvmjqIBxdZmv3lh8zwc4bmCXF2gw+nYSL0Z
  ohEUGW6yhhtoPkg3Goi3XZZenMfvJ2II4pEZXNLxId26F0KCl3GBUzGpn/Z9Yr9y
  4aOTHcyKJloJONDO1w2AFrR4pTqHTI2KpdVGl/IsELm8VCLAAVBpQ570su9t+Oza
  8eOx79+Rj1QqCyXBJhnEUhAFZdWCEOrCMc0u
  -----END CERTIFICATE-----
  === /C=BM/O=QuoVadis Limited/CN=QuoVadis Root CA 2 G3
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              44:57:34:24:5b:81:89:9b:35:f2:ce:b8:2b:3b:5b:a7:26:f0:75:28
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jan 12 18:59:32 2012 GMT
              Not After : Jan 12 18:59:32 2042 GMT
          Subject: C=BM, O=QuoVadis Limited, CN=QuoVadis Root CA 2 G3
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  ED:E7:6F:76:5A:BF:60:EC:49:5B:C6:A5:77:BB:72:16:71:9B:C4:3D
  SHA1 Fingerprint=09:3C:61:F3:8B:8B:DC:7D:55:DF:75:38:02:05:00:E1:25:F5:C8:36
  SHA256 Fingerprint=8F:E4:FB:0A:F9:3A:4D:0D:67:DB:0B:EB:B2:3E:37:C7:1B:F3:25:DC:BC:DD:24:0E:A0:4D:AF:58:B4:7E:18:40
  -----BEGIN CERTIFICATE-----
  MIIFYDCCA0igAwIBAgIURFc0JFuBiZs18s64KztbpybwdSgwDQYJKoZIhvcNAQEL
  BQAwSDELMAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxHjAc
  BgNVBAMTFVF1b1ZhZGlzIFJvb3QgQ0EgMiBHMzAeFw0xMjAxMTIxODU5MzJaFw00
  MjAxMTIxODU5MzJaMEgxCzAJBgNVBAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBM
  aW1pdGVkMR4wHAYDVQQDExVRdW9WYWRpcyBSb290IENBIDIgRzMwggIiMA0GCSqG
  SIb3DQEBAQUAA4ICDwAwggIKAoICAQChriWyARjcV4g/Ruv5r+LrI3HimtFhZiFf
  qq8nUeVuGxbULX1QsFN3vXg6YOJkApt8hpvWGo6t/x8Vf9WVHhLL5hSEBMHfNrMW
  n4rjyduYNM7YMxcoRvynyfDStNVNCXJJ+fKH46nafaF9a7I6JaltUkSs+L5u+9ym
  c5GQYaYDFCDy54ejiK2toIz/pgslUiXnFgHVy7g1gQyjO/Dh4fxaXc6AcW34Sas+
  O7q414AB+6XrW7PFXmAqMaCvN+ggOp+oMiwMzAkd056OXbxMmO7FGmh77FOm6RQ1
  o9/NgJ8MSPsc9PG/Srj61YxxSscfrf5BmrODXfKEVu+lV0POKa2Mq1W/xPtbAd0j
  IaFYAI7D0GoT7RPjEiuA3GfmlbLNHiJuKvhB1PLKFAeNilUSxmn1uIZoL1NesNKq
  IcGY5jDjZ1XHm26sGahVpkUG0CM62+tlXSoREfA7T8pt9DTEceT/AFr2XK4jYIVz
  8eQQsSWu1ZK7E8EM4DnatDlXtas1qnIhO4M15zHfeiFuuDIIfR0ykRVKYnLP43eh
  vNURG3YBZwjgQQvD6xVu+KQZ2aKrr+InUlYrAoosFCT5v0ICvybIxo/gbjh9Uy3l
  7ZizlWNof/k19N+IxWA1ksB8aRxhlRbQ694Lrz4EEEVlWFA4r0jyWbYW8jwNkALG
  cC4BrTwV1wIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB
  BjAdBgNVHQ4EFgQU7edvdlq/YOxJW8ald7tyFnGbxD0wDQYJKoZIhvcNAQELBQAD
  ggIBAJHfgD9DCX5xwvfrs4iP4VGyvD11+ShdyLyZm3tdquXK4Qr36LLTn91nMX66
  AarHakE7kNQIXLJgapDwyM4DYvmL7ftuKtwGTTwpD4kWilhMSA/ohGHqPHKmd+RC
  roijQ1h5fq7KpVMNqT1wvSAZYaRsOPxDMuHBR//47PERIjKWnML2W2mWeyAMQ0Ga
  W/ZZGYjeVYg3UQt4XAoeo0L9x52ID8DyeAIkVJOviYeIyUqAHerQbj5hLja7NQ4n
  lv1mNDthcnPxFlxHBlRJAHpYErAK74X9sbgzdWqTHBLmYF5vHX/JHyPLhGGfHoJE
  +V+tYlUkmlKY7VHnoX6XOuYvHxHaU4AshZ6rNRDbIl9qxV6XU/IyAgkwo1jwDQHV
  csaxfGl7w/U2Rcxhbl5MlMVerugOXou/983g7aEOGzPuVBj+D77vfoRrQ+NwmNtd
  dbINWQeFFSM51vHfqSYP1kjHs6Yi9TM3WpVHn3u6GBVv/9YUZINJ0gpnIdsPNWNg
  KCLjsZWDzYWm3S8P52dSbrsvhXz1SnPnxT7AvSESBT/8twNJAlvIJebiVDj1eYeM
  HVOyToV7BjjHLPj4sHKNJeV3UvQDHEimUF+IIDBu8oJDqz2XhOdT+yHBTw8imoa4
  WSr2Rz0ZiC3oheGe7IUIarFsNMkd7EgrO3jtZsSOeWmD3n+M
  -----END CERTIFICATE-----
  === /C=BM/O=QuoVadis Limited/CN=QuoVadis Root CA 3
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 1478 (0x5c6)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Nov 24 19:11:23 2006 GMT
              Not After : Nov 24 19:06:44 2031 GMT
          Subject: C=BM, O=QuoVadis Limited, CN=QuoVadis Root CA 3
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Certificate Policies:
                  Policy: 1.3.6.1.4.1.8024.0.3
                    User Notice:
                      Explicit Text: Any use of this Certificate constitutes acceptance of the QuoVadis Root CA 3 Certificate Policy / Certification Practice Statement.
                    CPS: http://www.quovadisglobal.com/cps

              X509v3 Key Usage:
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  F2:C0:13:E0:82:43:3E:FB:EE:2F:67:32:96:35:5C:DB:B8:CB:02:D0
              X509v3 Authority Key Identifier:
                  keyid:F2:C0:13:E0:82:43:3E:FB:EE:2F:67:32:96:35:5C:DB:B8:CB:02:D0
                  DirName:/C=BM/O=QuoVadis Limited/CN=QuoVadis Root CA 3
                  serial:05:C6

  SHA1 Fingerprint=1F:49:14:F7:D8:74:95:1D:DD:AE:02:C0:BE:FD:3A:2D:82:75:51:85
  SHA256 Fingerprint=18:F1:FC:7F:20:5D:F8:AD:DD:EB:7F:E0:07:DD:57:E3:AF:37:5A:9C:4D:8D:73:54:6B:F4:F1:FE:D1:E1:8D:35
  -----BEGIN CERTIFICATE-----
  MIIGnTCCBIWgAwIBAgICBcYwDQYJKoZIhvcNAQEFBQAwRTELMAkGA1UEBhMCQk0x
  GTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxGzAZBgNVBAMTElF1b1ZhZGlzIFJv
  b3QgQ0EgMzAeFw0wNjExMjQxOTExMjNaFw0zMTExMjQxOTA2NDRaMEUxCzAJBgNV
  BAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBMaW1pdGVkMRswGQYDVQQDExJRdW9W
  YWRpcyBSb290IENBIDMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDM
  V0IWVJzmmNPTTe7+7cefQzlKZbPoFog02w1ZkXTPkrgEQK0CSzGrvI2RaNggDhoB
  4hp7Thdd4oq3P5kazethq8Jlph+3t723j/z9cI8LoGe+AaJZz3HmDyl2/7FWeUUr
  H556VOijKTVopAFPD6QuN+8bv+OPEKhyq1hX51SGyMnzW9os2l2ObjyjPtr7guXd
  8lyyBTNvijbO0BNO/79KDDRMpsMhvVAEVeuxu537RR5kFd5VAYwCdrXLoT9Cabwv
  vWhDFlaJKjdhkf2mrk7AyxRllDdLkgbvBNDInIjbC3uBr7E9KsRlOni27tyAsdLT
  mZw67mtaa7ONt9XOnMK+pUsvFrGeaDsGb659n/je7Mwpp5ijJUMv7/FfJuGITfhe
  btfZFG4ZM2mnO4SJk8RTVROhUXhA+LjJou57ulJCg54U7QVSWllWp5f8nT8KKdjc
  T5EOE7zelaTfi5m+rJsziO+1ga8bxiJTyPbH7pcUsMV8eFLI8M5ud2CEpukqdiDt
  WAEXMJPpGovgc2PZapKUSU60rUqFxKMiMPwJ7Wgic6aIDFUhWMXhOp8q3crhkODZ
  c6tsgLjoC2SToJyMGf+z0gzskSaHirOi4XCPLArlzW1oUevaPwV/izLmE1xr/l9A
  4iLItLRkT9a6fUg+qGkM17uGcclzuD87nSVL2v9A6wIDAQABo4IBlTCCAZEwDwYD
  VR0TAQH/BAUwAwEB/zCB4QYDVR0gBIHZMIHWMIHTBgkrBgEEAb5YAAMwgcUwgZMG
  CCsGAQUFBwICMIGGGoGDQW55IHVzZSBvZiB0aGlzIENlcnRpZmljYXRlIGNvbnN0
  aXR1dGVzIGFjY2VwdGFuY2Ugb2YgdGhlIFF1b1ZhZGlzIFJvb3QgQ0EgMyBDZXJ0
  aWZpY2F0ZSBQb2xpY3kgLyBDZXJ0aWZpY2F0aW9uIFByYWN0aWNlIFN0YXRlbWVu
  dC4wLQYIKwYBBQUHAgEWIWh0dHA6Ly93d3cucXVvdmFkaXNnbG9iYWwuY29tL2Nw
  czALBgNVHQ8EBAMCAQYwHQYDVR0OBBYEFPLAE+CCQz777i9nMpY1XNu4ywLQMG4G
  A1UdIwRnMGWAFPLAE+CCQz777i9nMpY1XNu4ywLQoUmkRzBFMQswCQYDVQQGEwJC
  TTEZMBcGA1UEChMQUXVvVmFkaXMgTGltaXRlZDEbMBkGA1UEAxMSUXVvVmFkaXMg
  Um9vdCBDQSAzggIFxjANBgkqhkiG9w0BAQUFAAOCAgEAT62gLEz6wPJv92ZVqyM0
  7ucp2sNbtrCD2dDQ4iH782CnO11gUyeim/YIIirnv6By5ZwkajGxkHon24QRiSem
  d1o417+shvzuXYO8BsbRd2sPbSQvS3pspweWyuOEn62Iix2rFo1bZhfZFvSLgNLd
  +LJ2w/w4E6oM3kJpK27zPOuAJ9v1pkQNn1pVWQvVDVJIxa6f8i+AxeoyUDUSly7B
  4f/xI4hROJ/yZlZ25w9Rl6VSDE1JUZU2Pb+iSwwQHYaZTKrzchGT5Or2m9qoXadN
  t54CrnMAyNojA+j56hl0YgCUyyIgvpSnWbWCar6ZeXqp8kokUvd0/bpO5qgdAm6x
  DYBEwa7TIzdfu4V8K5Iu6H6li92Z4b8nby1dqnuH/grdS/yO9SbkbnBCbjPsMZ57
  k8HkyWkaPcBrTiJt7qtYTcbQQcEr6k8Sh17rRdhs9ZgC06DYVYoGmRmioHfRMJ6s
  zHXug/WwYjnPbFfiTNKRCw51KBuav/0aQ/HKd/s7j2G4aSgWQgRecCocIdiP4b0j
  Wy10QJLZYxkNc91pvGJHvOB0K7Lrfb5BG7XARsWhIstfTsEokt4YutUqKLsRixeT
  mJlglFwjz1onl14LBQaTNx47aTbrqZ5hHY8y2o4M1nQ+ewkk2gF3R8Q7zTSMmfXK
  4SVhM7JZG+Ju1zdXtg2pEto=
  -----END CERTIFICATE-----
  === /C=BM/O=QuoVadis Limited/CN=QuoVadis Root CA 3 G3
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              2e:f5:9b:02:28:a7:db:7a:ff:d5:a3:a9:ee:bd:03:a0:cf:12:6a:1d
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jan 12 20:26:32 2012 GMT
              Not After : Jan 12 20:26:32 2042 GMT
          Subject: C=BM, O=QuoVadis Limited, CN=QuoVadis Root CA 3 G3
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  C6:17:D0:BC:A8:EA:02:43:F2:1B:06:99:5D:2B:90:20:B9:D7:9C:E4
  SHA1 Fingerprint=48:12:BD:92:3C:A8:C4:39:06:E7:30:6D:27:96:E6:A4:CF:22:2E:7D
  SHA256 Fingerprint=88:EF:81:DE:20:2E:B0:18:45:2E:43:F8:64:72:5C:EA:5F:BD:1F:C2:D9:D2:05:73:07:09:C5:D8:B8:69:0F:46
  -----BEGIN CERTIFICATE-----
  MIIFYDCCA0igAwIBAgIULvWbAiin23r/1aOp7r0DoM8Sah0wDQYJKoZIhvcNAQEL
  BQAwSDELMAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxHjAc
  BgNVBAMTFVF1b1ZhZGlzIFJvb3QgQ0EgMyBHMzAeFw0xMjAxMTIyMDI2MzJaFw00
  MjAxMTIyMDI2MzJaMEgxCzAJBgNVBAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBM
  aW1pdGVkMR4wHAYDVQQDExVRdW9WYWRpcyBSb290IENBIDMgRzMwggIiMA0GCSqG
  SIb3DQEBAQUAA4ICDwAwggIKAoICAQCzyw4QZ47qFJenMioKVjZ/aEzHs286IxSR
  /xl/pcqs7rN2nXrpixurazHb+gtTTK/FpRp5PIpM/6zfJd5O2YIyC0TeytuMrKNu
  FoM7pmRLMon7FhY4futD4tN0SsJiCnMK3UmzV9KwCoWdcTzeo8vAMvMBOSBDGzXR
  U7Ox7sWTaYI+FrUoRqHe6okJ7UO4BUaKhvVZR74bbwEhELn9qdIoyhA5CcoTNs+c
  ra1AdHkrAj80//ogaX3T7mH1urPnMNA3I4ZyYUUpSFlob3emLoG+B01vr87ERROR
  FHAGjx+f+IdpsQ7vw4kZ6+ocYfx6bIrc1gMLnia6Et3UVDmrJqMz6nWB2i3ND0/k
  A9HvFZcba5DFApCTZgIhsUfei5pKgLlVj7WiL8DWM2fafsSntARE60f75li59wzw
  eyuxwHApw0BiLTtIadwjPEjrewl5qW3aqDCYz4ByA4imW0aucnl8CAMhZa634Ryl
  sSqiMd5mBPfAdOhx3v89WcyWJhKLhZVXGqtrdQtEPREoPHtht+KPZ0/l7DxMYIBp
  VzgeAVuNVejH38DMdyM0SXV89pgR6y3e7UEuFAUCf+D+IOs15xGsIs5XPd7JMG0Q
  A4XN8f+MFrXBsj6IbGB/kE+V9/YtrQE5BwT6dYB9v0lQ7e/JxHwc64B+27bQ3RP+
  ydOc17KXqQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB
  BjAdBgNVHQ4EFgQUxhfQvKjqAkPyGwaZXSuQILnXnOQwDQYJKoZIhvcNAQELBQAD
  ggIBADRh2Va1EodVTd2jNTFGu6QHcrxfYWLopfsLN7E8trP6KZ1/AvWkyaiTt3px
  KGmPc+FSkNrVvjrlt3ZqVoAh313m6Tqe5T72omnHKgqwGEfcIHB9UqM+WXzBusnI
  FUBhynLWcKzSt/Ac5IYp8M7vaGPQtSCKFWGafoaYtMnCdvvMujAWzKNhxnQT5Wvv
  oxXqA/4Ti2Tk08HS6IT7SdEQTXlm66r99I0xHnAUrdzeZxNMgRVhvLfZkXdxGYFg
  u/BYpbWcC/ePIlUnwEsBbTuZDdQdm2NnL9DuDcpmvJRPpq3t/O5jrFc/ZSXPsoaP
  0Aj/uHYUbt7lJ+yreLVTubY/6CD50qi+YUbKh4yE8/nxoGibIh6BJpsQBJFxwAYf
  3KDTuVan45gtf4Od34wrnDKOMpTwATwiKp9Dwi7DmDkHOHv8XgBCH/MyJnmDhPbl
  8MFREsALHgQjDFSlTC9JxUrRtm5gDWv8a4uFJGS3iQ6rJUdbPM9+Sb3H6QrG2vd+
  DhcI00iX0HGS8A85PjRqHH3Y8iKuu2n0M7SmSFXRDw4m6Oy2Cy2nhTXN/VnIn9HN
  PlopNLk9hM6xZdRZkZFWdSHBd575euFgndOtBBj0fOtek49TSiIp+EgrPk2GrFt/
  ywaZWWDYWGWVjUTR939+J399roD1B0y2PpxxVJkES/1Y+Zj0
  -----END CERTIFICATE-----

  ### SECOM Trust Systems CO.,LTD.

  === /C=JP/O=SECOM Trust Systems CO.,LTD./OU=Security Communication RootCA2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 0 (0x0)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: May 29 05:00:39 2009 GMT
              Not After : May 29 05:00:39 2029 GMT
          Subject: C=JP, O=SECOM Trust Systems CO.,LTD., OU=Security Communication RootCA2
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  0A:85:A9:77:65:05:98:7C:40:81:F8:0F:97:2C:38:F1:0A:EC:3C:CF
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=5F:3B:8C:F2:F8:10:B3:7D:78:B4:CE:EC:19:19:C3:73:34:B9:C7:74
  SHA256 Fingerprint=51:3B:2C:EC:B8:10:D4:CD:E5:DD:85:39:1A:DF:C6:C2:DD:60:D8:7B:B7:36:D2:B5:21:48:4A:A4:7A:0E:BE:F6
  -----BEGIN CERTIFICATE-----
  MIIDdzCCAl+gAwIBAgIBADANBgkqhkiG9w0BAQsFADBdMQswCQYDVQQGEwJKUDEl
  MCMGA1UEChMcU0VDT00gVHJ1c3QgU3lzdGVtcyBDTy4sTFRELjEnMCUGA1UECxMe
  U2VjdXJpdHkgQ29tbXVuaWNhdGlvbiBSb290Q0EyMB4XDTA5MDUyOTA1MDAzOVoX
  DTI5MDUyOTA1MDAzOVowXTELMAkGA1UEBhMCSlAxJTAjBgNVBAoTHFNFQ09NIFRy
  dXN0IFN5c3RlbXMgQ08uLExURC4xJzAlBgNVBAsTHlNlY3VyaXR5IENvbW11bmlj
  YXRpb24gUm9vdENBMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANAV
  OVKxUrO6xVmCxF1SrjpDZYBLx/KWvNs2l9amZIyoXvDjChz335c9S672XewhtUGr
  zbl+dp+++T42NKA7wfYxEUV0kz1XgMX5iZnK5atq1LXaQZAQwdbWQonCv/Q4EpVM
  VAX3NuRFg3sUZdbcDE3R3n4MqzvEFb46VqZab3ZpUql6ucjrappdUtAtCms1FgkQ
  hNBqyjoGADdH5H5XTz+L62e4iKrFvlNVspHEfbmwhRkGeC7bYRr6hfVKkaHnFtWO
  ojnflLhwHyg/i/xAXmODPIMqGplrz95Zajv8bxbXH/1KEOtOghY6rCcMU/Gt1SSw
  awNQwS08Ft1ENCcadfsCAwEAAaNCMEAwHQYDVR0OBBYEFAqFqXdlBZh8QIH4D5cs
  OPEK7DzPMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3
  DQEBCwUAA4IBAQBMOqNErLlFsceTfsgLCkLfZOoc7llsCLqJX2rKSpWeeo8HxdpF
  coJxDjrSzG+ntKEju/Ykn8sX/oymzsLS28yN/HH8AynBbF0zX2S2ZTuJbxh2ePXc
  okgfGT+Ok+vx+hfuzU7jBBJV1uXk3fs+BXziHV7Gp7yXT2g69ekuCkO2r1dcYmh8
  t/2jioSgrGK+KwmHNPBqAbubKVY8/gA3zyNs8U6qtnRGEmyR7jTV7JqR50S+kDFy
  1UkC9gLl9B/rfNmWVan/7Ir5mUf/NVoCqgTLiluHcSmRvaS0eg29mvVXIwAHIRc/
  SjnRBUkLp7Y3gaVdjKozXoEofKd9J+sAro03
  -----END CERTIFICATE-----

  ### SECOM Trust.net

  === /C=JP/O=SECOM Trust.net/OU=Security Communication RootCA1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 0 (0x0)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Sep 30 04:20:49 2003 GMT
              Not After : Sep 30 04:20:49 2023 GMT
          Subject: C=JP, O=SECOM Trust.net, OU=Security Communication RootCA1
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  A0:73:49:99:68:DC:85:5B:65:E3:9B:28:2F:57:9F:BD:33:BC:07:48
              X509v3 Key Usage:
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=36:B1:2B:49:F9:81:9E:D7:4C:9E:BC:38:0F:C6:56:8F:5D:AC:B2:F7
  SHA256 Fingerprint=E7:5E:72:ED:9F:56:0E:EC:6E:B4:80:00:73:A4:3F:C3:AD:19:19:5A:39:22:82:01:78:95:97:4A:99:02:6B:6C
  -----BEGIN CERTIFICATE-----
  MIIDWjCCAkKgAwIBAgIBADANBgkqhkiG9w0BAQUFADBQMQswCQYDVQQGEwJKUDEY
  MBYGA1UEChMPU0VDT00gVHJ1c3QubmV0MScwJQYDVQQLEx5TZWN1cml0eSBDb21t
  dW5pY2F0aW9uIFJvb3RDQTEwHhcNMDMwOTMwMDQyMDQ5WhcNMjMwOTMwMDQyMDQ5
  WjBQMQswCQYDVQQGEwJKUDEYMBYGA1UEChMPU0VDT00gVHJ1c3QubmV0MScwJQYD
  VQQLEx5TZWN1cml0eSBDb21tdW5pY2F0aW9uIFJvb3RDQTEwggEiMA0GCSqGSIb3
  DQEBAQUAA4IBDwAwggEKAoIBAQCzs/5/022x7xZ8V6UMbXaKL0u/ZPtM7orw8yl8
  9f/uKuDp6bpbZCKamm8sOiZpUQWZJtzVHGpxxpp9Hp3dfGzGjGdnSj74cbAZJ6kJ
  DKaVv0uMDPpVmDvY6CKhS3E4eayXkmmziX7qIWgGmBSWh9JhNrxtJ1aeV+7AwFb9
  Ms+k2Y7CI9eNqPPYJayX5HA49LY6tJ07lyZDo6G8SVlyTCMwhwFY9k6+HGhWZq/N
  QV3Is00qVUarH9oe4kA92819uZKAnDfdDJZkndwi92SL32HeFZRSFaB9UslLqCHJ
  xrHty8OVYNEP8Ktw+N/LTX7s1vqr2b1/VPKl6Xn62dZ2JChzAgMBAAGjPzA9MB0G
  A1UdDgQWBBSgc0mZaNyFW2XjmygvV5+9M7wHSDALBgNVHQ8EBAMCAQYwDwYDVR0T
  AQH/BAUwAwEB/zANBgkqhkiG9w0BAQUFAAOCAQEAaECpqLvkT115swW1F7NgE+vG
  kl3g0dNq/vu+m22/xwVtWSDEHPC32oRYAmP6SBbvT6UL90qY8j+eG61Ha2POCEfr
  Uj94nK9NrvjVT8+amCoQQTlSxN3Zmw7vkwGusi7KaEIkQmywszo+zenaSMQVy+n5
  Bw+SUEmK3TGXX8npN6o7WWWXlDLJs58+OmJYxUmtYg5xpTKqL8aJdkNAExNnPaJU
  JRDL8Try2frbSVa7pv6nQTXD4IhhyYjH3zYQIphZ6rBK+1YWc26sTfcioU+tHXot
  RSflMMFe8toTyyVCUZVHA4xsIcx0Qu1T/zOLjw9XARYvz6buyXAiFL39vmwLAw==
  -----END CERTIFICATE-----

  ### SecureTrust Corporation

  === /C=US/O=SecureTrust Corporation/CN=Secure Global CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              07:56:22:a4:e8:d4:8a:89:4d:f4:13:c8:f0:f8:ea:a5
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Nov  7 19:42:28 2006 GMT
              Not After : Dec 31 19:52:06 2029 GMT
          Subject: C=US, O=SecureTrust Corporation, CN=Secure Global CA
          X509v3 extensions:
              1.3.6.1.4.1.311.20.2:
                  ...C.A
              X509v3 Key Usage:
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  AF:44:04:C2:41:7E:48:83:DB:4E:39:02:EC:EC:84:7A:E6:CE:C9:A4
              X509v3 CRL Distribution Points:

                  Full Name:
                    URI:http://crl.securetrust.com/SGCA.crl

              1.3.6.1.4.1.311.21.1:
                  ...
  SHA1 Fingerprint=3A:44:73:5A:E5:81:90:1F:24:86:61:46:1E:3B:9C:C4:5F:F5:3A:1B
  SHA256 Fingerprint=42:00:F5:04:3A:C8:59:0E:BB:52:7D:20:9E:D1:50:30:29:FB:CB:D4:1C:A1:B5:06:EC:27:F1:5A:DE:7D:AC:69
  -----BEGIN CERTIFICATE-----
  MIIDvDCCAqSgAwIBAgIQB1YipOjUiolN9BPI8PjqpTANBgkqhkiG9w0BAQUFADBK
  MQswCQYDVQQGEwJVUzEgMB4GA1UEChMXU2VjdXJlVHJ1c3QgQ29ycG9yYXRpb24x
  GTAXBgNVBAMTEFNlY3VyZSBHbG9iYWwgQ0EwHhcNMDYxMTA3MTk0MjI4WhcNMjkx
  MjMxMTk1MjA2WjBKMQswCQYDVQQGEwJVUzEgMB4GA1UEChMXU2VjdXJlVHJ1c3Qg
  Q29ycG9yYXRpb24xGTAXBgNVBAMTEFNlY3VyZSBHbG9iYWwgQ0EwggEiMA0GCSqG
  SIb3DQEBAQUAA4IBDwAwggEKAoIBAQCvNS7YrGxVaQZx5RNoJLNP2MwhR/jxYDiJ
  iQPpvepeRlMJ3Fz1Wuj3RSoC6zFh1ykzTM7HfAo3fg+6MpjhHZevj8fcyTiW89sa
  /FHtaMbQbqR8JNGuQsiWUGMu4P51/pinX0kuleM5M2SOHqRfkNJnPLLZ/kG5VacJ
  jnIFHovdRIWCQtBJwB1g8NEXLJXr9qXBkqPFwqcIYA1gBBCWeZ4WNOaptvolRTnI
  HmX5k/Wq8VLcmZg9pYYaDDUz+kulBAYVHDGA76oYa8J719rO+TMg1fW9ajMtgQT7
  sFzUnKPiXB3jqUJ1XnvUd+85VLrJChgbEplJL4hL/VBi0XPnj3pDAgMBAAGjgZ0w
  gZowEwYJKwYBBAGCNxQCBAYeBABDAEEwCwYDVR0PBAQDAgGGMA8GA1UdEwEB/wQF
  MAMBAf8wHQYDVR0OBBYEFK9EBMJBfkiD2045AuzshHrmzsmkMDQGA1UdHwQtMCsw
  KaAnoCWGI2h0dHA6Ly9jcmwuc2VjdXJldHJ1c3QuY29tL1NHQ0EuY3JsMBAGCSsG
  AQQBgjcVAQQDAgEAMA0GCSqGSIb3DQEBBQUAA4IBAQBjGghAfaReUw132HquHw0L
  URYD7xh8yOOvaliTFGCRsoTciE6+OYo68+aCiV0BN7OrJKQVDpI1WkpEXk5X+nXO
  H0jOZvQ8QCaSmGwb7iRGDBezUqXbpZGRzzfTb+cnCDpOGR86p1hcF895P4vkp9Mm
  I50mD1hp/Ed+stCNi5O/KU9DaXR2Z0vPB4zmAve14bRDtUstFJ/53CYNv6ZHdAbY
  iNE6KTCEztI5gGIbqMdXSbxqVVFnFUq+NQfk1XWYN3kwFNspnWzFacxHVaIw98xc
  f8LDmBxrThaA63p4ZUWiABqvDA1VZDRIuJK58bRQKfJPIx/abKwfROHdI3hRW8cW
  -----END CERTIFICATE-----
  === /C=US/O=SecureTrust Corporation/CN=SecureTrust CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              0c:f0:8e:5c:08:16:a5:ad:42:7f:f0:eb:27:18:59:d0
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Nov  7 19:31:18 2006 GMT
              Not After : Dec 31 19:40:55 2029 GMT
          Subject: C=US, O=SecureTrust Corporation, CN=SecureTrust CA
          X509v3 extensions:
              1.3.6.1.4.1.311.20.2:
                  ...C.A
              X509v3 Key Usage:
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  42:32:B6:16:FA:04:FD:FE:5D:4B:7A:C3:FD:F7:4C:40:1D:5A:43:AF
              X509v3 CRL Distribution Points:

                  Full Name:
                    URI:http://crl.securetrust.com/STCA.crl

              1.3.6.1.4.1.311.21.1:
                  ...
  SHA1 Fingerprint=87:82:C6:C3:04:35:3B:CF:D2:96:92:D2:59:3E:7D:44:D9:34:FF:11
  SHA256 Fingerprint=F1:C1:B5:0A:E5:A2:0D:D8:03:0E:C9:F6:BC:24:82:3D:D3:67:B5:25:57:59:B4:E7:1B:61:FC:E9:F7:37:5D:73
  -----BEGIN CERTIFICATE-----
  MIIDuDCCAqCgAwIBAgIQDPCOXAgWpa1Cf/DrJxhZ0DANBgkqhkiG9w0BAQUFADBI
  MQswCQYDVQQGEwJVUzEgMB4GA1UEChMXU2VjdXJlVHJ1c3QgQ29ycG9yYXRpb24x
  FzAVBgNVBAMTDlNlY3VyZVRydXN0IENBMB4XDTA2MTEwNzE5MzExOFoXDTI5MTIz
  MTE5NDA1NVowSDELMAkGA1UEBhMCVVMxIDAeBgNVBAoTF1NlY3VyZVRydXN0IENv
  cnBvcmF0aW9uMRcwFQYDVQQDEw5TZWN1cmVUcnVzdCBDQTCCASIwDQYJKoZIhvcN
  AQEBBQADggEPADCCAQoCggEBAKukgeWVzfX2FI7CT8rU4niVWJxB4Q2ZQCQXOZEz
  Zum+4YOvYlyJ0fwkW2Gz4BERQRwdbvC4u/jep4G6pkjGnx29vo6pQT64lO0pGtSO
  0gMdA+9tDWccV9cGrcrI9f4Or2YlSASWC12juhbDCE/RRvgUXPLIXgGZbf2IzIao
  wW8xQmxSPmjL8xk037uHGFaAJsTQ3MBv396gwpEWoGQRS0S8Hvbn+mPeZqx2pHGj
  7DaUaHp3pLHnDi+BeuK1cobvomuL8A/b01k/unK8RCSc43Oz969XL0Imnal0ugBS
  8kvNU3xHCzaFDmapCJcWNFfBZveA4+1wVMeT4C4oFVmHursCAwEAAaOBnTCBmjAT
  BgkrBgEEAYI3FAIEBh4EAEMAQTALBgNVHQ8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB
  /zAdBgNVHQ4EFgQUQjK2FvoE/f5dS3rD/fdMQB1aQ68wNAYDVR0fBC0wKzApoCeg
  JYYjaHR0cDovL2NybC5zZWN1cmV0cnVzdC5jb20vU1RDQS5jcmwwEAYJKwYBBAGC
  NxUBBAMCAQAwDQYJKoZIhvcNAQEFBQADggEBADDtT0rhWDpSclu1pqNlGKa7UTt3
  6Z3q059c4EVlew3KW+JwULKUBRSuSceNQQcSc5R+DCMh/bwQf2AQWnL1mA6s7Ll/
  3XpvXdMc9P+IBWlCqQVxyLesJugutIxq/3HcuLHfmbx8IVQr5Fiiu1cprp6poxkm
  D5kuCLDv/WnPmRoJjeOnnyvJNjR7JLN4TJUXpAYmHrZkUjZfYGfZnMUFdAvnZyPS
  CPyI6a6Lf+Ew9Dd+/cYy2i2eRDAwbO4H3tI0/NL/QPZL9GZGBlSm8jIKYyYwa5vR
  3ItHuuG51WLQoqD0ZwV4KWMabwTW+MZMo5qxN7SN5ShLHZ4swrhovO0C7jE=
  -----END CERTIFICATE-----

  ### Sonera


  ### SSL Corporation

  === /C=US/ST=Texas/L=Houston/O=SSL Corporation/CN=SSL.com EV Root Certification Authority ECC
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 3182246526754555285 (0x2c299c5b16ed0595)
      Signature Algorithm: ecdsa-with-SHA256
          Validity
              Not Before: Feb 12 18:15:23 2016 GMT
              Not After : Feb 12 18:15:23 2041 GMT
          Subject: C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com EV Root Certification Authority ECC
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  5B:CA:5E:E5:DE:D2:81:AA:CD:A8:2D:64:51:B6:D9:72:9B:97:E6:4F
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Authority Key Identifier:
                  keyid:5B:CA:5E:E5:DE:D2:81:AA:CD:A8:2D:64:51:B6:D9:72:9B:97:E6:4F

              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
  SHA1 Fingerprint=4C:DD:51:A3:D1:F5:20:32:14:B0:C6:C5:32:23:03:91:C7:46:42:6D
  SHA256 Fingerprint=22:A2:C1:F7:BD:ED:70:4C:C1:E7:01:B5:F4:08:C3:10:88:0F:E9:56:B5:DE:2A:4A:44:F9:9C:87:3A:25:A7:C8
  -----BEGIN CERTIFICATE-----
  MIIClDCCAhqgAwIBAgIILCmcWxbtBZUwCgYIKoZIzj0EAwIwfzELMAkGA1UEBhMC
  VVMxDjAMBgNVBAgMBVRleGFzMRAwDgYDVQQHDAdIb3VzdG9uMRgwFgYDVQQKDA9T
  U0wgQ29ycG9yYXRpb24xNDAyBgNVBAMMK1NTTC5jb20gRVYgUm9vdCBDZXJ0aWZp
  Y2F0aW9uIEF1dGhvcml0eSBFQ0MwHhcNMTYwMjEyMTgxNTIzWhcNNDEwMjEyMTgx
  NTIzWjB/MQswCQYDVQQGEwJVUzEOMAwGA1UECAwFVGV4YXMxEDAOBgNVBAcMB0hv
  dXN0b24xGDAWBgNVBAoMD1NTTCBDb3Jwb3JhdGlvbjE0MDIGA1UEAwwrU1NMLmNv
  bSBFViBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IEVDQzB2MBAGByqGSM49
  AgEGBSuBBAAiA2IABKoSR5CYG/vvw0AHgyBO8TCCogbR8pKGYfL2IWjKAMTH6kMA
  VIbc/R/fALhBYlzccBYy3h+Z1MzFB8gIH2EWB1E9fVwHU+M1OIzfzZ/ZLg1Kthku
  WnBaBu2+8KGwytAJKaNjMGEwHQYDVR0OBBYEFFvKXuXe0oGqzagtZFG22XKbl+ZP
  MA8GA1UdEwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAUW8pe5d7SgarNqC1kUbbZcpuX
  5k8wDgYDVR0PAQH/BAQDAgGGMAoGCCqGSM49BAMCA2gAMGUCMQCK5kCJN+vp1RPZ
  ytRrJPOwPYdGWBrssd9v+1a6cGvHOMzosYxPD/fxZ3YOg9AeUY8CMD32IygmTMZg
  h5Mmm7I1HrrW9zzRHM76JTymGoEVW/MSD2zuZYrJh6j5B+BimoxcSg==
  -----END CERTIFICATE-----
  === /C=US/ST=Texas/L=Houston/O=SSL Corporation/CN=SSL.com EV Root Certification Authority RSA R2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 6248227494352943350 (0x56b629cd34bc78f6)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: May 31 18:14:37 2017 GMT
              Not After : May 30 18:14:37 2042 GMT
          Subject: C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com EV Root Certification Authority RSA R2
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Authority Key Identifier:
                  keyid:F9:60:BB:D4:E3:D5:34:F6:B8:F5:06:80:25:A7:73:DB:46:69:A8:9E

              X509v3 Subject Key Identifier:
                  F9:60:BB:D4:E3:D5:34:F6:B8:F5:06:80:25:A7:73:DB:46:69:A8:9E
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
  SHA1 Fingerprint=74:3A:F0:52:9B:D0:32:A0:F4:4A:83:CD:D4:BA:A9:7B:7C:2E:C4:9A
  SHA256 Fingerprint=2E:7B:F1:6C:C2:24:85:A7:BB:E2:AA:86:96:75:07:61:B0:AE:39:BE:3B:2F:E9:D0:CC:6D:4E:F7:34:91:42:5C
  -----BEGIN CERTIFICATE-----
  MIIF6zCCA9OgAwIBAgIIVrYpzTS8ePYwDQYJKoZIhvcNAQELBQAwgYIxCzAJBgNV
  BAYTAlVTMQ4wDAYDVQQIDAVUZXhhczEQMA4GA1UEBwwHSG91c3RvbjEYMBYGA1UE
  CgwPU1NMIENvcnBvcmF0aW9uMTcwNQYDVQQDDC5TU0wuY29tIEVWIFJvb3QgQ2Vy
  dGlmaWNhdGlvbiBBdXRob3JpdHkgUlNBIFIyMB4XDTE3MDUzMTE4MTQzN1oXDTQy
  MDUzMDE4MTQzN1owgYIxCzAJBgNVBAYTAlVTMQ4wDAYDVQQIDAVUZXhhczEQMA4G
  A1UEBwwHSG91c3RvbjEYMBYGA1UECgwPU1NMIENvcnBvcmF0aW9uMTcwNQYDVQQD
  DC5TU0wuY29tIEVWIFJvb3QgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgUlNBIFIy
  MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAjzZlQOHWTcDXtOlG2mvq
  M0fNTPl9fb69LT3w23jhhqXZuglXaO1XPqDQCEGD5yhBJB/jchXQARr7XnAjssuf
  OePPxU7Gkm0mxnu7s9onnQqG6YE3Bf7wcXHswxzpY6IXFJ3vG2fThVUCAtZJycxa
  4bH3bzKfydQ7iEGonL3Lq9ttewkfokxykNorCPzPPFTOZw+oz12WGQvE43LrrdF9
  HSfvkusQv1vrO6/PgN3B0pYEW3p+pKk8OHakYo6gOV7qd89dAFmPZiw+B6KjBSYR
  aZfqhbcPlgtLyEDhULouisv3D5oi53+aNxPN8k0TayHRwMwi8qFG9kRpnMphNQcA
  b9ZhCBHqurj26bNg5U257J8UZslXWNvNh2n4ioYSA0e/ZhN2rHd9NCSFg83XqpyQ
  Gp8hLH94t2S42Oim9HizVcuE0jLEeK6jj2HdzghTreyI/BXkmg3mnxp3zkyPuBQV
  PWKchjgGAGYS5Fl2WlPAApiiECtoRHuOec4zSnaqW4EWG7WK2NAAe15itAnWhmMO
  pgWVSbooi4iTsjQc2KRVbrcc0N6ZVTsj9CLg+SlmJuwgUHfbSguPvuUCYHBBXtSu
  UDkiFCbLsjtzdFVHB3mBOagwE0TlBIqulhMlQg+5U8Sb/M3kHN48+qvWBkofZ6aY
  MBzdLNvcGJVXZsb/XItW9XcCAwEAAaNjMGEwDwYDVR0TAQH/BAUwAwEB/zAfBgNV
  HSMEGDAWgBT5YLvU49U09rj1BoAlp3PbRmmonjAdBgNVHQ4EFgQU+WC71OPVNPa4
  9QaAJadz20ZpqJ4wDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4ICAQBW
  s47LCp1Jjr+kxJG7ZhcFUZh1++VQLHqe8RT6q9OKPv+RKY9ji9i0qVQBDb6Thi/5
  Sm3HXvVX+cpVHBK+Rw82xd9qt9t1wkclf7nxY/hoLVUE0fKNsKTPvDxeH3jnpaAg
  cLAExbf3cqfeIg29MyVGjGSSJuM+LmOW2puMPfgYCdcDzH2GguDKBAdRUNf/ktUM
  79qGn5nX67evaOI5JpS6aLe/g9Pqemc9YmeuJeVy6OLk7K4S9ksrPJ/psEDzOFSz
  /bdoyNrGj1E8svuR3Bznm53htw1yj+KkxKl4+esUrMZDBcJlOSgYAsOCsp0FvmXt
  ll9ldDz7CTUue5wT/RsPXcdtgTpWD8w74a8CLyKsRspGPKAcTNZEtF4uXBVmCeEm
  Kf7GUmG6sXP/wwyc5WxqlD8UykAWlYTzWamsX0xhk23RO8yilQwipmdnRC652dKK
  QbNmC1r7fSOl8hqw/96bg5Qu0T/fkreRrwU7ZcegbLHNYhLDkBvjJc40vG93drEQ
  w/cFGsDWr3RiSBd3kmmQYRzelYB0VI8YHMPzA9C/pEN1hlMYegouCRw2n5H9gooi
  S9EOUCXdywMMF8mDAAhONU2Ki+3wApRmLER/y5UnlhetCTCstnEXbosX9hwJ1C07
  mKVx01QT2WDz9UtmT/rx7iASjbSsV7FFY6GsdqnC+w==
  -----END CERTIFICATE-----
  === /C=US/ST=Texas/L=Houston/O=SSL Corporation/CN=SSL.com Root Certification Authority ECC
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 8495723813297216424 (0x75e6dfcbc1685ba8)
      Signature Algorithm: ecdsa-with-SHA256
          Validity
              Not Before: Feb 12 18:14:03 2016 GMT
              Not After : Feb 12 18:14:03 2041 GMT
          Subject: C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority ECC
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  82:D1:85:73:30:E7:35:04:D3:8E:02:92:FB:E5:A4:D1:C4:21:E8:CD
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Authority Key Identifier:
                  keyid:82:D1:85:73:30:E7:35:04:D3:8E:02:92:FB:E5:A4:D1:C4:21:E8:CD

              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
  SHA1 Fingerprint=C3:19:7C:39:24:E6:54:AF:1B:C4:AB:20:95:7A:E2:C3:0E:13:02:6A
  SHA256 Fingerprint=34:17:BB:06:CC:60:07:DA:1B:96:1C:92:0B:8A:B4:CE:3F:AD:82:0E:4A:A3:0B:9A:CB:C4:A7:4E:BD:CE:BC:65
  -----BEGIN CERTIFICATE-----
  MIICjTCCAhSgAwIBAgIIdebfy8FoW6gwCgYIKoZIzj0EAwIwfDELMAkGA1UEBhMC
  VVMxDjAMBgNVBAgMBVRleGFzMRAwDgYDVQQHDAdIb3VzdG9uMRgwFgYDVQQKDA9T
  U0wgQ29ycG9yYXRpb24xMTAvBgNVBAMMKFNTTC5jb20gUm9vdCBDZXJ0aWZpY2F0
  aW9uIEF1dGhvcml0eSBFQ0MwHhcNMTYwMjEyMTgxNDAzWhcNNDEwMjEyMTgxNDAz
  WjB8MQswCQYDVQQGEwJVUzEOMAwGA1UECAwFVGV4YXMxEDAOBgNVBAcMB0hvdXN0
  b24xGDAWBgNVBAoMD1NTTCBDb3Jwb3JhdGlvbjExMC8GA1UEAwwoU1NMLmNvbSBS
  b290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IEVDQzB2MBAGByqGSM49AgEGBSuB
  BAAiA2IABEVuqVDEpiM2nl8ojRfLliJkP9x6jh3MCLOicSS6jkm5BBtHllirLZXI
  7Z4INcgn64mMU1jrYor+8FsPazFSY0E7ic3s7LaNGdM0B9y7xgZ/wkWV7Mt/qCPg
  CemB+vNH06NjMGEwHQYDVR0OBBYEFILRhXMw5zUE044CkvvlpNHEIejNMA8GA1Ud
  EwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAUgtGFczDnNQTTjgKS++Wk0cQh6M0wDgYD
  VR0PAQH/BAQDAgGGMAoGCCqGSM49BAMCA2cAMGQCMG/n61kRpGDPYbCWe+0F+S8T
  kdzt5fxQaxFGRrMcIQBiu77D5+jNB5n5DQtdcj7EqgIwH7y6C+IwJPt8bYBVCpk+
  gA0z5Wajs6O7pdWLjwkspl1+4vAHCGht0nxpbl/f5Wpl
  -----END CERTIFICATE-----
  === /C=US/ST=Texas/L=Houston/O=SSL Corporation/CN=SSL.com Root Certification Authority RSA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 8875640296558310041 (0x7b2c9bd316803299)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Feb 12 17:39:39 2016 GMT
              Not After : Feb 12 17:39:39 2041 GMT
          Subject: C=US, ST=Texas, L=Houston, O=SSL Corporation, CN=SSL.com Root Certification Authority RSA
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  DD:04:09:07:A2:F5:7A:7D:52:53:12:92:95:EE:38:80:25:0D:A6:59
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Authority Key Identifier:
                  keyid:DD:04:09:07:A2:F5:7A:7D:52:53:12:92:95:EE:38:80:25:0D:A6:59

              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
  SHA1 Fingerprint=B7:AB:33:08:D1:EA:44:77:BA:14:80:12:5A:6F:BD:A9:36:49:0C:BB
  SHA256 Fingerprint=85:66:6A:56:2E:E0:BE:5C:E9:25:C1:D8:89:0A:6F:76:A8:7E:C1:6D:4D:7D:5F:29:EA:74:19:CF:20:12:3B:69
  -----BEGIN CERTIFICATE-----
  MIIF3TCCA8WgAwIBAgIIeyyb0xaAMpkwDQYJKoZIhvcNAQELBQAwfDELMAkGA1UE
  BhMCVVMxDjAMBgNVBAgMBVRleGFzMRAwDgYDVQQHDAdIb3VzdG9uMRgwFgYDVQQK
  DA9TU0wgQ29ycG9yYXRpb24xMTAvBgNVBAMMKFNTTC5jb20gUm9vdCBDZXJ0aWZp
  Y2F0aW9uIEF1dGhvcml0eSBSU0EwHhcNMTYwMjEyMTczOTM5WhcNNDEwMjEyMTcz
  OTM5WjB8MQswCQYDVQQGEwJVUzEOMAwGA1UECAwFVGV4YXMxEDAOBgNVBAcMB0hv
  dXN0b24xGDAWBgNVBAoMD1NTTCBDb3Jwb3JhdGlvbjExMC8GA1UEAwwoU1NMLmNv
  bSBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IFJTQTCCAiIwDQYJKoZIhvcN
  AQEBBQADggIPADCCAgoCggIBAPkP3aMrfcvQKv7sZ4Wm5y4bunfh4/WvpOz6Sl2R
  xFdHaxh3a3by/ZPkPQ/CFp4LZsNWlJ4Xg4XOVu/yFv0AYvUiCVToZRdOQbngT0aX
  qhvIuG5iXmmxX9sqAn78bMrzQdjt0Oj8P2FI7bADFB0QDksZ4LtO7IZl/zbzXmcC
  C52GVWH9ejjt/uIZALdvoVBidXQ8oPrIJZK0bnoix/geoeOy3ZExqysdBP+lSgQ3
  6YWkMyv94tZVNHwZpEpox7Ko07fKoZOI68GXvIz5HdkihCR0xwQ9aqkpk8zruFvh
  /l8lqjRYyMEjVJ0bmBHDOJx+PYZspQ9AhnwC9FwCTyjLrnGfDzrIM/4RJTXq/LrF
  YD3ZfBjVsqnTdXgDciLKOsMf7yzlLqn6niy2UUb9rwPW6mBo6oUWNmuF6R7As93E
  JNyAKoFBbZQ+yODJgUEAnl6/f8UImKIYLEJAs/lvOCdLToD0PYFH4Ih86hzOtXVc
  US4cK38acijnALXRdMbX5J+tB5O2UzU1/Dfkw/ZdFr4hc96SCvigY2q8lpJqPvi8
  ZVWb3vUNiSYE/CUapiVpy8JtynziWV+XrOvvLsi81xtZPCvM8hnIk2snYxnP/Okm
  +Mpxm3+T/jRnhE6Z6/yzeAkzcLpmpnbtG3PrGqUNxCITIJRWCk4sbE6x/c+cCbqi
  M+2HAgMBAAGjYzBhMB0GA1UdDgQWBBTdBAkHovV6fVJTEpKV7jiAJQ2mWTAPBgNV
  HRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFN0ECQei9Xp9UlMSkpXuOIAlDaZZMA4G
  A1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOCAgEAIBgRlCn7Jp0cHh5wYfGV
  cpNxJK1ok1iOMq8bs3AD/CUrdIWQPXhq9LmLpZc7tRiRux6n+UBbkflVma8eEdBc
  Hadm47GUBwwyOabqG7B52B2ccETjit3E+ZUfijhDPwGFpUenPUayvOUiaPd7nNgs
  PgohyC0zrL/FgZkxdMF1ccW+sfAjRfSda/wZY52jvATGGAslu1OJD7OAUN5F7kR/
  q5R4ZJjT9ijdh9hwZXT7DrkT66cPYakylszeu+1jTBi7qUD3oFRuIIhxdRjqerQ0
  cuAjJ3dctpDqhiVAq+8zD8ufgr6iIPv2tS0a5sKFsXQP+8hlAqRSAUfdSSLBv9jr
  a6x+3uxjMxW3IwiPxg+NQVrdjsW5j+VFP3jbutIbQLH+cU0/4IGiul607BXgk90I
  H37hVZkLId6Tngr75qNJvTYw/ud3sqB1l7UtgYgXZSD32pAAn8lSzDLKNXz1PQ/Y
  K9f1JmzJBjSWFupwWRoyeXkLtoh/D1JIPb9s2KJELtFOt3JY04kTlf5Eq/jXixtu
  nLwsoFvVagCvXzfh1foQC5ichucmj87w7G6KVwuA406ywKBjYZC6VWg3dGq2ktuf
  oYYitmUnDuy2n0Jg5GfCtdpBC8TTi2EbvPofkSvXRAdeuims2cXp71NIWuuA8ShY
  Ic2wBlX7Jz9TkHCpBB5XJ7k=
  -----END CERTIFICATE-----

  ### Staat der Nederlanden

  === /C=NL/O=Staat der Nederlanden/CN=Staat der Nederlanden EV Root CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 10000013 (0x98968d)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Dec  8 11:19:29 2010 GMT
              Not After : Dec  8 11:10:28 2022 GMT
          Subject: C=NL, O=Staat der Nederlanden, CN=Staat der Nederlanden EV Root CA
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  FE:AB:00:90:98:9E:24:FC:A9:CC:1A:8A:FB:27:B8:BF:30:6E:A8:3B
  SHA1 Fingerprint=76:E2:7E:C1:4F:DB:82:C1:C0:A6:75:B5:05:BE:3D:29:B4:ED:DB:BB
  SHA256 Fingerprint=4D:24:91:41:4C:FE:95:67:46:EC:4C:EF:A6:CF:6F:72:E2:8A:13:29:43:2F:9D:8A:90:7A:C4:CB:5D:AD:C1:5A
  -----BEGIN CERTIFICATE-----
  MIIFcDCCA1igAwIBAgIEAJiWjTANBgkqhkiG9w0BAQsFADBYMQswCQYDVQQGEwJO
  TDEeMBwGA1UECgwVU3RhYXQgZGVyIE5lZGVybGFuZGVuMSkwJwYDVQQDDCBTdGFh
  dCBkZXIgTmVkZXJsYW5kZW4gRVYgUm9vdCBDQTAeFw0xMDEyMDgxMTE5MjlaFw0y
  MjEyMDgxMTEwMjhaMFgxCzAJBgNVBAYTAk5MMR4wHAYDVQQKDBVTdGFhdCBkZXIg
  TmVkZXJsYW5kZW4xKTAnBgNVBAMMIFN0YWF0IGRlciBOZWRlcmxhbmRlbiBFViBS
  b290IENBMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA48d+ifkkSzrS
  M4M1LGns3Amk41GoJSt5uAg94JG6hIXGhaTK5skuU6TJJB79VWZxXSzFYGgEt9nC
  UiY4iKTWO0Cmws0/zZiTs1QUWJZV1VD+hq2kY39ch/aO5ieSZxeSAgMs3NZmdO3d
  Z//BYY1jTw+bbRcwJu+r0h8QoPnFfxZpgQNH7R5ojXKhTbImxrpsX23Wr9GxE46p
  rfNeaXUmGD5BKyF/7otdBwadQ8QpCiv8Kj6GyzyDOvnJDdrFmeK8eEEzduG/L13l
  pJhQDBXd4Pqcfzho0LKmeqfRMb1+ilgnQ7O6M5HTp5gVXJrm0w912fxBmJc+qiXb
  j5IusHsMX/FjqTf5m3VpTCgmJdrV8hJwRVXj33NeN/UhbJCONVrJ0yPr08C+eKxC
  KFhmpUZtcALXEPlLVPxdhkqHz3/KRawRWrUgUY0viEeXOcDPusBCAUCZSCELa6fS
  /ZbV0b5GnUngC6agIk440ME8MLxwjyx1zNDFjFE7PZQIZCZhfbnDZY8UnCHQqv0X
  cgOPvZuM5l5Tnrmd74K74bzickFbIZTTRTeU0d8JOV3nI6qaHcptqAqGhYqCvkIH
  1vI4gnPah1vlPNOePqc7nvQDs/nxfRN0Av+7oeX6AHkcpmZBiFxgV6YuCcS6/ZrP
  px9Aw7vMWgpVSzs4dlG4Y4uElBbmVvMCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB
  /zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFP6rAJCYniT8qcwaivsnuL8wbqg7
  MA0GCSqGSIb3DQEBCwUAA4ICAQDPdyxuVr5Os7aEAJSrR8kN0nbHhp8dB9O2tLsI
  eK9p0gtJ3jPFrK3CiAJ9Brc1AsFgyb/E6JTe1NOpEyVa/m6irn0F3H3zbPB+po3u
  2dfOWBfoqSmuc0iH55vKbimhZF8ZE/euBhD/UcabTVUlT5OZEAFTdfETzsemQUHS
  v4ilf0X8rLiltTMMgsT7B/Zq5SWEXwbKwYY5EdtYzXc7LMJMD16a4/CrPmEbUCTC
  wPTxGfARKbalGAKb12NMcIxHowNDXLldRqANb/9Zjr7dn3LDWyvfjFvO5QxGbJKy
  CqNMVEIYFRIYvdr8unRu/8G2oGTYqV9Vrp9canaW2HNnh/tNf1zuacpzEPuKqf2e
  vTY4SUmH9A4U8OmHuD+nT3pajnnUk+S7aFKErGzp85hwVXIy+TSrK0m1zSBi5Dp6
  Z2Orltxtrpfs/J92VoguZs9btsmksNcFuuEnL5O7Jiqik7Ab846+HUCjuTaPPoIa
  Gl6I6lD4WeKDRikL40Rc4ZW2aZCaFG+XroHPaO+Zmr615+F/+PoTRxZMzG0IQOeL
  eG9QgkRQP2YGiqtDhFZKDyAthg710tvSeopLzaXoTvFeJiUBWSOgftL2fiFX1ye8
  FVdMpEbB4IMeDExNH08GGeL5qPQ6gqGyeUN51q1veieQA6TqJIc/2b3Z6fJfUEkc
  7uzXLg==
  -----END CERTIFICATE-----

  ### Starfield Technologies, Inc.

  === /C=US/O=Starfield Technologies, Inc./OU=Starfield Class 2 Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 0 (0x0)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Jun 29 17:39:16 2004 GMT
              Not After : Jun 29 17:39:16 2034 GMT
          Subject: C=US, O=Starfield Technologies, Inc., OU=Starfield Class 2 Certification Authority
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  BF:5F:B7:D1:CE:DD:1F:86:F4:5B:55:AC:DC:D7:10:C2:0E:A9:88:E7
              X509v3 Authority Key Identifier:
                  keyid:BF:5F:B7:D1:CE:DD:1F:86:F4:5B:55:AC:DC:D7:10:C2:0E:A9:88:E7
                  DirName:/C=US/O=Starfield Technologies, Inc./OU=Starfield Class 2 Certification Authority
                  serial:00

              X509v3 Basic Constraints:
                  CA:TRUE
  SHA1 Fingerprint=AD:7E:1C:28:B0:64:EF:8F:60:03:40:20:14:C3:D0:E3:37:0E:B5:8A
  SHA256 Fingerprint=14:65:FA:20:53:97:B8:76:FA:A6:F0:A9:95:8E:55:90:E4:0F:CC:7F:AA:4F:B7:C2:C8:67:75:21:FB:5F:B6:58
  -----BEGIN CERTIFICATE-----
  MIIEDzCCAvegAwIBAgIBADANBgkqhkiG9w0BAQUFADBoMQswCQYDVQQGEwJVUzEl
  MCMGA1UEChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjEyMDAGA1UECxMp
  U3RhcmZpZWxkIENsYXNzIDIgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDQw
  NjI5MTczOTE2WhcNMzQwNjI5MTczOTE2WjBoMQswCQYDVQQGEwJVUzElMCMGA1UE
  ChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjEyMDAGA1UECxMpU3RhcmZp
  ZWxkIENsYXNzIDIgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggEgMA0GCSqGSIb3
  DQEBAQUAA4IBDQAwggEIAoIBAQC3Msj+6XGmBIWtDBFk385N78gDGIc/oav7PKaf
  8MOh2tTYbitTkPskpD6E8J7oX+zlJ0T1KKY/e97gKvDIr1MvnsoFAZMej2YcOadN
  +lq2cwQlZut3f+dZxkqZJRRU6ybH838Z1TBwj6+wRir/resp7defqgSHo9T5iaU0
  X9tDkYI22WY8sbi5gv2cOj4QyDvvBmVmepsZGD3/cVE8MC5fvj13c7JdBmzDI1aa
  K4UmkhynArPkPw2vCHmCuDY96pzTNbO8acr1zJ3o/WSNF4Azbl5KXZnJHoe0nRrA
  1W4TNSNe35tfPe/W93bC6j67eA0cQmdrBNj41tpvi/JEoAGrAgEDo4HFMIHCMB0G
  A1UdDgQWBBS/X7fRzt0fhvRbVazc1xDCDqmI5zCBkgYDVR0jBIGKMIGHgBS/X7fR
  zt0fhvRbVazc1xDCDqmI56FspGowaDELMAkGA1UEBhMCVVMxJTAjBgNVBAoTHFN0
  YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xMjAwBgNVBAsTKVN0YXJmaWVsZCBD
  bGFzcyAyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5ggEAMAwGA1UdEwQFMAMBAf8w
  DQYJKoZIhvcNAQEFBQADggEBAAWdP4id0ckaVaGsafPzWdqbAYcaT1epoXkJKtv3
  L7IezMdeatiDh6GX70k1PncGQVhiv45YuApnP+yz3SFmH8lU+nLMPUxA2IGvd56D
  eruix/U0F47ZEUD0/CwqTRV/p2JdLiXTAAsgGh1o+Re49L2L7ShZ3U0WixeDyLJl
  xy16paq8U4Zt3VekyvggQQto8PT7dL5WXXp59fkdheMtlb71cZBDzI0fmgAKhynp
  VSJYACPq4xJDKVtHCN2MQWplBqjlIapBtJUhlbl90TSrE9atvNziPTnNvT51cKEY
  WQPJIrSPnNVeKtelttQKbfi3QBFGmh95DmK/D5fs4C8fF5Q=
  -----END CERTIFICATE-----
  === /C=US/ST=Arizona/L=Scottsdale/O=Starfield Technologies, Inc./CN=Starfield Root Certificate Authority - G2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 0 (0x0)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Sep  1 00:00:00 2009 GMT
              Not After : Dec 31 23:59:59 2037 GMT
          Subject: C=US, ST=Arizona, L=Scottsdale, O=Starfield Technologies, Inc., CN=Starfield Root Certificate Authority - G2
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  7C:0C:32:1F:A7:D9:30:7F:C4:7D:68:A3:62:A8:A1:CE:AB:07:5B:27
  SHA1 Fingerprint=B5:1C:06:7C:EE:2B:0C:3D:F8:55:AB:2D:92:F4:FE:39:D4:E7:0F:0E
  SHA256 Fingerprint=2C:E1:CB:0B:F9:D2:F9:E1:02:99:3F:BE:21:51:52:C3:B2:DD:0C:AB:DE:1C:68:E5:31:9B:83:91:54:DB:B7:F5
  -----BEGIN CERTIFICATE-----
  MIID3TCCAsWgAwIBAgIBADANBgkqhkiG9w0BAQsFADCBjzELMAkGA1UEBhMCVVMx
  EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT
  HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xMjAwBgNVBAMTKVN0YXJmaWVs
  ZCBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAw
  MFoXDTM3MTIzMTIzNTk1OVowgY8xCzAJBgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6
  b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFyZmllbGQgVGVj
  aG5vbG9naWVzLCBJbmMuMTIwMAYDVQQDEylTdGFyZmllbGQgUm9vdCBDZXJ0aWZp
  Y2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC
  ggEBAL3twQP89o/8ArFvW59I2Z154qK3A2FWGMNHttfKPTUuiUP3oWmb3ooa/RMg
  nLRJdzIpVv257IzdIvpy3Cdhl+72WoTsbhm5iSzchFvVdPtrX8WJpRBSiUZV9Lh1
  HOZ/5FSuS/hVclcCGfgXcVnrHigHdMWdSL5stPSksPNkN3mSwOxGXn/hbVNMYq/N
  Hwtjuzqd+/x5AJhhdM8mgkBj87JyahkNmcrUDnXMN/uLicFZ8WJ/X7NfZTD4p7dN
  dloedl40wOiWVpmKs/B/pM293DIxfJHP4F8R+GuqSVzRmZTRouNjWwl2tVZi4Ut0
  HZbUJtQIBFnQmA4O5t78w+wfkPECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAO
  BgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFHwMMh+n2TB/xH1oo2Kooc6rB1snMA0G
  CSqGSIb3DQEBCwUAA4IBAQARWfolTwNvlJk7mh+ChTnUdgWUXuEok21iXQnCoKjU
  sHU48TRqneSfioYmUeYs0cYtbpUgSpIB7LiKZ3sx4mcujJUDJi5DnUox9g61DLu3
  4jd/IroAow57UvtruzvE03lRTs2Q9GcHGcg8RnoNAX3FWOdt5oUwF5okxBDgBPfg
  8n/Uqgr/Qh037ZTlZFkSIHc40zI+OIF1lnP6aI+xy84fxez6nH7PfrHxBy22/L/K
  pL/QlwVKvOoYKAKQvVR4CSFx09F9HdkWsKlhPdAKACL8x3vLCWRFCztAgfd9fDL1
  mMpYjn0q7pBZc2T5NnReJaH1ZgUufzkVqSr7UIuOhWn0
  -----END CERTIFICATE-----
  === /C=US/ST=Arizona/L=Scottsdale/O=Starfield Technologies, Inc./CN=Starfield Services Root Certificate Authority - G2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 0 (0x0)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Sep  1 00:00:00 2009 GMT
              Not After : Dec 31 23:59:59 2037 GMT
          Subject: C=US, ST=Arizona, L=Scottsdale, O=Starfield Technologies, Inc., CN=Starfield Services Root Certificate Authority - G2
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  9C:5F:00:DF:AA:01:D7:30:2B:38:88:A2:B8:6D:4A:9C:F2:11:91:83
  SHA1 Fingerprint=92:5A:8F:8D:2C:6D:04:E0:66:5F:59:6A:FF:22:D8:63:E8:25:6F:3F
  SHA256 Fingerprint=56:8D:69:05:A2:C8:87:08:A4:B3:02:51:90:ED:CF:ED:B1:97:4A:60:6A:13:C6:E5:29:0F:CB:2A:E6:3E:DA:B5
  -----BEGIN CERTIFICATE-----
  MIID7zCCAtegAwIBAgIBADANBgkqhkiG9w0BAQsFADCBmDELMAkGA1UEBhMCVVMx
  EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT
  HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xOzA5BgNVBAMTMlN0YXJmaWVs
  ZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5
  MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRAwDgYD
  VQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFy
  ZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTswOQYDVQQDEzJTdGFyZmllbGQgU2Vy
  dmljZXMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZI
  hvcNAQEBBQADggEPADCCAQoCggEBANUMOsQq+U7i9b4Zl1+OiFOxHz/Lz58gE20p
  OsgPfTz3a3Y4Y9k2YKibXlwAgLIvWX/2h/klQ4bnaRtSmpDhcePYLQ1Ob/bISdm2
  8xpWriu2dBTrz/sm4xq6HZYuajtYlIlHVv8loJNwU4PahHQUw2eeBGg6345AWh1K
  Ts9DkTvnVtYAcMtS7nt9rjrnvDH5RfbCYM8TWQIrgMw0R9+53pBlbQLPLJGmpufe
  hRhJfGZOozptqbXuNC66DQO4M99H67FrjSXZm86B0UVGMpZwh94CDklDhbZsc7tk
  6mFBrMnUVN+HL8cisibMn1lUaJ/8viovxFUcdUBgF4UCVTmLfwUCAwEAAaNCMEAw
  DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFJxfAN+q
  AdcwKziIorhtSpzyEZGDMA0GCSqGSIb3DQEBCwUAA4IBAQBLNqaEd2ndOxmfZyMI
  bw5hyf2E3F/YNoHN2BtBLZ9g3ccaaNnRbobhiCPPE95Dz+I0swSdHynVv/heyNXB
  ve6SbzJ08pGCL72CQnqtKrcgfU28elUSwhXqvfdqlS5sdJ/PHLTyxQGjhdByPq1z
  qwubdQxtRbeOlKyWN7Wg0I8VRw7j6IPdj/3vQQF3zCepYoUz8jcI73HPdwbeyBkd
  iEDPfUYd/x7H4c7/I9vG+o1VTqkC50cRRj70/b17KSa7qWFiNyi2LSr2EIZkyXCn
  0q23KXB56jzaYyWf/Wi3MOxw+3WKt21gZ7IeyLnp2KhvAotnDU0mV3HaIPzBSlCN
  sSi6
  -----END CERTIFICATE-----

  ### SwissSign AG

  === /C=CH/O=SwissSign AG/CN=SwissSign Gold CA - G2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              bb:40:1c:43:f5:5e:4f:b0
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Oct 25 08:30:35 2006 GMT
              Not After : Oct 25 08:30:35 2036 GMT
          Subject: C=CH, O=SwissSign AG, CN=SwissSign Gold CA - G2
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  5B:25:7B:96:A4:65:51:7E:B8:39:F3:C0:78:66:5E:E8:3A:E7:F0:EE
              X509v3 Authority Key Identifier:
                  keyid:5B:25:7B:96:A4:65:51:7E:B8:39:F3:C0:78:66:5E:E8:3A:E7:F0:EE

              X509v3 Certificate Policies:
                  Policy: 2.16.756.1.89.1.2.1.1
                    CPS: http://repository.swisssign.com/

  SHA1 Fingerprint=D8:C5:38:8A:B7:30:1B:1B:6E:D4:7A:E6:45:25:3A:6F:9F:1A:27:61
  SHA256 Fingerprint=62:DD:0B:E9:B9:F5:0A:16:3E:A0:F8:E7:5C:05:3B:1E:CA:57:EA:55:C8:68:8F:64:7C:68:81:F2:C8:35:7B:95
  -----BEGIN CERTIFICATE-----
  MIIFujCCA6KgAwIBAgIJALtAHEP1Xk+wMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV
  BAYTAkNIMRUwEwYDVQQKEwxTd2lzc1NpZ24gQUcxHzAdBgNVBAMTFlN3aXNzU2ln
  biBHb2xkIENBIC0gRzIwHhcNMDYxMDI1MDgzMDM1WhcNMzYxMDI1MDgzMDM1WjBF
  MQswCQYDVQQGEwJDSDEVMBMGA1UEChMMU3dpc3NTaWduIEFHMR8wHQYDVQQDExZT
  d2lzc1NpZ24gR29sZCBDQSAtIEcyMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC
  CgKCAgEAr+TufoskDhJuqVAtFkQ7kpJcyrhdhJJCEyq8ZVeCQD5XJM1QiyUqt2/8
  76LQwB8CJEoTlo8jE+YoWACjR8cGp4QjK7u9lit/VcyLwVcfDmJlD909Vopz2q5+
  bbqBHH5CjCA12UNNhPqE21Is8w4ndwtrvxEvcnifLtg+5hg3Wipy+dpikJKVyh+c
  6bM8K8vzARO/Ws/BtQpgvd21mWRTuKCWs2/iJneRjOBiEAKfNA+k1ZIzUd6+jbqE
  emA8atufK+ze3gE/bk3lUIbLtK/tREDFylqM2tIrfKjuvqblCqoOpd8FUrdVxyJd
  MmqXl2MT28nbeTZ7hTpKxVKJ+STnnXepgv9VHKVxaSvRAiTysybUa9oEVeXBCsdt
  MDeQKuSeFDNeFhdVxVu1yzSJkvGdJo+hB9TGsnhQ2wwMC3wLjEHXuendjIj3o02y
  MszYF9rNt85mndT9Xv+9lz4pded+p2JYryU0pUHHPbwNUMoDAw8IWh+Vc3hiv69y
  FGkOpeUDDniOJihC8AcLYiAQZzlG+qkDzAQ4embvIIO1jEpWjpEA/I5cgt6IoMPi
  aG59je883WX0XaxR7ySArqpWl2/5rX3aYT+YdzylkbYcjCbaZaIJbcHiVOO5ykxM
  gI93e2CaHt+28kgeDrpOVG2Y4OGiGqJ3UM/EY5LsRxmd6+ZrzsECAwEAAaOBrDCB
  qTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUWyV7
  lqRlUX64OfPAeGZe6Drn8O4wHwYDVR0jBBgwFoAUWyV7lqRlUX64OfPAeGZe6Drn
  8O4wRgYDVR0gBD8wPTA7BglghXQBWQECAQEwLjAsBggrBgEFBQcCARYgaHR0cDov
  L3JlcG9zaXRvcnkuc3dpc3NzaWduLmNvbS8wDQYJKoZIhvcNAQEFBQADggIBACe6
  45R88a7A3hfm5djV9VSwg/S7zV4Fe0+fdWavPOhWfvxyeDgD2StiGwC5+OlgzczO
  UYrHUDFu4Up+GC9pWbY9ZIEr44OE5iKHjn3g7gKZYbge9LgriBIWhMIxkziWMaa5
  O1M/wySTVltpkuzFwbs4AOPsF6m43Md8AYOfMke6UiI0HTJ6CVanfCU2qT1L2sCC
  bwq7EsiHSycR+R4tx5M/nttfJmtS2S6K8RTGRI0Vqbe/vd6mGu6uLftIdxf+u+yv
  GPUqUfA5hJeVbG4bwyvEdGB5JbAKJ9/fXtI5z0V9QkvfsywexcZdylU6oJxpmo/a
  77KwPJ+HbBIrZXAVUjEaJM9vMSNQH4xPjyPDdEFjHFWoFN0+4FFQz/EbMFYOkrCC
  hdiDyyJkvC24JdVUorgG6q2SpCSgwYa1ShNqR88uC1aVVMvOmttqtKay20EIhid3
  92qgQmwLOM7XdVAyksLfKzAiSNDVQTglXaTpXZ/GlHXQRf0wl0OPkKsKx4ZzYEpp
  Ld6leNcG2mqeSz53OiATIgHQv2ieY2BrNU0LbbqhPcCT4H8js1WtciVORvnSFu+w
  ZMEBnunKoGqYDs/YYPIvSbjkQuE4NRb0yG5P94FW6LqjviOvrv1vA+ACOzB2+htt
  Qc8Bsem4yWb02ybzOqR08kkkW8mw0FfB+j564ZfJ
  -----END CERTIFICATE-----
  === /C=CH/O=SwissSign AG/CN=SwissSign Silver CA - G2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 5700383053117599563 (0x4f1bd42f54bb2f4b)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Oct 25 08:32:46 2006 GMT
              Not After : Oct 25 08:32:46 2036 GMT
          Subject: C=CH, O=SwissSign AG, CN=SwissSign Silver CA - G2
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  17:A0:CD:C1:E4:41:B6:3A:5B:3B:CB:45:9D:BD:1C:C2:98:FA:86:58
              X509v3 Authority Key Identifier:
                  keyid:17:A0:CD:C1:E4:41:B6:3A:5B:3B:CB:45:9D:BD:1C:C2:98:FA:86:58

              X509v3 Certificate Policies:
                  Policy: 2.16.756.1.89.1.3.1.1
                    CPS: http://repository.swisssign.com/

  SHA1 Fingerprint=9B:AA:E5:9F:56:EE:21:CB:43:5A:BE:25:93:DF:A7:F0:40:D1:1D:CB
  SHA256 Fingerprint=BE:6C:4D:A2:BB:B9:BA:59:B6:F3:93:97:68:37:42:46:C3:C0:05:99:3F:A9:8F:02:0D:1D:ED:BE:D4:8A:81:D5
  -----BEGIN CERTIFICATE-----
  MIIFvTCCA6WgAwIBAgIITxvUL1S7L0swDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UE
  BhMCQ0gxFTATBgNVBAoTDFN3aXNzU2lnbiBBRzEhMB8GA1UEAxMYU3dpc3NTaWdu
  IFNpbHZlciBDQSAtIEcyMB4XDTA2MTAyNTA4MzI0NloXDTM2MTAyNTA4MzI0Nlow
  RzELMAkGA1UEBhMCQ0gxFTATBgNVBAoTDFN3aXNzU2lnbiBBRzEhMB8GA1UEAxMY
  U3dpc3NTaWduIFNpbHZlciBDQSAtIEcyMIICIjANBgkqhkiG9w0BAQEFAAOCAg8A
  MIICCgKCAgEAxPGHf9N4Mfc4yfjDmUO8x/e8N+dOcbpLj6VzHVxumK4DV644N0Mv
  Fz0fyM5oEMF4rhkDKxD6LHmD9ui5aLlV8gREpzn5/ASLHvGiTSf5YXu6t+WiE7br
  YT7QbNHm+/pe7R20nqA1W6GSy/BJkv6FCgU+5tkL4k+73JU3/JHpMjUi0R86TieF
  nbAVlDLaYQ1HTWBCrpJH6INaUFjpiou5XaHc3ZlKHzZnu0jkg7Y360g6rw9njxcH
  6ATK72oxh9TAtvmUcXtnZLi2kUpCe2UuMGoM9ZDulebyzYLs2aFK7PayS+VFheZt
  eJMELpyCbTapxDFkH4aDCyr0NQp4yVXPQbBH6TCfmb5hqAaEuSh6XzjZG6k4sIN/
  c8HDO0gqgg8hm7jMqDXDhBuDsz6+pJVpATqJAHgE2cn0mRmrVn5bi4Y5FZGkECwJ
  MoBgs5PAKrYYC51+jUnyEEp/+dVGLxmSo5mnJqy7jDzmDrxHB9xzUfFwZC8I+bRH
  HTBsROopN4WSaGa8gzj+ezku01DwH/teYLappvonQfGbGHLy9YR0SslnxFSuSGTf
  jNFusB3hB48IHpmccelM2KX3RxIfdNFRnobzwqIjQAtz20um53MGjMGg6cFZrEb6
  5i/4z3GcRm25xBWNOHkDRUjvxF3XCO6HOSKGsg0PWEP3calILv3q1h8CAwEAAaOB
  rDCBqTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU
  F6DNweRBtjpbO8tFnb0cwpj6hlgwHwYDVR0jBBgwFoAUF6DNweRBtjpbO8tFnb0c
  wpj6hlgwRgYDVR0gBD8wPTA7BglghXQBWQEDAQEwLjAsBggrBgEFBQcCARYgaHR0
  cDovL3JlcG9zaXRvcnkuc3dpc3NzaWduLmNvbS8wDQYJKoZIhvcNAQEFBQADggIB
  AHPGgeAn0i0P4JUw4ppBf1AsX19iYamGamkYDHRJ1l2E6kFSGG9YrVBWIGrGvShp
  WJHckRE1qTodvBqlYJ7YH39FkWnZfrt4csEGDyrOj4VwYaygzQu4OSlWhDJOhrs9
  xCrZ1x9y7v5RoSJBsXECYxqCsGKrXlcSH9/L3XWgwF15kIwb4FDm3jH+mHtwX6WQ
  2K34ArZv02DdQEsixT2tOnqfGhpHkXkzuoLcMmkDlm4fS/Bx/uNncqCxv1yL5PqZ
  IseEuRuNI5c/7SXgz2W79WEE790eslpBIlqhn10s6FvJbakMDHiqYMZWjwFaDGi8
  aRl5xB9+lwW/xekkUV7U1UtT7dkjWjYDZaPBA61BMPNGG4WQr2W11bHkFlt4dR2X
  em1ZqSqPe97Dh4kQmUlzeMg9vVE1dCrV8X5pGyq7O70luJpaPXJhkGaH7gzWTdQR
  dAtq/gsD/KNVV4n+SsuuWxcFyPKNIzFTONItaj+CuY0IavdeQXRuwxF+B6wpYJE/
  OMpXEA29MC/HpeZBoNquBYeaoKRlbEwJDIm6uNO5wJOKMPqN5ZprFQFOZ6raYlY+
  hAhm0sQ2fac+EPyI4NSA5QC9qvNOBqN6avlicuMJT+ubDgEj8Z+7fNzcbBGXJbLy
  tGMU0gYqZ4yD9c7qB9iaah7s5Aq7KkzrCWA5zspi2C5u
  -----END CERTIFICATE-----

  ### T-Systems Enterprise Services GmbH

  === /C=DE/O=T-Systems Enterprise Services GmbH/OU=T-Systems Trust Center/CN=T-TeleSec GlobalRoot Class 2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 1 (0x1)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Oct  1 10:40:14 2008 GMT
              Not After : Oct  1 23:59:59 2033 GMT
          Subject: C=DE, O=T-Systems Enterprise Services GmbH, OU=T-Systems Trust Center, CN=T-TeleSec GlobalRoot Class 2
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  BF:59:20:36:00:79:A0:A0:22:6B:8C:D5:F2:61:D2:B8:2C:CB:82:4A
  SHA1 Fingerprint=59:0D:2D:7D:88:4F:40:2E:61:7E:A5:62:32:17:65:CF:17:D8:94:E9
  SHA256 Fingerprint=91:E2:F5:78:8D:58:10:EB:A7:BA:58:73:7D:E1:54:8A:8E:CA:CD:01:45:98:BC:0B:14:3E:04:1B:17:05:25:52
  -----BEGIN CERTIFICATE-----
  MIIDwzCCAqugAwIBAgIBATANBgkqhkiG9w0BAQsFADCBgjELMAkGA1UEBhMCREUx
  KzApBgNVBAoMIlQtU3lzdGVtcyBFbnRlcnByaXNlIFNlcnZpY2VzIEdtYkgxHzAd
  BgNVBAsMFlQtU3lzdGVtcyBUcnVzdCBDZW50ZXIxJTAjBgNVBAMMHFQtVGVsZVNl
  YyBHbG9iYWxSb290IENsYXNzIDIwHhcNMDgxMDAxMTA0MDE0WhcNMzMxMDAxMjM1
  OTU5WjCBgjELMAkGA1UEBhMCREUxKzApBgNVBAoMIlQtU3lzdGVtcyBFbnRlcnBy
  aXNlIFNlcnZpY2VzIEdtYkgxHzAdBgNVBAsMFlQtU3lzdGVtcyBUcnVzdCBDZW50
  ZXIxJTAjBgNVBAMMHFQtVGVsZVNlYyBHbG9iYWxSb290IENsYXNzIDIwggEiMA0G
  CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCqX9obX+hzkeXaXPSi5kfl82hVYAUd
  AqSzm1nzHoqvNK38DcLZSBnuaY/JIPwhqgcZ7bBcrGXHX+0CfHt8LRvWurmAwhiC
  FoT6ZrAIxlQjgeTNuUk/9k9uN0goOA/FvudocP05l03Sx5iRUKrERLMjfTlH6VJi
  1hKTXrcxlkIF+3anHqP1wvzpesVsqXFP6st4vGCvx9702cu+fjOlbpSD8DT6Iavq
  jnKgP6TeMFvvhk1qlVtDRKgQFRzlAVfFmPHmBiiRqiDFt1MmUUOyCxGVWOHAD3bZ
  wI18gfNycJ5v/hqO2V81xrJvNHy+SE/iWjnX2J14np+GPgNeGYtEotXHAgMBAAGj
  QjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBS/
  WSA2AHmgoCJrjNXyYdK4LMuCSjANBgkqhkiG9w0BAQsFAAOCAQEAMQOiYQsfdOhy
  NsZt+U2e+iKo4YFWz827n+qrkRk4r6p8FU3ztqONpfSO9kSpp+ghla0+AGIWiPAC
  uvxhI+YzmzB6azZie60EI4RYZeLbK4rnJVM3YlNfvNoBYimipidx5joifsFvHZVw
  IEoHNN/q/xWA5brXethbdXwFeilHfkCoMRN3zUA7tFFHei4R40cR3p1m0IvVVGb6
  g1XqfMIpiRvpb7PO4gWEyS8+eIVibslfwXhjdFjASBgMmTnrpMwatXlajRWc2BQN
  9noHV8cigwUtPJslJj0Ys6lDfMjIq2SPDqO/nBudMNva0Bkuqjzx+zOAduTNrRlP
  BSeOE6Fuwg==
  -----END CERTIFICATE-----
  === /C=DE/O=T-Systems Enterprise Services GmbH/OU=T-Systems Trust Center/CN=T-TeleSec GlobalRoot Class 3
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 1 (0x1)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Oct  1 10:29:56 2008 GMT
              Not After : Oct  1 23:59:59 2033 GMT
          Subject: C=DE, O=T-Systems Enterprise Services GmbH, OU=T-Systems Trust Center, CN=T-TeleSec GlobalRoot Class 3
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  B5:03:F7:76:3B:61:82:6A:12:AA:18:53:EB:03:21:94:BF:FE:CE:CA
  SHA1 Fingerprint=55:A6:72:3E:CB:F2:EC:CD:C3:23:74:70:19:9D:2A:BE:11:E3:81:D1
  SHA256 Fingerprint=FD:73:DA:D3:1C:64:4F:F1:B4:3B:EF:0C:CD:DA:96:71:0B:9C:D9:87:5E:CA:7E:31:70:7A:F3:E9:6D:52:2B:BD
  -----BEGIN CERTIFICATE-----
  MIIDwzCCAqugAwIBAgIBATANBgkqhkiG9w0BAQsFADCBgjELMAkGA1UEBhMCREUx
  KzApBgNVBAoMIlQtU3lzdGVtcyBFbnRlcnByaXNlIFNlcnZpY2VzIEdtYkgxHzAd
  BgNVBAsMFlQtU3lzdGVtcyBUcnVzdCBDZW50ZXIxJTAjBgNVBAMMHFQtVGVsZVNl
  YyBHbG9iYWxSb290IENsYXNzIDMwHhcNMDgxMDAxMTAyOTU2WhcNMzMxMDAxMjM1
  OTU5WjCBgjELMAkGA1UEBhMCREUxKzApBgNVBAoMIlQtU3lzdGVtcyBFbnRlcnBy
  aXNlIFNlcnZpY2VzIEdtYkgxHzAdBgNVBAsMFlQtU3lzdGVtcyBUcnVzdCBDZW50
  ZXIxJTAjBgNVBAMMHFQtVGVsZVNlYyBHbG9iYWxSb290IENsYXNzIDMwggEiMA0G
  CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC9dZPwYiJvJK7genasfb3ZJNW4t/zN
  8ELg63iIVl6bmlQdTQyK9tPPcPRStdiTBONGhnFBSivwKixVA9ZIw+A5OO3yXDw/
  RLyTPWGrTs0NvvAgJ1gORH8EGoel15YUNpDQSXuhdfsaa3Ox+M6pCSzyU9XDFES4
  hqX2iys52qMzVNn6chr3IhUciJFrf2blw2qAsCTz34ZFiP0Zf3WHHx+xGwpzJFu5
  ZeAsVMhg02YXP+HMVDNzkQI6pn97djmiH5a2OK61yJN0HZ65tOVgnS9W0eDrXltM
  EnAMbEQgqxHY9Bn20pxSN+f6tsIxO0rUFJmtxxr1XV/6B7h8DR/Wgx6zAgMBAAGj
  QjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBS1
  A/d2O2GCahKqGFPrAyGUv/7OyjANBgkqhkiG9w0BAQsFAAOCAQEAVj3vlNW92nOy
  WL6ukK2YJ5f+AbGwUgC4TeQbIXQbfsDuXmkqJa9c1h3a0nnJ85cp4IaH3gRZD/FZ
  1GSFS5mvJQQeyUapl96Cshtwn5z2r3Ex3XsFpSzTucpH9sry9uetuUg/vBa3wW30
  6gmv7PO15wWeph6KU1HWk4HMdJP2udqmJQV0eVp+QD6CSyYRMG7hP0HHRwA11fXT
  91Q+gT3aSWqas+8QPebrb9HIIkfLzM8BMZLZGOMivgkeGj5asuRrDFR6fUNOuIml
  e9eiPZaGzPImNC1qkp2aGtAw4l1OBLBfiyB+d8E9lYLRRpo7PHi4b6HQDWSieB4p
  TpPDpFQUWw==
  -----END CERTIFICATE-----

  ### TAIWAN-CA

  === /C=TW/O=TAIWAN-CA/OU=Root CA/CN=TWCA Global Root CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 3262 (0xcbe)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jun 27 06:28:33 2012 GMT
              Not After : Dec 31 15:59:59 2030 GMT
          Subject: C=TW, O=TAIWAN-CA, OU=Root CA, CN=TWCA Global Root CA
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=9C:BB:48:53:F6:A4:F6:D3:52:A4:E8:32:52:55:60:13:F5:AD:AF:65
  SHA256 Fingerprint=59:76:90:07:F7:68:5D:0F:CD:50:87:2F:9F:95:D5:75:5A:5B:2B:45:7D:81:F3:69:2B:61:0A:98:67:2F:0E:1B
  -----BEGIN CERTIFICATE-----
  MIIFQTCCAymgAwIBAgICDL4wDQYJKoZIhvcNAQELBQAwUTELMAkGA1UEBhMCVFcx
  EjAQBgNVBAoTCVRBSVdBTi1DQTEQMA4GA1UECxMHUm9vdCBDQTEcMBoGA1UEAxMT
  VFdDQSBHbG9iYWwgUm9vdCBDQTAeFw0xMjA2MjcwNjI4MzNaFw0zMDEyMzExNTU5
  NTlaMFExCzAJBgNVBAYTAlRXMRIwEAYDVQQKEwlUQUlXQU4tQ0ExEDAOBgNVBAsT
  B1Jvb3QgQ0ExHDAaBgNVBAMTE1RXQ0EgR2xvYmFsIFJvb3QgQ0EwggIiMA0GCSqG
  SIb3DQEBAQUAA4ICDwAwggIKAoICAQCwBdvI64zEbooh745NnHEKH1Jw7W2CnJfF
  10xORUnLQEK1EjRsGcJ0pDFfhQKX7EMzClPSnIyOt7h52yvVavKOZsTuKwEHktSz
  0ALfUPZVr2YOy+BHYC8rMjk1Ujoog/h7FsYYuGLWRyWRzvAZEk2tY/XTP3VfKfCh
  MBwqoJimFb3u/Rk28OKRQ4/6ytYQJ0lM793B8YVwm8rqqFpD/G2Gb3PpN0Wp8DbH
  zIh1HrtsBv+baz4X7GGqcXzGHaL3SekVtTzWoWH1EfcFbx39Eb7QMAfCKbAJTibc
  46KokWofwpFFiFzlmLhxpRUZyXx1EcxwdE8tmx2RRP1WKKD+u4ZqyPpcC1jcxkt2
  yKsi2XMPpfRaAok/T54igu6idFMqPVMnaR1sjjIsZAAmY2E2TqNGtz99sy2sbZCi
  laLOz9qC5wc0GZbpuCGqKX6mOL6OKUohZnkfs8O1CWfe1tQHRvMq2uYiN2DLgbYP
  oA/pyJV/v1WRBXrPPRXAb94JlAGD1zQbzECl8LibZ9WYkTunhHiVJqRaCPgrdLQA
  BDzfuBSO6N+pjWxnkjMdwLfS7JLIvgm/LCkFbwJrnu+8vyq8W8BQj0FwcYeyTbcE
  qYSjMq+u7msXi7Kx/mzhkIyIqJdIzshNy/MGz19qCkKxHh53L46g5pIOBvwFItIm
  4TFRfTLcDwIDAQABoyMwITAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB
  /zANBgkqhkiG9w0BAQsFAAOCAgEAXzSBdu+WHdXltdkCY4QWwa6gcFGn90xHNcgL
  1yg9iXHZqjNB6hQbbCEAwGxCGX6faVsgQt+i0trEfJdLjbDorMjupWkEmQqSpqsn
  LhpNgb+E1HAerUf+/UqdM+DyucRFCCEK2mlpc3INvjT+lIutwx4116KD7+U4x6WF
  H6vPNOw/KP4M8VeGTslV9xzU2KV9Bnpv1d8Q34FOIWWxtuEXeZVFBs5fzNxGiWNo
  RI2T9GRwoD2dKAXDOXC4Ynsg/eTb6QihuJ49CcdP+yz4k3ZB3lLg4VfSnQO8d57+
  nile98FRYB/e2guyLXW3Q0iT5/Z5xoRdgFlglPx4mI88k1HtQJAH32RjJMtOcQWh
  15QaiDLxInQirqWm2BJpTGCjAu4r7NRjkgtevi92a6O2JryPA9gK8kxkRr05YuWW
  6zRjESjMlfGt7+/cgFhI6Uu46mWs6fyAtbXIRfmswZ/ZuepiiI7E8UuDEq3mi4TW
  nsLrgxifarsbJGAzcMzs9zLzXNl5fe+epP7JI8Mk7hWSsT2RTyaGvWZzJBPqpK5j
  wa19hAM8EHiGG3njxPPyBJUgriOCxLM6AGK/5jYk4Ve6xx6QddVfP5VhK8E7zeWz
  aGHQRiapIVJpLesux+t3zqY6tQMzT3bR51xUAV3LePTJDL/PEo4XLSNolOer/qmy
  KwbQBM0=
  -----END CERTIFICATE-----
  === /C=TW/O=TAIWAN-CA/OU=Root CA/CN=TWCA Root Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 1 (0x1)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Aug 28 07:24:33 2008 GMT
              Not After : Dec 31 15:59:59 2030 GMT
          Subject: C=TW, O=TAIWAN-CA, OU=Root CA, CN=TWCA Root Certification Authority
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  6A:38:5B:26:8D:DE:8B:5A:F2:4F:7A:54:83:19:18:E3:08:35:A6:BA
  SHA1 Fingerprint=CF:9E:87:6D:D3:EB:FC:42:26:97:A3:B5:A3:7A:A0:76:A9:06:23:48
  SHA256 Fingerprint=BF:D8:8F:E1:10:1C:41:AE:3E:80:1B:F8:BE:56:35:0E:E9:BA:D1:A6:B9:BD:51:5E:DC:5C:6D:5B:87:11:AC:44
  -----BEGIN CERTIFICATE-----
  MIIDezCCAmOgAwIBAgIBATANBgkqhkiG9w0BAQUFADBfMQswCQYDVQQGEwJUVzES
  MBAGA1UECgwJVEFJV0FOLUNBMRAwDgYDVQQLDAdSb290IENBMSowKAYDVQQDDCFU
  V0NBIFJvb3QgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDgwODI4MDcyNDMz
  WhcNMzAxMjMxMTU1OTU5WjBfMQswCQYDVQQGEwJUVzESMBAGA1UECgwJVEFJV0FO
  LUNBMRAwDgYDVQQLDAdSb290IENBMSowKAYDVQQDDCFUV0NBIFJvb3QgQ2VydGlm
  aWNhdGlvbiBBdXRob3JpdHkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB
  AQCwfnK4pAOU5qfeCTiRShFAh6d8WWQUe7UREN3+v9XAu1bihSX0NXIP+FPQQeFE
  AcK0HMMxQhZHhTMidrIKbw/lJVBPhYa+v5guEGcevhEFhgWQxFnQfHgQsIBct+HH
  K3XLfJ+utdGdIzdjp9xCoi2SBBtQwXu4PhvJVgSLL1KbralW6cH/ralYhzC2gfeX
  RfwZVzsrb+RH9JlF/h3x+JejiB03HFyP4HYlmlD4oFT/RJB2I9IyxsOrBr/8+7/z
  rX2SYgJbKdM1o5OaQ2RgXbL6Mv87BK9NQGr5x+PvI/1ry+UPizgN7gr8/g+YnzAx
  3WxSZfmLgb4i4RxYA7qRG4kHAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
  HRMBAf8EBTADAQH/MB0GA1UdDgQWBBRqOFsmjd6LWvJPelSDGRjjCDWmujANBgkq
  hkiG9w0BAQUFAAOCAQEAPNV3PdrfibqHDAhUaiBQkr6wQT25JmSDCi/oQMCXKCeC
  MErJk/9q56YAf4lCmtYR5VPOL8zy2gXE/uJQxDqGfczafhAJO5I1KlOy/usrBdls
  XebQ79NqZp4VKIV66IIArB6nCWlWQtNoURi+VJq/REG6Sb4gumlc7rh3zc5sH62D
  lhh9DrUUOYTxKOkto557HnpyWoOzeW/vtPzQCqVYT0bf+215WfKEIlKuD8z7fDvn
  aspHYcN6+NOSBB+4IIThNlQWx0DeO4pz3N/GCUzf7Nr/1FNCocnyYh0igzyXxfkZ
  YiesZSLX0zzG5Y6yU8xJzrww/nsOM5D77dIUkR8Hrw==
  -----END CERTIFICATE-----

  ### TeliaSonera

  === /O=TeliaSonera/CN=TeliaSonera Root CA v1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              95:be:16:a0:f7:2e:46:f1:7b:39:82:72:fa:8b:cd:96
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Oct 18 12:00:50 2007 GMT
              Not After : Oct 18 12:00:50 2032 GMT
          Subject: O=TeliaSonera, CN=TeliaSonera Root CA v1
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage:
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  F0:8F:59:38:00:B3:F5:8F:9A:96:0C:D5:EB:FA:7B:AA:17:E8:13:12
  SHA1 Fingerprint=43:13:BB:96:F1:D5:86:9B:C1:4E:6A:92:F6:CF:F6:34:69:87:82:37
  SHA256 Fingerprint=DD:69:36:FE:21:F8:F0:77:C1:23:A1:A5:21:C1:22:24:F7:22:55:B7:3E:03:A7:26:06:93:E8:A2:4B:0F:A3:89
  -----BEGIN CERTIFICATE-----
  MIIFODCCAyCgAwIBAgIRAJW+FqD3LkbxezmCcvqLzZYwDQYJKoZIhvcNAQEFBQAw
  NzEUMBIGA1UECgwLVGVsaWFTb25lcmExHzAdBgNVBAMMFlRlbGlhU29uZXJhIFJv
  b3QgQ0EgdjEwHhcNMDcxMDE4MTIwMDUwWhcNMzIxMDE4MTIwMDUwWjA3MRQwEgYD
  VQQKDAtUZWxpYVNvbmVyYTEfMB0GA1UEAwwWVGVsaWFTb25lcmEgUm9vdCBDQSB2
  MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMK+6yfwIaPzaSZVfp3F
  VRaRXP3vIb9TgHot0pGMYzHw7CTww6XScnwQbfQ3t+XmfHnqjLWCi65ItqwA3GV1
  7CpNX8GH9SBlK4GoRz6JI5UwFpB/6FcHSOcZrr9FZ7E3GwYq/t75rH2D+1665I+X
  Z75Ljo1kB1c4VWk0Nj0TSO9P4tNmHqTPGrdeNjPUtAa9GAH9d4RQAEX1jF3oI7x+
  /jXh7VB7qTCNGdMJjmhnXb88lxhTuylixcpecsHHltTbLaC0H2kD7OriUPEMPPCs
  81Mt8Bz17Ww5OXOAFshSsCPN4D7c3TxHoLs1iuKYaIu+5b9y7tL6pe0S7fyYGKkm
  dtwoSxAgHNN/Fnct7W+A90m7UwW7XWjH1Mh1Fj+JWov3F0fUTPHSiXk+TT2YqGHe
  Oh7S+F4D4MHJHIzTjU3TlTazN19jY5szFPAtJmtTfImMMsJu7D0hADnJoWjiUIMu
  sDor8zagrC/kb2HCUQk5PotTubtn2txTuXZZNp1D5SDgPTJghSJRt8czu90VL6R4
  pgd7gUY2BIbdeTXHlSw7sKMXNeVzH7RcWe/a6hBle3rQf5+ztCo3O3CLm1u5K7fs
  slESl1MpWtTwEhDcTwK7EpIvYtQ/aUN8Ddb8WHUBiJ1YFkveupD/RwGJBmr2X7KQ
  arMCpgKIv7NHfirZ1fpoeDVNAgMBAAGjPzA9MA8GA1UdEwEB/wQFMAMBAf8wCwYD
  VR0PBAQDAgEGMB0GA1UdDgQWBBTwj1k4ALP1j5qWDNXr+nuqF+gTEjANBgkqhkiG
  9w0BAQUFAAOCAgEAvuRcYk4k9AwI//DTDGjkk0kiP0Qnb7tt3oNmzqjMDfz1mgbl
  dxSR651Be5kqhOX//CHBXfDkH1e3damhXwIm/9fH907eT/j3HEbAek9ALCI18Bmx
  0GtnLLCo4MBANzX2hFxc469CeP6nyQ1Q6g2EdvZR74NTxnr/DlZJLo961gzmJ1Tj
  TQpgcmLNkQfWpb/ImWvtxBnmq0wROMVvMeJuScg/doAmAyYp4Db29iBT4xdwNBed
  Y2gea+zDTYa4EzAvXUYNR0PVG6pZDrlcjQZIrXSHX8f8MVRBE+LHIQ6e4B4N4cB7
  Q4WQxYpYxmUKeFfyxiMPAdkgS94P+5KFdSpcc41teyWRyu5FrgZLAMzTsVlQ2jqI
  OylDRl6XK1TOU2+NSueW+r9xDkKLfP0ooNBIytrEgUy7onOTJsjrDNYmiLbAJM+7
  vVvrdX3pCI6GMyx5dwlppYn8s3CQh3aP0yK7Qs69cwsgJirQmz1wHiRszYd2qReW
  t88NkvuOGKmYSdGe/mBEciG5Ge3C9THxOUiIkCR1VBatzvT4aRRkOfujuLpwQMcn
  HL/EVlP6Y2XQ8xwOFvVrhlhNGNTkDY6lnVuR3HYkUD/GKvvZt5y11ubQ2egZixVx
  SK236thZiNSQvxaz2emsWWFUyBy6ysHK4bkgTI86k4mloMy/0/Z1pHWWbVY=
  -----END CERTIFICATE-----

  ### The Go Daddy Group, Inc.

  === /C=US/O=The Go Daddy Group, Inc./OU=Go Daddy Class 2 Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 0 (0x0)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Jun 29 17:06:20 2004 GMT
              Not After : Jun 29 17:06:20 2034 GMT
          Subject: C=US, O=The Go Daddy Group, Inc., OU=Go Daddy Class 2 Certification Authority
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  D2:C4:B0:D2:91:D4:4C:11:71:B3:61:CB:3D:A1:FE:DD:A8:6A:D4:E3
              X509v3 Authority Key Identifier:
                  keyid:D2:C4:B0:D2:91:D4:4C:11:71:B3:61:CB:3D:A1:FE:DD:A8:6A:D4:E3
                  DirName:/C=US/O=The Go Daddy Group, Inc./OU=Go Daddy Class 2 Certification Authority
                  serial:00

              X509v3 Basic Constraints:
                  CA:TRUE
  SHA1 Fingerprint=27:96:BA:E6:3F:18:01:E2:77:26:1B:A0:D7:77:70:02:8F:20:EE:E4
  SHA256 Fingerprint=C3:84:6B:F2:4B:9E:93:CA:64:27:4C:0E:C6:7C:1E:CC:5E:02:4F:FC:AC:D2:D7:40:19:35:0E:81:FE:54:6A:E4
  -----BEGIN CERTIFICATE-----
  MIIEADCCAuigAwIBAgIBADANBgkqhkiG9w0BAQUFADBjMQswCQYDVQQGEwJVUzEh
  MB8GA1UEChMYVGhlIEdvIERhZGR5IEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBE
  YWRkeSBDbGFzcyAyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA0MDYyOTE3
  MDYyMFoXDTM0MDYyOTE3MDYyMFowYzELMAkGA1UEBhMCVVMxITAfBgNVBAoTGFRo
  ZSBHbyBEYWRkeSBHcm91cCwgSW5jLjExMC8GA1UECxMoR28gRGFkZHkgQ2xhc3Mg
  MiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASAwDQYJKoZIhvcNAQEBBQADggEN
  ADCCAQgCggEBAN6d1+pXGEmhW+vXX0iG6r7d/+TvZxz0ZWizV3GgXne77ZtJ6XCA
  PVYYYwhv2vLM0D9/AlQiVBDYsoHUwHU9S3/Hd8M+eKsaA7Ugay9qK7HFiH7Eux6w
  wdhFJ2+qN1j3hybX2C32qRe3H3I2TqYXP2WYktsqbl2i/ojgC95/5Y0V4evLOtXi
  EqITLdiOr18SPaAIBQi2XKVlOARFmR6jYGB0xUGlcmIbYsUfb18aQr4CUWWoriMY
  avx4A6lNf4DD+qta/KFApMoZFv6yyO9ecw3ud72a9nmYvLEHZ6IVDd2gWMZEewo+
  YihfukEHU1jPEX44dMX4/7VpkI+EdOqXG68CAQOjgcAwgb0wHQYDVR0OBBYEFNLE
  sNKR1EwRcbNhyz2h/t2oatTjMIGNBgNVHSMEgYUwgYKAFNLEsNKR1EwRcbNhyz2h
  /t2oatTjoWekZTBjMQswCQYDVQQGEwJVUzEhMB8GA1UEChMYVGhlIEdvIERhZGR5
  IEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBEYWRkeSBDbGFzcyAyIENlcnRpZmlj
  YXRpb24gQXV0aG9yaXR5ggEAMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQAD
  ggEBADJL87LKPpH8EsahB4yOd6AzBhRckB4Y9wimPQoZ+YeAEW5p5JYXMP80kWNy
  OO7MHAGjHZQopDH2esRU1/blMVgDoszOYtuURXO1v0XJJLXVggKtI3lpjbi2Tc7P
  TMozI+gciKqdi0FuFskg5YmezTvacPd+mSYgFFQlq25zheabIZ0KbIIOqPjCDPoQ
  HmyW74cNxA9hi63ugyuV+I6ShHI56yDqg+2DzZduCLzrTia2cyvk0/ZM/iZx4mER
  dEr/VxqHD3VILs9RaRegAhJhldXRQLIQTO7ErBBDpqWeCtWVYpoNz4iCxTIM5Cuf
  ReYNnyicsbkqWletNw+vHX/bvZ8=
  -----END CERTIFICATE-----

  ### The USERTRUST Network

  === /C=US/ST=New Jersey/L=Jersey City/O=The USERTRUST Network/CN=USERTrust ECC Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              5c:8b:99:c5:5a:94:c5:d2:71:56:de:cd:89:80:cc:26
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Feb  1 00:00:00 2010 GMT
              Not After : Jan 18 23:59:59 2038 GMT
          Subject: C=US, ST=New Jersey, L=Jersey City, O=The USERTRUST Network, CN=USERTrust ECC Certification Authority
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  3A:E1:09:86:D4:CF:19:C2:96:76:74:49:76:DC:E0:35:C6:63:63:9A
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=D1:CB:CA:5D:B2:D5:2A:7F:69:3B:67:4D:E5:F0:5A:1D:0C:95:7D:F0
  SHA256 Fingerprint=4F:F4:60:D5:4B:9C:86:DA:BF:BC:FC:57:12:E0:40:0D:2B:ED:3F:BC:4D:4F:BD:AA:86:E0:6A:DC:D2:A9:AD:7A
  -----BEGIN CERTIFICATE-----
  MIICjzCCAhWgAwIBAgIQXIuZxVqUxdJxVt7NiYDMJjAKBggqhkjOPQQDAzCBiDEL
  MAkGA1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNl
  eSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMT
  JVVTRVJUcnVzdCBFQ0MgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMjAx
  MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgT
  Ck5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4wHAYDVQQKExVUaGUg
  VVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVzdCBFQ0MgQ2VydGlm
  aWNhdGlvbiBBdXRob3JpdHkwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQarFRaqflo
  I+d61SRvU8Za2EurxtW20eZzca7dnNYMYf3boIkDuAUU7FfO7l0/4iGzzvfUinng
  o4N+LZfQYcTxmdwlkWOrfzCjtHDix6EznPO/LlxTsV+zfTJ/ijTjeXmjQjBAMB0G
  A1UdDgQWBBQ64QmG1M8ZwpZ2dEl23OA1xmNjmjAOBgNVHQ8BAf8EBAMCAQYwDwYD
  VR0TAQH/BAUwAwEB/zAKBggqhkjOPQQDAwNoADBlAjA2Z6EWCNzklwBBHU6+4WMB
  zzuqQhFkoJ2UOQIReVx7Hfpkue4WQrO/isIJxOzksU0CMQDpKmFHjFJKS04YcPbW
  RNZu9YO6bVi9JNlWSOrvxKJGgYhqOkbRqZtNyWHa0V1Xahg=
  -----END CERTIFICATE-----
  === /C=US/ST=New Jersey/L=Jersey City/O=The USERTRUST Network/CN=USERTrust RSA Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              01:fd:6d:30:fc:a3:ca:51:a8:1b:bc:64:0e:35:03:2d
      Signature Algorithm: sha384WithRSAEncryption
          Validity
              Not Before: Feb  1 00:00:00 2010 GMT
              Not After : Jan 18 23:59:59 2038 GMT
          Subject: C=US, ST=New Jersey, L=Jersey City, O=The USERTRUST Network, CN=USERTrust RSA Certification Authority
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  53:79:BF:5A:AA:2B:4A:CF:54:80:E1:D8:9B:C0:9D:F2:B2:03:66:CB
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=2B:8F:1B:57:33:0D:BB:A2:D0:7A:6C:51:F7:0E:E9:0D:DA:B9:AD:8E
  SHA256 Fingerprint=E7:93:C9:B0:2F:D8:AA:13:E2:1C:31:22:8A:CC:B0:81:19:64:3B:74:9C:89:89:64:B1:74:6D:46:C3:D4:CB:D2
  -----BEGIN CERTIFICATE-----
  MIIF3jCCA8agAwIBAgIQAf1tMPyjylGoG7xkDjUDLTANBgkqhkiG9w0BAQwFADCB
  iDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0pl
  cnNleSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNV
  BAMTJVVTRVJUcnVzdCBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAw
  MjAxMDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBiDELMAkGA1UEBhMCVVMxEzARBgNV
  BAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4wHAYDVQQKExVU
  aGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVzdCBSU0EgQ2Vy
  dGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK
  AoICAQCAEmUXNg7D2wiz0KxXDXbtzSfTTK1Qg2HiqiBNCS1kCdzOiZ/MPans9s/B
  3PHTsdZ7NygRK0faOca8Ohm0X6a9fZ2jY0K2dvKpOyuR+OJv0OwWIJAJPuLodMkY
  tJHUYmTbf6MG8YgYapAiPLz+E/CHFHv25B+O1ORRxhFnRghRy4YUVD+8M/5+bJz/
  Fp0YvVGONaanZshyZ9shZrHUm3gDwFA66Mzw3LyeTP6vBZY1H1dat//O+T23LLb2
  VN3I5xI6Ta5MirdcmrS3ID3KfyI0rn47aGYBROcBTkZTmzNg95S+UzeQc0PzMsNT
  79uq/nROacdrjGCT3sTHDN/hMq7MkztReJVni+49Vv4M0GkPGw/zJSZrM233bkf6
  c0Plfg6lZrEpfDKEY1WJxA3Bk1QwGROs0303p+tdOmw1XNtB1xLaqUkL39iAigmT
  Yo61Zs8liM2EuLE/pDkP2QKe6xJMlXzzawWpXhaDzLhn4ugTncxbgtNMs+1b/97l
  c6wjOy0AvzVVdAlJ2ElYGn+SNuZRkg7zJn0cTRe8yexDJtC/QV9AqURE9JnnV4ee
  UB9XVKg+/XRjL7FQZQnmWEIuQxpMtPAlR1n6BB6T1CZGSlCBst6+eLf8ZxXhyVeE
  Hg9j1uliutZfVS7qXMYoCAQlObgOK6nyTJccBz8NUvXt7y+CDwIDAQABo0IwQDAd
  BgNVHQ4EFgQUU3m/WqorSs9UgOHYm8Cd8rIDZsswDgYDVR0PAQH/BAQDAgEGMA8G
  A1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEMBQADggIBAFzUfA3P9wF9QZllDHPF
  Up/L+M+ZBn8b2kMVn54CVVeWFPFSPCeHlCjtHzoBN6J2/FNQwISbxmtOuowhT6KO
  VWKR82kV2LyI48SqC/3vqOlLVSoGIG1VeCkZ7l8wXEskEVX/JJpuXior7gtNn3/3
  ATiUFJVDBwn7YKnuHKsSjKCaXqeYalltiz8I+8jRRa8YFWSQEg9zKC7F4iRO/Fjs
  8PRF/iKz6y+O0tlFYQXBl2+odnKPi4w2r78NBc5xjeambx9spnFixdjQg3IM8WcR
  iQycE0xyNN+81XHfqnHd4blsjDwSXWXavVcStkNr/+XeTWYRUc+ZruwXtuhxkYze
  Sf7dNXGiFSeUHM9h4ya7b6NnJSFd5t0dCy5oGzuCr+yDZ4XUmFF0sbmZgIn/f3gZ
  XHlKYC6SQK5MNyosycdiyA5d9zZbyuAlJQG03RoHnHcAP9Dc1ew91Pq7P8yF1m9/
  qS3fuQL39ZeatTXaw2ewh0qpKJ4jjv9cJ2vhsE/zB+4ALtRZh8tSQZXq9EfX7mRB
  VXyNWQKV3WKdwrnuWih0hKWbt5DHDAff9Yk2dDLWKMGwsAvgnEzDHNb842m1R0aB
  L6KCq9NjRHDEjf8tM7qtj3u1cIiuPhnPQCjY/MiQu12ZIvVS5ljFH4gxQ+6IHdfG
  jjxDah2nGN59PRbxYvnKkKj9
  -----END CERTIFICATE-----

  ### TrustCor Systems S. de R.L.

  === /C=PA/ST=Panama/L=Panama City/O=TrustCor Systems S. de R.L./OU=TrustCor Certificate Authority/CN=TrustCor ECA-1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              84:82:2c:5f:1c:62:d0:40
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Feb  4 12:32:33 2016 GMT
              Not After : Dec 31 17:28:07 2029 GMT
          Subject: C=PA, ST=Panama, L=Panama City, O=TrustCor Systems S. de R.L., OU=TrustCor Certificate Authority, CN=TrustCor ECA-1
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  44:9E:48:F5:CC:6D:48:D4:A0:4B:7F:FE:59:24:2F:83:97:99:9A:86
              X509v3 Authority Key Identifier:
                  keyid:44:9E:48:F5:CC:6D:48:D4:A0:4B:7F:FE:59:24:2F:83:97:99:9A:86

              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
  SHA1 Fingerprint=58:D1:DF:95:95:67:6B:63:C0:F0:5B:1C:17:4D:8B:84:0B:C8:78:BD
  SHA256 Fingerprint=5A:88:5D:B1:9C:01:D9:12:C5:75:93:88:93:8C:AF:BB:DF:03:1A:B2:D4:8E:91:EE:15:58:9B:42:97:1D:03:9C
  -----BEGIN CERTIFICATE-----
  MIIEIDCCAwigAwIBAgIJAISCLF8cYtBAMA0GCSqGSIb3DQEBCwUAMIGcMQswCQYD
  VQQGEwJQQTEPMA0GA1UECAwGUGFuYW1hMRQwEgYDVQQHDAtQYW5hbWEgQ2l0eTEk
  MCIGA1UECgwbVHJ1c3RDb3IgU3lzdGVtcyBTLiBkZSBSLkwuMScwJQYDVQQLDB5U
  cnVzdENvciBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkxFzAVBgNVBAMMDlRydXN0Q29y
  IEVDQS0xMB4XDTE2MDIwNDEyMzIzM1oXDTI5MTIzMTE3MjgwN1owgZwxCzAJBgNV
  BAYTAlBBMQ8wDQYDVQQIDAZQYW5hbWExFDASBgNVBAcMC1BhbmFtYSBDaXR5MSQw
  IgYDVQQKDBtUcnVzdENvciBTeXN0ZW1zIFMuIGRlIFIuTC4xJzAlBgNVBAsMHlRy
  dXN0Q29yIENlcnRpZmljYXRlIEF1dGhvcml0eTEXMBUGA1UEAwwOVHJ1c3RDb3Ig
  RUNBLTEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDPj+ARtZ+odnbb
  3w9U73NjKYKtR8aja+3+XzP4Q1HpGjORMRegdMTUpwHmspI+ap3tDvl0mEDTPwOA
  BoJA6LHip1GnHYMma6ve+heRK9jGrB6xnhkB1Zem6g23xFUfJ3zSCNV2HykVh0A5
  3ThFEXXQmqc04L/NyFIduUd+Dbi7xgz2c1cWWn5DkR9VOsZtRASqnKmcp0yJF4Ou
  owReUoCLHhIlERnXDH19MURB6tuvsBzvgdAsxZohmz3tQjtQJvLsznFhBmIhVE5/
  wZ0+fyCMgMsq2JdiyIMzkX2woloPV+g7zPIlstR8L+xNxqE6FXrntl019fZISjZF
  ZtS6mFjBAgMBAAGjYzBhMB0GA1UdDgQWBBREnkj1zG1I1KBLf/5ZJC+Dl5mahjAf
  BgNVHSMEGDAWgBREnkj1zG1I1KBLf/5ZJC+Dl5mahjAPBgNVHRMBAf8EBTADAQH/
  MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOCAQEABT41XBVwm8nHc2Fv
  civUwo/yQ10CzsSUuZQRg2dd4mdsdXa/uwyqNsatR5Nj3B5+1t4u/ukZMjgDfxT2
  AHMsWbEhBuH7rBiVDKP/mZb3Kyeb1STMHd3BOuCYRLDE5D53sXOpZCz2HAF8P11F
  hcCF5yWPldwX8zyfGm6wyuMdKulMY/okYWLW2n62HGz1Ah3UKt1VkOsqEUc8Ll50
  soIipX1TH0XsJ5F95yIW6MBoNtjG8U+ARDL54dHRHareqKucBK+tIA5kmE2la8BI
  WJZpTdwHjFGTot+fDz2LYLSCjaoITmJF4PkL0uDgPFveXHEnJcLmA4GLEFPjx1Wi
  tJ/X5g==
  -----END CERTIFICATE-----
  === /C=PA/ST=Panama/L=Panama City/O=TrustCor Systems S. de R.L./OU=TrustCor Certificate Authority/CN=TrustCor RootCert CA-1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              da:9b:ec:71:f3:03:b0:19
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Feb  4 12:32:16 2016 GMT
              Not After : Dec 31 17:23:16 2029 GMT
          Subject: C=PA, ST=Panama, L=Panama City, O=TrustCor Systems S. de R.L., OU=TrustCor Certificate Authority, CN=TrustCor RootCert CA-1
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  EE:6B:49:3C:7A:3F:0D:E3:B1:09:B7:8A:C8:AB:19:9F:73:33:50:E7
              X509v3 Authority Key Identifier:
                  keyid:EE:6B:49:3C:7A:3F:0D:E3:B1:09:B7:8A:C8:AB:19:9F:73:33:50:E7

              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
  SHA1 Fingerprint=FF:BD:CD:E7:82:C8:43:5E:3C:6F:26:86:5C:CA:A8:3A:45:5B:C3:0A
  SHA256 Fingerprint=D4:0E:9C:86:CD:8F:E4:68:C1:77:69:59:F4:9E:A7:74:FA:54:86:84:B6:C4:06:F3:90:92:61:F4:DC:E2:57:5C
  -----BEGIN CERTIFICATE-----
  MIIEMDCCAxigAwIBAgIJANqb7HHzA7AZMA0GCSqGSIb3DQEBCwUAMIGkMQswCQYD
  VQQGEwJQQTEPMA0GA1UECAwGUGFuYW1hMRQwEgYDVQQHDAtQYW5hbWEgQ2l0eTEk
  MCIGA1UECgwbVHJ1c3RDb3IgU3lzdGVtcyBTLiBkZSBSLkwuMScwJQYDVQQLDB5U
  cnVzdENvciBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkxHzAdBgNVBAMMFlRydXN0Q29y
  IFJvb3RDZXJ0IENBLTEwHhcNMTYwMjA0MTIzMjE2WhcNMjkxMjMxMTcyMzE2WjCB
  pDELMAkGA1UEBhMCUEExDzANBgNVBAgMBlBhbmFtYTEUMBIGA1UEBwwLUGFuYW1h
  IENpdHkxJDAiBgNVBAoMG1RydXN0Q29yIFN5c3RlbXMgUy4gZGUgUi5MLjEnMCUG
  A1UECwweVHJ1c3RDb3IgQ2VydGlmaWNhdGUgQXV0aG9yaXR5MR8wHQYDVQQDDBZU
  cnVzdENvciBSb290Q2VydCBDQS0xMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
  CgKCAQEAv463leLCJhJrMxnHQFgKq1mqjQCj/IDHUHuO1CAmujIS2CNUSSUQIpid
  RtLByZ5OGy4sDjjzGiVoHKZaBeYei0i/mJZ0PmnK6bV4pQa81QBeCQryJ3pS/C3V
  seq0iWEk8xoT26nPUu0MJLq5nux+AHT6k61sKZKuUbS701e/s/OojZz0JEsq1pme
  9J7+wH5COucLlVPat2gOkEz7cD+PSiyU8ybdY2mplNgQTsVHCJCZGxdNuWxu72CV
  EY4hgLW9oHPY0LJ3xEXqWib7ZnZ2+AYfYW0PVcWDtxBWcgYHpfOxGgMFZA6dWorW
  hnAbJN7+KIor0Gqw/Hqi3LJ5DotlDwIDAQABo2MwYTAdBgNVHQ4EFgQU7mtJPHo/
  DeOxCbeKyKsZn3MzUOcwHwYDVR0jBBgwFoAU7mtJPHo/DeOxCbeKyKsZn3MzUOcw
  DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD
  ggEBACUY1JGPE+6PHh0RU9otRCkZoB5rMZ5NDp6tPVxBb5UrJKF5mDo4Nvu7Zp5I
  /5CQ7z3UuJu0h3U/IJvOcs+hVcFNZKIZBqEHMwwLKeXx6quj7LUKdJDHfXLy11yf
  ke+Ri7fc7Waiz45mO7yfOgLgJ90WmMCV1Aqk5IGadZQ1nJBfiDcGrVmVCrDRZ9MZ
  yonnMlo2HD6CqFqTvsbQZJG2z9m2GM/bftJlo6bEjhcxwft+dtvTheNYsnd6djts
  L1Ac59v2Z3kf9YKVmgenFK+P3CghZwnS1k1aHBkcjndcw5QkPTJrS37UeJSDvjdN
  zl/HHk484IkzlQsPpTLWPFp5LBk=
  -----END CERTIFICATE-----
  === /C=PA/ST=Panama/L=Panama City/O=TrustCor Systems S. de R.L./OU=TrustCor Certificate Authority/CN=TrustCor RootCert CA-2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 2711694510199101698 (0x25a1dfca33cb5902)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Feb  4 12:32:23 2016 GMT
              Not After : Dec 31 17:26:39 2034 GMT
          Subject: C=PA, ST=Panama, L=Panama City, O=TrustCor Systems S. de R.L., OU=TrustCor Certificate Authority, CN=TrustCor RootCert CA-2
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  D9:FE:21:40:6E:94:9E:BC:9B:3D:9C:7D:98:20:19:E5:8C:30:62:B2
              X509v3 Authority Key Identifier:
                  keyid:D9:FE:21:40:6E:94:9E:BC:9B:3D:9C:7D:98:20:19:E5:8C:30:62:B2

              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
  SHA1 Fingerprint=B8:BE:6D:CB:56:F1:55:B9:63:D4:12:CA:4E:06:34:C7:94:B2:1C:C0
  SHA256 Fingerprint=07:53:E9:40:37:8C:1B:D5:E3:83:6E:39:5D:AE:A5:CB:83:9E:50:46:F1:BD:0E:AE:19:51:CF:10:FE:C7:C9:65
  -----BEGIN CERTIFICATE-----
  MIIGLzCCBBegAwIBAgIIJaHfyjPLWQIwDQYJKoZIhvcNAQELBQAwgaQxCzAJBgNV
  BAYTAlBBMQ8wDQYDVQQIDAZQYW5hbWExFDASBgNVBAcMC1BhbmFtYSBDaXR5MSQw
  IgYDVQQKDBtUcnVzdENvciBTeXN0ZW1zIFMuIGRlIFIuTC4xJzAlBgNVBAsMHlRy
  dXN0Q29yIENlcnRpZmljYXRlIEF1dGhvcml0eTEfMB0GA1UEAwwWVHJ1c3RDb3Ig
  Um9vdENlcnQgQ0EtMjAeFw0xNjAyMDQxMjMyMjNaFw0zNDEyMzExNzI2MzlaMIGk
  MQswCQYDVQQGEwJQQTEPMA0GA1UECAwGUGFuYW1hMRQwEgYDVQQHDAtQYW5hbWEg
  Q2l0eTEkMCIGA1UECgwbVHJ1c3RDb3IgU3lzdGVtcyBTLiBkZSBSLkwuMScwJQYD
  VQQLDB5UcnVzdENvciBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkxHzAdBgNVBAMMFlRy
  dXN0Q29yIFJvb3RDZXJ0IENBLTIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK
  AoICAQCnIG7CKqJiJJWQdsg4foDSq8GbZQWU9MEKENUCrO2fk8eHyLAnK0IMPQo+
  QVqedd2NyuCb7GgypGmSaIwLgQ5WoD4a3SwlFIIvl9NkRvRUqdw6VC0xK5mC8tkq
  1+9xALgxpL56JAfDQiDyitSSBBtlVkxs1Pu2YVpHI7TYabS3OtB0PAx1oYxOdqHp
  2yqlO/rOsP9+aij9JxzIsekp8VduZLTQwRVtDr4uDkbIXvRR/u8OYzo7cbrPb1nK
  DOObXUm4TOJXsZiKQlecdu/vvdFoqNL0Cbt3Nb4lggjEFixEIFapRBF37120Hape
  az6LMvYHL1cEksr1/p3C6eizjkxLAjHZ5DxIgif3GIJ2SDpxsROhOdUuxTTCHWKF
  3wP+TfSvPd9cW436cOGlfifHhi5qjxLGhF5DUVCcGZt45vz27Ud+ez1m7xMTiF88
  oWP7+ayHNZ/zgp6kPwqcMWmLmaSISo5uZk3vFsQPeSghYA2FFn3XVDjxklb9tTNM
  g9zXEJ9L/cb4Qr26fHMC4P99zVvh1Kxhe1fVSntb1IVYJ12/+CtgrKAmrhQhJ8Z3
  mjOAPF5GP/fDsaOGM8boXg25NSyqRsGFAnWAoOsk+xWq5Gd/bnc/9ASKL3x74xdh
  8N0JqSDIvgmk0H5Ew7IwSjiqqewYmgeCK9u4nBit2uBGF6zPXQIDAQABo2MwYTAd
  BgNVHQ4EFgQU2f4hQG6UnrybPZx9mCAZ5YwwYrIwHwYDVR0jBBgwFoAU2f4hQG6U
  nrybPZx9mCAZ5YwwYrIwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYw
  DQYJKoZIhvcNAQELBQADggIBAJ5Fngw7tu/hOsh80QA9z+LqBrWyOrsGS2h60COX
  dKcs8AjYeVrXWoSK2BKaG9l9XE1wxaX5q+WjiYndAfrs3fnpkpfbsEZC89NiqpX+
  MWcUaViQCqoL7jcjx1BRtPV+nuN79+TMQjItSQzL/0kMmx40/W5ulop5A7Zv2wnL
  /V9lFDfhOPXzYRZY5LVtDQsEGz9QLX+zx3oaFoBg+Iof6Rsqxvm6ARppv9JYx1RX
  CI/hOWB3S6xZhBqI8d3LT3jX5+EzLfzuQfogsL7L9ziUwOHQhQ+77Sxzq+3+knYa
  ZH9bDTMJBzN7Bj8RpFxwPIXAz+OQqIN3+tvmxYxoZxBnpVIt8MSZj3+/0WvitUfW
  2dCFmU2Umw9Lje4AWkcdEQOsQRivh7dvDDqPys/cA8GiCcjl/YBeyGBCARsaU1q7
  N6a3vLqE6R5sGtRk2tRD/pOLS/IseRYQ1JMLiI+h2IYURpFHmygk71dSTlxCnKr3
  Sewn6EAes6aJInKc9Q0ztFijMDvd1GpUk74aTfOTlPf8hAs/hCBcNANExdqtvArB
  As8e5ZTZ845b2EzwnexhF7sUMlQMAimTHpKG9n/v55IFDlndmQguLvqcAFLTxWYp
  5KeXRKQOKIETNcX2b2TmQcTVL8w0RSXPQQCWPUouwpaYT05KnJe32x+SMsj/D1Fu
  1uwJ
  -----END CERTIFICATE-----

  ### Trustis Limited

  === /C=GB/O=Trustis Limited/OU=Trustis FPS Root CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              1b:1f:ad:b6:20:f9:24:d3:36:6b:f7:c7:f1:8c:a0:59
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Dec 23 12:14:06 2003 GMT
              Not After : Jan 21 11:36:54 2024 GMT
          Subject: C=GB, O=Trustis Limited, OU=Trustis FPS Root CA
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Authority Key Identifier:
                  keyid:BA:FA:71:25:79:8B:57:41:25:21:86:0B:71:EB:B2:64:0E:8B:21:67

              X509v3 Subject Key Identifier:
                  BA:FA:71:25:79:8B:57:41:25:21:86:0B:71:EB:B2:64:0E:8B:21:67
  SHA1 Fingerprint=3B:C0:38:0B:33:C3:F6:A6:0C:86:15:22:93:D9:DF:F5:4B:81:C0:04
  SHA256 Fingerprint=C1:B4:82:99:AB:A5:20:8F:E9:63:0A:CE:55:CA:68:A0:3E:DA:5A:51:9C:88:02:A0:D3:A6:73:BE:8F:8E:55:7D
  -----BEGIN CERTIFICATE-----
  MIIDZzCCAk+gAwIBAgIQGx+ttiD5JNM2a/fH8YygWTANBgkqhkiG9w0BAQUFADBF
  MQswCQYDVQQGEwJHQjEYMBYGA1UEChMPVHJ1c3RpcyBMaW1pdGVkMRwwGgYDVQQL
  ExNUcnVzdGlzIEZQUyBSb290IENBMB4XDTAzMTIyMzEyMTQwNloXDTI0MDEyMTEx
  MzY1NFowRTELMAkGA1UEBhMCR0IxGDAWBgNVBAoTD1RydXN0aXMgTGltaXRlZDEc
  MBoGA1UECxMTVHJ1c3RpcyBGUFMgUm9vdCBDQTCCASIwDQYJKoZIhvcNAQEBBQAD
  ggEPADCCAQoCggEBAMVQe547NdDfxIzNjpvto8A2mfRC6qc+gIMPpqdZh8mQRUN+
  AOqGeSoDvT03mYlmt+WKVoaTnGhLaASMk5MCPjDSNzoiYYkchU59j9WvezX2fihH
  iTHcDnlkH5nSW7r+f2C/revnPDgpai/lkQtV/+xvWNUtyd5MZnGPDNcE2gfmHhjj
  vSkCqPoc4Vu5g6hBSLwacY3nYuUtsuvffM/bq1rKMfFMIvMFE/eC+XN5DL7XSxzA
  0RU8k0Fk0ea+IxciAIleH2ulrG6nS4zto3Lmr2NNL4XSFDWaLk6M6jKYKIahkQlB
  OrTh4/L68MkKokHdqeMDx4gVOxzUGpTXn2RZEm0CAwEAAaNTMFEwDwYDVR0TAQH/
  BAUwAwEB/zAfBgNVHSMEGDAWgBS6+nEleYtXQSUhhgtx67JkDoshZzAdBgNVHQ4E
  FgQUuvpxJXmLV0ElIYYLceuyZA6LIWcwDQYJKoZIhvcNAQEFBQADggEBAH5Y//01
  GX2cGE+esCu8jowU/yyg2kdbw++BLa8F6nRIW/M+TgfHbcWzk88iNVy2P3UnXwmW
  zaD+vkAMXBJV+JOCyinpXj9WV4s4NvdFGkwozZ5BuO1WTISkQMi4sKUraXAEasP4
  1BIy+Q7DsdwyhEQsb8tGD+pmQQ9P8Vilpg0ND2HepZ5dfWWhPBfnqFVO76DH7cZE
  f1T1o+CP8HxVIo8ptoGj4W1OLBuAZ+ytIJ8MYmHVl/9D7S3B2l0pKoU/rGXuhg8F
  jZBf3+6f9L/uHfuY5H+QK4R4EA5sSVPvFVtlRkpdr7r7OnIdzfYliB6XzCGcKQEN
  ZetX2fNXlrtIzYE=
  -----END CERTIFICATE-----

  ### Trustwave Holdings, Inc.

  === /C=US/ST=Illinois/L=Chicago/O=Trustwave Holdings, Inc./CN=Trustwave Global Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              05:f7:0e:86:da:49:f3:46:35:2e:ba:b2
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Aug 23 19:34:12 2017 GMT
              Not After : Aug 23 19:34:12 2042 GMT
          Subject: C=US, ST=Illinois, L=Chicago, O=Trustwave Holdings, Inc., CN=Trustwave Global Certification Authority
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  99:E0:19:67:0D:62:DB:76:B3:DA:3D:B8:5B:E8:FD:42:D2:31:0E:87
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
  SHA1 Fingerprint=2F:8F:36:4F:E1:58:97:44:21:59:87:A5:2A:9A:D0:69:95:26:7F:B5
  SHA256 Fingerprint=97:55:20:15:F5:DD:FC:3C:87:88:C0:06:94:45:55:40:88:94:45:00:84:F1:00:86:70:86:BC:1A:2B:B5:8D:C8
  -----BEGIN CERTIFICATE-----
  MIIF2jCCA8KgAwIBAgIMBfcOhtpJ80Y1LrqyMA0GCSqGSIb3DQEBCwUAMIGIMQsw
  CQYDVQQGEwJVUzERMA8GA1UECAwISWxsaW5vaXMxEDAOBgNVBAcMB0NoaWNhZ28x
  ITAfBgNVBAoMGFRydXN0d2F2ZSBIb2xkaW5ncywgSW5jLjExMC8GA1UEAwwoVHJ1
  c3R3YXZlIEdsb2JhbCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0xNzA4MjMx
  OTM0MTJaFw00MjA4MjMxOTM0MTJaMIGIMQswCQYDVQQGEwJVUzERMA8GA1UECAwI
  SWxsaW5vaXMxEDAOBgNVBAcMB0NoaWNhZ28xITAfBgNVBAoMGFRydXN0d2F2ZSBI
  b2xkaW5ncywgSW5jLjExMC8GA1UEAwwoVHJ1c3R3YXZlIEdsb2JhbCBDZXJ0aWZp
  Y2F0aW9uIEF1dGhvcml0eTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIB
  ALldUShLPDeS0YLOvR29zd24q88KPuFd5dyqCblXAj7mY2Hf8g+CY66j96xz0Xzn
  swuvCAAJWX/NKSqIk4cXGIDtiLK0thAfLdZfVaITXdHG6wZWiYj+rDKd/VzDBcdu
  7oaJuogDnXIhhpCujwOl3J+IKMujkkkP7NAP4m1ET4BqstTnoApTAbqOl5F2brz8
  1Ws25kCI1nsvXwXoLG0R8+eyvpJETNKXpP7ScoFDB5zpET71ixpZfR9oWN0EACyW
  80OzfpgZdNmcc9kYvkHHNHnZ9GLCQ7mzJ7Aiy/k9UscwR7PJPrhq4ufogXBeQotP
  JqX+OsIgbrv4Fo7NDKm0G2x2EOFYeUY+VM6AqFcJNykbmROPDMjWLBz7BegIlT1l
  RtzuzWniTY+HKE40Cz7PFNm73bZQmq131BnW2hqIyE4bJ3XYsgjxroMwuREOzYfw
  hI0Vcnyh78zyiGG69Gm7DIwLdVcEuE4qFC49DxweMqZiNu5m4iK4BUBjECLzMx10
  coos9TkpoNPnG4CELcU9402x/RpvumUHO1jsQkUm+9jaJXLE9gCxInm943xZYkqc
  BW89zubWR2OZxiRvchLIrH+QtAuRcOi35hYQcRfO3gZPSEF9NUqjifLJS3tBEW1n
  twiYTOURGa5CgNz7kAXU+FDKvuStx8KU1xad5hePrzb7AgMBAAGjQjBAMA8GA1Ud
  EwEB/wQFMAMBAf8wHQYDVR0OBBYEFJngGWcNYtt2s9o9uFvo/ULSMQ6HMA4GA1Ud
  DwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAmHNw4rDT7TnsTGDZqRKGFx6W
  0OhUKDtkLSGm+J1WE2pIPU/HPinbbViDVD2HfSMF1OQc3Og4ZYbFdada2zUFvXfe
  uyk3QAUHw5RSn8pk3fEbK9xGChACMf1KaA0HZJDmHvUqoai7PF35owgLEQzxPy0Q
  lG/+4jSHg9bP5Rs1bdID4bANqKCqRieCNqcVtgimQlRXtpla4gt5kNdXElE1GYhB
  aCXUNxeEFfsBctyV3lImIJgm4nb1J2/6ADtKYdkNy1GTKv0WBpanI5ojSP5RvbbE
  sLFUzt5sQa0WZ37b/TjNuThOssFgy50X31ieemKyJo90lZvkWx3SD92YHJtZuSPT
  MaCm/zjdzyBP6VhWOmfD0faZmZ26NraAL4hHT4a/RDqA5Dccprrql5gR0IRiR2Qe
  qu5AvzSxnI9O4fKSTx+O856X3vOmeWqJcU9LJxdI/uz0UA9PSX3MReO9ekDFQdxh
  VicGaeVyQYHTtgGJoC86cnn+OjC/QezHYj6RS8fZMXZC+fc8Y+wmjHMMfRod6qh8
  h6jCJ3zhM0EPz8/8AKAigJ5Kp28AsEFFtyLKaEjFQqKu3R3y4G5OBVixwJAWKqQ9
  EEC+j2Jjg6mcgn0tAumDMHzLJ8n9HmYAsC7TIS+OMxZsmO0QqAfWzJPP29FpHOTK
  yeC2nOnOcXHebD8WpHk=
  -----END CERTIFICATE-----
  === /C=US/ST=Illinois/L=Chicago/O=Trustwave Holdings, Inc./CN=Trustwave Global ECC P256 Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              0d:6a:5f:08:3f:28:5c:3e:51:95:df:5d
      Signature Algorithm: ecdsa-with-SHA256
          Validity
              Not Before: Aug 23 19:35:10 2017 GMT
              Not After : Aug 23 19:35:10 2042 GMT
          Subject: C=US, ST=Illinois, L=Chicago, O=Trustwave Holdings, Inc., CN=Trustwave Global ECC P256 Certification Authority
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  A3:41:06:AC:90:6D:D1:4A:EB:75:A5:4A:10:99:B3:B1:A1:8B:4A:F7
  SHA1 Fingerprint=B4:90:82:DD:45:0C:BE:8B:5B:B1:66:D3:E2:A4:08:26:CD:ED:42:CF
  SHA256 Fingerprint=94:5B:BC:82:5E:A5:54:F4:89:D1:FD:51:A7:3D:DF:2E:A6:24:AC:70:19:A0:52:05:22:5C:22:A7:8C:CF:A8:B4
  -----BEGIN CERTIFICATE-----
  MIICYDCCAgegAwIBAgIMDWpfCD8oXD5Rld9dMAoGCCqGSM49BAMCMIGRMQswCQYD
  VQQGEwJVUzERMA8GA1UECBMISWxsaW5vaXMxEDAOBgNVBAcTB0NoaWNhZ28xITAf
  BgNVBAoTGFRydXN0d2F2ZSBIb2xkaW5ncywgSW5jLjE6MDgGA1UEAxMxVHJ1c3R3
  YXZlIEdsb2JhbCBFQ0MgUDI1NiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0x
  NzA4MjMxOTM1MTBaFw00MjA4MjMxOTM1MTBaMIGRMQswCQYDVQQGEwJVUzERMA8G
  A1UECBMISWxsaW5vaXMxEDAOBgNVBAcTB0NoaWNhZ28xITAfBgNVBAoTGFRydXN0
  d2F2ZSBIb2xkaW5ncywgSW5jLjE6MDgGA1UEAxMxVHJ1c3R3YXZlIEdsb2JhbCBF
  Q0MgUDI1NiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTBZMBMGByqGSM49AgEGCCqG
  SM49AwEHA0IABH77bOYj43MyCMpg5lOcunSNGLB4kFKA3TjASh3RqMyTpJcGOMoN
  FWLGjgEqZZ2q3zSRLoHB5DOSMcT9CTqmP62jQzBBMA8GA1UdEwEB/wQFMAMBAf8w
  DwYDVR0PAQH/BAUDAwcGADAdBgNVHQ4EFgQUo0EGrJBt0UrrdaVKEJmzsaGLSvcw
  CgYIKoZIzj0EAwIDRwAwRAIgB+ZU2g6gWrKuEZ+Hxbb/ad4lvvigtwjzRM4q3wgh
  DDcCIC0mA6AFvWvR9lz4ZcyGbbOcNEhjhAnFjXca4syc4XR7
  -----END CERTIFICATE-----
  === /C=US/ST=Illinois/L=Chicago/O=Trustwave Holdings, Inc./CN=Trustwave Global ECC P384 Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              08:bd:85:97:6c:99:27:a4:80:68:47:3b
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Aug 23 19:36:43 2017 GMT
              Not After : Aug 23 19:36:43 2042 GMT
          Subject: C=US, ST=Illinois, L=Chicago, O=Trustwave Holdings, Inc., CN=Trustwave Global ECC P384 Certification Authority
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  55:A9:84:89:D2:C1:32:BD:18:CB:6C:A6:07:4E:C8:E7:9D:BE:82:90
  SHA1 Fingerprint=E7:F3:A3:C8:CF:6F:C3:04:2E:6D:0E:67:32:C5:9E:68:95:0D:5E:D2
  SHA256 Fingerprint=55:90:38:59:C8:C0:C3:EB:B8:75:9E:CE:4E:25:57:22:5F:F5:75:8B:BD:38:EB:D4:82:76:60:1E:1B:D5:80:97
  -----BEGIN CERTIFICATE-----
  MIICnTCCAiSgAwIBAgIMCL2Fl2yZJ6SAaEc7MAoGCCqGSM49BAMDMIGRMQswCQYD
  VQQGEwJVUzERMA8GA1UECBMISWxsaW5vaXMxEDAOBgNVBAcTB0NoaWNhZ28xITAf
  BgNVBAoTGFRydXN0d2F2ZSBIb2xkaW5ncywgSW5jLjE6MDgGA1UEAxMxVHJ1c3R3
  YXZlIEdsb2JhbCBFQ0MgUDM4NCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0x
  NzA4MjMxOTM2NDNaFw00MjA4MjMxOTM2NDNaMIGRMQswCQYDVQQGEwJVUzERMA8G
  A1UECBMISWxsaW5vaXMxEDAOBgNVBAcTB0NoaWNhZ28xITAfBgNVBAoTGFRydXN0
  d2F2ZSBIb2xkaW5ncywgSW5jLjE6MDgGA1UEAxMxVHJ1c3R3YXZlIEdsb2JhbCBF
  Q0MgUDM4NCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTB2MBAGByqGSM49AgEGBSuB
  BAAiA2IABGvaDXU1CDFHBa5FmVXxERMuSvgQMSOjfoPTfygIOiYaOs+Xgh+AtycJ
  j9GOMMQKmw6sWASr9zZ9lCOkmwqKi6vr/TklZvFe/oyujUF5nQlgziip04pt89ZF
  1PKYhDhloKNDMEEwDwYDVR0TAQH/BAUwAwEB/zAPBgNVHQ8BAf8EBQMDBwYAMB0G
  A1UdDgQWBBRVqYSJ0sEyvRjLbKYHTsjnnb6CkDAKBggqhkjOPQQDAwNnADBkAjA3
  AZKXRRJ+oPM+rRk6ct30UJMDEr5E0k9BpIycnR+j9sKS50gU/k6bpZFXrsY3crsC
  MGclCrEMXu6pY5Jv5ZAL/mYiykf9ijH3g/56vxC+GCsej/YpHpRZ744hN8tRmKVu
  Sw==
  -----END CERTIFICATE-----

  ### Turkiye Bilimsel ve Teknolojik Arastirma Kurumu - TUBITAK

  === /C=TR/L=Gebze - Kocaeli/O=Turkiye Bilimsel ve Teknolojik Arastirma Kurumu - TUBITAK/OU=Kamu Sertifikasyon Merkezi - Kamu SM/CN=TUBITAK Kamu SM SSL Kok Sertifikasi - Surum 1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 1 (0x1)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Nov 25 08:25:55 2013 GMT
              Not After : Oct 25 08:25:55 2043 GMT
          Subject: C=TR, L=Gebze - Kocaeli, O=Turkiye Bilimsel ve Teknolojik Arastirma Kurumu - TUBITAK, OU=Kamu Sertifikasyon Merkezi - Kamu SM, CN=TUBITAK Kamu SM SSL Kok Sertifikasi - Surum 1
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  65:3F:C7:8A:86:C6:3C:DD:3C:54:5C:35:F8:3A:ED:52:0C:47:57:C8
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=31:43:64:9B:EC:CE:27:EC:ED:3A:3F:0B:8F:0D:E4:E8:91:DD:EE:CA
  SHA256 Fingerprint=46:ED:C3:68:90:46:D5:3A:45:3F:B3:10:4A:B8:0D:CA:EC:65:8B:26:60:EA:16:29:DD:7E:86:79:90:64:87:16
  -----BEGIN CERTIFICATE-----
  MIIEYzCCA0ugAwIBAgIBATANBgkqhkiG9w0BAQsFADCB0jELMAkGA1UEBhMCVFIx
  GDAWBgNVBAcTD0dlYnplIC0gS29jYWVsaTFCMEAGA1UEChM5VHVya2l5ZSBCaWxp
  bXNlbCB2ZSBUZWtub2xvamlrIEFyYXN0aXJtYSBLdXJ1bXUgLSBUVUJJVEFLMS0w
  KwYDVQQLEyRLYW11IFNlcnRpZmlrYXN5b24gTWVya2V6aSAtIEthbXUgU00xNjA0
  BgNVBAMTLVRVQklUQUsgS2FtdSBTTSBTU0wgS29rIFNlcnRpZmlrYXNpIC0gU3Vy
  dW0gMTAeFw0xMzExMjUwODI1NTVaFw00MzEwMjUwODI1NTVaMIHSMQswCQYDVQQG
  EwJUUjEYMBYGA1UEBxMPR2ViemUgLSBLb2NhZWxpMUIwQAYDVQQKEzlUdXJraXll
  IEJpbGltc2VsIHZlIFRla25vbG9qaWsgQXJhc3Rpcm1hIEt1cnVtdSAtIFRVQklU
  QUsxLTArBgNVBAsTJEthbXUgU2VydGlmaWthc3lvbiBNZXJrZXppIC0gS2FtdSBT
  TTE2MDQGA1UEAxMtVFVCSVRBSyBLYW11IFNNIFNTTCBLb2sgU2VydGlmaWthc2kg
  LSBTdXJ1bSAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAr3UwM6q7
  a9OZLBI3hNmNe5eA027n/5tQlT6QlVZC1xl8JoSNkvoBHToP4mQ4t4y86Ij5iySr
  LqP1N+RAjhgleYN1Hzv/bKjFxlb4tO2KRKOrbEz8HdDc72i9z+SqzvBV96I01INr
  N3wcwv61A+xXzry0tcXtAA9TNypN9E8Mg/uGz8v+jE69h/mniyFXnHrfA2eJLJ2X
  YacQuFWQfw4tJzh03+f92k4S400VIgLI4OD8D62K18lUUMw7D8oWgITQUVbDjlZ/
  iSIzL+aFCr2lqBs23tPcLG07xxO9WSMs5uWk99gL7eqQQESolbuT1dCANLZGeA4f
  AJNG4e7p+exPFwIDAQABo0IwQDAdBgNVHQ4EFgQUZT/HiobGPN08VFw1+DrtUgxH
  V8gwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEL
  BQADggEBACo/4fEyjq7hmFxLXs9rHmoJ0iKpEsdeV31zVmSAhHqT5Am5EM2fKifh
  AHe+SMg1qIGf5LgsyX8OsNJLN13qudULXjS99HMpw+0mFZx+CFOKWI3QSyjfwbPf
  IPP54+M638yclNhOT8NrF7f3cuitZjO1JVOr4PhMqZ398g26rrnZqsZr+ZO7rqu4
  lzwDGrpDxpa5RXI4s6ehlj2Re37AIVNMh+3yC1SVUZPVIqUNivGTDj5UDrDYyU7c
  8jEyVupk+eq1nRZmQnLzf9OxMUP8pI4X8W0jq5Rm+K37DwhuJi1/FwcJsoz7UMCf
  lo3Ptv0AnVoUmr8CRPXBwp8iXqIPoeM=
  -----END CERTIFICATE-----

  ### UniTrust

  === /C=CN/O=UniTrust/CN=UCA Extended Validation Root
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              4f:d2:2b:8f:f5:64:c8:33:9e:4f:34:58:66:23:70:60
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Mar 13 00:00:00 2015 GMT
              Not After : Dec 31 00:00:00 2038 GMT
          Subject: C=CN, O=UniTrust, CN=UCA Extended Validation Root
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  D9:74:3A:E4:30:3D:0D:F7:12:DC:7E:5A:05:9F:1E:34:9A:F7:E1:14
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
  SHA1 Fingerprint=A3:A1:B0:6F:24:61:23:4A:E3:36:A5:C2:37:FC:A6:FF:DD:F0:D7:3A
  SHA256 Fingerprint=D4:3A:F9:B3:54:73:75:5C:96:84:FC:06:D7:D8:CB:70:EE:5C:28:E7:73:FB:29:4E:B4:1E:E7:17:22:92:4D:24
  -----BEGIN CERTIFICATE-----
  MIIFWjCCA0KgAwIBAgIQT9Irj/VkyDOeTzRYZiNwYDANBgkqhkiG9w0BAQsFADBH
  MQswCQYDVQQGEwJDTjERMA8GA1UECgwIVW5pVHJ1c3QxJTAjBgNVBAMMHFVDQSBF
  eHRlbmRlZCBWYWxpZGF0aW9uIFJvb3QwHhcNMTUwMzEzMDAwMDAwWhcNMzgxMjMx
  MDAwMDAwWjBHMQswCQYDVQQGEwJDTjERMA8GA1UECgwIVW5pVHJ1c3QxJTAjBgNV
  BAMMHFVDQSBFeHRlbmRlZCBWYWxpZGF0aW9uIFJvb3QwggIiMA0GCSqGSIb3DQEB
  AQUAA4ICDwAwggIKAoICAQCpCQcoEwKwmeBkqh5DFnpzsZGgdT6o+uM4AHrsiWog
  D4vFsJszA1qGxliG1cGFu0/GnEBNyr7uaZa4rYEwmnySBesFK5pI0Lh2PpbIILvS
  sPGP2KxFRv+qZ2C0d35qHzwaUnoEPQc8hQ2E0B92CvdqFN9y4zR8V05WAT558aop
  O2z6+I9tTcg1367r3CTueUWnhbYFiN6IXSV8l2RnCdm/WhUFhvMJHuxYMjMR83dk
  sHYf5BA1FxvyDrFspCqjc/wJHx4yGVMR59mzLC52LqGj3n5qiAno8geK+LLNEOfi
  c0CTuwjRP+H8C5SzJe98ptfRr5//lpr1kXuYC3fUfugH0mK1lTnj8/FtDw5lhIpj
  VMWAtuCeS31HJqcBCF3RiJ7XwzJE+oJKCmhUfzhTA8ykADNkUVkLo4KRel7sFsLz
  KuZi2irbWWIQJUoqgQtHB0MGcIfS+pMRKXpITeuUx3BNr2fVUbGAIAEBtHoIppB/
  TuDvB0GHr2qlXov7z1CymlSvw4m6WC31MJixNnI5fkkE/SmnTHnkBVfblLkWU41G
  sx2VYVdWf6/wFlthWG82UBEL2KwrlRYaDh8IzTY0ZRBiZtWAXxQgXy0MoHgKaNYs
  1+lvK9JKBZP8nm9rZ/+I8U6laUpSNwXqxhaN0sSZ0YIrO7o1dfdRUVjzyAfd5LQD
  fwIDAQABo0IwQDAdBgNVHQ4EFgQU2XQ65DA9DfcS3H5aBZ8eNJr34RQwDwYDVR0T
  AQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQADggIBADaN
  l8xCFWQpN5smLNb7rhVpLGsaGvdftvkHTFnq88nIua7Mui563MD1sC3AO6+fcAUR
  ap8lTwEpcOPlDOHqWnzcSbvBHiqB9RZLcpHIojG5qtr8nR/zXUACE/xOHAbKsxSQ
  VBcZEhrxH9cMaVr2cXj0lH2RC47skFSOvG+hTKv8dGT9cZr4QQehzZHkPJrgmzI5
  c6sq1WnIeJEmMX3ixzDx/BR4dxIOE/TdFpS/S2d7cFOFyrC78zhNLJA5wA3CXWvp
  4uXViI3WLL+rG761KIcSF3Ru/H38j9CHJrAb+7lsq+KePRXBOy5nAliRn+/4Qh8s
  t2j1da3Ptfb/EX3C8CSlrdP6oDyp+l3cpaDvRKS+1ujl5BOWF3sGPjLtx7dCvHaj
  2GU4Kzg1USEODm8uNBNA4StnDG1KQTAYI1oyVZnJF+A83vbsea0rWBmirSwiGpWO
  vpaQXUJXxPkUAzUrHC1RVwinOt4/5Mi0A3PCwSaAuwtCH60NryZy2sy+s6ODWA2C
  xR9GUeOcGMyNm43sSet1UNWMKFnKdDTajAshqx7qG+XH/RU+wBeq+yNuJkbL+vmx
  cmtpzyKEC2IPrNkZAJSidjzULZrtBJ4tBmIQN1IchXIbJ+XMxjHsN+xjWZsLHXbM
  fjKaiJUINlK73nZfdklJrX+9ZSCyycErdhh2n1ax
  -----END CERTIFICATE-----
  === /C=CN/O=UniTrust/CN=UCA Global G2 Root
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              5d:df:b1:da:5a:a3:ed:5d:be:5a:65:20:65:03:90:ef
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Mar 11 00:00:00 2016 GMT
              Not After : Dec 31 00:00:00 2040 GMT
          Subject: C=CN, O=UniTrust, CN=UCA Global G2 Root
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  81:C4:8C:CC:F5:E4:30:FF:A5:0C:08:5F:8C:15:67:21:74:01:DF:DF
  SHA1 Fingerprint=28:F9:78:16:19:7A:FF:18:25:18:AA:44:FE:C1:A0:CE:5C:B6:4C:8A
  SHA256 Fingerprint=9B:EA:11:C9:76:FE:01:47:64:C1:BE:56:A6:F9:14:B5:A5:60:31:7A:BD:99:88:39:33:82:E5:16:1A:A0:49:3C
  -----BEGIN CERTIFICATE-----
  MIIFRjCCAy6gAwIBAgIQXd+x2lqj7V2+WmUgZQOQ7zANBgkqhkiG9w0BAQsFADA9
  MQswCQYDVQQGEwJDTjERMA8GA1UECgwIVW5pVHJ1c3QxGzAZBgNVBAMMElVDQSBH
  bG9iYWwgRzIgUm9vdDAeFw0xNjAzMTEwMDAwMDBaFw00MDEyMzEwMDAwMDBaMD0x
  CzAJBgNVBAYTAkNOMREwDwYDVQQKDAhVbmlUcnVzdDEbMBkGA1UEAwwSVUNBIEds
  b2JhbCBHMiBSb290MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAxeYr
  b3zvJgUno4Ek2m/LAfmZmqkywiKHYUGRO8vDaBsGxUypK8FnFyIdK+35KYmToni9
  kmugow2ifsqTs6bRjDXVdfkX9s9FxeV67HeToI8jrg4aA3++1NDtLnurRiNb/yzm
  VHqUwCoV8MmNsHo7JOHXaOIxPAYzRrZUEaalLyJUKlgNAQLx+hVRZ2zA+te2G3/R
  VogvGjqNO7uCEeBHANBSh6v7hn4PJGtAnTRnvI3HLYZveT6OqTwXS3+wmeOwcWDc
  C/Vkw85DvG1xudLeJ1uK6NjGruFZfc8oLTW4lVYa8bJYS7cSN8h8s+1LgOGN+jIj
  tm+3SJUIsUROhYw6AlQgL9+/V087OpAh18EmNVQg7Mc/R+zvWr9LesGtOxdQXGLY
  D0tK3Cv6brxzks3sx1DoQZbXqX5t2Okdj4q1uViSukqSKwxW/YDrCPBeKW4bHAyv
  j5OJrdu9o54hyokZ7N+1wxrrFv54NkzWbtA+FxyQF2smuvt6L78RHBgOLXMDj6Dl
  NaBa4kx1HXHhOThTeEDMg5PXCp6dW4+K5OXgSORIskfNTip1KnvyIvbJvgmRlld6
  iIis7nCs+dwp4wwcOxJORNanTrAmyPPZGpeRaOrvjUYG0lZFWJo8DA+DuAUlwznP
  O6Q0ibd5Ei9Hxeepl2n8pndntd978XplFeRhVmUCAwEAAaNCMEAwDgYDVR0PAQH/
  BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFIHEjMz15DD/pQwIX4wV
  ZyF0Ad/fMA0GCSqGSIb3DQEBCwUAA4ICAQATZSL1jiutROTL/7lo5sOASD0Ee/oj
  L3rtNtqyzm325p7lX1iPyzcyochltq44PTUbPrw7tgTQvPlJ9Zv3hcU2tsu8+Mg5
  1eRfB70VVJd0ysrtT7q6ZHafgbiERUlMjW+i67HM0cOU2kTC5uLqGOiiHycFutfl
  1qnN3e92mI0ADs0b+gO3joBYDic/UvuUospeZcnWhNq5NXHzJsBPd+aBJ9J3O5oU
  b3n09tDh05S60FdRvScFDcH9yBIw7m+NESsIndTUv4BFFJqIRNow6rSn4+7vW4LV
  PtateJLbXDzz2K36uGt/xDYotgIVilQsnLAXc47QN6MUPJiVAAwpBVueSUmxX8fj
  y88nZY41F7dXyDDZQVu5FLbowg+UMaeUmMxq67XhJ/UQqAHojhJi6IjMtX9Gl8Cb
  EGY4GjZGXyJoPd/JxhMnq1MGrKI8hgZlb7F+sSlEmqO6SWkoaY/X5V+tBIZkbxqg
  DMUIYs6Ao9Dz7GjevjPHF1t/gMRMTLGmhIrDO7gJzRSBuhjjVFc2/tsvfEehOjPI
  +Vg7RE+xygKJBJYoaMVLuCaJu9YzL1DV/pqJuhgyklTGW+Cd+V7lDSKb9triyCGy
  YiGqhkCyLmTTX8jjfhFnRR8F/uOi77Oos/N9j/gMHyIfLXC0uAE0djAA5SN4p1bX
  UB+K+wb1whnw0A==
  -----END CERTIFICATE-----

  ### Unizeto Technologies S.A.

  === /C=PL/O=Unizeto Technologies S.A./OU=Certum Certification Authority/CN=Certum Trusted Network CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 279744 (0x444c0)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Oct 22 12:07:37 2008 GMT
              Not After : Dec 31 12:07:37 2029 GMT
          Subject: C=PL, O=Unizeto Technologies S.A., OU=Certum Certification Authority, CN=Certum Trusted Network CA
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  08:76:CD:CB:07:FF:24:F6:C5:CD:ED:BB:90:BC:E2:84:37:46:75:F7
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
  SHA1 Fingerprint=07:E0:32:E0:20:B7:2C:3F:19:2F:06:28:A2:59:3A:19:A7:0F:06:9E
  SHA256 Fingerprint=5C:58:46:8D:55:F5:8E:49:7E:74:39:82:D2:B5:00:10:B6:D1:65:37:4A:CF:83:A7:D4:A3:2D:B7:68:C4:40:8E
  -----BEGIN CERTIFICATE-----
  MIIDuzCCAqOgAwIBAgIDBETAMA0GCSqGSIb3DQEBBQUAMH4xCzAJBgNVBAYTAlBM
  MSIwIAYDVQQKExlVbml6ZXRvIFRlY2hub2xvZ2llcyBTLkEuMScwJQYDVQQLEx5D
  ZXJ0dW0gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxIjAgBgNVBAMTGUNlcnR1bSBU
  cnVzdGVkIE5ldHdvcmsgQ0EwHhcNMDgxMDIyMTIwNzM3WhcNMjkxMjMxMTIwNzM3
  WjB+MQswCQYDVQQGEwJQTDEiMCAGA1UEChMZVW5pemV0byBUZWNobm9sb2dpZXMg
  Uy5BLjEnMCUGA1UECxMeQ2VydHVtIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MSIw
  IAYDVQQDExlDZXJ0dW0gVHJ1c3RlZCBOZXR3b3JrIENBMIIBIjANBgkqhkiG9w0B
  AQEFAAOCAQ8AMIIBCgKCAQEA4/t9o3K6wvDJFIf1awFO4W5AB7ptJ11/91sts1rH
  UV+rpDKmYYe2bg+G0jACl/jXaVehGDldamR5xgFZrDwxSjh80gTSSyjoIF87B6LM
  TXPb865Px1bVWqeWifrzq2jUI4ZZJ88JJ7ysbnKDHDBy3+Ci6dLhdHUZvSqeexVU
  BBvXQzmtVSjF4hq79MDkrjhJM8x2hZ85RdKknvISjFH4fOQtf/WsX+sWn7Et0brM
  kUJ3TCXJkDhv2/DM+44el1k+1WBO5gUo7Ul5E0u6SNsv+XLTOcr+H9g0cvW0QM8x
  AcPs3hEtF10fuFDRXhmnad4HMyjKUJX5p1TLVIZQRan5SQIDAQABo0IwQDAPBgNV
  HRMBAf8EBTADAQH/MB0GA1UdDgQWBBQIds3LB/8k9sXN7buQvOKEN0Z19zAOBgNV
  HQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQEFBQADggEBAKaorSLOAT2mo/9i0Eidi15y
  sHhE49wcrwn9I0j6vSrEuVUEtRCjjSfeC4Jj0O7eDDd5QVsisrCaQVymcODU0HfL
  I9MA4GxWL+FpDQ3Zqr8hgVDZBqWo/5U30Kr+4rP1mS1FhIrlQgnXdAIv94nYmem8
  J9RHjboNRhx3zxSkHLmkMcScKHQDNP8zGSal6Q10tz6XxnboJ5ajZt3hrvJBW8qY
  VoNzcOSGGtIxQbovvi0TWnZvTuhOgQ4/WwMioBK+ZlgRSssDxLQqKi2WF+A5VLxI
  03YnnZotBqbJ7DnSq9ufmgsnAjUpsUCV5/nonFWIGUbWtzT1fs45mtk48VH3Tyw=
  -----END CERTIFICATE-----

  ### WISeKey

  === /C=CH/O=WISeKey/OU=OISTE Foundation Endorsed/CN=OISTE WISeKey Global Root GB CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              76:b1:20:52:74:f0:85:87:46:b3:f8:23:1a:f6:c2:c0
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Dec  1 15:00:32 2014 GMT
              Not After : Dec  1 15:10:31 2039 GMT
          Subject: C=CH, O=WISeKey, OU=OISTE Foundation Endorsed, CN=OISTE WISeKey Global Root GB CA
          X509v3 extensions:
              X509v3 Key Usage:
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  35:0F:C8:36:63:5E:E2:A3:EC:F9:3B:66:15:CE:51:52:E3:91:9A:3D
              1.3.6.1.4.1.311.21.1:
                  ...
  SHA1 Fingerprint=0F:F9:40:76:18:D3:D7:6A:4B:98:F0:A8:35:9E:0C:FD:27:AC:CC:ED
  SHA256 Fingerprint=6B:9C:08:E8:6E:B0:F7:67:CF:AD:65:CD:98:B6:21:49:E5:49:4A:67:F5:84:5E:7B:D1:ED:01:9F:27:B8:6B:D6
  -----BEGIN CERTIFICATE-----
  MIIDtTCCAp2gAwIBAgIQdrEgUnTwhYdGs/gjGvbCwDANBgkqhkiG9w0BAQsFADBt
  MQswCQYDVQQGEwJDSDEQMA4GA1UEChMHV0lTZUtleTEiMCAGA1UECxMZT0lTVEUg
  Rm91bmRhdGlvbiBFbmRvcnNlZDEoMCYGA1UEAxMfT0lTVEUgV0lTZUtleSBHbG9i
  YWwgUm9vdCBHQiBDQTAeFw0xNDEyMDExNTAwMzJaFw0zOTEyMDExNTEwMzFaMG0x
  CzAJBgNVBAYTAkNIMRAwDgYDVQQKEwdXSVNlS2V5MSIwIAYDVQQLExlPSVNURSBG
  b3VuZGF0aW9uIEVuZG9yc2VkMSgwJgYDVQQDEx9PSVNURSBXSVNlS2V5IEdsb2Jh
  bCBSb290IEdCIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2Be3
  HEokKtaXscriHvt9OO+Y9bI5mE4nuBFde9IllIiCFSZqGzG7qFshISvYD06fWvGx
  WuR51jIjK+FTzJlFXHtPrby/h0oLS5daqPZI7H17Dc0hBt+eFf1Biki3IPShehtX
  1F1Q/7pn2COZH8g/497/b1t3sWtuuMlk9+HKQUYOKXHQuSP8yYFfTvdv37+ErXNk
  u7dCjmn21HYdfp2nuFeKUWdy19SouJVUQHMD9ur06/4oQnc/nSMbsrY9gBQHTC5P
  99UKFg29ZkM3fiNDecNAhvVMKdqOmq0NpQSHiB6F4+lT1ZvIiwNjeOvgGUpuuy9r
  M2RYk61pv48b74JIxwIDAQABo1EwTzALBgNVHQ8EBAMCAYYwDwYDVR0TAQH/BAUw
  AwEB/zAdBgNVHQ4EFgQUNQ/INmNe4qPs+TtmFc5RUuORmj0wEAYJKwYBBAGCNxUB
  BAMCAQAwDQYJKoZIhvcNAQELBQADggEBAEBM+4eymYGQfp3FsLAmzYh7KzKNbrgh
  cViXfa43FK8+5/ea4n32cZiZBKpDdHij40lhPnOMTZTg+XHEthYOU3gf1qKHLwI5
  gSk8rxWYITD+KJAAjNHhy/peyP34EEY7onhCkRd0VQreUGdNZtGn//3ZwLWoo4rO
  ZvUPQ82nK1d7Y0Zqqi5S2PTt4W2tKZB4SLrhI6qjiey1q5bAtEuiHZeeevJuQHHf
  aPFlTc58Bd9TZaml8LGXBHAVRgOY1NK/VLSgWH1Sb9pWJmLU2NuJMW8c8CLC02Ic
  Nc1MaRVUGpCY3useX8p3x8uOPUNpnJpY0CQ73xtAln41rYHHTnG6iBM=
  -----END CERTIFICATE-----
  === /C=CH/O=WISeKey/OU=OISTE Foundation Endorsed/CN=OISTE WISeKey Global Root GC CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              21:2a:56:0c:ae:da:0c:ab:40:45:bf:2b:a2:2d:3a:ea
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: May  9 09:48:34 2017 GMT
              Not After : May  9 09:58:33 2042 GMT
          Subject: C=CH, O=WISeKey, OU=OISTE Foundation Endorsed, CN=OISTE WISeKey Global Root GC CA
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  48:87:14:AC:E3:C3:9E:90:60:3A:D7:CA:89:EE:D3:AD:8C:B4:50:66
              1.3.6.1.4.1.311.21.1:
                  ...
  SHA1 Fingerprint=E0:11:84:5E:34:DE:BE:88:81:B9:9C:F6:16:26:D1:96:1F:C3:B9:31
  SHA256 Fingerprint=85:60:F9:1C:36:24:DA:BA:95:70:B5:FE:A0:DB:E3:6F:F1:1A:83:23:BE:94:86:85:4F:B3:F3:4A:55:71:19:8D
  -----BEGIN CERTIFICATE-----
  MIICaTCCAe+gAwIBAgIQISpWDK7aDKtARb8roi066jAKBggqhkjOPQQDAzBtMQsw
  CQYDVQQGEwJDSDEQMA4GA1UEChMHV0lTZUtleTEiMCAGA1UECxMZT0lTVEUgRm91
  bmRhdGlvbiBFbmRvcnNlZDEoMCYGA1UEAxMfT0lTVEUgV0lTZUtleSBHbG9iYWwg
  Um9vdCBHQyBDQTAeFw0xNzA1MDkwOTQ4MzRaFw00MjA1MDkwOTU4MzNaMG0xCzAJ
  BgNVBAYTAkNIMRAwDgYDVQQKEwdXSVNlS2V5MSIwIAYDVQQLExlPSVNURSBGb3Vu
  ZGF0aW9uIEVuZG9yc2VkMSgwJgYDVQQDEx9PSVNURSBXSVNlS2V5IEdsb2JhbCBS
  b290IEdDIENBMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAETOlQwMYPchi82PG6s4ni
  eUqjFqdrVCTbUf/q9Akkwwsin8tqJ4KBDdLArzHkdIJuyiXZjHWd8dvQmqJLIX4W
  p2OQ0jnUsYd4XxiWD1AbNTcPasbc2RNNpI6QN+a9WzGRo1QwUjAOBgNVHQ8BAf8E
  BAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUSIcUrOPDnpBgOtfKie7T
  rYy0UGYwEAYJKwYBBAGCNxUBBAMCAQAwCgYIKoZIzj0EAwMDaAAwZQIwJsdpW9zV
  57LnyAyMjMPdeYwbY9XJUpROTYJKcx6ygISpJcBMWm1JKWB4E+J+SOtkAjEA2zQg
  Mgj/mkkCtojeFK9dbJlxjRo/i9fgojaGHAeCOnZT/cKi7e97sIBPWA9LUzm9
  -----END CERTIFICATE-----

  ### XRamp Security Services Inc

  === /C=US/OU=www.xrampsecurity.com/O=XRamp Security Services Inc/CN=XRamp Global Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              50:94:6c:ec:18:ea:d5:9c:4d:d5:97:ef:75:8f:a0:ad
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Nov  1 17:14:04 2004 GMT
              Not After : Jan  1 05:37:19 2035 GMT
          Subject: C=US, OU=www.xrampsecurity.com, O=XRamp Security Services Inc, CN=XRamp Global Certification Authority
          X509v3 extensions:
              1.3.6.1.4.1.311.20.2:
                  ...C.A
              X509v3 Key Usage:
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  C6:4F:A2:3D:06:63:84:09:9C:CE:62:E4:04:AC:8D:5C:B5:E9:B6:1B
              X509v3 CRL Distribution Points:

                  Full Name:
                    URI:http://crl.xrampsecurity.com/XGCA.crl

              1.3.6.1.4.1.311.21.1:
                  ...
  SHA1 Fingerprint=B8:01:86:D1:EB:9C:86:A5:41:04:CF:30:54:F3:4C:52:B7:E5:58:C6
  SHA256 Fingerprint=CE:CD:DC:90:50:99:D8:DA:DF:C5:B1:D2:09:B7:37:CB:E2:C1:8C:FB:2C:10:C0:FF:0B:CF:0D:32:86:FC:1A:A2
  -----BEGIN CERTIFICATE-----
  MIIEMDCCAxigAwIBAgIQUJRs7Bjq1ZxN1ZfvdY+grTANBgkqhkiG9w0BAQUFADCB
  gjELMAkGA1UEBhMCVVMxHjAcBgNVBAsTFXd3dy54cmFtcHNlY3VyaXR5LmNvbTEk
  MCIGA1UEChMbWFJhbXAgU2VjdXJpdHkgU2VydmljZXMgSW5jMS0wKwYDVQQDEyRY
  UmFtcCBHbG9iYWwgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDQxMTAxMTcx
  NDA0WhcNMzUwMTAxMDUzNzE5WjCBgjELMAkGA1UEBhMCVVMxHjAcBgNVBAsTFXd3
  dy54cmFtcHNlY3VyaXR5LmNvbTEkMCIGA1UEChMbWFJhbXAgU2VjdXJpdHkgU2Vy
  dmljZXMgSW5jMS0wKwYDVQQDEyRYUmFtcCBHbG9iYWwgQ2VydGlmaWNhdGlvbiBB
  dXRob3JpdHkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCYJB69FbS6
  38eMpSe2OAtp87ZOqCwuIR1cRN8hXX4jdP5efrRKt6atH67gBhbim1vZZ3RrXYCP
  KZ2GG9mcDZhtdhAoWORlsH9KmHmf4MMxfoArtYzAQDsRhtDLooY2YKTVMIJt2W7Q
  DxIEM5dfT2Fa8OT5kavnHTu86M/0ay00fOJIYRyO82FEzG+gSqmUsE3a56k0enI4
  qEHMPJQRfevIpoy3hsvKMzvZPTeL+3o+hiznc9cKV6xkmxnr9A8ECIqsAxcZZPRa
  JSKNNCyy9mgdEm3Tih4U2sSPpuIjhdV6Db1q4Ons7Be7QhtnqiXtRYMh/MHJfNVi
  PvryxS3T/dRlAgMBAAGjgZ8wgZwwEwYJKwYBBAGCNxQCBAYeBABDAEEwCwYDVR0P
  BAQDAgGGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFMZPoj0GY4QJnM5i5ASs
  jVy16bYbMDYGA1UdHwQvMC0wK6ApoCeGJWh0dHA6Ly9jcmwueHJhbXBzZWN1cml0
  eS5jb20vWEdDQS5jcmwwEAYJKwYBBAGCNxUBBAMCAQEwDQYJKoZIhvcNAQEFBQAD
  ggEBAJEVOQMBG2f7Shz5CmBbodpNl2L5JFMn14JkTpAuw0kbK5rc/Kh4ZzXxHfAR
  vbdI4xD2Dd8/0sm2qlWkSLoC295ZLhVbO50WfUfXN+pfTXYSNrsf16GBBEYgoyxt
  qZ4Bfj8pzgCT3/3JknOJiWSe5yvkHJEs0rnOfc5vMZnT5r7SHpDwCRR5XCOrTdLa
  IR9NmXmd4c8nnxCbHIgNsIpkQTG4DmyQJKSbXHGPurt+HBvbaoAPIbzp26a3QPSy
  i6mx5O+aGtA9aZnuqCij4Tyz8LIRnM98QObd50N9otg6tamN8jSZxNQQ4Qb9CYQQ
  O+7ETPTsJ3xCwnR8gooJybQDJbw=
  -----END CERTIFICATE-----
)certs"
#include "library/common/engine.h"

#include "source/common/api/os_sys_calls_impl.h"
#include "source/common/common/lock_guard.h"
#include "source/common/runtime/runtime_features.h"

#include "absl/synchronization/notification.h"
#include "library/common/bridge/utility.h"
#include "library/common/data/utility.h"
#include "library/common/stats/utility.h"

namespace Envoy {

static std::atomic<envoy_stream_t> current_stream_handle_{0};

envoy_stream_t Engine::initStream() { return current_stream_handle_++; }

Engine::Engine(envoy_engine_callbacks callbacks, envoy_logger logger,
               envoy_event_tracker event_tracker)
    : callbacks_(callbacks), logger_(logger), event_tracker_(event_tracker),
      dispatcher_(std::make_unique<Event::ProvisionalDispatcher>()) {
  ExtensionRegistry::registerFactories();

  // TODO(Augustyniak): Capturing an address of event_tracker_ and registering it in the API
  // registry may lead to crashes at Engine shutdown. To be figured out as part of
  // https://github.com/envoyproxy/envoy-mobile/issues/332
  Envoy::Api::External::registerApi(std::string(envoy_event_tracker_api_name), &event_tracker_);
  // Envoy Mobile always requires dfp_mixed_scheme for the TLS and cleartext DFP clusters.
  // While dfp_mixed_scheme defaults to true, some environments force it to false (e.g. within
  // Google), so we force it back to true in Envoy Mobile.
  // TODO(abeyad): Remove once this is no longer needed.
  Runtime::maybeSetRuntimeGuard("envoy.reloadable_features.dfp_mixed_scheme", true);
}

envoy_status_t Engine::run(const std::string& config, const std::string& log_level) {
  // Start the Envoy on the dedicated thread. Note: due to how the assignment operator works with
  // std::thread, main_thread_ is the same object after this call, but its state is replaced with
  // that of the temporary. The temporary object's state becomes the default state, which does
  // nothing.
  auto options = std::make_unique<Envoy::OptionsImplBase>();
  options->setConfigYaml(config);
  if (!log_level.empty()) {
    ENVOY_BUG(options->setLogLevel(log_level).ok(), "invalid log level");
  }
  options->setConcurrency(1);
  return run(std::move(options));
}

envoy_status_t Engine::run(std::unique_ptr<Envoy::OptionsImplBase>&& options) {
  main_thread_ = std::thread(&Engine::main, this, std::move(options));
  return ENVOY_SUCCESS;
}

envoy_status_t Engine::main(std::unique_ptr<Envoy::OptionsImplBase>&& options) {
  // Using unique_ptr ensures main_common's lifespan is strictly scoped to this function.
  std::unique_ptr<EngineCommon> main_common;
  {
    Thread::LockGuard lock(mutex_);
    TRY_NEEDS_AUDIT {
      if (event_tracker_.track != nullptr) {
        assert_handler_registration_ =
            Assert::addDebugAssertionFailureRecordAction([this](const char* location) {
              const auto event = Bridge::Utility::makeEnvoyMap(
                  {{"name", "assertion"}, {"location", std::string(location)}});
              event_tracker_.track(event, event_tracker_.context);
            });
        bug_handler_registration_ =
            Assert::addEnvoyBugFailureRecordAction([this](const char* location) {
              const auto event = Bridge::Utility::makeEnvoyMap(
                  {{"name", "bug"}, {"location", std::string(location)}});
              event_tracker_.track(event, event_tracker_.context);
            });
      }

      // We let the thread clean up this log delegate pointer
      if (logger_.log) {
        log_delegate_ptr_ =
            std::make_unique<Logger::LambdaDelegate>(logger_, Logger::Registry::getSink());
      } else {
        log_delegate_ptr_ =
            std::make_unique<Logger::DefaultDelegate>(log_mutex_, Logger::Registry::getSink());
      }

      main_common = std::make_unique<EngineCommon>(std::move(options));
      server_ = main_common->server();
      event_dispatcher_ = &server_->dispatcher();

      cv_.notifyAll();
    }
    END_TRY
    CATCH(const Envoy::EnvoyException& e, { PANIC(e.what()); });

    // Note: We're waiting longer than we might otherwise to drain to the main thread's dispatcher.
    // This is because we're not simply waiting for its availability and for it to have started, but
    // also because we're waiting for clusters to have done their first attempt at DNS resolution.
    // When we improve synchronous failure handling and/or move to dynamic forwarding, we only need
    // to wait until the dispatcher is running (and can drain by enqueueing a drain callback on it,
    // as we did previously).

    postinit_callback_handler_ = main_common->server()->lifecycleNotifier().registerCallback(
        Envoy::Server::ServerLifecycleNotifier::Stage::PostInit, [this]() -> void {
          ASSERT(Thread::MainThread::isMainOrTestThread());

          Envoy::Server::GenericFactoryContextImpl generic_context(
              server_->serverFactoryContext(),
              server_->serverFactoryContext().messageValidationVisitor());
          connectivity_manager_ = Network::ConnectivityManagerFactory{generic_context}.get();
          auto v4_interfaces = connectivity_manager_->enumerateV4Interfaces();
          auto v6_interfaces = connectivity_manager_->enumerateV6Interfaces();
          logInterfaces("netconf_get_v4_interfaces", v4_interfaces);
          logInterfaces("netconf_get_v6_interfaces", v6_interfaces);
          client_scope_ = server_->serverFactoryContext().scope().createScope("pulse.");
          // StatNameSet is lock-free, the benefit of using it is being able to create StatsName
          // on-the-fly without risking contention on system with lots of threads.
          // It also comes with ease of programming.
          stat_name_set_ = client_scope_->symbolTable().makeSet("pulse");
          auto api_listener = server_->listenerManager().apiListener()->get().createHttpApiListener(
              server_->dispatcher());
          ASSERT(api_listener != nullptr);
          http_client_ = std::make_unique<Http::Client>(std::move(api_listener), *dispatcher_,
                                                        server_->serverFactoryContext().scope(),
                                                        server_->api().randomGenerator());
          dispatcher_->drain(server_->dispatcher());
          if (callbacks_.on_engine_running != nullptr) {
            callbacks_.on_engine_running(callbacks_.context);
          }
        });
  } // mutex_

  // The main run loop must run without holding the mutex, so that the destructor can acquire it.
  bool run_success = main_common->run();
  // The above call is blocking; at this point the event loop has exited.

  // Ensure destructors run on Envoy's main thread.
  postinit_callback_handler_.reset(nullptr);
  connectivity_manager_.reset();
  client_scope_.reset();
  stat_name_set_.reset();
  main_common.reset(nullptr);
  bug_handler_registration_.reset(nullptr);
  assert_handler_registration_.reset(nullptr);

  callbacks_.on_exit(callbacks_.context);

  return run_success ? ENVOY_SUCCESS : ENVOY_FAILURE;
}

envoy_status_t Engine::terminate() {
  // If main_thread_ has finished (or hasn't started), there's nothing more to do.
  if (!main_thread_.joinable()) {
    return ENVOY_FAILURE;
  }

  // We need to be sure that MainCommon is finished being constructed so we can dispatch shutdown.
  {
    Thread::LockGuard lock(mutex_);

    if (!event_dispatcher_) {
      cv_.wait(mutex_);
    }

    ASSERT(event_dispatcher_);
    ASSERT(dispatcher_);

    // We must destroy the Http::ApiListener in the main thread.
    dispatcher_->post([this]() { http_client_->shutdownApiListener(); });

    // Exit the event loop and finish up in Engine::run(...)
    if (std::this_thread::get_id() == main_thread_.get_id()) {
      // TODO(goaway): figure out some way to support this.
      PANIC("Terminating the engine from its own main thread is currently unsupported.");
    } else {
      dispatcher_->terminate();
    }
  } // lock(_mutex)

  if (std::this_thread::get_id() != main_thread_.get_id()) {
    main_thread_.join();
  }

  return ENVOY_SUCCESS;
}

Engine::~Engine() { terminate(); }

envoy_status_t Engine::setProxySettings(const char* hostname, const uint16_t port) {
  return dispatcher_->post([&, host = std::string(hostname), port]() -> void {
    connectivity_manager_->setProxySettings(Network::ProxySettings::parseHostAndPort(host, port));
  });
}

envoy_status_t Engine::resetConnectivityState() {
  return dispatcher_->post([&]() -> void { connectivity_manager_->resetConnectivityState(); });
}

envoy_status_t Engine::setPreferredNetwork(envoy_network_t network) {
  return dispatcher_->post([&, network]() -> void {
    envoy_netconf_t configuration_key =
        Envoy::Network::ConnectivityManagerImpl::setPreferredNetwork(network);
    connectivity_manager_->refreshDns(configuration_key, true);
  });
}

envoy_status_t Engine::recordCounterInc(absl::string_view elements, envoy_stats_tags tags,
                                        uint64_t count) {
  return dispatcher_->post(
      [&, name = Stats::Utility::sanitizeStatsName(elements), tags, count]() -> void {
        ENVOY_LOG(trace, "[pulse.{}] recordCounterInc", name);
        Stats::StatNameTagVector tags_vctr =
            Stats::Utility::transformToStatNameTagVector(tags, stat_name_set_);
        Stats::Utility::counterFromElements(*client_scope_, {Stats::DynamicName(name)}, tags_vctr)
            .add(count);
      });
}

Event::ProvisionalDispatcher& Engine::dispatcher() { return *dispatcher_; }

void statsAsText(const std::map<std::string, uint64_t>& all_stats,
                 const std::vector<Stats::ParentHistogramSharedPtr>& histograms,
                 Buffer::Instance& response) {
  for (const auto& stat : all_stats) {
    response.addFragments({stat.first, ": ", absl::StrCat(stat.second), "\n"});
  }
  std::map<std::string, std::string> all_histograms;
  for (const Stats::ParentHistogramSharedPtr& histogram : histograms) {
    if (histogram->used()) {
      all_histograms.emplace(histogram->name(), histogram->quantileSummary());
    }
  }
  for (const auto& histogram : all_histograms) {
    response.addFragments({histogram.first, ": ", histogram.second, "\n"});
  }
}

void handlerStats(Stats::Store& stats, Buffer::Instance& response) {
  std::map<std::string, uint64_t> all_stats;
  for (const Stats::CounterSharedPtr& counter : stats.counters()) {
    if (counter->used()) {
      all_stats.emplace(counter->name(), counter->value());
    }
  }

  for (const Stats::GaugeSharedPtr& gauge : stats.gauges()) {
    if (gauge->used()) {
      all_stats.emplace(gauge->name(), gauge->value());
    }
  }

  std::vector<Stats::ParentHistogramSharedPtr> histograms = stats.histograms();
  stats.symbolTable().sortByStatNames<Stats::ParentHistogramSharedPtr>(
      histograms.begin(), histograms.end(),
      [](const Stats::ParentHistogramSharedPtr& a) -> Stats::StatName { return a->statName(); });

  statsAsText(all_stats, histograms, response);
}

envoy_status_t Engine::dumpStats(envoy_data* out) {
  // If the engine isn't running, fail.
  if (!main_thread_.joinable()) {
    return ENVOY_FAILURE;
  }

  absl::Notification stats_received;
  if (dispatcher_->post([&]() -> void {
        Envoy::Buffer::OwnedImpl instance;
        handlerStats(server_->stats(), instance);
        *out = Envoy::Data::Utility::toBridgeData(instance, 1024 * 1024 * 100);
        stats_received.Notify();
      }) == ENVOY_SUCCESS) {
    stats_received.WaitForNotification();
    return ENVOY_SUCCESS;
  }
  return ENVOY_FAILURE;
}

Upstream::ClusterManager& Engine::getClusterManager() {
  ASSERT(dispatcher_->isThreadSafe(),
         "getClusterManager must be called from the dispatcher's context");
  return server_->clusterManager();
}

Stats::Store& Engine::getStatsStore() {
  ASSERT(dispatcher_->isThreadSafe(), "getStatsStore must be called from the dispatcher's context");
  return server_->stats();
}

void Engine::logInterfaces(absl::string_view event,
                           std::vector<Network::InterfacePair>& interfaces) {
  std::vector<std::string> names;
  names.resize(interfaces.size());
  std::transform(interfaces.begin(), interfaces.end(), names.begin(),
                 [](Network::InterfacePair& pair) { return std::get<0>(pair); });

  auto unique_end = std::unique(names.begin(), names.end());
  std::string all_names = std::accumulate(names.begin(), unique_end, std::string{},
                                          [](std::string acc, std::string next) {
                                            return acc.empty() ? next : std::move(acc) + "," + next;
                                          });
  ENVOY_LOG_EVENT(debug, event, all_names);
}

} // namespace Envoy
#include "library/common/bridge/utility.h"

#include <string>

namespace Envoy {
namespace Bridge {
namespace Utility {

envoy_error_code_t errorCodeFromLocalStatus(Http::Code status) {
  switch (status) {
  case Http::Code::RequestTimeout:
    return ENVOY_REQUEST_TIMEOUT;
  case Http::Code::PayloadTooLarge:
    return ENVOY_BUFFER_LIMIT_EXCEEDED;
  case Http::Code::ServiceUnavailable:
    return ENVOY_CONNECTION_FAILURE;
  default:
    return ENVOY_UNDEFINED_ERROR;
  }
}

envoy_map makeEnvoyMap(std::initializer_list<std::pair<std::string, std::string>> map) {
  return makeEnvoyMap<std::initializer_list<std::pair<std::string, std::string>>>(map);
}

} // namespace Utility
} // namespace Bridge
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "utility_lib",
    srcs = ["utility.cc"],
    hdrs = ["utility.h"],
    repository = "@envoy",
    visibility = ["//visibility:public"],
    deps = [
        "//library/common/data:utility_lib",
        "//library/common/types:c_types_lib",
        "@envoy//envoy/http:codes_interface",
        "@envoy//source/common/http:codes_lib",
    ],
)
#pragma once

#include <string>

#include "source/common/http/codes.h"

#include "library/common/data/utility.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Bridge {
namespace Utility {

envoy_error_code_t errorCodeFromLocalStatus(Http::Code status);

// Helper that converts a C++ map-like (i.e. anything that iterates over a pair of strings) type
// into an envoy_map, copying all the values.
template <class T> envoy_map makeEnvoyMap(const T& map) {
  envoy_map new_map;
  new_map.length = std::size(map);
  new_map.entries =
      static_cast<envoy_map_entry*>(safe_malloc(sizeof(envoy_map_entry) * std::size(map)));

  uint64_t i = 0;
  for (const auto& e : map) {
    new_map.entries[i].key = Envoy::Data::Utility::copyToBridgeData(e.first);
    new_map.entries[i].value = Envoy::Data::Utility::copyToBridgeData(e.second);
    i++;
  }

  return new_map;
}

// Function overload that helps resolve makeEnvoyMap({{"key", "value"}}).
envoy_map makeEnvoyMap(std::initializer_list<std::pair<std::string, std::string>> map);

} // namespace Utility
} // namespace Bridge
} // namespace Envoy
#pragma once

#include "envoy/config/core/v3/base.pb.h"
#include "envoy/network/address.h"
#include "envoy/network/listen_socket.h"

namespace Envoy {
namespace Network {

/**
 * This is a "synthetic" socket option implementation, which sets the source IP/port of a socket
 * using a provided IP address (and maybe port) during bind.
 *
 * Based on the OriginalSrcSocketOption extension.
 */
class SrcAddrSocketOptionImpl : public Network::Socket::Option {
public:
  /**
   * Constructs a socket option which will set the socket to use source @c source_address
   */
  SrcAddrSocketOptionImpl(Network::Address::InstanceConstSharedPtr source_address);
  ~SrcAddrSocketOptionImpl() override = default;

  /**
   * Updates the source address of the socket to match `source_address_`.
   * Adds socket options to the socket to allow this to work.
   */
  bool setOption(Network::Socket& socket,
                 envoy::config::core::v3::SocketOption::SocketState state) const override;

  /**
   * Appends a key which uniquely identifies the address being tracked.
   */
  void hashKey(std::vector<uint8_t>& key) const override;

  absl::optional<Details>
  getOptionDetails(const Network::Socket& socket,
                   envoy::config::core::v3::SocketOption::SocketState state) const override;
  bool isSupported() const override { return true; }

private:
  Network::Address::InstanceConstSharedPtr source_address_;
};

} // namespace Network
} // namespace Envoy
#include "library/common/network/connectivity_manager.h"

#include <net/if.h>

#include "envoy/common/platform.h"

#include "source/common/api/os_sys_calls_impl.h"
#include "source/common/common/assert.h"
#include "source/common/common/scalar_to_byte_vector.h"
#include "source/common/common/utility.h"
#include "source/common/network/addr_family_aware_socket_option_impl.h"
#include "source/common/network/address_impl.h"
#include "source/extensions/common/dynamic_forward_proxy/dns_cache_manager_impl.h"

#include "fmt/ostream.h"
#include "library/common/network/src_addr_socket_option_impl.h"

// Used on Linux (requires root/CAP_NET_RAW)
#ifdef SO_BINDTODEVICE
#define ENVOY_SOCKET_SO_BINDTODEVICE ENVOY_MAKE_SOCKET_OPTION_NAME(SOL_SOCKET, SO_BINDTODEVICE)
#else
#define ENVOY_SOCKET_SO_BINDTODEVICE Network::SocketOptionName()
#endif

// Used on BSD/iOS
#ifdef IP_BOUND_IF
#define ENVOY_SOCKET_IP_BOUND_IF ENVOY_MAKE_SOCKET_OPTION_NAME(IPPROTO_IP, IP_BOUND_IF)
#else
#define ENVOY_SOCKET_IP_BOUND_IF Network::SocketOptionName()
#endif

#ifdef IPV6_BOUND_IF
#define ENVOY_SOCKET_IPV6_BOUND_IF ENVOY_MAKE_SOCKET_OPTION_NAME(IPPROTO_IPV6, IPV6_BOUND_IF)
#else
#define ENVOY_SOCKET_IPV6_BOUND_IF Network::SocketOptionName()
#endif

// Dummy/test option
#ifdef IP_TTL
#define ENVOY_SOCKET_IP_TTL ENVOY_MAKE_SOCKET_OPTION_NAME(IPPROTO_IP, IP_TTL)
#else
#define ENVOY_SOCKET_IP_TTL Network::SocketOptionName()
#endif

#ifdef IPV6_UNICAST_HOPS
#define ENVOY_SOCKET_IPV6_UNICAST_HOPS                                                             \
  ENVOY_MAKE_SOCKET_OPTION_NAME(IPPROTO_IPV6, IPV6_UNICAST_HOPS)
#else
#define ENVOY_SOCKET_IPV6_UNICAST_HOPS Network::SocketOptionName()
#endif

#define DEFAULT_IP_TTL 64

// Prefixes used to prefer well-known interface names.
#if defined(__APPLE__)
constexpr absl::string_view WlanPrefix = "en";
constexpr absl::string_view WwanPrefix = "pdp_ip";
#elif defined(__ANDROID_API__)
constexpr absl::string_view WlanPrefix = "wlan";
constexpr absl::string_view WwanPrefix = "rmnet";
#else
// An empty prefix is essentially the same as disabling filtering since it will always match.
constexpr absl::string_view WlanPrefix = "";
constexpr absl::string_view WwanPrefix = "";
#endif

namespace Envoy {
namespace Network {

SINGLETON_MANAGER_REGISTRATION(connectivity_manager);

constexpr absl::string_view BaseDnsCache = "base_dns_cache";

// The number of faults allowed on a newly-established connection before switching socket mode.
constexpr unsigned int InitialFaultThreshold = 1;
// The number of faults allowed on a previously-successful connection (i.e. able to send and receive
// L7 bytes) before switching socket mode.
constexpr unsigned int MaxFaultThreshold = 3;

ConnectivityManagerImpl::NetworkState ConnectivityManagerImpl::network_state_{
    1, ENVOY_NET_GENERIC, MaxFaultThreshold, DefaultPreferredNetworkMode,
    Thread::MutexBasicLockable{}};

envoy_netconf_t ConnectivityManagerImpl::setPreferredNetwork(envoy_network_t network) {
  Thread::LockGuard lock{network_state_.mutex_};

  // TODO(goaway): Re-enable this guard. There's some concern that this will miss network updates
  // moving from offline to online states. We should address this then re-enable this guard to
  // avoid unnecessary cache refresh and connection drain.
  // if (network_state_.network_ == network) {
  //  // Provide a non-current key preventing further scheduled effects (e.g. DNS refresh).
  //  return network_state_.configuration_key_ - 1;
  //}

  ENVOY_LOG_EVENT(debug, "netconf_network_change", std::to_string(network));

  network_state_.configuration_key_++;
  network_state_.network_ = network;
  network_state_.remaining_faults_ = 1;
  network_state_.socket_mode_ = DefaultPreferredNetworkMode;

  return network_state_.configuration_key_;
}

void ConnectivityManagerImpl::setProxySettings(ProxySettingsConstSharedPtr new_proxy_settings) {
  if (proxy_settings_ == nullptr && new_proxy_settings != nullptr) {
    ENVOY_LOG_EVENT(info, "netconf_proxy_change", new_proxy_settings->asString());
    proxy_settings_ = new_proxy_settings;
  } else if (proxy_settings_ != nullptr && new_proxy_settings == nullptr) {
    ENVOY_LOG_EVENT(info, "netconf_proxy_change", "no_proxy_configured");
    proxy_settings_ = new_proxy_settings;
  } else if (proxy_settings_ != nullptr && new_proxy_settings != nullptr &&
             *proxy_settings_ != *new_proxy_settings) {
    ENVOY_LOG_EVENT(info, "netconf_proxy_change", new_proxy_settings->asString());
    proxy_settings_ = new_proxy_settings;
  }

  return;
}

ProxySettingsConstSharedPtr ConnectivityManagerImpl::getProxySettings() { return proxy_settings_; }

envoy_network_t ConnectivityManagerImpl::getPreferredNetwork() {
  Thread::LockGuard lock{network_state_.mutex_};
  return network_state_.network_;
}

envoy_socket_mode_t ConnectivityManagerImpl::getSocketMode() {
  Thread::LockGuard lock{network_state_.mutex_};
  return network_state_.socket_mode_;
}

envoy_netconf_t ConnectivityManagerImpl::getConfigurationKey() {
  Thread::LockGuard lock{network_state_.mutex_};
  return network_state_.configuration_key_;
}

// This call contains the main heuristic that will determine if the network connectivity_manager
// switches socket modes: If the configuration_key isn't current, don't do anything. If there was no
// fault (i.e. success) reset remaining_faults_ to MaxFaultTreshold. If there was a network fault,
// decrement remaining_faults_.
//   - At 0, increment configuration_key, reset remaining_faults_ to InitialFaultThreshold and
//     toggle socket_mode_.
void ConnectivityManagerImpl::reportNetworkUsage(envoy_netconf_t configuration_key,
                                                 bool network_fault) {
  ENVOY_LOG(debug, "reportNetworkUsage(configuration_key: {}, network_fault: {})",
            configuration_key, network_fault);

  if (!enable_interface_binding_) {
    ENVOY_LOG(debug, "bailing due to interface binding being disabled");
    return;
  }

  bool configuration_updated = false;
  {
    Thread::LockGuard lock{network_state_.mutex_};

    // If the configuration_key isn't current, don't do anything.
    if (configuration_key != network_state_.configuration_key_) {
      ENVOY_LOG(debug, "bailing due to stale configuration key");
      return;
    }

    if (!network_fault) {
      // If there was no fault (i.e. success) reset remaining_faults_ to MaxFaultThreshold.
      ENVOY_LOG(debug, "resetting fault threshold");
      network_state_.remaining_faults_ = MaxFaultThreshold;
    } else {
      // If there was a network fault, decrement remaining_faults_.
      ASSERT(network_state_.remaining_faults_ > 0);
      network_state_.remaining_faults_--;
      ENVOY_LOG(debug, "decrementing remaining faults; {} remaining",
                network_state_.remaining_faults_);

      // At 0, increment configuration_key, reset remaining_faults_ to InitialFaultThreshold and
      // toggle socket_mode_.
      if (network_state_.remaining_faults_ == 0) {
        configuration_updated = true;
        configuration_key = ++network_state_.configuration_key_;
        network_state_.socket_mode_ = network_state_.socket_mode_ == DefaultPreferredNetworkMode
                                          ? AlternateBoundInterfaceMode
                                          : DefaultPreferredNetworkMode;
        network_state_.remaining_faults_ = InitialFaultThreshold;
        if (network_state_.socket_mode_ == DefaultPreferredNetworkMode) {
          ENVOY_LOG_EVENT(debug, "netconf_mode_switch", "DefaultPreferredNetworkMode");
        } else if (network_state_.socket_mode_ == AlternateBoundInterfaceMode) {
          auto v4_pair = getActiveAlternateInterface(network_state_.network_, AF_INET);
          auto v6_pair = getActiveAlternateInterface(network_state_.network_, AF_INET6);
          ENVOY_LOG_EVENT(debug, "netconf_mode_switch", "AlternateBoundInterfaceMode [{}|{}]",
                          std::get<const std::string>(v4_pair),
                          std::get<const std::string>(v6_pair));
        }
      }
    }
  }

  // If configuration state changed, refresh dns.
  if (configuration_updated) {
    refreshDns(configuration_key, false);
  }
}

void ConnectivityManagerImpl::onDnsResolutionComplete(
    const std::string& resolved_host,
    const Extensions::Common::DynamicForwardProxy::DnsHostInfoSharedPtr&,
    Network::DnsResolver::ResolutionStatus) {
  if (enable_drain_post_dns_refresh_) {
    // Check if the set of hosts pending drain contains the current resolved host.
    if (hosts_to_drain_.erase(resolved_host) == 0) {
      return;
    }

    // We ignore whether DNS resolution has succeeded here. If it failed, we may be offline and
    // should probably drain connections. If it succeeds, we may have new DNS entries and so we
    // drain connections. It may be possible to refine this logic in the future.
    // TODO(goaway): check the set of cached hosts from the last triggered DNS refresh for this
    // host, and if present, remove it and trigger connection drain for this host specifically.
    ENVOY_LOG_EVENT(debug, "netconf_post_dns_drain_cx", resolved_host);

    // Pass predicate to only drain connections to the resolved host (for any cluster).
    cluster_manager_.drainConnections(
        [resolved_host](const Upstream::Host& host) { return host.hostname() == resolved_host; });
  }
}

void ConnectivityManagerImpl::setDrainPostDnsRefreshEnabled(bool enabled) {
  enable_drain_post_dns_refresh_ = enabled;
  if (!enabled) {
    hosts_to_drain_.clear();
  } else if (!dns_callbacks_handle_) {
    // Register callbacks once, on demand, using the handle as a sentinel. There may not be
    // a DNS cache during initialization, but if one is available, it should always exist by the
    // time this function is called from the NetworkConfigurationFilter.
    if (auto dns_cache = dnsCache()) {
      dns_callbacks_handle_ = dns_cache->addUpdateCallbacks(*this);
    }
  }
}

void ConnectivityManagerImpl::setInterfaceBindingEnabled(bool enabled) {
  enable_interface_binding_ = enabled;
}

void ConnectivityManagerImpl::refreshDns(envoy_netconf_t configuration_key,
                                         bool drain_connections) {
  {
    Thread::LockGuard lock{network_state_.mutex_};

    // refreshDns must be queued on Envoy's event loop, whereas network_state_ is updated
    // synchronously. In the event that multiple refreshes become queued on the event loop,
    // this check avoids triggering a refresh for a non-current network.
    // Note this does NOT completely prevent parallel refreshes from being triggered in multiple
    // flip-flop scenarios.
    if (configuration_key != network_state_.configuration_key_) {
      ENVOY_LOG_EVENT(debug, "netconf_dns_flipflop", std::to_string(configuration_key));
      return;
    }
  }

  if (auto dns_cache = dnsCache()) {
    ENVOY_LOG_EVENT(debug, "netconf_refresh_dns", std::to_string(configuration_key));

    if (drain_connections && enable_drain_post_dns_refresh_) {
      dns_cache->iterateHostMap(
          [&](absl::string_view host,
              const Extensions::Common::DynamicForwardProxy::DnsHostInfoSharedPtr&) {
            hosts_to_drain_.emplace(host);
          });
    }

    dns_cache->forceRefreshHosts();
  }
}

Extensions::Common::DynamicForwardProxy::DnsCacheSharedPtr ConnectivityManagerImpl::dnsCache() {
  auto cache = dns_cache_manager_->lookUpCacheByName(BaseDnsCache);
  if (!cache) {
    ENVOY_LOG_EVENT(warn, "netconf_dns_cache_missing", std::string(BaseDnsCache));
  }
  return cache;
}

void ConnectivityManagerImpl::resetConnectivityState() {
  envoy_netconf_t configuration_key;
  {
    Thread::LockGuard lock{network_state_.mutex_};
    network_state_.remaining_faults_ = 1;
    network_state_.socket_mode_ = DefaultPreferredNetworkMode;
    configuration_key = ++network_state_.configuration_key_;
  }

  refreshDns(configuration_key, true);
}

std::vector<InterfacePair> ConnectivityManagerImpl::enumerateV4Interfaces() {
  return enumerateInterfaces(AF_INET, 0, 0);
}

std::vector<InterfacePair> ConnectivityManagerImpl::enumerateV6Interfaces() {
  return enumerateInterfaces(AF_INET6, 0, 0);
}

Socket::OptionsSharedPtr
ConnectivityManagerImpl::getUpstreamSocketOptions(envoy_network_t network,
                                                  envoy_socket_mode_t socket_mode) {
  if (enable_interface_binding_ && socket_mode == AlternateBoundInterfaceMode &&
      network != ENVOY_NET_GENERIC) {
    return getAlternateInterfaceSocketOptions(network);
  }

  // Envoy uses the hash signature of overridden socket options to choose a connection pool.
  // Setting a dummy socket option is a hack that allows us to select a different
  // connection pool without materially changing the socket configuration.
  ASSERT(network >= 0 && network < 3);
  int ttl_value = DEFAULT_IP_TTL + static_cast<int>(network);
  auto options = std::make_shared<Socket::Options>();
  options->push_back(std::make_shared<AddrFamilyAwareSocketOptionImpl>(
      envoy::config::core::v3::SocketOption::STATE_PREBIND, ENVOY_SOCKET_IP_TTL,
      ENVOY_SOCKET_IPV6_UNICAST_HOPS, ttl_value));
  return options;
}

Socket::OptionsSharedPtr
ConnectivityManagerImpl::getAlternateInterfaceSocketOptions(envoy_network_t network) {
  auto v4_pair = getActiveAlternateInterface(network, AF_INET);
  auto v6_pair = getActiveAlternateInterface(network, AF_INET6);
  ENVOY_LOG(debug, "found active alternate interface (ipv4): {} {}", std::get<0>(v4_pair),
            std::get<1>(v4_pair)->asString());
  ENVOY_LOG(debug, "found active alternate interface (ipv6): {} {}", std::get<0>(v6_pair),
            std::get<1>(v6_pair)->asString());

  auto options = std::make_shared<Socket::Options>();

#ifdef IP_BOUND_IF
  // iOS
  // On platforms where it exists, IP_BOUND_IF/IPV6_BOUND_IF provide a straightforward way to bind
  // a socket explicitly to specific interface. (The Linux alternative is SO_BINDTODEVICE, but has
  // other restriction; see below.)
  int v4_idx = if_nametoindex(std::get<const std::string>(v4_pair).c_str());
  int v6_idx = if_nametoindex(std::get<const std::string>(v6_pair).c_str());
  options->push_back(std::make_shared<AddrFamilyAwareSocketOptionImpl>(
      envoy::config::core::v3::SocketOption::STATE_PREBIND, ENVOY_SOCKET_IP_BOUND_IF, v4_idx,
      ENVOY_SOCKET_IPV6_BOUND_IF, v6_idx));
#else
  // Android
  // SO_BINDTODEVICE is defined on Android, but applying it requires root privileges (or more
  // specifically, CAP_NET_RAW). As a workaround, this binds the socket to the interface by
  // attaching "synthetic" socket option, which sets the socket's source address to the local
  // address of the interface. This is not quite as precise, since it's possible that multiple
  // interfaces share the same local address, but this is all best-effort anyways.
  options->push_back(std::make_shared<AddrFamilyAwareSocketOptionImpl>(
      std::make_unique<SrcAddrSocketOptionImpl>(std::get<1>(v4_pair)),
      std::make_unique<SrcAddrSocketOptionImpl>(std::get<1>(v6_pair))));
#endif

  return options;
}

envoy_netconf_t
ConnectivityManagerImpl::addUpstreamSocketOptions(Socket::OptionsSharedPtr options) {
  envoy_netconf_t configuration_key;
  envoy_network_t network;
  envoy_socket_mode_t socket_mode;

  {
    Thread::LockGuard lock{network_state_.mutex_};
    configuration_key = network_state_.configuration_key_;
    network = network_state_.network_;
    socket_mode = network_state_.socket_mode_;
  }

  auto new_options = getUpstreamSocketOptions(network, socket_mode);
  options->insert(options->end(), new_options->begin(), new_options->end());
  return configuration_key;
}

InterfacePair ConnectivityManagerImpl::getActiveAlternateInterface(envoy_network_t network,
                                                                   unsigned short family) {
  // Attempt to derive an active interface that differs from the passed network parameter.
  if (network == ENVOY_NET_WWAN) {
    // Network is cellular, so look for a WiFi interface.
    // WiFi should always support multicast, and will not be point-to-point.
    auto interfaces =
        enumerateInterfaces(family, IFF_UP | IFF_MULTICAST, IFF_LOOPBACK | IFF_POINTOPOINT);
    for (const auto& interface : interfaces) {
      // Look for interface with name that matches the expected prefix.
      // TODO(goaway): This is quite brittle. It would be an improvement to:
      //   1) Improve the scoping via flags.
      //   2) Prioritize interfaces by prefix instead of simply filtering them.
      if (absl::StartsWith(std::get<const std::string>(interface), WlanPrefix)) {
        return interface;
      }
    }
  } else if (network == ENVOY_NET_WLAN) {
    // Network is WiFi, so look for a cellular interface.
    // Cellular networks should be point-to-point.
    auto interfaces = enumerateInterfaces(family, IFF_UP | IFF_POINTOPOINT, IFF_LOOPBACK);
    for (const auto& interface : interfaces) {
      // Look for interface with name that matches the expected prefix.
      // TODO(goaway): This is quite brittle. It would be an improvement to:
      //   1) Improve the scoping via flags.
      //   2) Prioritize interfaces by prefix instead of simply filtering them.
      if (absl::StartsWith(std::get<const std::string>(interface), WwanPrefix)) {
        return interface;
      }
    }
  }

  return std::make_pair("", nullptr);
}

std::vector<InterfacePair>
ConnectivityManagerImpl::enumerateInterfaces([[maybe_unused]] unsigned short family,
                                             [[maybe_unused]] unsigned int select_flags,
                                             [[maybe_unused]] unsigned int reject_flags) {
  std::vector<InterfacePair> pairs{};

  if (!Api::OsSysCallsSingleton::get().supportsGetifaddrs()) {
    return pairs;
  }

  Api::InterfaceAddressVector interface_addresses{};
  const Api::SysCallIntResult rc = Api::OsSysCallsSingleton::get().getifaddrs(interface_addresses);
  RELEASE_ASSERT(!rc.return_value_, fmt::format("getiffaddrs error: {}", rc.errno_));

  for (const auto& interface_address : interface_addresses) {
    const auto family_version = family == AF_INET ? Envoy::Network::Address::IpVersion::v4
                                                  : Envoy::Network::Address::IpVersion::v6;
    if (interface_address.interface_addr_->ip()->version() != family_version) {
      continue;
    }

    if ((interface_address.interface_flags_ & (select_flags ^ reject_flags)) != select_flags) {
      continue;
    }

    pairs.push_back(
        std::make_pair(interface_address.interface_name_, interface_address.interface_addr_));
  }

  return pairs;
}

ConnectivityManagerSharedPtr ConnectivityManagerFactory::get() {
  return context_.serverFactoryContext().singletonManager().getTyped<ConnectivityManagerImpl>(
      SINGLETON_MANAGER_REGISTERED_NAME(connectivity_manager), [this] {
        Envoy::Extensions::Common::DynamicForwardProxy::DnsCacheManagerFactoryImpl
            cache_manager_factory{context_};
        return std::make_shared<ConnectivityManagerImpl>(
            context_.serverFactoryContext().clusterManager(), cache_manager_factory.get());
      });
}

ConnectivityManagerSharedPtr ConnectivityManagerHandle::get() {
  return singleton_manager_.getTyped<ConnectivityManagerImpl>(
      SINGLETON_MANAGER_REGISTERED_NAME(connectivity_manager));
}

} // namespace Network
} // namespace Envoy
#include "library/common/network/src_addr_socket_option_impl.h"

#include "envoy/config/core/v3/base.pb.h"

#include "source/common/common/assert.h"

namespace Envoy {
namespace Network {

SrcAddrSocketOptionImpl::SrcAddrSocketOptionImpl(
    Network::Address::InstanceConstSharedPtr source_address)
    : source_address_(std::move(source_address)) {
  ASSERT(!source_address_ || source_address_->type() == Network::Address::Type::Ip);
}

bool SrcAddrSocketOptionImpl::setOption(
    Network::Socket& socket, envoy::config::core::v3::SocketOption::SocketState state) const {
  if (source_address_ && state == envoy::config::core::v3::SocketOption::STATE_PREBIND) {
    socket.connectionInfoProvider().setLocalAddress(source_address_);
  }

  return true;
}

/**
 * Inserts an address, already in network order, to a byte array.
 */
template <typename T> void addressIntoVector(std::vector<uint8_t>& vec, const T& address) {
  const uint8_t* byte_array = reinterpret_cast<const uint8_t*>(&address);
  vec.insert(vec.end(), byte_array, byte_array + sizeof(T));
}

void SrcAddrSocketOptionImpl::hashKey(std::vector<uint8_t>& key) const {

  // Note: we're assuming that there cannot be a conflict between IPv6 addresses here. If an IPv4
  // address is mapped into an IPv6 address using an IPv4-Mapped IPv6 Address (RFC4921), then it's
  // possible the hashes will be different despite the IP address used by the connection being
  // the same.
  if (source_address_->ip()->version() == Network::Address::IpVersion::v4) {
    // note raw_address is already in network order
    uint32_t raw_address = source_address_ ? source_address_->ip()->ipv4()->address() : 0;
    addressIntoVector(key, raw_address);
  } else if (source_address_->ip()->version() == Network::Address::IpVersion::v6) {
    // note raw_address is already in network order
    absl::uint128 raw_address = source_address_ ? source_address_->ip()->ipv6()->address() : 0;
    addressIntoVector(key, raw_address);
  }
}

absl::optional<Network::Socket::Option::Details> SrcAddrSocketOptionImpl::getOptionDetails(
    const Network::Socket&, envoy::config::core::v3::SocketOption::SocketState) const {
  // no details for this option.
  return absl::nullopt;
}

} // namespace Network
} // namespace Envoy
#pragma once

#include <string>
#include <vector>

#include "envoy/network/socket.h"
#include "envoy/singleton/manager.h"
#include "envoy/upstream/cluster_manager.h"

#include "source/extensions/common/dynamic_forward_proxy/dns_cache.h"
#include "source/extensions/common/dynamic_forward_proxy/dns_cache_impl.h"

#include "library/common/network/proxy_settings.h"
#include "library/common/types/c_types.h"

/**
 * envoy_netconf_t identifies a snapshot of network configuration state. It's returned from calls
 * that may alter current state, and passed back as a parameter to this API to determine if calls
 * remain valid/relevant at time of execution.
 *
 * Currently, there are two primary circumstances this is used:
 * 1. When network type changes, a refreshDNS call will be scheduled on the event dispatcher, along
 * with a configuration key of this type. If network type changes again before that refresh
 * executes, the refresh is now stale, another refresh task will have been queued, and it should no
 * longer execute. The configuration key allows the connectivity_manager to determine if the
 * refreshDNS call is representative of current configuration.
 * 2. When a request is configured with a certain set of socket options and begins, it is given a
 * configuration key. The heuristic in reportNetworkUsage relies on characteristics of the
 * request/response to make future decisions about socket options, but needs to be able to correctly
 * associate these metrics with their original configuration. If network state changes while the
 * request/response are in-flight, the connectivity_manager can determine the relevance of
 * associated metrics through the configuration key.
 *
 * Additionally, in the future, more advanced heuristics may maintain multiple parallel
 * configurations across different interfaces/network types. In these more complicated scenarios, a
 * configuration key will be able to identify not only if the configuration is current, but also
 * which of several current configurations is relevant.
 */
typedef uint16_t envoy_netconf_t;

/**
 * These values specify the behavior of the network connectivity_manager with respect to the
 * upstream socket options it supplies.
 */
typedef enum {
  // In this mode, the connectivity_manager will provide socket options that result in the creation
  // of a
  // distinct connection pool for a given value of preferred network.
  DefaultPreferredNetworkMode = 0,
  // In this mode, the connectivity_manager will provide socket options that intentionally attempt
  // to
  // override the current preferred network type with an alternative, via interface-binding socket
  // options. Note this mode is experimental, and it will not be enabled at all unless
  // enable_interface_binding_ is set to true.
  AlternateBoundInterfaceMode = 1,
} envoy_socket_mode_t;

namespace Envoy {
namespace Network {

using DnsCacheManagerSharedPtr = Extensions::Common::DynamicForwardProxy::DnsCacheManagerSharedPtr;
using InterfacePair = std::pair<const std::string, Address::InstanceConstSharedPtr>;

/**
 * Object responsible for tracking network state, especially with respect to multiple interfaces,
 * and providing auxiliary configuration to network connections, in the form of upstream socket
 * options.
 *
 * Code is largely structured to be run exclusively on the engine's main thread. However,
 * setPreferredNetwork is allowed to be called from any thread, and the internal NetworkState that
 * it modifies owns a mutex used to synchronize all access to that state.
 * (Note NetworkState was originally designed to fit into an atomic, and could still feasibly be
 * switched to one.)
 *
 * This object is a singleton per-engine. Note that several pieces of functionality assume a DNS
 * cache adhering to the one set up in base configuration will be present, but will become no-ops
 * if that cache is missing either due to alternate configurations, or lifecycle-related timing.
 *
 */
class ConnectivityManager
    : public Extensions::Common::DynamicForwardProxy::DnsCache::UpdateCallbacks {
public:
  virtual ~ConnectivityManager() = default;

  /**
   * @returns a list of local network interfaces supporting IPv4.
   */
  virtual std::vector<InterfacePair> enumerateV4Interfaces() PURE;

  /**
   * @returns a list of local network interfaces supporting IPv6.
   */
  virtual std::vector<InterfacePair> enumerateV6Interfaces() PURE;

  /**
   * @param family, network family of the interface.
   * @param select_flags, flags which MUST be set for each returned interface.
   * @param reject_flags, flags which MUST NOT be set for any returned interface.
   * @returns a list of local network interfaces filtered by the providered flags.
   */
  virtual std::vector<InterfacePair> enumerateInterfaces(unsigned short family,
                                                         unsigned int select_flags,
                                                         unsigned int reject_flags) PURE;

  /**
   * @returns the current OS default/preferred network class.
   */
  virtual envoy_network_t getPreferredNetwork() PURE;

  /**
   * @returns the current mode used to determine upstream socket options.
   */
  virtual envoy_socket_mode_t getSocketMode() PURE;

  /**
   * @returns configuration key representing current network state.
   */
  virtual envoy_netconf_t getConfigurationKey() PURE;

  /**
   *
   * @return the current proxy settings.
   */
  virtual Envoy::Network::ProxySettingsConstSharedPtr getProxySettings() PURE;

  /**
   * Call to report on the current viability of the passed network configuration after an attempt
   * at transmission (e.g., an HTTP request).
   * @param network_fault, whether a transmission attempt terminated w/o receiving upstream bytes.
   */
  virtual void reportNetworkUsage(envoy_netconf_t configuration_key, bool network_fault) PURE;

  /**
   * @brief Sets the current proxy settings.
   *
   * @param proxy_settings The proxy settings. `nullptr` if there is no proxy configured on a
   * device.
   */
  virtual void setProxySettings(ProxySettingsConstSharedPtr proxy_settings) PURE;

  /**
   * Configure whether connections should be drained after a triggered DNS refresh. Currently this
   * may happen either due to an external call to refreshConnectivityState or an update to
   * setPreferredNetwork.
   * @param enabled, whether to enable connection drain after DNS refresh.
   */
  virtual void setDrainPostDnsRefreshEnabled(bool enabled) PURE;

  /**
   * Sets whether subsequent calls for upstream socket options may leverage options that bind
   * to specific network interfaces.
   * @param enabled, whether to enable interface binding.
   */
  virtual void setInterfaceBindingEnabled(bool enabled) PURE;

  /**
   * Refresh DNS in response to preferred network update. May be no-op.
   * @param configuration_key, key provided by this class representing the current configuration.
   * @param drain_connections, request that connections be drained after next DNS resolution.
   */
  virtual void refreshDns(envoy_netconf_t configuration_key, bool drain_connections) PURE;

  /**
   * Drain all upstream connections associated with this Engine.
   */
  virtual void resetConnectivityState() PURE;

  /**
   * @returns the current socket options that should be used for connections.
   */
  virtual Socket::OptionsSharedPtr getUpstreamSocketOptions(envoy_network_t network,
                                                            envoy_socket_mode_t socket_mode) PURE;

  /**
   * @param options, upstream connection options to which additional options should be appended.
   * @returns configuration key to associate with any related calls.
   */
  virtual envoy_netconf_t addUpstreamSocketOptions(Socket::OptionsSharedPtr options) PURE;

  /**
   * Returns the default DNS cache set up in base configuration. This cache may be missing either
   * due to engine lifecycle-related timing or alternate configurations. If it is, operations
   * that use it should revert to no-ops.
   *
   * @returns the default DNS cache set up in base configuration or nullptr.
   */
  virtual Extensions::Common::DynamicForwardProxy::DnsCacheSharedPtr dnsCache() PURE;
};

class ConnectivityManagerImpl : public ConnectivityManager,
                                public Singleton::Instance,
                                public Logger::Loggable<Logger::Id::upstream> {
public:
  /**
   * Sets the current OS default/preferred network class. Note this function is allowed to be
   * called from any thread.
   * @param network, the OS-preferred network.
   * @returns configuration key to associate with any related calls.
   */
  static envoy_netconf_t setPreferredNetwork(envoy_network_t network);

  ConnectivityManagerImpl(Upstream::ClusterManager& cluster_manager,
                          DnsCacheManagerSharedPtr dns_cache_manager)
      : cluster_manager_(cluster_manager), dns_cache_manager_(dns_cache_manager) {}

  // Extensions::Common::DynamicForwardProxy::DnsCache::UpdateCallbacks
  void onDnsHostAddOrUpdate(
      const std::string& /*host*/,
      const Extensions::Common::DynamicForwardProxy::DnsHostInfoSharedPtr&) override {}
  void onDnsHostRemove(const std::string& /*host*/) override {}
  void onDnsResolutionComplete(const std::string& /*host*/,
                               const Extensions::Common::DynamicForwardProxy::DnsHostInfoSharedPtr&,
                               Network::DnsResolver::ResolutionStatus) override;

  // ConnectivityManager
  std::vector<InterfacePair> enumerateV4Interfaces() override;
  std::vector<InterfacePair> enumerateV6Interfaces() override;
  std::vector<InterfacePair> enumerateInterfaces(unsigned short family, unsigned int select_flags,
                                                 unsigned int reject_flags) override;
  envoy_network_t getPreferredNetwork() override;
  envoy_socket_mode_t getSocketMode() override;
  envoy_netconf_t getConfigurationKey() override;
  Envoy::Network::ProxySettingsConstSharedPtr getProxySettings() override;
  void reportNetworkUsage(envoy_netconf_t configuration_key, bool network_fault) override;
  void setProxySettings(ProxySettingsConstSharedPtr new_proxy_settings) override;
  void setDrainPostDnsRefreshEnabled(bool enabled) override;
  void setInterfaceBindingEnabled(bool enabled) override;
  void refreshDns(envoy_netconf_t configuration_key, bool drain_connections) override;
  void resetConnectivityState() override;
  Socket::OptionsSharedPtr getUpstreamSocketOptions(envoy_network_t network,
                                                    envoy_socket_mode_t socket_mode) override;
  envoy_netconf_t addUpstreamSocketOptions(Socket::OptionsSharedPtr options) override;
  Extensions::Common::DynamicForwardProxy::DnsCacheSharedPtr dnsCache() override;

private:
  struct NetworkState {
    // The configuration key is passed through calls dispatched on the run loop to determine if
    // they're still valid/relevant at time of execution.
    envoy_netconf_t configuration_key_ ABSL_GUARDED_BY(mutex_);
    envoy_network_t network_ ABSL_GUARDED_BY(mutex_);
    uint8_t remaining_faults_ ABSL_GUARDED_BY(mutex_);
    envoy_socket_mode_t socket_mode_ ABSL_GUARDED_BY(mutex_);
    Thread::MutexBasicLockable mutex_;
  };
  Socket::OptionsSharedPtr getAlternateInterfaceSocketOptions(envoy_network_t network);
  InterfacePair getActiveAlternateInterface(envoy_network_t network, unsigned short family);

  bool enable_drain_post_dns_refresh_{false};
  bool enable_interface_binding_{false};
  absl::flat_hash_set<std::string> hosts_to_drain_;
  Extensions::Common::DynamicForwardProxy::DnsCache::AddUpdateCallbacksHandlePtr
      dns_callbacks_handle_{nullptr};
  Upstream::ClusterManager& cluster_manager_;
  DnsCacheManagerSharedPtr dns_cache_manager_;
  ProxySettingsConstSharedPtr proxy_settings_;
  static NetworkState network_state_;
};

using ConnectivityManagerSharedPtr = std::shared_ptr<ConnectivityManager>;

/**
 * Provides access to the singleton ConnectivityManager.
 */
class ConnectivityManagerFactory {
public:
  ConnectivityManagerFactory(Server::Configuration::GenericFactoryContext& context)
      : context_(context) {}

  /**
   * @returns singleton ConnectivityManager instance.
   */
  ConnectivityManagerSharedPtr get();

private:
  Server::GenericFactoryContextImpl context_;
};

/**
 * Provides nullable access to the singleton ConnectivityManager.
 */
class ConnectivityManagerHandle {
public:
  ConnectivityManagerHandle(Singleton::Manager& singleton_manager)
      : singleton_manager_(singleton_manager) {}

  /**
   * @returns singleton ConnectivityManager instance. Can be nullptr if it hasn't been created.
   */
  ConnectivityManagerSharedPtr get();

private:
  Singleton::Manager& singleton_manager_;
};

} // namespace Network
} // namespace Envoy
#pragma once

#include "source/common/network/utility.h"

namespace Envoy {
namespace Network {

struct ProxySettings;
using ProxySettingsConstSharedPtr = std::shared_ptr<const ProxySettings>;

/**
 * Proxy settings coming from platform specific APIs, i.e. ConnectivityManager in
 * the case of Android platform.
 *
 */
struct ProxySettings {
  /**
   * @brief Construct a new Proxy Settings object.
   *
   * @param host The proxy host defined as a hostname or an IP address. Some platforms
   *             (i.e., Android) allow users to specify proxy using either one of these.
   * @param port The proxy port.
   */
  ProxySettings(const std::string& host, const uint16_t port)
      : address_(Envoy::Network::Utility::parseInternetAddressNoThrow(host, port)), hostname_(host),
        port_(port) {}

  /**
   * @brief Parses given host and domain and creates proxy settings. Returns nullptr
   *        for an empty host and a port equal to 0 as they are passed to c++ native layer
   *        as a synonym of the lack of proxy settings configured on a device.
   *
   * @param host The proxy host defined as a hostname or an IP address. Some platforms
   *             (i.e., Android) allow users to specify proxy using either one of these.
   * @param port The proxy port.
   * @return The created proxy settings, nullptr if the passed host is an empty string and
   *         port is equal to 0.
   */
  static const ProxySettingsConstSharedPtr parseHostAndPort(const std::string& host,
                                                            const uint16_t port) {
    if (host == "" && port == 0) {
      return nullptr;
    }
    return std::make_shared<ProxySettings>(host, port);
  }

  /**
   * @brief Returns an address of a proxy. This method returns nullptr for proxy settings
   *        that are initialized with anything other than an IP address.
   *
   * @return Address of a proxy or nullptr if proxy address is incorrect or host is
   *         defined using a hostname and not an IP address.
   */
  const Envoy::Network::Address::InstanceConstSharedPtr& address() const { return address_; }

  /**
   * @brief Returns the hostname of a proxy.
   *
   * @return Hostname of a proxy or the empty string if there is no hostname.
   */
  const std::string& hostname() const { return hostname_; }

  /**
   * @brief Returns the port of the proxy.
   *
   * @return Port of the proxy.
   */
  uint16_t port() const { return port_; }

  /**
   * @brief Returns a human readable representation of the proxy settings represented
   *        by the receiver
   *
   * @return const A human readable representation of the receiver.
   */
  const std::string asString() const {
    if (address_ != nullptr) {
      return address_->asString();
    }
    if (!hostname_.empty()) {
      return absl::StrCat(hostname_, ":", port_);
    }
    return "no_proxy_configured";
  }

  bool operator==(ProxySettings const& rhs) const {
    // Even if the hostnames are IP addresses, they'll be stored in hostname_
    return hostname() == rhs.hostname() && port() == rhs.port();
  }

  bool operator!=(ProxySettings const& rhs) const { return !(*this == rhs); }

private:
  Envoy::Network::Address::InstanceConstSharedPtr address_;
  std::string hostname_;
  uint16_t port_;
};

} // namespace Network
} // namespace Envoy
#pragma once

#include <vector>

#include "absl/strings/string_view.h"
#include "library/common/extensions/cert_validator/platform_bridge/c_types.h"

// NOLINT(namespace-envoy)
envoy_cert_validation_result verify_cert(const std::vector<std::string>& certs,
                                         absl::string_view hostname);
#include "library/common/network/socket_tag_socket_option_impl.h"

#include "envoy/config/core/v3/base.pb.h"

#include "source/common/common/assert.h"
#include "source/common/common/scalar_to_byte_vector.h"

#include "library/common/jni/android_jni_utility.h"

namespace Envoy {
namespace Network {

SocketTagSocketOptionImpl::SocketTagSocketOptionImpl(uid_t uid, uint32_t traffic_stats_tag)
    : optname_(0, 0, "socket_tag"), uid_(uid), traffic_stats_tag_(traffic_stats_tag) {}

bool SocketTagSocketOptionImpl::setOption(
    Socket& socket, envoy::config::core::v3::SocketOption::SocketState state) const {
  if (state != envoy::config::core::v3::SocketOption::STATE_PREBIND) {
    return true;
  }

  // Because socket tagging happens at the socket level, not at the request level,
  // requests with different socket tags must not use the same socket. As a result
  // different socket tag socket options must end up in different socket pools.
  // This happens because different socket tag socket option generate different
  // hash keys.
  // Further, this only works for sockets which have a raw fd and will be a no-op
  // otherwise.
  int fd = socket.ioHandle().fdDoNotUse();
  JNI::tagSocket(fd, uid_, traffic_stats_tag_);
  return true;
}

void SocketTagSocketOptionImpl::hashKey(std::vector<uint8_t>& hash_key) const {
  pushScalarToByteVector(uid_, hash_key);
  pushScalarToByteVector(traffic_stats_tag_, hash_key);
}

absl::optional<Socket::Option::Details> SocketTagSocketOptionImpl::getOptionDetails(
    const Socket&, envoy::config::core::v3::SocketOption::SocketState /*state*/) const {
  if (!isSupported()) {
    return absl::nullopt;
  }

  static std::string name = "socket_tag";
  Socket::Option::Details details;
  details.name_ = optname_;
  std::vector<uint8_t> data;
  pushScalarToByteVector(uid_, data);
  pushScalarToByteVector(traffic_stats_tag_, data);
  details.value_ = std::string(reinterpret_cast<char*>(data.data()), data.size());
  return absl::make_optional(std::move(details));
}

bool SocketTagSocketOptionImpl::isSupported() const { return optname_.hasValue(); }

} // namespace Network
} // namespace Envoy
#include "library/common/network/apple_platform_cert_verifier.h"

#include <CoreFoundation/CFArray.h>
#include <CoreFoundation/CoreFoundation.h>
#include <Security/SecCertificate.h>
#include <Security/SecPolicy.h>
#include <Security/SecTrust.h>

#include "library/common/extensions/cert_validator/platform_bridge/c_types.h"
#include "openssl/ssl.h"

// NOLINT(namespace-envoy)

// Returns a new CFMutableArrayRef containing a series of SecPolicyRefs to be
// added to a SecTrustRef used to validate a certificate for an SSL server,
// or NULL on failure.
CFMutableArrayRef CreateTrustPolicies() {
  CFMutableArrayRef policies = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!policies) {
    return NULL;
  }

  SecPolicyRef ssl_policy = SecPolicyCreateBasicX509();
  CFArrayAppendValue(policies, ssl_policy);
  CFRelease(ssl_policy);

  ssl_policy = SecPolicyCreateSSL(true, NULL);
  CFArrayAppendValue(policies, ssl_policy);
  CFRelease(ssl_policy);

  return policies;
}

// Returns a new CFMutableArrayRef containing the specified certificates
// in the form expected by Security.framework and Keychain Services, or
// NULL on failure.
CFMutableArrayRef CreateSecCertificateArray(const std::vector<std::string>& certs) {
  CFMutableArrayRef cert_array =
      CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);

  if (!cert_array) {
    return NULL;
  }

  for (absl::string_view cert : certs) {
    CFDataRef cert_data = CFDataCreate(
        kCFAllocatorDefault, reinterpret_cast<const uint8_t*>(cert.data()), cert.length());
    if (!cert_data) {
      CFRelease(cert_array);
      return NULL;
    }
    SecCertificateRef sec_cert = SecCertificateCreateWithData(NULL, cert_data);
    if (!sec_cert) {
      CFRelease(cert_array);
      return NULL;
    }
    CFArrayAppendValue(cert_array, sec_cert);
    CFRelease(cert_data);
  }
  return cert_array;
}

// Helper to create a envoy_cert_validation_result.
envoy_cert_validation_result make_result(envoy_status_t status, uint8_t tls_alert,
                                         const char* error_details) {
  envoy_cert_validation_result result;
  result.result = status;
  result.tls_alert = tls_alert;
  result.error_details = error_details;
  return result;
}

envoy_cert_validation_result verify_cert(const std::vector<std::string>& certs,
                                         absl::string_view /*hostname*/) {
  CFArrayRef trust_policies = CreateTrustPolicies();
  if (!trust_policies) {
    return make_result(ENVOY_FAILURE, SSL_AD_CERTIFICATE_UNKNOWN,
                       "validation couldn't be conducted.");
  }

  CFMutableArrayRef cert_array = CreateSecCertificateArray(certs);
  if (!cert_array) {
    return make_result(ENVOY_FAILURE, SSL_AD_CERTIFICATE_UNKNOWN,
                       "validation couldn't be conducted.");
  }

  SecTrustRef trust = NULL;
  OSStatus status = SecTrustCreateWithCertificates(cert_array, trust_policies, &trust);
  if (status) {
    return make_result(ENVOY_FAILURE, SSL_AD_CERTIFICATE_UNKNOWN,
                       "validation couldn't be conducted.");
  }

  CFErrorRef error;
  bool verified = SecTrustEvaluateWithError(trust, &error);

  CFRelease(cert_array);
  CFRelease(trust);

  if (!verified) {
    return make_result(ENVOY_FAILURE, SSL_AD_CERTIFICATE_UNKNOWN,
                       "validation couldn't be conducted.");
  }
  return make_result(ENVOY_SUCCESS, 0, "");
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "connectivity_manager_lib",
    srcs = [
        "connectivity_manager.cc",
    ],
    hdrs = [
        "connectivity_manager.h",
        "proxy_settings.h",
    ],
    repository = "@envoy",
    deps = [
        "//library/common/network:src_addr_socket_option_lib",
        "//library/common/types:c_types_lib",
        "@envoy//envoy/network:socket_interface",
        "@envoy//envoy/singleton:manager_interface",
        "@envoy//source/common/common:assert_lib",
        "@envoy//source/common/common:scalar_to_byte_vector_lib",
        "@envoy//source/common/common:utility_lib",
        "@envoy//source/common/network:addr_family_aware_socket_option_lib",
        "@envoy//source/common/network:socket_option_lib",
        "@envoy//source/extensions/common/dynamic_forward_proxy:dns_cache_manager_impl",
    ],
)

envoy_cc_library(
    name = "src_addr_socket_option_lib",
    srcs = ["src_addr_socket_option_impl.cc"],
    hdrs = ["src_addr_socket_option_impl.h"],
    repository = "@envoy",
    deps = [
        "@envoy//envoy/network:address_interface",
        "@envoy//source/common/network:socket_option_lib",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "socket_tag_socket_option_lib",
    srcs = ["socket_tag_socket_option_impl.cc"],
    hdrs = ["socket_tag_socket_option_impl.h"],
    repository = "@envoy",
    deps = [
        "//library/common/jni:android_jni_utility_lib",
        "@envoy//envoy/network:address_interface",
        "@envoy//source/common/common:scalar_to_byte_vector_lib",
        "@envoy//source/common/network:socket_option_lib",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "synthetic_address_lib",
    hdrs = ["synthetic_address_impl.h"],
    repository = "@envoy",
    deps = [
        "@envoy//envoy/network:address_interface",
        "@envoy//source/common/network:socket_interface_lib",
    ],
)

envoy_cc_library(
    name = "apple_platform_cert_verifier",
    srcs = select({
        "@envoy//bazel:apple": ["apple_platform_cert_verifier.cc"],
        "//conditions:default": [],
    }),
    hdrs = select({
        "@envoy//bazel:apple": ["apple_platform_cert_verifier.h"],
        "//conditions:default": [],
    }),
    linkopts = select({
        "@envoy//bazel:apple": ["-framework Security"],
        "//conditions:default": [],
    }),
    repository = "@envoy",
    deps = select({
        "@envoy//bazel:apple": [
            "//library/common/extensions/cert_validator/platform_bridge:c_types_lib",
            "@envoy//bazel:boringssl",
        ],
        "//conditions:default": [],
    }),
)
#pragma once

#include "envoy/config/core/v3/base.pb.h"
#include "envoy/network/address.h"
#include "envoy/network/listen_socket.h"

namespace Envoy {
namespace Network {

/**
 * This is a "synthetic" socket option implementation, which sets the android socket tag
 * during bind.
 */
class SocketTagSocketOptionImpl : public Network::Socket::Option {
public:
  SocketTagSocketOptionImpl(uid_t uid, uint32_t traffic_stats_tag);

  // Socket::Option
  bool setOption(Network::Socket& socket,
                 envoy::config::core::v3::SocketOption::SocketState state) const override;
  void hashKey(std::vector<uint8_t>& hash_key) const override;
  absl::optional<Details>
  getOptionDetails(const Network::Socket& socket,
                   envoy::config::core::v3::SocketOption::SocketState state) const override;
  bool isSupported() const override;

private:
  const Network::SocketOptionName optname_;

  // Thread stats UID to be applied to the socket.
  // See: https://developer.android.com/reference/android/net/TrafficStats#setThreadStatsUid(int)
  uid_t uid_;
  // Thread stats tag to be applied to the socket.
  // See: https://developer.android.com/reference/android/net/TrafficStats#setThreadStatsTag(int)
  uint32_t traffic_stats_tag_;
};

} // namespace Network
} // namespace Envoy
#pragma once

#include <cerrno>

#include "envoy/network/address.h"

#include "source/common/network/socket_interface.h"

namespace Envoy {
namespace Network {
namespace Address {

// TODO(junr03): https://github.com/envoyproxy/envoy/pull/9362/ introduced API surface to the
// codec's Stream interface that made it necessary for Stream to be aware of its underlying
// connection. This class is created in order to stub out Address for Stream implementations
// that have no backing connection, e.g Envoy Mobile's DirectStream. It might be possible to
// eliminate this dependency.
// TODO(junr03): consider moving this code to Envoy's codebase.
class SyntheticAddressImpl : public Instance {
public:
  SyntheticAddressImpl() {}

  bool operator==(const Instance&) const override {
    // Every synthetic address is different from one another and other address types. In reality,
    // whatever object owns a synthetic address can't rely on address equality for any logic as the
    // address is just a stub.
    return false;
  }

  const std::string& asString() const override { return address_; }

  absl::string_view asStringView() const override { return address_; }

  const std::string& logicalName() const override { return address_; }

  const Ip* ip() const override { return nullptr; }

  const Pipe* pipe() const override { return nullptr; }

  const EnvoyInternalAddress* envoyInternalAddress() const override { return nullptr; }

  const sockaddr* sockAddr() const override { return nullptr; }

  socklen_t sockAddrLen() const override { return 0; }

  Type type() const override {
    // TODO(junr03): consider adding another type of address.
    return Type::Ip;
  }

  absl::string_view addressType() const override { return "default"; }

  const SocketInterface& socketInterface() const override {
    return SocketInterfaceSingleton::get();
  }

private:
  const std::string address_{"synthetic"};
};
} // namespace Address
} // namespace Network
} // namespace Envoy
syntax = "proto3";

package envoymobile.extensions.filters.http.local_error;

message LocalError {
}
#pragma once

#include <string>

#include "source/extensions/filters/http/common/factory_base.h"

#include "library/common/extensions/filters/http/local_error/filter.pb.h"
#include "library/common/extensions/filters/http/local_error/filter.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace LocalError {

/**
 * Config registration for the local_error filter. @see NamedHttpFilterConfigFactory.
 */
class LocalErrorFilterFactory
    : public Common::FactoryBase<envoymobile::extensions::filters::http::local_error::LocalError> {
public:
  LocalErrorFilterFactory() : FactoryBase("local_error") {}

private:
  ::Envoy::Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoymobile::extensions::filters::http::local_error::LocalError& config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

DECLARE_FACTORY(LocalErrorFilterFactory);

} // namespace LocalError
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "library/common/extensions/filters/http/local_error/filter.h"

#include "envoy/server/filter_config.h"

#include "library/common/http/header_utility.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace LocalError {

Http::LocalErrorStatus LocalErrorFilter::onLocalReply(const LocalReplyData& reply) {
  ENVOY_LOG(trace, "LocalErrorFilter::onLocalReply({}, {})", static_cast<uint64_t>(reply.code_),
            reply.details_);
  ASSERT(decoder_callbacks_);
  auto& info = decoder_callbacks_->streamInfo();
  // TODO(goaway): set responseCode in upstream Envoy when responseCodDetails are set.
  // ASSERT(static_cast<uint32_t>(reply.code_) == info.responseCode());
  // TODO(goaway): follow up on the underscore discrepancy between these values.
  // ASSERT(reply.details_ == info.responseCodeDetails().value());
  info.setResponseCode(static_cast<uint32_t>(reply.code_));

  return Http::Utility::statusForOnLocalReply(reply, decoder_callbacks_->streamInfo());
}

} // namespace LocalError
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_extension",
    "envoy_extension_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_extension_package()

envoy_proto_library(
    name = "filter",
    srcs = ["filter.proto"],
)

envoy_cc_extension(
    name = "local_error_filter_lib",
    srcs = ["filter.cc"],
    hdrs = ["filter.h"],
    repository = "@envoy",
    deps = [
        ":filter_cc_proto",
        "//library/common/http:header_utility_lib",
        "//library/common/http:internal_headers_lib",
        "//library/common/types:c_types_lib",
        "@envoy//envoy/http:codes_interface",
        "@envoy//envoy/http:filter_interface",
        "@envoy//source/common/grpc:common_lib",
        "@envoy//source/common/grpc:status_lib",
        "@envoy//source/common/http:codes_lib",
        "@envoy//source/common/http:header_map_lib",
        "@envoy//source/common/http:headers_lib",
        "@envoy//source/common/http:utility_lib",
        "@envoy//source/extensions/filters/http/common:pass_through_filter_lib",
    ],
)

envoy_cc_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    repository = "@envoy",
    deps = [
        ":local_error_filter_lib",
        "@envoy//source/extensions/filters/http/common:factory_base_lib",
    ],
)
#pragma once

#include "envoy/http/filter.h"

#include "source/common/common/logger.h"
#include "source/extensions/filters/http/common/pass_through_filter.h"

#include "library/common/extensions/filters/http/local_error/filter.pb.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace LocalError {

/**
 * Filter to assert expectations on HTTP requests.
 */
class LocalErrorFilter final : public Http::PassThroughFilter,
                               public Logger::Loggable<Logger::Id::filter> {
public:
  // StreamFilterBase
  Http::LocalErrorStatus onLocalReply(const LocalReplyData&) override;
};

} // namespace LocalError
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "library/common/extensions/filters/http/local_error/config.h"

#include "library/common/extensions/filters/http/local_error/filter.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace LocalError {

Http::FilterFactoryCb LocalErrorFilterFactory::createFilterFactoryFromProtoTyped(
    const envoymobile::extensions::filters::http::local_error::LocalError&, const std::string&,
    Server::Configuration::FactoryContext&) {

  return [](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamFilter(std::make_shared<LocalErrorFilter>());
  };
}

/**
 * Static registration for the LocalError filter. @see NamedHttpFilterConfigFactory.
 */
REGISTER_FACTORY(LocalErrorFilterFactory, Server::Configuration::NamedHttpFilterConfigFactory);

} // namespace LocalError
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";

package envoymobile.extensions.filters.http.network_configuration;

message NetworkConfiguration {
  // If set to true, the filter will permit the NetworkConnectivityManager to provide upstream
  // socket option that MAY bind a connection to a specific network interface.
  bool enable_interface_binding = 1;

  // If set to true, the filter will permit the NetworkConnectivityManager to drain connections
  // when a DNS refresh is externally triggered.
  bool enable_drain_post_dns_refresh = 2;
}
#pragma once

#include <string>

#include "source/extensions/filters/http/common/factory_base.h"

#include "library/common/extensions/filters/http/network_configuration/filter.pb.h"
#include "library/common/extensions/filters/http/network_configuration/filter.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace NetworkConfiguration {

/**
 * Config registration for the network_configuration filter. @see NamedHttpFilterConfigFactory.
 */
class NetworkConfigurationFilterFactory
    : public Common::FactoryBase<
          envoymobile::extensions::filters::http::network_configuration::NetworkConfiguration> {
public:
  NetworkConfigurationFilterFactory() : FactoryBase("network_configuration") {}

private:
  ::Envoy::Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoymobile::extensions::filters::http::network_configuration::NetworkConfiguration&
          config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

DECLARE_FACTORY(NetworkConfigurationFilterFactory);

} // namespace NetworkConfiguration
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "library/common/extensions/filters/http/network_configuration/filter.h"

#include "envoy/server/filter_config.h"

#include "source/common/network/filter_state_proxy_info.h"

#include "library/common/http/header_utility.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace NetworkConfiguration {

const Http::LowerCaseString AuthorityHeaderName{":authority"};

void NetworkConfigurationFilter::setDecoderFilterCallbacks(
    Http::StreamDecoderFilterCallbacks& callbacks) {
  ENVOY_LOG(debug, "NetworkConfigurationFilter::setDecoderFilterCallbacks");

  auto new_extra_stream_info = std::make_unique<StreamInfo::ExtraStreamInfo>();
  extra_stream_info_ = new_extra_stream_info.get();

  decoder_callbacks_ = &callbacks;
  decoder_callbacks_->streamInfo().filterState()->setData(
      StreamInfo::ExtraStreamInfo::key(), std::move(new_extra_stream_info),
      StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Request);

  auto options = std::make_shared<Network::Socket::Options>();
  connectivity_manager_->setInterfaceBindingEnabled(enable_interface_binding_);
  connectivity_manager_->setDrainPostDnsRefreshEnabled(enable_drain_post_dns_refresh_);
  extra_stream_info_->configuration_key_ = connectivity_manager_->addUpstreamSocketOptions(options);
  decoder_callbacks_->addUpstreamSocketOptions(options);
}

void NetworkConfigurationFilter::onLoadDnsCacheComplete(
    const Common::DynamicForwardProxy::DnsHostInfoSharedPtr& host_info) {
  if (onAddressResolved(host_info)) {
    continue_decoding_callback_ = decoder_callbacks_->dispatcher().createSchedulableCallback(
        [this]() { decoder_callbacks_->continueDecoding(); });
    continue_decoding_callback_->scheduleCallbackNextIteration();
    return;
  }
}

bool NetworkConfigurationFilter::onAddressResolved(
    const Common::DynamicForwardProxy::DnsHostInfoSharedPtr& host_info) {
  if (host_info->address()) {
    setInfo(decoder_callbacks_->streamInfo().getRequestHeaders()->getHostValue(),
            host_info->address());
    return true;
  }
  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,
                                     "Proxy configured but DNS resolution failed", nullptr,
                                     absl::nullopt, "no_dns_address_for_proxy");
  return false;
}

Http::FilterHeadersStatus
NetworkConfigurationFilter::decodeHeaders(Http::RequestHeaderMap& request_headers, bool) {
  ENVOY_LOG(trace, "NetworkConfigurationFilter::decodeHeaders", request_headers);

  const auto authority = request_headers.getHostValue();
  if (authority.empty()) {
    return Http::FilterHeadersStatus::Continue;
  }

  // If there is no proxy configured, continue.
  const auto proxy_settings = connectivity_manager_->getProxySettings();
  if (proxy_settings == nullptr) {
    return Http::FilterHeadersStatus::Continue;
  }

  ENVOY_LOG(trace, "netconf_filter_processing_proxy_for_request", proxy_settings->asString());
  // If there is a proxy with a raw address, set the information, and continue.
  const auto proxy_address = proxy_settings->address();
  if (proxy_address != nullptr) {
    const auto authorityHeader = request_headers.get(AuthorityHeaderName);

    setInfo(request_headers.getHostValue(), proxy_address);
    return Http::FilterHeadersStatus::Continue;
  }

  // If there's no address or hostname, continue.
  if (proxy_settings->hostname().empty()) {
    return Http::FilterHeadersStatus::Continue;
  }

  // If there's a proxy hostname but no way to do a DNS lookup, fail the request.
  if (!connectivity_manager_->dnsCache()) {
    decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,
                                       "Proxy configured but no DNS cache available", nullptr,
                                       absl::nullopt, "no_dns_cache_for_proxy");
    return Http::FilterHeadersStatus::StopIteration;
  }

  // Attempt to load the proxy's hostname from the DNS cache.
  auto result = connectivity_manager_->dnsCache()->loadDnsCacheEntry(
      proxy_settings->hostname(), proxy_settings->port(), false, *this);

  // If the hostname is not in the cache, pause filter iteration. The DNS cache will call
  // onLoadDnsCacheComplete when DNS resolution succeeds, fails, or times out and processing
  // will resume from there.
  if (result.status_ == Common::DynamicForwardProxy::DnsCache::LoadDnsCacheEntryStatus::Loading) {
    dns_cache_handle_ = std::move(result.handle_);
    return Http::FilterHeadersStatus::StopAllIterationAndWatermark;
  }

  // If the hostname is in cache, set the info and continue.
  if (result.host_info_.has_value()) {
    if (onAddressResolved(*result.host_info_)) {
      return Http::FilterHeadersStatus::Continue;
    } else {
      return Http::FilterHeadersStatus::StopIteration;
    }
  }

  // If DNS lookup straight up fails, fail the request.
  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,
                                     "Proxy configured but DNS resolution failed", nullptr,
                                     absl::nullopt, "no_dns_address_for_proxy");
  return Http::FilterHeadersStatus::StopIteration;
}

void NetworkConfigurationFilter::setInfo(absl::string_view authority,
                                         Network::Address::InstanceConstSharedPtr address) {
  ENVOY_LOG(trace, "netconf_filter_set_proxy_for_request {} {}", authority, address->asString());
  decoder_callbacks_->streamInfo().filterState()->setData(
      Network::Http11ProxyInfoFilterState::key(),
      std::make_unique<Network::Http11ProxyInfoFilterState>(authority, address),
      StreamInfo::FilterState::StateType::ReadOnly, StreamInfo::FilterState::LifeSpan::FilterChain);
}

Http::FilterHeadersStatus NetworkConfigurationFilter::encodeHeaders(Http::ResponseHeaderMap&,
                                                                    bool) {
  ENVOY_LOG(debug, "NetworkConfigurationFilter::encodeHeaders");
  // Report request status to network connectivity_manager, so that socket configuration may be
  // adapted to current network conditions. Receiving headers from upstream always means some level
  // of network transmission was successful, so we unconditionally set network_fault to false.
  connectivity_manager_->reportNetworkUsage(extra_stream_info_->configuration_key_.value(),
                                            false /* network_fault */);

  return Http::FilterHeadersStatus::Continue;
}

Http::LocalErrorStatus NetworkConfigurationFilter::onLocalReply(const LocalReplyData& reply) {
  ENVOY_LOG(debug, "NetworkConfigurationFilter::onLocalReply");

  bool success_status = static_cast<int>(reply.code_) < 400;
  // Envoy uses local replies to report various local errors, including networking failures (which
  // Envoy Mobile later surfaces as errors). As a proxy for the many different types of network
  // errors, this code interprets any local error where a stream received no bytes from the upstream
  // as a network fault. This status is passed to the connectivity_manager below when we report
  // network usage, where it may be factored into future socket configuration.
  bool network_fault = !success_status && (!decoder_callbacks_->streamInfo().upstreamInfo() ||
                                           !decoder_callbacks_->streamInfo()
                                                .upstreamInfo()
                                                ->upstreamTiming()
                                                .first_upstream_rx_byte_received_.has_value());
  // Report request status to network connectivity_manager, so that socket configuration may be
  // adapted to current network conditions.
  connectivity_manager_->reportNetworkUsage(extra_stream_info_->configuration_key_.value(),
                                            network_fault);

  return Http::Utility::statusForOnLocalReply(reply, decoder_callbacks_->streamInfo());
}

void NetworkConfigurationFilter::onDestroy() { dns_cache_handle_.reset(); }

} // namespace NetworkConfiguration
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_extension",
    "envoy_extension_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_extension_package()

envoy_proto_library(
    name = "filter",
    srcs = ["filter.proto"],
)

envoy_cc_extension(
    name = "network_configuration_filter_lib",
    srcs = ["filter.cc"],
    hdrs = ["filter.h"],
    repository = "@envoy",
    deps = [
        ":filter_cc_proto",
        "//library/common/http:header_utility_lib",
        "//library/common/http:internal_headers_lib",
        "//library/common/network:connectivity_manager_lib",
        "//library/common/stream_info:extra_stream_info_lib",
        "//library/common/types:c_types_lib",
        "@envoy//envoy/http:codes_interface",
        "@envoy//envoy/http:filter_interface",
        "@envoy//source/common/grpc:common_lib",
        "@envoy//source/common/grpc:status_lib",
        "@envoy//source/common/http:codes_lib",
        "@envoy//source/common/http:header_map_lib",
        "@envoy//source/common/http:headers_lib",
        "@envoy//source/common/http:utility_lib",
        "@envoy//source/common/network:filter_state_proxy_info_lib",
        "@envoy//source/extensions/filters/http/common:pass_through_filter_lib",
    ],
)

envoy_cc_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    repository = "@envoy",
    deps = [
        ":network_configuration_filter_lib",
        "@envoy//source/extensions/filters/http/common:factory_base_lib",
    ],
)
#pragma once

#include "envoy/http/filter.h"

#include "source/common/common/logger.h"
#include "source/extensions/filters/http/common/pass_through_filter.h"

#include "library/common/extensions/filters/http/network_configuration/filter.pb.h"
#include "library/common/network/connectivity_manager.h"
#include "library/common/stream_info/extra_stream_info.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace NetworkConfiguration {

/**
 * Filter to set upstream socket options based on network conditions.
 */
class NetworkConfigurationFilter final
    : public Http::PassThroughFilter,
      public Logger::Loggable<Logger::Id::filter>,
      public Extensions::Common::DynamicForwardProxy::DnsCache::LoadDnsCacheEntryCallbacks {
public:
  NetworkConfigurationFilter(Network::ConnectivityManagerSharedPtr connectivity_manager,
                             bool enable_drain_post_dns_refresh, bool enable_interface_binding)
      : connectivity_manager_(connectivity_manager),
        extra_stream_info_(nullptr), // always set in setDecoderFilterCallbacks
        enable_drain_post_dns_refresh_(enable_drain_post_dns_refresh),
        enable_interface_binding_(enable_interface_binding) {}

  // Http::StreamDecoderFilter
  void setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) override;
  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& request_headers, bool) override;
  // Http::StreamEncoderFilter
  Http::FilterHeadersStatus encodeHeaders(Http::ResponseHeaderMap&, bool) override;
  // Http::StreamFilterBase
  Http::LocalErrorStatus onLocalReply(const LocalReplyData&) override;

  // LoadDnsCacheEntryCallbacks
  void onLoadDnsCacheComplete(
      const Extensions::Common::DynamicForwardProxy::DnsHostInfoSharedPtr& host_info) override;

  void onDestroy() override;

private:
  void setInfo(absl::string_view authority, Network::Address::InstanceConstSharedPtr address);
  bool
  onAddressResolved(const Extensions::Common::DynamicForwardProxy::DnsHostInfoSharedPtr& host_info);

  // This is only present if there is an active proxy DNS lookup in progress.
  std::unique_ptr<Extensions::Common::DynamicForwardProxy::DnsCache::LoadDnsCacheEntryHandle>
      dns_cache_handle_;
  Network::ConnectivityManagerSharedPtr connectivity_manager_;
  StreamInfo::ExtraStreamInfo* extra_stream_info_;
  bool enable_drain_post_dns_refresh_;
  bool enable_interface_binding_;
  Event::SchedulableCallbackPtr continue_decoding_callback_;
};

} // namespace NetworkConfiguration
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "library/common/extensions/filters/http/network_configuration/config.h"

#include "library/common/extensions/filters/http/network_configuration/filter.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace NetworkConfiguration {

Http::FilterFactoryCb NetworkConfigurationFilterFactory::createFilterFactoryFromProtoTyped(
    const envoymobile::extensions::filters::http::network_configuration::NetworkConfiguration&
        proto_config,
    const std::string&, Server::Configuration::FactoryContext& context) {

  auto connectivity_manager = Network::ConnectivityManagerFactory{context}.get();
  bool enable_drain_post_dns_refresh = proto_config.enable_drain_post_dns_refresh();
  bool enable_interface_binding = proto_config.enable_interface_binding();

  return [connectivity_manager, enable_drain_post_dns_refresh,
          enable_interface_binding](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamFilter(std::make_shared<NetworkConfigurationFilter>(
        connectivity_manager, enable_drain_post_dns_refresh, enable_interface_binding));
  };
}

/**
 * Static registration for the NetworkConfiguration filter. @see NamedHttpFilterConfigFactory.
 */
REGISTER_FACTORY(NetworkConfigurationFilterFactory,
                 Server::Configuration::NamedHttpFilterConfigFactory);

} // namespace NetworkConfiguration
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";

package envoymobile.extensions.filters.http.platform_bridge;

import "validate/validate.proto";

message PlatformBridge {
  string platform_filter_name = 1 [(validate.rules).string.min_len = 1];
}
#pragma once

#include <string>

#include "source/extensions/filters/http/common/factory_base.h"

#include "library/common/extensions/filters/http/platform_bridge/filter.pb.h"
#include "library/common/extensions/filters/http/platform_bridge/filter.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace PlatformBridge {

/**
 * Config registration for the platform bridge filter. @see NamedHttpFilterConfigFactory.
 */
class PlatformBridgeFilterFactory
    : public Common::FactoryBase<
          envoymobile::extensions::filters::http::platform_bridge::PlatformBridge> {
public:
  PlatformBridgeFilterFactory() : FactoryBase("platform_bridge") {}

private:
  ::Envoy::Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoymobile::extensions::filters::http::platform_bridge::PlatformBridge& config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

DECLARE_FACTORY(PlatformBridgeFilterFactory);

} // namespace PlatformBridge
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "library/common/types/c_types.h"

// NOLINT(namespace-envoy)

/**
 * Convenience constant indicating no changes to data.
 */
extern const envoy_data envoy_unaltered_data;

/**
 * Convenience constant indicating no changes to headers.
 */
extern const envoy_headers envoy_unaltered_headers;

/**
 * Return codes for on-headers filter invocations. @see envoy/http/filter.h
 */
typedef int envoy_filter_headers_status_t;
extern const envoy_filter_headers_status_t kEnvoyFilterHeadersStatusContinue;
extern const envoy_filter_headers_status_t kEnvoyFilterHeadersStatusStopIteration;
extern const envoy_filter_headers_status_t kEnvoyFilterHeadersStatusStopAllIterationAndBuffer;
// Note this return status is unique to platform filters and used only to resume iteration after
// it has been previously stopped.
extern const envoy_filter_headers_status_t kEnvoyFilterHeadersStatusResumeIteration;

/**
 * Compound return type for on-headers filter invocations.
 */
typedef struct {
  envoy_filter_headers_status_t status;
  envoy_headers headers;
} envoy_filter_headers_status;

/**
 * Return codes for on-data filter invocations. @see envoy/http/filter.h
 */
typedef int envoy_filter_data_status_t;
extern const envoy_filter_data_status_t kEnvoyFilterDataStatusContinue;
extern const envoy_filter_data_status_t kEnvoyFilterDataStatusStopIterationAndBuffer;
extern const envoy_filter_data_status_t kEnvoyFilterDataStatusStopIterationNoBuffer;
// Note this return status is unique to platform filters and used only to resume iteration after
// it has been previously stopped.
extern const envoy_filter_data_status_t kEnvoyFilterDataStatusResumeIteration;

/**
 * Compound return type for on-data filter invocations.
 */
typedef struct {
  envoy_filter_data_status_t status;
  envoy_data data;
  envoy_headers* pending_headers;
} envoy_filter_data_status;

/**
 * Return codes for on-trailers filter invocations. @see envoy/http/filter.h
 */
typedef int envoy_filter_trailers_status_t;
extern const envoy_filter_trailers_status_t kEnvoyFilterTrailersStatusContinue;
extern const envoy_filter_trailers_status_t kEnvoyFilterTrailersStatusStopIteration;
// Note this return status is unique to platform filters and used only to resume iteration after
// it has been previously stopped.
extern const envoy_filter_trailers_status_t kEnvoyFilterTrailersStatusResumeIteration;

/**
 * Compound return type for on-trailers filter invocations.
 */
typedef struct {
  envoy_filter_trailers_status_t status;
  envoy_headers trailers;
  envoy_headers* pending_headers;
  envoy_data* pending_data;
} envoy_filter_trailers_status;

/**
 * Return code for on-resume filter invocations. This is an invocation unique to platform
 * filters that provides an in-thread opportunity to read and modify pending stream state
 * upon asynchronous resumption of filter iteration.
 */
typedef int envoy_filter_resume_status_t;
extern const envoy_filter_resume_status_t kEnvoyFilterResumeStatusStopIteration;
extern const envoy_filter_resume_status_t kEnvoyFilterResumeStatusResumeIteration;

/**
 * Compound return type for on-resume filter invocations. It is a filter state
 * violation for the entities in the return status to be a different set from those passed as
 * parameters to the filter invocation.
 */
typedef struct {
  envoy_filter_resume_status_t status;
  envoy_headers* pending_headers;
  envoy_data* pending_data;
  envoy_headers* pending_trailers;
} envoy_filter_resume_status;

#ifdef __cplusplus
extern "C" { // function pointers
#endif

/**
 * Function signature for filter factory. Implementations must return a instance_context
 * capable of dispatching envoy_http_filter calls (below) to a platform filter instance.
 */
typedef const void* (*envoy_filter_init_f)(const void* context);

/**
 * Function signature for on-headers filter invocations.
 */
typedef envoy_filter_headers_status (*envoy_filter_on_headers_f)(envoy_headers headers,
                                                                 bool end_stream,
                                                                 envoy_stream_intel stream_intel,
                                                                 const void* context);

/**
 * Function signature for on-data filter invocations.
 */
typedef envoy_filter_data_status (*envoy_filter_on_data_f)(envoy_data data, bool end_stream,
                                                           envoy_stream_intel stream_intel,
                                                           const void* context);

/**
 * Function signature for on-trailers filter invocations.
 */
typedef envoy_filter_trailers_status (*envoy_filter_on_trailers_f)(envoy_headers trailers,
                                                                   envoy_stream_intel stream_intel,
                                                                   const void* context);

/**
 * Function signature for filter invocation after asynchronous resumption. Passes a
 * snapshot of all HTTP state that has not yet been forwarded along the filter chain.
 */
typedef envoy_filter_resume_status (*envoy_filter_on_resume_f)(
    envoy_headers* headers, envoy_data* data, envoy_headers* trailers, bool end_stream,
    envoy_stream_intel stream_intel, const void* context);

/**
 * Function signature for on-cancellation filter invocations.
 */
typedef void (*envoy_filter_on_cancel_f)(envoy_stream_intel stream_intel,
                                         envoy_final_stream_intel final_stream_intel,
                                         const void* context);

/**
 * Function signature for on-error filter invocations.
 */
typedef void (*envoy_filter_on_error_f)(envoy_error error, envoy_stream_intel stream_intel,
                                        envoy_final_stream_intel final_stream_intel,
                                        const void* context);

/**
 * Function signature to release a filter instance once the filter chain is finished with it.
 */
typedef void (*envoy_filter_release_f)(const void* context);

/**
 * Function signature for asynchronous filter callback to resume filter iteration.
 */
typedef void (*envoy_filter_resume_f)(const void* context);

/**
 * Function signature for async filter callback to reset stream idle timeout.
 */
typedef void (*envoy_filter_reset_idle_f)(const void* context);

/**
 * Raw datatype containing asynchronous callbacks for platform HTTP filters.
 */
typedef struct {
  envoy_filter_resume_f resume_iteration;
  envoy_filter_reset_idle_f reset_idle;
  envoy_filter_release_f release_callbacks;
  const void* callback_context;
} envoy_http_filter_callbacks;

typedef void (*envoy_filter_set_callbacks_f)(envoy_http_filter_callbacks callbacks,
                                             const void* context);

#ifdef __cplusplus
} // function pointers
#endif

/**
 * Raw datatype containing dispatch functions for a platform HTTP filter. Leveraged by the
 * PlatformBridgeFilter.
 */
typedef struct {
  envoy_filter_init_f init_filter;
  envoy_filter_on_headers_f on_request_headers;
  envoy_filter_on_data_f on_request_data;
  envoy_filter_on_trailers_f on_request_trailers;
  envoy_filter_on_headers_f on_response_headers;
  envoy_filter_on_data_f on_response_data;
  envoy_filter_on_trailers_f on_response_trailers;
  envoy_filter_set_callbacks_f set_request_callbacks;
  envoy_filter_on_resume_f on_resume_request;
  envoy_filter_set_callbacks_f set_response_callbacks;
  envoy_filter_on_resume_f on_resume_response;
  envoy_filter_on_cancel_f on_cancel;
  envoy_filter_on_error_f on_error;
  envoy_filter_release_f release_filter;
  const void* static_context;
  const void* instance_context;
} envoy_http_filter;
#include "library/common/extensions/filters/http/platform_bridge/filter.h"

#include "envoy/server/filter_config.h"

#include "source/common/buffer/buffer_impl.h"
#include "source/common/common/assert.h"
#include "source/common/common/dump_state_utils.h"
#include "source/common/common/scope_tracker.h"
#include "source/common/common/utility.h"

#include "library/common/api/external.h"
#include "library/common/bridge/utility.h"
#include "library/common/buffer/bridge_fragment.h"
#include "library/common/data/utility.h"
#include "library/common/extensions/filters/http/platform_bridge/c_type_definitions.h"
#include "library/common/http/header_utility.h"
#include "library/common/http/headers.h"
#include "library/common/stream_info/extra_stream_info.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace PlatformBridge {

namespace {

constexpr auto SlowCallbackWarningThreshold = std::chrono::seconds(1);

// TODO: https://github.com/envoyproxy/envoy-mobile/issues/1287
void replaceHeaders(Http::HeaderMap& headers, envoy_headers c_headers) {
  headers.clear();
  for (envoy_map_size_t i = 0; i < c_headers.length; i++) {
    headers.addCopy(Http::LowerCaseString(Data::Utility::copyToString(c_headers.entries[i].key)),
                    Data::Utility::copyToString(c_headers.entries[i].value));
  }
  // The C envoy_headers struct can be released now because the headers have been copied.
  release_envoy_headers(c_headers);
}

} // namespace

static void envoy_filter_release_callbacks(const void* context) {
  PlatformBridgeFilterWeakPtr* weak_filter =
      static_cast<PlatformBridgeFilterWeakPtr*>(const_cast<void*>(context));
  delete weak_filter;
}

static void envoy_filter_callback_resume_decoding(const void* context) {
  PlatformBridgeFilterWeakPtr* weak_filter =
      static_cast<PlatformBridgeFilterWeakPtr*>(const_cast<void*>(context));
  if (auto filter = weak_filter->lock()) {
    filter->resumeDecoding();
  }
}

static void envoy_filter_callback_resume_encoding(const void* context) {
  PlatformBridgeFilterWeakPtr* weak_filter =
      static_cast<PlatformBridgeFilterWeakPtr*>(const_cast<void*>(context));
  if (auto filter = weak_filter->lock()) {
    filter->resumeEncoding();
  }
}

static void envoy_filter_reset_idle(const void* context) {
  PlatformBridgeFilterWeakPtr* weak_filter =
      static_cast<PlatformBridgeFilterWeakPtr*>(const_cast<void*>(context));
  if (auto filter = weak_filter->lock()) {
    filter->resetIdleTimer();
  }
}

PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(
    Server::Configuration::FactoryContext& context,
    const envoymobile::extensions::filters::http::platform_bridge::PlatformBridge& proto_config)
    : root_scope_(context.scope()), stats_(generateStats("", root_scope_)),
      filter_name_(proto_config.platform_filter_name()),
      platform_filter_(static_cast<envoy_http_filter*>(
          Api::External::retrieveApi(proto_config.platform_filter_name()))) {}

PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config,
                                           Event::Dispatcher& dispatcher)
    : config_(config), dispatcher_(dispatcher), filter_name_(config->filter_name()),
      platform_filter_(*config->platform_filter()) {
  // The initialization above sets platform_filter_ to a copy of the struct stored on the config.
  // In the typical case, this will represent a filter implementation that needs to be intantiated.
  // static_context will contain the necessary platform-specific mechanism to produce a filter
  // instance. instance_context will initially be null, but after initialization, set to the
  // context needed for actual filter invocations.
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::PlatformBridgeFilter", filter_name_);

  if (platform_filter_.init_filter) {
    // Set the instance_context to the result of the initialization call. Cleanup will ultimately
    // occur within the onDestroy() invocation below.
    ENVOY_LOG(trace, "PlatformBridgeFilter({})->init_filter", filter_name_);

    auto callback_time_ms = std::make_unique<Stats::HistogramCompletableTimespanImpl>(
        config_->stats().init_callback_latency_, timeSource());

    platform_filter_.instance_context = platform_filter_.init_filter(&platform_filter_);

    callback_time_ms->complete();
    auto elapsed = callback_time_ms->elapsed();
    if (elapsed > SlowCallbackWarningThreshold) {
      ENVOY_LOG_EVENT(warn, "slow_init_cb",
                      filter_name_ + "|" + std::to_string(elapsed.count()) + "ms");
    }

    ASSERT(platform_filter_.instance_context,
           fmt::format("PlatformBridgeFilter({}): init_filter unsuccessful", filter_name_));
  } else {
    // If init_filter is missing, zero out the rest of the struct for safety.
    ENVOY_LOG(debug, "PlatformBridgeFilter({}): missing initializer", filter_name_);
    platform_filter_ = {};
  }

  // Set directional filters now that the platform_filter_ has been updated (initialized or zero'ed
  // out).
  request_filter_base_ = std::make_unique<RequestFilterBase>(*this);
  response_filter_base_ = std::make_unique<ResponseFilterBase>(*this);
}

void PlatformBridgeFilter::setDecoderFilterCallbacks(
    Http::StreamDecoderFilterCallbacks& callbacks) {
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::setDecoderCallbacks", filter_name_);
  decoder_callbacks_ = &callbacks;

  // TODO(goaway): currently both platform APIs unconditionally set this field, meaning that the
  // heap allocation below occurs when it could be avoided.
  if (platform_filter_.set_request_callbacks) {
    platform_request_callbacks_.resume_iteration = envoy_filter_callback_resume_decoding;
    platform_request_callbacks_.reset_idle = envoy_filter_reset_idle;
    platform_request_callbacks_.release_callbacks = envoy_filter_release_callbacks;
    // We use a weak_ptr wrapper for the filter to ensure presence before dispatching callbacks.
    // The weak_ptr is heap-allocated, because it must be managed (and eventually released) by
    // platform code.
    platform_request_callbacks_.callback_context =
        new PlatformBridgeFilterWeakPtr{shared_from_this()};
    ENVOY_LOG(trace, "PlatformBridgeFilter({})->set_request_callbacks", filter_name_);
    platform_filter_.set_request_callbacks(platform_request_callbacks_,
                                           platform_filter_.instance_context);
  }
}

void PlatformBridgeFilter::setEncoderFilterCallbacks(
    Http::StreamEncoderFilterCallbacks& callbacks) {
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::setEncoderCallbacks", filter_name_);
  encoder_callbacks_ = &callbacks;

  // TODO(goaway): currently both platform APIs unconditionally set this field, meaning that the
  // heap allocation below occurs when it could be avoided.
  if (platform_filter_.set_response_callbacks) {
    platform_response_callbacks_.resume_iteration = envoy_filter_callback_resume_encoding;
    platform_response_callbacks_.reset_idle = envoy_filter_reset_idle;
    platform_response_callbacks_.release_callbacks = envoy_filter_release_callbacks;
    // We use a weak_ptr wrapper for the filter to ensure presence before dispatching callbacks.
    // The weak_ptr is heap-allocated, because it must be managed (and eventually released) by
    // platform code.
    platform_response_callbacks_.callback_context =
        new PlatformBridgeFilterWeakPtr{shared_from_this()};
    ENVOY_LOG(trace, "PlatformBridgeFilter({})->set_response_callbacks", filter_name_);
    platform_filter_.set_response_callbacks(platform_response_callbacks_,
                                            platform_filter_.instance_context);
  }
}

void PlatformBridgeFilter::onDestroy() {
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::onDestroy", filter_name_);
  alive_ = false;

  if (!response_filter_base_->state_.stream_complete_ && platform_filter_.on_cancel) {
    // If the filter chain is destroyed before a response is received, treat as cancellation.
    ENVOY_LOG(trace, "PlatformBridgeFilter({})->on_cancel", filter_name_);

    auto callback_time_ms = std::make_unique<Stats::HistogramCompletableTimespanImpl>(
        config_->stats().on_cancel_callback_latency_, timeSource());

    platform_filter_.on_cancel(streamIntel(), finalStreamIntel(),
                               platform_filter_.instance_context);

    callback_time_ms->complete();
    auto elapsed = callback_time_ms->elapsed();
    if (elapsed > SlowCallbackWarningThreshold) {
      ENVOY_LOG_EVENT(warn, "slow_on_cancel_cb",
                      filter_name_ + "|" + std::to_string(elapsed.count()) + "ms");
    }
  }

  // Allow nullptr as no-op only if nothing was initialized.
  if (platform_filter_.release_filter == nullptr) {
    ASSERT(!platform_filter_.instance_context,
           fmt::format("PlatformBridgeFilter({}): release_filter required", filter_name_));
    return;
  }

  ENVOY_LOG(trace, "PlatformBridgeFilter({})->release_filter", filter_name_);
  platform_filter_.release_filter(platform_filter_.instance_context);
  platform_filter_.instance_context = nullptr;
}

Http::LocalErrorStatus PlatformBridgeFilter::onLocalReply(const LocalReplyData& reply) {
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::onLocalReply", filter_name_);
  response_filter_base_->state_.stream_complete_ = true;
  auto& info = decoder_callbacks_->streamInfo();
  // TODO(goaway): set responseCode in upstream Envoy when responseCodDetails are set.
  // ASSERT(static_cast<uint32_t>(reply.code_) == info.responseCode());
  // TODO(goaway): follow up on the underscore discrepancy between these values.
  // ASSERT(reply.details_ == info.responseCodeDetails());

  if (platform_filter_.on_error) {
    envoy_error_code_t error_code = Bridge::Utility::errorCodeFromLocalStatus(reply.code_);
    envoy_data error_message = Data::Utility::copyToBridgeData(reply.details_);
    int32_t attempts = static_cast<int32_t>(info.attemptCount().value_or(0));
    platform_filter_.on_error({error_code, error_message, attempts}, streamIntel(),
                              finalStreamIntel(), platform_filter_.instance_context);
  }

  return Http::Utility::statusForOnLocalReply(reply, decoder_callbacks_->streamInfo());
}

envoy_final_stream_intel PlatformBridgeFilter::finalStreamIntel() {
  RELEASE_ASSERT(decoder_callbacks_, "StreamInfo accessed before filter callbacks are set");
  // FIXME: Stream handle cannot currently be set from the filter context.
  envoy_final_stream_intel final_stream_intel{-1, -1, -1, -1, -1, -1, -1, -1,
                                              -1, -1, -1, 0,  0,  0,  0,  -1};
  setFinalStreamIntel(decoder_callbacks_->streamInfo(), dispatcher_.timeSource(),
                      final_stream_intel);
  return final_stream_intel;
}

envoy_stream_intel PlatformBridgeFilter::streamIntel() {
  RELEASE_ASSERT(decoder_callbacks_, "StreamInfo accessed before filter callbacks are set");
  auto& info = decoder_callbacks_->streamInfo();
  // FIXME: Stream handle cannot currently be set from the filter context.
  envoy_stream_intel stream_intel{-1, -1, 0, 0};
  if (info.upstreamInfo()) {
    stream_intel.connection_id = info.upstreamInfo()->upstreamConnectionId().value_or(-1);
  }
  stream_intel.attempt_count = info.attemptCount().value_or(0);
  return stream_intel;
}

void PlatformBridgeFilter::dumpState(std::ostream& os, int indent_level) const {
  std::stringstream ss;
  const char* spaces = spacesForLevel(indent_level);

  ss << spaces << "PlatformBridgeFilter" << DUMP_MEMBER(filter_name_)
     << DUMP_MEMBER(error_response_) << std::endl;

  const char* inner_spaces = spacesForLevel(indent_level + 1);
  if (request_filter_base_) {
    ss << inner_spaces << "Request Filter";
    request_filter_base_->dumpState(ss, 0);
  }
  if (response_filter_base_) {
    ss << inner_spaces << "Response Filter";
    response_filter_base_->dumpState(ss, 0);
  }

  // TODO(junr03): only output to ostream arg
  // https://github.com/envoyproxy/envoy-mobile/issues/1497.
  ENVOY_LOG(error, "\n{}", ss.str());
  os << ss.str();
}

Http::FilterHeadersStatus PlatformBridgeFilter::FilterBase::onHeaders(Http::HeaderMap& headers,
                                                                      bool end_stream) {
  ScopeTrackerScopeState scope(&parent_, parent_.scopeTracker());
  state_.stream_complete_ = end_stream;

  // Allow nullptr to act as no-op.
  if (on_headers_ == nullptr) {
    state_.headers_forwarded_ = true;
    return Http::FilterHeadersStatus::Continue;
  }

  envoy_headers in_headers = Http::Utility::toBridgeHeaders(headers);
  ENVOY_LOG(trace, "PlatformBridgeFilter({})->on_{}_headers", parent_.filter_name_, direction_);

  auto callback_time_ms = std::make_unique<Stats::HistogramCompletableTimespanImpl>(
      on_headers_callback_latency_, parent_.timeSource());

  envoy_filter_headers_status result =
      on_headers_(in_headers, end_stream, streamIntel(), parent_.platform_filter_.instance_context);

  callback_time_ms->complete();
  auto elapsed = callback_time_ms->elapsed();
  if (elapsed > SlowCallbackWarningThreshold) {
    ENVOY_LOG_EVENT(warn, "slow_on_" + direction_ + "_headers_cb",
                    parent_.filter_name_ + "|" + std::to_string(elapsed.count()) + "ms");
  }

  state_.on_headers_called_ = true;

  switch (result.status) {
  case kEnvoyFilterHeadersStatusContinue:
    replaceHeaders(headers, result.headers);
    state_.headers_forwarded_ = true;
    return Http::FilterHeadersStatus::Continue;

  case kEnvoyFilterHeadersStatusStopIteration:
    pending_headers_ = &headers;
    state_.iteration_state_ = IterationState::Stopped;
    ASSERT(result.headers.length == 0 && result.headers.entries == NULL);
    return Http::FilterHeadersStatus::StopIteration;

  default:
    PANIC("invalid filter state: unsupported status for platform filters");
  }

  PANIC("not reached");
}

Http::FilterDataStatus PlatformBridgeFilter::FilterBase::onData(Buffer::Instance& data,
                                                                bool end_stream) {
  ScopeTrackerScopeState scope(&parent_, parent_.scopeTracker());
  state_.stream_complete_ = end_stream;

  // Allow nullptr to act as no-op.
  if (on_data_ == nullptr) {
    state_.data_forwarded_ = true;
    return Http::FilterDataStatus::Continue;
  }

  auto internal_buffer = buffer();
  envoy_data in_data;

  // Decide whether to preemptively buffer data to present aggregate to platform.
  bool prebuffer_data = state_.iteration_state_ == IterationState::Stopped && internal_buffer &&
                        &data != internal_buffer && internal_buffer->length() > 0;

  if (prebuffer_data) {
    internal_buffer->move(data);
    in_data = Data::Utility::copyToBridgeData(*internal_buffer);
  } else {
    in_data = Data::Utility::copyToBridgeData(data);
  }

  ENVOY_LOG(trace, "PlatformBridgeFilter({})->on_{}_data", parent_.filter_name_, direction_);

  auto callback_time_ms = std::make_unique<Stats::HistogramCompletableTimespanImpl>(
      on_data_callback_latency_, parent_.timeSource());

  envoy_filter_data_status result =
      on_data_(in_data, end_stream, streamIntel(), parent_.platform_filter_.instance_context);

  callback_time_ms->complete();
  auto elapsed = callback_time_ms->elapsed();
  if (elapsed > SlowCallbackWarningThreshold) {
    ENVOY_LOG_EVENT(warn, "slow_on_" + direction_ + "_data_cb",
                    parent_.filter_name_ + "|" + std::to_string(elapsed.count()) + "ms");
  }

  state_.on_data_called_ = true;

  switch (result.status) {
  case kEnvoyFilterDataStatusContinue:
    RELEASE_ASSERT(state_.iteration_state_ != IterationState::Stopped,
                   "invalid filter state: filter iteration must be resumed with ResumeIteration");
    data.drain(data.length());
    data.addBufferFragment(*Buffer::BridgeFragment::createBridgeFragment(result.data));
    state_.data_forwarded_ = true;
    return Http::FilterDataStatus::Continue;

  case kEnvoyFilterDataStatusStopIterationAndBuffer:
    if (prebuffer_data) {
      // Data will already have been added to the internal buffer (above).
      return Http::FilterDataStatus::StopIterationNoBuffer;
    }
    // Data will be buffered on return.
    state_.iteration_state_ = IterationState::Stopped;
    return Http::FilterDataStatus::StopIterationAndBuffer;

  case kEnvoyFilterDataStatusStopIterationNoBuffer:
    // In this context all previously buffered data can/should be dropped. If no data has been
    // buffered, this is a no-op. If data was previously buffered, the most likely case is
    // that a filter has decided to handle generating a response itself and no longer needs it.
    // We opt for making this assumption since it's otherwise ambiguous how we should handle
    // buffering when switching between the two stopped states, and since data can be arbitrarily
    // interleaved, it's unclear that there's any legitimate case to support any more complex
    // behavior.
    if (internal_buffer) {
      internal_buffer->drain(internal_buffer->length());
    }
    state_.iteration_state_ = IterationState::Stopped;
    return Http::FilterDataStatus::StopIterationNoBuffer;

  // Resume previously-stopped iteration, possibly forwarding headers if iteration was stopped
  // during an on*Headers invocation.
  case kEnvoyFilterDataStatusResumeIteration:
    RELEASE_ASSERT(state_.iteration_state_ == IterationState::Stopped,
                   "invalid filter state: ResumeIteration may only be used when filter iteration "
                   "is stopped");
    // Update pending henders before resuming iteration, if needed.
    if (result.pending_headers) {
      replaceHeaders(*pending_headers_, *result.pending_headers);
      pending_headers_ = nullptr;
      free(result.pending_headers);
    }
    // We've already moved data into the internal buffer and presented it to the platform. Replace
    // the internal buffer with any modifications returned by the platform filter prior to
    // resumption.
    if (internal_buffer) {
      internal_buffer->drain(internal_buffer->length());
      internal_buffer->addBufferFragment(
          *Buffer::BridgeFragment::createBridgeFragment(result.data));
    } else {
      data.drain(data.length());
      data.addBufferFragment(*Buffer::BridgeFragment::createBridgeFragment(result.data));
    }
    state_.iteration_state_ = IterationState::Ongoing;
    state_.data_forwarded_ = true;
    return Http::FilterDataStatus::Continue;

  default:
    PANIC("invalid filter state: unsupported status for platform filters");
  }

  PANIC("not reached");
}

Http::FilterTrailersStatus PlatformBridgeFilter::FilterBase::onTrailers(Http::HeaderMap& trailers) {
  ScopeTrackerScopeState scope(&parent_, parent_.scopeTracker());
  state_.stream_complete_ = true;

  // Allow nullptr to act as no-op.
  if (on_trailers_ == nullptr) {
    state_.trailers_forwarded_ = true;
    return Http::FilterTrailersStatus::Continue;
  }

  auto internal_buffer = buffer();
  envoy_headers in_trailers = Http::Utility::toBridgeHeaders(trailers);
  ENVOY_LOG(trace, "PlatformBridgeFilter({})->on_{}_trailers", parent_.filter_name_, direction_);

  auto callback_time_ms = std::make_unique<Stats::HistogramCompletableTimespanImpl>(
      on_trailers_callback_latency_, parent_.timeSource());

  envoy_filter_trailers_status result =
      on_trailers_(in_trailers, streamIntel(), parent_.platform_filter_.instance_context);

  callback_time_ms->complete();
  auto elapsed = callback_time_ms->elapsed();
  if (elapsed > SlowCallbackWarningThreshold) {
    ENVOY_LOG_EVENT(warn, "slow_on_" + direction_ + "_trailers_cb",
                    parent_.filter_name_ + "|" + std::to_string(elapsed.count()) + "ms");
  }

  state_.on_trailers_called_ = true;

  switch (result.status) {
  case kEnvoyFilterTrailersStatusContinue:
    RELEASE_ASSERT(state_.iteration_state_ != IterationState::Stopped,
                   "invalid filter state: ResumeIteration may only be used when filter iteration "
                   "is stopped");
    replaceHeaders(trailers, result.trailers);
    state_.trailers_forwarded_ = true;
    return Http::FilterTrailersStatus::Continue;

  case kEnvoyFilterTrailersStatusStopIteration:
    pending_trailers_ = &trailers;
    state_.iteration_state_ = IterationState::Stopped;
    ASSERT(result.trailers.length == 0 && result.trailers.entries == NULL);
    return Http::FilterTrailersStatus::StopIteration;

  // Resume previously-stopped iteration, possibly forwarding headers and data if iteration was
  // stopped during an on*Headers or on*Data invocation.
  case kEnvoyFilterTrailersStatusResumeIteration:
    RELEASE_ASSERT(state_.iteration_state_ == IterationState::Stopped,
                   "invalid filter state: ResumeIteration may only be used when filter iteration "
                   "is stopped");
    // Update pending henders before resuming iteration, if needed.
    if (result.pending_headers) {
      replaceHeaders(*pending_headers_, *result.pending_headers);
      pending_headers_ = nullptr;
      free(result.pending_headers);
    }
    // We've already moved data into the internal buffer and presented it to the platform. Replace
    // the internal buffer with any modifications returned by the platform filter prior to
    // resumption.
    if (result.pending_data) {
      internal_buffer->drain(internal_buffer->length());
      internal_buffer->addBufferFragment(
          *Buffer::BridgeFragment::createBridgeFragment(*result.pending_data));
      free(result.pending_data);
    }
    replaceHeaders(trailers, result.trailers);
    state_.iteration_state_ = IterationState::Ongoing;
    state_.trailers_forwarded_ = true;
    return Http::FilterTrailersStatus::Continue;

  default:
    PANIC("invalid filter state: unsupported status for platform filters");
  }

  PANIC("not reached");
}

Http::FilterHeadersStatus PlatformBridgeFilter::decodeHeaders(Http::RequestHeaderMap& headers,
                                                              bool end_stream) {
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::decodeHeaders(end_stream:{})", filter_name_,
            end_stream);

  // Delegate to base implementation for request and response path.
  return request_filter_base_->onHeaders(headers, end_stream);
}

Http::FilterHeadersStatus PlatformBridgeFilter::encodeHeaders(Http::ResponseHeaderMap& headers,
                                                              bool end_stream) {
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::encodeHeaders(end_stream:{})", filter_name_,
            end_stream);

  // Presence of internal error header indicates an error that should be surfaced as an
  // error callback (rather than an HTTP response).
  const auto error_code_header = headers.get(Http::InternalHeaders::get().ErrorCode);
  if (error_code_header.empty()) {
    // No error, so delegate to base implementation for request and response path.
    return response_filter_base_->onHeaders(headers, end_stream);
  }

  // Update stream state, since we won't be delegating to FilterBase.
  response_filter_base_->state_.stream_complete_ = end_stream;
  error_response_ = true;

  envoy_error_code_t error_code;
  bool parsed_code = absl::SimpleAtoi(error_code_header[0]->value().getStringView(), &error_code);
  RELEASE_ASSERT(parsed_code, "parse error reading error code");

  envoy_data error_message = envoy_nodata;
  const auto error_message_header = headers.get(Http::InternalHeaders::get().ErrorMessage);
  if (!error_message_header.empty()) {
    error_message =
        Data::Utility::copyToBridgeData(error_message_header[0]->value().getStringView());
  }

  int32_t attempt_count = 1;
  if (headers.EnvoyAttemptCount()) {
    bool parsed_attempts =
        absl::SimpleAtoi(headers.EnvoyAttemptCount()->value().getStringView(), &attempt_count);
    RELEASE_ASSERT(parsed_attempts, "parse error reading attempt count");
  }

  if (platform_filter_.on_error) {
    platform_filter_.on_error({error_code, error_message, attempt_count}, streamIntel(),
                              finalStreamIntel(), platform_filter_.instance_context);
  } else {
    release_envoy_data(error_message);
  }

  response_filter_base_->state_.headers_forwarded_ = true;
  return Http::FilterHeadersStatus::Continue;
}

Http::FilterDataStatus PlatformBridgeFilter::decodeData(Buffer::Instance& data, bool end_stream) {
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::decodeData(length:{}, end_stream:{})", filter_name_,
            data.length(), end_stream);

  // Delegate to base implementation for request and response path.
  return request_filter_base_->onData(data, end_stream);
}

Http::FilterDataStatus PlatformBridgeFilter::encodeData(Buffer::Instance& data, bool end_stream) {
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::encodeData(length:{}, end_stream:{})", filter_name_,
            data.length(), end_stream);

  // Pass through if already mapped to error response.
  if (error_response_) {
    response_filter_base_->state_.data_forwarded_ = true;
    return Http::FilterDataStatus::Continue;
  }

  // Delegate to base implementation for request and response path.
  return response_filter_base_->onData(data, end_stream);
}

Http::FilterTrailersStatus PlatformBridgeFilter::decodeTrailers(Http::RequestTrailerMap& trailers) {
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::decodeTrailers", filter_name_);

  // Delegate to base implementation for request and response path.
  return request_filter_base_->onTrailers(trailers);
}

Http::FilterTrailersStatus
PlatformBridgeFilter::encodeTrailers(Http::ResponseTrailerMap& trailers) {
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::encodeTrailers", filter_name_);

  // Pass through if already mapped to error response.
  if (error_response_) {
    response_filter_base_->state_.trailers_forwarded_ = true;
    return Http::FilterTrailersStatus::Continue;
  }

  // Delegate to base implementation for request and response path.
  return response_filter_base_->onTrailers(trailers);
}

void PlatformBridgeFilter::resumeDecoding() {
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::resumeDecoding", filter_name_);

  auto weak_self = weak_from_this();
  // TODO(goaway): There's a potential shutdown race here, due to the fact that the shared
  // reference that now holds the filter does not retain the dispatcher. In the future we should
  // make this safer by, e.g.:
  // 1) adding support to Envoy for (optionally) retaining the dispatcher, or
  // 2) retaining the engine to transitively retain the dispatcher via Envoy's ownership graph, or
  // 3) dispatching via a safe intermediary
  // Relevant: https://github.com/envoyproxy/envoy-mobile/issues/332
  dispatcher_.post([weak_self]() -> void {
    if (auto self = weak_self.lock()) {
      // Delegate to base implementation for request and response path.
      self->request_filter_base_->onResume();
    }
  });
}

void PlatformBridgeFilter::resumeEncoding() {
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::resumeEncoding", filter_name_);

  auto weak_self = weak_from_this();
  dispatcher_.post([weak_self]() -> void {
    if (auto self = weak_self.lock()) {
      // Delegate to base implementation for request and response path.
      self->response_filter_base_->onResume();
    }
  });
}

void PlatformBridgeFilter::resetIdleTimer() {
  ENVOY_LOG(trace, "PlatformBridgeFilter({})::resetIdleTimer", filter_name_);

  auto weak_self = weak_from_this();
  dispatcher_.post([weak_self]() -> void {
    if (auto self = weak_self.lock()) {
      // Stream idle timeout is nondirectional.
      self->decoder_callbacks_->resetIdleTimer();
    }
  });
}

void PlatformBridgeFilter::FilterBase::onResume() {
  ScopeTrackerScopeState scope(&parent_, parent_.scopeTracker());
  ENVOY_LOG(debug, "PlatformBridgeFilter({})::onResume", parent_.filter_name_);
  if (!parent_.isAlive()) {
    return;
  }

  if (state_.iteration_state_ == IterationState::Ongoing) {
    return;
  }

  auto internal_buffer = buffer();
  envoy_headers bridged_headers;
  envoy_data bridged_data;
  envoy_headers bridged_trailers;
  envoy_headers* pending_headers = nullptr;
  envoy_data* pending_data = nullptr;
  envoy_headers* pending_trailers = nullptr;

  if (pending_headers_) {
    bridged_headers = Http::Utility::toBridgeHeaders(*pending_headers_);
    pending_headers = &bridged_headers;
  }
  if (internal_buffer) {
    bridged_data = Data::Utility::copyToBridgeData(*internal_buffer);
    pending_data = &bridged_data;
  }
  if (pending_trailers_) {
    bridged_trailers = Http::Utility::toBridgeHeaders(*pending_trailers_);
    pending_trailers = &bridged_trailers;
  }

  ENVOY_LOG(trace, "PlatformBridgeFilter({})->on_resume_{}", parent_.filter_name_, direction_);

  auto callback_time_ms = std::make_unique<Stats::HistogramCompletableTimespanImpl>(
      on_resume_callback_latency_, parent_.timeSource());

  envoy_filter_resume_status result =
      on_resume_(pending_headers, pending_data, pending_trailers, state_.stream_complete_,
                 streamIntel(), parent_.platform_filter_.instance_context);

  callback_time_ms->complete();
  auto elapsed = callback_time_ms->elapsed();
  if (elapsed > SlowCallbackWarningThreshold) {
    ENVOY_LOG_EVENT(warn, "slow_on_" + direction_ + "_resume_cb",
                    parent_.filter_name_ + "|" + std::to_string(elapsed.count()) + "ms");
  }

  state_.on_resume_called_ = true;

  if (result.status == kEnvoyFilterResumeStatusStopIteration) {
    RELEASE_ASSERT(!result.pending_headers, "invalid filter state: headers must not be present on "
                                            "stopping filter iteration on async resume");
    RELEASE_ASSERT(!result.pending_data, "invalid filter state: data must not be present on "
                                         "stopping filter iteration on async resume");
    RELEASE_ASSERT(!result.pending_trailers, "invalid filter state: trailers must not be present on"
                                             " stopping filter iteration on async resume");
    return;
  }

  if (pending_headers_) {
    RELEASE_ASSERT(result.pending_headers, "invalid filter state: headers are pending and must be "
                                           "returned to resume filter iteration");
    replaceHeaders(*pending_headers_, *result.pending_headers);
    pending_headers_ = nullptr;
    ENVOY_LOG(debug, "PlatformBridgeFilter({})->on_resume_ process headers free#1",
              parent_.filter_name_);
    if (pending_headers != result.pending_headers) {
      free(result.pending_headers);
    }
  }

  if (internal_buffer) {
    RELEASE_ASSERT(
        result.pending_data,
        "invalid filter state: data is pending and must be returned to resume filter iteration");
    internal_buffer->drain(internal_buffer->length());
    internal_buffer->addBufferFragment(
        *Buffer::BridgeFragment::createBridgeFragment(*result.pending_data));
    ENVOY_LOG(debug, "PlatformBridgeFilter({})->on_resume_ process data free#1",
              parent_.filter_name_);
    if (pending_data != result.pending_data) {
      free(result.pending_data);
    }
  } else if (result.pending_data) {
    addData(*result.pending_data);
    ENVOY_LOG(debug, "PlatformBridgeFilter({})->on_resume_ process data free#2",
              parent_.filter_name_);
    if (pending_data != result.pending_data) {
      free(result.pending_data);
    }
  }

  if (pending_trailers_) {
    RELEASE_ASSERT(result.pending_trailers, "invalid filter state: trailers are pending and must "
                                            "be returned to resume filter iteration");
    replaceHeaders(*pending_trailers_, *result.pending_trailers);
    pending_trailers_ = nullptr;
    ENVOY_LOG(debug, "PlatformBridgeFilter({})->on_resume_ process trailers free#1",
              parent_.filter_name_);
    if (pending_trailers != result.pending_trailers) {
      free(result.pending_trailers);
    }
  } else if (result.pending_trailers) {
    addTrailers(*result.pending_trailers);
    ENVOY_LOG(debug, "PlatformBridgeFilter({})->on_resume_ process trailers free#2",
              parent_.filter_name_);
    if (pending_trailers != result.pending_trailers) {
      free(result.pending_trailers);
    }
  }

  state_.iteration_state_ = IterationState::Ongoing;
  resumeIteration();
}

void PlatformBridgeFilter::FilterBase::dumpState(std::ostream& os, int indent_level) {
  Buffer::Instance* buffer = this->buffer();
  const char* spaces = spacesForLevel(indent_level);
  os << spaces
     << DUMP_MEMBER_AS(state_.iteration_state_,
                       (state_.iteration_state_ == IterationState::Ongoing ? "ongoing" : "stopped"))
     << DUMP_MEMBER(state_.on_headers_called_) << DUMP_MEMBER(state_.headers_forwarded_)
     << DUMP_MEMBER(state_.on_data_called_) << DUMP_MEMBER(state_.data_forwarded_)
     << DUMP_MEMBER(state_.on_trailers_called_) << DUMP_MEMBER(state_.trailers_forwarded_)
     << DUMP_MEMBER(state_.on_resume_called_) << DUMP_NULLABLE_MEMBER(pending_headers_, "pending")
     << DUMP_NULLABLE_MEMBER(buffer, fmt::format("{} bytes", buffer->length()))
     << DUMP_NULLABLE_MEMBER(pending_trailers_, "pending") << DUMP_MEMBER(state_.stream_complete_)
     << std::endl;
};

void PlatformBridgeFilter::RequestFilterBase::addData(envoy_data data) {
  Buffer::OwnedImpl inject_data;
  inject_data.addBufferFragment(*Buffer::BridgeFragment::createBridgeFragment(data));
  parent_.decoder_callbacks_->addDecodedData(inject_data, /* watermark */ false);
}

void PlatformBridgeFilter::ResponseFilterBase::addData(envoy_data data) {
  Buffer::OwnedImpl inject_data;
  inject_data.addBufferFragment(*Buffer::BridgeFragment::createBridgeFragment(data));
  parent_.encoder_callbacks_->addEncodedData(inject_data, /* watermark */ false);
}

void PlatformBridgeFilter::RequestFilterBase::addTrailers(envoy_headers trailers) {
  Http::HeaderMap& inject_trailers = parent_.decoder_callbacks_->addDecodedTrailers();
  replaceHeaders(inject_trailers, trailers);
}

void PlatformBridgeFilter::ResponseFilterBase::addTrailers(envoy_headers trailers) {
  Http::HeaderMap& inject_trailers = parent_.encoder_callbacks_->addEncodedTrailers();
  replaceHeaders(inject_trailers, trailers);
}

void PlatformBridgeFilter::RequestFilterBase::resumeIteration() {
  parent_.decoder_callbacks_->continueDecoding();
}

void PlatformBridgeFilter::ResponseFilterBase::resumeIteration() {
  parent_.encoder_callbacks_->continueEncoding();
}

// Technically-speaking to align with Envoy's internal API this method should take
// a closure to execute with the available buffer, but since we control all usage,
// this shortcut works for now.
Buffer::Instance* PlatformBridgeFilter::RequestFilterBase::buffer() {
  Buffer::Instance* internal_buffer = nullptr;
  // This only exists to provide a mutable buffer, and that buffer is only used when iteration is
  // stopped. We check iteration state here before returning the buffer, to ensure this filter is
  // the one that stopped iteration.
  if (state_.iteration_state_ == IterationState::Stopped &&
      parent_.decoder_callbacks_->decodingBuffer()) {
    parent_.decoder_callbacks_->modifyDecodingBuffer(
        [&internal_buffer](Buffer::Instance& mutable_buffer) {
          internal_buffer = &mutable_buffer;
        });
  }
  return internal_buffer;
}

// Technically-speaking to align with Envoy's internal API this method should take
// a closure to execute with the available buffer, but since we control all usage,
// this shortcut works for now.
Buffer::Instance* PlatformBridgeFilter::ResponseFilterBase::buffer() {
  Buffer::Instance* internal_buffer = nullptr;
  // This only exists to provide a mutable buffer, and that buffer is only used when iteration is
  // stopped. We check iteration state here before returning the buffer, to ensure this filter is
  // the one that stopped iteration.
  if (state_.iteration_state_ == IterationState::Stopped &&
      parent_.encoder_callbacks_->encodingBuffer()) {
    parent_.encoder_callbacks_->modifyEncodingBuffer(
        [&internal_buffer](Buffer::Instance& mutable_buffer) {
          internal_buffer = &mutable_buffer;
        });
  }
  return internal_buffer;
}

} // namespace PlatformBridge
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/http/filter.h"

#include "library/common/extensions/filters/http/platform_bridge/c_types.h"

// NOLINT(namespace-envoy)

const envoy_filter_headers_status_t kEnvoyFilterHeadersStatusContinue =
    static_cast<envoy_filter_headers_status_t>(Envoy::Http::FilterHeadersStatus::Continue);
const envoy_filter_headers_status_t kEnvoyFilterHeadersStatusStopIteration =
    static_cast<envoy_filter_headers_status_t>(Envoy::Http::FilterHeadersStatus::StopIteration);
const envoy_filter_headers_status_t kEnvoyFilterHeadersStatusStopAllIterationAndBuffer =
    static_cast<envoy_filter_headers_status_t>(
        Envoy::Http::FilterHeadersStatus::StopAllIterationAndBuffer);
// ResumeIteration is not a status supported by Envoy itself, and only has relevance in Envoy
// Mobile's implementation of platform filters.
//
// Regarding enum values, the C++11 standard (7.2/2) states:
//   If the first enumerator has no initializer, the value of the corresponding constant is zero.
//   An enumerator-definition without an initializer gives the enumerator the value obtained by
//   increasing the value of the previous enumerator by one.
//
// Creating a new return status like this is brittle, but at least somewhat more resilient to
// a new status being added in Envoy, since it won't overlap as long as the new status is added
// rather than prepended.
const envoy_filter_headers_status_t kEnvoyFilterHeadersStatusResumeIteration =
    kEnvoyFilterHeadersStatusContinue - 1;

const envoy_filter_data_status_t kEnvoyFilterDataStatusContinue =
    static_cast<envoy_filter_data_status_t>(Envoy::Http::FilterDataStatus::Continue);
const envoy_filter_data_status_t kEnvoyFilterDataStatusStopIterationAndBuffer =
    static_cast<envoy_filter_data_status_t>(Envoy::Http::FilterDataStatus::StopIterationAndBuffer);
const envoy_filter_data_status_t kEnvoyFilterDataStatusStopIterationNoBuffer =
    static_cast<envoy_filter_data_status_t>(Envoy::Http::FilterDataStatus::StopIterationNoBuffer);
// See comment above.
const envoy_filter_data_status_t kEnvoyFilterDataStatusResumeIteration =
    kEnvoyFilterDataStatusContinue - 1;

const envoy_filter_trailers_status_t kEnvoyFilterTrailersStatusContinue =
    static_cast<envoy_filter_trailers_status_t>(Envoy::Http::FilterTrailersStatus::Continue);
const envoy_filter_trailers_status_t kEnvoyFilterTrailersStatusStopIteration =
    static_cast<envoy_filter_trailers_status_t>(Envoy::Http::FilterTrailersStatus::StopIteration);
// See comment above.
const envoy_filter_trailers_status_t kEnvoyFilterTrailersStatusResumeIteration =
    kEnvoyFilterTrailersStatusContinue - 1;

// These values don't exist in Envoy and are essentially arbitrary.
const envoy_filter_resume_status_t kEnvoyFilterResumeStatusStopIteration = 1;
const envoy_filter_resume_status_t kEnvoyFilterResumeStatusResumeIteration = -1;
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_extension",
    "envoy_extension_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_extension_package()

envoy_proto_library(
    name = "filter",
    srcs = ["filter.proto"],
)

envoy_cc_extension(
    name = "platform_bridge_filter_lib",
    srcs = [
        "c_type_definitions.h",
        "filter.cc",
    ],
    hdrs = [
        "c_types.h",
        "filter.h",
    ],
    repository = "@envoy",
    deps = [
        ":filter_cc_proto",
        "//library/common/api:external_api_lib",
        "//library/common/bridge:utility_lib",
        "//library/common/data:utility_lib",
        "//library/common/http:header_utility_lib",
        "//library/common/http:internal_headers_lib",
        "//library/common/stream_info:extra_stream_info_lib",
        "//library/common/types:c_types_lib",
        "@envoy//envoy/common:scope_tracker_interface",
        "@envoy//envoy/http:filter_interface",
        "@envoy//envoy/stats:stats_interface",
        "@envoy//envoy/stats:stats_macros",
        "@envoy//envoy/stats:timespan_interface",
        "@envoy//source/common/common:minimal_logger_lib",
        "@envoy//source/common/common:scope_tracker",
        "@envoy//source/common/stats:timespan_lib",
        "@envoy//source/extensions/filters/http/common:factory_base_lib",
        "@envoy//source/extensions/filters/http/common:pass_through_filter_lib",
    ],
)

envoy_cc_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    repository = "@envoy",
    deps = [
        ":platform_bridge_filter_lib",
        "@envoy//source/extensions/filters/http/common:factory_base_lib",
    ],
)
#pragma once

#include "envoy/common/scope_tracker.h"
#include "envoy/http/filter.h"
#include "envoy/stats/stats_macros.h"

#include "source/common/common/logger.h"
#include "source/common/stats/timespan_impl.h"
#include "source/extensions/filters/http/common/factory_base.h"
#include "source/extensions/filters/http/common/pass_through_filter.h"

#include "library/common/extensions/filters/http/platform_bridge/c_types.h"
#include "library/common/extensions/filters/http/platform_bridge/filter.pb.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace PlatformBridge {

/**
 * All PlatformBridge Filter stats. @see stats_macros.h
 */
#define ALL_PLATFORM_BRIDGE_FILTER_STATS(COUNTER, HISTOGRAM)                                       \
  HISTOGRAM(init_callback_latency, Milliseconds)                                                   \
  HISTOGRAM(on_rq_headers_callback_latency, Milliseconds)                                          \
  HISTOGRAM(on_rq_data_callback_latency, Milliseconds)                                             \
  HISTOGRAM(on_rq_trailers_callback_latency, Milliseconds)                                         \
  HISTOGRAM(on_rq_resume_callback_latency, Milliseconds)                                           \
  HISTOGRAM(on_rs_headers_callback_latency, Milliseconds)                                          \
  HISTOGRAM(on_rs_data_callback_latency, Milliseconds)                                             \
  HISTOGRAM(on_rs_trailers_callback_latency, Milliseconds)                                         \
  HISTOGRAM(on_rs_resume_callback_latency, Milliseconds)                                           \
  HISTOGRAM(on_cancel_callback_latency, Milliseconds)                                              \
  HISTOGRAM(on_error_callback_latency, Milliseconds)

/**
 * Struct definition for all DNS Filter stats. @see stats_macros.h
 */
struct PlatformBridgeFilterStats {
  ALL_PLATFORM_BRIDGE_FILTER_STATS(GENERATE_COUNTER_STRUCT, GENERATE_HISTOGRAM_STRUCT)
};

class PlatformBridgeFilter;

class PlatformBridgeFilterConfig {
public:
  PlatformBridgeFilterConfig(
      Server::Configuration::FactoryContext& context,
      const envoymobile::extensions::filters::http::platform_bridge::PlatformBridge& proto_config);

  PlatformBridgeFilterStats& stats() const { return stats_; }
  const std::string& filter_name() { return filter_name_; }
  const envoy_http_filter* platform_filter() const { return platform_filter_; }

private:
  static PlatformBridgeFilterStats generateStats(const std::string& stat_prefix,
                                                 Stats::Scope& scope) {
    const auto final_prefix = absl::StrCat("pbf_filter.", stat_prefix);
    return {ALL_PLATFORM_BRIDGE_FILTER_STATS(POOL_COUNTER_PREFIX(scope, final_prefix),
                                             POOL_HISTOGRAM_PREFIX(scope, final_prefix))};
  }

  Stats::Scope& root_scope_;
  mutable PlatformBridgeFilterStats stats_;
  const std::string filter_name_;
  const envoy_http_filter* platform_filter_;
};

using PlatformBridgeFilterConfigSharedPtr = std::shared_ptr<PlatformBridgeFilterConfig>;

enum class IterationState { Ongoing, Stopped };

/**
 * Harness to bridge Envoy filter invocations up to the platform layer.
 *
 * This filter enables filter implementations to be written in high-level platform-specific
 * languages and run within the Envoy filter chain. To mirror platform API conventions, the
 * semantic structure of platform filters differs slightly from Envoy filters. Platform
 * filter invocations (on-headers, on-data, etc.) receive *immutable* entities as parameters
 * and are expected to return compound results that include both the filter status, as well
 * as any desired modifications to the HTTP entity. Additionally, when platform filters
 * stop iteration, they _must_ use a new ResumeIteration status to resume iteration
 * at a later point. The Continue status is only valid if iteration is already ongoing.
 *
 * For more information on implementing platform filters, see the docs.
 */
class PlatformBridgeFilter final : public Http::PassThroughFilter,
                                   public ScopeTrackedObject,
                                   public Logger::Loggable<Logger::Id::filter>,
                                   public std::enable_shared_from_this<PlatformBridgeFilter> {
public:
  PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config, Event::Dispatcher& dispatcher);

  // Asynchronously trigger resumption of filter iteration, if applicable.
  // This is a no-op if filter iteration is already ongoing.
  void resumeDecoding();

  // Asynchronously trigger resumption of filter iteration, if applicable.
  // This is a no-op if filter iteration is already ongoing.
  void resumeEncoding();

  // Asynchronously reset the stream idle timeout. Does not affect other timeouts.
  void resetIdleTimer();

  // StreamFilterBase
  void onDestroy() override;
  Http::LocalErrorStatus onLocalReply(const LocalReplyData&) override;

  // StreamDecoderFilter
  void setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) override;
  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& headers,
                                          bool end_stream) override;
  Http::FilterDataStatus decodeData(Buffer::Instance& data, bool end_stream) override;
  Http::FilterTrailersStatus decodeTrailers(Http::RequestTrailerMap& trailers) override;

  // StreamEncoderFilter
  void setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) override;
  Http::FilterHeadersStatus encodeHeaders(Http::ResponseHeaderMap& headers,
                                          bool end_stream) override;
  Http::FilterDataStatus encodeData(Buffer::Instance& data, bool end_stream) override;
  Http::FilterTrailersStatus encodeTrailers(Http::ResponseTrailerMap& trailers) override;

  // ScopeTrackedObject
  void dumpState(std::ostream& os, int indent_level = 0) const override;

  // Common stream instrumentation.
  envoy_final_stream_intel finalStreamIntel();
  envoy_stream_intel streamIntel();

  // Filter state.
  bool isAlive() { return alive_; }

  TimeSource& timeSource() { return dispatcher_.timeSource(); }

private:
  /**
   * Internal delegate for managing logic and state that exists for both the request (decoding)
   * and response (encoding) paths.
   */
  struct FilterBase : public Logger::Loggable<Logger::Id::filter> {
    FilterBase(PlatformBridgeFilter& parent, std::string direction,
               envoy_filter_on_headers_f on_headers, envoy_filter_on_data_f on_data,
               envoy_filter_on_trailers_f on_trailers, envoy_filter_on_resume_f on_resume,
               Stats::Histogram& on_headers_callback_latency,
               Stats::Histogram& on_data_callback_latency,
               Stats::Histogram& on_trailers_callback_latency,
               Stats::Histogram& on_resume_callback_latency)
        : parent_(parent), direction_(std::move(direction)), on_headers_(on_headers),
          on_data_(on_data), on_trailers_(on_trailers), on_resume_(on_resume),
          on_headers_callback_latency_(on_headers_callback_latency),
          on_data_callback_latency_(on_data_callback_latency),
          on_trailers_callback_latency_(on_trailers_callback_latency),
          on_resume_callback_latency_(on_resume_callback_latency) {
      state_.iteration_state_ = IterationState::Ongoing;
    }

    virtual ~FilterBase() = default;

    // Common handling for both request and response path.
    Http::FilterHeadersStatus onHeaders(Http::HeaderMap& headers, bool end_stream);
    Http::FilterDataStatus onData(Buffer::Instance& data, bool end_stream);
    Http::FilterTrailersStatus onTrailers(Http::HeaderMap& trailers);

    // Scheduled on the dispatcher when resumeDecoding/Encoding is called from platform
    // filter callbacks. Provides a snapshot of pending HTTP stream state to the
    // platform filter, and consumes invocation results to modify pending HTTP
    // entities before resuming iteration.
    void onResume();

    // Common stream instrumentation.
    envoy_stream_intel streamIntel() { return parent_.streamIntel(); }

    // Debugging instrumentation.
    void dumpState(std::ostream& os, int indent_level = 0);

    // Directional (request/response) helper methods.
    virtual void addData(envoy_data data) PURE;
    virtual void addTrailers(envoy_headers trailers) PURE;
    virtual void resumeIteration() PURE;
    virtual Buffer::Instance* buffer() PURE;

    // Struct that collects Filter state for keeping track of state transitions and to report via
    // dumpState.
    struct FilterState {
      IterationState iteration_state_;
      bool on_headers_called_{};
      bool headers_forwarded_{};
      bool on_data_called_{};
      bool data_forwarded_{};
      bool on_trailers_called_{};
      bool trailers_forwarded_{};
      bool on_resume_called_{};
      bool stream_complete_{};
    };

    PlatformBridgeFilter& parent_;
    const std::string direction_;
    FilterState state_;
    envoy_filter_on_headers_f on_headers_;
    envoy_filter_on_data_f on_data_;
    envoy_filter_on_trailers_f on_trailers_;
    envoy_filter_on_resume_f on_resume_;
    Stats::Histogram& on_headers_callback_latency_;
    Stats::Histogram& on_data_callback_latency_;
    Stats::Histogram& on_trailers_callback_latency_;
    Stats::Histogram& on_resume_callback_latency_;
    Http::HeaderMap* pending_headers_{};
    Http::HeaderMap* pending_trailers_{};
  };

  struct RequestFilterBase : FilterBase {
    RequestFilterBase(PlatformBridgeFilter& parent)
        : FilterBase(parent, "request", parent.platform_filter_.on_request_headers,
                     parent.platform_filter_.on_request_data,
                     parent.platform_filter_.on_request_trailers,
                     parent.platform_filter_.on_resume_request,
                     parent.config_->stats().on_rq_headers_callback_latency_,
                     parent.config_->stats().on_rq_data_callback_latency_,
                     parent.config_->stats().on_rq_trailers_callback_latency_,
                     parent.config_->stats().on_rq_resume_callback_latency_) {}

    // FilterBase
    void addData(envoy_data data) override;
    void addTrailers(envoy_headers trailers) override;
    void resumeIteration() override;
    Buffer::Instance* buffer() override;
  };

  using RequestFilterBasePtr = std::unique_ptr<RequestFilterBase>;

  struct ResponseFilterBase : FilterBase {
    ResponseFilterBase(PlatformBridgeFilter& parent)
        : FilterBase(parent, "response", parent.platform_filter_.on_response_headers,
                     parent.platform_filter_.on_response_data,
                     parent.platform_filter_.on_response_trailers,
                     parent.platform_filter_.on_resume_response,
                     parent.config_->stats().on_rs_headers_callback_latency_,
                     parent.config_->stats().on_rs_data_callback_latency_,
                     parent.config_->stats().on_rs_trailers_callback_latency_,
                     parent.config_->stats().on_rs_resume_callback_latency_) {}

    // FilterBase
    void addData(envoy_data data) override;
    void addTrailers(envoy_headers trailers) override;
    void resumeIteration() override;
    Buffer::Instance* buffer() override;
  };

  using ResponseFilterBasePtr = std::unique_ptr<ResponseFilterBase>;

  Event::ScopeTracker& scopeTracker() const { return dispatcher_; }

  PlatformBridgeFilterConfigSharedPtr config_;
  Event::Dispatcher& dispatcher_;
  const std::string filter_name_;
  envoy_http_filter platform_filter_;
  RequestFilterBasePtr request_filter_base_{};
  ResponseFilterBasePtr response_filter_base_{};
  envoy_http_filter_callbacks platform_request_callbacks_{};
  envoy_http_filter_callbacks platform_response_callbacks_{};
  bool error_response_{};
  bool alive_{true};
};

using PlatformBridgeFilterSharedPtr = std::shared_ptr<PlatformBridgeFilter>;
using PlatformBridgeFilterWeakPtr = std::weak_ptr<PlatformBridgeFilter>;

} // namespace PlatformBridge
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "library/common/extensions/filters/http/platform_bridge/config.h"

#include "library/common/extensions/filters/http/platform_bridge/filter.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace PlatformBridge {

Http::FilterFactoryCb PlatformBridgeFilterFactory::createFilterFactoryFromProtoTyped(
    const envoymobile::extensions::filters::http::platform_bridge::PlatformBridge& proto_config,
    const std::string&, Server::Configuration::FactoryContext& context) {

  PlatformBridgeFilterConfigSharedPtr filter_config =
      std::make_shared<PlatformBridgeFilterConfig>(context, proto_config);
  return [filter_config, &context](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamFilter(std::make_shared<PlatformBridgeFilter>(
        filter_config, context.serverFactoryContext().mainThreadDispatcher()));
  };
}

/**
 * Static registration for the PlatformBridge filter. @see NamedHttpFilterConfigFactory.
 */
REGISTER_FACTORY(PlatformBridgeFilterFactory, Server::Configuration::NamedHttpFilterConfigFactory);

} // namespace PlatformBridge
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";

package envoymobile.extensions.filters.http.socket_tag;

// Configuration for the socket tagging filer. This filter uses data from the
// x-envoy-mobile-socket-tag request header to apply an Android Socket Tag to the upstream
// socket.
// See: https://source.android.com/devices/tech/datausage/tags-explained
// See: https://developer.android.com/reference/android/net/TrafficStats#setThreadStatsTag(int)
// See: https://developer.android.com/reference/android/net/TrafficStats#setThreadStatsUid(int)
// See: https://developer.android.com/reference/android/net/TrafficStats#tagSocket(java.net.Socket)
message SocketTag {
}
#pragma once

#include <string>

#include "source/extensions/filters/http/common/factory_base.h"

#include "library/common/extensions/filters/http/socket_tag/filter.pb.h"
#include "library/common/extensions/filters/http/socket_tag/filter.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace SocketTag {

/**
 * Config registration for the socket tag filter. @see NamedHttpFilterConfigFactory.
 */
class SocketTagFilterFactory
    : public Common::FactoryBase<envoymobile::extensions::filters::http::socket_tag::SocketTag> {
public:
  SocketTagFilterFactory() : FactoryBase("socket_tag") {}

private:
  ::Envoy::Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoymobile::extensions::filters::http::socket_tag::SocketTag& config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

DECLARE_FACTORY(SocketTagFilterFactory);

} // namespace SocketTag
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "library/common/extensions/filters/http/socket_tag/filter.h"

#include "envoy/server/filter_config.h"

#include "library/common/network/socket_tag_socket_option_impl.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace SocketTag {

Http::FilterHeadersStatus SocketTagFilter::decodeHeaders(Http::RequestHeaderMap& request_headers,
                                                         bool) {
  static auto socket_tag_header = Http::LowerCaseString("x-envoy-mobile-socket-tag");
  Http::RequestHeaderMap::GetResult header = request_headers.get(socket_tag_header);
  if (header.empty()) {
    return Http::FilterHeadersStatus::Continue;
  }

  // The x-envoy-mobile-socket-tag header must contain a pair of number separated by a comma, e.g.:
  // x-envoy-mobile-socket-tag: 123,456
  // The first number contains the UID and the second contains the traffic stats tag.
  std::string tag_string(header[0]->value().getStringView());
  std::pair<std::string, std::string> data = absl::StrSplit(tag_string, ',');
  uid_t uid;
  uint32_t traffic_stats_tag;
  if (!absl::SimpleAtoi(data.first, &uid) || !absl::SimpleAtoi(data.second, &traffic_stats_tag)) {
    decoder_callbacks_->sendLocalReply(
        Http::Code::BadRequest,
        absl::StrCat("Invalid x-envoy-mobile-socket-tag header: ", tag_string), nullptr,
        absl::nullopt, "");
    return Http::FilterHeadersStatus::StopIteration;
  }
  auto options = std::make_shared<Network::Socket::Options>();
  options->push_back(std::make_shared<Network::SocketTagSocketOptionImpl>(uid, traffic_stats_tag));
  decoder_callbacks_->addUpstreamSocketOptions(options);
  request_headers.remove(socket_tag_header);
  return Http::FilterHeadersStatus::Continue;
}

} // namespace SocketTag
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_extension",
    "envoy_extension_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_extension_package()

envoy_proto_library(
    name = "filter",
    srcs = ["filter.proto"],
)

envoy_cc_extension(
    name = "socket_tag_filter_lib",
    srcs = ["filter.cc"],
    hdrs = ["filter.h"],
    repository = "@envoy",
    deps = [
        ":filter_cc_proto",
        "//library/common/http:internal_headers_lib",
        "//library/common/network:socket_tag_socket_option_lib",
        "//library/common/types:c_types_lib",
        "@envoy//envoy/http:codes_interface",
        "@envoy//envoy/http:filter_interface",
        "@envoy//source/extensions/filters/http/common:pass_through_filter_lib",
    ],
)

envoy_cc_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    repository = "@envoy",
    deps = [
        ":socket_tag_filter_lib",
        "@envoy//source/extensions/filters/http/common:factory_base_lib",
    ],
)
#pragma once

#include "envoy/http/filter.h"

#include "source/common/common/logger.h"
#include "source/extensions/filters/http/common/pass_through_filter.h"

#include "library/common/extensions/filters/http/socket_tag/filter.pb.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace SocketTag {

/**
 * Filter to set upstream socket tags based on a request header.
 * See: https://source.android.com/devices/tech/datausage/tags-explained
 */
class SocketTagFilter final : public Http::PassThroughFilter,
                              public Logger::Loggable<Logger::Id::filter> {
public:
  // Http::PassThroughDecoderFilter
  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& request_headers, bool) override;
};

} // namespace SocketTag
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "library/common/extensions/filters/http/socket_tag/config.h"

#include <stdint.h>
#include <sys/types.h>
#include <unistd.h>

#include "envoy/network/listen_socket.h"

#include "library/common/extensions/filters/http/socket_tag/filter.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace SocketTag {

Http::FilterFactoryCb SocketTagFilterFactory::createFilterFactoryFromProtoTyped(
    const envoymobile::extensions::filters::http::socket_tag::SocketTag& /*proto_config*/,
    const std::string&, Server::Configuration::FactoryContext& /*context*/) {

  return [](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamFilter(std::make_shared<SocketTagFilter>());
  };
}

/**
 * Static registration for the SocketTag filter. @see NamedHttpFilterConfigFactory.
 */
REGISTER_FACTORY(SocketTagFilterFactory, Server::Configuration::NamedHttpFilterConfigFactory);

} // namespace SocketTag
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include <string>

#include "envoy/upstream/retry.h"

#include "source/common/protobuf/message_validator_impl.h"

#include "library/common/extensions/retry/options/network_configuration/predicate.h"
#include "library/common/extensions/retry/options/network_configuration/predicate.pb.h"
#include "library/common/extensions/retry/options/network_configuration/predicate.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace Retry {
namespace Options {

class NetworkConfigurationRetryOptionsPredicateFactory
    : public Upstream::RetryOptionsPredicateFactory {
public:
  Upstream::RetryOptionsPredicateConstSharedPtr
  createOptionsPredicate(const Protobuf::Message& config,
                         Upstream::RetryExtensionFactoryContext& context) override {
    return std::make_shared<NetworkConfigurationRetryOptionsPredicate>(
        MessageUtil::downcastAndValidate<
            const envoymobile::extensions::retry::options::network_configuration::
                NetworkConfigurationOptionsPredicate&>(
            config, ProtobufMessage::getStrictValidationVisitor()),
        context);
  }

  std::string name() const override {
    return "envoy.retry_options_predicates.network_configuration";
  }

  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<envoymobile::extensions::retry::options::network_configuration::
                                NetworkConfigurationOptionsPredicate>();
  }
};

DECLARE_FACTORY(NetworkConfigurationRetryOptionsPredicateFactory);

} // namespace Options
} // namespace Retry
} // namespace Extensions
} // namespace Envoy
#include "library/common/extensions/retry/options/network_configuration/predicate.h"

#include "library/common/stream_info/extra_stream_info.h"

namespace Envoy {
namespace Extensions {
namespace Retry {
namespace Options {

NetworkConfigurationRetryOptionsPredicate::NetworkConfigurationRetryOptionsPredicate(
    const envoymobile::extensions::retry::options::network_configuration::
        NetworkConfigurationOptionsPredicate&,
    Upstream::RetryExtensionFactoryContext& context) {
  connectivity_manager_ = Network::ConnectivityManagerHandle{context.singletonManager()}.get();
  RELEASE_ASSERT(connectivity_manager_ != nullptr,
                 "unexpected nullptr network connectivity_manager");
}

Upstream::RetryOptionsPredicate::UpdateOptionsReturn
NetworkConfigurationRetryOptionsPredicate::updateOptions(
    const Upstream::RetryOptionsPredicate::UpdateOptionsParameters& parameters) const {

  auto options = std::make_shared<Network::Socket::Options>();
  auto& stream_info = parameters.retriable_request_stream_info_;
  auto filter_state = stream_info.filterState();

  // ExtraStreamInfo is added by the NetworkConfigurationFilter and should normally always be
  // present - this check is mostly defensive.
  if (!filter_state->hasData<StreamInfo::ExtraStreamInfo>(StreamInfo::ExtraStreamInfo::key())) {
    ENVOY_LOG(warn, "extra stream info is missing");

    // Returning nullopt results in existing socket options being preserved.
    return Upstream::RetryOptionsPredicate::UpdateOptionsReturn{absl::nullopt};
  }

  StreamInfo::ExtraStreamInfo* extra_stream_info =
      filter_state->getDataMutable<StreamInfo::ExtraStreamInfo>(StreamInfo::ExtraStreamInfo::key());

  if (extra_stream_info == nullptr) {
    ENVOY_LOG(warn, "extra stream info is missing");

    // Returning nullopt results in existing socket options being preserved.
    return Upstream::RetryOptionsPredicate::UpdateOptionsReturn{absl::nullopt};
  }

  // This check is also defensive. The NetworkConfigurationFilter should always set this when
  // ExtraStreaminfo is created.
  if (!extra_stream_info->configuration_key_.has_value()) {
    ENVOY_LOG(warn, "network configuration key is missing");

    // Returning nullopt results in existing socket options being preserved.
    return Upstream::RetryOptionsPredicate::UpdateOptionsReturn{absl::nullopt};
  }

  // As a proxy for the many different types of network errors, this code interprets any failure
  // where a stream received no bytes from the upstream as a network fault. This status is passed to
  // the connectivity_manager below when we report network usage, where it may be factored into
  // future socket configuration.
  bool network_fault =
      !stream_info.upstreamInfo() ||
      !stream_info.upstreamInfo()->upstreamTiming().first_upstream_rx_byte_received_.has_value();

  // Report request status to network connectivity_manager, so that socket configuration may be
  // adapted to current network conditions.
  connectivity_manager_->reportNetworkUsage(extra_stream_info->configuration_key_.value(),
                                            network_fault);

  // Update socket configuration for next retry attempt.
  extra_stream_info->configuration_key_ = connectivity_manager_->addUpstreamSocketOptions(options);

  // The options returned here replace any existing socket options used for a prior attempt. At
  // present, all socket options set in Envoy Mobile are provided by the NetworkConnectivityManager,
  // so it's safe to simply replace them.
  // TODO(goaway): If additional socket options are ever provided by a source other than the
  // NetworkConnectivityManager, we need to account for the potential presence of those options
  // here.
  return Upstream::RetryOptionsPredicate::UpdateOptionsReturn{options};
}

} // namespace Options
} // namespace Retry
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";

package envoymobile.extensions.retry.options.network_configuration;

message NetworkConfigurationOptionsPredicate {
}
#pragma once

#include "envoy/upstream/retry.h"

#include "source/common/common/logger.h"

#include "library/common/extensions/retry/options/network_configuration/predicate.pb.h"
#include "library/common/extensions/retry/options/network_configuration/predicate.pb.validate.h"
#include "library/common/network/connectivity_manager.h"

namespace Envoy {
namespace Extensions {
namespace Retry {
namespace Options {

class NetworkConfigurationRetryOptionsPredicate : public Upstream::RetryOptionsPredicate,
                                                  public Logger::Loggable<Logger::Id::upstream> {
public:
  NetworkConfigurationRetryOptionsPredicate(
      const envoymobile::extensions::retry::options::network_configuration::
          NetworkConfigurationOptionsPredicate&,
      Upstream::RetryExtensionFactoryContext& context);

  Upstream::RetryOptionsPredicate::UpdateOptionsReturn
  updateOptions(const Upstream::RetryOptionsPredicate::UpdateOptionsParameters&) const override;

private:
  Network::ConnectivityManagerSharedPtr connectivity_manager_;
};

} // namespace Options
} // namespace Retry
} // namespace Extensions
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_extension",
    "envoy_extension_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_extension_package()

envoy_proto_library(
    name = "predicate",
    srcs = ["predicate.proto"],
)

envoy_cc_extension(
    name = "network_configuration_retry_options_predicate_lib",
    srcs = ["predicate.cc"],
    hdrs = ["predicate.h"],
    repository = "@envoy",
    deps = [
        ":predicate_cc_proto",
        "//library/common/network:connectivity_manager_lib",
        "//library/common/stream_info:extra_stream_info_lib",
        "@envoy//envoy/upstream:retry_interface",
    ],
)

envoy_cc_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    repository = "@envoy",
    deps = [
        ":network_configuration_retry_options_predicate_lib",
        ":predicate_cc_proto",
        "@envoy//envoy/upstream:retry_interface",
    ],
)
#include "library/common/extensions/retry/options/network_configuration/config.h"

#include "envoy/registry/registry.h"

namespace Envoy {
namespace Extensions {
namespace Retry {
namespace Options {

REGISTER_FACTORY(NetworkConfigurationRetryOptionsPredicateFactory,
                 Upstream::RetryOptionsPredicateFactory);

}
} // namespace Retry
} // namespace Extensions
} // namespace Envoy
#include "library/common/extensions/listener_managers/api_listener_manager/api_listener_manager.h"

#include "envoy/config/listener/v3/listener.pb.h"
#include "envoy/network/listener.h"

#include "source/common/common/assert.h"
#include "source/common/common/fmt.h"
#include "source/common/config/utility.h"
#include "source/server/api_listener_impl.h"

namespace Envoy {
namespace Server {

ApiListenerManagerImpl::ApiListenerManagerImpl(Instance& server) : server_(server) {}

absl::StatusOr<bool>
ApiListenerManagerImpl::addOrUpdateListener(const envoy::config::listener::v3::Listener& config,
                                            const std::string&, bool added_via_api) {
  ENVOY_LOG(debug, "Creating API listener manager");
  std::string name;
  if (!config.name().empty()) {
    name = config.name();
  } else {
    // TODO (soulxu): The random uuid name is bad for logging. We can use listening addresses in
    // the log to improve that.
    name = server_.api().randomGenerator().uuid();
  }

  // TODO(junr03): currently only one ApiListener can be installed via bootstrap to avoid having to
  // build a collection of listeners, and to have to be able to warm and drain the listeners. In the
  // future allow multiple ApiListeners, and allow them to be created via LDS as well as bootstrap.
  if (config.has_api_listener()) {
    if (config.has_internal_listener()) {
      return absl::InvalidArgumentError(fmt::format(
          "error adding listener named '{}': api_listener and internal_listener cannot be both set",
          name));
    }
    if (!api_listener_ && !added_via_api) {
      auto listener_or_error = HttpApiListener::create(config, server_, config.name());
      RETURN_IF_STATUS_NOT_OK(listener_or_error);
      api_listener_ = std::move(listener_or_error.value());
      return true;
    } else {
      ENVOY_LOG(warn, "listener {} can not be added because currently only one ApiListener is "
                      "allowed, and it can only be added via bootstrap configuration");
      return false;
    }
  }
  return false;
}

REGISTER_FACTORY(ApiListenerManagerFactoryImpl, ListenerManagerFactory);

} // namespace Server
} // namespace Envoy
#pragma once

#include <memory>

#include "envoy/server/instance.h"
#include "envoy/server/listener_manager.h"

#include "source/server/listener_manager_factory.h"

namespace Envoy {
namespace Server {

/**
 * Implementation of a lightweight ListenerManager for Envoy Mobile.
 * This does not handle downstream TCP / UDP connections but only the API listener.
 */
class ApiListenerManagerImpl : public ListenerManager, Logger::Loggable<Logger::Id::config> {
public:
  explicit ApiListenerManagerImpl(Instance& server);

  // Server::ListenerManager
  absl::StatusOr<bool> addOrUpdateListener(const envoy::config::listener::v3::Listener& config,
                                           const std::string& version_info,
                                           bool added_via_api) override;
  void createLdsApi(const envoy::config::core::v3::ConfigSource&,
                    const xds::core::v3::ResourceLocator*) override {}
  std::vector<std::reference_wrapper<Network::ListenerConfig>> listeners(ListenerState) override {
    return {};
  }
  uint64_t numConnections() const override { return 0; }
  bool removeListener(const std::string&) override { return true; }
  void startWorkers(OptRef<GuardDog>, std::function<void()> callback) override { callback(); }
  void stopListeners(StopListenersType, const Network::ExtraShutdownListenerOptions&) override {}
  void stopWorkers() override {}
  void beginListenerUpdate() override {}
  void endListenerUpdate(FailureStates&&) override {}
  bool isWorkerStarted() override { return true; }
  Http::Context& httpContext() { return server_.httpContext(); }
  ApiListenerOptRef apiListener() override {
    return api_listener_ ? ApiListenerOptRef(std::ref(*api_listener_)) : absl::nullopt;
  }

private:
  Instance& server_;
  ApiListenerPtr api_listener_;
};

class ApiListenerManagerFactoryImpl : public ListenerManagerFactory {
public:
  std::unique_ptr<ListenerManager>
  createListenerManager(Instance& server, std::unique_ptr<ListenerComponentFactory>&&,
                        WorkerFactory&, bool, Quic::QuicStatNames&) override {
    return std::make_unique<ApiListenerManagerImpl>(server);
  }
  std::string name() const override { return "envoy.listener_manager_impl.api"; }
  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<envoy::config::listener::v3::ApiListenerManager>();
  }
};

DECLARE_FACTORY(ApiListenerManagerFactoryImpl);

} // namespace Server
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_extension",
    "envoy_extension_package",
)

licenses(["notice"])  # Apache 2

envoy_extension_package()

envoy_cc_extension(
    name = "api_listener_manager_lib",
    srcs = [
        "api_listener_manager.cc",
    ],
    hdrs = [
        "api_listener_manager.h",
    ],
    repository = "@envoy",
    deps = [
        "@envoy//envoy/server:instance_interface",
        "@envoy//envoy/server:listener_manager_interface",
        "@envoy//source/server:api_listener_lib",
        "@envoy//source/server:listener_manager_factory_lib",
        "@envoy_api//envoy/config/listener/v3:pkg_cc_proto",
    ],
)
#pragma once

#include "envoy/registry/registry.h"

#include "source/extensions/transport_sockets/tls/cert_validator/factory.h"

#include "library/common/extensions/cert_validator/platform_bridge/platform_bridge.pb.h"
#include "library/common/extensions/cert_validator/platform_bridge/platform_bridge_cert_validator.h"

namespace Envoy {
namespace Extensions {
namespace TransportSockets {
namespace Tls {

class PlatformBridgeCertValidatorFactory : public CertValidatorFactory,
                                           public Config::TypedFactory {
public:
  CertValidatorPtr createCertValidator(const Envoy::Ssl::CertificateValidationContextConfig* config,
                                       SslStats& stats, TimeSource& time_source) override;

  std::string name() const override {
    return "envoy_mobile.cert_validator.platform_bridge_cert_validator";
  }
  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<
        envoy_mobile::extensions::cert_validator::platform_bridge::PlatformBridgeCertValidator>();
  }
  std::string category() const override { return "envoy.tls.cert_validator"; }
};

DECLARE_FACTORY(PlatformBridgeCertValidatorFactory);

} // namespace Tls
} // namespace TransportSockets
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";

package envoy_mobile.extensions.cert_validator.platform_bridge;

message PlatformBridgeCertValidator {
}
#include "library/common/extensions/cert_validator/platform_bridge/platform_bridge_cert_validator.h"

#include <list>
#include <memory>
#include <type_traits>

#include "library/common/common/system_helper.h"
#include "library/common/data/utility.h"

namespace Envoy {
namespace Extensions {
namespace TransportSockets {
namespace Tls {

PlatformBridgeCertValidator::PlatformBridgeCertValidator(
    const Envoy::Ssl::CertificateValidationContextConfig* config, SslStats& stats)
    : allow_untrusted_certificate_(config != nullptr &&
                                   config->trustChainVerification() ==
                                       envoy::extensions::transport_sockets::tls::v3::
                                           CertificateValidationContext::ACCEPT_UNTRUSTED),
      stats_(stats) {
  ENVOY_BUG(config != nullptr && config->caCert().empty() &&
                config->certificateRevocationList().empty(),
            "Invalid certificate validation context config.");
}

PlatformBridgeCertValidator::~PlatformBridgeCertValidator() {
  // Wait for validation threads to finish.
  for (auto& [id, job] : validation_jobs_) {
    if (job.validation_thread_.joinable()) {
      job.validation_thread_.join();
    }
  }
}

ValidationResults PlatformBridgeCertValidator::doVerifyCertChain(
    STACK_OF(X509) & cert_chain, Ssl::ValidateResultCallbackPtr callback,
    const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,
    SSL_CTX& /*ssl_ctx*/, const CertValidator::ExtraValidationContext& /*validation_context*/,
    bool is_server, absl::string_view hostname) {
  ASSERT(!is_server);
  if (sk_X509_num(&cert_chain) == 0) {
    const char* error = "verify cert chain failed: empty cert chain.";
    stats_.fail_verify_error_.inc();
    ENVOY_LOG(debug, error);
    return {ValidationResults::ValidationStatus::Failed,
            Envoy::Ssl::ClientValidationStatus::NotValidated, absl::nullopt, error};
  }
  if (callback == nullptr) {
    IS_ENVOY_BUG("No callback specified");
    const char* error = "verify cert chain failed: no callback specified.";
    return {ValidationResults::ValidationStatus::Failed,
            Envoy::Ssl::ClientValidationStatus::NotValidated, absl::nullopt, error};
  }

  std::vector<std::string> certs;
  for (uint64_t i = 0; i < sk_X509_num(&cert_chain); i++) {
    X509* cert = sk_X509_value(&cert_chain, i);
    unsigned char* cert_in_der = nullptr;
    int der_length = i2d_X509(cert, &cert_in_der);
    ASSERT(der_length > 0 && cert_in_der != nullptr);

    absl::string_view cert_str(reinterpret_cast<char*>(cert_in_der),
                               static_cast<size_t>(der_length));
    certs.push_back(std::string(cert_str));
    OPENSSL_free(cert_in_der);
  }

  absl::string_view host;
  if (transport_socket_options != nullptr &&
      !transport_socket_options->verifySubjectAltNameListOverride().empty()) {
    host = transport_socket_options->verifySubjectAltNameListOverride()[0];
  } else {
    host = hostname;
  }

  std::vector<std::string> subject_alt_names;
  if (transport_socket_options != nullptr &&
      !transport_socket_options->verifySubjectAltNameListOverride().empty()) {
    subject_alt_names = transport_socket_options->verifySubjectAltNameListOverride();
  } else if (!hostname.empty()) {
    subject_alt_names = {std::string(hostname)};
  }

  ValidationJob job;
  job.result_callback_ = std::move(callback);
  job.validation_thread_ =
      std::thread(&verifyCertChainByPlatform, &(job.result_callback_->dispatcher()),
                  std::move(certs), std::string(host), std::move(subject_alt_names), this);
  std::thread::id thread_id = job.validation_thread_.get_id();
  validation_jobs_[thread_id] = std::move(job);
  return {ValidationResults::ValidationStatus::Pending,
          Envoy::Ssl::ClientValidationStatus::NotValidated, absl::nullopt, absl::nullopt};
}

void PlatformBridgeCertValidator::verifyCertChainByPlatform(
    Event::Dispatcher* dispatcher, std::vector<std::string> cert_chain, std::string hostname,
    std::vector<std::string> subject_alt_names, PlatformBridgeCertValidator* parent) {
  ASSERT(!cert_chain.empty());
  ENVOY_LOG(trace, "Start verifyCertChainByPlatform for host {}", hostname);
  // This is running in a stand alone thread other than the engine thread.
  const std::string& leaf_cert_der = cert_chain[0];
  const unsigned char* leaf_cert_data =
      reinterpret_cast<const unsigned char*>(leaf_cert_der.data());
  bssl::UniquePtr<X509> leaf_cert(d2i_X509(nullptr, &leaf_cert_data, leaf_cert_der.length()));
  envoy_cert_validation_result result =
      SystemHelper::getInstance().validateCertificateChain(cert_chain, hostname);
  bool success = result.result == ENVOY_SUCCESS;
  if (!success) {
    ENVOY_LOG(debug, result.error_details);
    postVerifyResultAndCleanUp(success, std::move(hostname), result.error_details, result.tls_alert,
                               ValidationFailureType::FAIL_VERIFY_ERROR, dispatcher, parent);
    return;
  }

  absl::string_view error_details;
  if (!subject_alt_names.empty()) {
    // Verify that host name matches leaf cert.
    success = DefaultCertValidator::verifySubjectAltName(leaf_cert.get(), subject_alt_names);
  }
  if (!success) {
    error_details = "PlatformBridgeCertValidator_verifySubjectAltName failed: SNI mismatch.";
    ENVOY_LOG(debug, error_details);
    postVerifyResultAndCleanUp(success, std::move(hostname), error_details, SSL_AD_BAD_CERTIFICATE,
                               ValidationFailureType::FAIL_VERIFY_SAN, dispatcher, parent);
    return;
  }
  postVerifyResultAndCleanUp(success, std::move(hostname), error_details,
                             SSL_AD_CERTIFICATE_UNKNOWN, ValidationFailureType::SUCCESS, dispatcher,
                             parent);
}

void PlatformBridgeCertValidator::postVerifyResultAndCleanUp(bool success, std::string hostname,
                                                             absl::string_view error_details,
                                                             uint8_t tls_alert,
                                                             ValidationFailureType failure_type,
                                                             Event::Dispatcher* dispatcher,
                                                             PlatformBridgeCertValidator* parent) {
  ENVOY_LOG(trace,
            "Finished platform cert validation for {}, post result callback to network thread",
            hostname);

  SystemHelper::getInstance().cleanupAfterCertificateValidation();

  std::weak_ptr<size_t> weak_alive_indicator(parent->alive_indicator_);

  dispatcher->post([weak_alive_indicator, success, hostname = std::move(hostname),
                    error = std::string(error_details), tls_alert, failure_type,
                    thread_id = std::this_thread::get_id(), parent]() {
    if (weak_alive_indicator.expired()) {
      return;
    }
    parent->onVerificationComplete(thread_id, hostname, success, error, tls_alert, failure_type);
  });
}

void PlatformBridgeCertValidator::onVerificationComplete(std::thread::id thread_id,
                                                         std::string hostname, bool success,
                                                         std::string error, uint8_t tls_alert,
                                                         ValidationFailureType failure_type) {
  ENVOY_LOG(trace, "Got validation result for {} from platform", hostname);

  auto job_handle = validation_jobs_.extract(thread_id);
  if (job_handle.empty()) {
    IS_ENVOY_BUG("No job found for thread");
    return;
  }
  ValidationJob& job = job_handle.mapped();
  job.validation_thread_.join();

  Ssl::ClientValidationStatus detailed_status = Envoy::Ssl::ClientValidationStatus::NotValidated;
  switch (failure_type) {
  case ValidationFailureType::SUCCESS:
    detailed_status = Envoy::Ssl::ClientValidationStatus::Validated;
    break;
  case ValidationFailureType::FAIL_VERIFY_ERROR:
    detailed_status = Envoy::Ssl::ClientValidationStatus::Failed;
    stats_.fail_verify_error_.inc();
    break;
  case ValidationFailureType::FAIL_VERIFY_SAN:
    detailed_status = Envoy::Ssl::ClientValidationStatus::Failed;
    stats_.fail_verify_san_.inc();
    break;
  }

  job.result_callback_->onCertValidationResult(allow_untrusted_certificate_ || success,
                                               detailed_status, error, tls_alert);
  ENVOY_LOG(trace,
            "Finished platform cert validation for {}, post result callback to network thread",
            hostname);
}

} // namespace Tls
} // namespace TransportSockets
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "library/common/types/c_types.h"

// NOLINT(namespace-envoy)

/**
 * Certification validation binary result with corresponding boring SSL alert
 * and error details if the result indicates failure.
 */
typedef struct {
  envoy_status_t result;
  uint8_t tls_alert;
  const char* error_details;
} envoy_cert_validation_result;
#pragma once

#include <thread>

#include "source/extensions/transport_sockets/tls/cert_validator/default_validator.h"

#include "absl/container/flat_hash_map.h"
#include "library/common/extensions/cert_validator/platform_bridge/c_types.h"

namespace Envoy {
namespace Extensions {
namespace TransportSockets {
namespace Tls {

// A certification validation implementation that uses the platform provided APIs to verify
// certificate chain. Since some platform APIs are slow blocking calls, in order not to block
// network events, this implementation creates stand-alone threads to make those calls for each
// validation.
class PlatformBridgeCertValidator : public CertValidator, Logger::Loggable<Logger::Id::connection> {
public:
  PlatformBridgeCertValidator(const Envoy::Ssl::CertificateValidationContextConfig* config,
                              SslStats& stats);

  ~PlatformBridgeCertValidator() override;

  // CertValidator
  // These are not very meaningful interfaces for cert validator on client side and are only called
  // by server TLS context. Ideally they should be moved from CertValidator into an extended server
  // cert validator interface. And this class only extends the client interface. But their owner
  // (Tls::ContextImpl) doesn't have endpoint perspective today, so there will need more refactoring
  // to achieve this.
  void addClientValidationContext(SSL_CTX* /*context*/, bool /*require_client_cert*/) override {
    PANIC("Should not be reached");
  }
  void updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& /*md*/,
                                uint8_t* /*hash_buffer[EVP_MAX_MD_SIZE]*/,
                                unsigned /*hash_length*/) override {
    PANIC("Should not be reached");
  }
  absl::optional<uint32_t> daysUntilFirstCertExpires() const override { return absl::nullopt; }
  Envoy::Ssl::CertificateDetailsPtr getCaCertInformation() const override { return nullptr; }
  // Return empty string
  std::string getCaFileName() const override { return ""; }
  // Overridden to call into platform extension API asynchronously.
  ValidationResults
  doVerifyCertChain(STACK_OF(X509) & cert_chain, Ssl::ValidateResultCallbackPtr callback,
                    const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,
                    SSL_CTX& ssl_ctx,
                    const CertValidator::ExtraValidationContext& validation_context, bool is_server,
                    absl::string_view hostname) override;
  // Returns SSL_VERIFY_PEER so that doVerifyCertChain() will be called from the TLS stack.
  int initializeSslContexts(std::vector<SSL_CTX*> /*contexts*/,
                            bool /*handshaker_provides_certificates*/) override {
    return SSL_VERIFY_PEER;
  }

private:
  enum class ValidationFailureType {
    SUCCESS,
    FAIL_VERIFY_ERROR,
    FAIL_VERIFY_SAN,
  };

  // Calls into platform APIs in a stand-alone thread to verify the given certs.
  // Once the validation is done, the result will be posted back to the current
  // thread to trigger callback and update verify stats.
  // Must be called on the validation thread.
  static void verifyCertChainByPlatform(Event::Dispatcher* dispatcher,
                                        std::vector<std::string> cert_chain, std::string hostname,
                                        std::vector<std::string> subject_alt_names,
                                        PlatformBridgeCertValidator* parent);

  // Must be called on the validation thread.
  static void postVerifyResultAndCleanUp(bool success, std::string hostname,
                                         absl::string_view error_details, uint8_t tls_alert,
                                         ValidationFailureType failure_type,
                                         Event::Dispatcher* dispatcher,
                                         PlatformBridgeCertValidator* parent);

  // Called when a pending verification completes. Must be invoked on the main thread.
  void onVerificationComplete(std::thread::id thread_id, std::string hostname, bool success,
                              std::string error_details, uint8_t tls_alert,
                              ValidationFailureType failure_type);

  struct ValidationJob {
    Ssl::ValidateResultCallbackPtr result_callback_;
    std::thread validation_thread_;
  };

  const bool allow_untrusted_certificate_;
  SslStats& stats_;
  absl::flat_hash_map<std::thread::id, ValidationJob> validation_jobs_;
  std::shared_ptr<size_t> alive_indicator_{new size_t(1)};
};

} // namespace Tls
} // namespace TransportSockets
} // namespace Extensions
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_extension",
    "envoy_cc_library",
    "envoy_extension_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_extension_package()

envoy_proto_library(
    name = "platform_bridge",
    srcs = ["platform_bridge.proto"],
)

envoy_cc_library(
    name = "c_types_lib",
    hdrs = ["c_types.h"],
    repository = "@envoy",
    deps = [
        "//library/common/data:utility_lib",
    ],
)

envoy_cc_library(
    name = "platform_bridge_cert_validator_lib",
    srcs = ["platform_bridge_cert_validator.cc"],
    hdrs = [
        "platform_bridge_cert_validator.h",
    ],
    repository = "@envoy",
    deps = [
        ":c_types_lib",
        ":platform_bridge_cc_proto",
        "//library/common/common:system_helper_lib",
        "@envoy//source/extensions/transport_sockets/tls/cert_validator:cert_validator_lib",
    ],
)

envoy_cc_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = [
        "c_types.h",
        "config.h",
    ],
    repository = "@envoy",
    deps = [
        ":platform_bridge_cert_validator_lib",
        "//library/common/api:external_api_lib",
        "//library/common/data:utility_lib",
        "@envoy//envoy/registry",
    ],
)
#include "library/common/extensions/cert_validator/platform_bridge/config.h"

#include "library/common/api/external.h"

namespace Envoy {
namespace Extensions {
namespace TransportSockets {
namespace Tls {

CertValidatorPtr PlatformBridgeCertValidatorFactory::createCertValidator(
    const Envoy::Ssl::CertificateValidationContextConfig* config, SslStats& stats,
    TimeSource& /*time_source*/) {
  return std::make_unique<PlatformBridgeCertValidator>(config, stats);
}

REGISTER_FACTORY(PlatformBridgeCertValidatorFactory, CertValidatorFactory);

} // namespace Tls
} // namespace TransportSockets
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";

package envoymobile.extensions.key_value.platform;

import "google/protobuf/duration.proto";

import "validate/validate.proto";

message PlatformKeyValueStoreConfig {
  // The key to save the contents to.
  string key = 1 [(validate.rules).string = {min_len: 1}];

  // The interval at which the key value store should be saved.
  google.protobuf.Duration save_interval = 2;

  // The maximum number of entries that can be stored in the cache.
  uint64 max_entries = 3;
}
#pragma once

#include "envoy/common/key_value_store.h"
#include "envoy/registry/registry.h"

#include "source/common/common/key_value_store_base.h"

#include "library/common/extensions/key_value/platform/platform.pb.h"
#include "library/common/extensions/key_value/platform/platform.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace KeyValue {

class PlatformInterface {
public:
  virtual ~PlatformInterface() {}
  // Save the contents to the key provided. This may be done asynchronously.
  virtual void save(const std::string& key, const std::string& contents) PURE;
  // Read the contents of the key provided.
  virtual std::string read(const std::string& key) const PURE;
};

// A platform file based key value store, which reads from and saves from based on
// a key. An example implementation would be flushing to the android prefs file.
//
// All keys and values are flushed to a single entry as
// [length]\n[key][length]\n[value]
class PlatformKeyValueStore : public KeyValueStoreBase {
public:
  PlatformKeyValueStore(Event::Dispatcher& dispatcher, std::chrono::milliseconds save_interval,
                        PlatformInterface& platform_interface, uint64_t max_entries,
                        const std::string& key);
  // KeyValueStore
  void flush() override;

private:
  PlatformInterface& platform_interface_;
  const std::string key_;
};

class PlatformKeyValueStoreFactory : public KeyValueStoreFactory {
public:
  PlatformKeyValueStoreFactory() = default;

  // KeyValueStoreFactory
  KeyValueStorePtr createStore(const Protobuf::Message& config,
                               ProtobufMessage::ValidationVisitor& validation_visitor,
                               Event::Dispatcher& dispatcher,
                               Filesystem::Instance& file_system) override;

  // TypedFactory
  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<
        envoymobile::extensions::key_value::platform::PlatformKeyValueStoreConfig>();
  }

  std::string name() const override { return "envoy.key_value.platform"; }
};

DECLARE_FACTORY(PlatformKeyValueStoreFactory);

} // namespace KeyValue
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "library/common/types/c_types.h"

// NOLINT(namespace-envoy)

#ifdef __cplusplus
extern "C" { // function pointers
#endif

/**
 * Function signature for reading value from implementation.
 */
typedef envoy_data (*envoy_kv_store_read_f)(envoy_data key, const void* context);

/**
 * Function signature for saving value to implementation.
 */
typedef void (*envoy_kv_store_save_f)(envoy_data key, envoy_data value, const void* context);

/**
 * Function signature for removing value from implementation.
 */
typedef void (*envoy_kv_store_remove_f)(envoy_data key, const void* context);

#ifdef __cplusplus
} // function pointers
#endif

typedef struct {
  envoy_kv_store_read_f read;
  envoy_kv_store_save_f save;
  envoy_kv_store_remove_f remove;
  const void* context;
} envoy_kv_store;
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_extension",
    "envoy_extension_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_extension_package()

envoy_proto_library(
    name = "platform",
    srcs = ["platform.proto"],
)

envoy_cc_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = [
        "c_types.h",
        "config.h",
    ],
    repository = "@envoy",
    deps = [
        ":platform_cc_proto",
        "//library/common/api:external_api_lib",
        "//library/common/data:utility_lib",
        "@envoy//envoy/common:key_value_store_interface",
        "@envoy//envoy/event:dispatcher_interface",
        "@envoy//envoy/filesystem:filesystem_interface",
        "@envoy//envoy/registry",
        "@envoy//source/common/common:key_value_store_lib",
        "@envoy_api//envoy/config/common/key_value/v3:pkg_cc_proto",
    ],
)
#include "library/common/extensions/key_value/platform/config.h"

#include "envoy/config/common/key_value/v3/config.pb.h"
#include "envoy/config/common/key_value/v3/config.pb.validate.h"

#include "library/common/api/external.h"
#include "library/common/data/utility.h"
#include "library/common/extensions/key_value/platform/c_types.h"

namespace Envoy {
namespace Extensions {
namespace KeyValue {

namespace {

constexpr absl::string_view PlatformStoreName{"reserved.platform_store"};

class PlatformInterfaceImpl : public PlatformInterface,
                              public Logger::Loggable<Logger::Id::filter> {
public:
  PlatformInterfaceImpl()
      : bridged_store_(*static_cast<envoy_kv_store*>(
            Api::External::retrieveApi(std::string(PlatformStoreName)))) {}

  ~PlatformInterfaceImpl() override {}

  std::string read(const std::string& key) const override {
    envoy_data bridged_key = Data::Utility::copyToBridgeData(key);
    envoy_data bridged_value = bridged_store_.read(bridged_key, bridged_store_.context);
    std::string result = Data::Utility::copyToString(bridged_value);
    release_envoy_data(bridged_value);
    return result;
  }

  void save(const std::string& key, const std::string& contents) override {
    envoy_data bridged_key = Data::Utility::copyToBridgeData(key);
    envoy_data bridged_value = Data::Utility::copyToBridgeData(contents);
    bridged_store_.save(bridged_key, bridged_value, bridged_store_.context);
  }

private:
  envoy_kv_store& bridged_store_;
};

PlatformInterfaceImpl& getPlatformInterfaceImplSingleton() {
  static PlatformInterfaceImpl impl = PlatformInterfaceImpl();
  return impl;
}

} // namespace

PlatformKeyValueStore::PlatformKeyValueStore(Event::Dispatcher& dispatcher,
                                             std::chrono::milliseconds save_interval,
                                             PlatformInterface& platform_interface,
                                             uint64_t max_entries, const std::string& key)
    : KeyValueStoreBase(dispatcher, save_interval, max_entries),
      platform_interface_(platform_interface), key_(key) {
  const std::string contents = platform_interface_.read(key);
  if (!parseContents(contents)) {
    ENVOY_LOG(warn, "Failed to parse key value store contents {}", key);
  }
}

void PlatformKeyValueStore::flush() {
  std::string output;
  for (const auto& [key, value_with_ttl] : store()) {
    std::string string_value = value_with_ttl.value_;
    absl::StrAppend(&output, key.length(), "\n", key, string_value.length(), "\n", string_value);
  }
  platform_interface_.save(key_, output);
}

KeyValueStorePtr
PlatformKeyValueStoreFactory::createStore(const Protobuf::Message& config,
                                          ProtobufMessage::ValidationVisitor& validation_visitor,
                                          Event::Dispatcher& dispatcher, Filesystem::Instance&) {
  const auto& typed_config = MessageUtil::downcastAndValidate<
      const ::envoy::config::common::key_value::v3::KeyValueStoreConfig&>(config,
                                                                          validation_visitor);
  const auto platform_kv_store_config = MessageUtil::anyConvertAndValidate<
      envoymobile::extensions::key_value::platform::PlatformKeyValueStoreConfig>(
      typed_config.config().typed_config(), validation_visitor);
  auto milliseconds = std::chrono::milliseconds(
      DurationUtil::durationToMilliseconds(platform_kv_store_config.save_interval()));
  return std::make_unique<PlatformKeyValueStore>(
      dispatcher, milliseconds, getPlatformInterfaceImplSingleton(),
      platform_kv_store_config.max_entries(), platform_kv_store_config.key());
}

REGISTER_FACTORY(PlatformKeyValueStoreFactory, KeyValueStoreFactory);

} // namespace KeyValue
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/event/timer.h"
#include "envoy/server/instance.h"

#include "source/common/event/real_time_system.h"
#include "source/exe/platform_impl.h"
#include "source/exe/stripped_main_base.h"
#include "source/server/listener_hooks.h"
#include "source/server/options_impl_base.h"

#ifdef ENVOY_HANDLE_SIGNALS
#include "source/common/signal/signal_action.h"
#include "source/exe/terminate_handler.h"
#endif

namespace Envoy {

/**
 * This class is used instead of Envoy::MainCommon to customize logic for the Envoy Mobile setting.
 * It largely leverages Envoy::StrippedMainBase.
 */
class EngineCommon {
public:
  EngineCommon(std::unique_ptr<Envoy::OptionsImplBase>&& options);
  bool run() {
    base_->runServer();
    return true;
  }

  /**
   * @return a pointer to the server instance, or nullptr if initialized into
   *         validation mode.
   */
  Server::Instance* server() { return base_->server(); }

private:
#ifdef ENVOY_HANDLE_SIGNALS
  // TODO(junr03): build a derived Event::SignalAction that uses the Envoy Logger as the ostream.
  // https://github.com/envoyproxy/envoy-mobile/issues/1497.
  Envoy::SignalAction handle_sigs_;
  Envoy::TerminateHandler log_on_terminate_;
#endif
  std::unique_ptr<Envoy::OptionsImplBase> options_;
  Event::RealTimeSystem real_time_system_; // NO_CHECK_FORMAT(real_time)
  DefaultListenerHooks default_listener_hooks_;
  ProdComponentFactory prod_component_factory_;
  std::unique_ptr<StrippedMainBase> base_;
};

} // namespace Envoy
#pragma once

#include <memory>
#include <vector>

#include "envoy/common/pure.h"

#include "absl/strings/string_view.h"
#include "library/common/extensions/cert_validator/platform_bridge/c_types.h"

namespace Envoy {

namespace test {
class SystemHelperPeer;
} // namespace test

/**
 * SystemHelper provided a platform-agnostic API for interacting with platform-specific
 * system APIs. The singleton helper is accessible via the `getInstance()` static
 * method. Tests may override this singleton via `test::SystemHelperPeer` class.
 */
class SystemHelper {
public:
  virtual ~SystemHelper() = default;

  /**
   * @return true if the system permits cleartext requests.
   */
  virtual bool isCleartextPermitted(absl::string_view hostname) PURE;

  /**
   * Invokes platform APIs to validate certificates.
   */
  virtual envoy_cert_validation_result
  validateCertificateChain(const std::vector<std::string>& certs, absl::string_view hostname) PURE;

  /**
   * Invokes platform APIs to clean up after validation is complete.
   */
  virtual void cleanupAfterCertificateValidation() PURE;

  /**
   * @return a reference to the current SystemHelper instance.
   */
  static SystemHelper& getInstance();

private:
  friend class test::SystemHelperPeer;

  static std::unique_ptr<SystemHelper> instance_;
};

} // namespace Envoy
#pragma once

#include "library/common/common/system_helper.h"

namespace Envoy {

/**
 * Default implementation of SystemHelper which invokes the appropriate
 * platform-specific system APIs.
 */
class DefaultSystemHelper : public SystemHelper {
public:
  ~DefaultSystemHelper() override = default;

  // SystemHelper:
  bool isCleartextPermitted(absl::string_view hostname) override;
  envoy_cert_validation_result validateCertificateChain(const std::vector<std::string>& certs,
                                                        absl::string_view hostname) override;
  void cleanupAfterCertificateValidation() override;
};

} // namespace Envoy
#include "library/common/common/default_system_helper.h"
#include "library/common/jni/android_jni_utility.h"
#include "library/common/jni/android_network_utility.h"

namespace Envoy {

bool DefaultSystemHelper::isCleartextPermitted(absl::string_view hostname) {
  return JNI::isCleartextPermitted(hostname);
}

envoy_cert_validation_result
DefaultSystemHelper::validateCertificateChain(const std::vector<std::string>& certs,
                                              absl::string_view hostname) {
  return JNI::verifyX509CertChain(certs, hostname);
}

void DefaultSystemHelper::cleanupAfterCertificateValidation() { JNI::jvmDetachThread(); }

} // namespace Envoy
#pragma once

#include <iostream>
#include <string>

#include "source/common/common/logger.h"

#include "absl/strings/string_view.h"
#include "library/common/api/external.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Logger {

class EventTrackingDelegate : public SinkDelegate {
public:
  explicit EventTrackingDelegate(DelegatingLogSinkSharedPtr log_sink)
      : SinkDelegate(log_sink), event_tracker_(*static_cast<envoy_event_tracker*>(
                                    Api::External::retrieveApi(envoy_event_tracker_api_name))) {}

  void logWithStableName(absl::string_view stable_name, absl::string_view level,
                         absl::string_view component, absl::string_view msg) override;

private:
  envoy_event_tracker& event_tracker_;
};

using EventTrackingDelegatePtr = std::unique_ptr<EventTrackingDelegate>;
class LambdaDelegate : public EventTrackingDelegate {
public:
  LambdaDelegate(envoy_logger logger, DelegatingLogSinkSharedPtr log_sink);
  ~LambdaDelegate() override;

  // SinkDelegate
  void log(absl::string_view msg, const spdlog::details::log_msg& log_msg) override;
  // Currently unexposed. May be desired in the future.
  void flush() override{};

private:
  envoy_logger logger_;
};

// A default log delegate that logs to stderr, mimicking the default used by Envoy
// when no logger has been installed. Using this default delegate allows us to
// intercept the named log lines (used for analytic events) even if no platform
// logger has been installed.
class DefaultDelegate : public EventTrackingDelegate {
public:
  DefaultDelegate(absl::Mutex& mutex, DelegatingLogSinkSharedPtr log_sink);
  ~DefaultDelegate() override;

  // SinkDelegate
  void log(absl::string_view msg, const spdlog::details::log_msg&) override {
    absl::MutexLock l(&mutex_);
    std::cerr << msg;
  }
  void flush() override {
    absl::MutexLock l(&mutex_);
    std::cerr << std::flush;
  };

private:
  absl::Mutex& mutex_;
};

} // namespace Logger
} // namespace Envoy
load("@bazel_skylib//lib:selects.bzl", "selects")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

selects.config_setting_group(
    name = "use_android_system_helper",
    match_any = [
        "@envoy//bazel:android_system_helper",
        "@envoy//bazel:android",
    ],
)

envoy_cc_library(
    name = "system_helper_lib",
    srcs = [
        "system_helper.cc",
    ],
    hdrs = [
        "system_helper.h",
    ],
    copts = select({
        ":use_android_system_helper": ["-DUSE_ANDROID_SYSTEM_HELPER"],
        "//conditions:default": [],
    }),
    repository = "@envoy",
    deps = [
        ":default_system_helper_lib",
        "//library/common/extensions/cert_validator/platform_bridge:c_types_lib",
    ] + select({
        ":use_android_system_helper": [
            "//library/common/jni:android_jni_utility_lib",
            "//library/common/jni:android_network_utility_lib",
        ],
        "//conditions:default": [],
    }) + select({
        "@envoy//bazel:apple": [
            "//library/common/network:apple_platform_cert_verifier",
        ],
        "//conditions:default": [],
    }),
)

# Ideally, Bazel select() would choose the appropriate implementation to use.
# It would use the Android implementation on Android, or when the config
# android_system_helper is set. Otherwise, it would use the Apple implementation
# on Apple platforms, or the default otherwise. However, Bazel select() doesn't
# have a good way to express this. Instead, system_helper.cc uses "#if defined"
# and "#include" to select the correct implementation.
envoy_cc_library(
    name = "default_system_helper_lib",
    srcs = [],
    hdrs = [
        "default_system_helper.cc",
        "default_system_helper.h",
        "default_system_helper_android.cc",
        "default_system_helper_apple.cc",
    ],
    repository = "@envoy",
    deps = [],
)

envoy_cc_library(
    name = "lambda_logger_delegate_lib",
    srcs = ["lambda_logger_delegate.cc"],
    hdrs = ["lambda_logger_delegate.h"],
    repository = "@envoy",
    deps = [
        "//library/common/api:external_api_lib",
        "//library/common/bridge:utility_lib",
        "//library/common/data:utility_lib",
        "//library/common/types:c_types_lib",
        "@envoy//source/common/common:macros",
        "@envoy//source/common/common:minimal_logger_lib",
    ],
)
#include "library/common/common/system_helper.h"

#include "library/common/common/default_system_helper.h"

#if defined(USE_ANDROID_SYSTEM_HELPER)
#include "library/common/common/default_system_helper_android.cc"
#elif defined(__APPLE__)
#include "library/common/common/default_system_helper_apple.cc"
#else
#include "library/common/common/default_system_helper.cc"
#endif

namespace Envoy {

std::unique_ptr<SystemHelper> SystemHelper::instance_ = std::make_unique<DefaultSystemHelper>();

SystemHelper& SystemHelper::getInstance() { return *instance_; }

} // namespace Envoy
#include "library/common/common/lambda_logger_delegate.h"

#include <iostream>

#include "library/common/bridge/utility.h"
#include "library/common/data/utility.h"

namespace Envoy {
namespace Logger {

void EventTrackingDelegate::logWithStableName(absl::string_view stable_name, absl::string_view,
                                              absl::string_view, absl::string_view msg) {
  if (event_tracker_.track == nullptr) {
    return;
  }

  event_tracker_.track(Bridge::Utility::makeEnvoyMap({{"name", "event_log"},
                                                      {"log_name", std::string(stable_name)},
                                                      {"message", std::string(msg)}}),
                       event_tracker_.context);
}

LambdaDelegate::LambdaDelegate(envoy_logger logger, DelegatingLogSinkSharedPtr log_sink)
    : EventTrackingDelegate(log_sink), logger_(logger) {
  setDelegate();
}

LambdaDelegate::~LambdaDelegate() {
  restoreDelegate();
  logger_.release(logger_.context);
}

void LambdaDelegate::log(absl::string_view msg, const spdlog::details::log_msg&) {
  logger_.log(Data::Utility::copyToBridgeData(msg), logger_.context);
}

DefaultDelegate::DefaultDelegate(absl::Mutex& mutex, DelegatingLogSinkSharedPtr log_sink)
    : EventTrackingDelegate(log_sink), mutex_(mutex) {
  setDelegate();
}

DefaultDelegate::~DefaultDelegate() { restoreDelegate(); }

} // namespace Logger
} // namespace Envoy
#include "library/common/common/default_system_helper.h"
#include "library/common/network/apple_platform_cert_verifier.h"

namespace Envoy {

bool DefaultSystemHelper::isCleartextPermitted(absl::string_view /*hostname*/) { return true; }

envoy_cert_validation_result
DefaultSystemHelper::validateCertificateChain(const std::vector<std::string>& certs,
                                              absl::string_view hostname) {
  return verify_cert(certs, hostname);
}

void DefaultSystemHelper::cleanupAfterCertificateValidation() {}

} // namespace Envoy
#include "library/common/common/default_system_helper.h"

namespace Envoy {

bool DefaultSystemHelper::isCleartextPermitted(absl::string_view /*hostname*/) { return true; }

envoy_cert_validation_result
DefaultSystemHelper::validateCertificateChain(const std::vector<std::string>& /*certs*/,
                                              absl::string_view /*hostname*/) {
  envoy_cert_validation_result result;
  result.result = ENVOY_FAILURE;
  result.tls_alert = 80; // internal error
  result.error_details = "Certificate verification not implemented.";
  return result;
}

void DefaultSystemHelper::cleanupAfterCertificateValidation() {}

} // namespace Envoy
#pragma once

#include "envoy/buffer/buffer.h"
#include "envoy/common/random_generator.h"
#include "envoy/common/scope_tracker.h"
#include "envoy/event/deferred_deletable.h"
#include "envoy/http/api_listener.h"
#include "envoy/http/codec.h"
#include "envoy/http/header_map.h"
#include "envoy/stats/histogram.h"
#include "envoy/stats/stats_macros.h"

#include "source/common/buffer/watermark_buffer.h"
#include "source/common/common/logger.h"
#include "source/common/http/codec_helper.h"
#include "source/common/network/socket_impl.h"
#include "source/common/stats/timespan_impl.h"

#include "absl/container/flat_hash_map.h"
#include "absl/types/optional.h"
#include "library/common/event/provisional_dispatcher.h"
#include "library/common/network/synthetic_address_impl.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Http {

/**
 * All http client stats. @see stats_macros.h
 */
#define ALL_HTTP_CLIENT_STATS(COUNTER, HISTOGRAM)                                                  \
  COUNTER(stream_success)                                                                          \
  COUNTER(stream_failure)                                                                          \
  COUNTER(stream_cancel)                                                                           \
  HISTOGRAM(on_headers_callback_latency, Milliseconds)                                             \
  HISTOGRAM(on_data_callback_latency, Milliseconds)                                                \
  HISTOGRAM(on_trailers_callback_latency, Milliseconds)                                            \
  HISTOGRAM(on_complete_callback_latency, Milliseconds)                                            \
  HISTOGRAM(on_cancel_callback_latency, Milliseconds)                                              \
  HISTOGRAM(on_error_callback_latency, Milliseconds)

/**
 * Struct definition for client stats. @see stats_macros.h
 */
struct HttpClientStats {
  ALL_HTTP_CLIENT_STATS(GENERATE_COUNTER_STRUCT, GENERATE_HISTOGRAM_STRUCT)
};

/**
 * Manages HTTP streams, and provides an interface to interact with them.
 */
class Client : public Logger::Loggable<Logger::Id::http> {
public:
  Client(ApiListenerPtr&& api_listener, Event::ProvisionalDispatcher& dispatcher,
         Stats::Scope& scope, Random::RandomGenerator& random)
      : api_listener_(std::move(api_listener)), dispatcher_(dispatcher),
        stats_(
            HttpClientStats{ALL_HTTP_CLIENT_STATS(POOL_COUNTER_PREFIX(scope, "http.client."),
                                                  POOL_HISTOGRAM_PREFIX(scope, "http.client."))}),
        address_provider_(std::make_shared<Network::Address::SyntheticAddressImpl>(), nullptr),
        random_(random) {}

  /**
   * Attempts to open a new stream to the remote. Note that this function is asynchronous and
   * opening a stream may fail. The returned handle is immediately valid for use with this API, but
   * there is no guarantee it will ever functionally represent an open stream.
   * @param stream, the stream to start.
   * @param bridge_callbacks, wrapper for callbacks for events on this stream.
   * @param explicit_flow_control, whether the stream will require explicit flow control.
   */
  void startStream(envoy_stream_t stream, envoy_http_callbacks bridge_callbacks,
                   bool explicit_flow_control);

  /**
   * Send headers over an open HTTP stream. This method can be invoked once and needs to be called
   * before send_data.
   * @param stream, the stream to send headers over.
   * @param headers, the headers to send.
   * @param end_stream, indicates whether to close the stream locally after sending this frame.
   */
  void sendHeaders(envoy_stream_t stream, envoy_headers headers, bool end_stream);

  /**
   * Notify the stream that the caller is ready to receive more data from the response stream. Only
   * used in explicit flow control mode.
   * @param bytes_to_read, the quantity of data the caller is prepared to process.
   */
  void readData(envoy_stream_t stream, size_t bytes_to_read);

  /**
   * Send data over an open HTTP stream. This method can be invoked multiple times.
   * @param stream, the stream to send data over.
   * @param data, the data to send.
   * @param end_stream, indicates whether to close the stream locally after sending this frame.
   */
  void sendData(envoy_stream_t stream, envoy_data data, bool end_stream);

  /**
   * Send metadata over an HTTP stream. This method can be invoked multiple times.
   * @param stream, the stream to send metadata over.
   * @param metadata, the metadata to send.
   */
  void sendMetadata(envoy_stream_t stream, envoy_headers metadata);

  /**
   * Send trailers over an open HTTP stream. This method can only be invoked once per stream.
   * Note that this method implicitly closes the stream locally.
   * @param stream, the stream to send trailers over.
   * @param trailers, the trailers to send.
   */
  void sendTrailers(envoy_stream_t stream, envoy_headers trailers);

  /**
   * Reset an open HTTP stream. This operation closes the stream locally, and remote.
   * No further operations are valid on the stream.
   * @param stream, the stream to reset.
   */
  void cancelStream(envoy_stream_t stream);

  const HttpClientStats& stats() const;
  Event::ScopeTracker& scopeTracker() const { return dispatcher_; }

  TimeSource& timeSource() { return dispatcher_.timeSource(); }

  // Used to fill response code details for streams that are cancelled via cancelStream.
  const std::string& getCancelDetails() {
    CONSTRUCT_ON_FIRST_USE(std::string, "client_cancelled_stream");
  }

  void shutdownApiListener() { api_listener_.reset(); }

private:
  class DirectStream;
  friend class ClientTest;
  /**
   * Notifies caller of async HTTP stream status.
   * Note the HTTP stream is full-duplex, even if the local to remote stream has been ended
   * by sendHeaders/sendData with end_stream=true, sendTrailers, or locallyCloseStream
   * DirectStreamCallbacks can continue to receive events until the remote to local stream is
   * closed, or resetStream is called.
   */
  class DirectStreamCallbacks : public ResponseEncoder, public Logger::Loggable<Logger::Id::http> {
  public:
    DirectStreamCallbacks(DirectStream& direct_stream, envoy_http_callbacks bridge_callbacks,
                          Client& http_client);
    virtual ~DirectStreamCallbacks();

    void closeStream(bool end_stream = true);
    void onComplete();
    void onCancel();
    void onError();
    void onSendWindowAvailable();

    // ResponseEncoder
    void encodeHeaders(const ResponseHeaderMap& headers, bool end_stream) override;
    void encodeData(Buffer::Instance& data, bool end_stream) override;
    void encodeTrailers(const ResponseTrailerMap& trailers) override;
    Stream& getStream() override { return direct_stream_; }
    Http1StreamEncoderOptionsOptRef http1StreamEncoderOptions() override { return absl::nullopt; }
    void encode1xxHeaders(const ResponseHeaderMap&) override {
      // TODO(goaway): implement?
      PANIC("not implemented");
    }
    bool streamErrorOnInvalidHttpMessage() const override { return false; }
    void setRequestDecoder(RequestDecoder& /*decoder*/) override{};
    void setDeferredLoggingHeadersAndTrailers(Http::RequestHeaderMapConstSharedPtr,
                                              Http::ResponseHeaderMapConstSharedPtr,
                                              Http::ResponseTrailerMapConstSharedPtr,
                                              StreamInfo::StreamInfo&) override {}

    void encodeMetadata(const MetadataMapVector&) override { PANIC("not implemented"); }

    void onHasBufferedData();
    void onBufferedDataDrained();

    // To be called by mobile library when in explicit flow control mode and more data is wanted.
    // If bytes are available, the bytes available (up to the limit of
    // bytes_to_send) will be shipped the bridge immediately.
    //
    // If no bytes are available, the next time data is received from the
    // network, up to bytes_to_send bytes will be shipped to the bridge.
    //
    // Bytes will only be sent up once, even if the bytes available are fewer
    // than bytes_to_send.
    void resumeData(size_t bytes_to_send);

    void latchError();

  private:
    bool hasBufferedData() { return response_data_.get() && response_data_->length() != 0; }

    void sendDataToBridge(Buffer::Instance& data, bool end_stream);
    void sendTrailersToBridge(const ResponseTrailerMap& trailers);
    void sendErrorToBridge();
    envoy_stream_intel streamIntel();
    envoy_final_stream_intel& finalStreamIntel();

    DirectStream& direct_stream_;
    const envoy_http_callbacks bridge_callbacks_;
    Client& http_client_;
    absl::optional<envoy_error> error_;
    bool success_{};

    // Buffered response data when in explicit flow control mode.
    Buffer::InstancePtr response_data_;
    ResponseTrailerMapPtr response_trailers_;
    // True if the bridge should operate in explicit flow control mode, and only send
    // data when it is requested by the caller.
    bool explicit_flow_control_{};
    // Set true when the response headers have been forwarded to the bridge.
    bool response_headers_forwarded_{};
    // Called in closeStream() to communicate that the end of the stream has
    // been received by the DirectStreamCallbacks.
    bool remote_end_stream_received_{};
    // Set true when the end stream has been forwarded to the bridge.
    bool remote_end_stream_forwarded_{};
    size_t bytes_to_send_{};
  };

  using DirectStreamCallbacksPtr = std::unique_ptr<DirectStreamCallbacks>;

  /**
   * Contains state about an HTTP stream; both in the outgoing direction via an underlying
   * AsyncClient::Stream and in the incoming direction via DirectStreamCallbacks.
   */
  class DirectStream : public Stream,
                       public StreamCallbackHelper,
                       public ScopeTrackedObject,
                       public Logger::Loggable<Logger::Id::http> {
  public:
    DirectStream(envoy_stream_t stream_handle, Client& http_client);
    ~DirectStream();

    // Stream
    void addCallbacks(StreamCallbacks& callbacks) override { addCallbacksHelper(callbacks); }
    void removeCallbacks(StreamCallbacks& callbacks) override { removeCallbacksHelper(callbacks); }
    CodecEventCallbacks* registerCodecEventCallbacks(CodecEventCallbacks* codec_callbacks) override;

    void resetStream(StreamResetReason) override;
    Network::ConnectionInfoProvider& connectionInfoProvider() override {
      return parent_.address_provider_;
    }
    absl::string_view responseDetails() override { return response_details_; }
    // This is called any time upstream buffers exceed the configured flow
    // control limit, to attempt halt the flow of data from the mobile client
    // or to resume the flow of data when buffers have been drained.
    //
    // It only has an effect in explicit flow control mode, where when all buffers are drained,
    // on_send_window_available callbacks are called.
    void readDisable(bool disable) override;
    uint32_t bufferLimit() const override {
      // 1Mb
      return 1024000;
    }
    // Not applicable
    void setAccount(Buffer::BufferMemoryAccountSharedPtr) override {
      // Acounting became default in https://github.com/envoyproxy/envoy/pull/17702 but is a no=op.
    }
    void setFlushTimeout(std::chrono::milliseconds) override {}

    Buffer::BufferMemoryAccountSharedPtr account() const override { return nullptr; }

    const StreamInfo::BytesMeterSharedPtr& bytesMeter() override { return bytes_meter_; }

    // ScopeTrackedObject
    void dumpState(std::ostream& os, int indent_level = 0) const override;

    void setResponseDetails(absl::string_view response_details) {
      response_details_ = response_details;
    }

    // Latches stream information as it may not be available when accessed.
    void saveLatestStreamIntel();

    // Latches latency info from stream info before it goes away.
    void saveFinalStreamIntel();

    // Various signals to propagate to the adapter.
    enum class AdapterSignal { EncodeComplete, Error, Cancel };

    // Used to notify adapter of stream's completion.
    void notifyAdapter(AdapterSignal signal) {
      if (codec_callbacks_) {
        switch (signal) {
        case AdapterSignal::EncodeComplete:
          codec_callbacks_->onCodecEncodeComplete();
          break;
        case AdapterSignal::Error:
          FALLTHRU;
        case AdapterSignal::Cancel:
          codec_callbacks_->onCodecLowLevelReset();
        }
        registerCodecEventCallbacks(nullptr);
      }
    }

    OptRef<RequestDecoder> requestDecoder() {
      if (!request_decoder_) {
        return {};
      }
      ENVOY_BUG(request_decoder_->get(), "attempting to access deleted decoder");
      return request_decoder_->get();
    }

    const envoy_stream_t stream_handle_;

    // Used to issue outgoing HTTP stream operations.
    RequestDecoderHandlePtr request_decoder_;
    // Used to receive incoming HTTP stream operations.
    DirectStreamCallbacksPtr callbacks_;
    Client& parent_;
    // Used to communicate with the HTTP Connection Manager that
    // it can destroy the active stream.
    CodecEventCallbacks* codec_callbacks_{nullptr};
    // Response details used by the connection manager.
    absl::string_view response_details_;
    // Tracks read disable calls. Different buffers can call read disable, and
    // the stack should not consider itself "ready to write" until all
    // read-disable calls have been unwound.
    uint32_t read_disable_count_{};
    // Set true in explicit flow control mode if the library has sent body data and may want to
    // send more when buffer is available.
    bool wants_write_notification_{};
    // True if the bridge should operate in explicit flow control mode.
    //
    // In this mode only one callback can be sent to the bridge until more is
    // asked for. When a response is started this will either allow headers or an
    // error to be sent up. Body, trailers, or further errors will not be sent
    // until resumeData is called. This, combined with standard Envoy flow control push
    // back, avoids excessive buffering of response bodies if the response body is
    // read faster than the mobile caller can process it.
    bool explicit_flow_control_ = false;
    // Latest intel data retrieved from the StreamInfo.
    envoy_stream_intel stream_intel_{-1, -1, 0, 0};
    envoy_final_stream_intel envoy_final_stream_intel_{-1, -1, -1, -1, -1, -1, -1, -1,
                                                       -1, -1, -1, 0,  0,  0,  0,  -1};
    StreamInfo::BytesMeterSharedPtr bytes_meter_;
  };

  using DirectStreamSharedPtr = std::shared_ptr<DirectStream>;

  // Used to deferredDelete the ref count of the DirectStream owned by streams_ while still
  // maintaining a container of DirectStreamSharedPtr. Using deferredDelete is important due to the
  // necessary ordering of ActiveStream deletion w.r.t DirectStream deletion; the former needs to be
  // destroyed first. Using post to defer delete the DirectStream provides no ordering guarantee per
  // envoy/source/common/event/libevent.h Maintaining a container of DirectStreamSharedPtr is
  // important because Client::resetStream is initiated by a platform thread.
  struct DirectStreamWrapper : public Event::DeferredDeletable {
    DirectStreamWrapper(DirectStreamSharedPtr stream) : stream_(stream) {}

  private:
    const DirectStreamSharedPtr stream_;
  };

  using DirectStreamWrapperPtr = std::unique_ptr<DirectStreamWrapper>;

  enum GetStreamFilters {
    // If a stream has been finished from upstream, but stream completion has
    // not yet been communicated, the downstream mobile library should not be
    // allowed to access the stream. getStream takes an argument to ensure that
    // the mobile client won't do things like send further request data for
    // streams in this state.
    ALLOW_ONLY_FOR_OPEN_STREAMS,
    // If a stream has been finished from upstream, make sure that getStream
    // will continue to work for functions such as resumeData (pushing that data
    // to the mobile library) and cancelStream (the client not wanting further
    // data for the stream).
    ALLOW_FOR_ALL_STREAMS,
  };
  DirectStreamSharedPtr getStream(envoy_stream_t stream_handle, GetStreamFilters filters);
  void removeStream(envoy_stream_t stream_handle);
  void setDestinationCluster(RequestHeaderMap& headers);

  ApiListenerPtr api_listener_;
  Event::ProvisionalDispatcher& dispatcher_;
  Event::SchedulableCallbackPtr scheduled_callback_;
  HttpClientStats stats_;
  // The set of open streams, which can safely have request data sent on them
  // or response data received.
  absl::flat_hash_map<envoy_stream_t, DirectStreamSharedPtr> streams_;
  // The set of closed streams, where end stream has been received from upstream
  // but not yet communicated to the mobile library.
  absl::flat_hash_map<envoy_stream_t, DirectStreamSharedPtr> closed_streams_;
  // Shared synthetic address providers across DirectStreams.
  Network::ConnectionInfoSetterImpl address_provider_;
  Random::RandomGenerator& random_;
};

using ClientPtr = std::unique_ptr<Client>;

} // namespace Http
} // namespace Envoy
#include "library/common/http/header_utility.h"

#include "source/common/http/header_map_impl.h"
#include "source/extensions/http/header_formatters/preserve_case/preserve_case_formatter.h"

#include "library/common/data/utility.h"

namespace Envoy {
namespace Http {
namespace Utility {

Http::LocalErrorStatus statusForOnLocalReply(const StreamDecoderFilter::LocalReplyData& reply,
                                             const StreamInfo::StreamInfo& info) {
  // This is a horrible hack to work around legacy swift direct response API.
  // TODO(https://github.com/envoyproxy/envoy/issues/24428) remove.
  if (reply.details_ == "direct_response" && info.getRequestHeaders() &&
      info.getRequestHeaders()->getHostValue() == "127.0.0.1") {
    return Http::LocalErrorStatus::Continue;
  }
  return Http::LocalErrorStatus::ContinueAndResetStream;
}

void toEnvoyHeaders(HeaderMap& envoy_result_headers, envoy_headers headers) {
  Envoy::Http::StatefulHeaderKeyFormatter& formatter = envoy_result_headers.formatter().value();
  for (envoy_map_size_t i = 0; i < headers.length; i++) {
    std::string key = Data::Utility::copyToString(headers.entries[i].key);
    // Make sure the formatter knows the original case.
    formatter.processKey(key);
    envoy_result_headers.addCopy(LowerCaseString(key),
                                 Data::Utility::copyToString(headers.entries[i].value));
  }
  // The C envoy_headers struct can be released now because the headers have been copied.
  release_envoy_headers(headers);
}

RequestHeaderMapPtr toRequestHeaders(envoy_headers headers) {
  auto transformed_headers = RequestHeaderMapImpl::create();
  transformed_headers->setFormatter(
      std::make_unique<
          Extensions::Http::HeaderFormatters::PreserveCase::PreserveCaseHeaderFormatter>(
          false, envoy::extensions::http::header_formatters::preserve_case::v3::
                     PreserveCaseFormatterConfig::DEFAULT));
  toEnvoyHeaders(*transformed_headers, headers);
  return transformed_headers;
}

RequestTrailerMapPtr toRequestTrailers(envoy_headers trailers) {
  RequestTrailerMapPtr transformed_trailers = RequestTrailerMapImpl::create();
  for (envoy_map_size_t i = 0; i < trailers.length; i++) {
    transformed_trailers->addCopy(
        LowerCaseString(Data::Utility::copyToString(trailers.entries[i].key)),
        Data::Utility::copyToString(trailers.entries[i].value));
  }
  // The C envoy_headers struct can be released now because the headers have been copied.
  release_envoy_headers(trailers);
  return transformed_trailers;
}

envoy_headers toBridgeHeaders(const HeaderMap& header_map, absl::string_view alpn) {
  int alpn_entry = alpn.empty() ? 0 : 1;
  envoy_map_entry* headers = static_cast<envoy_map_entry*>(
      safe_malloc(sizeof(envoy_map_entry) * (header_map.size() + alpn_entry)));
  envoy_headers transformed_headers;
  transformed_headers.length = 0;
  transformed_headers.entries = headers;

  header_map.iterate(
      [&transformed_headers, &header_map](const HeaderEntry& header) -> HeaderMap::Iterate {
        std::string key_val = std::string(header.key().getStringView());
        if (header_map.formatter().has_value()) {
          const Envoy::Http::StatefulHeaderKeyFormatter& formatter = header_map.formatter().value();
          key_val = formatter.format(key_val);
        }
        envoy_data key = Data::Utility::copyToBridgeData(key_val);
        envoy_data value = Data::Utility::copyToBridgeData(header.value().getStringView());

        transformed_headers.entries[transformed_headers.length] = {key, value};
        transformed_headers.length++;

        return HeaderMap::Iterate::Continue;
      });
  if (!alpn.empty()) {
    envoy_data key = Data::Utility::copyToBridgeData("x-envoy-upstream-alpn");
    envoy_data value = Data::Utility::copyToBridgeData(alpn);
    transformed_headers.entries[transformed_headers.length] = {key, value};
    transformed_headers.length++;
  }
  return transformed_headers;
}

} // namespace Utility
} // namespace Http
} // namespace Envoy
#pragma once

#include "envoy/http/header_map.h"

namespace Envoy {
namespace Http {

/**
 * Constant HTTP headers used internally for in-band signalling in the request/response path.
 */
class InternalHeaderValues {
public:
  const LowerCaseString ErrorCode{"x-internal-error-code"};
  const LowerCaseString ErrorMessage{"x-internal-error-message"};
};

using InternalHeaders = ConstSingleton<InternalHeaderValues>;

} // namespace Http
} // namespace Envoy
#include "library/common/http/client.h"

#include "source/common/common/dump_state_utils.h"
#include "source/common/common/scope_tracker.h"
#include "source/common/http/codes.h"
#include "source/common/http/header_map_impl.h"
#include "source/common/http/headers.h"
#include "source/common/http/utility.h"

#include "library/common/bridge/utility.h"
#include "library/common/common/system_helper.h"
#include "library/common/data/utility.h"
#include "library/common/http/header_utility.h"
#include "library/common/http/headers.h"
#include "library/common/stream_info/extra_stream_info.h"

namespace Envoy {
namespace Http {

/**
 * IMPORTANT: stream closure semantics in envoy mobile depends on the fact that the HCM fires a
 * stream reset when the remote side of the stream is closed but the local side remains open.
 * In other words the HCM (like the rest of Envoy) disallows locally half-open streams.
 * If this changes in Envoy, this file will need to change as well.
 * For implementation details @see Client::DirectStreamCallbacks::closeRemote.
 */

namespace {

constexpr auto SlowCallbackWarningThreshold = std::chrono::seconds(1);

} // namespace

Client::DirectStreamCallbacks::DirectStreamCallbacks(DirectStream& direct_stream,
                                                     envoy_http_callbacks bridge_callbacks,
                                                     Client& http_client)
    : direct_stream_(direct_stream), bridge_callbacks_(bridge_callbacks), http_client_(http_client),
      explicit_flow_control_(direct_stream_.explicit_flow_control_) {}

Client::DirectStreamCallbacks::~DirectStreamCallbacks() {
  if (error_.has_value()) {
    release_envoy_error(error_.value());
  }
}

void Client::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& headers,
                                                  bool end_stream) {
  ScopeTrackerScopeState scope(&direct_stream_, http_client_.scopeTracker());
  ENVOY_LOG(debug, "[S{}] response headers for stream (end_stream={}):\n{}",
            direct_stream_.stream_handle_, end_stream, headers);

  ASSERT(http_client_.getStream(direct_stream_.stream_handle_,
                                GetStreamFilters::ALLOW_FOR_ALL_STREAMS));

  // Capture some metadata before potentially closing the stream.
  absl::string_view alpn = "";
  OptRef<RequestDecoder> request_decoder = direct_stream_.requestDecoder();
  if (request_decoder) {
    direct_stream_.saveLatestStreamIntel();
    const auto& info = request_decoder->streamInfo();
    // Set the initial number of bytes consumed for the non terminal callbacks.
    direct_stream_.stream_intel_.consumed_bytes_from_response =
        info.getUpstreamBytesMeter() ? info.getUpstreamBytesMeter()->headerBytesReceived() : 0;
    // Capture the alpn if available.
    if (info.upstreamInfo() && info.upstreamInfo()->upstreamSslConnection()) {
      alpn = info.upstreamInfo()->upstreamSslConnection()->alpn();
    }
  }

  if (end_stream) {
    closeStream();
  }

  // Track success for later bookkeeping (stream could still be reset).
  uint64_t response_status = Utility::getResponseStatus(headers);
  success_ = CodeUtility::is2xx(response_status);

  ENVOY_LOG(debug, "[S{}] dispatching to platform response headers for stream (end_stream={}):\n{}",
            direct_stream_.stream_handle_, end_stream, headers);

  auto callback_time_ms = std::make_unique<Stats::HistogramCompletableTimespanImpl>(
      http_client_.stats().on_headers_callback_latency_, http_client_.timeSource());

  bridge_callbacks_.on_headers(Utility::toBridgeHeaders(headers, alpn), end_stream, streamIntel(),
                               bridge_callbacks_.context);

  callback_time_ms->complete();
  auto elapsed = callback_time_ms->elapsed();
  if (elapsed > SlowCallbackWarningThreshold) {
    ENVOY_LOG_EVENT(warn, "slow_on_headers_cb", std::to_string(elapsed.count()) + "ms");
  }

  response_headers_forwarded_ = true;
  if (end_stream) {
    onComplete();
  }
}

uint32_t calculateBytesToSend(const Buffer::Instance& data, uint32_t max_bytes) {
  if (max_bytes == 0) {
    return data.length();
  }
  return std::min<uint32_t>(max_bytes, data.length());
}

void Client::DirectStreamCallbacks::encodeData(Buffer::Instance& data, bool end_stream) {
  ScopeTrackerScopeState scope(&direct_stream_, http_client_.scopeTracker());
  ENVOY_LOG(debug, "[S{}] response data for stream (length={} end_stream={})",
            direct_stream_.stream_handle_, data.length(), end_stream);

  ASSERT(http_client_.getStream(direct_stream_.stream_handle_,
                                GetStreamFilters::ALLOW_FOR_ALL_STREAMS));
  direct_stream_.saveLatestStreamIntel();
  if (end_stream) {
    closeStream();
  }

  // The response_data_ is systematically assigned here because resumeData can
  // incur an asynchronous callback to sendDataToBridge.
  if (explicit_flow_control_ && !response_data_) {
    response_data_ = std::make_unique<Buffer::WatermarkBuffer>(
        [this]() -> void { onBufferedDataDrained(); }, [this]() -> void { onHasBufferedData(); },
        []() -> void {});
    // Default to 1M per stream. This is fairly arbitrary and will result in
    // Envoy buffering up to 1M + flow-control-window for HTTP/2 and HTTP/3,
    // and having local data of 1M + kernel-buffer-limit for HTTP/1.1
    response_data_->setWatermarks(1000000);
  }

  // Send data if in default flow control mode, or if resumeData has been called in explicit
  // flow control mode.
  if (bytes_to_send_ > 0 || !explicit_flow_control_) {
    ASSERT(!hasBufferedData());
    sendDataToBridge(data, end_stream);
  }

  // If not all the bytes have been sent up, buffer any remaining data in response_data.
  if (data.length() != 0) {
    ASSERT(explicit_flow_control_);
    ENVOY_LOG(
        debug, "[S{}] buffering {} bytes due to explicit flow control. {} total bytes buffered.",
        direct_stream_.stream_handle_, data.length(), data.length() + response_data_->length());
    response_data_->move(data);
  } else if (error_.has_value()) {
    sendErrorToBridge();
  }
}

void Client::DirectStreamCallbacks::sendDataToBridge(Buffer::Instance& data, bool end_stream) {
  ASSERT(!explicit_flow_control_ || bytes_to_send_ > 0);

  // Cap by bytes_to_send_ if and only if applying explicit flow control.
  uint32_t bytes_to_send = calculateBytesToSend(data, bytes_to_send_);
  // Update the number of bytes consumed by this non terminal callback.
  direct_stream_.stream_intel_.consumed_bytes_from_response += bytes_to_send;
  // Only send end stream if all data is being sent.
  bool send_end_stream = end_stream && (bytes_to_send == data.length());

  ENVOY_LOG(debug,
            "[S{}] dispatching to platform response data for stream (length={} end_stream={})",
            direct_stream_.stream_handle_, bytes_to_send, send_end_stream);

  auto callback_time_ms = std::make_unique<Stats::HistogramCompletableTimespanImpl>(
      http_client_.stats().on_data_callback_latency_, http_client_.timeSource());

  // Make sure that when using explicit flow control this won't send more data until the next call
  // to resumeData. Set before on-data to handle reentrant callbacks.
  bytes_to_send_ = 0;

  bridge_callbacks_.on_data(Data::Utility::toBridgeData(data, bytes_to_send), send_end_stream,
                            streamIntel(), bridge_callbacks_.context);

  callback_time_ms->complete();
  auto elapsed = callback_time_ms->elapsed();
  if (elapsed > SlowCallbackWarningThreshold) {
    ENVOY_LOG_EVENT(warn, "slow_on_data_cb", std::to_string(elapsed.count()) + "ms");
  }

  if (send_end_stream) {
    onComplete();
  }
}

void Client::DirectStreamCallbacks::encodeTrailers(const ResponseTrailerMap& trailers) {
  ScopeTrackerScopeState scope(&direct_stream_, http_client_.scopeTracker());
  ENVOY_LOG(debug, "[S{}] response trailers for stream:\n{}", direct_stream_.stream_handle_,
            trailers);

  ASSERT(http_client_.getStream(direct_stream_.stream_handle_,
                                GetStreamFilters::ALLOW_FOR_ALL_STREAMS));
  direct_stream_.saveLatestStreamIntel();
  closeStream(); // Trailers always indicate the end of the stream.

  // For explicit flow control, don't send data unless prompted.
  if (explicit_flow_control_ && bytes_to_send_ == 0) {
    response_trailers_ = ResponseTrailerMapImpl::create();
    HeaderMapImpl::copyFrom(*response_trailers_, trailers);
    return;
  }

  sendTrailersToBridge(trailers);
}

void Client::DirectStreamCallbacks::sendTrailersToBridge(const ResponseTrailerMap& trailers) {
  ENVOY_LOG(debug, "[S{}] dispatching to platform response trailers for stream:\n{}",
            direct_stream_.stream_handle_, trailers);

  auto callback_time_ms = std::make_unique<Stats::HistogramCompletableTimespanImpl>(
      http_client_.stats().on_trailers_callback_latency_, http_client_.timeSource());

  bridge_callbacks_.on_trailers(Utility::toBridgeHeaders(trailers), streamIntel(),
                                bridge_callbacks_.context);

  callback_time_ms->complete();
  auto elapsed = callback_time_ms->elapsed();
  if (elapsed > SlowCallbackWarningThreshold) {
    ENVOY_LOG_EVENT(warn, "slow_on_trailers_cb", std::to_string(elapsed.count()) + "ms");
  }

  onComplete();
}

void Client::DirectStreamCallbacks::resumeData(size_t bytes_to_send) {
  ASSERT(explicit_flow_control_);
  ASSERT(bytes_to_send > 0);

  bytes_to_send_ = bytes_to_send;

  ENVOY_LOG(debug, "[S{}] received resume data call for {} bytes", direct_stream_.stream_handle_,
            bytes_to_send_);

  // If there is buffered data, send up to bytes_to_send bytes.
  // Make sure to send end stream with data only if
  // 1) it has been received from the peer and
  // 2) there are no trailers
  if (hasBufferedData() ||
      (remote_end_stream_received_ && !remote_end_stream_forwarded_ && !response_trailers_)) {
    sendDataToBridge(*response_data_, remote_end_stream_received_ && !response_trailers_.get());
    bytes_to_send_ = 0;
  }

  // If all buffered data has been sent, send and free up trailers.
  if (!hasBufferedData() && response_trailers_.get() && bytes_to_send_ > 0) {
    sendTrailersToBridge(*response_trailers_);
    response_trailers_.reset();
    bytes_to_send_ = 0;
  }
}

void Client::DirectStreamCallbacks::closeStream(bool end_stream) {
  ENVOY_LOG(debug, "[S{}] close stream end stream {}\n", direct_stream_.stream_handle_, end_stream);
  remote_end_stream_received_ |= end_stream;
  if (end_stream) {
    // Latch stream intel on stream completion, as the stream info will go away.
    // If end_stream is false this is the stream reset case and data is latched
    // in resetStream
    direct_stream_.saveFinalStreamIntel();
  }

  auto& client = direct_stream_.parent_;
  auto stream = client.getStream(direct_stream_.stream_handle_, ALLOW_ONLY_FOR_OPEN_STREAMS);
  ASSERT(stream != nullptr);
  if (stream) {
    ENVOY_LOG(debug, "[S{}] erased stream\n", direct_stream_.stream_handle_);
    client.closed_streams_.emplace(direct_stream_.stream_handle_, std::move(stream));
    size_t erased = client.streams_.erase(direct_stream_.stream_handle_);
    ASSERT(erased == 1, "closeStream should always remove one entry from the streams map");
  }
  direct_stream_.request_decoder_ = nullptr;
}

void Client::DirectStreamCallbacks::onComplete() {
  direct_stream_.notifyAdapter(DirectStream::AdapterSignal::EncodeComplete);
  http_client_.removeStream(direct_stream_.stream_handle_);
  remote_end_stream_forwarded_ = true;
  ENVOY_LOG(debug, "[S{}] complete stream (success={})", direct_stream_.stream_handle_, success_);
  if (success_) {
    http_client_.stats().stream_success_.inc();
  } else {
    http_client_.stats().stream_failure_.inc();
  }

  auto callback_time_ms = std::make_unique<Stats::HistogramCompletableTimespanImpl>(
      http_client_.stats().on_complete_callback_latency_, http_client_.timeSource());

  bridge_callbacks_.on_complete(streamIntel(), finalStreamIntel(), bridge_callbacks_.context);

  callback_time_ms->complete();
  auto elapsed = callback_time_ms->elapsed();
  if (elapsed > SlowCallbackWarningThreshold) {
    ENVOY_LOG_EVENT(warn, "slow_on_complete_cb", std::to_string(elapsed.count()) + "ms");
  }
}

void Client::DirectStreamCallbacks::onError() {
  direct_stream_.notifyAdapter(DirectStream::AdapterSignal::Error);
  ScopeTrackerScopeState scope(&direct_stream_, http_client_.scopeTracker());
  ENVOY_LOG(debug, "[S{}] remote reset stream", direct_stream_.stream_handle_);

  // When using explicit flow control, if any response data has been sent (e.g. headers), response
  // errors must be deferred until after resumeData has been called.
  // TODO(goaway): What is the expected behavior when an error is received, held, and then another
  // error occurs (e.g., timeout)?

  if (explicit_flow_control_ && response_headers_forwarded_ && bytes_to_send_ == 0) {
    ENVOY_LOG(debug, "[S{}] defering remote reset stream due to explicit flow control",
              direct_stream_.stream_handle_);
    if (direct_stream_.parent_.getStream(direct_stream_.stream_handle_,
                                         ALLOW_ONLY_FOR_OPEN_STREAMS)) {
      closeStream(false);
    }
    return;
  }

  http_client_.removeStream(direct_stream_.stream_handle_);
  direct_stream_.request_decoder_ = nullptr;
  sendErrorToBridge();
}

void Client::DirectStreamCallbacks::sendErrorToBridge() {
  if (remote_end_stream_forwarded_) {
    // If the request was not fully sent, but the response was complete, Envoy
    // will reset the stream after sending the fin bit. Don't pass this class of
    // errors up to the user.
    ENVOY_LOG(debug, "[S{}] not sending error as onComplete was called");
    return;
  }

  // The stream should no longer be preset in the map, because onError() was either called from a
  // terminal callback that mapped to an error or it was called in response to a resetStream().
  ASSERT(!http_client_.getStream(direct_stream_.stream_handle_,
                                 GetStreamFilters::ALLOW_FOR_ALL_STREAMS));

  ENVOY_LOG(debug, "[S{}] dispatching to platform remote reset stream",
            direct_stream_.stream_handle_);
  http_client_.stats().stream_failure_.inc();

  auto callback_time_ms = std::make_unique<Stats::HistogramCompletableTimespanImpl>(
      http_client_.stats().on_error_callback_latency_, http_client_.timeSource());

  bridge_callbacks_.on_error(error_.value(), streamIntel(), finalStreamIntel(),
                             bridge_callbacks_.context);
  error_.reset();

  callback_time_ms->complete();
  auto elapsed = callback_time_ms->elapsed();
  if (elapsed > SlowCallbackWarningThreshold) {
    ENVOY_LOG_EVENT(warn, "slow_on_error_cb", std::to_string(elapsed.count()) + "ms");
  }
}

void Client::DirectStreamCallbacks::onSendWindowAvailable() {
  ENVOY_LOG(debug, "[S{}] remote send window available", direct_stream_.stream_handle_);
  bridge_callbacks_.on_send_window_available(streamIntel(), bridge_callbacks_.context);
}

void Client::DirectStreamCallbacks::onCancel() {
  ScopeTrackerScopeState scope(&direct_stream_, http_client_.scopeTracker());

  ENVOY_LOG(debug, "[S{}] dispatching to platform cancel stream", direct_stream_.stream_handle_);
  http_client_.stats().stream_cancel_.inc();

  // Attempt to latch the latest stream info. This will be a no-op if the stream
  // is already complete.
  direct_stream_.saveFinalStreamIntel();

  auto callback_time_ms = std::make_unique<Stats::HistogramCompletableTimespanImpl>(
      http_client_.stats().on_cancel_callback_latency_, http_client_.timeSource());

  bridge_callbacks_.on_cancel(streamIntel(), finalStreamIntel(), bridge_callbacks_.context);

  callback_time_ms->complete();
  auto elapsed = callback_time_ms->elapsed();
  if (elapsed > SlowCallbackWarningThreshold) {
    ENVOY_LOG_EVENT(warn, "slow_on_cancel_cb", std::to_string(elapsed.count()) + "ms");
  }
}

void Client::DirectStreamCallbacks::onHasBufferedData() {
  // This call is potentially asynchronous, and may occur for a closed stream.
  if (!remote_end_stream_received_) {
    direct_stream_.runHighWatermarkCallbacks();
  }
}

void Client::DirectStreamCallbacks::onBufferedDataDrained() {
  // This call is potentially asynchronous, and may occur for a closed stream.
  if (!remote_end_stream_received_) {
    direct_stream_.runLowWatermarkCallbacks();
  }
}

envoy_stream_intel Client::DirectStreamCallbacks::streamIntel() {
  return direct_stream_.stream_intel_;
}

envoy_final_stream_intel& Client::DirectStreamCallbacks::finalStreamIntel() {
  return direct_stream_.envoy_final_stream_intel_;
}

void Client::DirectStream::saveLatestStreamIntel() {
  OptRef<RequestDecoder> request_decoder = requestDecoder();
  if (!request_decoder) {
    return;
  }
  const auto& info = request_decoder->streamInfo();
  if (info.upstreamInfo()) {
    stream_intel_.connection_id = info.upstreamInfo()->upstreamConnectionId().value_or(-1);
  }
  stream_intel_.stream_id = static_cast<uint64_t>(stream_handle_);
  stream_intel_.attempt_count = info.attemptCount().value_or(0);
}

void Client::DirectStream::saveFinalStreamIntel() {
  if (!parent_.getStream(stream_handle_, ALLOW_ONLY_FOR_OPEN_STREAMS)) {
    return;
  }
  OptRef<RequestDecoder> request_decoder = requestDecoder();
  if (!request_decoder) {
    return;
  }
  StreamInfo::setFinalStreamIntel(request_decoder->streamInfo(), parent_.dispatcher_.timeSource(),
                                  envoy_final_stream_intel_);
}

void Client::DirectStreamCallbacks::latchError() {
  if (error_.has_value()) {
    return; // Only latch error once.
  }
  error_ = envoy_error();

  OptRef<RequestDecoder> request_decoder = direct_stream_.requestDecoder();
  if (!request_decoder) {
    error_->message = envoy_nodata;
    return;
  }
  const auto& info = request_decoder->streamInfo();

  if (info.responseCode().has_value()) {
    error_->error_code = Bridge::Utility::errorCodeFromLocalStatus(
        static_cast<Http::Code>(info.responseCode().value()));
  } else if (StreamInfo::isStreamIdleTimeout(info)) {
    error_->error_code = ENVOY_REQUEST_TIMEOUT;
  } else {
    error_->error_code = ENVOY_STREAM_RESET;
  }

  if (info.responseCodeDetails().has_value()) {
    error_->message = Data::Utility::copyToBridgeData(info.responseCodeDetails().value());
  } else {
    error_->message = envoy_nodata;
  }

  error_->attempt_count = info.attemptCount().value_or(0);
}

Client::DirectStream::DirectStream(envoy_stream_t stream_handle, Client& http_client)
    : stream_handle_(stream_handle), parent_(http_client) {}

Client::DirectStream::~DirectStream() { ENVOY_LOG(debug, "[S{}] destroy stream", stream_handle_); }

CodecEventCallbacks*
Client::DirectStream::registerCodecEventCallbacks(CodecEventCallbacks* codec_callbacks) {
  // registerCodecEventCallbacks is called with nullptr when the underlying
  // Envoy stream is going away. Make sure Envoy Mobile sees the stream as
  // closed as well.
  if (codec_callbacks == nullptr &&
      parent_.getStream(stream_handle_, ALLOW_ONLY_FOR_OPEN_STREAMS)) {
    // Generally this only happens if Envoy closes the (virtual) downstream
    // connection, otherwise Envoy would inform the codec to send a reset.
    callbacks_->closeStream(false);
  }
  std::swap(codec_callbacks, codec_callbacks_);
  return codec_callbacks;
}

// Correctly receiving resetStream() for errors in Http::Client relies on at least one filter
// resetting the stream when handling a pending local response. By default, the LocalReplyFilter
// has this responsibility.
void Client::DirectStream::resetStream(StreamResetReason reason) {
  // This seems in line with other codec implementations, and so the assumption is that this is in
  // line with upstream expectations.
  // TODO(goaway): explore an upstream fix to get the HCM to clean up ActiveStream itself.
  saveFinalStreamIntel();   // Take a snapshot now in case the stream gets destroyed.
  callbacks_->latchError(); // Latch the error in case the stream gets destroyed.
  runResetCallbacks(reason);
  if (!parent_.getStream(stream_handle_, GetStreamFilters::ALLOW_FOR_ALL_STREAMS)) {
    // We don't assert here, because Envoy will issue a stream reset if a stream closes remotely
    // while still open locally. In this case the stream will already have been removed from
    // our stream maps due to the remote closure.
    return;
  }
  callbacks_->onError();
}

void Client::DirectStream::readDisable(bool disable) {
  if (disable) {
    ++read_disable_count_;
  } else {
    ASSERT(read_disable_count_ > 0);
    --read_disable_count_;
    if (read_disable_count_ == 0 && wants_write_notification_) {
      wants_write_notification_ = false;
      callbacks_->onSendWindowAvailable();
    }
  }
}

void Client::DirectStream::dumpState(std::ostream&, int indent_level) const {
  // TODO(junr03): output to ostream arg - https://github.com/envoyproxy/envoy-mobile/issues/1497.
  std::stringstream ss;
  const char* spaces = spacesForLevel(indent_level);

  ss << spaces << "DirectStream" << DUMP_MEMBER(stream_handle_) << std::endl;
  ENVOY_LOG(error, "\n{}", ss.str());
}

void Client::startStream(envoy_stream_t new_stream_handle, envoy_http_callbacks bridge_callbacks,
                         bool explicit_flow_control) {
  ASSERT(dispatcher_.isThreadSafe());
  Client::DirectStreamSharedPtr direct_stream{new DirectStream(new_stream_handle, *this)};
  direct_stream->explicit_flow_control_ = explicit_flow_control;
  direct_stream->callbacks_ =
      std::make_unique<DirectStreamCallbacks>(*direct_stream, bridge_callbacks, *this);

  // Note: streams created by Envoy Mobile are tagged as is_internally_created. This means that
  // the Http::ConnectionManager _will not_ sanitize headers when creating a stream.
  direct_stream->request_decoder_ =
      api_listener_->newStreamHandle(*direct_stream->callbacks_, true /* is_internally_created */);

  streams_.emplace(new_stream_handle, std::move(direct_stream));
  ENVOY_LOG(debug, "[S{}] start stream", new_stream_handle);
}

void Client::sendHeaders(envoy_stream_t stream, envoy_headers headers, bool end_stream) {
  ASSERT(dispatcher_.isThreadSafe());
  Client::DirectStreamSharedPtr direct_stream =
      getStream(stream, GetStreamFilters::ALLOW_ONLY_FOR_OPEN_STREAMS);
  // If direct_stream is not found, it means the stream has already closed or been reset
  // and the appropriate callback has been issued to the caller. There's nothing to do here
  // except silently swallow this.
  // TODO: handle potential race condition with cancellation or failure get a stream in the
  // first place. Additionally it is possible to get a nullptr due to bogus envoy_stream_t
  // from the caller.
  // https://github.com/envoyproxy/envoy-mobile/issues/301
  if (!direct_stream) {
    return;
  }
  OptRef<RequestDecoder> request_decoder = direct_stream->requestDecoder();
  if (!request_decoder) {
    return;
  }

  ScopeTrackerScopeState scope(direct_stream.get(), scopeTracker());
  RequestHeaderMapPtr internal_headers = Utility::toRequestHeaders(headers);

  // This is largely a check for the android platform: isCleartextPermitted
  // is a no-op for other platforms.
  if (internal_headers->getSchemeValue() != "https" &&
      !SystemHelper::getInstance().isCleartextPermitted(internal_headers->getHostValue())) {
    request_decoder->sendLocalReply(Http::Code::BadRequest, "Cleartext is not permitted", nullptr,
                                    absl::nullopt, "");
    return;
  }

  setDestinationCluster(*internal_headers);
  // Set the x-forwarded-proto header to https because Envoy Mobile only has clusters with TLS
  // enabled. This is done here because the ApiListener's synthetic connection would make the
  // Http::ConnectionManager set the scheme to http otherwise. In the future we might want to
  // configure the connection instead of setting the header here.
  // https://github.com/envoyproxy/envoy/issues/10291
  //
  // Setting this header is also currently important because Envoy Mobile starts stream with the
  // ApiListener setting the is_internally_created bool to true. This means the
  // Http::ConnectionManager *will not* mutate Envoy Mobile's request headers. One of the
  // mutations done is adding the x-forwarded-proto header if not present. Unfortunately, the
  // router relies on the present of this header to determine if it should provided a route for
  // a request here:
  // https://github.com/envoyproxy/envoy/blob/c9e3b9d2c453c7fe56a0e3615f0c742ac0d5e768/source/common/router/config_impl.cc#L1091-L1096
  internal_headers->setReferenceForwardedProto(Headers::get().SchemeValues.Https);
  ENVOY_LOG(debug, "[S{}] request headers for stream (end_stream={}):\n{}", stream, end_stream,
            *internal_headers);
  request_decoder->decodeHeaders(std::move(internal_headers), end_stream);
}

void Client::readData(envoy_stream_t stream, size_t bytes_to_read) {
  ASSERT(dispatcher_.isThreadSafe());
  // This is allowed for closed streams, else we could never send data up after
  // the FIN was received.
  Client::DirectStreamSharedPtr direct_stream =
      getStream(stream, GetStreamFilters::ALLOW_FOR_ALL_STREAMS);
  // If direct_stream is not found, it means the stream has already canceled or been reset
  // and the appropriate callback has been issued to the caller. There's nothing to do here
  // except silently swallow this.
  if (direct_stream) {
    direct_stream->callbacks_->resumeData(bytes_to_read);
  }
}

void Client::sendData(envoy_stream_t stream, envoy_data data, bool end_stream) {
  ASSERT(dispatcher_.isThreadSafe());
  Client::DirectStreamSharedPtr direct_stream =
      getStream(stream, GetStreamFilters::ALLOW_ONLY_FOR_OPEN_STREAMS);

  // Take ownership of data early, in case of early returns.
  // The buffer is moved internally, in a synchronous fashion, so we don't need the lifetime
  // of the InstancePtr to outlive this function call.
  Buffer::InstancePtr buf = Data::Utility::toInternalData(data);

  // If direct_stream is not found, it means the stream has already closed or been reset
  // and the appropriate callback has been issued to the caller. There's nothing to do here
  // except silently swallow this.
  // TODO: handle potential race condition with cancellation or failure get a stream in the
  // first place. Additionally it is possible to get a nullptr due to bogus envoy_stream_t
  // from the caller.
  // https://github.com/envoyproxy/envoy-mobile/issues/301
  if (!direct_stream) {
    return;
  }
  OptRef<RequestDecoder> request_decoder = direct_stream->requestDecoder();
  if (!request_decoder) {
    return;
  }

  ScopeTrackerScopeState scope(direct_stream.get(), scopeTracker());

  ENVOY_LOG(debug, "[S{}] request data for stream (length={} end_stream={})\n", stream, data.length,
            end_stream);
  request_decoder->decodeData(*buf, end_stream);

  if (direct_stream->explicit_flow_control_ && !end_stream) {
    if (direct_stream->read_disable_count_ == 0) {
      // If there is still buffer space after the write, notify the sender
      // that send window is available, on the next dispatcher iteration so
      // that repeated writes do not starve reads.
      direct_stream->wants_write_notification_ = false;
      // A new callback must be scheduled each time to capture any changes to the
      // DirectStream's callbacks from call to call.
      scheduled_callback_ = dispatcher_.createSchedulableCallback(
          [direct_stream] { direct_stream->callbacks_->onSendWindowAvailable(); });
      scheduled_callback_->scheduleCallbackNextIteration();
    } else {
      // Otherwise, make sure the stack will send a notification when the
      // buffers are drained.
      direct_stream->wants_write_notification_ = true;
    }
  }
}

void Client::sendMetadata(envoy_stream_t, envoy_headers) { PANIC("not implemented"); }

void Client::sendTrailers(envoy_stream_t stream, envoy_headers trailers) {
  ASSERT(dispatcher_.isThreadSafe());
  Client::DirectStreamSharedPtr direct_stream =
      getStream(stream, GetStreamFilters::ALLOW_ONLY_FOR_OPEN_STREAMS);
  // If direct_stream is not found, it means the stream has already closed or been reset
  // and the appropriate callback has been issued to the caller. There's nothing to do here
  // except silently swallow this.
  // TODO: handle potential race condition with cancellation or failure get a stream in the
  // first place. Additionally it is possible to get a nullptr due to bogus envoy_stream_t
  // from the caller.
  // https://github.com/envoyproxy/envoy-mobile/issues/301
  if (!direct_stream) {
    return;
  }
  OptRef<RequestDecoder> request_decoder = direct_stream->requestDecoder();
  if (!request_decoder) {
    return;
  }
  ScopeTrackerScopeState scope(direct_stream.get(), scopeTracker());
  RequestTrailerMapPtr internal_trailers = Utility::toRequestTrailers(trailers);
  ENVOY_LOG(debug, "[S{}] request trailers for stream:\n{}", stream, *internal_trailers);
  request_decoder->decodeTrailers(std::move(internal_trailers));
}

void Client::cancelStream(envoy_stream_t stream) {
  ASSERT(dispatcher_.isThreadSafe());
  // This is the one place where downstream->upstream communication is allowed
  // for closed streams: if the client cancels the stream it should be canceled
  // whether it was closed or not.
  Client::DirectStreamSharedPtr direct_stream =
      getStream(stream, GetStreamFilters::ALLOW_FOR_ALL_STREAMS);
  scheduled_callback_ = nullptr;
  if (direct_stream) {
    // Attempt to latch the latest stream info. This will be a no-op if the stream
    // is already complete.
    ENVOY_LOG(debug, "[S{}] application cancelled stream", stream);
    direct_stream->saveFinalStreamIntel();
    bool stream_was_open =
        getStream(stream, GetStreamFilters::ALLOW_ONLY_FOR_OPEN_STREAMS) != nullptr;
    ScopeTrackerScopeState scope(direct_stream.get(), scopeTracker());
    direct_stream->notifyAdapter(DirectStream::AdapterSignal::Cancel);
    removeStream(direct_stream->stream_handle_);

    direct_stream->callbacks_->onCancel();

    // Since https://github.com/envoyproxy/envoy/pull/13052, the connection manager expects that
    // response code details are set on all possible paths for streams.
    direct_stream->setResponseDetails(getCancelDetails());

    // Only run the reset callback if the stream is still open.
    if (stream_was_open) {
      // The runResetCallbacks call synchronously causes Envoy to defer delete the HCM's
      // ActiveStream. We have some concern that this could potentially race a terminal callback
      // scheduled on the same iteration of the event loop. If we see violations in the callback
      // assertions checking stream presence, this is a likely potential culprit. However, it's
      // plausible that upstream guards will protect us here, given that Envoy allows streams to be
      // reset from a wide variety of contexts without apparent issue.
      direct_stream->runResetCallbacks(StreamResetReason::RemoteReset);
    }
  }
}

const HttpClientStats& Client::stats() const { return stats_; }

Client::DirectStreamSharedPtr Client::getStream(envoy_stream_t stream,
                                                GetStreamFilters get_stream_filters) {
  auto direct_stream_pair_it = streams_.find(stream);
  if (direct_stream_pair_it != streams_.end()) {
    return direct_stream_pair_it->second;
  }
  if (get_stream_filters == ALLOW_FOR_ALL_STREAMS) {
    direct_stream_pair_it = closed_streams_.find(stream);
    if (direct_stream_pair_it != closed_streams_.end()) {
      return direct_stream_pair_it->second;
    }
  }
  return nullptr;
}

void Client::removeStream(envoy_stream_t stream_handle) {
  RELEASE_ASSERT(
      dispatcher_.isThreadSafe(),
      fmt::format("[S{}] stream removeStream must be performed on the dispatcher_'s thread.",
                  stream_handle));
  Client::DirectStreamSharedPtr direct_stream =
      getStream(stream_handle, GetStreamFilters::ALLOW_FOR_ALL_STREAMS);
  RELEASE_ASSERT(
      direct_stream,
      fmt::format(
          "[S{}] removeStream is a private method that is only called with stream ids that exist",
          stream_handle));

  // The DirectStream should live through synchronous code that already has a reference to it.
  // Hence why it is scheduled for deferred deletion. If this was all that was needed then it
  // would be sufficient to return a shared_ptr in getStream. However, deferred deletion is still
  // required because in Client::resetStream the DirectStream needs to live for as long and
  // the HCM's ActiveStream lives. Hence its deletion needs to live beyond the synchronous code in
  // Client::resetStream.
  auto direct_stream_wrapper = std::make_unique<DirectStreamWrapper>(std::move(direct_stream));
  dispatcher_.deferredDelete(std::move(direct_stream_wrapper));
  // However, the entry in the map should not exist after removeStream.
  // Hence why it is synchronously erased from the streams map.
  size_t erased = streams_.erase(stream_handle);
  if (erased != 1) {
    erased = closed_streams_.erase(stream_handle);
  }
  ASSERT(erased == 1, "removeStream should always remove one entry from the streams map");
  ENVOY_LOG(debug, "[S{}] erased stream from streams container", stream_handle);
}

namespace {

const LowerCaseString ClusterHeader{"x-envoy-mobile-cluster"};

const char* BaseCluster = "base";
const char* ClearTextCluster = "base_clear";

} // namespace

void Client::setDestinationCluster(Http::RequestHeaderMap& headers) {
  // Determine upstream cluster:
  // - Force http/1.1 if request scheme is http (cleartext).
  // - Base cluster (best available protocol) for all secure traffic.
  const char* cluster{};
  if (headers.getSchemeValue() == Headers::get().SchemeValues.Http) {
    cluster = ClearTextCluster;
  } else {
    cluster = BaseCluster;
  }

  headers.addCopy(ClusterHeader, std::string{cluster});
}

} // namespace Http
} // namespace Envoy
#pragma once

#include "envoy/buffer/buffer.h"
#include "envoy/http/filter.h"
#include "envoy/http/header_map.h"

#include "library/common/types/c_types.h"

namespace Envoy {
namespace Http {
namespace Utility {

/*
 * Returns the proper status code for onLocalReply
 * @param reply the local reply data for the stream.
 * @param stream_info the info for the stream.
 */
Http::LocalErrorStatus statusForOnLocalReply(const StreamDecoderFilter::LocalReplyData& reply,
                                             const StreamInfo::StreamInfo& stream_info);

/**
 * Transform envoy_headers to the supplied HeaderMap
 * This function copies the content.
 * @param envoy_result_headers, the Envoy headers to fill in. These headers must have a formatter
 *        set.
 * @param headers, the envoy_headers to transform. headers is free'd. Use after function return is
 * unsafe.
 */
void toEnvoyHeaders(HeaderMap& envoy_result_headers, envoy_headers headers);

/**
 * Transform envoy_headers to RequestHeaderMap.
 * This function copies the content.
 * @param headers, the envoy_headers to transform. headers is free'd. Use after function return is
 * unsafe.
 * @return RequestHeaderMapPtr, the RequestHeaderMap 1:1 transformation of the headers param.
 */
RequestHeaderMapPtr toRequestHeaders(envoy_headers headers);

/**
 * Transform envoy_headers to RequestHeaderMap.
 * This function copies the content.
 * @param trailers, the envoy_headers (trailers) to transform. headers is free'd. Use after function
 * return is unsafe.
 * @return RequestTrailerMapPtr, the RequestTrailerMap 1:1 transformation of the headers param.
 */
RequestTrailerMapPtr toRequestTrailers(envoy_headers trailers);

/**
 * Transform envoy_headers to HeaderMap.
 * This function copies the content.
 * Caller owns the allocated bytes for the return value, and needs to free after use.
 * @param headers, the HeaderMap to transform.
 * @param alpn, the optional alpn to add to the headers.
 * @return envoy_headers, the HeaderMap 1:1 transformation of the headers param.
 */
envoy_headers toBridgeHeaders(const HeaderMap& headers, absl::string_view alpn = "");

} // namespace Utility
} // namespace Http
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "client_lib",
    srcs = ["client.cc"],
    hdrs = ["client.h"],
    external_deps = ["abseil_optional"],
    repository = "@envoy",
    deps = [
        "//library/common/bridge:utility_lib",
        "//library/common/buffer:bridge_fragment_lib",
        "//library/common/common:system_helper_lib",
        "//library/common/data:utility_lib",
        "//library/common/event:provisional_dispatcher_lib",
        "//library/common/extensions/filters/http/local_error:local_error_filter_lib",
        "//library/common/extensions/filters/http/network_configuration:network_configuration_filter_lib",
        "//library/common/http:header_utility_lib",
        "//library/common/network:connectivity_manager_lib",
        "//library/common/network:synthetic_address_lib",
        "//library/common/stream_info:extra_stream_info_lib",
        "//library/common/types:c_types_lib",
        "@envoy//envoy/buffer:buffer_interface",
        "@envoy//envoy/common:scope_tracker_interface",
        "@envoy//envoy/event:deferred_deletable",
        "@envoy//envoy/http:api_listener_interface",
        "@envoy//envoy/http:header_map_interface",
        "@envoy//envoy/stats:stats_interface",
        "@envoy//envoy/stats:stats_macros",
        "@envoy//envoy/stats:timespan_interface",
        "@envoy//source/common/buffer:buffer_lib",
        "@envoy//source/common/buffer:watermark_buffer_lib",
        "@envoy//source/common/common:lock_guard_lib",
        "@envoy//source/common/common:minimal_logger_lib",
        "@envoy//source/common/common:random_generator_lib",
        "@envoy//source/common/http:codec_helper_lib",
        "@envoy//source/common/http:codes_lib",
        "@envoy//source/common/http:header_map_lib",
        "@envoy//source/common/http:headers_lib",
        "@envoy//source/common/http:utility_lib",
        "@envoy//source/common/network:socket_lib",
        "@envoy//source/common/stats:timespan_lib",
    ],
)

envoy_cc_library(
    name = "header_utility_lib",
    srcs = ["header_utility.cc"],
    hdrs = ["header_utility.h"],
    repository = "@envoy",
    deps = [
        "//library/common/data:utility_lib",
        "//library/common/types:c_types_lib",
        "@envoy//envoy/buffer:buffer_interface",
        "@envoy//envoy/http:filter_interface",
        "@envoy//envoy/http:header_map_interface",
        "@envoy//source/common/http:header_map_lib",
        "@envoy//source/extensions/http/header_formatters/preserve_case:preserve_case_formatter",
    ],
)

envoy_cc_library(
    name = "internal_headers_lib",
    hdrs = ["headers.h"],
    repository = "@envoy",
    deps = [
        "@envoy//envoy/http:header_map_interface",
        "@envoy//source/common/singleton:const_singleton",
        "@envoy//source/common/singleton:threadsafe_singleton",
    ],
)
#include "external.h"

#include "source/common/common/assert.h"

#include "absl/container/flat_hash_map.h"

namespace Envoy {
namespace Api {
namespace External {

// TODO(goaway): This needs to be updated not to leak once multiple engines are supported.
// See https://github.com/envoyproxy/envoy-mobile/issues/332
static absl::flat_hash_map<std::string, void*> registry_{};

// TODO(goaway): To expose this for general usage, it will need to be made thread-safe. For now it
// relies on the assumption that usage will occur only as part of Engine configuration, and thus be
// limited to a single thread.
void registerApi(std::string name, void* api) {
  RELEASE_ASSERT(api != nullptr, "cannot register null API");
  registry_[name] = api;
}

// TODO(goaway): This is not thread-safe, but the assumption here is that all writes will complete
// before any reads occur.
void* retrieveApi(std::string name, bool allow_absent) {
  void* api = registry_[name];
  if (!allow_absent) {
    RELEASE_ASSERT(api != nullptr, fmt::format("{} not registered", name));
  }
  return api;
}

} // namespace External
} // namespace Api
} // namespace Envoy
#pragma once

#include <string>

namespace Envoy {
namespace Api {
namespace External {

/**
 * Register an external runtime API for usage (e.g. in extensions).
 */
void registerApi(std::string name, void* api);

/**
 * Retrieve an external runtime API for usage (e.g. in extensions).
 */
void* retrieveApi(std::string name, bool allow_absent = false);

} // namespace External
} // namespace Api
} // namespace Envoy
#pragma once

#include "library/common/types/c_types.h"

// NOLINT(namespace-envoy)

#ifdef __cplusplus
extern "C" { // function pointers
#endif

typedef envoy_data (*envoy_get_string_f)(const void* context);

#ifdef __cplusplus
} // function pointers
#endif

/**
 * Datatype used to access strings from the platform layer. This accessor is read-only.
 */
// TODO: https://github.com/envoyproxy/envoy-mobile/issues/1192 generalize to access arbitrary
//       types.
typedef struct {
  envoy_get_string_f get_string;
  const void* context;
} envoy_string_accessor;
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "external_api_lib",
    srcs = [
        "external.cc",
    ],
    hdrs = [
        "external.h",
    ],
    repository = "@envoy",
    visibility = ["//visibility:public"],
    deps = [
        "@envoy//source/common/common:assert_lib",
    ],
)

envoy_cc_library(
    name = "c_types",
    hdrs = ["c_types.h"],
    repository = "@envoy",
    deps = [
        "//library/common/types:c_types_lib",
    ],
)
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package", "envoy_select_signal_trace")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "engine_lib",
    repository = "@envoy",
    deps = [
        ":engine_common_lib_stamped",
        ":engine_lib_no_stamp",
    ],
)

envoy_cc_library(
    name = "engine_lib_no_stamp",
    srcs = [
        "engine.cc",
    ],
    hdrs = [
        "engine.h",
    ],
    repository = "@envoy",
    deps = [
        ":engine_common_lib",
        "//library/common/bridge:utility_lib",
        "//library/common/common:lambda_logger_delegate_lib",
        "//library/common/data:utility_lib",
        "//library/common/event:provisional_dispatcher_lib",
        "//library/common/http:client_lib",
        "//library/common/http:header_utility_lib",
        "//library/common/network:connectivity_manager_lib",
        "//library/common/stats:utility_lib",
        "//library/common/types:c_types_lib",
        "@envoy//envoy/server:lifecycle_notifier_interface",
        "@envoy//envoy/stats:stats_interface",
        "@envoy//source/common/runtime:runtime_lib",
        "@envoy_build_config//:extension_registry",
    ],
)

envoy_cc_library(
    name = "engine_common_lib",
    srcs = ["engine_common.cc"],
    hdrs = ["engine_common.h"],
    repository = "@envoy",
    deps = [
        "//library/common/extensions/cert_validator/platform_bridge:platform_bridge_cc_proto_descriptor",
        "//library/common/extensions/filters/http/local_error:filter_cc_proto_descriptor",
        "//library/common/extensions/filters/http/network_configuration:filter_cc_proto_descriptor",
        "//library/common/extensions/filters/http/platform_bridge:filter_cc_proto_descriptor",
        "//library/common/extensions/filters/http/socket_tag:filter_cc_proto_descriptor",
        "//library/common/extensions/key_value/platform:platform_cc_proto_descriptor",
        "//library/common/extensions/retry/options/network_configuration:predicate_cc_proto_descriptor",
        "@envoy//source/common/common:minimal_logger_lib",
        "@envoy//source/common/common:random_generator_lib",
        "@envoy//source/common/runtime:runtime_lib",
        "@envoy//source/exe:stripped_main_base_lib",
        "@envoy//source/server:null_overload_manager_lib",
    ] + envoy_select_signal_trace(
        ["@envoy//source/common/signal:sigaction_lib"],
        "@envoy",
    ),
)

envoy_cc_library(
    name = "engine_common_lib_stamped",
    repository = "@envoy",
    deps = [
        ":engine_common_lib",
        "@envoy//source/exe:envoy_stripped_main_base_lib",
    ],
)
#include "library/common/jni/android_network_utility.h"

#include "library/common/data/utility.h"
#include "library/common/jni/jni_support.h"
#include "library/common/jni/jni_utility.h"
#include "library/common/jni/types/exception.h"
#include "library/common/jni/types/java_virtual_machine.h"
#include "openssl/ssl.h"

namespace Envoy {
namespace JNI {

namespace {
// Helper functions call into AndroidNetworkLibrary, but they are not platform dependent
// because AndroidNetworkLibray can be called in non-Android platform with mock interfaces.

bool jvmCertIsIssuedByKnownRoot(JniHelper& jni_helper, jobject result) {
  LocalRefUniquePtr<jclass> jcls_AndroidCertVerifyResult =
      findClass("io.envoyproxy.envoymobile.utilities.AndroidCertVerifyResult");
  jmethodID jmid_isIssuedByKnownRoot =
      jni_helper.getMethodId(jcls_AndroidCertVerifyResult.get(), "isIssuedByKnownRoot", "()Z");
  ASSERT(jmid_isIssuedByKnownRoot);
  bool is_issued_by_known_root = jni_helper.callBooleanMethod(result, jmid_isIssuedByKnownRoot);
  return is_issued_by_known_root;
}

envoy_cert_verify_status_t jvmCertGetStatus(JniHelper& jni_helper, jobject j_result) {
  LocalRefUniquePtr<jclass> jcls_AndroidCertVerifyResult =
      findClass("io.envoyproxy.envoymobile.utilities.AndroidCertVerifyResult");
  jmethodID jmid_getStatus =
      jni_helper.getMethodId(jcls_AndroidCertVerifyResult.get(), "getStatus", "()I");
  ASSERT(jmid_getStatus);
  envoy_cert_verify_status_t result =
      static_cast<envoy_cert_verify_status_t>(jni_helper.callIntMethod(j_result, jmid_getStatus));
  return result;
}

LocalRefUniquePtr<jobjectArray> jvmCertGetCertificateChainEncoded(JniHelper& jni_helper,
                                                                  jobject result) {
  LocalRefUniquePtr<jclass> jcls_AndroidCertVerifyResult =
      findClass("io.envoyproxy.envoymobile.utilities.AndroidCertVerifyResult");
  jmethodID jmid_getCertificateChainEncoded = jni_helper.getMethodId(
      jcls_AndroidCertVerifyResult.get(), "getCertificateChainEncoded", "()[[B");
  LocalRefUniquePtr<jobjectArray> certificate_chain =
      jni_helper.callObjectMethod<jobjectArray>(result, jmid_getCertificateChainEncoded);
  return certificate_chain;
}

static void extractCertVerifyResult(JniHelper& jni_helper, jobject result,
                                    envoy_cert_verify_status_t* status,
                                    bool* is_issued_by_known_root,
                                    std::vector<std::string>* verified_chain) {
  *status = jvmCertGetStatus(jni_helper, result);
  if (*status == CERT_VERIFY_STATUS_OK) {
    *is_issued_by_known_root = jvmCertIsIssuedByKnownRoot(jni_helper, result);
    LocalRefUniquePtr<jobjectArray> chain_byte_array =
        jvmCertGetCertificateChainEncoded(jni_helper, result);
    if (chain_byte_array != nullptr) {
      javaArrayOfByteArrayToStringVector(jni_helper, chain_byte_array.get(), verified_chain);
    }
  }
}

// `auth_type` and `host` are expected to be UTF-8 encoded.
static void jvmVerifyX509CertChain(const std::vector<std::string>& cert_chain,
                                   std::string auth_type, absl::string_view hostname,
                                   envoy_cert_verify_status_t* status,
                                   bool* is_issued_by_known_root,
                                   std::vector<std::string>* verified_chain) {
  JniHelper jni_helper(getEnv());
  LocalRefUniquePtr<jobject> result =
      callJvmVerifyX509CertChain(jni_helper, cert_chain, auth_type, hostname);
  if (Exception::checkAndClear()) {
    *status = CERT_VERIFY_STATUS_NOT_YET_VALID;
  } else {
    extractCertVerifyResult(jni_helper, result.get(), status, is_issued_by_known_root,
                            verified_chain);
    if (Exception::checkAndClear()) {
      *status = CERT_VERIFY_STATUS_FAILED;
    }
  }
}

} // namespace

// `auth_type` and `host` are expected to be UTF-8 encoded.
LocalRefUniquePtr<jobject> callJvmVerifyX509CertChain(Envoy::JNI::JniHelper& jni_helper,
                                                      const std::vector<std::string>& cert_chain,
                                                      std::string auth_type,
                                                      absl::string_view hostname) {
  jni_log("[Envoy]", "jvmVerifyX509CertChain");
  LocalRefUniquePtr<jclass> jcls_AndroidNetworkLibrary =
      findClass("io.envoyproxy.envoymobile.utilities.AndroidNetworkLibrary");
  jmethodID jmid_verifyServerCertificates = jni_helper.getStaticMethodId(
      jcls_AndroidNetworkLibrary.get(), "verifyServerCertificates",
      "([[B[B[B)Lio/envoyproxy/envoymobile/utilities/AndroidCertVerifyResult;");
  LocalRefUniquePtr<jobjectArray> chain_byte_array =
      vectorStringToJavaArrayOfByteArray(jni_helper, cert_chain);
  LocalRefUniquePtr<jbyteArray> auth_string = stringToJavaByteArray(jni_helper, auth_type);
  LocalRefUniquePtr<jbyteArray> host_string = byteArrayToJavaByteArray(
      jni_helper, reinterpret_cast<const uint8_t*>(hostname.data()), hostname.length());
  LocalRefUniquePtr<jobject> result = jni_helper.callStaticObjectMethod(
      jcls_AndroidNetworkLibrary.get(), jmid_verifyServerCertificates, chain_byte_array.get(),
      auth_string.get(), host_string.get());
  return result;
}

envoy_cert_validation_result verifyX509CertChain(const std::vector<std::string>& certs,
                                                 absl::string_view hostname) {
  jni_log("[Envoy]", "verifyX509CertChain");

  envoy_cert_verify_status_t result;
  bool is_issued_by_known_root;
  std::vector<std::string> verified_chain;
  std::vector<std::string> cert_chain;
  for (absl::string_view cert : certs) {
    cert_chain.push_back(std::string(cert));
  }

  // Android ignores the authType parameter to X509TrustManager.checkServerTrusted, so pass in "RSA"
  // as dummy value. See https://crbug.com/627154.
  jvmVerifyX509CertChain(cert_chain, "RSA", hostname, &result, &is_issued_by_known_root,
                         &verified_chain);
  switch (result) {
  case CERT_VERIFY_STATUS_OK:
    return {ENVOY_SUCCESS, 0, nullptr};
  case CERT_VERIFY_STATUS_EXPIRED: {
    return {ENVOY_FAILURE, SSL_AD_CERTIFICATE_EXPIRED,
            "AndroidNetworkLibrary_verifyServerCertificates failed: expired cert."};
  }
  case CERT_VERIFY_STATUS_NO_TRUSTED_ROOT:
    return {ENVOY_FAILURE, SSL_AD_CERTIFICATE_UNKNOWN,
            "AndroidNetworkLibrary_verifyServerCertificates failed: no trusted root."};
  case CERT_VERIFY_STATUS_UNABLE_TO_PARSE:
    return {ENVOY_FAILURE, SSL_AD_BAD_CERTIFICATE,
            "AndroidNetworkLibrary_verifyServerCertificates failed: unable to parse cert."};
  case CERT_VERIFY_STATUS_INCORRECT_KEY_USAGE:
    return {ENVOY_FAILURE, SSL_AD_CERTIFICATE_UNKNOWN,
            "AndroidNetworkLibrary_verifyServerCertificates failed: incorrect key usage."};
  case CERT_VERIFY_STATUS_FAILED:
    return {
        ENVOY_FAILURE, SSL_AD_CERTIFICATE_UNKNOWN,
        "AndroidNetworkLibrary_verifyServerCertificates failed: validation couldn't be conducted."};
  case CERT_VERIFY_STATUS_NOT_YET_VALID:
    return {ENVOY_FAILURE, SSL_AD_CERTIFICATE_UNKNOWN,
            "AndroidNetworkLibrary_verifyServerCertificates failed: not yet valid."};
  default:
    PANIC_DUE_TO_CORRUPT_ENUM
  }
}

void jvmDetachThread() { JavaVirtualMachine::detachCurrentThread(); }

} // namespace JNI
} // namespace Envoy
#pragma once

#include "library/common/jni/import/jni_import.h"

namespace Envoy {
namespace JNI {

/**
 * JNI Environment variable wrapper.
 */
class Env {
public:
  static JNIEnv* get();

private:
  static thread_local JNIEnv* local_env_;
};

} // namespace JNI
} // namespace Envoy
#pragma once

#include "library/common/jni/import/jni_import.h"

namespace Envoy {
namespace JNI {

/**
 * @brief A convenience wrapper for JNI JavaVM type.
 *
 */
class JavaVirtualMachine {
public:
  /**
   * @brief Initializes virtual machine. It should be called only once.
   *
   * @param jvm A pointer to running JavaVM instance.
   * @return jint JNI_OK if the operation was successful, error code information otherwise.
   */
  static jint initialize(JavaVM* jvm);
  static JavaVM* getJavaVM();
  static jint getJNIVersion();
  static void detachCurrentThread();

private:
  static JavaVM* jvm_;
};

} // namespace JNI
} // namespace Envoy
#include "library/common/jni/types/java_virtual_machine.h"

#include "source/common/common/assert.h"

#include "library/common/jni/jni_support.h"

namespace Envoy {
namespace JNI {

jint JavaVirtualMachine::initialize(JavaVM* jvm) {
  JNIEnv* env = nullptr;
  if (jvm->GetEnv(reinterpret_cast<void**>(&env), getJNIVersion()) != JNI_OK) {
    return -1;
  }

  ASSERT(jvm_ == nullptr, "JavaVM has already been set");
  ASSERT(jvm != nullptr, "Passed JavaVM is invalid");
  jvm_ = jvm;

  return JNI_OK;
}

JavaVM* JavaVirtualMachine::getJavaVM() { return jvm_; }

jint JavaVirtualMachine::getJNIVersion() { return JNI_VERSION_1_6; }

void JavaVirtualMachine::detachCurrentThread() {
  const auto result = jvm_->DetachCurrentThread();
  ASSERT(result == JNI_OK, "Failed to detach current thread");
}

JavaVM* JavaVirtualMachine::jvm_ = nullptr;

} // namespace JNI
} // namespace Envoy
#include "library/common/jni/types/exception.h"

#include "source/common/common/assert.h"

#include "fmt/format.h"
#include "library/common/jni/types/env.h"
#include "library/common/jni/types/string.h"

namespace Envoy {
namespace JNI {

bool Exception::checkAndClear(const std::string& details) {
  auto env = Env::get();
  if (env->ExceptionCheck() == JNI_TRUE) {
    jthrowable throwable = env->ExceptionOccurred();
    env->ExceptionClear();

    const auto exception = Exception(env, throwable);
    ENVOY_LOG_EVENT_TO_LOGGER(GET_MISC_LOGGER(), info, "jni_cleared_pending_exception",
                              exception.description(details));
    return true;
  } else {
    return false;
  }
}

/**
 * @brief Creates a description of an exception in the following format:
 * GENERIC_EXCEPTION_DESCRIPTION||DETAIL||EXCEPTION_STACKTRACE||EXCEPTION_CAUSE_STACKTRACE
 */
std::string Exception::description(const std::string& detail) const {
  auto throwable_cause_description = causedByThrowableDescription();
  std::vector<std::string> descriptionComponents = {
      throwableDescription(throwable_),
      detail == "" ? "NO_DETAIL" : detail,
      throwableStacktraceDescription(throwable_),
      throwable_cause_description == "" ? "CAUSE_UNKNOWN_OR_NONEXISTENT"
                                        : throwable_cause_description,
  };

  return fmt::format("{}", fmt::join(descriptionComponents, "||"));
}

std::string Exception::throwableDescription(jthrowable throwable) const {
  jclass jcls_throwable = env_->FindClass("java/lang/Throwable");
  if (exceptionCheck()) {
    return "Throwable: class not found";
  }

  jmethodID mid_throwable_toString =
      env_->GetMethodID(jcls_throwable, "toString", "()Ljava/lang/String;");
  if (exceptionCheck()) {
    return "Throwable.toString: method not found";
  }

  jstring j_description =
      static_cast<jstring>(env_->CallObjectMethod(throwable, mid_throwable_toString));
  if (exceptionCheck()) {
    return "Throwable.toString: exception was thrown during method call";
  }

  return String(j_description).get();
}

std::string Exception::throwableStacktraceDescription(jthrowable throwable) const {
  jclass jcls_throwable = env_->FindClass("java/lang/Throwable");
  if (exceptionCheck()) {
    return "Throwable: class not found";
  }

  jmethodID mid_throwable_getStackTrace =
      env_->GetMethodID(jcls_throwable, "getStackTrace", "()[Ljava/lang/StackTraceElement;");
  if (exceptionCheck()) {
    return "Throwable.getStackTrace: method not found";
  }

  jclass jcls_frame = env_->FindClass("java/lang/StackTraceElement");
  if (exceptionCheck()) {
    return "StackTraceElement: class not found";
  }

  jmethodID mid_frame_toString = env_->GetMethodID(jcls_frame, "toString", "()Ljava/lang/String;");
  if (exceptionCheck()) {
    return "StackTraceElement.toString: method not found";
  }

  jobjectArray j_frames =
      static_cast<jobjectArray>(env_->CallObjectMethod(throwable, mid_throwable_getStackTrace));
  if (exceptionCheck()) {
    return "StackTraceElement.getStrackTrace: exception was thrown during method call";
  }

  jsize frames_length = env_->GetArrayLength(j_frames);
  if (exceptionCheck()) {
    return "GetArrayLength: exception was thrown during method call";
  }

  std::vector<std::string> lines;

  jsize i = 0;
  for (i = 0; i < frames_length; i++) {
    jobject j_frame = env_->GetObjectArrayElement(j_frames, i);
    if (exceptionCheck()) {
      lines.push_back("GetObjectArrayElement: exception was thrown during method call");
      break;
    }

    jstring j_description =
        static_cast<jstring>(env_->CallObjectMethod(j_frame, mid_frame_toString));
    if (exceptionCheck()) {
      lines.push_back("StackTraceElement.toString: exception was thrown during method call");
      break;
    }

    lines.push_back(String(j_description).get());
    env_->DeleteLocalRef(j_frame);
  }

  return fmt::format("{}", fmt::join(lines, ";"));
}

std::string Exception::causedByThrowableDescription() const {
  jclass jcls_throwable = env_->FindClass("java/lang/Throwable");
  if (exceptionCheck()) {
    return "Throwable: class not found";
  }

  jmethodID mid_throwable_getCause =
      env_->GetMethodID(jcls_throwable, "getCause", "()Ljava/lang/Throwable;");
  if (exceptionCheck()) {
    return "Throwable.getCause: method not found";
  }

  jthrowable j_throwable =
      static_cast<jthrowable>(env_->CallObjectMethod(throwable_, mid_throwable_getCause));
  if (exceptionCheck()) {
    return "Throwable.getCause: exception was thrown during method call";
  }

  if (j_throwable == nullptr) {
    return "";
  }

  return throwableDescription(j_throwable);
}

bool Exception::exceptionCheck() const {
  if (env_->ExceptionCheck() == JNI_TRUE) {
    env_->ExceptionClear();
    return true;
  }
  return false;
}

} // namespace JNI
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "jni_exception_lib",
    srcs = [
        "exception.cc",
    ],
    hdrs = [
        "exception.h",
    ],
    repository = "@envoy",
    deps = [
        "//library/common/jni/import:jni_import_lib",
        "//library/common/jni/types:jni_string_lib",
        "@envoy//source/common/common:assert_lib",
    ],
    # We need this to ensure that we link this into the .so even though there are no code references.
    alwayslink = True,
)

envoy_cc_library(
    name = "jni_string_lib",
    hdrs = [
        "string.h",
    ],
    repository = "@envoy",
    deps = [
        "//library/common/jni/import:jni_import_lib",
        "//library/common/jni/types:jni_env_lib",
    ],
    # We need this to ensure that we link this into the .so even though there are no code references.
    alwayslink = True,
)

envoy_cc_library(
    name = "jni_env_lib",
    srcs = [
        "env.cc",
    ],
    hdrs = [
        "env.h",
    ],
    repository = "@envoy",
    deps = [
        "//library/common/jni:jni_support_lib",
        "//library/common/jni/import:jni_import_lib",
        "//library/common/jni/types:jni_javavm_lib",
        "@envoy//source/common/common:assert_lib",
    ],
    # We need this to ensure that we link this into the .so even though there are no code references.
    alwayslink = True,
)

envoy_cc_library(
    name = "jni_javavm_lib",
    srcs = [
        "java_virtual_machine.cc",
    ],
    hdrs = [
        "java_virtual_machine.h",
    ],
    repository = "@envoy",
    deps = [
        "//library/common/jni:jni_support_lib",
        "//library/common/jni/import:jni_import_lib",
        "@envoy//source/common/common:assert_lib",
    ],
    # We need this to ensure that we link this into the .so even though there are no code references.
    alwayslink = True,
)
#pragma once

#include <string>

#include "library/common/jni/import/jni_import.h"

namespace Envoy {
namespace JNI {

/**
 * @brief A convenience wrapper for checking for and reporting JNI exceptions.
 */
class Exception {
public:
  /**
   * @brief Checks and clears any pending exceptions. Reports pending exceptions using
   * ENVOY_LOG_EVENT_TO_LOGGER macro. The macro ends up propagating the information to
   * platform layer using platform's logger and event tracker APIs. The corresponding log/event
   * uses emits `jni_cleared_pending_exception` log.
   *
   * @param detail Information that will be attached to a pending exception log if any is emitted.
   * @return true If a pending exception was present and cleared.
   * @return false If there was no pending exception.
   */
  static bool checkAndClear(const std::string& detail = "");

private:
  Exception(JNIEnv* env, jthrowable throwable) : env_(env), throwable_(throwable) {}

  std::string description(const std::string& detail) const;
  std::string throwableDescription(jthrowable) const;
  std::string throwableStacktraceDescription(jthrowable) const;
  std::string causedByThrowableDescription() const;

  bool exceptionCheck() const;

  JNIEnv* env_;
  jthrowable throwable_;
};

} // namespace JNI
} // namespace Envoy
#include "library/common/jni/types/env.h"

#include "source/common/common/assert.h"

#include "library/common/jni/jni_support.h"
#include "library/common/jni/types/java_virtual_machine.h"

namespace Envoy {
namespace JNI {

JNIEnv* Env::get() {
  if (local_env_) {
    return local_env_;
  }

  jint result = JavaVirtualMachine::getJavaVM()->GetEnv(reinterpret_cast<void**>(&local_env_),
                                                        JavaVirtualMachine::getJNIVersion());
  if (result == JNI_EDETACHED) {
    // Note: the only thread that should need to be attached is Envoy's engine std::thread.
    static const char* thread_name = "EnvoyMain";
    JavaVMAttachArgs args = {JavaVirtualMachine::getJNIVersion(), const_cast<char*>(thread_name),
                             nullptr};
    result = attach_jvm(JavaVirtualMachine::getJavaVM(), &local_env_, &args);
  }
  RELEASE_ASSERT(result == JNI_OK, "Unable to get a JVM env for the current thread");
  return local_env_;
}

thread_local JNIEnv* Env::local_env_ = nullptr;

} // namespace JNI
} // namespace Envoy
#pragma once

#include "absl/strings/string_view.h"
#include "library/common/jni/import/jni_import.h"
#include "library/common/jni/types/env.h"

namespace Envoy {
namespace JNI {

/**
 * @brief A convenience wrapper that makes working with jstring easier and less error prone.
 * It takes care of managing freeing JNI resources when it's deallocated.
 */
class String {
public:
  String(const String&) = delete;

  /**
   * @brief Construct a new String object. Retrieves a pointer to an array of bytes representing
   * the string in modified UTF-8 encoding.
   */
  explicit String(jstring jni_string)
      : env_(Env::get()), jni_string_(jni_string),
        string_(env_->GetStringUTFChars(jni_string, nullptr)) {}

  ~String() {
    if (string_ != nullptr) {
      env_->ReleaseStringUTFChars(jni_string_, string_);
    }
  }

  /**
   * @brief Returns a string that represents the underlying array of bytes.
   */
  std::string get() {
    if (string_ != nullptr) {
      return std::string(string_);
    }
    return "nullptr";
  }
  void operator=(const String&) = delete;

private:
  JNIEnv* env_;
  jstring jni_string_;
  const char* string_;
};

} // namespace JNI
} // namespace Envoy
#include "library/common/jni/jni_helper.h"

#include "source/common/common/assert.h"

namespace Envoy {
namespace JNI {

JNIEnv* JniHelper::getEnv() { return env_; }

jmethodID JniHelper::getMethodId(jclass clazz, const char* name, const char* signature) {
  jmethodID method_id = env_->GetMethodID(clazz, name, signature);
  rethrowException();
  return method_id;
}

jmethodID JniHelper::getStaticMethodId(jclass clazz, const char* name, const char* signature) {
  jmethodID method_id = env_->GetStaticMethodID(clazz, name, signature);
  rethrowException();
  return method_id;
}

LocalRefUniquePtr<jclass> JniHelper::findClass(const char* class_name) {
  LocalRefUniquePtr<jclass> result(env_->FindClass(class_name), LocalRefDeleter(env_));
  rethrowException();
  return result;
}

LocalRefUniquePtr<jclass> JniHelper::getObjectClass(jobject object) {
  return {env_->GetObjectClass(object), LocalRefDeleter(env_)};
}

void JniHelper::throwNew(const char* java_class_name, const char* message) {
  LocalRefUniquePtr<jclass> java_class = findClass(java_class_name);
  if (java_class != nullptr) {
    jint error = env_->ThrowNew(java_class.get(), message);
    RELEASE_ASSERT(error == JNI_OK, fmt::format("Failed calling ThrowNew."));
  }
}

LocalRefUniquePtr<jthrowable> JniHelper::exceptionOccurred() {
  return {env_->ExceptionOccurred(), LocalRefDeleter(env_)};
}

GlobalRefUniquePtr<jobject> JniHelper::newGlobalRef(jobject object) {
  GlobalRefUniquePtr<jobject> result(env_->NewGlobalRef(object), GlobalRefDeleter(env_));
  return result;
}

LocalRefUniquePtr<jobject> JniHelper::newObject(jclass clazz, jmethodID method_id, ...) {
  va_list args;
  va_start(args, method_id);
  LocalRefUniquePtr<jobject> result(env_->NewObjectV(clazz, method_id, args),
                                    LocalRefDeleter(env_));
  rethrowException();
  va_end(args);
  return result;
}

LocalRefUniquePtr<jstring> JniHelper::newStringUtf(const char* str) {
  LocalRefUniquePtr<jstring> result(env_->NewStringUTF(str), LocalRefDeleter(env_));
  rethrowException();
  return result;
}

StringUtfUniquePtr JniHelper::getStringUtfChars(jstring str, jboolean* is_copy) {
  StringUtfUniquePtr result(env_->GetStringUTFChars(str, is_copy), StringUtfDeleter(env_, str));
  rethrowException();
  return result;
}

jsize JniHelper::getArrayLength(jarray array) { return env_->GetArrayLength(array); }

#define DEFINE_NEW_ARRAY(JAVA_TYPE, JNI_TYPE)                                                      \
  LocalRefUniquePtr<JNI_TYPE> JniHelper::new##JAVA_TYPE##Array(jsize length) {                     \
    LocalRefUniquePtr<JNI_TYPE> result(env_->New##JAVA_TYPE##Array(length),                        \
                                       LocalRefDeleter(env_));                                     \
    rethrowException();                                                                            \
    return result;                                                                                 \
  }

DEFINE_NEW_ARRAY(Byte, jbyteArray)
DEFINE_NEW_ARRAY(Char, jcharArray)
DEFINE_NEW_ARRAY(Short, jshortArray)
DEFINE_NEW_ARRAY(Int, jintArray)
DEFINE_NEW_ARRAY(Long, jlongArray)
DEFINE_NEW_ARRAY(Float, jfloatArray)
DEFINE_NEW_ARRAY(Double, jdoubleArray)
DEFINE_NEW_ARRAY(Boolean, jbooleanArray)

LocalRefUniquePtr<jobjectArray> JniHelper::newObjectArray(jsize length, jclass element_class,
                                                          jobject initial_element) {
  LocalRefUniquePtr<jobjectArray> result(
      env_->NewObjectArray(length, element_class, initial_element), LocalRefDeleter(env_));

  return result;
}

#define DEFINE_GET_ARRAY_ELEMENTS(JAVA_TYPE, JNI_ARRAY_TYPE, JNI_ELEMENT_TYPE)                     \
  ArrayElementsUniquePtr<JNI_ARRAY_TYPE, JNI_ELEMENT_TYPE>                                         \
      JniHelper::get##JAVA_TYPE##ArrayElements(JNI_ARRAY_TYPE array, jboolean* is_copy) {          \
    ArrayElementsUniquePtr<JNI_ARRAY_TYPE, JNI_ELEMENT_TYPE> result(                               \
        env_->Get##JAVA_TYPE##ArrayElements(array, is_copy),                                       \
        ArrayElementsDeleter<JNI_ARRAY_TYPE, JNI_ELEMENT_TYPE>(env_, array));                      \
    rethrowException();                                                                            \
    return result;                                                                                 \
  }

DEFINE_GET_ARRAY_ELEMENTS(Byte, jbyteArray, jbyte)
DEFINE_GET_ARRAY_ELEMENTS(Char, jcharArray, jchar)
DEFINE_GET_ARRAY_ELEMENTS(Short, jshortArray, jshort)
DEFINE_GET_ARRAY_ELEMENTS(Int, jintArray, jint)
DEFINE_GET_ARRAY_ELEMENTS(Long, jlongArray, jlong)
DEFINE_GET_ARRAY_ELEMENTS(Float, jfloatArray, jfloat)
DEFINE_GET_ARRAY_ELEMENTS(Double, jdoubleArray, jdouble)
DEFINE_GET_ARRAY_ELEMENTS(Boolean, jbooleanArray, jboolean)

void JniHelper::setObjectArrayElement(jobjectArray array, jsize index, jobject value) {
  env_->SetObjectArrayElement(array, index, value);
  rethrowException();
}

#define DEFINE_SET_ARRAY_REGION(JAVA_TYPE, JNI_ARRAY_TYPE, JNI_ELEMENT_TYPE)                       \
  void JniHelper::set##JAVA_TYPE##ArrayRegion(JNI_ARRAY_TYPE array, jsize start, jsize length,     \
                                              const JNI_ELEMENT_TYPE* buffer) {                    \
    env_->Set##JAVA_TYPE##ArrayRegion(array, start, length, buffer);                               \
    rethrowException();                                                                            \
  }

DEFINE_SET_ARRAY_REGION(Byte, jbyteArray, jbyte)
DEFINE_SET_ARRAY_REGION(Char, jcharArray, jchar)
DEFINE_SET_ARRAY_REGION(Short, jshortArray, jshort)
DEFINE_SET_ARRAY_REGION(Int, jintArray, jint)
DEFINE_SET_ARRAY_REGION(Long, jlongArray, jlong)
DEFINE_SET_ARRAY_REGION(Float, jfloatArray, jfloat)
DEFINE_SET_ARRAY_REGION(Double, jdoubleArray, jdouble)
DEFINE_SET_ARRAY_REGION(Boolean, jbooleanArray, jboolean)

#define DEFINE_CALL_METHOD(JAVA_TYPE, JNI_TYPE)                                                    \
  JNI_TYPE JniHelper::call##JAVA_TYPE##Method(jobject object, jmethodID method_id, ...) {          \
    va_list args;                                                                                  \
    va_start(args, method_id);                                                                     \
    JNI_TYPE result = env_->Call##JAVA_TYPE##MethodV(object, method_id, args);                     \
    va_end(args);                                                                                  \
    rethrowException();                                                                            \
    return result;                                                                                 \
  }

DEFINE_CALL_METHOD(Byte, jbyte)
DEFINE_CALL_METHOD(Char, jchar)
DEFINE_CALL_METHOD(Short, jshort)
DEFINE_CALL_METHOD(Int, jint)
DEFINE_CALL_METHOD(Long, jlong)
DEFINE_CALL_METHOD(Float, jfloat)
DEFINE_CALL_METHOD(Double, jdouble)
DEFINE_CALL_METHOD(Boolean, jboolean)

void JniHelper::callVoidMethod(jobject object, jmethodID method_id, ...) {
  va_list args;
  va_start(args, method_id);
  env_->CallVoidMethodV(object, method_id, args);
  va_end(args);
  rethrowException();
}

#define DEFINE_CALL_STATIC_METHOD(JAVA_TYPE, JNI_TYPE)                                             \
  JNI_TYPE JniHelper::callStatic##JAVA_TYPE##Method(jclass clazz, jmethodID method_id, ...) {      \
    va_list args;                                                                                  \
    va_start(args, method_id);                                                                     \
    JNI_TYPE result = env_->CallStatic##JAVA_TYPE##MethodV(clazz, method_id, args);                \
    va_end(args);                                                                                  \
    rethrowException();                                                                            \
    return result;                                                                                 \
  }

DEFINE_CALL_STATIC_METHOD(Byte, jbyte)
DEFINE_CALL_STATIC_METHOD(Char, jchar)
DEFINE_CALL_STATIC_METHOD(Short, jshort)
DEFINE_CALL_STATIC_METHOD(Int, jint)
DEFINE_CALL_STATIC_METHOD(Long, jlong)
DEFINE_CALL_STATIC_METHOD(Float, jfloat)
DEFINE_CALL_STATIC_METHOD(Double, jdouble)
DEFINE_CALL_STATIC_METHOD(Boolean, jboolean)

void JniHelper::callStaticVoidMethod(jclass clazz, jmethodID method_id, ...) {
  va_list args;
  va_start(args, method_id);
  env_->CallStaticVoidMethodV(clazz, method_id, args);
  va_end(args);
  rethrowException();
}

jlong JniHelper::getDirectBufferCapacity(jobject buffer) {
  return env_->GetDirectBufferCapacity(buffer);
}

void JniHelper::rethrowException() {
  if (env_->ExceptionCheck()) {
    auto throwable = exceptionOccurred();
    env_->ExceptionClear();
    env_->Throw(throwable.release());
  }
}

} // namespace JNI
} // namespace Envoy
#include "library/common/jni/android_jni_utility.h"

#include "source/common/common/assert.h"

#if defined(__ANDROID_API__)
#include "library/common/data/utility.h"
#include "library/common/jni/import/jni_import.h"
#include "library/common/jni/jni_support.h"
#include "library/common/jni/jni_utility.h"
#endif

namespace Envoy {
namespace JNI {

bool isCleartextPermitted(absl::string_view hostname) {
#if defined(__ANDROID_API__)
  envoy_data host = Envoy::Data::Utility::copyToBridgeData(hostname);
  JniHelper jni_helper(getEnv());
  LocalRefUniquePtr<jstring> java_host = envoyDataToJavaString(jni_helper, host);
  LocalRefUniquePtr<jclass> jcls_AndroidNetworkLibrary =
      findClass("io.envoyproxy.envoymobile.utilities.AndroidNetworkLibrary");
  jmethodID jmid_isCleartextTrafficPermitted = jni_helper.getStaticMethodId(
      jcls_AndroidNetworkLibrary.get(), "isCleartextTrafficPermitted", "(Ljava/lang/String;)Z");
  jboolean result = jni_helper.callStaticBooleanMethod(
      jcls_AndroidNetworkLibrary.get(), jmid_isCleartextTrafficPermitted, java_host.get());
  release_envoy_data(host);
  return result == JNI_TRUE;
#else
  UNREFERENCED_PARAMETER(hostname);
  return true;
#endif
}

void tagSocket(int ifd, int uid, int tag) {
#if defined(__ANDROID_API__)
  JniHelper jni_helper(getEnv());
  LocalRefUniquePtr<jclass> jcls_AndroidNetworkLibrary =
      findClass("io.envoyproxy.envoymobile.utilities.AndroidNetworkLibrary");
  jmethodID jmid_tagSocket =
      jni_helper.getStaticMethodId(jcls_AndroidNetworkLibrary.get(), "tagSocket", "(III)V");
  jni_helper.callStaticVoidMethod(jcls_AndroidNetworkLibrary.get(), jmid_tagSocket, ifd, uid, tag);
#else
  UNREFERENCED_PARAMETER(ifd);
  UNREFERENCED_PARAMETER(uid);
  UNREFERENCED_PARAMETER(tag);
#endif
}

} // namespace JNI
} // namespace Envoy
#include "library/common/jni/jni_support.h"

// NOLINT(namespace-envoy)

int jni_log_fmt(const char* /*tag*/, const char* /*fmt*/, void* /*value*/) { return 0; }

int jni_log(const char* /*tag*/, const char* /*str*/) { return 0; }

jint attach_jvm(JavaVM* vm, JNIEnv** p_env, void* thr_args) {
  return vm->AttachCurrentThread(reinterpret_cast<void**>(p_env), thr_args);
}
#include "library/common/jni/jni_utility.h"

#include <cstdlib>
#include <cstring>

#include "source/common/common/assert.h"

#include "library/common/jni/jni_support.h"
#include "library/common/jni/types/env.h"
#include "library/common/jni/types/exception.h"

namespace Envoy {
namespace JNI {

static jobject static_class_loader = nullptr;

void setClassLoader(jobject class_loader) { static_class_loader = class_loader; }

jobject getClassLoader() {
  RELEASE_ASSERT(static_class_loader,
                 "findClass() is used before calling AndroidJniLibrary.load()");
  return static_class_loader;
}

LocalRefUniquePtr<jclass> findClass(const char* class_name) {
  JniHelper jni_helper(getEnv());
  LocalRefUniquePtr<jclass> class_loader = jni_helper.findClass("java/lang/ClassLoader");
  jmethodID find_class_method = jni_helper.getMethodId(class_loader.get(), "loadClass",
                                                       "(Ljava/lang/String;)Ljava/lang/Class;");
  LocalRefUniquePtr<jstring> str_class_name = jni_helper.newStringUtf(class_name);
  LocalRefUniquePtr<jclass> clazz = jni_helper.callObjectMethod<jclass>(
      getClassLoader(), find_class_method, str_class_name.get());
  return clazz;
}

JNIEnv* getEnv() { return Envoy::JNI::Env::get(); }

void jniDeleteGlobalRef(void* context) {
  JNIEnv* env = getEnv();
  jobject ref = static_cast<jobject>(context);
  env->DeleteGlobalRef(ref);
}

void jniDeleteConstGlobalRef(const void* context) {
  jniDeleteGlobalRef(const_cast<void*>(context));
}

int javaIntegerTotInt(JniHelper& jni_helper, jobject boxed_integer) {
  LocalRefUniquePtr<jclass> jcls_Integer = jni_helper.findClass("java/lang/Integer");
  jmethodID jmid_intValue = jni_helper.getMethodId(jcls_Integer.get(), "intValue", "()I");
  return jni_helper.callIntMethod(boxed_integer, jmid_intValue);
}

envoy_data javaByteArrayToEnvoyData(JniHelper& jni_helper, jbyteArray j_data) {
  size_t data_length = static_cast<size_t>(jni_helper.getArrayLength(j_data));
  return javaByteArrayToEnvoyData(jni_helper, j_data, data_length);
}

envoy_data javaByteArrayToEnvoyData(JniHelper& jni_helper, jbyteArray j_data, size_t data_length) {
  uint8_t* native_bytes = static_cast<uint8_t*>(safe_malloc(data_length));
  Envoy::JNI::PrimitiveArrayCriticalUniquePtr<void> critical_data =
      jni_helper.getPrimitiveArrayCritical(j_data, nullptr);
  memcpy(native_bytes, critical_data.get(), data_length); // NOLINT(safe-memcpy)
  return {data_length, native_bytes, free, native_bytes};
}

LocalRefUniquePtr<jstring> envoyDataToJavaString(JniHelper& jni_helper, envoy_data data) {
  // Ensure we get a null-terminated string, the data coming in via envoy_data might not be.
  std::string str(reinterpret_cast<const char*>(data.bytes), data.length);
  return jni_helper.newStringUtf(str.c_str());
}

LocalRefUniquePtr<jbyteArray> envoyDataToJavaByteArray(JniHelper& jni_helper, envoy_data data) {
  LocalRefUniquePtr<jbyteArray> j_data = jni_helper.newByteArray(data.length);
  PrimitiveArrayCriticalUniquePtr<void> critical_data =
      jni_helper.getPrimitiveArrayCritical(j_data.get(), nullptr);
  RELEASE_ASSERT(critical_data != nullptr, "unable to allocate memory in jni_utility");
  memcpy(critical_data.get(), data.bytes, data.length); // NOLINT(safe-memcpy)
  return j_data;
}

LocalRefUniquePtr<jlongArray> envoyStreamIntelToJavaLongArray(JniHelper& jni_helper,
                                                              envoy_stream_intel stream_intel) {
  LocalRefUniquePtr<jlongArray> j_array = jni_helper.newLongArray(4);
  PrimitiveArrayCriticalUniquePtr<jlong> critical_array =
      jni_helper.getPrimitiveArrayCritical<jlong*>(j_array.get(), nullptr);
  RELEASE_ASSERT(critical_array != nullptr, "unable to allocate memory in jni_utility");
  critical_array.get()[0] = static_cast<jlong>(stream_intel.stream_id);
  critical_array.get()[1] = static_cast<jlong>(stream_intel.connection_id);
  critical_array.get()[2] = static_cast<jlong>(stream_intel.attempt_count);
  critical_array.get()[3] = static_cast<jlong>(stream_intel.consumed_bytes_from_response);
  return j_array;
}

LocalRefUniquePtr<jlongArray>
envoyFinalStreamIntelToJavaLongArray(JniHelper& jni_helper,
                                     envoy_final_stream_intel final_stream_intel) {
  LocalRefUniquePtr<jlongArray> j_array = jni_helper.newLongArray(16);
  PrimitiveArrayCriticalUniquePtr<jlong> critical_array =
      jni_helper.getPrimitiveArrayCritical<jlong*>(j_array.get(), nullptr);
  RELEASE_ASSERT(critical_array != nullptr, "unable to allocate memory in jni_utility");

  critical_array.get()[0] = static_cast<jlong>(final_stream_intel.stream_start_ms);
  critical_array.get()[1] = static_cast<jlong>(final_stream_intel.dns_start_ms);
  critical_array.get()[2] = static_cast<jlong>(final_stream_intel.dns_end_ms);
  critical_array.get()[3] = static_cast<jlong>(final_stream_intel.connect_start_ms);
  critical_array.get()[4] = static_cast<jlong>(final_stream_intel.connect_end_ms);
  critical_array.get()[5] = static_cast<jlong>(final_stream_intel.ssl_start_ms);
  critical_array.get()[6] = static_cast<jlong>(final_stream_intel.ssl_end_ms);
  critical_array.get()[7] = static_cast<jlong>(final_stream_intel.sending_start_ms);
  critical_array.get()[8] = static_cast<jlong>(final_stream_intel.sending_end_ms);
  critical_array.get()[9] = static_cast<jlong>(final_stream_intel.response_start_ms);
  critical_array.get()[10] = static_cast<jlong>(final_stream_intel.stream_end_ms);
  critical_array.get()[11] = static_cast<jlong>(final_stream_intel.socket_reused);
  critical_array.get()[12] = static_cast<jlong>(final_stream_intel.sent_byte_count);
  critical_array.get()[13] = static_cast<jlong>(final_stream_intel.received_byte_count);
  critical_array.get()[14] = static_cast<jlong>(final_stream_intel.response_flags);
  critical_array.get()[15] = static_cast<jlong>(final_stream_intel.upstream_protocol);
  return j_array;
}

LocalRefUniquePtr<jobject> envoyMapToJavaMap(JniHelper& jni_helper, envoy_map map) {
  LocalRefUniquePtr<jclass> jcls_hashMap = jni_helper.findClass("java/util/HashMap");
  jmethodID jmid_hashMapInit = jni_helper.getMethodId(jcls_hashMap.get(), "<init>", "(I)V");
  LocalRefUniquePtr<jobject> j_hashMap =
      jni_helper.newObject(jcls_hashMap.get(), jmid_hashMapInit, map.length);
  jmethodID jmid_hashMapPut = jni_helper.getMethodId(
      jcls_hashMap.get(), "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
  for (envoy_map_size_t i = 0; i < map.length; i++) {
    LocalRefUniquePtr<jstring> key = envoyDataToJavaString(jni_helper, map.entries[i].key);
    LocalRefUniquePtr<jstring> value = envoyDataToJavaString(jni_helper, map.entries[i].value);
    LocalRefUniquePtr<jobject> ignored =
        jni_helper.callObjectMethod(j_hashMap.get(), jmid_hashMapPut, key.get(), value.get());
  }
  return j_hashMap;
}

envoy_data javaByteBufferToEnvoyData(JniHelper& jni_helper, jobject j_data) {
  // Returns -1 if the buffer is not a direct buffer.
  jlong data_length = jni_helper.getDirectBufferCapacity(j_data);

  if (data_length < 0) {
    LocalRefUniquePtr<jclass> jcls_ByteBuffer = jni_helper.findClass("java/nio/ByteBuffer");
    // We skip checking hasArray() because only direct ByteBuffers or array-backed ByteBuffers
    // are supported. We will crash here if this is an invalid buffer, but guards may be
    // implemented in the JVM layer.
    jmethodID jmid_array = jni_helper.getMethodId(jcls_ByteBuffer.get(), "array", "()[B");
    LocalRefUniquePtr<jbyteArray> array =
        jni_helper.callObjectMethod<jbyteArray>(j_data, jmid_array);
    envoy_data native_data = javaByteArrayToEnvoyData(jni_helper, array.get());
    return native_data;
  }

  return javaByteBufferToEnvoyData(jni_helper, j_data, static_cast<size_t>(data_length));
}

envoy_data javaByteBufferToEnvoyData(JniHelper& jni_helper, jobject j_data, size_t data_length) {
  // Returns nullptr if the buffer is not a direct buffer.
  uint8_t* direct_address = jni_helper.getDirectBufferAddress<uint8_t*>(j_data);

  if (direct_address == nullptr) {
    LocalRefUniquePtr<jclass> jcls_ByteBuffer = jni_helper.findClass("java/nio/ByteBuffer");
    // We skip checking hasArray() because only direct ByteBuffers or array-backed ByteBuffers
    // are supported. We will crash here if this is an invalid buffer, but guards may be
    // implemented in the JVM layer.
    jmethodID jmid_array = jni_helper.getMethodId(jcls_ByteBuffer.get(), "array", "()[B");
    LocalRefUniquePtr<jbyteArray> array =
        jni_helper.callObjectMethod<jbyteArray>(j_data, jmid_array);
    envoy_data native_data = javaByteArrayToEnvoyData(jni_helper, array.get(), data_length);
    return native_data;
  }

  envoy_data native_data;
  native_data.bytes = direct_address;
  native_data.length = data_length;
  native_data.release = jniDeleteGlobalRef;
  native_data.context = jni_helper.newGlobalRef(j_data).release();

  return native_data;
}

envoy_data* javaByteBufferToEnvoyDataPtr(JniHelper& jni_helper, jobject j_data) {
  // Note: This check works for LocalRefs and GlobalRefs, but will not work for WeakGlobalRefs.
  // Such usage would generally be inappropriate anyways; like C++ weak_ptrs, one should
  // acquire a new strong reference before attempting to interact with an object held by
  // a WeakGlobalRef. See:
  // https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#weak
  if (j_data == nullptr) {
    return nullptr;
  }

  envoy_data* native_data = static_cast<envoy_data*>(safe_malloc(sizeof(envoy_map_entry)));
  *native_data = javaByteBufferToEnvoyData(jni_helper, j_data);
  return native_data;
}

envoy_headers javaArrayOfObjectArrayToEnvoyHeaders(JniHelper& jni_helper, jobjectArray headers) {
  return javaArrayOfObjectArrayToEnvoyMap(jni_helper, headers);
}

envoy_headers* javaArrayOfObjectArrayToEnvoyHeadersPtr(JniHelper& jni_helper,
                                                       jobjectArray headers) {
  // Note: This check works for LocalRefs and GlobalRefs, but will not work for WeakGlobalRefs.
  // Such usage would generally be inappropriate anyways; like C++ weak_ptrs, one should
  // acquire a new strong reference before attempting to interact with an object held by
  // a WeakGlobalRef. See:
  // https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#weak
  if (headers == nullptr) {
    return nullptr;
  }

  envoy_headers* native_headers = static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_map_entry)));
  *native_headers = javaArrayOfObjectArrayToEnvoyHeaders(jni_helper, headers);
  return native_headers;
}

envoy_stats_tags javaArrayOfObjectArrayToEnvoyStatsTags(JniHelper& jni_helper, jobjectArray tags) {
  return javaArrayOfObjectArrayToEnvoyMap(jni_helper, tags);
}

envoy_map javaArrayOfObjectArrayToEnvoyMap(JniHelper& jni_helper, jobjectArray entries) {
  // Note that headers is a flattened array of key/value pairs.
  // Therefore, the length of the native header array is n envoy_data or n/2 envoy_map_entry.
  envoy_map_size_t length = jni_helper.getArrayLength(entries);
  if (length == 0) {
    return {0, nullptr};
  }

  envoy_map_entry* entry_array =
      static_cast<envoy_map_entry*>(safe_malloc(sizeof(envoy_map_entry) * length / 2));

  for (envoy_map_size_t i = 0; i < length; i += 2) {
    // Copy native byte array for header key
    LocalRefUniquePtr<jbyteArray> j_key = jni_helper.getObjectArrayElement<jbyteArray>(entries, i);
    envoy_data entry_key = javaByteArrayToEnvoyData(jni_helper, j_key.get());

    // Copy native byte array for header value
    LocalRefUniquePtr<jbyteArray> j_value =
        jni_helper.getObjectArrayElement<jbyteArray>(entries, i + 1);
    envoy_data entry_value = javaByteArrayToEnvoyData(jni_helper, j_value.get());

    entry_array[i / 2] = {entry_key, entry_value};
  }

  envoy_map native_map = {length / 2, entry_array};
  return native_map;
}

LocalRefUniquePtr<jobjectArray>
envoyHeadersToJavaArrayOfObjectArray(JniHelper& jni_helper,
                                     const Envoy::Types::ManagedEnvoyHeaders& map) {
  LocalRefUniquePtr<jclass> jcls_byte_array = jni_helper.findClass("java/lang/Object");
  LocalRefUniquePtr<jobjectArray> javaArray =
      jni_helper.newObjectArray(2 * map.get().length, jcls_byte_array.get(), nullptr);

  for (envoy_map_size_t i = 0; i < map.get().length; i++) {
    LocalRefUniquePtr<jbyteArray> key =
        envoyDataToJavaByteArray(jni_helper, map.get().entries[i].key);
    LocalRefUniquePtr<jbyteArray> value =
        envoyDataToJavaByteArray(jni_helper, map.get().entries[i].value);

    jni_helper.setObjectArrayElement(javaArray.get(), 2 * i, key.get());
    jni_helper.setObjectArrayElement(javaArray.get(), 2 * i + 1, value.get());
  }

  return javaArray;
}

LocalRefUniquePtr<jobjectArray>
vectorStringToJavaArrayOfByteArray(JniHelper& jni_helper, const std::vector<std::string>& v) {
  LocalRefUniquePtr<jclass> jcls_byte_array = jni_helper.findClass("[B");
  LocalRefUniquePtr<jobjectArray> joa =
      jni_helper.newObjectArray(v.size(), jcls_byte_array.get(), nullptr);

  for (size_t i = 0; i < v.size(); ++i) {
    LocalRefUniquePtr<jbyteArray> byte_array = byteArrayToJavaByteArray(
        jni_helper, reinterpret_cast<const uint8_t*>(v[i].data()), v[i].length());
    jni_helper.setObjectArrayElement(joa.get(), i, byte_array.get());
  }
  return joa;
}

LocalRefUniquePtr<jbyteArray> byteArrayToJavaByteArray(JniHelper& jni_helper, const uint8_t* bytes,
                                                       size_t len) {
  LocalRefUniquePtr<jbyteArray> byte_array = jni_helper.newByteArray(len);
  const jbyte* jbytes = reinterpret_cast<const jbyte*>(bytes);
  jni_helper.setByteArrayRegion(byte_array.get(), /*start=*/0, len, jbytes);
  return byte_array;
}

LocalRefUniquePtr<jbyteArray> stringToJavaByteArray(JniHelper& jni_helper, const std::string& str) {
  const uint8_t* str_bytes = reinterpret_cast<const uint8_t*>(str.data());
  return byteArrayToJavaByteArray(jni_helper, str_bytes, str.size());
}

void javaArrayOfByteArrayToStringVector(JniHelper& jni_helper, jobjectArray array,
                                        std::vector<std::string>* out) {
  ASSERT(out);
  ASSERT(array);
  size_t len = jni_helper.getArrayLength(array);
  out->resize(len);

  for (size_t i = 0; i < len; ++i) {
    LocalRefUniquePtr<jbyteArray> bytes_array =
        jni_helper.getObjectArrayElement<jbyteArray>(array, i);
    jsize bytes_len = jni_helper.getArrayLength(bytes_array.get());
    // It doesn't matter if the array returned by GetByteArrayElements is a copy
    // or not, as the data will be simply be copied into C++ owned memory below.
    ArrayElementsUniquePtr<jbyteArray, jbyte> bytes =
        jni_helper.getByteArrayElements(bytes_array.get(), /* is_copy= */ nullptr);
    (*out)[i].assign(reinterpret_cast<const char*>(bytes.get()), bytes_len);
  }
}

void javaByteArrayToString(JniHelper& jni_helper, jbyteArray jbytes, std::string* out) {
  std::vector<uint8_t> bytes;
  javaByteArrayToByteVector(jni_helper, jbytes, &bytes);
  *out = std::string(bytes.begin(), bytes.end());
}

void javaByteArrayToByteVector(JniHelper& jni_helper, jbyteArray array, std::vector<uint8_t>* out) {
  const size_t len = jni_helper.getArrayLength(array);
  out->resize(len);

  // It doesn't matter if the array returned by GetByteArrayElements is a copy
  // or not, as the data will be simply be copied into C++ owned memory below.
  ArrayElementsUniquePtr<jbyteArray, jbyte> jbytes =
      jni_helper.getByteArrayElements(array, /* is_copy= */ nullptr);
  uint8_t* bytes = reinterpret_cast<uint8_t*>(jbytes.get());
  std::copy(bytes, bytes + len, out->begin());
}

MatcherData::Type StringToType(std::string type_as_string) {
  if (type_as_string.length() != 4) {
    ASSERT("conversion failure failure");
    return MatcherData::EXACT;
  }
  // grab the lowest bit.
  switch (type_as_string[3]) {
  case 0:
    return MatcherData::EXACT;
  case 1:
    return MatcherData::SAFE_REGEX;
  }
  ASSERT("enum failure");
  return MatcherData::EXACT;
}

void javaByteArrayToProto(JniHelper& jni_helper, jbyteArray source,
                          Envoy::Protobuf::MessageLite* dest) {
  ArrayElementsUniquePtr<jbyteArray, jbyte> bytes =
      jni_helper.getByteArrayElements(source, /* is_copy= */ nullptr);
  jsize size = jni_helper.getArrayLength(source);
  bool success = dest->ParseFromArray(bytes.get(), size);
  RELEASE_ASSERT(success, "Failed to parse protobuf message.");
}

LocalRefUniquePtr<jbyteArray> protoToJavaByteArray(JniHelper& jni_helper,
                                                   const Envoy::Protobuf::MessageLite& source) {
  size_t size = source.ByteSizeLong();
  LocalRefUniquePtr<jbyteArray> byte_array = jni_helper.newByteArray(size);
  auto bytes = jni_helper.getByteArrayElements(byte_array.get(), nullptr);
  source.SerializeToArray(bytes.get(), size);
  return byte_array;
}

std::string javaStringToString(JniHelper& jni_helper, jstring java_string) {
  if (!java_string) {
    return "";
  }
  StringUtfUniquePtr native_java_string = jni_helper.getStringUtfChars(java_string, nullptr);
  std::string cpp_string(native_java_string.get());
  return cpp_string;
}

} // namespace JNI
} // namespace Envoy
#pragma once

#include <string>
#include <vector>

#include "absl/strings/string_view.h"
#include "library/common/api/c_types.h"
#include "library/common/extensions/cert_validator/platform_bridge/c_types.h"
#include "library/common/jni/import/jni_import.h"
#include "library/common/jni/jni_helper.h"

namespace Envoy {
namespace JNI {

/**
 * Calls up through JNI to validate given certificates.
 */
LocalRefUniquePtr<jobject> callJvmVerifyX509CertChain(JniHelper& jni_helper,
                                                      const std::vector<std::string>& cert_chain,
                                                      std::string auth_type,
                                                      absl::string_view hostname);

envoy_cert_validation_result verifyX509CertChain(const std::vector<std::string>& certs,
                                                 absl::string_view hostname);

void jvmDetachThread();

} // namespace JNI
} // namespace Envoy
#include <android/log.h>

#include "library/common/jni/jni_support.h"

// NOLINT(namespace-envoy)

int jni_log_fmt(const char* /*tag*/, const char* /*fmt*/, void* /*value*/) {
  // For debug logging, use __android_log_print(ANDROID_LOG_VERBOSE, tag, fmt, value);
  return 0;
}

int jni_log(const char* /*tag*/, const char* /*str*/) {
  // For debug logging, use __android_log_write(ANDROID_LOG_VERBOSE, tag, str);
  return 0;
}

jint attach_jvm(JavaVM* vm, JNIEnv** p_env, void* thr_args) {
  return vm->AttachCurrentThread(p_env, thr_args);
}
#pragma once

#include "absl/strings/string_view.h"

namespace Envoy {
namespace JNI {

/**
 * For android, calls up through JNI to see if cleartext is permitted for this host.
 * For other platforms simply returns true.
 */
bool isCleartextPermitted(absl::string_view hostname);

/**
 * For android, calls up through JNI to apply host. For other platforms simply returns true.
 */
void tagSocket(int ifd, int uid, int tag);

} // namespace JNI
} // namespace Envoy
#pragma once

#include <string>
#include <vector>

#include "source/common/protobuf/protobuf.h"

#include "library/common/jni/import/jni_import.h"
#include "library/common/jni/jni_helper.h"
#include "library/common/types/c_types.h"
#include "library/common/types/managed_envoy_headers.h"
#include "library/common/types/matcher_data.h"

namespace Envoy {
namespace JNI {

// TODO(Augustyniak): Replace the usages of this global method with Envoy::JNI::Env::get()
JNIEnv* getEnv();

void setClassLoader(jobject class_loader);

/**
 * Finds a class with a given name using a class loader provided with the use
 * of `setClassLoader` function. The class loader is supposed to come from
 * application's context and should be associated with project's code - Java classes
 * defined by the project. For finding classes of Java built in-types use
 * `env->FindClass(...)` method instead as it is lighter to use.
 *
 * Read more about why you cannot use `env->FindClass(...)` to look for Java classes
 * defined by the project and a pattern used by the implementation of `findClass` helper
 * method at https://developer.android.com/training/articles/perf-jni#native-libraries.
 *
 * The method works on Android targets only as the `setClassLoader` method is not
 * called by JVM-only targets.
 *
 * @param class_name, the name of the class to find (i.e.
 * "io.envoyproxy.envoymobile.utilities.AndroidNetworkLibrary").
 *
 * @return jclass, the class with a provided `class_name` or NULL if
 *         it couldn't be found.
 */
LocalRefUniquePtr<jclass> findClass(const char* class_name);

void jniDeleteGlobalRef(void* context);

void jniDeleteConstGlobalRef(const void* context);

/** Converts `java.lang.Integer` to C++ `int`. */
int javaIntegerTotInt(JniHelper& jni_helper, jobject boxed_integer);

/** Converts from Java byte array to `envoy_data`. */
envoy_data javaByteArrayToEnvoyData(JniHelper& jni_helper, jbyteArray j_data);

/** Converts from Java byte array with the specified length to `envoy_data`. */
envoy_data javaByteArrayToEnvoyData(JniHelper& jni_helper, jbyteArray j_data, size_t data_length);

/** Converts from `envoy_data` to Java byte array. */
LocalRefUniquePtr<jbyteArray> envoyDataToJavaByteArray(JniHelper& jni_helper, envoy_data data);

/** Converts from `envoy_stream_intel` to Java long array. */
LocalRefUniquePtr<jlongArray> envoyStreamIntelToJavaLongArray(JniHelper& jni_helper,
                                                              envoy_stream_intel stream_intel);

/** Converts from `envoy_final_stream_intel` to Java long array. */
LocalRefUniquePtr<jlongArray>
envoyFinalStreamIntelToJavaLongArray(JniHelper& jni_helper,
                                     envoy_final_stream_intel final_stream_intel);

/** Converts from Java `Map` to `envoy_map`. */
LocalRefUniquePtr<jobject> envoyMapToJavaMap(JniHelper& jni_helper, envoy_map map);

/** Converts from `envoy_data` to Java `String`. */
LocalRefUniquePtr<jstring> envoyDataToJavaString(JniHelper& jni_helper, envoy_data data);

/** Converts from Java `ByteBuffer` to `envoy_data`. */
envoy_data javaByteBufferToEnvoyData(JniHelper& jni_helper, jobject j_data);

/** Converts from Java `ByteBuffer` to `envoy_data` with the given length. */
envoy_data javaByteBufferToEnvoyData(JniHelper& jni_helper, jobject j_data, size_t data_length);

/** Returns the pointer of conversion from Java `ByteBuffer` to `envoy_data`. */
envoy_data* javaByteBufferToEnvoyDataPtr(JniHelper& jni_helper, jobject j_data);

/** Converts from Java array of object array[2] (key-value pairs) to `envoy_headers`. */
envoy_headers javaArrayOfObjectArrayToEnvoyHeaders(JniHelper& jni_helper, jobjectArray headers);

/** Returns the pointer of conversion from Java array of object array[2] (key-value pairs) to
 * `envoy_headers`. */
envoy_headers* javaArrayOfObjectArrayToEnvoyHeadersPtr(JniHelper& jni_helper, jobjectArray headers);

/** Converts from Java array of object array[2] (key-value pairs) to `envoy_stats_tags`. */
envoy_stats_tags javaArrayOfObjectArrayToEnvoyStatsTags(JniHelper& jni_helper, jobjectArray tags);

/** Converts from Java array of object array[2] (key-value pairs) to `envoy_map`. */
envoy_map javaArrayOfObjectArrayToEnvoyMap(JniHelper& jni_helper, jobjectArray entries);

/** Converts from `ManagedEnvoyHeaders` to Java array of object array[2] (key-value pairs). */
LocalRefUniquePtr<jobjectArray>
envoyHeadersToJavaArrayOfObjectArray(JniHelper& jni_helper,
                                     const Envoy::Types::ManagedEnvoyHeaders& map);

/** Converts from C++ vector of strings to Java array of byte array. */
LocalRefUniquePtr<jobjectArray>
vectorStringToJavaArrayOfByteArray(JniHelper& jni_helper, const std::vector<std::string>& v);

/** Converts from C++ byte array to Java byte array. */
LocalRefUniquePtr<jbyteArray> byteArrayToJavaByteArray(JniHelper& jni_helper, const uint8_t* bytes,
                                                       size_t len);

/** Converts from C++ string to Java byte array. */
LocalRefUniquePtr<jbyteArray> stringToJavaByteArray(JniHelper& jni_helper, const std::string& str);

/** Converts from Java array of byte array to C++ vector of strings. */
void javaArrayOfByteArrayToStringVector(JniHelper& jni_helper, jobjectArray array,
                                        std::vector<std::string>* out);

/** Converts from Java byte array to C++ vector of bytes. */
void javaByteArrayToByteVector(JniHelper& jni_helper, jbyteArray array, std::vector<uint8_t>* out);

/** Converts from Java byte array to C++ string. */
void javaByteArrayToString(JniHelper& jni_helper, jbyteArray jbytes, std::string* out);

/** Parses the proto from Java byte array and stores the output into `dest` proto. */
void javaByteArrayToProto(JniHelper& jni_helper, jbyteArray source,
                          Envoy::Protobuf::MessageLite* dest);

/** Converts from Proto to Java byte array. */
LocalRefUniquePtr<jbyteArray> protoToJavaByteArray(JniHelper& jni_helper,
                                                   const Envoy::Protobuf::MessageLite& source);

/** Converts from Java `String` to C++ string. */
std::string javaStringToString(JniHelper& jni_helper, jstring java_string);

} // namespace JNI
} // namespace Envoy
#pragma once

#include <memory>

#include "library/common/jni/import/jni_import.h"

namespace Envoy {
namespace JNI {

/** A custom deleter to delete JNI global ref. */
class GlobalRefDeleter {
public:
  explicit GlobalRefDeleter(JNIEnv* env) : env_(env) {}

  void operator()(jobject object) const {
    if (object != nullptr) {
      env_->DeleteGlobalRef(object);
    }
  }

private:
  JNIEnv* const env_;
};

/** A unique pointer for JNI global ref. */
template <typename T>
using GlobalRefUniquePtr = std::unique_ptr<typename std::remove_pointer<T>::type, GlobalRefDeleter>;

/** A custom deleter to delete JNI local ref. */
class LocalRefDeleter {
public:
  explicit LocalRefDeleter(JNIEnv* env) : env_(env) {}

  LocalRefDeleter(const LocalRefDeleter&) = default;

  // This is to allow move semantics in `LocalRefUniquePtr`.
  LocalRefDeleter& operator=(const LocalRefDeleter&) { return *this; }

  void operator()(jobject object) const {
    if (object != nullptr) {
      env_->DeleteLocalRef(object);
    }
  }

private:
  JNIEnv* const env_;
};

/** A unique pointer for JNI local ref. */
template <typename T>
using LocalRefUniquePtr = std::unique_ptr<typename std::remove_pointer<T>::type, LocalRefDeleter>;

/** A custom deleter for UTF strings. */
class StringUtfDeleter {
public:
  StringUtfDeleter(JNIEnv* env, jstring j_str) : env_(env), j_str_(j_str) {}

  void operator()(const char* c_str) const {
    if (c_str != nullptr) {
      env_->ReleaseStringUTFChars(j_str_, c_str);
    }
  }

private:
  JNIEnv* const env_;
  jstring j_str_;
};

/** A unique pointer for JNI UTF string. */
using StringUtfUniquePtr = std::unique_ptr<const char, StringUtfDeleter>;

/** A custom deleter to delete JNI array elements. */
template <typename ArrayType, typename ElementType> class ArrayElementsDeleter {
public:
  ArrayElementsDeleter(JNIEnv* env, ArrayType array) : env_(env), array_(array) {}

  void operator()(ElementType* elements) const {
    if (elements == nullptr) {
      return;
    }
    if constexpr (std::is_same_v<ElementType, jbyte>) {
      env_->ReleaseByteArrayElements(array_, elements, 0);
    } else if constexpr (std::is_same_v<ElementType, jchar>) {
      env_->ReleaseCharArrayElements(array_, elements, 0);
    } else if constexpr (std::is_same_v<ElementType, jshort>) {
      env_->ReleaseShortArrayElements(array_, elements, 0);
    } else if constexpr (std::is_same_v<ElementType, jint>) {
      env_->ReleaseIntArrayElements(array_, elements, 0);
    } else if constexpr (std::is_same_v<ElementType, jlong>) {
      env_->ReleaseLongArrayElements(array_, elements, 0);
    } else if constexpr (std::is_same_v<ElementType, jfloat>) {
      env_->ReleaseFloatArrayElements(array_, elements, 0);
    } else if constexpr (std::is_same_v<ElementType, jdouble>) {
      env_->ReleaseDoubleArrayElements(array_, elements, 0);
    } else if constexpr (std::is_same_v<ElementType, jboolean>) {
      env_->ReleaseBooleanArrayElements(array_, elements, 0);
    }
  }

private:
  JNIEnv* const env_;
  ArrayType array_;
};

/** A unique pointer for JNI array elements. */
template <typename ArrayType, typename ElementType>
using ArrayElementsUniquePtr = std::unique_ptr<
    typename std::remove_pointer<ElementType>::type,
    ArrayElementsDeleter<ArrayType, typename std::remove_pointer<ElementType>::type>>;

/** A custom deleter for JNI primitive array critical. */
class PrimitiveArrayCriticalDeleter {
public:
  PrimitiveArrayCriticalDeleter(JNIEnv* env, jarray array) : env_(env), array_(array) {}

  void operator()(void* c_array) const {
    if (c_array != nullptr) {
      env_->ReleasePrimitiveArrayCritical(array_, c_array, 0);
    }
  }

private:
  JNIEnv* const env_;
  jarray array_;
};

/** A unique pointer for JNI primitive array critical. */
template <typename T>
using PrimitiveArrayCriticalUniquePtr =
    std::unique_ptr<typename std::remove_pointer<T>::type, PrimitiveArrayCriticalDeleter>;

/**
 * A thin wrapper around JNI API with automatic memory management.
 *
 * NOTE: Do not put any other helper functions that are not part of the JNI API here.
 */
class JniHelper {
public:
  explicit JniHelper(JNIEnv* env) : env_(env) {}

  /** Gets the underlying `JNIEnv`. */
  JNIEnv* getEnv();

  /**
   * Gets the object method with the given signature.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#getmethodid
   */
  jmethodID getMethodId(jclass clazz, const char* name, const char* signature);

  /**
   * Gets the static method with the given signature.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#getstaticmethodid
   */
  jmethodID getStaticMethodId(jclass clazz, const char* name, const char* signature);

  /**
   * Finds the given `class_name` using Java classloader.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#findclass
   */
  [[nodiscard]] LocalRefUniquePtr<jclass> findClass(const char* class_name);

  /**
   * Returns the class of a given `object`.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#getobjectclass
   */
  [[nodiscard]] LocalRefUniquePtr<jclass> getObjectClass(jobject object);

  /**
   * Throws Java exception with the specified class name and error message.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#thrownew
   */
  void throwNew(const char* java_class_name, const char* message);

  /**
   * Determines if an exception is being thrown.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#exceptionoccurred
   */
  [[nodiscard]] LocalRefUniquePtr<jthrowable> exceptionOccurred();

  /**
   * Creates a new global reference to the object referred to by the `object` argument.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#newglobalref
   */
  [[nodiscard]] GlobalRefUniquePtr<jobject> newGlobalRef(jobject object);

  /**
   * Creates a new instance of a given `clazz` from the given `method_id`.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#newobject-newobjecta-newobjectv
   */
  [[nodiscard]] LocalRefUniquePtr<jobject> newObject(jclass clazz, jmethodID method_id, ...);

  /**
   * Creates a new Java string from the given `str`.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#newstringutf
   */
  [[nodiscard]] LocalRefUniquePtr<jstring> newStringUtf(const char* str);

  /** Gets the pointer to an array of bytes representing `str`. */
  [[nodiscard]] StringUtfUniquePtr getStringUtfChars(jstring str, jboolean* is_copy);

  /**
   * Gets the size of the array.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#getarraylength
   */
  jsize getArrayLength(jarray array);

/** A macro to create `New<Type>Array`. helper function. */
#define DECLARE_NEW_ARRAY(JAVA_TYPE, JNI_TYPE)                                                     \
  [[nodiscard]] LocalRefUniquePtr<JNI_TYPE> new##JAVA_TYPE##Array(jsize length);

  /**
   * Helper functions for `New<Type>Array`.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#newprimitivetypearray-routines
   */
  DECLARE_NEW_ARRAY(Byte, jbyteArray)
  DECLARE_NEW_ARRAY(Char, jcharArray)
  DECLARE_NEW_ARRAY(Short, jshortArray)
  DECLARE_NEW_ARRAY(Int, jintArray)
  DECLARE_NEW_ARRAY(Long, jlongArray)
  DECLARE_NEW_ARRAY(Float, jfloatArray)
  DECLARE_NEW_ARRAY(Double, jdoubleArray)
  DECLARE_NEW_ARRAY(Boolean, jbooleanArray)
  [[nodiscard]] LocalRefUniquePtr<jobjectArray> newObjectArray(jsize length, jclass element_class,
                                                               jobject initial_element = nullptr);

/** A macro to create `Get<JavaType>ArrayElement` function. */
#define DECLARE_GET_ARRAY_ELEMENTS(JAVA_TYPE, JNI_ARRAY_TYPE, JNI_ELEMENT_TYPE)                    \
  [[nodiscard]] ArrayElementsUniquePtr<JNI_ARRAY_TYPE, JNI_ELEMENT_TYPE>                           \
      get##JAVA_TYPE##ArrayElements(JNI_ARRAY_TYPE array, jboolean* is_copy);

  /**
   * Helper functions for `Get<JavaType>ArrayElements`.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#getprimitivetypearrayelements-routines
   */
  DECLARE_GET_ARRAY_ELEMENTS(Byte, jbyteArray, jbyte)
  DECLARE_GET_ARRAY_ELEMENTS(Char, jcharArray, jchar)
  DECLARE_GET_ARRAY_ELEMENTS(Short, jshortArray, jshort)
  DECLARE_GET_ARRAY_ELEMENTS(Int, jintArray, jint)
  DECLARE_GET_ARRAY_ELEMENTS(Long, jlongArray, jlong)
  DECLARE_GET_ARRAY_ELEMENTS(Float, jfloatArray, jfloat)
  DECLARE_GET_ARRAY_ELEMENTS(Double, jdoubleArray, jdouble)
  DECLARE_GET_ARRAY_ELEMENTS(Boolean, jbooleanArray, jboolean)

  /**
   * Gets an element of a given `array` with the specified `index`.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#getobjectarrayelement
   */
  template <typename T = jobject>
  [[nodiscard]] LocalRefUniquePtr<T> getObjectArrayElement(jobjectArray array, jsize index) {
    LocalRefUniquePtr<T> result(static_cast<T>(env_->GetObjectArrayElement(array, index)),
                                LocalRefDeleter(env_));
    rethrowException();
    return result;
  }

  /**
   * Sets an element of a given `array` with the specified `index.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#setobjectarrayelement
   */
  void setObjectArrayElement(jobjectArray array, jsize index, jobject value);

  /**
   * Returns the pointer into the primitive array.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#getprimitivearraycritical-releaseprimitivearraycritical
   */
  template <typename T = void*>
  [[nodiscard]] PrimitiveArrayCriticalUniquePtr<T> getPrimitiveArrayCritical(jarray array,
                                                                             jboolean* is_copy) {
    PrimitiveArrayCriticalUniquePtr<T> result(
        static_cast<T>(env_->GetPrimitiveArrayCritical(array, is_copy)),
        PrimitiveArrayCriticalDeleter(env_, array));
    return result;
  }

  /**
   * Sets a region of an `array` from a `buffer` with the specified `start` index and `length`.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#setprimitivetypearrayregion-routines
   */
#define DECLARE_SET_ARRAY_REGION(JAVA_TYPE, JNI_ARRAY_TYPE, JNI_ELEMENT_TYPE)                      \
  void set##JAVA_TYPE##ArrayRegion(JNI_ARRAY_TYPE array, jsize start, jsize length,                \
                                   const JNI_ELEMENT_TYPE* buffer);

  DECLARE_SET_ARRAY_REGION(Byte, jbyteArray, jbyte)
  DECLARE_SET_ARRAY_REGION(Char, jcharArray, jchar)
  DECLARE_SET_ARRAY_REGION(Short, jshortArray, jshort)
  DECLARE_SET_ARRAY_REGION(Int, jintArray, jint)
  DECLARE_SET_ARRAY_REGION(Long, jlongArray, jlong)
  DECLARE_SET_ARRAY_REGION(Float, jfloatArray, jfloat)
  DECLARE_SET_ARRAY_REGION(Double, jdoubleArray, jdouble)
  DECLARE_SET_ARRAY_REGION(Boolean, jbooleanArray, jboolean)

/** A macro to create `Call<Type>Method` helper function. */
#define DECLARE_CALL_METHOD(JAVA_TYPE, JNI_TYPE)                                                   \
  JNI_TYPE call##JAVA_TYPE##Method(jobject object, jmethodID method_id, ...);

  /**
   * Helper functions for `Call<Type>Method`.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#calltypemethod-routines-calltypemethoda-routines-calltypemethodv-routines
   */
  DECLARE_CALL_METHOD(Byte, jbyte)
  DECLARE_CALL_METHOD(Char, jchar)
  DECLARE_CALL_METHOD(Short, jshort)
  DECLARE_CALL_METHOD(Int, jint)
  DECLARE_CALL_METHOD(Long, jlong)
  DECLARE_CALL_METHOD(Float, jfloat)
  DECLARE_CALL_METHOD(Double, jdouble)
  DECLARE_CALL_METHOD(Boolean, jboolean)

  void callVoidMethod(jobject object, jmethodID method_id, ...);

  template <typename T = jobject>
  [[nodiscard]] LocalRefUniquePtr<T> callObjectMethod(jobject object, jmethodID method_id, ...) {
    va_list args;
    va_start(args, method_id);
    LocalRefUniquePtr<T> result(static_cast<T>(env_->CallObjectMethodV(object, method_id, args)),
                                LocalRefDeleter(env_));
    va_end(args);
    rethrowException();
    return result;
  }

/** A macro to create `CallStatic<Type>Method` helper function. */
#define DECLARE_CALL_STATIC_METHOD(JAVA_TYPE, JNI_TYPE)                                            \
  JNI_TYPE callStatic##JAVA_TYPE##Method(jclass clazz, jmethodID method_id, ...);

  /**
   * Helper functions for `CallStatic<Type>Method`.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#callstatictypemethod-routines-callstatictypemethoda-routines-callstatictypemethodv-routines
   */
  DECLARE_CALL_STATIC_METHOD(Byte, jbyte)
  DECLARE_CALL_STATIC_METHOD(Char, jchar)
  DECLARE_CALL_STATIC_METHOD(Short, jshort)
  DECLARE_CALL_STATIC_METHOD(Int, jint)
  DECLARE_CALL_STATIC_METHOD(Long, jlong)
  DECLARE_CALL_STATIC_METHOD(Float, jfloat)
  DECLARE_CALL_STATIC_METHOD(Double, jdouble)
  DECLARE_CALL_STATIC_METHOD(Boolean, jboolean)

  void callStaticVoidMethod(jclass clazz, jmethodID method_id, ...);

  template <typename T = jobject>
  [[nodiscard]] LocalRefUniquePtr<T> callStaticObjectMethod(jclass clazz, jmethodID method_id,
                                                            ...) {
    va_list args;
    va_start(args, method_id);
    LocalRefUniquePtr<T> result(
        static_cast<T>(env_->CallStaticObjectMethodV(clazz, method_id, args)),
        LocalRefDeleter(env_));
    va_end(args);
    rethrowException();
    return result;
  }

  /**
   * Returns the capacity of the memory region referenced by the given `java.nio.Buffer` object.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#getdirectbuffercapacity
   */
  jlong getDirectBufferCapacity(jobject buffer);

  /**
   * Gets the address of memory associated with the given NIO direct buffer.
   *
   * https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html#getdirectbufferaddress
   */
  template <typename T = void*> T getDirectBufferAddress(jobject buffer) {
    return static_cast<T>(env_->GetDirectBufferAddress(buffer));
  }

private:
  /** Rethrows the Java exception occurred. */
  void rethrowException();

  JNIEnv* const env_;
};

} // namespace JNI
} // namespace Envoy
#include "library/common/jni/import/jni_import.h"
#include "library/common/jni/jni_utility.h"

// NOLINT(namespace-envoy)

// AndroidJniLibrary

extern "C" JNIEXPORT jint JNICALL
Java_io_envoyproxy_envoymobile_engine_AndroidJniLibrary_initialize(JNIEnv* env,
                                                                   jclass, // class
                                                                   jobject class_loader) {
  Envoy::JNI::setClassLoader(env->NewGlobalRef(class_loader));
  return ENVOY_SUCCESS;
}
#pragma once

#include "library/common/jni/import/jni_import.h"

// NOLINT(namespace-envoy)

extern "C" int jni_log_fmt(const char* tag, const char* fmt, void* value);

extern "C" int jni_log(const char* tag, const char* str);

extern "C" jint attach_jvm(JavaVM* vm, JNIEnv** p_env, void* thr_args);
#include <cstddef>
#include <string>
#include <utility>

#include "source/common/protobuf/protobuf.h"

#include "library/cc/engine_builder.h"
#include "library/common/api/c_types.h"
#include "library/common/data/utility.h"
#include "library/common/engine.h"
#include "library/common/extensions/filters/http/platform_bridge/c_types.h"
#include "library/common/extensions/key_value/platform/c_types.h"
#include "library/common/jni/android_network_utility.h"
#include "library/common/jni/import/jni_import.h"
#include "library/common/jni/jni_support.h"
#include "library/common/jni/jni_utility.h"
#include "library/common/jni/types/exception.h"
#include "library/common/jni/types/java_virtual_machine.h"
#include "library/common/types/managed_envoy_headers.h"

using Envoy::Platform::EngineBuilder;

// NOLINT(namespace-envoy)

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* /*reserved*/) {
  const auto result = Envoy::JNI::JavaVirtualMachine::initialize(vm);
  if (result != JNI_OK) {
    return result;
  }

  return Envoy::JNI::JavaVirtualMachine::getJNIVersion();
}

// JniLibrary

static void jvm_on_engine_running(void* context) {
  if (context == nullptr) {
    return;
  }

  jni_log("[Envoy]", "jvm_on_engine_running");
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobject j_context = static_cast<jobject>(context);
  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmonEngineRunningContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_onEngineRunning = jni_helper.getMethodId(
      jcls_JvmonEngineRunningContext.get(), "invokeOnEngineRunning", "()Ljava/lang/Object;");
  Envoy::JNI::LocalRefUniquePtr<jobject> unused =
      jni_helper.callObjectMethod(j_context, jmid_onEngineRunning);

  // TODO(goaway): This isn't re-used by other engine callbacks, so it's safe to delete here.
  // This will need to be updated for https://github.com/envoyproxy/envoy-mobile/issues/332
  jni_helper.getEnv()->DeleteGlobalRef(j_context);
}

static void jvm_on_log(envoy_data data, const void* context) {
  if (context == nullptr) {
    return;
  }

  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  Envoy::JNI::LocalRefUniquePtr<jstring> str = Envoy::JNI::envoyDataToJavaString(jni_helper, data);

  jobject j_context = static_cast<jobject>(const_cast<void*>(context));
  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmLoggerContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_onLog =
      jni_helper.getMethodId(jcls_JvmLoggerContext.get(), "log", "(Ljava/lang/String;)V");
  jni_helper.callVoidMethod(j_context, jmid_onLog, str.get());

  release_envoy_data(data);
}

static void jvm_on_exit(void*) {
  jni_log("[Envoy]", "library is exiting");
  // Note that this is not dispatched because the thread that
  // needs to be detached is the engine thread.
  // This function is called from the context of the engine's
  // thread due to it being posted to the engine's event dispatcher.
  Envoy::JNI::JavaVirtualMachine::detachCurrentThread();
}

static void jvm_on_track(envoy_map events, const void* context) {
  jni_log("[Envoy]", "jvm_on_track");
  if (context == nullptr) {
    return;
  }

  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  Envoy::JNI::LocalRefUniquePtr<jobject> events_hashmap =
      Envoy::JNI::envoyMapToJavaMap(jni_helper, events);

  jobject j_context = static_cast<jobject>(const_cast<void*>(context));
  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_EnvoyEventTracker =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_onTrack =
      jni_helper.getMethodId(jcls_EnvoyEventTracker.get(), "track", "(Ljava/util/Map;)V");
  jni_helper.callVoidMethod(j_context, jmid_onTrack, events_hashmap.get());

  release_envoy_map(events);
}

extern "C" JNIEXPORT jint JNICALL
Java_io_envoyproxy_envoymobile_engine_JniLibrary_setLogLevel(JNIEnv* /*env*/, jclass, jint level) {
  Envoy::Logger::Context::changeAllLogLevels(static_cast<spdlog::level::level_enum>(level));
  return 0;
}

extern "C" JNIEXPORT jlong JNICALL Java_io_envoyproxy_envoymobile_engine_JniLibrary_initEngine(
    JNIEnv* env, jclass, jobject on_start_context, jobject envoy_logger_context,
    jobject j_event_tracker) {
  jobject retained_on_start_context =
      env->NewGlobalRef(on_start_context); // Required to keep context in memory
  envoy_engine_callbacks native_callbacks = {jvm_on_engine_running, jvm_on_exit,
                                             retained_on_start_context};

  const jobject retained_logger_context = env->NewGlobalRef(envoy_logger_context);
  envoy_logger logger = {nullptr, nullptr, nullptr};
  if (envoy_logger_context != nullptr) {
    logger = envoy_logger{jvm_on_log, Envoy::JNI::jniDeleteConstGlobalRef, retained_logger_context};
  }

  envoy_event_tracker event_tracker = {nullptr, nullptr};
  if (j_event_tracker != nullptr) {
    // TODO(goaway): The retained_context leaks, but it's tied to the life of the engine.
    // This will need to be updated for https://github.com/envoyproxy/envoy-mobile/issues/332.
    jobject retained_context = env->NewGlobalRef(j_event_tracker);
    jni_log_fmt("[Envoy]", "retained_context: %p", retained_context);
    event_tracker.track = jvm_on_track;
    event_tracker.context = retained_context;
  }

  return reinterpret_cast<intptr_t>(new Envoy::Engine(native_callbacks, logger, event_tracker));
}

extern "C" JNIEXPORT jint JNICALL Java_io_envoyproxy_envoymobile_engine_JniLibrary_runEngine(
    JNIEnv* env, jclass, jlong engine, jstring config, jlong bootstrap_ptr, jstring log_level) {
  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr java_string_config = jni_helper.getStringUtfChars(config, nullptr);
  Envoy::JNI::StringUtfUniquePtr java_log_level = jni_helper.getStringUtfChars(log_level, nullptr);
  // This should be either 0 (null) or a pointer generated by createBootstrap.
  // As documented in JniLibrary.java, take ownership.
  std::unique_ptr<envoy::config::bootstrap::v3::Bootstrap> bootstrap(
      reinterpret_cast<envoy::config::bootstrap::v3::Bootstrap*>(bootstrap_ptr));

  jint result;
  if (!bootstrap) {
    result = reinterpret_cast<Envoy::Engine*>(engine)->run(java_string_config.get(),
                                                           java_log_level.get());
  } else {
    auto options = std::make_unique<Envoy::OptionsImplBase>();
    options->setConfigProto(std::move(bootstrap));
    ENVOY_BUG(options->setLogLevel(java_log_level.get()).ok(), "invalid log level");
    options->setConcurrency(1);
    result = reinterpret_cast<Envoy::Engine*>(engine)->run(std::move(options));
  }

  return result;
}

extern "C" JNIEXPORT void JNICALL Java_io_envoyproxy_envoymobile_engine_JniLibrary_terminateEngine(
    JNIEnv* /*env*/, jclass, jlong engine_handle) {
  reinterpret_cast<Envoy::Engine*>(engine_handle)->terminate();
}

extern "C" JNIEXPORT jint JNICALL Java_io_envoyproxy_envoymobile_engine_JniLibrary_recordCounterInc(
    JNIEnv* env,
    jclass, // class
    jlong engine_handle, jstring elements, jobjectArray tags, jint count) {
  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr native_elements = jni_helper.getStringUtfChars(elements, nullptr);
  return reinterpret_cast<Envoy::Engine*>(engine_handle)
      ->recordCounterInc(native_elements.get(),
                         Envoy::JNI::javaArrayOfObjectArrayToEnvoyStatsTags(jni_helper, tags),
                         count);
}

extern "C" JNIEXPORT jstring JNICALL
Java_io_envoyproxy_envoymobile_engine_JniLibrary_dumpStats(JNIEnv* env,
                                                           jclass, // class
                                                           jlong engine_handle) {
  jni_log("[Envoy]", "dumpStats");
  auto engine = reinterpret_cast<Envoy::Engine*>(engine_handle);
  envoy_data data;
  jint result = engine->dumpStats(&data);
  Envoy::JNI::JniHelper jni_helper(env);
  if (result != ENVOY_SUCCESS) {
    return jni_helper.newStringUtf("").release();
  }

  Envoy::JNI::LocalRefUniquePtr<jstring> str = Envoy::JNI::envoyDataToJavaString(jni_helper, data);
  release_envoy_data(data);

  return str.release();
}

// JvmCallbackContext

static void passHeaders(const char* method, const Envoy::Types::ManagedEnvoyHeaders& headers,
                        jobject j_context) {
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmCallbackContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_passHeader =
      jni_helper.getMethodId(jcls_JvmCallbackContext.get(), method, "([B[BZ)V");
  jboolean start_headers = JNI_TRUE;

  for (envoy_map_size_t i = 0; i < headers.get().length; i++) {
    // Note: this is just an initial implementation, and we will pass a more optimized structure in
    // the future.
    // Note: the JNI function NewStringUTF would appear to be an appealing option here, except it
    // requires a null-terminated *modified* UTF-8 string.

    // Create platform byte array for header key
    Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_key =
        Envoy::JNI::envoyDataToJavaByteArray(jni_helper, headers.get().entries[i].key);
    // Create platform byte array for header value
    Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_value =
        Envoy::JNI::envoyDataToJavaByteArray(jni_helper, headers.get().entries[i].value);

    // Pass this header pair to the platform
    jni_helper.callVoidMethod(j_context, jmid_passHeader, j_key.get(), j_value.get(),
                              start_headers);

    // We don't release local refs currently because we've pushed a large enough frame, but we could
    // consider this and/or periodically popping the frame.
    start_headers = JNI_FALSE;
  }
}

// Platform callback implementation
// These methods call jvm methods which means the local references created will not be
// released automatically. Manual bookkeeping is required for these methods.

static void* jvm_on_headers(const char* method, const Envoy::Types::ManagedEnvoyHeaders& headers,
                            bool end_stream, envoy_stream_intel stream_intel, void* context) {
  jni_log("[Envoy]", "jvm_on_headers");
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobject j_context = static_cast<jobject>(context);
  passHeaders("passHeader", headers, j_context);

  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmCallbackContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_onHeaders =
      jni_helper.getMethodId(jcls_JvmCallbackContext.get(), method, "(JZ[J)Ljava/lang/Object;");

  Envoy::JNI::LocalRefUniquePtr<jlongArray> j_stream_intel =
      Envoy::JNI::envoyStreamIntelToJavaLongArray(jni_helper, stream_intel);
  // Note: be careful of JVM types. Before we casted to jlong we were getting integer problems.
  // TODO: make this cast safer.
  Envoy::JNI::LocalRefUniquePtr<jobject> result = jni_helper.callObjectMethod(
      j_context, jmid_onHeaders, static_cast<jlong>(headers.get().length),
      end_stream ? JNI_TRUE : JNI_FALSE, j_stream_intel.get());
  // TODO(Augustyniak): Pass the name of the filter in here so that we can instrument the origin of
  // the JNI exception better.
  bool exception_cleared = Envoy::JNI::Exception::checkAndClear(method);

  if (!exception_cleared) {
    return result.release();
  }

  // Create a "no operation" result:
  //  1. Tell the filter chain to continue the iteration.
  //  2. Return headers received on as method's input as part of the method's output.
  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_object_array =
      jni_helper.findClass("java/lang/Object");
  Envoy::JNI::LocalRefUniquePtr<jobjectArray> noopResult =
      jni_helper.newObjectArray(2, jcls_object_array.get(), NULL);

  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_int = jni_helper.findClass("java/lang/Integer");
  jmethodID jmid_intInit = jni_helper.getMethodId(jcls_int.get(), "<init>", "(I)V");
  Envoy::JNI::LocalRefUniquePtr<jobject> j_status =
      jni_helper.newObject(jcls_int.get(), jmid_intInit, 0);
  // Set status to "0" (FilterHeadersStatus::Continue). Signal that the intent
  // is to continue the iteration of the filter chain.
  jni_helper.setObjectArrayElement(noopResult.get(), 0, j_status.get());

  // Since the "on headers" call threw an exception set input headers as output headers.
  Envoy::JNI::LocalRefUniquePtr<jobjectArray> j_headers =
      Envoy::JNI::envoyHeadersToJavaArrayOfObjectArray(jni_helper, headers);
  jni_helper.setObjectArrayElement(noopResult.get(), 1, j_headers.get());

  return noopResult.release();
}

static void* jvm_on_response_headers(envoy_headers headers, bool end_stream,
                                     envoy_stream_intel stream_intel, void* context) {
  const auto managed_headers = Envoy::Types::ManagedEnvoyHeaders(headers);
  return jvm_on_headers("onResponseHeaders", managed_headers, end_stream, stream_intel, context);
}

static envoy_filter_headers_status
jvm_http_filter_on_request_headers(envoy_headers input_headers, bool end_stream,
                                   envoy_stream_intel stream_intel, const void* context) {
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  const auto headers = Envoy::Types::ManagedEnvoyHeaders(input_headers);
  jobjectArray result = static_cast<jobjectArray>(jvm_on_headers(
      "onRequestHeaders", headers, end_stream, stream_intel, const_cast<void*>(context)));

  if (result == NULL || jni_helper.getArrayLength(result) < 2) {
    jni_helper.getEnv()->DeleteLocalRef(result);
    return (envoy_filter_headers_status){/*status*/ kEnvoyFilterHeadersStatusStopIteration,
                                         /*headers*/ {}};
  }

  Envoy::JNI::LocalRefUniquePtr<jobject> status = jni_helper.getObjectArrayElement(result, 0);
  Envoy::JNI::LocalRefUniquePtr<jobjectArray> j_headers =
      jni_helper.getObjectArrayElement<jobjectArray>(result, 1);

  int unboxed_status = Envoy::JNI::javaIntegerTotInt(jni_helper, status.get());
  envoy_headers native_headers =
      Envoy::JNI::javaArrayOfObjectArrayToEnvoyHeaders(jni_helper, j_headers.get());

  jni_helper.getEnv()->DeleteLocalRef(result);

  return (envoy_filter_headers_status){/*status*/ unboxed_status,
                                       /*headers*/ native_headers};
}

static envoy_filter_headers_status
jvm_http_filter_on_response_headers(envoy_headers input_headers, bool end_stream,
                                    envoy_stream_intel stream_intel, const void* context) {
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  const auto headers = Envoy::Types::ManagedEnvoyHeaders(input_headers);
  jobjectArray result = static_cast<jobjectArray>(jvm_on_headers(
      "onResponseHeaders", headers, end_stream, stream_intel, const_cast<void*>(context)));

  if (result == NULL || jni_helper.getArrayLength(result) < 2) {
    jni_helper.getEnv()->DeleteLocalRef(result);
    return (envoy_filter_headers_status){/*status*/ kEnvoyFilterHeadersStatusStopIteration,
                                         /*headers*/ {}};
  }

  Envoy::JNI::LocalRefUniquePtr<jobject> status = jni_helper.getObjectArrayElement(result, 0);
  Envoy::JNI::LocalRefUniquePtr<jobjectArray> j_headers =
      jni_helper.getObjectArrayElement<jobjectArray>(result, 1);

  int unboxed_status = Envoy::JNI::javaIntegerTotInt(jni_helper, status.get());
  envoy_headers native_headers =
      Envoy::JNI::javaArrayOfObjectArrayToEnvoyHeaders(jni_helper, j_headers.get());

  jni_helper.getEnv()->DeleteLocalRef(result);

  return (envoy_filter_headers_status){/*status*/ unboxed_status,
                                       /*headers*/ native_headers};
}

static void* jvm_on_data(const char* method, envoy_data data, bool end_stream,
                         envoy_stream_intel stream_intel, void* context) {
  jni_log("[Envoy]", "jvm_on_data");
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobject j_context = static_cast<jobject>(context);

  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmCallbackContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_onData =
      jni_helper.getMethodId(jcls_JvmCallbackContext.get(), method, "([BZ[J)Ljava/lang/Object;");

  Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_data =
      Envoy::JNI::envoyDataToJavaByteArray(jni_helper, data);
  Envoy::JNI::LocalRefUniquePtr<jlongArray> j_stream_intel =
      Envoy::JNI::envoyStreamIntelToJavaLongArray(jni_helper, stream_intel);
  jobject result = jni_helper
                       .callObjectMethod(j_context, jmid_onData, j_data.get(),
                                         end_stream ? JNI_TRUE : JNI_FALSE, j_stream_intel.get())
                       .release();

  release_envoy_data(data);

  return result;
}

static void* jvm_on_response_data(envoy_data data, bool end_stream, envoy_stream_intel stream_intel,
                                  void* context) {
  return jvm_on_data("onResponseData", data, end_stream, stream_intel, context);
}

static envoy_filter_data_status jvm_http_filter_on_request_data(envoy_data data, bool end_stream,
                                                                envoy_stream_intel stream_intel,
                                                                const void* context) {
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobjectArray result = static_cast<jobjectArray>(
      jvm_on_data("onRequestData", data, end_stream, stream_intel, const_cast<void*>(context)));

  if (result == NULL || jni_helper.getArrayLength(result) < 2) {
    jni_helper.getEnv()->DeleteLocalRef(result);
    return (envoy_filter_data_status){/*status*/ kEnvoyFilterHeadersStatusStopIteration,
                                      /*data*/ {},
                                      /*pending_headers*/ {}};
  }

  Envoy::JNI::LocalRefUniquePtr<jobject> status = jni_helper.getObjectArrayElement(result, 0);
  Envoy::JNI::LocalRefUniquePtr<jobjectArray> j_data =
      jni_helper.getObjectArrayElement<jobjectArray>(result, 1);

  int unboxed_status = Envoy::JNI::javaIntegerTotInt(jni_helper, status.get());
  envoy_data native_data = Envoy::JNI::javaByteBufferToEnvoyData(jni_helper, j_data.get());

  envoy_headers* pending_headers = nullptr;
  // Avoid out-of-bounds access to array when checking for optional pending entities.
  if (unboxed_status == kEnvoyFilterDataStatusResumeIteration) {
    Envoy::JNI::LocalRefUniquePtr<jobjectArray> j_headers =
        jni_helper.getObjectArrayElement<jobjectArray>(result, 2);
    pending_headers =
        Envoy::JNI::javaArrayOfObjectArrayToEnvoyHeadersPtr(jni_helper, j_headers.get());
  }

  jni_helper.getEnv()->DeleteLocalRef(result);

  return (envoy_filter_data_status){/*status*/ unboxed_status,
                                    /*data*/ native_data,
                                    /*pending_headers*/ pending_headers};
}

static envoy_filter_data_status jvm_http_filter_on_response_data(envoy_data data, bool end_stream,
                                                                 envoy_stream_intel stream_intel,
                                                                 const void* context) {
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobjectArray result = static_cast<jobjectArray>(
      jvm_on_data("onResponseData", data, end_stream, stream_intel, const_cast<void*>(context)));

  if (result == NULL || jni_helper.getArrayLength(result) < 2) {
    jni_helper.getEnv()->DeleteLocalRef(result);
    return (envoy_filter_data_status){/*status*/ kEnvoyFilterHeadersStatusStopIteration,
                                      /*data*/ {},
                                      /*pending_headers*/ {}};
  }

  Envoy::JNI::LocalRefUniquePtr<jobject> status = jni_helper.getObjectArrayElement(result, 0);
  Envoy::JNI::LocalRefUniquePtr<jobjectArray> j_data =
      jni_helper.getObjectArrayElement<jobjectArray>(result, 1);

  int unboxed_status = Envoy::JNI::javaIntegerTotInt(jni_helper, status.get());
  envoy_data native_data = Envoy::JNI::javaByteBufferToEnvoyData(jni_helper, j_data.get());

  envoy_headers* pending_headers = nullptr;
  // Avoid out-of-bounds access to array when checking for optional pending entities.
  if (unboxed_status == kEnvoyFilterDataStatusResumeIteration) {
    Envoy::JNI::LocalRefUniquePtr<jobjectArray> j_headers =
        jni_helper.getObjectArrayElement<jobjectArray>(result, 2);
    pending_headers =
        Envoy::JNI::javaArrayOfObjectArrayToEnvoyHeadersPtr(jni_helper, j_headers.get());
  }

  jni_helper.getEnv()->DeleteLocalRef(result);

  return (envoy_filter_data_status){/*status*/ unboxed_status,
                                    /*data*/ native_data,
                                    /*pending_headers*/ pending_headers};
}

static void* jvm_on_metadata(envoy_headers metadata, envoy_stream_intel /*stream_intel*/,
                             void* /*context*/) {
  jni_log("[Envoy]", "jvm_on_metadata");
  jni_log("[Envoy]", std::to_string(metadata.length).c_str());
  return nullptr;
}

static void* jvm_on_trailers(const char* method, envoy_headers trailers,
                             envoy_stream_intel stream_intel, void* context) {
  jni_log("[Envoy]", "jvm_on_trailers");

  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobject j_context = static_cast<jobject>(context);
  passHeaders("passHeader", trailers, j_context);

  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmCallbackContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_onTrailers =
      jni_helper.getMethodId(jcls_JvmCallbackContext.get(), method, "(J[J)Ljava/lang/Object;");

  Envoy::JNI::LocalRefUniquePtr<jlongArray> j_stream_intel =
      Envoy::JNI::envoyStreamIntelToJavaLongArray(jni_helper, stream_intel);
  // Note: be careful of JVM types. Before we casted to jlong we were getting integer problems.
  // TODO: make this cast safer.
  jobject result = jni_helper
                       .callObjectMethod(j_context, jmid_onTrailers,
                                         static_cast<jlong>(trailers.length), j_stream_intel.get())
                       .release();

  return result;
}

static void* jvm_on_response_trailers(envoy_headers trailers, envoy_stream_intel stream_intel,
                                      void* context) {
  return jvm_on_trailers("onResponseTrailers", trailers, stream_intel, context);
}

static envoy_filter_trailers_status
jvm_http_filter_on_request_trailers(envoy_headers trailers, envoy_stream_intel stream_intel,
                                    const void* context) {
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobjectArray result = static_cast<jobjectArray>(
      jvm_on_trailers("onRequestTrailers", trailers, stream_intel, const_cast<void*>(context)));

  if (result == NULL || jni_helper.getArrayLength(result) < 2) {
    jni_helper.getEnv()->DeleteLocalRef(result);
    return (envoy_filter_trailers_status){/*status*/ kEnvoyFilterHeadersStatusStopIteration,
                                          /*trailers*/ {},
                                          /*pending_headers*/ {},
                                          /*pending_data*/ {}};
  }

  Envoy::JNI::LocalRefUniquePtr<jobject> status = jni_helper.getObjectArrayElement(result, 0);
  Envoy::JNI::LocalRefUniquePtr<jobjectArray> j_trailers =
      jni_helper.getObjectArrayElement<jobjectArray>(result, 1);

  int unboxed_status = Envoy::JNI::javaIntegerTotInt(jni_helper, status.get());
  envoy_headers native_trailers =
      Envoy::JNI::javaArrayOfObjectArrayToEnvoyHeaders(jni_helper, j_trailers.get());

  envoy_headers* pending_headers = nullptr;
  envoy_data* pending_data = nullptr;
  // Avoid out-of-bounds access to array when checking for optional pending entities.
  if (unboxed_status == kEnvoyFilterTrailersStatusResumeIteration) {
    Envoy::JNI::LocalRefUniquePtr<jobjectArray> j_headers =
        jni_helper.getObjectArrayElement<jobjectArray>(result, 2);
    pending_headers =
        Envoy::JNI::javaArrayOfObjectArrayToEnvoyHeadersPtr(jni_helper, j_headers.get());

    Envoy::JNI::LocalRefUniquePtr<jobject> j_data = jni_helper.getObjectArrayElement(result, 3);
    pending_data = Envoy::JNI::javaByteBufferToEnvoyDataPtr(jni_helper, j_data.get());
  }

  jni_helper.getEnv()->DeleteLocalRef(result);

  return (envoy_filter_trailers_status){/*status*/ unboxed_status,
                                        /*trailers*/ native_trailers,
                                        /*pending_headers*/ pending_headers,
                                        /*pending_data*/ pending_data};
}

static envoy_filter_trailers_status
jvm_http_filter_on_response_trailers(envoy_headers trailers, envoy_stream_intel stream_intel,
                                     const void* context) {
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobjectArray result = static_cast<jobjectArray>(
      jvm_on_trailers("onResponseTrailers", trailers, stream_intel, const_cast<void*>(context)));

  if (result == NULL || jni_helper.getArrayLength(result) < 2) {
    jni_helper.getEnv()->DeleteLocalRef(result);
    return (envoy_filter_trailers_status){/*status*/ kEnvoyFilterHeadersStatusStopIteration,
                                          /*trailers*/ {},
                                          /*pending_headers*/ {},
                                          /*pending_data*/ {}};
  }

  Envoy::JNI::LocalRefUniquePtr<jobject> status = jni_helper.getObjectArrayElement(result, 0);
  Envoy::JNI::LocalRefUniquePtr<jobjectArray> j_trailers =
      jni_helper.getObjectArrayElement<jobjectArray>(result, 1);

  int unboxed_status = Envoy::JNI::javaIntegerTotInt(jni_helper, status.get());
  envoy_headers native_trailers =
      Envoy::JNI::javaArrayOfObjectArrayToEnvoyHeaders(jni_helper, j_trailers.get());

  envoy_headers* pending_headers = nullptr;
  envoy_data* pending_data = nullptr;
  // Avoid out-of-bounds access to array when checking for optional pending entities.
  if (unboxed_status == kEnvoyFilterTrailersStatusResumeIteration) {
    Envoy::JNI::LocalRefUniquePtr<jobjectArray> j_headers =
        jni_helper.getObjectArrayElement<jobjectArray>(result, 2);
    pending_headers =
        Envoy::JNI::javaArrayOfObjectArrayToEnvoyHeadersPtr(jni_helper, j_headers.get());

    Envoy::JNI::LocalRefUniquePtr<jobject> j_data = jni_helper.getObjectArrayElement(result, 3);
    pending_data = Envoy::JNI::javaByteBufferToEnvoyDataPtr(jni_helper, j_data.get());
  }

  jni_helper.getEnv()->DeleteLocalRef(result);

  return (envoy_filter_trailers_status){/*status*/ unboxed_status,
                                        /*trailers*/ native_trailers,
                                        /*pending_headers*/ pending_headers,
                                        /*pending_data*/ pending_data};
}

static void jvm_http_filter_set_request_callbacks(envoy_http_filter_callbacks callbacks,
                                                  const void* context) {

  jni_log("[Envoy]", "jvm_http_filter_set_request_callbacks");

  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobject j_context = static_cast<jobject>(const_cast<void*>(context));
  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmCallbackContext =
      jni_helper.getObjectClass(j_context);

  envoy_http_filter_callbacks* on_heap_callbacks =
      static_cast<envoy_http_filter_callbacks*>(safe_malloc(sizeof(envoy_http_filter_callbacks)));
  *on_heap_callbacks = callbacks;
  jlong callback_handle = reinterpret_cast<jlong>(on_heap_callbacks);

  jmethodID jmid_setRequestFilterCallbacks =
      jni_helper.getMethodId(jcls_JvmCallbackContext.get(), "setRequestFilterCallbacks", "(J)V");
  jni_helper.callVoidMethod(j_context, jmid_setRequestFilterCallbacks, callback_handle);
}

static void jvm_http_filter_set_response_callbacks(envoy_http_filter_callbacks callbacks,
                                                   const void* context) {

  jni_log("[Envoy]", "jvm_http_filter_set_response_callbacks");

  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobject j_context = static_cast<jobject>(const_cast<void*>(context));
  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmCallbackContext =
      jni_helper.getObjectClass(j_context);

  envoy_http_filter_callbacks* on_heap_callbacks =
      static_cast<envoy_http_filter_callbacks*>(safe_malloc(sizeof(envoy_http_filter_callbacks)));
  *on_heap_callbacks = callbacks;
  jlong callback_handle = reinterpret_cast<jlong>(on_heap_callbacks);

  jmethodID jmid_setResponseFilterCallbacks =
      jni_helper.getMethodId(jcls_JvmCallbackContext.get(), "setResponseFilterCallbacks", "(J)V");
  jni_helper.callVoidMethod(j_context, jmid_setResponseFilterCallbacks, callback_handle);
}

static envoy_filter_resume_status
jvm_http_filter_on_resume(const char* method, envoy_headers* headers, envoy_data* data,
                          envoy_headers* trailers, bool end_stream, envoy_stream_intel stream_intel,
                          const void* context) {
  jni_log("[Envoy]", "jvm_on_resume");

  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobject j_context = static_cast<jobject>(const_cast<void*>(context));
  jlong headers_length = -1;
  if (headers) {
    headers_length = static_cast<jlong>(headers->length);
    passHeaders("passHeader", *headers, j_context);
  }
  Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_in_data = Envoy::JNI::LocalRefUniquePtr<jbyteArray>(
      nullptr, Envoy::JNI::LocalRefDeleter(jni_helper.getEnv()));
  if (data) {
    j_in_data = Envoy::JNI::envoyDataToJavaByteArray(jni_helper, *data);
  }
  jlong trailers_length = -1;
  if (trailers) {
    trailers_length = static_cast<jlong>(trailers->length);
    passHeaders("passTrailer", *trailers, j_context);
  }
  Envoy::JNI::LocalRefUniquePtr<jlongArray> j_stream_intel =
      Envoy::JNI::envoyStreamIntelToJavaLongArray(jni_helper, stream_intel);

  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmCallbackContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_onResume =
      jni_helper.getMethodId(jcls_JvmCallbackContext.get(), method, "(J[BJZ[J)Ljava/lang/Object;");
  // Note: be careful of JVM types. Before we casted to jlong we were getting integer problems.
  // TODO: make this cast safer.
  Envoy::JNI::LocalRefUniquePtr<jobjectArray> result = jni_helper.callObjectMethod<jobjectArray>(
      j_context, jmid_onResume, headers_length, j_in_data.get(), trailers_length,
      end_stream ? JNI_TRUE : JNI_FALSE, j_stream_intel.get());

  Envoy::JNI::LocalRefUniquePtr<jobject> status = jni_helper.getObjectArrayElement(result.get(), 0);
  Envoy::JNI::LocalRefUniquePtr<jobjectArray> j_headers =
      jni_helper.getObjectArrayElement<jobjectArray>(result.get(), 1);
  Envoy::JNI::LocalRefUniquePtr<jobject> j_data = jni_helper.getObjectArrayElement(result.get(), 2);
  Envoy::JNI::LocalRefUniquePtr<jobjectArray> j_trailers =
      jni_helper.getObjectArrayElement<jobjectArray>(result.get(), 3);

  int unboxed_status = Envoy::JNI::javaIntegerTotInt(jni_helper, status.get());
  envoy_headers* pending_headers =
      Envoy::JNI::javaArrayOfObjectArrayToEnvoyHeadersPtr(jni_helper, j_headers.get());
  envoy_data* pending_data = Envoy::JNI::javaByteBufferToEnvoyDataPtr(jni_helper, j_data.get());
  envoy_headers* pending_trailers =
      Envoy::JNI::javaArrayOfObjectArrayToEnvoyHeadersPtr(jni_helper, j_trailers.get());

  return (envoy_filter_resume_status){/*status*/ unboxed_status,
                                      /*pending_headers*/ pending_headers,
                                      /*pending_data*/ pending_data,
                                      /*pending_trailers*/ pending_trailers};
}

static envoy_filter_resume_status
jvm_http_filter_on_resume_request(envoy_headers* headers, envoy_data* data, envoy_headers* trailers,
                                  bool end_stream, envoy_stream_intel stream_intel,
                                  const void* context) {
  return jvm_http_filter_on_resume("onResumeRequest", headers, data, trailers, end_stream,
                                   stream_intel, context);
}

static envoy_filter_resume_status
jvm_http_filter_on_resume_response(envoy_headers* headers, envoy_data* data,
                                   envoy_headers* trailers, bool end_stream,
                                   envoy_stream_intel stream_intel, const void* context) {
  return jvm_http_filter_on_resume("onResumeResponse", headers, data, trailers, end_stream,
                                   stream_intel, context);
}

static void* call_jvm_on_complete(envoy_stream_intel stream_intel,
                                  envoy_final_stream_intel final_stream_intel, void* context) {
  jni_log("[Envoy]", "jvm_on_complete");

  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobject j_context = static_cast<jobject>(context);

  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmObserverContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_onComplete = jni_helper.getMethodId(jcls_JvmObserverContext.get(), "onComplete",
                                                     "([J[J)Ljava/lang/Object;");

  Envoy::JNI::LocalRefUniquePtr<jlongArray> j_stream_intel =
      Envoy::JNI::envoyStreamIntelToJavaLongArray(jni_helper, stream_intel);
  Envoy::JNI::LocalRefUniquePtr<jlongArray> j_final_stream_intel =
      Envoy::JNI::envoyFinalStreamIntelToJavaLongArray(jni_helper, final_stream_intel);
  jobject result = jni_helper
                       .callObjectMethod(j_context, jmid_onComplete, j_stream_intel.get(),
                                         j_final_stream_intel.get())
                       .release();

  return result;
}

static void* call_jvm_on_error(envoy_error error, envoy_stream_intel stream_intel,
                               envoy_final_stream_intel final_stream_intel, void* context) {
  jni_log("[Envoy]", "jvm_on_error");
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobject j_context = static_cast<jobject>(context);

  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmObserverContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_onError = jni_helper.getMethodId(jcls_JvmObserverContext.get(), "onError",
                                                  "(I[BI[J[J)Ljava/lang/Object;");

  Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_error_message =
      Envoy::JNI::envoyDataToJavaByteArray(jni_helper, error.message);
  Envoy::JNI::LocalRefUniquePtr<jlongArray> j_stream_intel =
      Envoy::JNI::envoyStreamIntelToJavaLongArray(jni_helper, stream_intel);
  Envoy::JNI::LocalRefUniquePtr<jlongArray> j_final_stream_intel =
      Envoy::JNI::envoyFinalStreamIntelToJavaLongArray(jni_helper, final_stream_intel);

  jobject result =
      jni_helper
          .callObjectMethod(j_context, jmid_onError, error.error_code, j_error_message.get(),
                            error.attempt_count, j_stream_intel.get(), j_final_stream_intel.get())
          .release();

  release_envoy_error(error);
  return result;
}

static void* jvm_on_error(envoy_error error, envoy_stream_intel stream_intel,
                          envoy_final_stream_intel final_stream_intel, void* context) {
  void* result = call_jvm_on_error(error, stream_intel, final_stream_intel, context);
  Envoy::JNI::jniDeleteGlobalRef(context);
  return result;
}

static void* call_jvm_on_cancel(envoy_stream_intel stream_intel,
                                envoy_final_stream_intel final_stream_intel, void* context) {
  jni_log("[Envoy]", "jvm_on_cancel");

  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobject j_context = static_cast<jobject>(context);

  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmObserverContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_onCancel =
      jni_helper.getMethodId(jcls_JvmObserverContext.get(), "onCancel", "([J[J)Ljava/lang/Object;");

  Envoy::JNI::LocalRefUniquePtr<jlongArray> j_stream_intel =
      Envoy::JNI::envoyStreamIntelToJavaLongArray(jni_helper, stream_intel);
  Envoy::JNI::LocalRefUniquePtr<jlongArray> j_final_stream_intel =
      Envoy::JNI::envoyFinalStreamIntelToJavaLongArray(jni_helper, final_stream_intel);

  jobject result = jni_helper
                       .callObjectMethod(j_context, jmid_onCancel, j_stream_intel.get(),
                                         j_final_stream_intel.get())
                       .release();

  return result;
}

static void* jvm_on_complete(envoy_stream_intel stream_intel,
                             envoy_final_stream_intel final_stream_intel, void* context) {
  void* result = call_jvm_on_complete(stream_intel, final_stream_intel, context);
  Envoy::JNI::jniDeleteGlobalRef(context);
  return result;
}

static void* jvm_on_cancel(envoy_stream_intel stream_intel,
                           envoy_final_stream_intel final_stream_intel, void* context) {
  void* result = call_jvm_on_cancel(stream_intel, final_stream_intel, context);
  Envoy::JNI::jniDeleteGlobalRef(context);
  return result;
}

static void jvm_http_filter_on_error(envoy_error error, envoy_stream_intel stream_intel,
                                     envoy_final_stream_intel final_stream_intel,
                                     const void* context) {
  call_jvm_on_error(error, stream_intel, final_stream_intel, const_cast<void*>(context));
}

static void jvm_http_filter_on_cancel(envoy_stream_intel stream_intel,
                                      envoy_final_stream_intel final_stream_intel,
                                      const void* context) {
  call_jvm_on_cancel(stream_intel, final_stream_intel, const_cast<void*>(context));
}

static void* jvm_on_send_window_available(envoy_stream_intel stream_intel, void* context) {
  jni_log("[Envoy]", "jvm_on_send_window_available");

  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobject j_context = static_cast<jobject>(context);

  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmObserverContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_onSendWindowAvailable = jni_helper.getMethodId(
      jcls_JvmObserverContext.get(), "onSendWindowAvailable", "([J)Ljava/lang/Object;");

  Envoy::JNI::LocalRefUniquePtr<jlongArray> j_stream_intel =
      Envoy::JNI::envoyStreamIntelToJavaLongArray(jni_helper, stream_intel);

  jobject result =
      jni_helper.callObjectMethod(j_context, jmid_onSendWindowAvailable, j_stream_intel.get())
          .release();

  return result;
}

// JvmKeyValueStoreContext
static envoy_data jvm_kv_store_read(envoy_data key, const void* context) {
  jni_log("[Envoy]", "jvm_kv_store_read");
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());

  jobject j_context = static_cast<jobject>(const_cast<void*>(context));

  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmKeyValueStoreContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_read =
      jni_helper.getMethodId(jcls_JvmKeyValueStoreContext.get(), "read", "([B)[B");
  Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_key =
      Envoy::JNI::envoyDataToJavaByteArray(jni_helper, key);
  Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_value =
      jni_helper.callObjectMethod<jbyteArray>(j_context, jmid_read, j_key.get());
  envoy_data native_data = Envoy::JNI::javaByteArrayToEnvoyData(jni_helper, j_value.get());

  return native_data;
}

static void jvm_kv_store_remove(envoy_data key, const void* context) {
  jni_log("[Envoy]", "jvm_kv_store_remove");
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());

  jobject j_context = static_cast<jobject>(const_cast<void*>(context));

  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmKeyValueStoreContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_remove =
      jni_helper.getMethodId(jcls_JvmKeyValueStoreContext.get(), "remove", "([B)V");
  Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_key =
      Envoy::JNI::envoyDataToJavaByteArray(jni_helper, key);
  jni_helper.callVoidMethod(j_context, jmid_remove, j_key.get());
}

static void jvm_kv_store_save(envoy_data key, envoy_data value, const void* context) {
  jni_log("[Envoy]", "jvm_kv_store_save");
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());

  jobject j_context = static_cast<jobject>(const_cast<void*>(context));

  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmKeyValueStoreContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_save =
      jni_helper.getMethodId(jcls_JvmKeyValueStoreContext.get(), "save", "([B[B)V");
  Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_key =
      Envoy::JNI::envoyDataToJavaByteArray(jni_helper, key);
  Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_value =
      Envoy::JNI::envoyDataToJavaByteArray(jni_helper, value);
  jni_helper.callVoidMethod(j_context, jmid_save, j_key.get(), j_value.get());
}

// JvmFilterFactoryContext

static const void* jvm_http_filter_init(const void* context) {
  jni_log("[Envoy]", "jvm_filter_init");

  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());

  envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
  jobject j_context = static_cast<jobject>(const_cast<void*>(c_filter->static_context));

  jni_log_fmt("[Envoy]", "j_context: %p", j_context);

  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmFilterFactoryContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_create =
      jni_helper.getMethodId(jcls_JvmFilterFactoryContext.get(), "create",
                             "()Lio/envoyproxy/envoymobile/engine/JvmFilterContext;");

  Envoy::JNI::LocalRefUniquePtr<jobject> j_filter =
      jni_helper.callObjectMethod(j_context, jmid_create);
  jni_log_fmt("[Envoy]", "j_filter: %p", j_filter.get());
  Envoy::JNI::GlobalRefUniquePtr<jobject> retained_filter = jni_helper.newGlobalRef(j_filter.get());

  return retained_filter.release();
}

// EnvoyStringAccessor

static envoy_data jvm_get_string(const void* context) {
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  jobject j_context = static_cast<jobject>(const_cast<void*>(context));
  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_JvmStringAccessorContext =
      jni_helper.getObjectClass(j_context);
  jmethodID jmid_getString =
      jni_helper.getMethodId(jcls_JvmStringAccessorContext.get(), "getEnvoyString", "()[B");
  Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_data =
      jni_helper.callObjectMethod<jbyteArray>(j_context, jmid_getString);
  envoy_data native_data = Envoy::JNI::javaByteArrayToEnvoyData(jni_helper, j_data.get());

  return native_data;
}

// EnvoyHTTPStream

extern "C" JNIEXPORT jlong JNICALL Java_io_envoyproxy_envoymobile_engine_JniLibrary_initStream(
    JNIEnv* /*env*/, jclass, jlong engine_handle) {

  auto engine = reinterpret_cast<Envoy::Engine*>(engine_handle);
  return engine->initStream();
}

extern "C" JNIEXPORT jint JNICALL Java_io_envoyproxy_envoymobile_engine_JniLibrary_startStream(
    JNIEnv* env, jclass, jlong engine_handle, jlong stream_handle, jobject j_context,
    jboolean explicit_flow_control) {
  // TODO: To be truly safe we may need stronger guarantees of operation ordering on this ref.
  jobject retained_context = env->NewGlobalRef(j_context);
  envoy_http_callbacks native_callbacks = {jvm_on_response_headers,
                                           jvm_on_response_data,
                                           jvm_on_metadata,
                                           jvm_on_response_trailers,
                                           jvm_on_error,
                                           jvm_on_complete,
                                           jvm_on_cancel,
                                           jvm_on_send_window_available,
                                           retained_context};
  auto engine = reinterpret_cast<Envoy::Engine*>(engine_handle);
  envoy_status_t result = engine->startStream(static_cast<envoy_stream_t>(stream_handle),
                                              native_callbacks, explicit_flow_control);
  if (result != ENVOY_SUCCESS) {
    env->DeleteGlobalRef(retained_context); // No callbacks are fired and we need to release
  }
  return result;
}

// EnvoyKeyValueStore

extern "C" JNIEXPORT jint JNICALL
Java_io_envoyproxy_envoymobile_engine_JniLibrary_registerKeyValueStore(JNIEnv* env, jclass,
                                                                       jstring name,
                                                                       jobject j_context) {

  // TODO(goaway): The java context here leaks, but it's tied to the life of the engine.
  // This will need to be updated for https://github.com/envoyproxy/envoy-mobile/issues/332
  jni_log("[Envoy]", "registerKeyValueStore");
  jni_log_fmt("[Envoy]", "j_context: %p", j_context);
  jobject retained_context = env->NewGlobalRef(j_context);
  jni_log_fmt("[Envoy]", "retained_context: %p", retained_context);
  envoy_kv_store* api = static_cast<envoy_kv_store*>(safe_malloc(sizeof(envoy_kv_store)));
  api->save = jvm_kv_store_save;
  api->read = jvm_kv_store_read;
  api->remove = jvm_kv_store_remove;
  api->context = retained_context;

  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr native_java_string = jni_helper.getStringUtfChars(name, nullptr);
  std::string api_name(native_java_string.get());
  Envoy::Api::External::registerApi(api_name, api);
  return ENVOY_SUCCESS;
}

// EnvoyHTTPFilter

extern "C" JNIEXPORT jint JNICALL
Java_io_envoyproxy_envoymobile_engine_JniLibrary_registerFilterFactory(JNIEnv* env, jclass,
                                                                       jstring filter_name,
                                                                       jobject j_context) {

  // TODO(goaway): Everything here leaks, but it's all be tied to the life of the engine.
  // This will need to be updated for https://github.com/envoyproxy/envoy-mobile/issues/332
  jni_log("[Envoy]", "registerFilterFactory");
  jni_log_fmt("[Envoy]", "j_context: %p", j_context);
  jobject retained_context = env->NewGlobalRef(j_context);
  jni_log_fmt("[Envoy]", "retained_context: %p", retained_context);
  envoy_http_filter* api = static_cast<envoy_http_filter*>(safe_malloc(sizeof(envoy_http_filter)));
  api->init_filter = jvm_http_filter_init;
  api->on_request_headers = jvm_http_filter_on_request_headers;
  api->on_request_data = jvm_http_filter_on_request_data;
  api->on_request_trailers = jvm_http_filter_on_request_trailers;
  api->on_response_headers = jvm_http_filter_on_response_headers;
  api->on_response_data = jvm_http_filter_on_response_data;
  api->on_response_trailers = jvm_http_filter_on_response_trailers;
  api->set_request_callbacks = jvm_http_filter_set_request_callbacks;
  api->on_resume_request = jvm_http_filter_on_resume_request;
  api->set_response_callbacks = jvm_http_filter_set_response_callbacks;
  api->on_resume_response = jvm_http_filter_on_resume_response;
  api->on_cancel = jvm_http_filter_on_cancel;
  api->on_error = jvm_http_filter_on_error;
  api->release_filter = Envoy::JNI::jniDeleteConstGlobalRef;
  api->static_context = retained_context;
  api->instance_context = nullptr;

  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr native_java_string =
      jni_helper.getStringUtfChars(filter_name, nullptr);
  std::string api_name(native_java_string.get());
  Envoy::Api::External::registerApi(api_name, api);
  return ENVOY_SUCCESS;
}

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_EnvoyHTTPFilterCallbacksImpl_callResumeIteration(
    JNIEnv* env, jclass, jlong callback_handle, jobject j_context) {
  jni_log("[Envoy]", "callResumeIteration");
  // Context is only passed here to ensure it's not inadvertently gc'd during execution of this
  // function. To be extra safe, do an explicit retain with a GlobalRef.
  jobject retained_context = env->NewGlobalRef(j_context);
  envoy_http_filter_callbacks* callbacks =
      reinterpret_cast<envoy_http_filter_callbacks*>(callback_handle);
  callbacks->resume_iteration(callbacks->callback_context);
  env->DeleteGlobalRef(retained_context);
}

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_EnvoyHTTPFilterCallbacksImpl_callResetIdleTimer(
    JNIEnv* env, jclass, jlong callback_handle, jobject j_context) {
  jni_log("[Envoy]", "callResetIdleTimer");
  // Context is only passed here to ensure it's not inadvertently gc'd during execution of this
  // function. To be extra safe, do an explicit retain with a GlobalRef.
  jobject retained_context = env->NewGlobalRef(j_context);
  envoy_http_filter_callbacks* callbacks =
      reinterpret_cast<envoy_http_filter_callbacks*>(callback_handle);
  callbacks->reset_idle(callbacks->callback_context);
  env->DeleteGlobalRef(retained_context);
}

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_EnvoyHTTPFilterCallbacksImpl_callReleaseCallbacks(
    JNIEnv* /*env*/, jclass, jlong callback_handle) {
  jni_log("[Envoy]", "callReleaseCallbacks");
  envoy_http_filter_callbacks* callbacks =
      reinterpret_cast<envoy_http_filter_callbacks*>(callback_handle);
  callbacks->release_callbacks(callbacks->callback_context);
  free(callbacks);
}

// EnvoyHTTPStream

extern "C" JNIEXPORT jint JNICALL Java_io_envoyproxy_envoymobile_engine_JniLibrary_readData(
    JNIEnv* /*env*/, jclass, jlong engine_handle, jlong stream_handle, jlong byte_count) {
  return reinterpret_cast<Envoy::Engine*>(engine_handle)
      ->readData(static_cast<envoy_stream_t>(stream_handle), byte_count);
}

// The Java counterpart guarantees to invoke this method with a non-null direct ByteBuffer where the
// provided length is between 0 and ByteBuffer.capacity(), inclusively.
extern "C" JNIEXPORT jint JNICALL Java_io_envoyproxy_envoymobile_engine_JniLibrary_sendData(
    JNIEnv* env, jclass, jlong engine_handle, jlong stream_handle, jobject data, jint length,
    jboolean end_stream) {
  Envoy::JNI::JniHelper jni_helper(env);
  if (end_stream) {
    jni_log("[Envoy]", "jvm_send_data_end_stream");
  }
  return reinterpret_cast<Envoy::Engine*>(engine_handle)
      ->sendData(static_cast<envoy_stream_t>(stream_handle),
                 Envoy::JNI::javaByteBufferToEnvoyData(jni_helper, data, length), end_stream);
}

// The Java counterpart guarantees to invoke this method with a non-null jbyteArray where the
// provided length is between 0 and the size of the jbyteArray, inclusively. And given that this
// jbyteArray comes from a ByteBuffer, it is also guaranteed that its length will not be greater
// than 2^31 - this is why the length type is jint.
extern "C" JNIEXPORT jint JNICALL
Java_io_envoyproxy_envoymobile_engine_JniLibrary_sendDataByteArray(JNIEnv* env, jclass,
                                                                   jlong engine_handle,
                                                                   jlong stream_handle,
                                                                   jbyteArray data, jint length,
                                                                   jboolean end_stream) {
  Envoy::JNI::JniHelper jni_helper(env);
  if (end_stream) {
    jni_log("[Envoy]", "jvm_send_data_end_stream");
  }
  return reinterpret_cast<Envoy::Engine*>(engine_handle)
      ->sendData(static_cast<envoy_stream_t>(stream_handle),
                 Envoy::JNI::javaByteArrayToEnvoyData(jni_helper, data, length), end_stream);
}

extern "C" JNIEXPORT jint JNICALL Java_io_envoyproxy_envoymobile_engine_JniLibrary_sendHeaders(
    JNIEnv* env, jclass, jlong engine_handle, jlong stream_handle, jobjectArray headers,
    jboolean end_stream) {
  Envoy::JNI::JniHelper jni_helper(env);
  return reinterpret_cast<Envoy::Engine*>(engine_handle)
      ->sendHeaders(static_cast<envoy_stream_t>(stream_handle),
                    Envoy::JNI::javaArrayOfObjectArrayToEnvoyHeaders(jni_helper, headers),
                    end_stream);
}

extern "C" JNIEXPORT jint JNICALL Java_io_envoyproxy_envoymobile_engine_JniLibrary_sendTrailers(
    JNIEnv* env, jclass, jlong engine_handle, jlong stream_handle, jobjectArray trailers) {
  Envoy::JNI::JniHelper jni_helper(env);
  jni_log("[Envoy]", "jvm_send_trailers");
  return reinterpret_cast<Envoy::Engine*>(engine_handle)
      ->sendTrailers(static_cast<envoy_stream_t>(stream_handle),
                     Envoy::JNI::javaArrayOfObjectArrayToEnvoyHeaders(jni_helper, trailers));
}

extern "C" JNIEXPORT jint JNICALL Java_io_envoyproxy_envoymobile_engine_JniLibrary_resetStream(
    JNIEnv* /*env*/, jclass, jlong engine_handle, jlong stream_handle) {
  return reinterpret_cast<Envoy::Engine*>(engine_handle)
      ->cancelStream(static_cast<envoy_stream_t>(stream_handle));
}

// EnvoyStringAccessor

extern "C" JNIEXPORT jint JNICALL
Java_io_envoyproxy_envoymobile_engine_JniLibrary_registerStringAccessor(JNIEnv* env, jclass,
                                                                        jstring accessor_name,
                                                                        jobject j_context) {

  // TODO(goaway): The retained_context leaks, but it's tied to the life of the engine.
  // This will need to be updated for https://github.com/envoyproxy/envoy-mobile/issues/332.
  jobject retained_context = env->NewGlobalRef(j_context);

  envoy_string_accessor* string_accessor =
      static_cast<envoy_string_accessor*>(safe_malloc(sizeof(envoy_string_accessor)));
  string_accessor->get_string = jvm_get_string;
  string_accessor->context = retained_context;

  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr native_java_string =
      jni_helper.getStringUtfChars(accessor_name, nullptr);
  std::string api_name(native_java_string.get());
  Envoy::Api::External::registerApi(api_name, string_accessor);
  return ENVOY_SUCCESS;
}

// Takes a jstring from Java, converts it to a C++ string, calls the supplied
// setter on it.
void setString(Envoy::JNI::JniHelper& jni_helper, jstring java_string, EngineBuilder* builder,
               EngineBuilder& (EngineBuilder::*setter)(std::string)) {
  if (!java_string) {
    return;
  }
  Envoy::JNI::StringUtfUniquePtr native_java_string =
      jni_helper.getStringUtfChars(java_string, nullptr);
  std::string java_string_str(native_java_string.get());
  if (!java_string_str.empty()) {
    (builder->*setter)(java_string_str);
  }
}

// Converts a java byte array to a C++ string.
std::string javaByteArrayToString(Envoy::JNI::JniHelper& jni_helper, jbyteArray j_data) {
  size_t data_length = static_cast<size_t>(jni_helper.getArrayLength(j_data));
  Envoy::JNI::PrimitiveArrayCriticalUniquePtr<char> critical_data =
      jni_helper.getPrimitiveArrayCritical<char*>(j_data, nullptr);
  std::string ret(critical_data.get(), data_length);
  return ret;
}

// Converts a java object array to C++ vector of strings.
std::vector<std::string> javaObjectArrayToStringVector(Envoy::JNI::JniHelper& jni_helper,
                                                       jobjectArray entries) {
  std::vector<std::string> ret;
  // Note that headers is a flattened array of key/value pairs.
  // Therefore, the length of the native header array is n envoy_data or n/2 envoy_map_entry.
  envoy_map_size_t length = jni_helper.getArrayLength(entries);
  if (length == 0) {
    return ret;
  }

  for (envoy_map_size_t i = 0; i < length; ++i) {
    // Copy native byte array for header key
    Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_str =
        jni_helper.getObjectArrayElement<jbyteArray>(entries, i);
    std::string str = javaByteArrayToString(jni_helper, j_str.get());
    ret.push_back(javaByteArrayToString(jni_helper, j_str.get()));
  }

  return ret;
}

// Converts a java object array to C++ vector of pairs of strings.
std::vector<std::pair<std::string, std::string>>
javaObjectArrayToStringPairVector(Envoy::JNI::JniHelper& jni_helper, jobjectArray entries) {
  std::vector<std::pair<std::string, std::string>> ret;
  // Note that headers is a flattened array of key/value pairs.
  // Therefore, the length of the native header array is n envoy_data or n/2 envoy_map_entry.
  envoy_map_size_t length = jni_helper.getArrayLength(entries);
  if (length == 0) {
    return ret;
  }

  for (envoy_map_size_t i = 0; i < length; i += 2) {
    // Copy native byte array for header key
    Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_key =
        jni_helper.getObjectArrayElement<jbyteArray>(entries, i);
    Envoy::JNI::LocalRefUniquePtr<jbyteArray> j_value =
        jni_helper.getObjectArrayElement<jbyteArray>(entries, i + 1);
    std::string first = javaByteArrayToString(jni_helper, j_key.get());
    std::string second = javaByteArrayToString(jni_helper, j_value.get());
    ret.push_back(std::make_pair(first, second));
  }

  return ret;
}

void configureBuilder(Envoy::JNI::JniHelper& jni_helper, jlong connect_timeout_seconds,
                      jlong dns_refresh_seconds, jlong dns_failure_refresh_seconds_base,
                      jlong dns_failure_refresh_seconds_max, jlong dns_query_timeout_seconds,
                      jlong dns_min_refresh_seconds, jobjectArray dns_preresolve_hostnames,
                      jboolean enable_dns_cache, jlong dns_cache_save_interval_seconds,
                      jboolean enable_drain_post_dns_refresh, jboolean enable_http3,
                      jstring http3_connection_options, jstring http3_client_connection_options,
                      jobjectArray quic_hints, jobjectArray quic_canonical_suffixes,
                      jboolean enable_gzip_decompression, jboolean enable_brotli_decompression,
                      jboolean enable_socket_tagging, jboolean enable_interface_binding,
                      jlong h2_connection_keepalive_idle_interval_milliseconds,
                      jlong h2_connection_keepalive_timeout_seconds, jlong max_connections_per_host,
                      jlong stream_idle_timeout_seconds, jlong per_try_idle_timeout_seconds,
                      jstring app_version, jstring app_id, jboolean trust_chain_verification,
                      jobjectArray filter_chain, jboolean enable_platform_certificates_validation,
                      jobjectArray runtime_guards, jstring node_id, jstring node_region,
                      jstring node_zone, jstring node_sub_zone, jbyteArray serialized_node_metadata,
                      Envoy::Platform::EngineBuilder& builder) {
  builder.addConnectTimeoutSeconds((connect_timeout_seconds));
  builder.addDnsRefreshSeconds((dns_refresh_seconds));
  builder.addDnsFailureRefreshSeconds((dns_failure_refresh_seconds_base),
                                      (dns_failure_refresh_seconds_max));
  builder.addDnsQueryTimeoutSeconds((dns_query_timeout_seconds));
  builder.addDnsMinRefreshSeconds((dns_min_refresh_seconds));
  builder.enableDnsCache(enable_dns_cache == JNI_TRUE, dns_cache_save_interval_seconds);
  builder.addMaxConnectionsPerHost((max_connections_per_host));
  builder.addH2ConnectionKeepaliveIdleIntervalMilliseconds(
      (h2_connection_keepalive_idle_interval_milliseconds));
  builder.addH2ConnectionKeepaliveTimeoutSeconds((h2_connection_keepalive_timeout_seconds));

  setString(jni_helper, app_version, &builder, &EngineBuilder::setAppVersion);
  setString(jni_helper, app_id, &builder, &EngineBuilder::setAppId);
  builder.setDeviceOs("Android");

  builder.setStreamIdleTimeoutSeconds((stream_idle_timeout_seconds));
  builder.setPerTryIdleTimeoutSeconds((per_try_idle_timeout_seconds));
  builder.enableGzipDecompression(enable_gzip_decompression == JNI_TRUE);
  builder.enableBrotliDecompression(enable_brotli_decompression == JNI_TRUE);
  builder.enableSocketTagging(enable_socket_tagging == JNI_TRUE);
#ifdef ENVOY_ENABLE_QUIC
  builder.enableHttp3(enable_http3 == JNI_TRUE);
  builder.setHttp3ConnectionOptions(
      Envoy::JNI::javaStringToString(jni_helper, http3_connection_options));
  builder.setHttp3ClientConnectionOptions(
      Envoy::JNI::javaStringToString(jni_helper, http3_client_connection_options));
  auto hints = javaObjectArrayToStringPairVector(jni_helper, quic_hints);
  for (const std::pair<std::string, std::string>& entry : hints) {
    builder.addQuicHint(entry.first, stoi(entry.second));
  }
  std::vector<std::string> suffixes =
      javaObjectArrayToStringVector(jni_helper, quic_canonical_suffixes);
  for (const std::string& suffix : suffixes) {
    builder.addQuicCanonicalSuffix(suffix);
  }

#endif
  builder.enableInterfaceBinding(enable_interface_binding == JNI_TRUE);
  builder.enableDrainPostDnsRefresh(enable_drain_post_dns_refresh == JNI_TRUE);
  builder.enforceTrustChainVerification(trust_chain_verification == JNI_TRUE);
  builder.enablePlatformCertificatesValidation(enable_platform_certificates_validation == JNI_TRUE);
  builder.setForceAlwaysUsev6(true);

  auto guards = javaObjectArrayToStringPairVector(jni_helper, runtime_guards);
  for (std::pair<std::string, std::string>& entry : guards) {
    builder.setRuntimeGuard(entry.first, entry.second == "true");
  }

  auto filters = javaObjectArrayToStringPairVector(jni_helper, filter_chain);
  for (std::pair<std::string, std::string>& filter : filters) {
    builder.addNativeFilter(filter.first, filter.second);
  }

  std::vector<std::string> hostnames =
      javaObjectArrayToStringVector(jni_helper, dns_preresolve_hostnames);
  builder.addDnsPreresolveHostnames(hostnames);
  std::string native_node_id = Envoy::JNI::javaStringToString(jni_helper, node_id);
  if (!native_node_id.empty()) {
    builder.setNodeId(native_node_id);
  }
  std::string native_node_region = Envoy::JNI::javaStringToString(jni_helper, node_region);
  if (!native_node_region.empty()) {
    builder.setNodeLocality(native_node_region,
                            Envoy::JNI::javaStringToString(jni_helper, node_zone),
                            Envoy::JNI::javaStringToString(jni_helper, node_sub_zone));
  }
  Envoy::ProtobufWkt::Struct node_metadata;
  Envoy::JNI::javaByteArrayToProto(jni_helper, serialized_node_metadata, &node_metadata);
  builder.setNodeMetadata(node_metadata);
}

#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#endif

extern "C" JNIEXPORT jlong JNICALL Java_io_envoyproxy_envoymobile_engine_JniLibrary_createBootstrap(
    JNIEnv* env, jclass, jlong connect_timeout_seconds, jlong dns_refresh_seconds,
    jlong dns_failure_refresh_seconds_base, jlong dns_failure_refresh_seconds_max,
    jlong dns_query_timeout_seconds, jlong dns_min_refresh_seconds,
    jobjectArray dns_preresolve_hostnames, jboolean enable_dns_cache,
    jlong dns_cache_save_interval_seconds, jboolean enable_drain_post_dns_refresh,
    jboolean enable_http3, jstring http3_connection_options,
    jstring http3_client_connection_options, jobjectArray quic_hints,
    jobjectArray quic_canonical_suffixes, jboolean enable_gzip_decompression,
    jboolean enable_brotli_decompression, jboolean enable_socket_tagging,
    jboolean enable_interface_binding, jlong h2_connection_keepalive_idle_interval_milliseconds,
    jlong h2_connection_keepalive_timeout_seconds, jlong max_connections_per_host,
    jlong stream_idle_timeout_seconds, jlong per_try_idle_timeout_seconds, jstring app_version,
    jstring app_id, jboolean trust_chain_verification, jobjectArray filter_chain,
    jboolean enable_platform_certificates_validation, jobjectArray runtime_guards,
    jstring rtds_resource_name, jlong rtds_timeout_seconds, jstring xds_address, jlong xds_port,
    jobjectArray xds_grpc_initial_metadata, jstring xds_root_certs, jstring node_id,
    jstring node_region, jstring node_zone, jstring node_sub_zone,
    jbyteArray serialized_node_metadata, jstring cds_resources_locator, jlong cds_timeout_seconds,
    jboolean enable_cds) {
  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::Platform::EngineBuilder builder;

  configureBuilder(jni_helper, connect_timeout_seconds, dns_refresh_seconds,
                   dns_failure_refresh_seconds_base, dns_failure_refresh_seconds_max,
                   dns_query_timeout_seconds, dns_min_refresh_seconds, dns_preresolve_hostnames,
                   enable_dns_cache, dns_cache_save_interval_seconds, enable_drain_post_dns_refresh,
                   enable_http3, http3_connection_options, http3_client_connection_options,
                   quic_hints, quic_canonical_suffixes, enable_gzip_decompression,
                   enable_brotli_decompression, enable_socket_tagging, enable_interface_binding,
                   h2_connection_keepalive_idle_interval_milliseconds,
                   h2_connection_keepalive_timeout_seconds, max_connections_per_host,
                   stream_idle_timeout_seconds, per_try_idle_timeout_seconds, app_version, app_id,
                   trust_chain_verification, filter_chain, enable_platform_certificates_validation,
                   runtime_guards, node_id, node_region, node_zone, node_sub_zone,
                   serialized_node_metadata, builder);

  std::string native_xds_address = Envoy::JNI::javaStringToString(jni_helper, xds_address);
  if (!native_xds_address.empty()) {
#ifdef ENVOY_MOBILE_XDS
    Envoy::Platform::XdsBuilder xds_builder(std::move(native_xds_address), xds_port);
    auto initial_metadata =
        javaObjectArrayToStringPairVector(jni_helper, xds_grpc_initial_metadata);
    for (const std::pair<std::string, std::string>& entry : initial_metadata) {
      xds_builder.addInitialStreamHeader(entry.first, entry.second);
    }
    std::string native_root_certs = Envoy::JNI::javaStringToString(jni_helper, xds_root_certs);
    if (!native_root_certs.empty()) {
      xds_builder.setSslRootCerts(std::move(native_root_certs));
    }
    std::string native_rtds_resource_name =
        Envoy::JNI::javaStringToString(jni_helper, rtds_resource_name);
    if (!native_rtds_resource_name.empty()) {
      xds_builder.addRuntimeDiscoveryService(std::move(native_rtds_resource_name),
                                             rtds_timeout_seconds);
    }
    if (enable_cds == JNI_TRUE) {
      xds_builder.addClusterDiscoveryService(
          Envoy::JNI::javaStringToString(jni_helper, cds_resources_locator), cds_timeout_seconds);
    }
    builder.setXds(std::move(xds_builder));
#else
    jni_helper.throwNew("java/lang/UnsupportedOperationException",
                        "This library does not support xDS. Please use "
                        "io.envoyproxy.envoymobile:envoy-xds instead.");
#endif
  }

  return reinterpret_cast<intptr_t>(builder.generateBootstrap().release());
}

#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

extern "C" JNIEXPORT jint JNICALL
Java_io_envoyproxy_envoymobile_engine_JniLibrary_resetConnectivityState(JNIEnv* /*env*/,
                                                                        jclass, // class
                                                                        jlong engine) {
  jni_log("[Envoy]", "resetConnectivityState");
  return reinterpret_cast<Envoy::Engine*>(engine)->resetConnectivityState();
}

extern "C" JNIEXPORT jint JNICALL
Java_io_envoyproxy_envoymobile_engine_JniLibrary_setPreferredNetwork(JNIEnv* /*env*/,
                                                                     jclass, // class
                                                                     jlong engine, jint network) {
  jni_log("[Envoy]", "setting preferred network");
  return reinterpret_cast<Envoy::Engine*>(engine)->setPreferredNetwork(
      static_cast<envoy_network_t>(network));
}

extern "C" JNIEXPORT jint JNICALL Java_io_envoyproxy_envoymobile_engine_JniLibrary_setProxySettings(
    JNIEnv* env,
    jclass, // class
    jlong engine, jstring host, jint port) {
  jni_log("[Envoy]", "setProxySettings");

  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr java_host = jni_helper.getStringUtfChars(host, nullptr);
  const uint16_t native_port = static_cast<uint16_t>(port);

  envoy_status_t result =
      reinterpret_cast<Envoy::Engine*>(engine)->setProxySettings(java_host.get(), native_port);

  return result;
}

static void jvm_add_test_root_certificate(const uint8_t* cert, size_t len) {
  jni_log("[Envoy]", "jvm_add_test_root_certificate");
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_AndroidNetworkLibrary =
      Envoy::JNI::findClass("io.envoyproxy.envoymobile.utilities.AndroidNetworkLibrary");
  jmethodID jmid_addTestRootCertificate = jni_helper.getStaticMethodId(
      jcls_AndroidNetworkLibrary.get(), "addTestRootCertificate", "([B)V");

  Envoy::JNI::LocalRefUniquePtr<jbyteArray> cert_array =
      Envoy::JNI::byteArrayToJavaByteArray(jni_helper, cert, len);
  jni_helper.callStaticVoidMethod(jcls_AndroidNetworkLibrary.get(), jmid_addTestRootCertificate,
                                  cert_array.get());
}

static void jvm_clear_test_root_certificate() {
  jni_log("[Envoy]", "jvm_clear_test_root_certificate");
  Envoy::JNI::JniHelper jni_helper(Envoy::JNI::getEnv());
  Envoy::JNI::LocalRefUniquePtr<jclass> jcls_AndroidNetworkLibrary =
      Envoy::JNI::findClass("io.envoyproxy.envoymobile.utilities.AndroidNetworkLibrary");
  jmethodID jmid_clearTestRootCertificates = jni_helper.getStaticMethodId(
      jcls_AndroidNetworkLibrary.get(), "clearTestRootCertificates", "()V");

  jni_helper.callStaticVoidMethod(jcls_AndroidNetworkLibrary.get(), jmid_clearTestRootCertificates);
}

extern "C" JNIEXPORT jobject JNICALL
Java_io_envoyproxy_envoymobile_engine_JniLibrary_callCertificateVerificationFromNative(
    JNIEnv* env, jclass, jobjectArray certChain, jbyteArray jauthType, jbyteArray jhost) {
  Envoy::JNI::JniHelper jni_helper(env);
  std::vector<std::string> cert_chain;
  std::string auth_type;
  std::string host;

  Envoy::JNI::javaArrayOfByteArrayToStringVector(jni_helper, certChain, &cert_chain);
  Envoy::JNI::javaByteArrayToString(jni_helper, jauthType, &auth_type);
  Envoy::JNI::javaByteArrayToString(jni_helper, jhost, &host);

  return callJvmVerifyX509CertChain(jni_helper, cert_chain, auth_type, host).release();
}

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_JniLibrary_callAddTestRootCertificateFromNative(
    JNIEnv* env, jclass, jbyteArray jcert) {
  Envoy::JNI::JniHelper jni_helper(env);
  std::vector<uint8_t> cert;
  Envoy::JNI::javaByteArrayToByteVector(jni_helper, jcert, &cert);
  jvm_add_test_root_certificate(cert.data(), cert.size());
}

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_JniLibrary_callClearTestRootCertificateFromNative(JNIEnv*,
                                                                                        jclass) {
  jvm_clear_test_root_certificate();
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")
load("//bazel:android_debug_info.bzl", "android_debug_info")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

# Support for JNI, using NDK on Android and Java otherwise, since the JNI APIs
# differ a bit between the two.
envoy_cc_library(
    name = "jni_support_lib",
    srcs = select({
        "@envoy//bazel:android": ["ndk_jni_support.cc"],
        "//conditions:default": ["java_jni_support.cc"],
    }),
    hdrs = ["jni_support.h"],
    linkopts = select({
        "@envoy//bazel:android": ["-llog"],
        "//conditions:default": [],
    }),
    repository = "@envoy",
    deps = [
        "//library/common/jni/import:jni_import_lib",
    ],
)

# Various JNI helper libraries.
envoy_cc_library(
    name = "jni_utility_lib",
    srcs = [
        "jni_utility.cc",
    ],
    hdrs = [
        "jni_utility.h",
    ],
    repository = "@envoy",
    deps = [
        ":jni_helper_lib",
        ":jni_support_lib",
        "//library/common/jni/import:jni_import_lib",
        "//library/common/jni/types:jni_env_lib",
        "//library/common/jni/types:jni_exception_lib",
        "//library/common/types:c_types_lib",
        "//library/common/types:managed_types_lib",
        "//library/common/types:matcher_data_lib",
        "@envoy//source/common/common:assert_lib",
        "@envoy//source/common/protobuf",
    ],
)

envoy_cc_library(
    name = "jni_helper_lib",
    srcs = [
        "jni_helper.cc",
    ],
    hdrs = [
        "jni_helper.h",
    ],
    repository = "@envoy",
    deps = [
        "//library/common/jni/import:jni_import_lib",
        "@envoy//source/common/common:assert_lib",
    ],
)

# Implementations of the various "native" Java methods for classes
# in library/java/io/envoyproxy/envoymobile.
envoy_cc_library(
    name = "jni_impl_lib",
    srcs = [
        "jni_impl.cc",
    ],
    repository = "@envoy",
    deps = [
        ":android_network_utility_lib",
        ":jni_utility_lib",
        "//library/cc:engine_builder_lib",
        "//library/common:engine_lib",
        "//library/common/api:c_types",
        "//library/common/extensions/cert_validator/platform_bridge:c_types_lib",
        "//library/common/extensions/key_value/platform:config",
        "//library/common/jni/types:jni_exception_lib",
        "//library/common/jni/types:jni_javavm_lib",
        "//library/common/types:managed_types_lib",
        "@envoy//source/common/protobuf",
    ],
    # We need this to ensure that we link this into the .so even though there are no code references.
    alwayslink = True,
)

# Cert verification related functions which call into AndroidNetworkLibrary.
envoy_cc_library(
    name = "android_network_utility_lib",
    srcs = [
        "android_network_utility.cc",
    ],
    hdrs = [
        "android_network_utility.h",
    ],
    repository = "@envoy",
    deps = [
        ":jni_utility_lib",
        "//library/common/api:c_types",
        "//library/common/data:utility_lib",
        "//library/common/extensions/cert_validator/platform_bridge:c_types_lib",
        "//library/common/jni/import:jni_import_lib",
        "//library/common/jni/types:jni_exception_lib",
        "//library/common/jni/types:jni_javavm_lib",
        "//library/common/types:c_types_lib",
        "@envoy//bazel:boringssl",
    ],
)

# Implementations of the "native" Java methods for AndroidJniLibrary.java
envoy_cc_library(
    name = "android_jni_impl_lib",
    srcs = [
        "android_jni_impl.cc",
    ],
    repository = "@envoy",
    deps = [
        ":android_network_utility_lib",
        ":jni_impl_lib",
        ":jni_support_lib",
        ":jni_utility_lib",
        "//library/common:engine_lib",
        "//library/common/jni/import:jni_import_lib",
    ],
    # We need this to ensure that we link this into the .so even though there are no code references.
    alwayslink = True,
)

# Library which contains all the JNI related targets.
envoy_cc_library(
    name = "envoy_jni_lib",
    linkopts = select({
        "@envoy//bazel:dbg_build": ["-Wl,--build-id=sha1"],
        "//conditions:default": [],
    }),
    repository = "@envoy",
    deps = [
        ":android_jni_impl_lib",
        ":android_network_utility_lib",
        ":jni_impl_lib",
        ":jni_support_lib",
        ":jni_utility_lib",
    ],
    # We need this to ensure that we link this into the .so even though there are no code references.
    alwayslink = True,
)

config_setting(
    name = "android_armeabi",
    constraint_values = [
        "@platforms//cpu:armv7",
        "@platforms//os:android",
    ],
)

# Main dynamic library for the Envoy Mobile aar
cc_binary(
    name = "libenvoy_jni.so",
    linkopts = [
        # Without this option the app crashes when launched
        # on arm64 emulator which is not covered by CI.
        "-ldl",
        # Brotli compressor includes libm, so Envoy itself gets it by default.
        # Envoy Mobile doesn't include Brotli compressor, so libm doesn't get
        # included in the build, but several parts of Envoy rely on libm, for
        # example, for std::pow, so we link it in here.
        "-lm",
    ] + select({
        "@envoy//bazel:dbg_build": ["-Wl,--build-id=sha1"],
        "//conditions:default": [],
    }),
    linkshared = True,
    deps = [
        ":envoy_jni_lib",
        "@envoy_mobile_extra_jni_deps//:extra_jni_dep",
    ],
)

android_debug_info(
    name = "libenvoy_jni.so.debug_info",
    dep = "libenvoy_jni.so",
)

envoy_cc_library(
    name = "android_jni_utility_lib",
    srcs = [
        "android_jni_utility.cc",
    ],
    hdrs = [
        "android_jni_utility.h",
    ],
    repository = "@envoy",
    deps = [
        "//library/common/types:c_types_lib",
        "@envoy//source/common/common:assert_lib",
    ] + select({
        "@envoy//bazel:android": [
            ":jni_support_lib",
            ":jni_utility_lib",
            "//library/common/data:utility_lib",
            "//library/common/jni/import:jni_import_lib",
        ],
        "//conditions:default": [],
    }),
)
#pragma once

#include <jni.h>

// NOLINT(namespace-envoy)

// This validates that the jni.h header that we include is *not* the jni.h provided by the JVM. This
// helps ensure that the build is using a consistent jni.h header.
#if defined(__ANDROID_API__) && defined(_JAVASOFT_JNI_H_)
#error "JVM jni.h imported during android build"
#endif
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "jni_import_lib",
    srcs = [
        "jni_import.h",
    ],
    repository = "@envoy",
    deps = select({
        "@envoy//bazel:linux": ["//bazel:jni"],
        "@envoy//bazel:apple": ["//bazel:jni"],
        "//conditions:default": [],
    }),
)
#include "library/common/data/utility.h"

#include <stdlib.h>

#include "source/common/buffer/buffer_impl.h"
#include "source/common/common/empty_string.h"

#include "library/common/buffer/bridge_fragment.h"

namespace Envoy {
namespace Data {
namespace Utility {

void updateMaxBytes(uint32_t& max_bytes, const Buffer::Instance& data) {
  if (max_bytes == 0) {
    max_bytes = data.length();
  } else {
    max_bytes = std::min<uint32_t>(max_bytes, data.length());
  }
}

Buffer::InstancePtr toInternalData(envoy_data data) {
  // This fragment only needs to live until done is called.
  // Therefore, it is sufficient to allocate on the heap, and delete in the done method.
  Buffer::BridgeFragment* fragment = Buffer::BridgeFragment::createBridgeFragment(data);
  Buffer::InstancePtr buf = std::make_unique<Buffer::OwnedImpl>();
  buf->addBufferFragment(*fragment);
  return buf;
}

envoy_data toBridgeData(Buffer::Instance& data, uint32_t max_bytes) {
  updateMaxBytes(max_bytes, data);
  envoy_data bridge_data = copyToBridgeData(data, max_bytes);
  data.drain(bridge_data.length);
  return bridge_data;
}

envoy_data copyToBridgeData(absl::string_view str) {
  uint8_t* buffer = static_cast<uint8_t*>(safe_malloc(sizeof(uint8_t) * str.length()));
  memcpy(buffer, str.data(), str.length()); // NOLINT(safe-memcpy)
  return {str.length(), buffer, free, buffer};
}

envoy_data copyToBridgeData(const Buffer::Instance& data, uint32_t max_bytes) {
  updateMaxBytes(max_bytes, data);
  uint8_t* buffer = static_cast<uint8_t*>(safe_malloc(sizeof(uint8_t) * max_bytes));
  data.copyOut(0, max_bytes, buffer);
  return {static_cast<size_t>(max_bytes), buffer, free, buffer};
}

std::string copyToString(envoy_data data) {
  if (data.length == 0) {
    return EMPTY_STRING;
  }
  return std::string(const_cast<char*>(reinterpret_cast<const char*>((data.bytes))), data.length);
}

} // namespace Utility
} // namespace Data
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "utility_lib",
    srcs = ["utility.cc"],
    hdrs = ["utility.h"],
    repository = "@envoy",
    deps = [
        "//library/common/buffer:bridge_fragment_lib",
        "//library/common/types:c_types_lib",
        "@envoy//envoy/buffer:buffer_interface",
        "@envoy//source/common/buffer:buffer_lib",
        "@envoy//source/common/common:empty_string",
    ],
)
#pragma once

#include "envoy/buffer/buffer.h"

#include "library/common/types/c_types.h"

namespace Envoy {
namespace Data {
namespace Utility {

/**
 * Transform envoy_data to Envoy::Buffer::Instance.
 * @param headers, the envoy_data to transform.
 * @return Envoy::Buffer::InstancePtr, the native transformation of the envoy_data param.
 */
Buffer::InstancePtr toInternalData(envoy_data data);

/**
 * Transform from Buffer::Instance to envoy_data.
 * @param data, the Buffer::Instance to transform.
 * @param max_bytes, the maximum bytes to transform or 0 to copy all available data.
 * @return envoy_data, the bridge transformation of the Buffer::Instance param.
 */
envoy_data toBridgeData(Buffer::Instance& data, uint32_t max_bytes = 0);

/**
 * Copy from string to envoy_data.
 * @param str, the string to copy.
 * @return envoy_data, the copy produced of the original string.
 */
envoy_data copyToBridgeData(absl::string_view);

/**
 * Copy from Buffer::Instance to envoy_data.
 * @param data, the Buffer::Instance to copy.
 * @param max_bytes, the maximum bytes to copy or 0 to copy all available data.
 * @return envoy_data, the copy produced from the Buffer::Instance param.
 */
envoy_data copyToBridgeData(const Buffer::Instance& data, uint32_t max_bytes = 0);

/**
 * Copy envoy_data into an std::string.
 * @param data, the envoy_data to copy.
 * @return std::string the string constructed from data.
 */
std::string copyToString(envoy_data data);

} // namespace Utility
} // namespace Data
} // namespace Envoy
#pragma once

#include <functional>
#include <memory>

#include "envoy/thread/thread.h"

namespace Envoy {
namespace Thread {

/**
 * A lock guard that deals with an optional lock and allows call-sites to release the lock prior to
 * the lock guard going out of scope.
 */
// TODO(junr03): this could be moved to Envoy's codebase.
class ABSL_SCOPED_LOCKABLE OptionalReleasableLockGuard {
public:
  /**
   * Establishes a scoped mutex-lock. If non-null, the mutex is locked upon construction.
   *
   * @param lock the mutex.
   */
  OptionalReleasableLockGuard(BasicLockable* lock) ABSL_EXCLUSIVE_LOCK_FUNCTION(lock)
      : lock_(lock) {
    if (lock_ != nullptr) {
      lock_->lock();
    }
  }

  /**
   * Destruction of the OptionalReleasableLockGuard unlocks the lock, if it is non-null and has not
   * already been explicitly released.
   */
  ~OptionalReleasableLockGuard() ABSL_UNLOCK_FUNCTION() { release(); }

  /**
   * Unlocks the mutex. This enables call-sites to release the mutex prior to the Lock going out of
   * scope.
   */
  void release() ABSL_UNLOCK_FUNCTION() {
    if (lock_ != nullptr) {
      lock_->unlock();
      lock_ = nullptr;
    }
  }

private:
  BasicLockable* lock_; // Set to nullptr on unlock, to prevent double-unlocking.
};

} // namespace Thread
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "lock_guard_lib",
    hdrs = ["lock_guard.h"],
    repository = "@envoy",
    deps = [
        "@envoy//envoy/thread:thread_interface",
        "@envoy//source/common/common:thread_annotations",
    ],
)
#pragma once

#include "envoy/event/deferred_deletable.h"
#include "envoy/event/dispatcher.h"

#include "source/common/common/thread_synchronizer.h"

#include "library/common/types/c_types.h"

namespace Envoy {
namespace Event {

/**
 * Wrapper around Envoy's Event::Dispatcher that queues callbacks until drain() is called. Future
 * versions may support correct calling semantics after the Event::Dispatcher has been
 * terminated/deleted or before it has been created.
 */
class ProvisionalDispatcher : public ScopeTracker {
public:
  ProvisionalDispatcher() = default;
  virtual ~ProvisionalDispatcher() = default;

  // ScopeTracker
  void pushTrackedObject(const ScopeTrackedObject* object) override;
  void popTrackedObject(const ScopeTrackedObject* expected_object) override;
  bool trackedObjectStackIsEmpty() const override;

  /**
   * Drains all queued callbacks to the real dispatcher. Must be called after the underlying
   * dispatcher is running. Further posts will be transparently passed through.
   */
  virtual void drain(Event::Dispatcher& event_dispatcher);

  // TODO(goaway): return ENVOY_FAILURE after the underlying dispatcher has exited.
  /**
   * Before the Event::Dispatcher is running, queues posted callbacks; afterwards passes them
   * through.
   * @param callback, the callback to be dispatched.
   * @return should return ENVOY_FAILURE when the Event::Dispatcher exits, but at present it
   * always returns ENVOY_SUCCESS.
   */
  virtual envoy_status_t post(Event::PostCb callback);

  /**
   * Allocates a schedulable callback. @see SchedulableCallback for docs on how to use the wrapped
   * callback.
   * @param cb supplies the callback to invoke when the SchedulableCallback is triggered on the
   * event loop.
   * Must be called from context where ProvisionalDispatcher::isThreadSafe() is true.
   */
  virtual Event::SchedulableCallbackPtr createSchedulableCallback(std::function<void()> cb);

  /**
   * @return false before the Event::Dispatcher is running, otherwise the result of the
   * underlying call to Event::Dispatcher::isThreadSafe().
   */
  virtual bool isThreadSafe() const;

  /**
   * Submits an item for deferred delete. Must be called from context where
   * ProvisionalDispatcher::isThreadSafe() is true.
   */
  virtual void deferredDelete(DeferredDeletablePtr&& to_delete);

  /**
   * Exposes the TimeSource held by the underlying Event::Dispatcher.
   */
  virtual TimeSource& timeSource();

  /**
   * Marks the dispatcher as terminated, preventing any future work from being enqueued.
   */
  virtual void terminate();

  // Used for testing.
  Thread::ThreadSynchronizer& synchronizer() { return synchronizer_; }

private:
  // TODO(goaway): This class supports a straightforward case-specific lock-free implementation, but
  // uses heavyweight synchronization for expediency at present.
  Thread::MutexBasicLockable state_lock_;
  bool drained_ ABSL_GUARDED_BY(state_lock_){};
  std::list<Event::PostCb> init_queue_ ABSL_GUARDED_BY(state_lock_);
  Event::Dispatcher* event_dispatcher_{};
  Thread::ThreadSynchronizer synchronizer_;
  bool terminated_ ABSL_GUARDED_BY(state_lock_){};
};

using ProvisionalDispatcherPtr = std::unique_ptr<ProvisionalDispatcher>;

} // namespace Event
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "provisional_dispatcher_lib",
    srcs = ["provisional_dispatcher.cc"],
    hdrs = ["provisional_dispatcher.h"],
    external_deps = ["abseil_optional"],
    repository = "@envoy",
    deps = [
        "//library/common/thread:lock_guard_lib",
        "//library/common/types:c_types_lib",
        "@envoy//envoy/event:deferred_deletable",
        "@envoy//envoy/event:dispatcher_interface",
        "@envoy//source/common/common:lock_guard_lib",
        "@envoy//source/common/common:thread_synchronizer_lib",
    ],
)
#include "library/common/event/provisional_dispatcher.h"

#include "source/common/common/lock_guard.h"

#include "library/common/thread/lock_guard.h"

namespace Envoy {
namespace Event {

void ProvisionalDispatcher::drain(Event::Dispatcher& event_dispatcher) {
  // TODO(goaway): Must be called from the Event::Dispatcher's thread, but we can't assert here
  // because of behavioral oddities in Event::Dispatcher: event_dispatcher_->isThreadSafe() will
  // crash.
  Thread::LockGuard lock(state_lock_);

  // Don't perform any work on the dispatcher if marked as terminated.
  if (terminated_) {
    event_dispatcher.exit();
    return;
  }

  RELEASE_ASSERT(!drained_, "ProvisionalDispatcher::drain must only occur once");
  drained_ = true;
  event_dispatcher_ = &event_dispatcher;

  while (!init_queue_.empty()) {
    event_dispatcher_->post(std::move(init_queue_.front()));
    init_queue_.pop_front();
  }
}

envoy_status_t ProvisionalDispatcher::post(Event::PostCb callback) {
  Thread::LockGuard lock(state_lock_);

  // Don't perform any work on the dispatcher if marked as terminated.
  if (terminated_) {
    return ENVOY_FAILURE;
  }

  if (drained_) {
    event_dispatcher_->post(std::move(callback));
    return ENVOY_SUCCESS;
  }

  init_queue_.push_back(std::move(callback));
  return ENVOY_SUCCESS;
}

Event::SchedulableCallbackPtr
ProvisionalDispatcher::createSchedulableCallback(std::function<void()> cb) {
  RELEASE_ASSERT(
      isThreadSafe(),
      "ProvisionalDispatcher::createSchedulableCallback must be called from a threadsafe context");
  return event_dispatcher_->createSchedulableCallback(cb);
}

bool ProvisionalDispatcher::isThreadSafe() const {
  // Doesn't require locking because if a thread has a stale view of drained_, then by definition
  // this wasn't a threadsafe call.
  return ABSL_TS_UNCHECKED_READ(drained_) && event_dispatcher_->isThreadSafe();
}

void ProvisionalDispatcher::deferredDelete(DeferredDeletablePtr&& to_delete) {
  RELEASE_ASSERT(isThreadSafe(),
                 "ProvisionalDispatcher::deferredDelete must be called from a threadsafe context");
  event_dispatcher_->deferredDelete(std::move(to_delete));
}

void ProvisionalDispatcher::pushTrackedObject(const ScopeTrackedObject* object) {
  RELEASE_ASSERT(
      isThreadSafe(),
      "ProvisionalDispatcher::pushTrackedObject must be called from a threadsafe context");
  event_dispatcher_->pushTrackedObject(object);
}

void ProvisionalDispatcher::popTrackedObject(const ScopeTrackedObject* expected_object) {
  RELEASE_ASSERT(
      isThreadSafe(),
      "ProvisionalDispatcher::popTrackedObject must be called from a threadsafe context");
  event_dispatcher_->popTrackedObject(expected_object);
}

bool ProvisionalDispatcher::trackedObjectStackIsEmpty() const {
  RELEASE_ASSERT(
      isThreadSafe(),
      "ProvisionalDispatcher::trackedObjectStackIsEmpty must be called from a threadsafe context");
  return event_dispatcher_->trackedObjectStackIsEmpty();
}

TimeSource& ProvisionalDispatcher::timeSource() { return event_dispatcher_->timeSource(); }

void ProvisionalDispatcher::terminate() {
  Thread::LockGuard lock(state_lock_);
  if (drained_) {
    event_dispatcher_->exit();
  }
  terminated_ = true;
}

} // namespace Event
} // namespace Envoy
// From upstream Envoy
#include "source/common/stats/utility.h"

#include "library/common/data/utility.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Stats {
namespace Utility {

Stats::StatNameTagVector transformToStatNameTagVector(envoy_stats_tags tags,
                                                      Stats::StatNameSetPtr& stat_name_set) {
  Stats::StatNameTagVector transformed_tags;
  for (envoy_map_size_t i = 0; i < tags.length; i++) {
    std::string key(Data::Utility::copyToString(tags.entries[i].key));
    std::string val(Data::Utility::copyToString(tags.entries[i].value));

    transformed_tags.push_back({stat_name_set->add(key), stat_name_set->add(val)});
  }
  // The C envoy_stats_tags struct can be released now because the tags have been copied.
  release_envoy_stats_tags(tags);
  return transformed_tags;
}
} // namespace Utility
} // namespace Stats
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "utility_lib",
    srcs = [
        "utility.cc",
    ],
    hdrs = ["utility.h"],
    repository = "@envoy",
    deps = [
        "//library/common/data:utility_lib",
        "@envoy//source/common/stats:utility_lib",
    ],
)
#pragma once

// From upstream Envoy
#include "source/common/stats/utility.h"

#include "library/common/types/c_types.h"

namespace Envoy {
namespace Stats {
namespace Utility {

/**
 * Transforms from envoy_stats_tags to Stats::StatNameTagVector.
 *
 * @param envoy_stats_tags tags to be transformed. tags is free'd. Use after function return is
 * unsafe.
 * @param stat_name_set the Stats::StatNameSetPtr for the transformed Stats::StatNameTagVector to be
 * kept in.
 * @return Stats::StatNameTagVector within the given stat_name_set.
 */
Stats::StatNameTagVector transformToStatNameTagVector(envoy_stats_tags tags,
                                                      Stats::StatNameSetPtr& stat_name_set);
} // namespace Utility
} // namespace Stats
} // namespace Envoy
#pragma once

#include "envoy/buffer/buffer.h"

#include "source/common/common/non_copyable.h"

#include "library/common/types/c_types.h"

namespace Envoy {
namespace Buffer {

/**
 * An implementation of BufferFragment backed by envoy_data.
 */
class BridgeFragment : NonCopyable, public BufferFragment {
public:
  // TODO: Consider moving this to a BridgeFragmentFactory class.
  static BridgeFragment* createBridgeFragment(envoy_data data) { return new BridgeFragment(data); }

  // Buffer::BufferFragment
  const void* data() const override { return data_.bytes; }
  size_t size() const override { return data_.length; }
  void done() override {
    release_envoy_data(data_);
    delete this;
  }

private:
  BridgeFragment(envoy_data data) : data_(data) {}
  ~BridgeFragment() {}
  envoy_data data_;
};

} // namespace Buffer
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "bridge_fragment_lib",
    hdrs = ["bridge_fragment.h"],
    repository = "@envoy",
    deps = [
        "//library/common/types:c_types_lib",
        "@envoy//envoy/buffer:buffer_interface",
    ],
)
-dontwarn android.support.**
-dontwarn kotlin.**
-dontwarn org.jetbrains.annotations.NotNull
-dontwarn org.jetbrains.annotations.Nullable

-dontnote android.support.**
-dontnote kotlin.**
-dontnote com.google.devtools.build.android.**

-keepclasseswithmembernames,includedescriptorclasses class * {
    native <methods>;
}

-keep, includedescriptorclasses class io.envoyproxy.envoymobile.utilities.AndroidNetworkLibrary {
   <methods>;
}

-keep, includedescriptorclasses class io.envoyproxy.envoymobile.utilities.AndroidCertVerifyResult {
   <methods>;
}

-keep, includedescriptorclasses class io.envoyproxy.envoymobile.engine.types.EnvoyEventTracker {
   <methods>;
}

-keep, includedescriptorclasses class io.envoyproxy.envoymobile.engine.types.EnvoyOnEngineRunning {
   <methods>;
}

-keep, includedescriptorclasses class io.envoyproxy.envoymobile.engine.EnvoyHTTPFilterCallbacksImpl {
   <methods>;
}

-keep, includedescriptorclasses class io.envoyproxy.envoymobile.engine.JvmBridgeUtility {
   <methods>;
}

-keep, includedescriptorclasses class io.envoyproxy.envoymobile.engine.JvmCallbackContext {
   <methods>;
}

-keep, includedescriptorclasses class io.envoyproxy.envoymobile.engine.JvmFilterContext {
   <methods>;
}

-keep, includedescriptorclasses class io.envoyproxy.envoymobile.engine.JvmFilterFactoryContext {
   <methods>;
}

-keep, includedescriptorclasses class io.envoyproxy.envoymobile.engine.JvmKeyValueStoreContext {
   <methods>;
}

-keep, includedescriptorclasses class io.envoyproxy.envoymobile.engine.JvmStringAccessorContext {
   <methods>;
}

-keep class io.envoyproxy.envoymobile.engine.types.EnvoyLogger {
   <methods>;
}
@_implementationOnly import EnvoyEngine
import Foundation

/// Mock implementation of `EnvoyEngine`. Used internally for testing the bridging layer & mocking.
final class MockEnvoyEngine: NSObject {
  init(runningCallback onEngineRunning: (() -> Void)? = nil, logger: ((String) -> Void)? = nil,
       eventTracker: (([String: String]) -> Void)? = nil, networkMonitoringMode: Int32 = 0) {}

  /// Closure called when `run(withConfig:)` is called.
  static var onRunWithConfig: ((_ config: EnvoyConfiguration, _ logLevel: String?) -> Void)?
  /// Closure called when `run(withConfigYAML:)` is called.
  static var onRunWithYAML: ((
    _ yaml: String,
    _ config: EnvoyConfiguration,
    _ logLevel: String?
  ) -> Void)?

  /// Closure called when `recordCounterInc(_:tags:count:)` is called.
  static var onRecordCounter: (
    (_ elements: String, _ tags: [String: String], _ count: UInt) -> Void)?
}

extension MockEnvoyEngine: EnvoyEngine {
  func run(withConfig config: EnvoyConfiguration, logLevel: String) -> Int32 {
    MockEnvoyEngine.onRunWithConfig?(config, logLevel)
    return kEnvoySuccess
  }

  func run(withYAML yaml: String, config: EnvoyConfiguration, logLevel: String) -> Int32 {
    MockEnvoyEngine.onRunWithYAML?(yaml, config, logLevel)
    return kEnvoySuccess
  }

  func startStream(
    with callbacks: EnvoyHTTPCallbacks,
    explicitFlowControl: Bool
  ) -> EnvoyHTTPStream {
    return MockEnvoyHTTPStream(handle: 0, engine: 0, callbacks: callbacks,
                               explicitFlowControl: explicitFlowControl)
  }

  func recordCounterInc(_ elements: String, tags: [String: String], count: UInt) -> Int32 {
    MockEnvoyEngine.onRecordCounter?(elements, tags, count)
    return kEnvoySuccess
  }

  func dumpStats() -> String {
    return ""
  }

  func terminate() {}

  func resetConnectivityState() {}
}
@_implementationOnly import EnvoyEngine
import Foundation

/// Mock implementation of `Stream` that also provides an interface for sending
/// mocked responses through to the stream's callbacks. Created via `MockStreamPrototype`.
@objcMembers
public final class MockStream: Stream {
  private let mockStream: MockEnvoyHTTPStream

  /// Closure that will be called when request headers are sent.
  public var onRequestHeaders: ((_ headers: RequestHeaders, _ endStream: Bool) -> Void)?
  /// Closure that will be called when request data is sent.
  public var onRequestData: ((_ data: Data, _ endStream: Bool) -> Void)?
  /// Closure that will be called when request trailers are sent.
  public var onRequestTrailers: ((_ trailers: RequestTrailers) -> Void)?
  /// Closure that will be called when the stream is canceled by the client.
  public var onCancel: (() -> Void)?

  init(mockStream: MockEnvoyHTTPStream) {
    self.mockStream = mockStream
    super.init(underlyingStream: mockStream)
  }

  // MARK: - Overrides

  public override func sendHeaders(_ headers: RequestHeaders, endStream: Bool) -> Stream {
    self.onRequestHeaders?(headers, endStream)
    return self
  }

  public override func sendData(_ data: Data) -> Stream {
    self.onRequestData?(data, false)
    return self
  }

  public override func close(data: Data) {
    self.onRequestData?(data, true)
  }

  public override func close(trailers: RequestTrailers) {
    self.onRequestTrailers?(trailers)
  }

  public override func cancel() {
    self.onCancel?()
  }

  // MARK: - Mocking responses

  /// Simulate response headers coming back over the stream.
  ///
  /// - parameter headers:   Response headers to receive.
  /// - parameter endStream: Whether this is a headers-only response.
  public func receiveHeaders(_ headers: ResponseHeaders, endStream: Bool) {
    self.mockStream.callbacks.onHeaders?(headers.caseSensitiveHeaders(), endStream,
                                         EnvoyStreamIntel())
  }

  /// Simulate response data coming back over the stream.
  ///
  /// - parameter data:      Response data to receive.
  /// - parameter endStream: Whether this is the last data frame.
  public func receiveData(_ data: Data, endStream: Bool) {
    self.mockStream.callbacks.onData?(data, endStream, EnvoyStreamIntel())
  }

  /// Simulate trailers coming back over the stream.
  ///
  /// - parameter trailers: Response trailers to receive.
  public func receiveTrailers(_ trailers: ResponseTrailers) {
    self.mockStream.callbacks.onTrailers?(trailers.caseSensitiveHeaders(), EnvoyStreamIntel())
  }

  /// Simulate the stream receiving a cancellation signal from Envoy.
  public func receiveCancel() {
    self.mockStream.callbacks.onCancel?(EnvoyStreamIntel(), EnvoyFinalStreamIntel())
  }

  /// Simulate Envoy returning an error.
  ///
  /// - parameter error: The error to receive.
  public func receiveError(_ error: EnvoyError) {
    self.mockStream.callbacks.onError?(error.errorCode, error.message,
                                       Int32(error.attemptCount ?? 0),
                                       EnvoyStreamIntel(), EnvoyFinalStreamIntel())
  }
}
@_implementationOnly import EnvoyEngine
import Foundation

/// Internal no-op mock implementation of the engine's `EnvoyHTTPStream`.
final class MockEnvoyHTTPStream: EnvoyHTTPStream {
  /// Callbacks associated with the stream.
  let callbacks: EnvoyHTTPCallbacks
  let explicitFlowControl: Bool

  init(handle: Int, engine: Int, callbacks: EnvoyHTTPCallbacks, explicitFlowControl: Bool) {
    self.callbacks = callbacks
    self.explicitFlowControl = explicitFlowControl
  }

  func sendHeaders(_ headers: [String: [String]], close: Bool) {}

  func readData(_ byteCount: size_t) {}

  func send(_ data: Data, close: Bool) {}

  func sendTrailers(_ trailers: [String: [String]]) {}

  func cancel() -> Int32 { return 0 }

  func cleanUp() {}
}
import Dispatch
@_implementationOnly import EnvoyEngine
import Foundation

/// Mock implementation of `StreamPrototype` which is used to produce `MockStream` instances.
@objcMembers
public final class MockStreamPrototype: StreamPrototype {
  private let onStart: ((MockStream) -> Void)?

  /// Initialize a new instance of the mock prototype.
  ///
  /// - parameter onStart: Closure that will be called each time a new stream
  ///                      is started from the prototype.
  init(onStart: @escaping (MockStream) -> Void) {
    self.onStart = onStart
    super.init(engine: MockEnvoyEngine())
  }

  public override func start(queue: DispatchQueue = .main) -> Stream {
    let callbacks = self.createCallbacks(queue: queue)
    let underlyingStream = MockEnvoyHTTPStream(handle: 0, engine: 0, callbacks: callbacks,
                                               explicitFlowControl: false)
    let stream = MockStream(mockStream: underlyingStream)
    self.onStart?(stream)
    return stream
  }
}
import Foundation

/// Mock implementation of `StreamClient` which produces `MockStreamPrototype` values.
@objcMembers
public final class MockStreamClient: NSObject {
  /// Closure that may be set to observe the creation of new streams.
  /// It will be called each time `newStreamPrototype()` is executed.
  ///
  /// Typically, this is used to capture streams on creation before sending values through them.
  public var onStartStream: ((MockStream) -> Void)?

  // Only explicitly implemented to work around a swiftinterface issue in Swift 5.1. This can be
  // removed once envoy is only built with Swift 5.2+
  public override init() {
    self.onStartStream = nil
    super.init()
  }

  /// Initialize a new instance of the stream client.
  ///
  /// - parameter onStartStream: Closure that may be set to observe the creation of new streams.
  public init(onStartStream: ((MockStream) -> Void)? = nil) {
    self.onStartStream = onStartStream
    super.init()
  }
}

extension MockStreamClient: StreamClient {
  public func newStreamPrototype() -> StreamPrototype {
    return MockStreamPrototype(onStart: { [weak self] in self?.onStartStream?($0) })
  }
}
extension RetryPolicy {
  /// Converts the retry policy to a set of headers recognized by Envoy.
  ///
  /// - returns: The header representation of the retry policy.
  func outboundHeaders() -> [String: [String]] {
    var headers = [
      "x-envoy-max-retries": ["\(self.maxRetryCount)"],
      "x-envoy-upstream-rq-timeout-ms": ["\(self.totalUpstreamTimeoutMS ?? 0)"],
    ]

    var retryOn = self.retryOn.map { $0.stringValue }
    if !self.retryStatusCodes.isEmpty {
      retryOn.append("retriable-status-codes")
      headers["x-envoy-retriable-status-codes"] = self.retryStatusCodes.map { "\($0)" }
    }

    headers["x-envoy-retry-on"] = retryOn

    if let perRetryTimeoutMS = self.perRetryTimeoutMS {
      headers["x-envoy-upstream-rq-per-try-timeout-ms"] = ["\(perRetryTimeoutMS)"]
    }

    return headers
  }

  // Envoy internally coalesces multiple x-envoy header values into one comma-delimited value.
  // These functions split those values up to correctly map back to Swift enums.
  static func splitRetryRule(value: String) -> [RetryRule] {
    return value.components(separatedBy: ",").compactMap(RetryRule.init)
  }
  static func splitRetriableStatusCodes(value: String) -> [UInt] {
    return value.components(separatedBy: ",").compactMap(UInt.init)
  }

  /// Initialize the retry policy from a set of headers.
  ///
  /// - parameter headers: The headers with which to initialize the retry policy.
  ///
  /// - returns: The `RetryPolicy` if one was derived from the headers.
  static func from(headers: Headers) -> RetryPolicy? {
    guard let maxRetryCount = headers.value(forName: "x-envoy-max-retries")?
      .first.flatMap(UInt.init) else
    {
      return nil
    }

    return RetryPolicy(
      maxRetryCount: maxRetryCount,
      retryOn: headers.value(forName: "x-envoy-retry-on")?
        .flatMap(RetryPolicy.splitRetryRule) ?? [],
      retryStatusCodes: headers.value(forName: "x-envoy-retriable-status-codes")?
        .flatMap(RetryPolicy.splitRetriableStatusCodes) ?? [],
      perRetryTimeoutMS: headers.value(forName: "x-envoy-upstream-rq-per-try-timeout-ms")?
        .first.flatMap(UInt.init),
      totalUpstreamTimeoutMS: headers.value(forName: "x-envoy-upstream-rq-timeout-ms")?
        .first.flatMap(UInt.init)
    )
  }
}
import Foundation

/// ResponseFilter supporting asynchronous resumption.
public protocol AsyncResponseFilter: ResponseFilter {
  /// Called by the filter manager once to initialize the filter callbacks that the filter should
  /// use.
  ///
  /// - parameter callbacks: The callbacks for this filter to use to interact with the chain.
  func setResponseFilterCallbacks(_ callbacks: ResponseFilterCallbacks)

  /// Invoked explicitly in response to an asynchronous `resumeResponse()` callback when filter
  /// iteration has been stopped. The parameters passed to this invocation will be a snapshot
  /// of any stream state that has not yet been forwarded along the filter chain.
  ///
  /// As with other filter invocations, this will be called on Envoy's main thread, and thus
  /// no additional synchronization is required between this and other invocations.
  ///
  /// - parameter headers:     Headers, if `stopIteration` was returned from `onResponseHeaders`.
  /// - parameter data:        Any data that has been buffered where `stopIterationAndBuffer` was
  ///                          returned.
  /// - parameter trailers:    Trailers, if `stopIteration` was returned from `onReponseTrailers`.
  /// - parameter endStream:   True, if the stream ended with the previous (and thus, last)
  ///                          invocation.
  /// - parameter streamIntel: Internal HTTP stream metrics, context, and other details.
  ///
  /// - returns: The resumption status including any HTTP entities that will be forwarded.
  func onResumeResponse(
    headers: ResponseHeaders?,
    data: Data?,
    trailers: ResponseTrailers?,
    endStream: Bool,
    streamIntel: StreamIntel
  ) -> FilterResumeStatus<ResponseHeaders, ResponseTrailers>
}
@_implementationOnly import EnvoyEngine
import Foundation

/// Envoy implementation of ResponseFilterCallbacks
final class ResponseFilterCallbacksImpl: NSObject {
  private let callbacks: EnvoyHTTPFilterCallbacks

  init(callbacks: EnvoyHTTPFilterCallbacks) {
    self.callbacks = callbacks
    super.init()
  }
}

extension ResponseFilterCallbacksImpl: ResponseFilterCallbacks {
  func resumeResponse() {
    self.callbacks.resumeIteration()
  }

  func resetIdleTimer() {
    self.callbacks.resetIdleTimer()
  }
}
@_implementationOnly import EnvoyEngine
import Foundation

/// Envoy implementation of RequestFilterCallbacks
final class RequestFilterCallbacksImpl: NSObject {
  private let callbacks: EnvoyHTTPFilterCallbacks

  init(callbacks: EnvoyHTTPFilterCallbacks) {
    self.callbacks = callbacks
    super.init()
  }
}

extension RequestFilterCallbacksImpl: RequestFilterCallbacks {
  func resumeRequest() {
    self.callbacks.resumeIteration()
  }

  func resetIdleTimer() {
    self.callbacks.resetIdleTimer()
  }
}
import Foundation

/// Status returned by filters when transmitting or receiving trailers.
@frozen
public enum FilterTrailersStatus<T: Headers, U: Trailers>: Equatable {
  /// Continue filter chain iteration, passing the provided trailers through.
  ///
  /// - params trailers: The (potentially-modified) trailers to be forwarded along the filter chain.
  case `continue`(trailers: U)

  /// Do not iterate to any of the remaining filters in the chain with trailers.
  ///
  /// Because trailers are by definition the last HTTP entity of a request or response, only
  /// asynchronous filters support resumption after returning `stopIteration` from on*Trailers.
  /// Calling `resumeRequest()`/`resumeResponse()` MUST occur if continued filter iteration
  /// is desired.
  case stopIteration

  /// Resume previously-stopped iteration, possibly forwarding headers and data if iteration was
  /// stopped during an on*Headers or on*Data invocation.
  ///
  /// It is an error to return `resumeIteration` if iteration is not currently stopped, and it is
  /// an error to include headers if headers have already been forwarded to the next filter
  /// (i.e. iteration was stopped during an on*Data invocation instead of on*Headers).
  ///
  /// - param headers: Headers to be forwarded (if needed).
  /// - param data: Data to be forwarded (if needed).
  /// - param trailers: Trailers to be forwarded.
  case resumeIteration(headers: T? = nil, data: Data? = nil, trailers: U)
}
public protocol RequestFilterCallbacks {
  /// Resume iterating through the filter chain with buffered headers and body data.
  ///
  /// This can only be called if the filter has previously returned `stopIteration{...}` from
  /// `onHeaders()`/`onData()`/`onTrailers()`.
  ///
  /// This will result in an `onResumeRequest()` callback on the RequestFilter.
  ///
  /// If the request is not complete, the filter may receive further `onData()`/`onTrailers()`
  /// calls.
  func resumeRequest()

  /// Reset the underlying stream idle timeout to its configured threshold.
  ///
  /// This may be useful if a filter stops iteration for an extended period of time, since stream
  /// timeouts will still apply. This may be called periodically to continue to indicate "activity"
  /// on the stream.
  func resetIdleTimer()
}
/// Status returned by filters when transmitting or receiving headers.
@frozen
public enum FilterHeadersStatus<T: Headers>: Equatable {
  /// Continue filter chain iteration, passing the provided headers through.
  ///
  /// - params headers: The (potentially-modified) headers to be forwarded along the filter chain.
  case `continue`(headers: T)

  /// Do not iterate to any of the remaining filters in the chain with headers.
  ///
  /// Returning `resumeIteration` from another filter invocation or calling
  /// `resumeRequest()`/`resumeResponse()` MUST occur when continued filter iteration is
  /// desired.
  case stopIteration
}
import Foundation

/// Status returned by filters when transmitting or receiving data.
@frozen
public enum FilterDataStatus<T: Headers>: Equatable {
  /// Continue filter chain iteration. If headers have not yet been sent to the next filter, they
  /// will be sent first via `onRequestHeaders()`/`onResponseHeaders()`.
  ///
  /// - param data: The (potentially-modified) data to be forwarded along the filter chain.
  case `continue`(data: Data)

  /// Do not iterate to any of the remaining filters in the chain, and buffer body data for later
  /// dispatching. The data passed to this invocation will be buffered internally.
  ///
  /// `onData` will continue to be called with any new chunks of data appended to all data that has
  /// been buffered so far.
  ///
  /// Returning `resumeIteration from another filter invocation or calling
  /// `resumeRequest()`/`resumeResponse()` MUST be called when continued filter iteration is
  /// desired.
  ///
  /// This should be called by filters which must parse a larger block of the incoming data before
  /// continuing processing.
  case stopIterationAndBuffer

  /// Do not iterate to any of the remaining filters in the chain, and do not internally buffer
  /// data.
  ///
  /// `onData` will continue to be called with new chunks of data.
  ///
  /// Returning `resumeIteration` from another filter invocation or calling
  /// `resumeRequest()`/`resumeResponse()` MUST be called when continued filter iteration is
  /// desired.
  ///
  /// This may be called by filters which must parse a larger block of the incoming data before
  /// continuing processing, and will handle their own buffering.
  case stopIterationNoBuffer

  /// Resume previously-stopped iteration, possibly forwarding headers if iteration was stopped
  /// during an on*Headers invocation.
  ///
  /// It is an error to return `resumeIteration` if iteration is not currently stopped, and it is
  /// an error to include headers if headers have already been forwarded to the next filter
  /// (i.e. iteration was stopped during an on*Data invocation instead of on*Headers).
  ///
  /// - param headers: Headers to be forwarded (if needed).
  /// - param data: Data to be forwarded.
  case resumeIteration(headers: T? = nil, data: Data)
}
@_implementationOnly import EnvoyEngine
import Foundation

/// Interface representing a filter. See `RequestFilter` and `ResponseFilter` for more details.
public protocol Filter {
}

extension EnvoyHTTPFilterFactory {
  convenience init(filterName: String, factory: @escaping () -> Filter) {
    self.init()
    self.filterName = filterName
    self.create = { EnvoyHTTPFilter(filter: factory()) }
  }
}

extension EnvoyHTTPFilter {
  /// Initialize an EnvoyHTTPFilter using the instance methods of a concrete Filter implementation.
  ///
  /// - parameter filter: The contrete `Filter` to wrap.
  convenience init(filter: Filter) {
    self.init()

    if let requestFilter = filter as? RequestFilter {
      self.onRequestHeaders = { envoyHeaders, endStream, streamIntel in
        let result = requestFilter.onRequestHeaders(RequestHeaders(headers: envoyHeaders),
                                                    endStream: endStream,
                                                    streamIntel: StreamIntel(streamIntel))
        switch result {
        case .continue(let headers):
          return [kEnvoyFilterHeadersStatusContinue, headers.caseSensitiveHeaders()]
        case .stopIteration:
          return [kEnvoyFilterHeadersStatusStopIteration, NSNull()]
        }
      }

      self.onRequestData = { data, endStream, streamIntel in
        let result = requestFilter.onRequestData(data, endStream: endStream,
                                                 streamIntel: StreamIntel(streamIntel))
        switch result {
        case .continue(let data):
          return [kEnvoyFilterDataStatusContinue, data]
        case .stopIterationAndBuffer:
          return [kEnvoyFilterDataStatusStopIterationAndBuffer, NSNull()]
        case .stopIterationNoBuffer:
          return [kEnvoyFilterDataStatusStopIterationNoBuffer, NSNull()]
        case .resumeIteration(let headers, let data):
          return [
                    kEnvoyFilterDataStatusResumeIteration, data,
                    headers?.caseSensitiveHeaders() as Any,
          ]
        }
      }

      self.onRequestTrailers = { envoyTrailers, streamIntel in
        let result = requestFilter.onRequestTrailers(RequestTrailers(headers: envoyTrailers),
                                                     streamIntel: StreamIntel(streamIntel))
        switch result {
        case .continue(let trailers):
          return [kEnvoyFilterTrailersStatusContinue, trailers.caseSensitiveHeaders()]
        case .stopIteration:
          return [kEnvoyFilterTrailersStatusStopIteration, NSNull()]
        case .resumeIteration(let headers, let data, let trailers):
          return [
            kEnvoyFilterTrailersStatusResumeIteration,
            trailers.caseSensitiveHeaders(),
            headers?.caseSensitiveHeaders() as Any,
            data as Any,
          ]
        }
      }
    }

    if let responseFilter = filter as? ResponseFilter {
      self.onResponseHeaders = { envoyHeaders, endStream, streamIntel in
        let result = responseFilter.onResponseHeaders(ResponseHeaders(headers: envoyHeaders),
                                                      endStream: endStream,
                                                      streamIntel: StreamIntel(streamIntel))
        switch result {
        case .continue(let headers):
          return [kEnvoyFilterHeadersStatusContinue, headers.caseSensitiveHeaders()]
        case .stopIteration:
          return [kEnvoyFilterHeadersStatusStopIteration, NSNull()]
        }
      }

      self.onResponseData = { data, endStream, streamIntel in
        let result = responseFilter.onResponseData(data, endStream: endStream,
                                                   streamIntel: StreamIntel(streamIntel))
        switch result {
        case .continue(let data):
          return [kEnvoyFilterDataStatusContinue, data]
        case .stopIterationAndBuffer:
          return [kEnvoyFilterDataStatusStopIterationAndBuffer, NSNull()]
        case .stopIterationNoBuffer:
          return [kEnvoyFilterDataStatusStopIterationNoBuffer, NSNull()]
        case .resumeIteration(let headers, let data):
          return [
                    kEnvoyFilterDataStatusResumeIteration, data,
                    headers?.caseSensitiveHeaders() as Any,
          ]
        }
      }

      self.onResponseTrailers = { envoyTrailers, streamIntel in
        let result = responseFilter.onResponseTrailers(ResponseTrailers(headers: envoyTrailers),
                                                       streamIntel: StreamIntel(streamIntel))
        switch result {
        case .continue(let trailers):
          return [kEnvoyFilterTrailersStatusContinue, trailers.caseSensitiveHeaders()]
        case .stopIteration:
          return [kEnvoyFilterTrailersStatusStopIteration, NSNull()]
        case .resumeIteration(let headers, let data, let trailers):
          return [
            kEnvoyFilterTrailersStatusResumeIteration,
            trailers.caseSensitiveHeaders(),
            headers?.caseSensitiveHeaders() as Any,
            data as Any,
          ]
        }
      }

      self.onError = { errorCode, message, attemptCount, streamIntel, finalStreamIntel in
        let error = EnvoyError(errorCode: errorCode, message: message,
                               attemptCount: UInt32(exactly: attemptCount), cause: nil)
        responseFilter.onError(error, streamIntel: FinalStreamIntel(streamIntel, finalStreamIntel))
      }

      self.onCancel = { streamIntel, finalStreamIntel in
        responseFilter.onCancel(streamIntel: FinalStreamIntel(streamIntel, finalStreamIntel))
      }

      self.onComplete = { streamIntel, finalStreamIntel in
        responseFilter.onComplete(streamIntel: FinalStreamIntel(streamIntel, finalStreamIntel))
      }
    }

    if let asyncRequestFilter = filter as? AsyncRequestFilter {
      self.setRequestFilterCallbacks = { envoyCallbacks in
        asyncRequestFilter.setRequestFilterCallbacks(
          RequestFilterCallbacksImpl(callbacks: envoyCallbacks)
        )
      }

      self.onResumeRequest = { envoyHeaders, data, envoyTrailers, endStream, streamIntel in
        let result = asyncRequestFilter.onResumeRequest(
          headers: envoyHeaders.map(RequestHeaders.init),
          data: data,
          trailers: envoyTrailers.map(RequestTrailers.init),
          endStream: endStream,
          streamIntel: StreamIntel(streamIntel))
        switch result {
        case .resumeIteration(let headers, let data, let trailers):
          return [
            kEnvoyFilterResumeStatusResumeIteration,
            headers?.caseSensitiveHeaders() as Any,
            data as Any,
            trailers?.caseSensitiveHeaders() as Any,
          ]
        }
      }
    }

    if let asyncResponseFilter = filter as? AsyncResponseFilter {
      self.setResponseFilterCallbacks = { envoyCallbacks in
        asyncResponseFilter.setResponseFilterCallbacks(
          ResponseFilterCallbacksImpl(callbacks: envoyCallbacks)
        )
      }

      self.onResumeResponse = { envoyHeaders, data, envoyTrailers, endStream, streamIntel in
        let result = asyncResponseFilter.onResumeResponse(
          headers: envoyHeaders.map(ResponseHeaders.init),
          data: data,
          trailers: envoyTrailers.map(ResponseTrailers.init),
          endStream: endStream,
          streamIntel: StreamIntel(streamIntel))
        switch result {
        case .resumeIteration(let headers, let data, let trailers):
          return [
            kEnvoyFilterResumeStatusResumeIteration,
            headers?.caseSensitiveHeaders() as Any,
            data as Any,
            trailers?.caseSensitiveHeaders() as Any,
          ]
        }
      }
    }
  }
}
import Foundation

/// Filter executed for outbound requests, providing the ability to observe and mutate streams.
public protocol RequestFilter: Filter {
  /// Called once when the request is initiated.
  ///
  /// Filters may mutate or delay the request headers.
  ///
  /// - parameter headers:     The current request headers.
  /// - parameter endStream:   Whether this is a headers-only request.
  /// - parameter streamIntel: Internal HTTP stream metrics, context, and other details.
  ///
  /// - returns: The header status containing headers with which to continue or buffer.
  func onRequestHeaders(_ headers: RequestHeaders, endStream: Bool, streamIntel: StreamIntel)
    -> FilterHeadersStatus<RequestHeaders>

  /// Called any number of times whenever body data is sent.
  ///
  /// Filters may mutate or buffer (defer and concatenate) the data.
  ///
  /// - parameter body:        The outbound body data chunk.
  /// - parameter endStream:   Whether this is the last data frame.
  /// - parameter streamIntel: Internal HTTP stream metrics, context, and other details.
  ///
  /// - returns: The data status containing body with which to continue or buffer.
  func onRequestData(_ body: Data, endStream: Bool, streamIntel: StreamIntel)
    -> FilterDataStatus<RequestHeaders>

  /// Called at most once when the request is closed from the client with trailers.
  ///
  /// Filters may mutate or delay the trailers. Note trailers imply the stream has ended.
  ///
  /// - parameter trailers:    The outbound trailers.
  /// - parameter streamIntel: Internal HTTP stream metrics, context, and other details.
  ///
  /// - returns: The trailer status containing body with which to continue or buffer.
  func onRequestTrailers(_ trailers: RequestTrailers, streamIntel: StreamIntel)
    -> FilterTrailersStatus<RequestHeaders, RequestTrailers>
}
import Foundation

/// Status returned by filters after resuming iteration asynchronously.
@frozen
public enum FilterResumeStatus<T: Headers, U: Trailers>: Equatable {
  /// Resume previously-stopped iteration, potentially forwarding headers, data, and/or trailers
  /// that have not yet been passed along the filter chain.
  ///
  /// It is an error to return resumeIteration if iteration is not currently stopped, and it is
  /// an error to include headers if headers have already been forwarded to the next filter
  /// (i.e. iteration was stopped during an on*Data invocation instead of on*Headers). It is also
  /// an error to include data or trailers if `endStream` was previously set or if trailers have
  /// already been forwarded.
  ///
  /// - param headers: Headers to be forwarded (if needed).
  /// - param data: Data to be forwarded (if needed).
  /// - param trailers: Trailers to be forwarded (if needed).
  case resumeIteration(headers: T? = nil, data: Data? = nil, trailers: U?)
}
import Foundation

/// Filter executed for inbound responses, providing the ability to observe and mutate streams.
public protocol ResponseFilter: Filter {
  /// Called once when the response is initiated.
  ///
  /// Filters may mutate or delay the response headers.
  ///
  /// - parameter headers:     The current response headers.
  /// - parameter endStream:   Whether this is a headers-only response.
  /// - parameter streamIntel: Internal HTTP stream metrics, context, and other details.
  ///
  /// - returns: The header status containing headers with which to continue or buffer.
  func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool, streamIntel: StreamIntel)
    -> FilterHeadersStatus<ResponseHeaders>

  /// Called any number of times whenever body data is received.
  ///
  /// Filters may mutate or buffer (defer and concatenate) the data.
  ///
  /// - parameter body:        The inbound body data chunk.
  /// - parameter endStream:   Whether this is the last data frame.
  /// - parameter streamIntel: Internal HTTP stream metrics, context, and other details.
  ///
  /// - returns: The data status containing body with which to continue or buffer.
  func onResponseData(_ body: Data, endStream: Bool, streamIntel: StreamIntel)
    -> FilterDataStatus<ResponseHeaders>

  /// Called at most once when the response is closed from the server with trailers.
  ///
  /// Filters may mutate or delay the trailers. Note trailers imply the stream has ended.
  ///
  /// - parameter trailers:    The outbound trailers.
  /// - parameter streamIntel: Internal HTTP stream metrics, context, and other details.
  ///
  /// - returns: The trailer status containing body with which to continue or buffer.
  func onResponseTrailers(_ trailers: ResponseTrailers, streamIntel: StreamIntel)
    -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers>

  /// Called at most once when an error within Envoy occurs.
  ///
  /// Only one of `onError`, `onCancel`, or `onComplete` will be called per stream.
  /// This should be considered a terminal state, and invalidates any previous attempts to
  /// `stopIteration{...}`.
  ///
  /// - parameter error:       The error that occurred within Envoy.
  /// - parameter streamIntel: Final internal HTTP stream metrics, context, and other details.
  func onError(_ error: EnvoyError, streamIntel: FinalStreamIntel)

  /// Called at most once when the client cancels the stream.
  ///
  /// Only one of `onError`, `onCancel`, or `onComplete` will be called per stream.
  /// This should be considered a terminal state, and invalidates any previous attempts to
  /// `stopIteration{...}`.
  ///
  /// - parameter streamIntel: Final internal HTTP stream metrics, context, and other details.
  func onCancel(streamIntel: FinalStreamIntel)

  /// Called at most once when the stream completes gracefully.
  ///
  /// Only one of `onError`, `onCancel`, or `onComplete` will be called per stream.
  /// This should be considered a terminal state, and invalidates any previous attempts to
  /// `stopIteration{...}`.
  ///
  /// - parameter streamIntel: Final internal HTTP stream metrics, context, and other details.
  func onComplete(streamIntel: FinalStreamIntel)
}
public protocol ResponseFilterCallbacks {
  /// Resume iterating through the filter chain with buffered headers and body data.
  ///
  /// This can only be called if the filter has previously returned `stopIteration{...}` from
  /// `onHeaders()`/`onData()`/`onTrailers()`.
  ///
  /// This will result in an `onResumeResponse()` callback on the ResponseFilter.
  ///
  /// If the response is not complete, the filter may receive further `onData()`/`onTrailers()`
  /// calls.
  func resumeResponse()

  /// Reset the underlying stream idle timeout to its configured threshold.
  ///
  /// This may be useful if a filter stops iteration for an extended period of time, since stream
  /// timeouts will still apply. This may be called periodically to continue to indicate "activity"
  /// on the stream.
  func resetIdleTimer()
}
import Foundation

/// RequestFilter supporting asynchronous resumption.
public protocol AsyncRequestFilter: RequestFilter {
  /// Called by the filter manager once to initialize the filter callbacks that the filter should
  /// use.
  ///
  /// - parameter callbacks: The callbacks for this filter to use to interact with the chain.
  func setRequestFilterCallbacks(_ callbacks: RequestFilterCallbacks)

  /// Invoked explicitly in response to an asynchronous `resumeRequest()` callback when filter
  /// iteration has been stopped. The parameters passed to this invocation will be a snapshot
  /// of any stream state that has not yet been forwarded along the filter chain.
  ///
  /// As with other filter invocations, this will be called on Envoy's main thread, and thus
  /// no additional synchronization is required between this and other invocations.
  ///
  /// - parameter headers:     Headers, if `stopIteration` was returned from `onRequestHeaders`.
  /// - parameter data:        Any data that has been buffered where `stopIterationAndBuffer` was
  ///                          returned.
  /// - parameter trailers:    Trailers, if `stopIteration` was returned from `onRequestTrailers`.
  /// - parameter endStream:   True, if the stream ended with the previous (and thus, last)
  ///                          invocation.
  /// - parameter streamIntel: Internal HTTP stream metrics, context, and other details.
  ///
  /// - returns: The resumption status including any HTTP entities that will be forwarded.
  func onResumeRequest(
    headers: RequestHeaders?,
    data: Data?,
    trailers: RequestTrailers?,
    endStream: Bool,
    streamIntel: StreamIntel
  ) -> FilterResumeStatus<RequestHeaders, RequestTrailers>
}
import Foundation

/// Base class used to represent trailer data structures.
/// To instantiate a new instance, see `{Request|Response}TrailersBuilder`.
@objcMembers
public class Trailers: Headers {
}
@_implementationOnly import EnvoyEngine
import Foundation

/// Envoy implementation of StreamClient.
final class StreamClientImpl: NSObject {
  private let engine: EnvoyEngine

  init(engine: EnvoyEngine) {
    self.engine = engine
    super.init()
  }
}

extension StreamClientImpl: StreamClient {
  func newStreamPrototype() -> StreamPrototype {
    return StreamPrototype(engine: self.engine)
  }
}
@_implementationOnly import EnvoyEngine
import Foundation

/// Envoy implementation of PulseClient.
final class PulseClientImpl: NSObject {
  private let engine: EnvoyEngine

  init(engine: EnvoyEngine) {
    self.engine = engine
    super.init()
  }
}

extension PulseClientImpl: PulseClient {
  func counter(elements: [Element]) -> Counter {
    return CounterImpl(elements: elements, tags: TagsBuilder().build(), engine: self.engine)
  }

  func counter(elements: [Element], tags: Tags) -> Counter {
    return CounterImpl(elements: elements, tags: tags, engine: self.engine)
  }
}
import Foundation

/// Trailers representing an inbound response.
@objcMembers
public final class ResponseTrailers: Trailers {
  /// Convert the trailers back to a builder for mutation.
  ///
  /// - returns: The new builder.
  public func toResponseTrailersBuilder() -> ResponseTrailersBuilder {
    return ResponseTrailersBuilder(container: self.container)
  }
}
@_implementationOnly import EnvoyEngine
import Foundation

/// A type representing a stream that is actively transferring data.
///
/// Constructed using `StreamPrototype`, and used to write to the network.
@objcMembers
public class Stream: NSObject {
  private let underlyingStream: EnvoyHTTPStream

  /// Initialize a new instance of the stream.
  ///
  /// - parameter underlyingStream: Underlying stream that can be used to send request data.
  init(underlyingStream: EnvoyHTTPStream) {
    self.underlyingStream = underlyingStream
    super.init()
  }

  // MARK: - Public

  /// Send headers over the stream.
  ///
  /// - parameter headers:   Headers to send over the stream.
  /// - parameter endStream: Whether this is a headers-only request.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func sendHeaders(_ headers: RequestHeaders, endStream: Bool) -> Stream {
    self.underlyingStream.sendHeaders(headers.caseSensitiveHeaders(), close: endStream)
    return self
  }

  /// Read data from the response stream. Returns immediately.
  /// Has no effect if explicit flow control is not enabled.
  ///
  /// - parameter byteCount: Maximum number of bytes that may be be passed by the next data
  ///                        callback.
  ///
  /// - returns: This stream, for chaining syntax.
  public func readData(_ byteCount: Int) -> Stream {
    self.underlyingStream.readData(byteCount)
    return self
  }

  /// Send data over the stream.
  ///
  /// - parameter data: Data to send over the stream.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func sendData(_ data: Data) -> Stream {
    self.underlyingStream.send(data, close: false)
    return self
  }

  /// Close the stream with trailers.
  ///
  /// - parameter trailers: Trailers with which to close the stream.
  public func close(trailers: RequestTrailers) {
    self.underlyingStream.sendTrailers(trailers.caseSensitiveHeaders())
  }

  /// Close the stream with a data frame.
  ///
  /// - parameter data: Data with which to close the stream.
  public func close(data: Data) {
    self.underlyingStream.send(data, close: true)
  }

  /// Cancel the stream.
  public func cancel() {
    _ = self.underlyingStream.cancel()
  }
}
import Foundation

private let kRestrictedPrefixes = [":", "x-envoy-mobile"]

private func isRestrictedHeader(name: String) -> Bool {
  let lowercasedName = name.lowercased()
  let isHostHeader = lowercasedName == "host"
  return isHostHeader || kRestrictedPrefixes.contains(where: lowercasedName.starts(with:))
}

/// Base builder class used to construct `Headers` instances.
/// It preserves the original casing of headers and enforces
/// a case-insensitive lookup and setting of headers.
/// See `{Request|Response}HeadersBuilder` for usage.
@objcMembers
public class HeadersBuilder: NSObject {
  private(set) var container: HeadersContainer

  /// Append a value to the header name.
  ///
  /// - parameter name:  The header name.
  /// - parameter value: The value associated to the header name.
  ///
  /// - returns: This builder.
  @discardableResult
  public func add(name: String, value: String) -> Self {
    if isRestrictedHeader(name: name) {
      return self
    }

    self.container.add(name: name, value: value)
    return self
  }

  /// Replace all values at the provided name with a new set of header values.
  ///
  /// - parameter name:  The header name.
  /// - parameter value: The value associated to the header name.
  ///
  /// - returns: This builder.
  @discardableResult
  public func set(name: String, value: [String]) -> Self {
    if isRestrictedHeader(name: name) {
      return self
    }

    self.container.set(name: name, value: value)
    return self
  }

  /// Remove all headers with this name.
  ///
  /// - parameter name: The header name to remove.
  ///
  /// - returns: This builder.
  @discardableResult
  public func remove(name: String) -> Self {
    if isRestrictedHeader(name: name) {
      return self
    }

    self.container.remove(name: name)
    return self
  }

  // MARK: - Internal

  /// Allows for setting headers that are not publicly mutable (i.e., restricted headers).
  ///
  /// - parameter name:  The header name.
  /// - parameter value: The value associated to the header name.
  ///
  /// - returns: This builder.
  @discardableResult
  func internalSet(name: String, value: [String]) -> Self {
    self.container.set(name: name, value: value)
    return self
  }

  /// Accessor for all underlying case-sensitive headers. When possible,
  /// use case-insensitive accessors instead.
  ///
  /// - returns: The underlying case-sensitive headers.
  func caseSensitiveHeaders() -> [String: [String]] {
    return self.container.caseSensitiveHeaders()
  }

  // Only explicitly implemented to work around a swiftinterface issue in Swift 5.1. This can be
  // removed once envoy is only built with Swift 5.2+
  public override init() {
    self.container = HeadersContainer()
    super.init()
  }

  // Initialize a new builder using the provided headers container.
  ///
  /// - parameter container: The headers container to initialize the receiver with.
  init(container: HeadersContainer) {
    self.container = container
    super.init()
  }

  // Initialize a new builder. Subclasses should provide their own public convenience initializers.
  //
  // - parameter headers: The headers with which to start.
  init(headers: [String: [String]]) {
    self.container = HeadersContainer(headers: headers)
    super.init()
  }
}

// MARK: - Equatable

extension HeadersBuilder {
  public override func isEqual(_ object: Any?) -> Bool {
    return (object as? Self)?.container == self.container
  }
}
import Foundation

/// Builder used for constructing instances of `RequestTrailers`.
@objcMembers
public final class RequestTrailersBuilder: HeadersBuilder {
  /// Initialize a new instance of the builder.
  public override convenience init() {
    self.init(container: HeadersContainer(headers: [:]))
  }

  /// Build the request trailers using the current builder.
  ///
  /// - returns: New instance of request trailers.
  public func build() -> RequestTrailers {
    return RequestTrailers(container: self.container)
  }
}
import Foundation

/// gRPC prefix length: 1 byte for compression and 4 bytes for message length.
let kGRPCPrefixLength: Int = 5

/// A type representing a gRPC stream that is actively transferring data.
///
/// Constructed using `GRPCStreamPrototype`, and used to write to the network.
@objcMembers
public final class GRPCStream: NSObject {
  private let underlyingStream: Stream

  // MARK: - Internal

  /// Initialize a new instance of the stream.
  ///
  /// - parameter underlyingStream: The underlying stream to use for sending data.
  required init(underlyingStream: Stream) {
    self.underlyingStream = underlyingStream
    super.init()
  }

  // MARK: - Public

  /// Send headers over the gRPC stream.
  ///
  /// - parameter headers:   Headers to send over the stream.
  /// - parameter endStream: Whether this is a headers-only request.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func sendHeaders(_ headers: GRPCRequestHeaders, endStream: Bool) -> GRPCStream {
    self.underlyingStream.sendHeaders(headers, endStream: endStream)
    return self
  }

  /// Send a protobuf message's binary data over the gRPC stream.
  ///
  /// - parameter messageData: Binary data of a protobuf message to send.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func sendMessage(_ messageData: Data) -> GRPCStream {
    // https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests
    // Length-Prefixed-Message = Compressed-Flag | Message-Length | Message
    // Compressed-Flag = 0 / 1, encoded as 1 byte unsigned integer
    // Message-Length = length of Message, encoded as 4 byte unsigned integer (big endian)
    // Message = binary representation of protobuf message
    var prefixData = Data(capacity: kGRPCPrefixLength)

    // Compression flag (1 byte) - 0, not compressed
    prefixData.append(0)

    // Message length (4 bytes)
    var length = UInt32(messageData.count).bigEndian
    prefixData.append(Data(bytes: &length, count: MemoryLayout<UInt32>.size))

    // Send prefix data followed by message data
    self.underlyingStream.sendData(prefixData)
    self.underlyingStream.sendData(messageData)
    return self
  }

  /// Cancel the stream forcefully regardless of whether the peer has more data to send.
  public func cancel() {
    self.underlyingStream.cancel()
  }
}
import Foundation

/// Builder used for constructing instances of `GRPCRequestHeaders`.
@objcMembers
public final class GRPCRequestHeadersBuilder: HeadersBuilder {
  /// Initialize a new builder.
  ///
  /// - parameter scheme:    The URL scheme for the request (i.e., "https").
  /// - parameter authority: The URL authority for the request (i.e., "api.foo.com").
  /// - parameter path:      Path for the RPC (i.e., `/pb.api.v1.Foo/GetBar`).
  public convenience init(scheme: String = "https", authority: String, path: String) {
    self.init(headers: [
      ":authority": [authority],
      ":method": ["POST"],
      ":path": [path],
      ":scheme": [scheme],
      "content-type": ["application/grpc"],
    ])
  }

  /// Add a specific timeout for the gRPC request. This will be sent in the `grpc-timeout` header.
  ///
  /// - parameter timeoutMs: Timeout, in milliseconds.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addTimeoutMs(_ timeoutMs: UInt?) -> GRPCRequestHeadersBuilder {
    let headerName = "grpc-timeout"
    if let timeoutMs = timeoutMs {
      self.set(name: headerName, value: ["\(timeoutMs)m"])
    } else {
      self.remove(name: headerName)
    }

    return self
  }

  /// Build the request headers using the current builder.
  ///
  /// - returns: New instance of request headers.
  public func build() -> GRPCRequestHeaders {
    return GRPCRequestHeaders(container: self.container)
  }
}
import Foundation

/// Client that supports sending and receiving gRPC traffic.
@objcMembers
public final class GRPCClient: NSObject {
  private let streamClient: StreamClient

  /// Create a new gRPC client instance.
  ///
  /// - parameter streamClient: The stream client to use for gRPC streams.
  public init(streamClient: StreamClient) {
    self.streamClient = streamClient
  }

  /// Create a new gRPC stream prototype which can be used to start streams.
  ///
  /// - returns: The new gRPC stream prototype.
  public func newGRPCStreamPrototype() -> GRPCStreamPrototype {
    let prototype = self.streamClient.newStreamPrototype()
    return GRPCStreamPrototype(underlyingStream: prototype)
  }
}
import Foundation

extension Data {
  /// Gets the integer at the provided index using the size of `T`.
  /// Returns nil if the data is too small.
  ///
  /// - parameter index: The index at which to get the integer value.
  ///
  /// - returns: The next integer in the data, or nil.
  func integer<T: FixedWidthInteger>(atIndex index: Int) -> T? {
    let size = MemoryLayout<T>.size
    guard self.count >= index + size else {
      return nil
    }

    var value: T = 0
    _ = Swift.withUnsafeMutableBytes(of: &value) { valuePointer in
      self.copyBytes(to: valuePointer, from: index ..< index + size)
    }

    return value
  }
}
import Foundation

/// A type representing a gRPC stream that has not yet been started.
///
/// Constructed via `GRPCClient`, and used to assign response callbacks
/// prior to starting a `GRPCStream` by calling `start()`.
@objcMembers
public final class GRPCStreamPrototype: NSObject {
  private let underlyingStream: StreamPrototype

  /// Initialize a new instance of the inactive gRPC stream.
  ///
  /// - parameter underlyingStream: The underlying stream to use.
  required init(underlyingStream: StreamPrototype) {
    self.underlyingStream = underlyingStream
    super.init()
  }

  // MARK: - Public

  /// Start a new gRPC stream.
  ///
  /// - parameter queue: Queue on which to receive callback events.
  ///
  /// - returns: The new gRPC stream.
  public func start(queue: DispatchQueue = .main) -> GRPCStream {
    let stream = self.underlyingStream.start(queue: queue)
    return GRPCStream(underlyingStream: stream)
  }

  /// Specify a callback for when response headers are received by the stream.
  ///
  /// - parameter closure: Closure which will receive the headers
  ///                      and flag indicating if the stream is headers-only.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func setOnResponseHeaders(
    closure: @escaping (_ headers: ResponseHeaders, _ endStream: Bool,
                        _ streamIntel: StreamIntel) -> Void
  ) -> GRPCStreamPrototype {
    self.underlyingStream.setOnResponseHeaders(closure: closure)
    return self
  }

  /// Specify a callback for when a new message has been received by the stream.
  ///
  /// - parameter closure: Closure which will receive messages on the stream.
  ///
  /// - returns: This handler, which may be used for chaining syntax.
  @discardableResult
  public func setOnResponseMessage(
    _ closure: @escaping (_ message: Data, _ streamIntel: StreamIntel) -> Void
  ) -> GRPCStreamPrototype {
    var buffer = Data()
    var state = GRPCMessageProcessor.State.expectingCompressionFlag
    self.underlyingStream.setOnResponseData { chunk, _, streamIntel in
      // Appending might result in extra copying that can be optimized in the future.
      buffer.append(chunk)
      // gRPC always sends trailers, so the stream will not complete here.
      GRPCMessageProcessor.processBuffer(&buffer, state: &state, streamIntel: streamIntel,
                                         onMessage: closure)
    }

    return self
  }

  /// Specify a callback for when trailers are received by the stream.
  /// If the closure is called, the stream is complete.
  ///
  /// - parameter closure: Closure which will receive the trailers.
  ///
  /// - returns: This handler, which may be used for chaining syntax.
  @discardableResult
  public func setOnResponseTrailers(_ closure:
    @escaping (_ trailers: ResponseTrailers, _ streamIntel: StreamIntel) -> Void
  ) -> GRPCStreamPrototype {
    self.underlyingStream.setOnResponseTrailers(closure: closure)
    return self
  }

  /// Specify a callback for when an internal Envoy exception occurs with the stream.
  /// If the closure is called, the stream is complete.
  ///
  /// - parameter closure: Closure which will be called when an error occurs.
  ///
  /// - returns: This handler, which may be used for chaining syntax.
  @discardableResult
  public func setOnError(
    _ closure: @escaping (_ error: EnvoyError, _ streamIntel: FinalStreamIntel) -> Void
  ) -> GRPCStreamPrototype {
    self.underlyingStream.setOnError(closure: closure)
    return self
  }

  /// Specify a callback for when the stream is canceled.
  /// If the closure is called, the stream is complete.
  ///
  /// - parameter closure: Closure which will be called when the stream is canceled.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func setOnCancel(
    closure: @escaping (_ streamIntel: FinalStreamIntel) -> Void
  ) -> GRPCStreamPrototype {
    self.underlyingStream.setOnCancel(closure: closure)
    return self
  }

  /// Specify a callback for when the stream completes gracefully.
  /// If the closure is called, the stream is complete.
  ///
  /// - parameter closure: Closure which will be called when the stream is closed.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func setOnComplete(
    closure: @escaping (_ streamIntel: FinalStreamIntel) -> Void
  ) -> GRPCStreamPrototype {
    self.underlyingStream.setOnComplete(closure: closure)
    return self
  }
}

private enum GRPCMessageProcessor {
  /// Represents the state of a response stream's body data.
  enum State {
    /// Awaiting a gRPC compression flag.
    case expectingCompressionFlag
    /// Awaiting the length specification of the next message.
    case expectingMessageLength
    /// Awaiting a message with the specified length.
    case expectingMessage(messageLength: UInt32)
  }

  /// Recursively processes a buffer of data, buffering it into messages based on state.
  /// When a message has been fully buffered, `onMessage` will be called with the message.
  ///
  /// - parameter buffer:      The buffer of data from which to determine state and messages.
  /// - parameter state:       The current state of the buffering.
  /// - parameter streamIntel: Internal HTTP stream metrics, context, and other details.
  /// - parameter onMessage:   Closure to call when a new message is available.
  static func processBuffer(_ buffer: inout Data, state: inout State, streamIntel: StreamIntel,
                            onMessage: (_ message: Data, _ streamIntel: StreamIntel) -> Void)
  {
    switch state {
    case .expectingCompressionFlag:
      guard let compressionFlag: UInt8 = buffer.integer(atIndex: 0) else {
        return
      }

      guard compressionFlag == 0 else {
        // TODO: Support gRPC compression https://github.com/envoyproxy/envoy-mobile/issues/501
        buffer.removeAll()
        state = .expectingCompressionFlag
        return
      }

      state = .expectingMessageLength

    case .expectingMessageLength:
      guard let messageLength: UInt32 = buffer.integer(atIndex: 1) else {
        return
      }

      state = .expectingMessage(messageLength: CFSwapInt32BigToHost(messageLength))

    case .expectingMessage(let messageLength):
      let prefixedLength = kGRPCPrefixLength + Int(messageLength)
      if buffer.count < prefixedLength {
        return
      }

      if messageLength > 0 {
        onMessage(buffer.subdata(in: kGRPCPrefixLength..<prefixedLength), streamIntel)
      } else {
        onMessage(Data(), streamIntel)
      }

      buffer.removeSubrange(0..<prefixedLength)
      state = .expectingCompressionFlag
    }

    self.processBuffer(&buffer, state: &state, streamIntel: streamIntel, onMessage: onMessage)
  }
}
import Foundation

/// Headers representing an outbound gRPC request.
@objcMembers
public final class GRPCRequestHeaders: RequestHeaders {
  /// Convert the headers back to a builder for mutation.
  ///
  /// - returns: The new builder.
  public func toGRPCRequestHeadersBuilder() -> GRPCRequestHeadersBuilder {
    return GRPCRequestHeadersBuilder(container: self.container)
  }
}
import Foundation

/// Engine represents a running instance of Envoy Mobile, and provides client interfaces that run on
/// that instance.
@objc
public protocol Engine: AnyObject {
  /// - returns: A client for opening and managing HTTP streams.
  func streamClient() -> StreamClient

  /// - returns: A client for recording time series metrics.
  func pulseClient() -> PulseClient

  func dumpStats() -> String

  /// Terminates the running engine.
  func terminate()

  /// Refresh DNS, and drain connections owned by this Engine.
  func resetConnectivityState()
}
@_implementationOnly import EnvoyEngine

/// Allows for configuring Envoy to return a local response based on matching criteria.
/// Especially useful for testing/mocking clients.
/// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/
/// v3/route_components.proto#config-route-v3-directresponseaction
public struct DirectResponse {
  public let matcher: RouteMatcher
  public let status: UInt
  public let body: String?
  public let headers: [String: String]

  /// Designated initializer.
  ///
  /// - parameter matcher: The matcher to use for returning a direct response.
  /// - parameter status:  HTTP status code that will be returned with the response.
  /// - parameter body:    String that will be returned as the body of the response.
  /// - parameter headers: Headers to add to the response.
  public init(matcher: RouteMatcher, status: UInt, body: String?, headers: [String: String] = [:]) {
    self.matcher = matcher
    self.status = status
    self.body = body
    self.headers = headers
  }

  func toObjC() -> EMODirectResponse {
    let result = EMODirectResponse()
    result.body = body
    result.status = status
    result.matcher = matcher.toObjC()
    result.headers = headers
    return result
  }
}
import Foundation

/// Builder used for constructing instances of `ResponseHeaders`.
@objcMembers
public final class ResponseHeadersBuilder: HeadersBuilder {
  /// Initialize a new instance of the builder.
  public override convenience init() {
    self.init(container: HeadersContainer(headers: [:]))
  }

  /// Add an HTTP status to the response headers.
  ///
  /// - parameter status: The HTTP status to add.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addHttpStatus(_ status: UInt) -> ResponseHeadersBuilder {
    self.internalSet(name: ":status", value: ["\(status)"])
    return self
  }

  /// Build the response headers using the current builder.
  ///
  /// - returns: New instance of response headers.
  public func build() -> ResponseHeaders {
    return ResponseHeaders(container: self.container)
  }
}
import Foundation

/// The different ways Envoy Mobile can monitor network reachability
/// state.
@objc
public enum NetworkMonitoringMode: Int {
  /// Do not monitor changes to the network reachability state.
  case disabled = 0
  /// Monitor changes to the network reachability state using `SCNetworkReachability`.
  case reachability = 1
  /// Monitor changes to the network reachability state using `NWPathMonitor`.
  case pathMonitor = 2
}
import Foundation

/// Rules that may be used with `RetryPolicy`.
/// See the `x-envoy-retry-on` Envoy header for documentation.
@objc
public enum RetryRule: Int, CaseIterable {
  case status5xx
  case gatewayError
  case connectFailure
  case refusedStream
  case retriable4xx
  case retriableHeaders
  case reset

  /// String representation of this rule.
  var stringValue: String {
    switch self {
    case .status5xx:
      return "5xx"
    case .gatewayError:
      return "gateway-error"
    case .connectFailure:
      return "connect-failure"
    case .refusedStream:
      return "refused-stream"
    case .retriable4xx:
      return "retriable-4xx"
    case .retriableHeaders:
      return "retriable-headers"
    case .reset:
      return "reset"
    }
  }

  /// Initialize the rule using a string value.
  ///
  /// - parameter stringValue: Case-insensitive rule value to use for initialization.
  init?(stringValue: String) {
    switch stringValue.lowercased() {
    case "5xx":
      self = .status5xx
    case "gateway-error":
      self = .gatewayError
    case "connect-failure":
      self = .connectFailure
    case "refused-stream":
      self = .refusedStream
    case "retriable-4xx":
      self = .retriable4xx
    case "retriable-headers":
      self = .retriableHeaders
    case "reset":
      self = .reset
    // This is mapped to null because this string value is added to headers automatically
    // in RetryPolicy.outboundHeaders()
    case "retriable-status-codes":
      return nil
    default:
      fatalError("invalid value '\(stringValue)'")
    }
  }
}

/// Specifies how a request may be retried, containing one or more rules.
/// https://www.envoyproxy.io/learn/automatic-retries
@objcMembers
public final class RetryPolicy: NSObject {
  public let maxRetryCount: UInt
  public let retryOn: [RetryRule]
  public let retryStatusCodes: [UInt]
  public let perRetryTimeoutMS: UInt?
  public let totalUpstreamTimeoutMS: UInt?

  /// Designated initializer.
  ///
  /// - parameter maxRetryCount:          Maximum number of retries that a request may be performed.
  /// - parameter retryOn:                Rules checked for retrying.
  /// - parameter retryStatusCodes:       Additional list of status codes that should be retried.
  /// - parameter perRetryTimeoutMS:      Timeout (in milliseconds) to apply to each retry. Must be
  ///                                     <= `totalUpstreamTimeoutMS` if it's a positive number.
  /// - parameter totalUpstreamTimeoutMS: Total timeout (in milliseconds) that includes all retries.
  ///                                     Spans the point at which the entire downstream request has
  ///                                     been processed and when the upstream response has been
  ///                                     completely processed. Nil or 0 may be specified to disable
  ///                                     it.
  public init(maxRetryCount: UInt, retryOn: [RetryRule], retryStatusCodes: [UInt] = [],
              perRetryTimeoutMS: UInt? = nil, totalUpstreamTimeoutMS: UInt? = 15_000)
  {
    if let perRetryTimeoutMS = perRetryTimeoutMS,
      let totalUpstreamTimeoutMS = totalUpstreamTimeoutMS
    {
      assert(perRetryTimeoutMS <= totalUpstreamTimeoutMS || totalUpstreamTimeoutMS == 0,
             "Per-retry timeout cannot be less than total timeout")
    }

    self.maxRetryCount = maxRetryCount
    self.retryOn = retryOn
    self.retryStatusCodes = retryStatusCodes
    self.perRetryTimeoutMS = perRetryTimeoutMS
    self.totalUpstreamTimeoutMS = totalUpstreamTimeoutMS
  }
}

// MARK: - Equatable overrides

extension RetryPolicy {
  public override func isEqual(_ object: Any?) -> Bool {
    guard let other = object as? RetryPolicy else {
      return false
    }

    return self.maxRetryCount == other.maxRetryCount
      && self.retryOn == other.retryOn
      && self.retryStatusCodes == other.retryStatusCodes
      && self.perRetryTimeoutMS == other.perRetryTimeoutMS
      && self.totalUpstreamTimeoutMS == other.totalUpstreamTimeoutMS
  }
}
@_implementationOnly import EnvoyCxxSwiftInterop

extension LogLevel {
  func toCXX() -> Envoy.Platform.LogLevel {
    switch self {
    case .trace:
      return .trace
    case .debug:
      return .debug
    case .info:
      return .info
    case .warn:
      return .warn
    case .error:
      return .error
    case .critical:
      return .critical
    case .off:
      return .off
    }
  }
}

// MARK: - Test Helpers

extension LogLevel {
  var cxxDescription: String {
    .fromCXX(Envoy.Platform.logLevelToString(self.toCXX()))
  }
}
@_implementationOnly import EnvoyCxxSwiftInterop

// MARK: - Internal

extension DirectResponse {
  func toCXX() -> Envoy.DirectResponseTesting.DirectResponse {
    var result = Envoy.DirectResponseTesting.DirectResponse()
    result.status = UInt32(self.status)
    if let body = self.body {
      result.body = body.toCXX()
    }
    result.matcher = self.matcher.toCXX()
    result.headers = self.headers.toCXX()
    return result
  }
}

// MARK: - Private

private extension RouteMatcher {
  func toCXX() -> Envoy.DirectResponseTesting.RouteMatcher {
    var result = Envoy.DirectResponseTesting.RouteMatcher()
    if let fullPath = self.fullPath {
      result.fullPath = fullPath.toCXX()
    }
    if let pathPrefix = self.pathPrefix {
      result.pathPrefix = pathPrefix.toCXX()
    }
    result.headers = self.headers.toCXX()
    return result
  }
}

private extension RouteMatcher.HeaderMatcher {
  func toCXX() -> Envoy.DirectResponseTesting.HeaderMatcher {
    return Envoy.DirectResponseTesting.HeaderMatcher(
      name: self.name.toCXX(),
      value: self.value.toCXX(),
      mode: self.mode.toCXX()
    )
  }
}

private extension Array<RouteMatcher.HeaderMatcher> {
  func toCXX() -> Envoy.CxxSwift.HeaderMatcherVector {
    var vector = Envoy.CxxSwift.HeaderMatcherVector()
    for element in self {
      var cppElement = element.toCXX()
      vector.push_back(&cppElement)
    }
    return vector
  }
}

private extension RouteMatcher.HeaderMatcher.MatchMode {
  func toCXX() -> Envoy.DirectResponseTesting.MatchMode {
    switch self {
    case .contains:
      return .Contains
    case .exact:
      return .Exact
    case .prefix:
      return .Prefix
    case .suffix:
      return .Suffix
    }
  }
}
@_implementationOnly import EnvoyCxxSwiftInterop

/// Wrapper around Envoy's bootstrap configuration.
final class Bootstrap {
  /// The underlying pointer to the C++ bootstrap configuration object.
  let pointer: Envoy.CxxSwift.BootstrapPtr

  /// Creates a Swift `Bootstrap` object from an underlying pointer to
  /// the C++ bootstrap configuration object.
  ///
  /// - parameter pointer: The underlying pointer to the C++ bootstrap configuration object.
  init(pointer: Envoy.CxxSwift.BootstrapPtr) {
    self.pointer = pointer
  }

  /// Generates a string description of this instance for debugging purposes.
  var debugDescription: String {
    .fromCXX(Envoy.CxxSwift.bootstrapDebugDescription(self.pointer))
  }
}

extension Envoy.Platform.EngineBuilder {
  /// Overrides the generateBootstrap() virtual function in the C++ EngineBuilder.
  ///
  /// NOTE: This function is `mutating` because we pass in the EngineBuilder by reference to
  /// CxxSwift.generateBootstrapPtr(). The CxxSwift.generateBootstrapPtr() function cannot take
  /// a const reference (const&) because passing by const reference is bridged as a value type
  /// (see https://github.com/apple/swift/blob/main/docs/CppInteroperability/InteropOddities.md)
  /// and EngineBuilder can't be a value type because it has virtual functions.
  ///
  /// - returns: A generated bootstrap object.
  mutating func generateBootstrap() -> Bootstrap {
    Bootstrap(pointer: Envoy.CxxSwift.generateBootstrapPtr(&self))
  }
}
@_implementationOnly import EnvoyCxxSwiftInterop
import Foundation
@_implementationOnly import std

// MARK: - String

extension String {
  static func fromCXX(_ cxxString: std.string) -> String {
    return String(cString: cxxString.c_str())
  }

  func toCXX() -> std.string {
    return self.utf8.reduce(into: std.string()) { result, codeUnit in
      result.push_back(Int8(codeUnit))
    }
  }
}

// MARK: - Collections

extension Array<String> {
  func toCXX() -> Envoy.CxxSwift.StringVector {
    return self.reduce(into: Envoy.CxxSwift.StringVector()) { result, string in
      var cxxString = string.toCXX()
      result.push_back(&cxxString)
    }
  }
}

extension Dictionary<String, String> {
  func toCXX() -> Envoy.CxxSwift.StringMap {
    return self.reduce(into: Envoy.CxxSwift.StringMap()) { result, keyValue in
      let (key, value) = keyValue
      Envoy.CxxSwift.string_map_set(&result, key.toCXX(), value.toCXX())
    }
  }
}
import Foundation

/// Base class that is used to represent header/trailer data structures.
/// To instantiate new instances, see `{Request|Response}HeadersBuilder`.
@objcMembers
public class Headers: NSObject {
  let container: HeadersContainer

  /// Get the value for the provided header name.
  ///
  /// - note: The lookup for a header name is a case-insensitive operation.
  ///
  /// - parameter name: Header name for which to get the current value.
  ///
  /// - returns: The current headers specified for the provided name.
  public func value(forName name: String) -> [String]? {
    return self.container.value(forName: name)
  }

  /// Accessor for all underlying case-sensitive headers. When possible,
  /// use case-insensitive accessors instead.
  ///
  /// - warning: It's discouraged to use this dictionary for equality
  ///            key-based lookups as this may lead to issues with headers
  ///            that do not follow expected casing i.e., "Content-Length"
  ///            instead of "content-length".
  ///
  /// - returns: The underlying case-sensitive headers.
  public func caseSensitiveHeaders() -> [String: [String]] {
    return self.container.caseSensitiveHeaders()
  }

  /// Internal initializer used by builders.
  ///
  /// - parameter container: Headers to set.
  required init(container: HeadersContainer) {
    self.container = container
    super.init()
  }

  /// Inialize the receiver with a given headers map.
  ///
  /// - parameter headers: The headers map to use.
  convenience init(headers: [String: [String]]) {
    self.init(container: HeadersContainer(headers: headers))
  }

  override convenience init() {
    self.init(headers: [:])
  }
}

// MARK: - Equatable

extension Headers {
  public override func isEqual(_ object: Any?) -> Bool {
    return (object as? Self)?.container == self.container
  }
}

// MARK: - CustomStringConvertible

extension Headers {
  public override var description: String {
    return "\(type(of: self)) \(self.caseSensitiveHeaders())"
  }
}
// swiftlint:disable force_unwrapping - Programmer error if properties are nil when accessed
import Foundation

/// Headers representing an outbound request.
@objcMembers
public class RequestHeaders: Headers {
  /// Method for the request.
  public private(set) lazy var method: RequestMethod =
    (self.value(forName: ":method")?.first.flatMap(RequestMethod.init))!

  /// The URL scheme for the request (i.e., "https").
  public private(set) lazy var scheme: String = (self.value(forName: ":scheme")?.first)!

  /// The URL authority for the request (i.e., "api.foo.com").
  public private(set) lazy var authority: String = (self.value(forName: ":authority")?.first)!

  /// The URL path for the request (i.e., "/foo").
  public private(set) lazy var path: String = (self.value(forName: ":path")?.first)!

  /// Retry policy to use for this request.
  public private(set) lazy var retryPolicy: RetryPolicy? = .from(headers: self)

  /// Convert the headers back to a builder for mutation.
  ///
  /// - returns: The new builder.
  public func toRequestHeadersBuilder() -> RequestHeadersBuilder {
    return RequestHeadersBuilder(container: self.container)
  }
}
@_implementationOnly import EnvoyEngine

/// Typed representation of a route matcher that may be specified when starting the engine.
/// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/
/// v3/route_components.proto#envoy-v3-api-msg-config-route-v3-routematch
public struct RouteMatcher {
  public let fullPath: String?
  public let pathPrefix: String?
  public let headers: [HeaderMatcher]

  public struct HeaderMatcher {
    public let name: String
    public let value: String
    public let mode: MatchMode

    public enum MatchMode: Int {
      case contains
      case exact
      case prefix
      case suffix

      fileprivate var objcValue: EMOMatchMode {
        switch self {
        case .contains:
          return .contains
        case .exact:
          return .exact
        case .prefix:
          return .prefix
        case .suffix:
          return .suffix
        }
      }
    }

    public init(name: String, value: String, mode: MatchMode) {
      self.name = name
      self.value = value
      self.mode = mode
    }
  }

  /// Initialize a matcher with a path prefix.
  ///
  /// - parameter pathPrefix: This prefix must match the beginning of the :path header.
  /// - parameter headers:    Specifies a set of headers that the route should match on. The
  ///                         router will check the requests headers against all the specified
  ///                         headers in the route
  ///                         config. A match will happen if all the headers in the route are
  ///                         present in the
  ///                         request with the same values (or based on presence if the value
  ///                         field is not in the config).
  public init(pathPrefix: String, headers: [HeaderMatcher] = []) {
    self.fullPath = nil
    self.pathPrefix = pathPrefix
    self.headers = headers
  }

  /// Initialize a matcher with a full path.
  ///
  /// - parameter fullPath: This value must exactly match the :path header once the query string is
  ///                       removed.
  /// - parameter headers:  Specifies a set of headers that the route should match on. The
  ///                       router will check the requests headers against all the specified
  ///                       headers in the route
  ///                       config. A match will happen if all the headers in the route are
  ///                       present in the
  ///                       request with the same values (or based on presence if the value
  ///                       field is not in the config).
  public init(fullPath: String, headers: [HeaderMatcher] = []) {
    self.fullPath = fullPath
    self.pathPrefix = nil
    self.headers = headers
  }
}

extension RouteMatcher {
  func toObjC() -> EMORouteMatcher {
    let result = EMORouteMatcher()
    result.fullPath = fullPath
    result.pathPrefix = pathPrefix
    result.headers = headers.map { $0.toObjC() }
    return result
  }
}

private extension RouteMatcher.HeaderMatcher {
  func toObjC() -> EMOHeaderMatcher {
    let result = EMOHeaderMatcher()
    result.name = name
    result.value = value
    result.mode = mode.objcValue
    return result
  }
}
import Dispatch
@_implementationOnly import EnvoyEngine
import Foundation

/// A type representing a stream that has not yet been started.
///
/// Constructed via `StreamClient`, and used to assign response callbacks
/// prior to starting an `Stream` by calling `start()`.
@objcMembers
public class StreamPrototype: NSObject {
  private let engine: EnvoyEngine
  private let callbacks = StreamCallbacks()
  private var explicitFlowControl = false

  /// Initialize a new instance of the stream prototype.
  ///
  /// - parameter engine: Engine to use for starting streams.
  init(engine: EnvoyEngine) {
    self.engine = engine
    super.init()
  }

  /// Create engine callbacks using the provided queue.
  ///
  /// - parameter queue: Queue on which to receive callback events.
  ///
  /// - returns: A new set of engine callbacks.
  func createCallbacks(queue: DispatchQueue) -> EnvoyHTTPCallbacks {
    return EnvoyHTTPCallbacks(callbacks: self.callbacks, queue: queue)
  }

  // MARK: - Public

  /// Start a new stream.
  ///
  /// - parameter queue: Queue on which to receive callback events.
  ///
  /// - returns: The new stream.
  public func start(queue: DispatchQueue = .main) -> Stream {
    let engineStream = self.engine.startStream(
      with: self.createCallbacks(queue: queue),
      explicitFlowControl: explicitFlowControl
    )
    return Stream(underlyingStream: engineStream)
  }

  /// Allows explicit flow control to be enabled. When explicit flow control is enabled, the owner
  /// of a stream is responsible for providing a buffer to receive response body data. If the buffer
  /// is smaller than the amount of data available, response callbacks will halt, and the underlying
  /// network protocol may signal for the server to stop sending data, until more space is
  /// available. This can limit the memory consumed by a server response, but may also result in
  /// reduced overall throughput, depending on usage.
  ///
  /// - parameter enabled: Whether explicit flow control will be enabled for the stream.
  ///
  /// - returns: This stream, for chaining syntax.
  public func setExplicitFlowControl(enabled: Bool) -> StreamPrototype {
    self.explicitFlowControl = enabled
    return self
  }

  /// Specify a callback to be invoked when response headers are received by the stream.
  /// If `endStream` is `true`, the stream is complete, pending an onComplete callback.
  ///
  /// - parameter closure: Closure which will receive the headers
  ///                      and flag indicating if the stream is headers-only.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func setOnResponseHeaders(
    closure: @escaping (_ headers: ResponseHeaders, _ endStream: Bool,
                        _ streamIntel: StreamIntel) -> Void
  ) -> StreamPrototype {
    self.callbacks.onHeaders = closure
    return self
  }

  /// Specify a callback to be invoked when a data frame is received by the stream.
  /// If `endStream` is `true`, the stream is complete, pending an onComplete callback.
  ///
  /// - parameter closure: Closure which will receive the data
  ///                      and flag indicating whether this is the last data frame.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func setOnResponseData(
    closure: @escaping (_ body: Data, _ endStream: Bool, _ streamIntel: StreamIntel) -> Void
  ) -> StreamPrototype {
    self.callbacks.onData = closure
    return self
  }

  /// Specify a callback to be invoked when trailers are received by the stream.
  /// If the closure is called, the stream is complete, pending an onComplete callback.
  ///
  /// - parameter closure: Closure which will receive the trailers.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func setOnResponseTrailers(
    closure: @escaping (_ trailers: ResponseTrailers, _ streamIntel: StreamIntel) -> Void
  ) -> StreamPrototype {
    self.callbacks.onTrailers = closure
    return self
  }

  /// Specify a callback to be invoked when additional send window becomes available.
  /// This is only ever called when the library is in explicit flow control mode. When enabled,
  /// the issuer should wait for this callback after calling sendData, before making another call
  /// to sendData.
  ///
  /// - parameter closure: Closure which will be called when additional send window becomes
  ///                      available.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func setOnSendWindowAvailable(
    closure: @escaping (_ streamIntel: StreamIntel) -> Void
  ) -> StreamPrototype {
    callbacks.onSendWindowAvailable = closure
    return self
  }

  /// Specify a callback to be invoked when an internal Envoy exception occurs with the stream.
  /// If the closure is called, the stream is complete.
  ///
  /// - parameter closure: Closure which will be called when an error occurs.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func setOnError(
    closure: @escaping (_ error: EnvoyError, _ streamIntel: FinalStreamIntel) -> Void
  ) -> StreamPrototype {
    self.callbacks.onError = closure
    return self
  }

  /// Specify a callback to be invoked when the stream is canceled.
  /// If the closure is called, the stream is complete.
  ///
  /// - parameter closure: Closure which will be called when the stream is canceled.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func setOnCancel(
    closure: @escaping (_ streamIntel: FinalStreamIntel) -> Void
  ) -> StreamPrototype {
    self.callbacks.onCancel = closure
    return self
  }

  /// Specify a callback to be invoked when the stream completes gracefully.
  /// If the closure is called, the stream is complete.
  ///
  /// - parameter closure: Closure which will be called when the stream is canceled.
  ///
  /// - returns: This stream, for chaining syntax.
  @discardableResult
  public func setOnComplete(
    closure: @escaping (_ streamIntel: FinalStreamIntel) -> Void
  ) -> StreamPrototype {
    self.callbacks.onCancel = closure
    return self
  }
}
import Foundation

/// Available logging levels for an Envoy instance.
/// Note that some levels may be compiled out.
@objc
public enum LogLevel: Int {
  case trace = 0
  case debug = 1
  case info = 2
  case warn = 3
  case error = 4
  case critical = 5
  case off = -1

  /// String representation of the log level.
  var stringValue: String {
    switch self {
    case .trace:
      return "trace"
    case .debug:
      return "debug"
    case .info:
      return "info"
    case .warn:
      return "warn"
    case .error:
      return "error"
    case .critical:
      return "critical"
    case .off:
      return "off"
    }
  }
}
import Foundation

extension UserDefaults: KeyValueStore {
  public func readValue(forKey key: String) -> String? {
    self.string(forKey: key)
  }

  public func saveValue(_ value: String, toKey key: String) {
    self.set(value, forKey: key)
  }

  public func removeKey(_ key: String) {
    self.removeObject(forKey: key)
  }
}
import Foundation

/// Error type containing information on failures reported by Envoy.
@objcMembers
public final class EnvoyError: NSObject, Error {
  /// Error code associated with the exception that occurred.
  public let errorCode: UInt64
  /// A description of what exception that occurred.
  public let message: String
  /// Optional number of times an operation was attempted before firing this error.
  public let attemptCount: UInt32?
  /// Optional cause for the error.
  public let cause: Error?

  public init(errorCode: UInt64, message: String, attemptCount: UInt32?, cause: Error?) {
    self.errorCode = errorCode
    self.message = message
    self.attemptCount = attemptCount
    self.cause = cause
  }
}
/// The container that manages the underlying headers map.
/// It maintains the original casing of passed header names.
/// It treats headers names as case-insensitive for the purpose
/// of header lookups and header name conflict resolutions.
struct HeadersContainer: Equatable {
  private var headers: [String: Header]

  /// Represents a header name together with all of its values.
  /// It preserves the original casing of the header name.
  struct Header: Equatable {
    private(set) var name: String
    private(set) var value: [String]

    init(name: String, value: [String] = []) {
      self.name = name
      self.value = value
    }

    mutating func addValues(_ values: [String]) {
      self.value.append(contentsOf: values)
    }

    mutating func addValue(_ value: String) {
      self.value.append(value)
    }
  }

  /// Initialize a new instance of the receiver using the provided headers map.
  ///
  /// - parameter headers: The headers map.
  init(headers: [String: [String]]) {
    var underlyingHeaders = [String: Header]()
    for (name, value) in headers {
      let lowercasedName = name.lowercased()
      /// Dictionaries are unordered collections. Process headers with names
      /// that are the same when lowercased in an alphabetical order to avoid a situation
      /// in which the result of the initialization is non-derministic i.e., we want
      /// ["A": ["1"], "a": ["2"]] headers to be always converted to ["A": ["1", "2"]] and
      /// never to "a": ["2", "1"].
      ///
      /// If a given header name already exists in the processed headers map, check
      /// if the currently processed header name is before the existing header name as
      /// determined by an alphabetical order.
      guard let existingHeader = underlyingHeaders[lowercasedName] else {
        underlyingHeaders[lowercasedName] = Header(name: name, value: value)
        continue
      }

      if existingHeader.name > name {
        underlyingHeaders[lowercasedName] =
          Header(name: name, value: value + existingHeader.value)
      } else {
        underlyingHeaders[lowercasedName]?.addValues(value)
      }
    }
    self.headers = underlyingHeaders
  }

  /// Initialize an empty headers container.
  init() {
    self.headers = [:]
  }

  /// Add a value to a header with a given name.
  ///
  /// - parameter name:  The name of the header. For the purpose of headers lookup
  ///                    and header name conflict resolution, the name of the header
  ///                    is considered to be case-insensitive.
  /// - parameter value: The value to add.
  mutating func add(name: String, value: String) {
      self.headers[name.lowercased(), default: Header(name: name)].addValue(value)
  }

  /// Set the value of a given header.
  ///
  /// - parameter name:  The name of the header.
  /// - parameter value: The value to set the header value to.
  mutating func set(name: String, value: [String]) {
    self.headers[name.lowercased()] = Header(name: name, value: value)
  }

  /// Remove a given header.
  ///
  /// - parameter name: The name of the header to remove.
  mutating func remove(name: String) {
    self.headers[name.lowercased()] = nil
  }

  /// Get the value for the provided header name.
  ///
  /// - parameter name: The case-insensitive header name for which to
  ///                   get the current value.
  ///
  /// - returns: The value associated with a given header.
  func value(forName name: String) -> [String]? {
    return self.headers[name.lowercased()]?.value
  }

  /// Accessor for all underlying case-sensitive headers. When possible,
  /// use case-insensitive accessors instead.
  ///
  /// - returns: The underlying headers.
  func caseSensitiveHeaders() -> [String: [String]] {
    return Dictionary(uniqueKeysWithValues: self.headers.map { _, value in
      return (value.name, value.value)
    })
  }
}

extension HeadersContainer: CustomStringConvertible {
  var description: String {
    return self.headers.description
  }
}
import Foundation

/// Trailers representing an outbound request.
@objcMembers
public final class RequestTrailers: Trailers {
  /// Convert the trailers back to a builder for mutation.
  ///
  /// - returns: The new builder.
  public func toRequestTrailersBuilder() -> RequestTrailersBuilder {
    return RequestTrailersBuilder(container: self.container)
  }
}
@_implementationOnly import EnvoyEngine
import Foundation

/// Exposes one time HTTP stream metrics, context, and other details.
/// Note: -1 means "not present" for the fields of type Int64.
@objcMembers
public final class FinalStreamIntel: StreamIntel {
  /// The time the stream started (a.k.a. request started), in ms since the epoch.
  public let streamStartMs: Int64
  /// The time the DNS resolution for this request started, in ms since the epoch.
  public let dnsStartMs: Int64
  /// The time the DNS resolution for this request completed, in ms since the epoch.
  public let dnsEndMs: Int64
  /// The time the upstream connection started, in ms since the epoch. (1)
  public let connectStartMs: Int64
  /// The time the upstream connection completed, in ms since the epoch. (1)
  public let connectEndMs: Int64
  /// The time the SSL handshake started, in ms since the epoch. (1)
  public let sslStartMs: Int64
  /// The time the SSL handshake completed, in ms since the epoch. (1)
  public let sslEndMs: Int64
  /// The time the first byte of the request was sent upstream, in ms since the epoch.
  public let sendingStartMs: Int64
  /// The time the last byte of the request was sent upstream, in ms since the epoch.
  public let sendingEndMs: Int64
  /// The time the first byte of the response was received, in ms since the epoch.
  public let responseStartMs: Int64
  /// The time the last byte of the request was received, in ms since the epoch.
  public let streamEndMs: Int64
  /// True if the upstream socket had been used previously.
  public let socketReused: Bool
  /// The number of bytes sent upstream.
  public let sentByteCount: UInt64
  /// The number of bytes received from upstream.
  public let receivedByteCount: UInt64
  /// The response flags for the upstream stream.
  public let responseFlags: UInt64
  /// The protocol of the upstream stream, or -1 if no stream was established.
  public let upstreamProtocol: Int64

  // NOTE(1): These fields may not be set if socket_reused is false.

  public init(
    streamId: Int64,
    connectionId: Int64,
    attemptCount: UInt64,
    streamStartMs: Int64,
    dnsStartMs: Int64,
    dnsEndMs: Int64,
    connectStartMs: Int64,
    connectEndMs: Int64,
    sslStartMs: Int64,
    sslEndMs: Int64,
    sendingStartMs: Int64,
    sendingEndMs: Int64,
    responseStartMs: Int64,
    streamEndMs: Int64,
    socketReused: Bool,
    sentByteCount: UInt64,
    receivedByteCount: UInt64,
    responseFlags: UInt64,
    upstreamProtocol: Int64
  ) {
    self.streamStartMs = streamStartMs
    self.dnsStartMs = dnsStartMs
    self.dnsEndMs = dnsEndMs
    self.connectStartMs = connectStartMs
    self.connectEndMs = connectEndMs
    self.sslStartMs = sslStartMs
    self.sslEndMs = sslEndMs
    self.sendingStartMs = sendingStartMs
    self.sendingEndMs = sendingEndMs
    self.responseStartMs = responseStartMs
    self.streamEndMs = streamEndMs
    self.socketReused = socketReused
    self.sentByteCount = sentByteCount
    self.receivedByteCount = receivedByteCount
    self.responseFlags = responseFlags
    self.upstreamProtocol = upstreamProtocol
    super.init(streamId: streamId, connectionId: connectionId, attemptCount: attemptCount)
  }
}

extension FinalStreamIntel {
  internal convenience init(_ cIntel: EnvoyStreamIntel, _ cFinalIntel: EnvoyFinalStreamIntel) {
    self.init(
      streamId: cIntel.stream_id,
      connectionId: cIntel.connection_id,
      attemptCount: cIntel.attempt_count,
      streamStartMs: cFinalIntel.stream_start_ms,
      dnsStartMs: cFinalIntel.dns_start_ms,
      dnsEndMs: cFinalIntel.dns_end_ms,
      connectStartMs: cFinalIntel.connect_start_ms,
      connectEndMs: cFinalIntel.connect_end_ms,
      sslStartMs: cFinalIntel.ssl_start_ms,
      sslEndMs: cFinalIntel.ssl_end_ms,
      sendingStartMs: cFinalIntel.sending_start_ms,
      sendingEndMs: cFinalIntel.sending_end_ms,
      responseStartMs: cFinalIntel.response_start_ms,
      streamEndMs: cFinalIntel.stream_end_ms,
      socketReused: cFinalIntel.socket_reused != 0,
      sentByteCount: cFinalIntel.sent_byte_count,
      receivedByteCount: cFinalIntel.received_byte_count,
      responseFlags: cFinalIntel.response_flags,
      upstreamProtocol: cFinalIntel.upstream_protocol
    )
  }
}
import Foundation

/// Represents an HTTP request method.
@objc
public enum RequestMethod: Int, CaseIterable {
  case delete
  case get
  case head
  case options
  case patch
  case post
  case put
  case trace

  /// String representation of this method.
  public var stringValue: String {
    switch self {
    case .delete:
      return "DELETE"
    case .get:
      return "GET"
    case .head:
      return "HEAD"
    case .options:
      return "OPTIONS"
    case .patch:
      return "PATCH"
    case .post:
      return "POST"
    case .put:
      return "PUT"
    case .trace:
      return "TRACE"
    }
  }

  /// Initialize the method using a string value.
  ///
  /// - parameter stringValue: Case-insensitive string value to use for initialization.
  init(stringValue: String) {
    switch stringValue.uppercased() {
    case "DELETE":
      self = .delete
    case "GET":
      self = .get
    case "HEAD":
      self = .head
    case "OPTIONS":
      self = .options
    case "PATCH":
      self = .patch
    case "POST":
      self = .post
    case "PUT":
      self = .put
    case "TRACE":
      self = .trace
    default:
      fatalError("invalid value '\(stringValue)'")
    }
  }
}
import Foundation

/// Builder used for constructing instances of `RequestHeaders`.
@objcMembers
public final class RequestHeadersBuilder: HeadersBuilder {
  /// Initialize a new instance of the builder.
  ///
  /// - parameter method:    Method for the request.
  /// - parameter scheme:    The URL scheme for the request (i.e., "https").
  /// - parameter authority: The URL authority for the request (i.e., "api.foo.com").
  /// - parameter path:      The URL path for the request (i.e., "/foo").
  public convenience init(method: RequestMethod, scheme: String = "https",
                          authority: String, path: String)
  {
    self.init(headers: [
      ":authority": [authority],
      ":method": [method.stringValue],
      ":path": [path],
      ":scheme": [scheme],
    ])
  }

  /// Add a retry policy to be used with this request.
  ///
  /// - parameter retryPolicy: The retry policy to use.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addRetryPolicy(_ retryPolicy: RetryPolicy) -> RequestHeadersBuilder {
    for (name, value) in retryPolicy.outboundHeaders() {
      self.internalSet(name: name, value: value)
    }

    return self
  }

  /// Build the request headers using the current builder.
  ///
  /// - returns: New instance of request headers.
  public func build() -> RequestHeaders {
    return RequestHeaders(container: self.container)
  }
}
#include "cxx_swift_interop.h"

#include "source/server/options_impl_base.h"

#include "library/common/engine.h"

namespace Envoy {
namespace CxxSwift {

void run(BootstrapPtr bootstrap_ptr, Platform::LogLevel log_level, envoy_engine_t engine_handle) {
  auto options = std::make_unique<Envoy::OptionsImplBase>();
  options->setConfigProto(bootstrapFromPtr(bootstrap_ptr));
  options->setLogLevel(static_cast<spdlog::level::level_enum>(log_level));
  options->setConcurrency(1);
  reinterpret_cast<Envoy::Engine*>(engine_handle)->run(std::move(options));
}

} // namespace CxxSwift
} // namespace Envoy
#pragma once

#include "library/cc/bridge_utility.h"
#include "library/cc/direct_response_testing.h"
#include "library/cc/engine_builder.h"
#include "library/common/data/utility.h"
#include "library/common/extensions/filters/http/platform_bridge/c_types.h"
#include "library/common/stats/utility.h"

// This file exists in order to expose headers for Envoy's C++ libraries
// to Envoy Mobile's Swift implementation.
// Further, Swift only supports interacting with a subset of C++ language features
// so some types are renamed with the `using` keyword, and some features that
// cannot be imported into Swift are abstracted via interfaces that are supported.
// See this document on Swift's C++ interoperability status to learn more:
// https://github.com/apple/swift/blob/swift-5.7.3-RELEASE/docs/CppInteroperability/CppInteroperabilityStatus.md

namespace Envoy {
namespace CxxSwift {

using StringVector = std::vector<std::string>;
using StringPair = std::pair<std::string, std::string>;
using StringPairVector = std::vector<StringPair>;
using StringMap = absl::flat_hash_map<std::string, std::string>;
using HeaderMatcherVector = std::vector<DirectResponseTesting::HeaderMatcher>;
using BootstrapPtr = intptr_t;

// Exposes `map[std::move(key)] = std::move(value)` to Swift.
inline void string_map_set(StringMap& map, std::string key, std::string value) {
  map[std::move(key)] = std::move(value);
}

// Exposes `map[std::move(key)] = std::move(value)` to Swift.
inline void raw_header_map_set(Platform::RawHeaderMap& map, std::string key,
                               std::vector<std::string> value) {
  map[std::move(key)] = std::move(value);
}

// Smart pointers aren't currently supported by Swift / C++ interop, so we "erase"
// it into a `BootstrapPtr` / `intptr_t`, which we can import from Swift.
inline BootstrapPtr generateBootstrapPtr(Platform::EngineBuilder& builder) {
  return reinterpret_cast<BootstrapPtr>(builder.generateBootstrap().release());
}

inline std::unique_ptr<envoy::config::bootstrap::v3::Bootstrap>
bootstrapFromPtr(BootstrapPtr bootstrap_ptr) {
  return absl::WrapUnique(
      reinterpret_cast<envoy::config::bootstrap::v3::Bootstrap*>(bootstrap_ptr));
}

inline std::string bootstrapDebugDescription(BootstrapPtr bootstrap_ptr) {
  return bootstrapFromPtr(bootstrap_ptr)->ShortDebugString();
}

/**
 * Run the engine with the provided configuration.
 * @param bootstrap_ptr, the Envoy bootstrap configuration to use.
 * @param log_level, the log level.
 * @param engine_handle, the handle to an Envoy engine instance.
 */
void run(BootstrapPtr bootstrap_ptr, Platform::LogLevel log_level, envoy_engine_t engine_handle);

} // namespace CxxSwift
} // namespace Envoy
load("@build_bazel_rules_swift//swift:swift.bzl", "swift_c_module")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "cxx_swift_interop_lib",
    srcs = ["cxx_swift_interop.cc"],
    hdrs = ["cxx_swift_interop.h"],
    repository = "@envoy",
    deps = [
        "//library/cc:engine_builder_lib",
        "//library/common/network:apple_platform_cert_verifier",
    ],
)

swift_c_module(
    name = "EnvoyCxxSwiftInterop",
    module_map = "module.modulemap",
    module_name = "EnvoyCxxSwiftInterop",
    visibility = ["//visibility:public"],
    deps = [":cxx_swift_interop_lib"],
)
module EnvoyCxxSwiftInterop {
    header "cxx_swift_interop.h"
    requires cplusplus
}
#if canImport(EnvoyCxxSwiftInterop)
@_implementationOnly import EnvoyCxxSwiftInterop
#endif
@_implementationOnly import EnvoyEngine
import Foundation

// swiftlint:disable file_length

#if ENVOY_MOBILE_XDS
/// Builder for generating the xDS configuration for the Envoy Mobile engine.
/// xDS is a protocol for dynamic configuration of Envoy instances, more information can be found in
/// https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol.
///
/// This class is typically used as input to the EngineBuilder's setXds() method.
@objcMembers
open class XdsBuilder: NSObject {
  public static let defaultXdsTimeoutInSeconds: UInt32 = 5

  let xdsServerAddress: String
  let xdsServerPort: UInt32
  var xdsGrpcInitialMetadata: [String: String] = [:]
  var sslRootCerts: String?
  var rtdsResourceName: String?
  var rtdsTimeoutInSeconds: UInt32 = 0
  var enableCds: Bool = false
  var cdsResourcesLocator: String?
  var cdsTimeoutInSeconds: UInt32 = 0

  /// Initialize a new builder for xDS configuration.
  ///
  /// - parameter xdsServerAddress: The host name or IP address of the xDS management server.
  /// - parameter xdsServerPort:    The port on which the server listens for client connections.
  public init(xdsServerAddress: String, xdsServerPort: UInt32) {
    self.xdsServerAddress = xdsServerAddress
    self.xdsServerPort = xdsServerPort
  }

  /// Adds a header to the initial HTTP metadata headers sent on the gRPC stream.
  ///
  /// A common use for the initial metadata headers is for authentication to the xDS management
  /// server.
  ///
  /// For example, if using API keys to authenticate to Traffic Director on GCP (see
  /// https://cloud.google.com/docs/authentication/api-keys for details), invoke:
  ///   builder.addInitialStreamHeader("x-goog-api-key", apiKeyToken)
  ///          .addInitialStreamHeader("X-Android-Package", appPackageName)
  ///          .addInitialStreamHeader("X-Android-Cert", sha1KeyFingerprint);
  ///
  /// - parameter header: The HTTP header to add on the gRPC stream's initial metadata.
  /// - parameter value:  The HTTP header value to add on the gRPC stream's initial metadata.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addInitialStreamHeader(
    header: String,
    value: String) -> Self {
    self.xdsGrpcInitialMetadata[header] = value
    return self
  }

  /// Sets the PEM-encoded server root certificates used to negotiate the TLS handshake for the gRPC
  /// connection. If no root certs are specified, the operating system defaults are used.
  ///
  /// - parameter rootCerts: The PEM-encoded server root certificates.
  ///
  /// - returns: This builder.
  @discardableResult
  public func setSslRootCerts(rootCerts: String) -> Self {
    self.sslRootCerts = rootCerts
    return self
  }

  /// Adds Runtime Discovery Service (RTDS) to the Runtime layers of the Bootstrap configuration,
  /// to retrieve dynamic runtime configuration via the xDS management server.
  ///
  /// - parameter resourceName:     The runtime config resource to subscribe to.
  /// - parameter timeoutInSeconds: <optional> specifies the `initial_fetch_timeout` field on the
  ///                               api.v3.core.ConfigSource. Unlike the ConfigSource default of
  ///                               15s, we set a default fetch timeout value of 5s, to prevent
  ///                               mobile app initialization from stalling. The default parameter
  ///                               value may change through the course of experimentation and no
  ///                               assumptions should be made of its exact value.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addRuntimeDiscoveryService(
    resourceName: String,
    timeoutInSeconds: UInt32 = XdsBuilder.defaultXdsTimeoutInSeconds) -> Self {
    self.rtdsResourceName = resourceName
    self.rtdsTimeoutInSeconds = timeoutOrXdsDefault(timeoutInSeconds)
    return self
  }

  /// Adds the Cluster Discovery Service (CDS) configuration for retrieving dynamic cluster
  /// resources via the xDS management server.
  ///
  /// - parameter cdsResourcesLocator: <optional> the xdstp:// URI for subscribing to the cluster
  ///                                  resources. If not using xdstp, then `cds_resources_locator`
  ///                                  should be set to the empty string.
  /// - parameter timeoutInSeconds:    <optional> specifies the `initial_fetch_timeout` field on the
  ///                                  api.v3.core.ConfigSource. Unlike the ConfigSource default of
  ///                                  15s, we set a default fetch timeout value of 5s, to prevent
  ///                                  mobile app initialization from stalling. The default
  ///                                  parameter value may change through the course of
  ///                                  experimentation and no assumptions should be made of its
  ///                                  exact value.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addClusterDiscoveryService(
    cdsResourcesLocator: String? = nil,
    timeoutInSeconds: UInt32 = XdsBuilder.defaultXdsTimeoutInSeconds) -> Self {
    self.enableCds = true
    self.cdsResourcesLocator = cdsResourcesLocator
    self.cdsTimeoutInSeconds = timeoutOrXdsDefault(timeoutInSeconds)
    return self
  }

  private func timeoutOrXdsDefault(_ timeout: UInt32) -> UInt32 {
    return timeout > 0 ? timeout : XdsBuilder.defaultXdsTimeoutInSeconds
  }
}
#endif

/// Builder used for creating and running a new Engine instance.
@objcMembers
open class EngineBuilder: NSObject {
  // swiftlint:disable:previous type_body_length
  private let base: BaseConfiguration
  private var engineType: EnvoyEngine.Type = EnvoyEngineImpl.self
  private var logLevel: LogLevel = .info

  private enum BaseConfiguration {
    case standard
    case custom(String)
  }

  private var connectTimeoutSeconds: UInt32 = 30
  private var dnsFailureRefreshSecondsBase: UInt32 = 2
  private var dnsFailureRefreshSecondsMax: UInt32 = 10
  private var dnsQueryTimeoutSeconds: UInt32 = 25
  private var dnsMinRefreshSeconds: UInt32 = 60
  private var dnsPreresolveHostnames: [String] = []
  private var dnsRefreshSeconds: UInt32 = 60
  private var enableDNSCache: Bool = false
  private var dnsCacheSaveIntervalSeconds: UInt32 = 1
  private var enableGzipDecompression: Bool = true
  private var enableBrotliDecompression: Bool = false
#if ENVOY_ENABLE_QUIC
  private var enableHttp3: Bool = true
#else
  private var enableHttp3: Bool = false
#endif
  private var quicHints: [String: Int] = [:]
  private var quicCanonicalSuffixes: [String] = []
  private var enableInterfaceBinding: Bool = false
  private var enforceTrustChainVerification: Bool = true
  private var enablePlatformCertificateValidation: Bool = false
  private var enableDrainPostDnsRefresh: Bool = false
  private var forceIPv6: Bool = false
  private var h2ConnectionKeepaliveIdleIntervalMilliseconds: UInt32 = 1
  private var h2ConnectionKeepaliveTimeoutSeconds: UInt32 = 10
  private var maxConnectionsPerHost: UInt32 = 7
  private var streamIdleTimeoutSeconds: UInt32 = 15
  private var perTryIdleTimeoutSeconds: UInt32 = 15
  private var appVersion: String = "unspecified"
  private var appId: String = "unspecified"
  private var onEngineRunning: (() -> Void)?
  private var logger: ((String) -> Void)?
  private var eventTracker: (([String: String]) -> Void)?
  private(set) var monitoringMode: NetworkMonitoringMode = .pathMonitor
  private var nativeFilterChain: [EnvoyNativeFilterConfig] = []
  private var platformFilterChain: [EnvoyHTTPFilterFactory] = []
  private var stringAccessors: [String: EnvoyStringAccessor] = [:]
  private var keyValueStores: [String: EnvoyKeyValueStore] = [:]
  private var runtimeGuards: [String: Bool] = [:]
  private var nodeID: String?
  private var nodeRegion: String?
  private var nodeZone: String?
  private var nodeSubZone: String?
#if ENVOY_MOBILE_XDS
  private var xdsBuilder: XdsBuilder?
#endif
  private var enableSwiftBootstrap = false

  // MARK: - Public

  /// Initialize a new builder with standard HTTP library configuration.
  public override init() {
    self.base = .standard
  }

  /// Initialize a new builder with a custom full YAML configuration.
  /// Setting other attributes in this builder will have no effect.
  ///
  /// - parameter yaml: Contents of a YAML file to use for configuration.
  public init(yaml: String) {
    self.base = .custom(yaml)
  }

  /// Add a log level to use with Envoy.
  ///
  /// - parameter logLevel: The log level to use with Envoy.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addLogLevel(_ logLevel: LogLevel) -> Self {
    self.logLevel = logLevel
    return self
  }

  /// Add a timeout for new network connections to hosts in the cluster.
  ///
  /// - parameter connectTimeoutSeconds: Timeout for new network
  ///                                    connections to hosts in the cluster.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addConnectTimeoutSeconds(_ connectTimeoutSeconds: UInt32) -> Self {
    self.connectTimeoutSeconds = connectTimeoutSeconds
    return self
  }

  /// Add a rate at which to refresh DNS in case of DNS failure.
  ///
  /// - parameter base: Base rate in seconds.
  /// - parameter max:  Max rate in seconds.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addDNSFailureRefreshSeconds(base: UInt32, max: UInt32) -> Self {
    self.dnsFailureRefreshSecondsBase = base
    self.dnsFailureRefreshSecondsMax = max
    return self
  }

  /// Add a rate at which to timeout DNS queries.
  ///
  /// - parameter dnsQueryTimeoutSeconds: Rate in seconds to timeout DNS queries.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addDNSQueryTimeoutSeconds(_ dnsQueryTimeoutSeconds: UInt32) -> Self {
    self.dnsQueryTimeoutSeconds = dnsQueryTimeoutSeconds
    return self
  }

  /// Add the minimum rate at which to refresh DNS. Once DNS has been resolved for a host, DNS TTL
  /// will be respected, subject to this minimum. Defaults to 60 seconds.
  ///
  /// - parameter dnsMinRefreshSeconds: Minimum rate in seconds at which to refresh DNS.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addDNSMinRefreshSeconds(_ dnsMinRefreshSeconds: UInt32) -> Self {
    self.dnsMinRefreshSeconds = dnsMinRefreshSeconds
    return self
  }

  /// Add a list of hostnames to preresolve on Engine startup.
  ///
  /// - parameter dnsPreresolveHostnames: the hostnames to resolve.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addDNSPreresolveHostnames(dnsPreresolveHostnames: [String]) -> Self {
    self.dnsPreresolveHostnames = dnsPreresolveHostnames
    return self
  }

  /// Add a default rate at which to refresh DNS.
  ///
  /// - parameter dnsRefreshSeconds: Default rate in seconds at which to refresh DNS.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addDNSRefreshSeconds(_ dnsRefreshSeconds: UInt32) -> Self {
    self.dnsRefreshSeconds = dnsRefreshSeconds
    return self
  }

  /// Specify whether to enable DNS cache.
  ///
  /// Note that DNS cache requires an addition of a key value store named
  /// 'reserved.platform_store'.
  ///
  /// - parameter enableDNSCache: whether to enable DNS cache. Disabled by default.
  /// - parameter saveInterval:   the interval at which to save results to the configured
  ///                             key value store.
  ///
  /// - returns: This builder.
  @discardableResult
  public func enableDNSCache(_ enableDNSCache: Bool, saveInterval: UInt32 = 1) -> Self {
    self.enableDNSCache = enableDNSCache
    self.dnsCacheSaveIntervalSeconds = saveInterval
    return self
  }

  /// Specify whether to do gzip response decompression or not.  Defaults to true.
  ///
  /// - parameter enableGzipDecompression: whether or not to gunzip responses.
  ///
  /// - returns: This builder.
  @discardableResult
  public func enableGzipDecompression(_ enableGzipDecompression: Bool) -> Self {
    self.enableGzipDecompression = enableGzipDecompression
    return self
  }

  /// Specify whether to do brotli response decompression or not.  Defaults to false.
  ///
  /// - parameter enableBrotliDecompression: whether or not to brotli decompress responses.
  ///
  /// - returns: This builder.
  @discardableResult
  public func enableBrotliDecompression(_ enableBrotliDecompression: Bool) -> Self {
    self.enableBrotliDecompression = enableBrotliDecompression
    return self
  }

#if ENVOY_ENABLE_QUIC
  /// Specify whether to enable support for HTTP/3 or not.  Defaults to true.
  ///
  /// - parameter enableHttp3: whether or not to enable HTTP/3.
  ///
  /// - returns: This builder.
  @discardableResult
  public func enableHttp3(_ enableHttp3: Bool) -> Self {
    self.enableHttp3 = enableHttp3
    return self
  }

  /// Add a host port pair that's known to support QUIC.
  ///
  /// - parameter host: the string representation of the host name
  /// - parameter port: the host's port number
  ///
  /// - returns: This builder.
  @discardableResult
  public func addQuicHint(_ host: String, _ port: Int) -> Self {
    self.quicHints[host] = port
    return self
  }

  /// Add a host suffix that's known to support QUIC.
  ///
  /// - parameter suffix: the string representation of the host suffix
  ///
  /// - returns: This builder.
  @discardableResult
  public func addQuicCanonicalSuffix(_ suffix: String) -> Self {
    self.quicCanonicalSuffixes.append(suffix)
    return self
  }
#endif

  /// Specify whether sockets may attempt to bind to a specific interface, based on network
  /// conditions.
  ///
  /// - parameter enableInterfaceBinding: whether to allow interface binding.
  ///
  /// - returns: This builder.
  @discardableResult
  public func enableInterfaceBinding(_ enableInterfaceBinding: Bool) -> Self {
    self.enableInterfaceBinding = enableInterfaceBinding
    return self
  }

  /// Specify whether to drain connections after the resolution of a soft DNS refresh.
  /// A refresh may be triggered directly via the Engine API, or as a result of a network
  /// status update provided by the OS. Draining connections does not interrupt existing
  /// connections or requests, but will establish new connections for any further requests.
  ///
  /// - parameter enableDrainPostDnsRefresh: whether to drain connections after soft DNS refresh.
  ///
  /// - returns: This builder.
  @discardableResult
  public func enableDrainPostDnsRefresh(_ enableDrainPostDnsRefresh: Bool) -> Self {
    self.enableDrainPostDnsRefresh = enableDrainPostDnsRefresh
    return self
  }

  /// Specify whether to enforce TLS trust chain verification for secure sockets.
  ///
  /// - parameter enforceTrustChainVerification: whether to enforce trust chain verification.
  ///
  /// - returns: This builder.
  @discardableResult
  public func enforceTrustChainVerification(_ enforceTrustChainVerification: Bool) -> Self {
    self.enforceTrustChainVerification = enforceTrustChainVerification
    return self
  }

  /// Specify whether to use the platform certificate verifier.
  ///
  /// - parameter enablePlatformCertificateValidation: whether to use the platform verifier.
  ///
  /// - returns: This builder.
  @discardableResult
  public func enablePlatformCertificateValidation(
    _ enablePlatformCertificateValidation: Bool) -> Self {
    self.enablePlatformCertificateValidation = enablePlatformCertificateValidation
    return self
  }

  /// Specify whether to remap IPv4 addresses to the IPv6 space and always force connections
  /// to use IPv6. Note this is an experimental option and should be enabled with caution.
  ///
  /// - parameter forceIPv6: whether to force connections to use IPv6.
  ///
  /// - returns: This builder.
  @discardableResult
  public func forceIPv6(_ forceIPv6: Bool) -> Self {
    self.forceIPv6 = forceIPv6
    return self
  }

  /// Add a rate at which to ping h2 connections on new stream creation if the connection has
  /// sat idle. Defaults to 1 millisecond which effectively enables h2 ping functionality
  /// and results in a connection ping on every new stream creation. Set it to
  /// 100000000 milliseconds to effectively disable the ping.
  ///
  /// - parameter h2ConnectionKeepaliveIdleIntervalMilliseconds: Rate in milliseconds.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addH2ConnectionKeepaliveIdleIntervalMilliseconds(
    _ h2ConnectionKeepaliveIdleIntervalMilliseconds: UInt32) -> Self {
    self.h2ConnectionKeepaliveIdleIntervalMilliseconds =
      h2ConnectionKeepaliveIdleIntervalMilliseconds
    return self
  }

  /// Add a rate at which to timeout h2 pings.
  ///
  /// - parameter h2ConnectionKeepaliveTimeoutSeconds: Rate in seconds to timeout h2 pings.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addH2ConnectionKeepaliveTimeoutSeconds(
    _ h2ConnectionKeepaliveTimeoutSeconds: UInt32) -> Self {
    self.h2ConnectionKeepaliveTimeoutSeconds = h2ConnectionKeepaliveTimeoutSeconds
    return self
  }

  /// Set the maximum number of connections to open to a single host. Default is 7.
  ///
  /// - parameter maxConnectionsPerHost: the maximum number of connections per host.
  ///
  /// - returns: This builder.
  @discardableResult
  public func setMaxConnectionsPerHost(_ maxConnectionsPerHost: UInt32) -> Self {
    self.maxConnectionsPerHost = maxConnectionsPerHost
    return self
  }

  /// Add a custom idle timeout for HTTP streams. Defaults to 15 seconds.
  ///
  /// - parameter streamIdleTimeoutSeconds: Idle timeout for HTTP streams.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addStreamIdleTimeoutSeconds(_ streamIdleTimeoutSeconds: UInt32) -> Self {
    self.streamIdleTimeoutSeconds = streamIdleTimeoutSeconds
    return self
  }

  /// Add a custom per try idle timeout for HTTP streams. Defaults to 15 seconds.
  ///
  /// - parameter perTryIdleTimeoutSeconds: Idle timeout for HTTP streams.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addPerTryIdleTimeoutSeconds(_ perTryIdleTimeoutSeconds: UInt32) -> Self {
    self.perTryIdleTimeoutSeconds = perTryIdleTimeoutSeconds
    return self
  }

  /// Add an HTTP platform filter factory used to construct filters for streams sent by this client.
  ///
  /// - parameter name:    Custom name to use for this filter factory. Useful for having
  ///                      more meaningful trace logs, but not required. Should be unique
  ///                      per factory registered.
  /// - parameter factory: Closure returning an instantiated filter. Called once per stream.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addPlatformFilter(name: String,
                                factory: @escaping () -> Filter) -> Self
  {
    self.platformFilterChain.append(EnvoyHTTPFilterFactory(filterName: name, factory: factory))
    return self
  }

  /// Add an HTTP platform filter factory used to construct filters for streams sent by this client.
  ///
  /// - parameter factory: Closure returning an instantiated filter. Called once per stream.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addPlatformFilter(_ factory: @escaping () -> Filter) -> Self
  {
    self.platformFilterChain.append(
      EnvoyHTTPFilterFactory(filterName: UUID().uuidString, factory: factory)
    )
    return self
  }

  /// Add an HTTP native filter factory used to construct filters for streams sent by this client.
  ///
  /// - parameter name:        Custom name to use for this filter factory. Useful for having
  ///                          more meaningful trace logs, but not required. Should be unique
  ///                          per factory registered.
  /// - parameter typedConfig: Config string for the filter.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addNativeFilter(name: String = UUID().uuidString, typedConfig: String) -> Self {
    self.nativeFilterChain.append(EnvoyNativeFilterConfig(name: name, typedConfig: typedConfig))
    return self
  }

  /// Add a string accessor to this Envoy Client.
  ///
  /// - parameter name:     the name of the accessor.
  /// - parameter accessor: lambda to access a string from the platform layer.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addStringAccessor(name: String, accessor: @escaping () -> String) -> Self {
    self.stringAccessors[name] = EnvoyStringAccessor(block: accessor)
    return self
  }

  /// Register a key-value store implementation for internal use.
  ///
  /// - parameter name:          the name of the KV store.
  /// - parameter keyValueStore: the KV store implementation.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addKeyValueStore(name: String, keyValueStore: KeyValueStore) -> Self {
    self.keyValueStores[name] = KeyValueStoreImpl(implementation: keyValueStore)
    return self
  }

  /// Set a runtime guard with the provided value.
  ///
  /// - parameter name:  the name of the runtime guard, e.g. test_feature_false.
  /// - parameter value: the value for the runtime guard.
  ///
  /// - returns: This builder.
  @discardableResult
  public func setRuntimeGuard(_ name: String, _ value: Bool) -> Self {
    self.runtimeGuards[name] = value
    return self
  }

  /// Set a closure to be called when the engine finishes its async startup and begins running.
  ///
  /// - parameter closure: The closure to be called.
  ///
  /// - returns: This builder.
  @discardableResult
  public func setOnEngineRunning(closure: @escaping () -> Void) -> Self {
    self.onEngineRunning = closure
    return self
  }

  /// Set a closure to be called when the engine's logger logs.
  ///
  /// - parameter closure: The closure to be called.
  ///
  /// - returns: This builder.
  @discardableResult
  public func setLogger(closure: @escaping (String) -> Void) -> Self {
    self.logger = closure
    return self
  }

  /// Set a closure to be called when the engine emits an event.
  ///
  /// - parameter closure: The closure to be called.
  ///
  /// - returns: This builder.
  @discardableResult
  public func setEventTracker(closure: @escaping ([String: String]) -> Void) -> Self {
    self.eventTracker = closure
    return self
  }

  /// Configure how the engine observes network reachability state changes.
  /// Defaults to `.pathMonitor`.
  ///
  /// - parameter mode: The mode to use.
  ///
  /// - returns: This builder.
  @discardableResult
  public func setNetworkMonitoringMode(_ mode: NetworkMonitoringMode) -> Self {
    self.monitoringMode = mode
    return self
  }

  /// Add the App Version of the App using this Envoy Client.
  ///
  /// - parameter appVersion: The version.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addAppVersion(_ appVersion: String) -> Self {
    self.appVersion = appVersion
    return self
  }

  /// Add the App ID of the App using this Envoy Client.
  ///
  /// - parameter appId: The ID.
  ///
  /// - returns: This builder.
  @discardableResult
  public func addAppId(_ appId: String) -> Self {
    self.appId = appId
    return self
  }

  /// Sets the node.id field in the Bootstrap configuration.
  ///
  /// - parameter nodeID: The node ID.
  ///
  /// - returns: This builder.
  @discardableResult
  public func setNodeID(_ nodeID: String) -> Self {
    self.nodeID = nodeID
    return self
  }

  /// Sets the node locality in the Bootstrap configuration.
  ///
  /// - parameter region:  The region.
  /// - parameter zone:    The zone.
  /// - parameter subZone: The sub-zone.
  ///
  /// - returns: This builder.
  @discardableResult
  public func setNodeLocality(
    region: String,
    zone: String,
    subZone: String
  ) -> Self {
    self.nodeRegion = region
    self.nodeZone = zone
    self.nodeSubZone = subZone
    return self
  }

#if ENVOY_MOBILE_XDS
  /// Sets the xDS configuration for the Envoy Mobile engine.
  ///
  /// - parameter xdsBuilder: The XdsBuilder instance which specifies the xDS config options.
  ///                         The EngineBuilder takes ownership over the xds_builder.
  ///
  /// - returns: This builder.
  @discardableResult
  public func setXds(_ xdsBuilder: XdsBuilder) -> Self {
    self.xdsBuilder = xdsBuilder
    return self
  }
#endif

#if canImport(EnvoyCxxSwiftInterop)
  /// Use Swift's experimental C++ interop support to generate the bootstrap object
  /// instead of going through the Objective-C layer.
  ///
  /// - parameter enableSwiftBootstrap: Whether or not to use the Swift / C++ interop
  ///                                   to generate the bootstrap object.
  ///
  /// - returns: This builder.
  @discardableResult
  public func enableSwiftBootstrap(_ enableSwiftBootstrap: Bool) -> Self {
    self.enableSwiftBootstrap = enableSwiftBootstrap
    return self
  }
#endif

  /// Builds and runs a new `Engine` instance with the provided configuration.
  ///
  /// - note: Must be strongly retained in order for network requests to be performed correctly.
  ///
  /// - returns: The built `Engine`.
  public func build() -> Engine {
    let engine = self.engineType.init(runningCallback: self.onEngineRunning, logger: self.logger,
                                      eventTracker: self.eventTracker,
                                      networkMonitoringMode: Int32(self.monitoringMode.rawValue))
    let config = self.makeConfig()
#if canImport(EnvoyCxxSwiftInterop)
    if self.enableSwiftBootstrap {
      config.bootstrapPointer = self.generateBootstrap().pointer
    }
#endif

    switch self.base {
    case .custom(let yaml):
      return EngineImpl(yaml: yaml, config: config, logLevel: self.logLevel, engine: engine)
    case .standard:
      return EngineImpl(config: config, logLevel: self.logLevel, engine: engine)
    }
  }

  // MARK: - Internal

  /// Add a specific implementation of `EnvoyEngine` to use for starting Envoy.
  /// A new instance of this engine will be created when `build()` is called.
  /// Used for testing, as initializing with `EnvoyEngine.Type` results in a
  /// segfault: https://github.com/envoyproxy/envoy-mobile/issues/334
  ///
  /// - parameter engineType: The specific implementation of `EnvoyEngine` to use for starting
  ///                         Envoy.
  ///
  /// - returns: This builder.
  @discardableResult
  func addEngineType(_ engineType: EnvoyEngine.Type) -> Self {
    self.engineType = engineType
    return self
  }

  func makeConfig() -> EnvoyConfiguration {
    var xdsServerAddress: String?
    var xdsServerPort: UInt32 = 0
    var xdsGrpcInitialMetadata: [String: String] = [:]
    var xdsSslRootCerts: String?
    var rtdsResourceName: String?
    var rtdsTimeoutSeconds: UInt32 = 0
    var enableCds: Bool = false
    var cdsResourcesLocator: String?
    var cdsTimeoutSeconds: UInt32 = 0

#if ENVOY_MOBILE_XDS
    xdsServerAddress = self.xdsBuilder?.xdsServerAddress
    xdsServerPort = self.xdsBuilder?.xdsServerPort ?? 0
    xdsGrpcInitialMetadata = self.xdsBuilder?.xdsGrpcInitialMetadata ?? [:]
    xdsSslRootCerts = self.xdsBuilder?.sslRootCerts
    rtdsResourceName = self.xdsBuilder?.rtdsResourceName
    rtdsTimeoutSeconds = self.xdsBuilder?.rtdsTimeoutInSeconds ?? 0
    enableCds = self.xdsBuilder?.enableCds ?? false
    cdsResourcesLocator = self.xdsBuilder?.cdsResourcesLocator
    cdsTimeoutSeconds = self.xdsBuilder?.cdsTimeoutInSeconds ?? 0
#endif

    return EnvoyConfiguration(
      connectTimeoutSeconds: self.connectTimeoutSeconds,
      dnsRefreshSeconds: self.dnsRefreshSeconds,
      dnsFailureRefreshSecondsBase: self.dnsFailureRefreshSecondsBase,
      dnsFailureRefreshSecondsMax: self.dnsFailureRefreshSecondsMax,
      dnsQueryTimeoutSeconds: self.dnsQueryTimeoutSeconds,
      dnsMinRefreshSeconds: self.dnsMinRefreshSeconds,
      dnsPreresolveHostnames: self.dnsPreresolveHostnames,
      enableDNSCache: self.enableDNSCache,
      dnsCacheSaveIntervalSeconds: self.dnsCacheSaveIntervalSeconds,
      enableHttp3: self.enableHttp3,
      quicHints: self.quicHints.mapValues { NSNumber(value: $0) },
      quicCanonicalSuffixes: self.quicCanonicalSuffixes,
      enableGzipDecompression: self.enableGzipDecompression,
      enableBrotliDecompression: self.enableBrotliDecompression,
      enableInterfaceBinding: self.enableInterfaceBinding,
      enableDrainPostDnsRefresh: self.enableDrainPostDnsRefresh,
      enforceTrustChainVerification: self.enforceTrustChainVerification,
      forceIPv6: self.forceIPv6,
      enablePlatformCertificateValidation: self.enablePlatformCertificateValidation,
      h2ConnectionKeepaliveIdleIntervalMilliseconds:
        self.h2ConnectionKeepaliveIdleIntervalMilliseconds,
      h2ConnectionKeepaliveTimeoutSeconds: self.h2ConnectionKeepaliveTimeoutSeconds,
      maxConnectionsPerHost: self.maxConnectionsPerHost,
      streamIdleTimeoutSeconds: self.streamIdleTimeoutSeconds,
      perTryIdleTimeoutSeconds: self.perTryIdleTimeoutSeconds,
      appVersion: self.appVersion,
      appId: self.appId,
      runtimeGuards: self.runtimeGuards.mapValues({ "\($0)" }),
      nativeFilterChain: self.nativeFilterChain,
      platformFilterChain: self.platformFilterChain,
      stringAccessors: self.stringAccessors,
      keyValueStores: self.keyValueStores,
      nodeId: self.nodeID,
      nodeRegion: self.nodeRegion,
      nodeZone: self.nodeZone,
      nodeSubZone: self.nodeSubZone,
      xdsServerAddress: xdsServerAddress,
      xdsServerPort: xdsServerPort,
      xdsGrpcInitialMetadata: xdsGrpcInitialMetadata,
      xdsSslRootCerts: xdsSslRootCerts,
      rtdsResourceName: rtdsResourceName,
      rtdsTimeoutSeconds: rtdsTimeoutSeconds,
      enableCds: enableCds,
      cdsResourcesLocator: cdsResourcesLocator,
      cdsTimeoutSeconds: cdsTimeoutSeconds
    )
  }

  func bootstrapDebugDescription() -> String {
    let objcDescription = self.makeConfig().bootstrapDebugDescription()
#if canImport(EnvoyCxxSwiftInterop)
    assert(
      self.generateBootstrap().debugDescription == objcDescription,
      "Swift bootstrap is different from ObjC bootstrap"
    )
#endif
    return objcDescription
  }
}

#if canImport(EnvoyCxxSwiftInterop)
private extension EngineBuilder {
  func generateBootstrap() -> Bootstrap {
    var cxxBuilder = Envoy.Platform.EngineBuilder()
    cxxBuilder.addLogLevel(self.logLevel.toCXX())

    cxxBuilder.addConnectTimeoutSeconds(Int32(self.connectTimeoutSeconds))
    cxxBuilder.addDnsRefreshSeconds(Int32(self.dnsRefreshSeconds))
    cxxBuilder.addDnsFailureRefreshSeconds(Int32(self.dnsFailureRefreshSecondsBase),
                                           Int32(self.dnsFailureRefreshSecondsMax))
    cxxBuilder.addDnsQueryTimeoutSeconds(Int32(self.dnsQueryTimeoutSeconds))
    cxxBuilder.addDnsMinRefreshSeconds(Int32(self.dnsMinRefreshSeconds))
    cxxBuilder.addDnsPreresolveHostnames(self.dnsPreresolveHostnames.toCXX())
    cxxBuilder.enableDnsCache(self.enableDNSCache, Int32(self.dnsCacheSaveIntervalSeconds))
#if ENVOY_ENABLE_QUIC
    cxxBuilder.enableHttp3(self.enableHttp3)
    for (host, port) in self.quicHints {
      cxxBuilder.addQuicHint(host.toCXX(), Int32(port))
    }
    for (suffix) in self.quicCanonicalSuffixes {
      cxxBuilder.addQuicCanonicalSuffix(suffix.toCXX())
    }
#endif
    cxxBuilder.enableGzipDecompression(self.enableGzipDecompression)
    cxxBuilder.enableBrotliDecompression(self.enableBrotliDecompression)
    cxxBuilder.enableInterfaceBinding(self.enableInterfaceBinding)
    cxxBuilder.enableDrainPostDnsRefresh(self.enableDrainPostDnsRefresh)
    cxxBuilder.enforceTrustChainVerification(self.enforceTrustChainVerification)
    cxxBuilder.setForceAlwaysUsev6(self.forceIPv6)
    cxxBuilder.enablePlatformCertificatesValidation(self.enablePlatformCertificateValidation)
    cxxBuilder.addH2ConnectionKeepaliveIdleIntervalMilliseconds(
      Int32(self.h2ConnectionKeepaliveIdleIntervalMilliseconds)
    )
    cxxBuilder.addH2ConnectionKeepaliveTimeoutSeconds(
      Int32(self.h2ConnectionKeepaliveTimeoutSeconds)
    )
    cxxBuilder.addMaxConnectionsPerHost(Int32(self.maxConnectionsPerHost))
    cxxBuilder.setStreamIdleTimeoutSeconds(Int32(self.streamIdleTimeoutSeconds))
    cxxBuilder.setPerTryIdleTimeoutSeconds(Int32(self.perTryIdleTimeoutSeconds))
    cxxBuilder.setAppVersion(self.appVersion.toCXX())
    cxxBuilder.setAppId(self.appId.toCXX())
    cxxBuilder.setDeviceOs("iOS".toCXX())

    for (runtimeGuard, value) in self.runtimeGuards {
      cxxBuilder.setRuntimeGuard(runtimeGuard.toCXX(), value)
    }

    for filter in self.nativeFilterChain.reversed() {
      cxxBuilder.addNativeFilter(filter.name.toCXX(), filter.typedConfig.toCXX())
    }

    for filter in self.platformFilterChain.reversed() {
      cxxBuilder.addPlatformFilter(filter.filterName.toCXX())
    }

    if
      let nodeRegion = self.nodeRegion,
      let nodeZone = self.nodeZone,
      let nodeSubZone = self.nodeSubZone
    {
      cxxBuilder.setNodeLocality(nodeRegion.toCXX(), nodeZone.toCXX(), nodeSubZone.toCXX())
    }

    if let nodeID = self.nodeID {
      cxxBuilder.setNodeId(nodeID.toCXX())
    }

    generateXds(&cxxBuilder)

    return cxxBuilder.generateBootstrap()
  }

  private func generateXds(_ cxxBuilder: inout Envoy.Platform.EngineBuilder) {
#if ENVOY_MOBILE_XDS
    if let xdsBuilder = self.xdsBuilder {
      var cxxXdsBuilder = Envoy.Platform.XdsBuilder(xdsBuilder.xdsServerAddress.toCXX(),
                                                    xdsBuilder.xdsServerPort)
      for (header, value) in xdsBuilder.xdsGrpcInitialMetadata {
        cxxXdsBuilder.addInitialStreamHeader(header.toCXX(), value.toCXX())
      }
      if let xdsSslRootCerts = xdsBuilder.sslRootCerts {
        cxxXdsBuilder.setSslRootCerts(xdsSslRootCerts.toCXX())
      }
      if let rtdsResourceName = xdsBuilder.rtdsResourceName {
        cxxXdsBuilder.addRuntimeDiscoveryService(rtdsResourceName.toCXX(),
                                                 Int32(xdsBuilder.rtdsTimeoutInSeconds))
      }
      if xdsBuilder.enableCds {
        cxxXdsBuilder.addClusterDiscoveryService(
          xdsBuilder.cdsResourcesLocator?.toCXX() ?? "".toCXX(),
          Int32(xdsBuilder.cdsTimeoutInSeconds))
      }
      cxxBuilder.setXds(cxxXdsBuilder)
    }
#endif
  }
}
#endif
load("@build_bazel_rules_apple//apple:apple.bzl", "apple_static_xcframework")
load("@build_bazel_rules_apple//apple:ios.bzl", "ios_static_framework")
load("@build_bazel_rules_swift//swift:swift.bzl", "swift_library")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_defines", "envoy_mobile_package")
load("//bazel:apple.bzl", "envoy_mobile_swift_copts")
load("//bazel:config.bzl", "MINIMUM_IOS_VERSION")
load("//bazel:swift_header_collector.bzl", "swift_header_collector")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

swift_library(
    name = "ios_lib",
    srcs = [
        "DirectResponse.swift",
        "Engine.swift",
        "EngineBuilder.swift",
        "EngineImpl.swift",
        "EnvoyError.swift",
        "FinalStreamIntel.swift",
        "Headers.swift",
        "HeadersBuilder.swift",
        "HeadersContainer.swift",
        "KeyValueStore.swift",
        "LogLevel.swift",
        "NetworkMonitoringMode.swift",
        "PulseClient.swift",
        "PulseClientImpl.swift",
        "RequestHeaders.swift",
        "RequestHeadersBuilder.swift",
        "RequestMethod.swift",
        "RequestTrailers.swift",
        "RequestTrailersBuilder.swift",
        "ResponseHeaders.swift",
        "ResponseHeadersBuilder.swift",
        "ResponseTrailers.swift",
        "ResponseTrailersBuilder.swift",
        "RetryPolicy.swift",
        "RetryPolicyMapper.swift",
        "RouteMatcher.swift",
        "Stream.swift",
        "StreamCallbacks.swift",
        "StreamClient.swift",
        "StreamClientImpl.swift",
        "StreamIntel.swift",
        "StreamPrototype.swift",
        "Trailers.swift",
        "extensions/UserDefaults+KeyValueStore.swift",
        "filters/AsyncRequestFilter.swift",
        "filters/AsyncResponseFilter.swift",
        "filters/Filter.swift",
        "filters/FilterDataStatus.swift",
        "filters/FilterHeadersStatus.swift",
        "filters/FilterResumeStatus.swift",
        "filters/FilterTrailersStatus.swift",
        "filters/RequestFilter.swift",
        "filters/RequestFilterCallbacks.swift",
        "filters/RequestFilterCallbacksImpl.swift",
        "filters/ResponseFilter.swift",
        "filters/ResponseFilterCallbacks.swift",
        "filters/ResponseFilterCallbacksImpl.swift",
        "grpc/Data+Extension.swift",
        "grpc/GRPCClient.swift",
        "grpc/GRPCRequestHeaders.swift",
        "grpc/GRPCRequestHeadersBuilder.swift",
        "grpc/GRPCStream.swift",
        "grpc/GRPCStreamPrototype.swift",
        "mocks/MockEnvoyEngine.swift",
        "mocks/MockEnvoyHTTPStream.swift",
        "mocks/MockStream.swift",
        "mocks/MockStreamClient.swift",
        "mocks/MockStreamPrototype.swift",
        "stats/Counter.swift",
        "stats/CounterImpl.swift",
        "stats/Element.swift",
        "stats/Tags.swift",
        "stats/TagsBuilder.swift",
    ] + [
        "@envoy_mobile_extra_swift_sources//:extra_swift_srcs",
    ] + select({
        "//bazel:envoy_mobile_swift_cxx_interop": [
            "cxx/Bootstrap.swift",
            "cxx/DirectResponse+Cxx.swift",
            "cxx/LogLevel+Cxx.swift",
            "cxx/Swift+Cxx.swift",
        ],
        "//conditions:default": [],
    }),
    copts = select({
        "//bazel:envoy_mobile_swift_cxx_interop": envoy_mobile_swift_copts(True),
        "//conditions:default": [],
    }),
    defines = envoy_mobile_defines("@envoy"),
    features = [
        "swift.emit_symbol_graph",
        "swift.enable_library_evolution",
    ],
    generates_header = True,
    module_name = "Envoy",
    private_deps = [
        "//library/objective-c:envoy_engine_objc_lib",
        "@envoy_mobile_extra_swift_sources//:extra_private_dep",
    ] + select({
        "//bazel:envoy_mobile_swift_cxx_interop": [
            "//library/swift/EnvoyCxxSwiftInterop",
        ],
        "//conditions:default": [],
    }),
    visibility = ["//visibility:public"],
)

swift_header_collector(
    name = "ios_lib_headers",
    library = "ios_lib",
)

ios_static_framework(
    name = "ios_framework",
    hdrs = ["ios_lib_headers"],
    bundle_name = "Envoy",
    minimum_os_version = MINIMUM_IOS_VERSION,
    # Currently the framework is over 2GB, and is not worth caching
    tags = [
        "no-cache",
        "no-remote",
    ],
    visibility = ["//visibility:public"],
    deps = ["ios_lib"],
)

apple_static_xcframework(
    name = "Envoy",
    ios = {
        "simulator": [
            "arm64",
            "x86_64",
        ],
        "device": [
            "arm64",
        ],
    },
    minimum_os_versions = {
        "ios": MINIMUM_IOS_VERSION,
    },
    # Currently the framework is over 2GB, and is not worth caching
    tags = [
        "no-cache",
        "no-remote",
    ],
    visibility = ["//visibility:public"],
    deps = ["ios_lib"],
)
import Dispatch
@_implementationOnly import EnvoyEngine
import Foundation

/// A collection of platform-level callbacks that are specified by consumers
/// who wish to interact with streams.
///
/// `StreamCallbacks` are bridged through to `EnvoyHTTPCallbacks` to communicate with the engine.
final class StreamCallbacks {
  var onHeaders: (
    (_ headers: ResponseHeaders, _ endStream: Bool, _ streamIntel: StreamIntel) -> Void
  )?
  var onData: ((_ body: Data, _ endStream: Bool, _ streamIntel: StreamIntel) -> Void)?
  var onTrailers: ((_ trailers: ResponseTrailers, _ streamIntel: StreamIntel) -> Void)?
  var onSendWindowAvailable: ((_ streamintel: StreamIntel) -> Void)?
  var onComplete: ((_ streamintel: FinalStreamIntel) -> Void)?
  var onCancel: ((_ streamintel: FinalStreamIntel) -> Void)?
  var onError: ((_ error: EnvoyError, _ streamIntel: FinalStreamIntel) -> Void)?
}

extension EnvoyHTTPCallbacks {
  /// Initializer propagating the platform callbacks into callbacks that the engine can use.
  ///
  /// - parameter callbacks: Platform callbacks to use.
  /// - parameter queue:     Queue on which to receive callback events.
  convenience init(callbacks: StreamCallbacks, queue: DispatchQueue) {
    self.init()
    self.dispatchQueue = queue
    self.onHeaders = { callbacks.onHeaders?(ResponseHeaders(headers: $0), $1, StreamIntel($2)) }
    self.onData = { callbacks.onData?($0, $1, StreamIntel($2)) }
    self.onTrailers = { callbacks.onTrailers?(ResponseTrailers(headers: $0), StreamIntel($1)) }
    self.onSendWindowAvailable = { callbacks.onSendWindowAvailable?(StreamIntel($0)) }
    self.onComplete = { callbacks.onCancel?(FinalStreamIntel($0, $1)) }
    self.onCancel = { callbacks.onCancel?(FinalStreamIntel($0, $1)) }
    self.onError = { errorCode, message, attemptCount, streamIntel, finalStreamIntel in
      // The initializer below will return nil if `attemptCount` is negative.
      // This is the desired behavior because the bridge layer uses -1 to signify absence.
      let error = EnvoyError(errorCode: errorCode, message: message,
                             attemptCount: UInt32(exactly: attemptCount), cause: nil)
      callbacks.onError?(error, FinalStreamIntel(streamIntel, finalStreamIntel))
    }
  }
}
@_implementationOnly import EnvoyEngine
import Foundation

/// `KeyValueStore` is an interface that may be implemented to provide access to an arbitrary
/// key-value store implementation that may be made accessible to native Envoy Mobile code.
@objc
public protocol KeyValueStore {
  /// Read a value from the key value store implementation.
  ///
  /// - parameter key: The key whose value should be read.
  ///
  /// - returns: The value read for the key if it was found.
  func readValue(forKey key: String) -> String?

  /// Save a value to the key value store implementation.
  ///
  /// - parameter value: The value to save.
  /// - parameter key:   The key to associate with the saved value.
  func saveValue(_ value: String, toKey key: String)

  /// Remove a value from the key value store implementation.
  ///
  /// - parameter key: The key whose value should be removed.
  func removeKey(_ key: String)
}

/// KeyValueStoreImpl is an internal type used for mapping calls from the common library layer.
internal class KeyValueStoreImpl: EnvoyKeyValueStore {
  internal let implementation: KeyValueStore

  init(implementation: KeyValueStore) {
    self.implementation = implementation
  }

  func readValue(forKey key: String) -> String? {
    return implementation.readValue(forKey: key)
  }

  func saveValue(_ value: String, toKey key: String) {
    implementation.saveValue(value, toKey: key)
  }

  func removeKey(_ key: String) {
    implementation.removeKey(key)
  }
}
import Foundation

/// Client used to create HTTP streams.
@objc
public protocol StreamClient: AnyObject {
  /// Create a new stream prototype which can be used to start streams.
  ///
  /// - returns: The new stream prototype.
  func newStreamPrototype() -> StreamPrototype
}
import Foundation

/// Headers representing an inbound response.
@objcMembers
public final class ResponseHeaders: Headers {
  /// HTTP status code received with the response.
  public private(set) lazy var httpStatus: UInt? =
    self.value(forName: ":status")?.first.flatMap(UInt.init)

  /// Convert the headers back to a builder for mutation.
  ///
  /// - returns: The new builder.
  public func toResponseHeadersBuilder() -> ResponseHeadersBuilder {
    return ResponseHeadersBuilder(container: self.container)
  }
}
@_implementationOnly import EnvoyEngine
import Foundation

/// Exposes internal HTTP stream metrics, context, and other details.
@objcMembers
public class StreamIntel: NSObject, Error {
  // An internal identifier for the stream. -1 if not set.
  public let streamId: Int64
  // An internal identifier for the connection carrying the stream. -1 if not set.
  public let connectionId: Int64
  // The number of internal attempts to carry out a request/operation. 0 if not set.
  public let attemptCount: UInt64

  public init(streamId: Int64, connectionId: Int64, attemptCount: UInt64) {
    self.streamId = streamId
    self.connectionId = connectionId
    self.attemptCount = attemptCount
  }
}

extension StreamIntel {
  internal convenience init(_ cStruct: EnvoyStreamIntel) {
    self.init(streamId: cStruct.stream_id,
              connectionId: cStruct.connection_id,
              attemptCount: cStruct.attempt_count)
  }
}
import Foundation

/// Client for Envoy Mobile's stats library, Pulse, used to record client time series metrics.
///
/// Note: this an experimental interface and is subject to change. The implementation has not been
/// optimized, and there may be performance implications in production usage.
@objc
public protocol PulseClient: AnyObject {
  /// - parameter elements: Elements to identify a counter
  ///
  /// - returns: A Counter based on the joined elements.
  func counter(elements: [Element]) -> Counter

  /// - parameter elements: Elements to identify a counter
  /// - parameter tags:     Tags of the counter
  ///
  /// - returns: A Counter based on the joined elements and along with tags
  func counter(elements: [Element], tags: Tags) -> Counter
}
@_implementationOnly import EnvoyEngine
import Foundation

/// The implementation of time series counter.
@objcMembers
final class CounterImpl: NSObject, Counter {
  private let series: String
  private let tags: Tags
  private weak var engine: EnvoyEngine?

  init(elements: [Element], tags: Tags, engine: EnvoyEngine) {
    self.series = elements.map { $0.value }.joined(separator: ".")
    self.engine = engine
    self.tags = tags
    super.init()
  }

  /// Increment the counter by the given count.
  ///
  /// - parameter count: The count to increment on this counter.
  func increment(count: Int) {
    // TODO(jingwei99) potentially surface error up if engine is nil.
    self.engine?.recordCounterInc(self.series, tags: self.tags.allTags(), count: numericCast(count))
  }

  /// Increment the counter by the given count with tags.
  ///
  /// - parameter tags:  The tags to attach to this counter.
  /// - parameter count: The count to increment on this counter.
  func increment(tags: Tags, count: Int) {
    self.engine?.recordCounterInc(self.series, tags: tags.allTags(), count: numericCast(count))
  }
}
import Foundation

/// Builder class used to construct `Tags` instances.
/// See `TagsBuilder` for usage.
@objcMembers
public class TagsBuilder: NSObject {
  private(set) var tags: [String: String]

  /// Append a value to the tag name.
  ///
  /// - parameter name:  The tag name.
  /// - parameter value: The value associated to the tag name.
  ///
  /// - returns: This builder.
  @discardableResult
  public func add(name: String, value: String) -> Self {
    self.tags[name] = value
    return self
  }

  /// Replace all values at the provided name with a new set of tag values.
  ///
  /// - parameter name:  The tag name.
  /// - parameter value: The value associated to the tag name.
  ///
  /// - returns: This builder.
  @discardableResult
  public func set(name: String, value: String) -> Self {
    self.tags[name] = value
    return self
  }

  /// Remove all tags with this name.
  ///
  /// - parameter name: The tag name to remove.
  ///
  /// - returns: This builder.
  @discardableResult
  public func remove(name: String) -> Self {
    self.tags[name] = nil
    return self
  }

  /// Add all tags from dictionary to builder.
  ///
  /// - parameter tags: a dictionary of tags.
  ///
  /// - returns: This builder.
  @discardableResult
  public func putAll(tags: [String: String]) -> Self {
    self.tags = self.tags.merging(tags, uniquingKeysWith: { _, last in last })
    return self
  }

  /// Build the tags using the current builder.
  ///
  /// - returns: New instance of request headers.
  public func build() -> Tags {
    return Tags(tags: self.tags)
  }

  // MARK: - Internal

  /// Allows for setting tags that are not publicly mutable (i.e., restricted tags).
  ///
  /// - parameter name:  The tag name.
  /// - parameter value: The value associated to the tag name.
  ///
  /// - returns: This builder.
  @discardableResult
  func internalSet(name: String, value: String) -> Self {
    self.tags[name] = value
    return self
  }

  // Only explicitly implemented to work around a swiftinterface issue in Swift 5.1. This can be
  // removed once envoy is only built with Swift 5.2+
  public override required init() {
    self.tags = [String: String]()
    super.init()
  }

  /// Initialize a new builder with a tag map.
  ///
  /// - parameter tags: The tags with which to start.
  public required init(tags: [String: String]) {
    self.tags = tags
    super.init()
  }
}

// MARK: - Equatable

extension TagsBuilder {
  public override func isEqual(_ object: Any?) -> Bool {
    return (object as? Self)?.tags == self.tags
  }
}
import Foundation

private let kPattern = "^[A-Za-z_]+$"

/// Element represents one dot-delimited component of a time series name.
/// Element values must conform to the regex /^[A-Za-z_]+$/.
@objcMembers
public final class Element: NSObject, ExpressibleByStringLiteral {
  internal let value: String

  public init(stringLiteral value: String) {
    precondition(
      value.matchesStatsElementPattern,
      "Element values must conform to the regex '\(kPattern)'."
    )
    self.value = value
  }

  public override func isEqual(_ object: Any?) -> Bool {
    return (object as? Element)?.value == self.value
  }
}

extension String {
  var matchesStatsElementPattern: Bool {
    if #available(iOS 16.0, macOS 13.0, *) {
      return self.contains(/^[A-Za-z_]+$/)
    }

    // `std` is the name of the C++ stdlib when importing it into Swift.
    // So effectively this checks if we're compiling with `-enable-experimental-cxx-interop`.
#if canImport(std)
    return (self as NSString).range(of: kPattern, options: regularExpression).location != NSNotFound
#else
    return self.range(of: kPattern, options: .regularExpression) != nil
#endif
  }
}
import Foundation

/// Class used to represent tags data structures.
/// To instantiate new instances, see `TagsBuilder`.
@objcMembers
public class Tags: NSObject {
  let tags: [String: String]

  /// Get the value for the provided tag name.
  ///
  /// - parameter name: tag name for which to get the current value.
  ///
  /// - returns: The current tag value specified for the provided name.
  public func value(forName name: String) -> String? {
    return self.tags[name]
  }

  /// Accessor for all underlying tags as a map.
  ///
  /// - returns: The underlying tags.
  public func allTags() -> [String: String] {
    return self.tags
  }

  /// Internal initializer used by builders.
  ///
  /// - parameter tags: Tags to set.
  required init(tags: [String: String]) {
    self.tags = tags
    super.init()
  }

  /// Internal initializer used by builders.
  override required init() {
    self.tags = [String: String]()
    super.init()
  }
}

// MARK: - Equatable

extension Tags {
  public override func isEqual(_ object: Any?) -> Bool {
    return (object as? Self)?.tags == self.tags
  }
}

// MARK: - CustomStringConvertible

extension Tags {
  public override var description: String {
    return "\(type(of: self)) \(self.tags.description)"
  }
}
import Foundation

/// A time series counter.
@objc
public protocol Counter: AnyObject {
  /// Increment the counter by the given count.
  ///
  /// - parameter count: The count to add to this counter.
  func increment(count: Int)

  /// Increment the counter by the given count and along with tags.
  ///
  /// - parameter tags:  The tags to attach to this Counter.
  /// - parameter count: The count to add to this counter.
  func increment(tags: Tags, count: Int)
}

extension Counter {
  /// Increment the counter by 1.
  public func increment() {
    self.increment(count: 1)
  }
}
import Foundation

/// Builder used for constructing instances of `ResponseTrailers`.
@objcMembers
public final class ResponseTrailersBuilder: HeadersBuilder {
  /// Initialize a new instance of the builder.
  public override convenience init() {
    self.init(container: HeadersContainer())
  }

  /// Build the response trailers using the current builder.
  ///
  /// - returns: New instance of response trailers.
  public func build() -> ResponseTrailers {
    return ResponseTrailers(container: self.container)
  }
}
@_implementationOnly import EnvoyEngine
import Foundation

/// Envoy Mobile Engine implementation.
@objcMembers
final class EngineImpl: NSObject {
  private let engine: EnvoyEngine
  private let pulseClientImpl: PulseClientImpl
  private let streamClientImpl: StreamClientImpl

  private enum ConfigurationType {
    case custom(yaml: String, config: EnvoyConfiguration)
    case standard(config: EnvoyConfiguration)
  }

  private init(configType: ConfigurationType, logLevel: LogLevel, engine: EnvoyEngine) {
    self.engine = engine
    self.pulseClientImpl = PulseClientImpl(engine: engine)
    self.streamClientImpl = StreamClientImpl(engine: engine)
    super.init()

    switch configType {
    case .custom(let yaml, let config):
      self.engine.run(withYAML: yaml, config: config, logLevel: logLevel.stringValue)
    case .standard(let config):
      self.engine.run(withConfig: config, logLevel: logLevel.stringValue)
    }
  }

  /// Initialize a new Envoy instance using a typed configuration.
  ///
  /// - parameter config:   Configuration to use for starting Envoy.
  /// - parameter logLevel: Log level to use for this instance.
  /// - parameter engine:   The underlying engine to use for starting Envoy.
  convenience init(config: EnvoyConfiguration, logLevel: LogLevel = .info, engine: EnvoyEngine) {
    self.init(configType: .standard(config: config), logLevel: logLevel, engine: engine)
  }

  /// Initialize a new Envoy instance using a string configuration.
  ///
  /// - parameter yaml:     Template yaml to use as basis for configuration.
  /// - parameter config:   Configuration to use for starting Envoy.
  /// - parameter logLevel: Log level to use for this instance.
  /// - parameter engine:   The underlying engine to use for starting Envoy.
  convenience init(yaml: String, config: EnvoyConfiguration, logLevel: LogLevel = .info,
                   engine: EnvoyEngine)
  {
    self.init(configType: .custom(yaml: yaml, config: config), logLevel: logLevel, engine: engine)
  }
}

extension EngineImpl: Engine {
  func streamClient() -> StreamClient {
    return self.streamClientImpl
  }

  func pulseClient() -> PulseClient {
    return self.pulseClientImpl
  }

  func dumpStats() -> String {
    self.engine.dumpStats()
  }

  func terminate() {
    self.engine.terminate()
  }

  func resetConnectivityState() {
    self.engine.resetConnectivityState()
  }
}
-dontwarn com.google.protobuf.**

-dontnote com.google.protobuf.**

-keep class com.google.protobuf.** {
   *;
}

-keep class com.google.protobuf.MessageLite {
   *;
}

-keep class com.google.protobuf.MessageLite$Builder {
   *;
}
#pragma once

#include <memory>
#include <optional>
#include <vector>

#include "absl/types/optional.h"
#include "library/cc/envoy_error.h"
#include "library/cc/response_headers.h"
#include "library/cc/response_trailers.h"
#include "library/cc/stream.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Platform {

class Stream;
using StreamSharedPtr = std::shared_ptr<Stream>;

using OnHeadersCallback = std::function<void(ResponseHeadersSharedPtr headers, bool end_stream,
                                             envoy_stream_intel intel)>;
using OnDataCallback = std::function<void(envoy_data data, bool end_stream)>;
using OnTrailersCallback =
    std::function<void(ResponseTrailersSharedPtr trailers, envoy_stream_intel intel)>;
using OnErrorCallback = std::function<void(EnvoyErrorSharedPtr error, envoy_stream_intel intel,
                                           envoy_final_stream_intel final_intel)>;
using OnCompleteCallback =
    std::function<void(envoy_stream_intel intel, envoy_final_stream_intel final_intel)>;
using OnCancelCallback =
    std::function<void(envoy_stream_intel intel, envoy_final_stream_intel final_intel)>;
using OnSendWindowAvailableCallback = std::function<void(envoy_stream_intel intel)>;

// See library/common/types/c_types.h for what these callbacks should do.
struct StreamCallbacks : public std::enable_shared_from_this<StreamCallbacks> {
  absl::optional<OnHeadersCallback> on_headers;
  absl::optional<OnDataCallback> on_data;
  absl::optional<OnTrailersCallback> on_trailers;
  absl::optional<OnErrorCallback> on_error;
  absl::optional<OnCompleteCallback> on_complete;
  absl::optional<OnCancelCallback> on_cancel;
  absl::optional<OnSendWindowAvailableCallback> on_send_window_available;

  envoy_http_callbacks asEnvoyHttpCallbacks();
};

using StreamCallbacksSharedPtr = std::shared_ptr<StreamCallbacks>;

} // namespace Platform
} // namespace Envoy
#include "library/cc/stream_client.h"

namespace Envoy {
namespace Platform {

StreamClient::StreamClient(EngineSharedPtr engine) : engine_(engine) {}

StreamPrototypeSharedPtr StreamClient::newStreamPrototype() {
  return std::make_shared<StreamPrototype>(engine_);
}

} // namespace Platform
} // namespace Envoy
#include "stream_prototype.h"

#include "library/common/engine.h"

namespace Envoy {
namespace Platform {

StreamPrototype::StreamPrototype(EngineSharedPtr engine) : engine_(engine) {
  callbacks_ = std::make_shared<StreamCallbacks>();
}

StreamSharedPtr StreamPrototype::start(bool explicit_flow_control) {
  auto envoy_stream = engine_->engine_->initStream();
  engine_->engine_->startStream(envoy_stream, callbacks_->asEnvoyHttpCallbacks(),
                                explicit_flow_control);
  return std::make_shared<Stream>(engine_->engine_, envoy_stream);
}

StreamPrototype& StreamPrototype::setOnHeaders(OnHeadersCallback closure) {
  callbacks_->on_headers = closure;
  return *this;
}

StreamPrototype& StreamPrototype::setOnData(OnDataCallback closure) {
  callbacks_->on_data = closure;
  return *this;
}

StreamPrototype& StreamPrototype::setOnTrailers(OnTrailersCallback closure) {
  callbacks_->on_trailers = closure;
  return *this;
}

StreamPrototype& StreamPrototype::setOnError(OnErrorCallback closure) {
  callbacks_->on_error = closure;
  return *this;
}

StreamPrototype& StreamPrototype::setOnComplete(OnCompleteCallback closure) {
  callbacks_->on_complete = closure;
  return *this;
}

StreamPrototype& StreamPrototype::setOnCancel(OnCancelCallback closure) {
  callbacks_->on_cancel = closure;
  return *this;
}

StreamPrototype& StreamPrototype::setOnSendWindowAvailable(OnSendWindowAvailableCallback closure) {
  callbacks_->on_send_window_available = closure;
  return *this;
}

} // namespace Platform
} // namespace Envoy
#pragma once

#include <exception>
#include <memory>
#include <optional>
#include <string>

#include "absl/types/optional.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Platform {

struct EnvoyError {
  envoy_error_code_t error_code;
  std::string message;
  absl::optional<int> attempt_count;
  absl::optional<std::exception> cause;
};

using EnvoyErrorSharedPtr = std::shared_ptr<EnvoyError>;

} // namespace Platform
} // namespace Envoy
#pragma once

#include <functional>

#include "library/cc/log_level.h"
#include "library/cc/stream_client.h"
#include "library/common/types/c_types.h"

namespace Envoy {
class Engine;
class BaseClientIntegrationTest;

namespace Platform {

class StreamClient;
using StreamClientSharedPtr = std::shared_ptr<StreamClient>;

class Engine : public std::enable_shared_from_this<Engine> {
public:
  ~Engine();

  std::string dumpStats();
  StreamClientSharedPtr streamClient();

  envoy_status_t terminate();
  Envoy::Engine* engine() { return engine_; }

private:
  Engine(::Envoy::Engine* engine);

  // required to access private constructor
  friend class EngineBuilder;
  // required to use envoy_engine_t without exposing it publicly
  friend class StreamPrototype;
  // for testing only
  friend class ::Envoy::BaseClientIntegrationTest;

  Envoy::Engine* engine_;
  StreamClientSharedPtr stream_client_;
  bool terminated_;
};

using EngineSharedPtr = std::shared_ptr<Engine>;

} // namespace Platform
} // namespace Envoy
#include "library/cc/headers.h"

namespace Envoy {
namespace Platform {

Headers::const_iterator Headers::begin() const {
  return Headers::const_iterator(allHeaders().begin());
}

Headers::const_iterator Headers::end() const { return Headers::const_iterator(allHeaders().end()); }

const std::vector<std::string>& Headers::operator[](absl::string_view key) const {
  return headers_.at(key);
}

const RawHeaderMap& Headers::allHeaders() const { return headers_; }

bool Headers::contains(const std::string& key) const { return headers_.contains(key); }

Headers::Headers(const RawHeaderMap& headers) : headers_(headers) {}

} // namespace Platform
} // namespace Envoy
#pragma once

#include <optional>

#include "absl/types/optional.h"
#include "library/cc/headers.h"
#include "library/cc/request_headers_builder.h"
#include "library/cc/request_method.h"
#include "library/cc/retry_policy.h"

namespace Envoy {
namespace Platform {

class RequestHeadersBuilder;

class RequestHeaders : public Headers {
public:
  RequestMethod requestMethod() const;
  const std::string& scheme() const;
  const std::string& authority() const;
  const std::string& path() const;
  absl::optional<RetryPolicy> retryPolicy() const;

  RequestHeadersBuilder toRequestHeadersBuilder() const;

private:
  RequestHeaders(RawHeaderMap headers) : Headers(std::move(headers)) {}

  friend class RequestHeadersBuilder;
};

using RequestHeadersSharedPtr = std::shared_ptr<RequestHeaders>;

} // namespace Platform
} // namespace Envoy
#pragma once

#include <memory>

#include "envoy/common/pure.h"

#include "absl/types/optional.h"
#include "library/common/api/c_types.h"

namespace Envoy {
namespace Platform {

/**
 * `StringAccessor` is an interface that may be implemented to provide access to an arbitrary
 * string from the application.
 */
class StringAccessor : public std::enable_shared_from_this<StringAccessor> {
public:
  virtual ~StringAccessor() = default;

  /**
   * Returns the string associated with this accessor.
   */
  virtual const std::string& get() const PURE;

  /**
   * Maps an implementation to its internal representation.
   * @return portable internal type used to call an implementation.
   */
  static envoy_string_accessor asEnvoyStringAccessor(std::shared_ptr<StringAccessor> accessor);
};

using StringAccessorSharedPtr = std::shared_ptr<StringAccessor>;

} // namespace Platform
} // namespace Envoy
#include "library/cc/response_headers.h"

namespace Envoy {
namespace Platform {

int ResponseHeaders::httpStatus() const {
  if (!contains(":status")) {
    return 0;
  }
  return stoi((*this)[":status"][0]);
}

ResponseHeadersBuilder ResponseHeaders::toResponseHeadersBuilder() {
  ResponseHeadersBuilder builder;
  if (contains(":status")) {
    builder.addHttpStatus(httpStatus());
  }
  for (const auto& pair : allHeaders()) {
    builder.set(pair.first, pair.second);
  }
  return builder;
}

} // namespace Platform
} // namespace Envoy
#include "library/cc/response_trailers.h"

namespace Envoy {
namespace Platform {

ResponseTrailersBuilder ResponseTrailers::toResponseTrailersBuilder() {
  ResponseTrailersBuilder builder;
  for (const auto& pair : allHeaders()) {
    builder.set(pair.first, pair.second);
  }
  return builder;
}

} // namespace Platform
} // namespace Envoy
#pragma once

#include <memory>

#include "library/cc/engine.h"
#include "library/cc/stream_prototype.h"

namespace Envoy {
namespace Platform {

class Engine;
using EngineSharedPtr = std::shared_ptr<Engine>;

class StreamPrototype;
using StreamPrototypeSharedPtr = std::shared_ptr<StreamPrototype>;

class StreamClient {
public:
  StreamClient(EngineSharedPtr engine);

  StreamPrototypeSharedPtr newStreamPrototype();

private:
  EngineSharedPtr engine_;
};

using StreamClientSharedPtr = std::shared_ptr<StreamClient>;

} // namespace Platform
} // namespace Envoy
#include "request_method.h"

#include <stdexcept>

#include "source/common/common/assert.h"

#include "absl/strings/string_view.h"

namespace Envoy {
namespace Platform {

namespace {

const std::pair<RequestMethod, absl::string_view> REQUEST_METHOD_LOOKUP[]{
    {RequestMethod::DELETE, "DELETE"}, {RequestMethod::GET, "GET"},
    {RequestMethod::HEAD, "HEAD"},     {RequestMethod::OPTIONS, "OPTIONS"},
    {RequestMethod::PATCH, "PATCH"},   {RequestMethod::POST, "POST"},
    {RequestMethod::PUT, "PUT"},       {RequestMethod::TRACE, "TRACE"},
};

} // namespace

absl::string_view requestMethodToString(RequestMethod method) {
  for (const auto& pair : REQUEST_METHOD_LOOKUP) {
    if (pair.first == method) {
      return pair.second;
    }
  }

  IS_ENVOY_BUG("unknown method");
  return "";
}

RequestMethod requestMethodFromString(absl::string_view str) {
  for (const auto& pair : REQUEST_METHOD_LOOKUP) {
    if (pair.second == str) {
      return pair.first;
    }
  }

  IS_ENVOY_BUG("unknown method");
  return REQUEST_METHOD_LOOKUP[0].first;
}

} // namespace Platform
} // namespace Envoy
#pragma once

#include "library/cc/headers.h"

namespace Envoy {
namespace Platform {

class Trailers : public Headers {
public:
  Trailers(const RawHeaderMap& headers) : Headers(headers) {}
};

} // namespace Platform
} // namespace Envoy
#include "engine.h"

#include "library/common/data/utility.h"
#include "library/common/engine.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Platform {

Engine::Engine(::Envoy::Engine* engine) : engine_(engine), terminated_(false) {}

Engine::~Engine() {
  if (!terminated_) {
    terminate();
  }
}

// we lazily construct the stream and pulse clients
// because they either require or will require a weak ptr
// which can't be provided from inside of the constructor
// because of how std::enable_shared_from_this works
StreamClientSharedPtr Engine::streamClient() {
  return std::make_shared<StreamClient>(shared_from_this());
}

std::string Engine::dumpStats() {
  envoy_data data;
  if (engine_->dumpStats(&data) == ENVOY_FAILURE) {
    return "";
  }
  const std::string to_return = Data::Utility::copyToString(data);
  release_envoy_data(data);

  return to_return;
}

envoy_status_t Engine::terminate() {
  if (terminated_) {
    IS_ENVOY_BUG("attempted to double terminate engine");
    return ENVOY_FAILURE;
  }
  envoy_status_t ret = engine_->terminate();
  terminated_ = true;
  return ret;
}

} // namespace Platform
} // namespace Envoy
#pragma once

#include "library/cc/headers.h"
#include "library/cc/response_headers_builder.h"

namespace Envoy {
namespace Platform {

class ResponseHeadersBuilder;

class ResponseHeaders : public Headers {
public:
  int httpStatus() const;

  ResponseHeadersBuilder toResponseHeadersBuilder();

private:
  ResponseHeaders(RawHeaderMap headers) : Headers(std::move(headers)) {}

  friend class ResponseHeadersBuilder;
};

using ResponseHeadersSharedPtr = std::shared_ptr<ResponseHeaders>;

} // namespace Platform
} // namespace Envoy
#include "request_trailers.h"

namespace Envoy {
namespace Platform {

RequestTrailersBuilder RequestTrailers::toRequestTrailersBuilder() const {
  RequestTrailersBuilder builder;
  for (const auto& pair : allHeaders()) {
    builder.set(pair.first, pair.second);
  }
  return builder;
}

} // namespace Platform
} // namespace Envoy
#include "library/cc/request_trailers_builder.h"

namespace Envoy {
namespace Platform {

RequestTrailers RequestTrailersBuilder::build() const { return RequestTrailers(allHeaders()); }

} // namespace Platform
} // namespace Envoy
#pragma once

#include <string>
#include <vector>

#include "library/cc/headers.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Platform {

envoy_headers rawHeaderMapAsEnvoyHeaders(const RawHeaderMap& headers);
RawHeaderMap envoyHeadersAsRawHeaderMap(envoy_headers raw_headers);

} // namespace Platform
} // namespace Envoy
#include "library/cc/retry_policy.h"

namespace Envoy {
namespace Platform {

RawHeaderMap RetryPolicy::asRawHeaderMap() const {
  RawHeaderMap outbound_headers{
      {"x-envoy-max-retries", {std::to_string(max_retry_count)}},
      {"x-envoy-upstream-rq-timeout-ms", {std::to_string(total_upstream_timeout_ms.value_or(0))}},
  };

  if (per_try_timeout_ms.has_value()) {
    outbound_headers["x-envoy-upstream-rq-per-try-timeout-ms"] =
        std::vector<std::string>{std::to_string(per_try_timeout_ms.value())};
  }

  std::vector<std::string> retry_on_copy;
  retry_on_copy.reserve(retry_on.size());
  for (const auto& retry_rule : retry_on) {
    retry_on_copy.push_back(retry_rule);
  }

  if (!retry_status_codes.empty()) {
    retry_on_copy.push_back("retriable-status-codes");
    std::vector<std::string> retry_status_codes_copy;
    retry_status_codes_copy.reserve(retry_status_codes.size());
    for (const auto& status_code : retry_status_codes) {
      retry_status_codes_copy.push_back(std::to_string(status_code));
    }
    outbound_headers["x-envoy-retriable-status-codes"] = retry_status_codes_copy;
  }

  if (!retry_on.empty()) {
    outbound_headers["x-envoy-retry-on"] = retry_on_copy;
  }

  return outbound_headers;
}

RetryPolicy RetryPolicy::fromRawHeaderMap(const RawHeaderMap& headers) {
  RetryPolicy retry_policy;

  if (headers.contains("x-envoy-max-retries")) {
    retry_policy.max_retry_count = std::stoi(headers.at("x-envoy-max-retries")[0]);
  }

  if (headers.contains("x-envoy-upstream-rq-timeout-ms")) {
    retry_policy.total_upstream_timeout_ms =
        std::stoi(headers.at("x-envoy-upstream-rq-timeout-ms")[0]);
  }

  if (headers.contains("x-envoy-upstream-rq-per-try-timeout-ms")) {
    retry_policy.per_try_timeout_ms =
        std::stoi(headers.at("x-envoy-upstream-rq-per-try-timeout-ms")[0]);
  }

  bool has_retriable_status_codes = false;
  if (headers.contains("x-envoy-retry-on")) {
    for (const auto& retry_rule_str : headers.at("x-envoy-retry-on")) {
      if (retry_rule_str == "retriable-status_codes") {
        has_retriable_status_codes = true;
        continue;
      }
      retry_policy.retry_on.push_back(retry_rule_str);
    }
  }

  if (has_retriable_status_codes && headers.contains("x-envoy-retriable-status-codes")) {
    for (const auto& status_code_str : headers.at("x-envoy-retriable-status-codes")) {
      retry_policy.retry_status_codes.push_back(std::stoi(status_code_str));
    }
  }

  return retry_policy;
}

} // namespace Platform
} // namespace Envoy
#include "stream_callbacks.h"

#include "library/cc/bridge_utility.h"
#include "library/cc/response_headers_builder.h"
#include "library/cc/response_trailers_builder.h"
#include "library/common/data/utility.h"

namespace Envoy {
namespace Platform {

namespace {

void* c_on_headers(envoy_headers headers, bool end_stream, envoy_stream_intel intel,
                   void* context) {
  auto stream_callbacks = *static_cast<StreamCallbacksSharedPtr*>(context);
  if (stream_callbacks->on_headers.has_value()) {
    auto raw_headers = envoyHeadersAsRawHeaderMap(headers);
    ResponseHeadersBuilder builder;
    for (const auto& pair : raw_headers) {
      if (pair.first == ":status") {
        builder.addHttpStatus(std::stoi(pair.second[0]));
      }
      builder.set(pair.first, pair.second);
    }
    auto on_headers = stream_callbacks->on_headers.value();
    on_headers(builder.build(), end_stream, intel);
  } else {
    release_envoy_headers(headers);
  }
  return context;
}

void* c_on_data(envoy_data data, bool end_stream, envoy_stream_intel, void* context) {
  auto stream_callbacks = *static_cast<StreamCallbacksSharedPtr*>(context);
  if (stream_callbacks->on_data.has_value()) {
    auto on_data = stream_callbacks->on_data.value();
    on_data(data, end_stream);
  } else {
    release_envoy_data(data);
  }
  return context;
}

void* c_on_trailers(envoy_headers metadata, envoy_stream_intel intel, void* context) {
  auto stream_callbacks = *static_cast<StreamCallbacksSharedPtr*>(context);
  if (stream_callbacks->on_trailers.has_value()) {
    auto raw_headers = envoyHeadersAsRawHeaderMap(metadata);
    ResponseTrailersBuilder builder;
    for (const auto& pair : raw_headers) {
      builder.set(pair.first, pair.second);
    }
    auto on_trailers = stream_callbacks->on_trailers.value();
    on_trailers(builder.build(), intel);
  } else {
    release_envoy_headers(metadata);
  }
  return context;
}

void* c_on_error(envoy_error raw_error, envoy_stream_intel intel,
                 envoy_final_stream_intel final_intel, void* context) {
  auto stream_callbacks_ptr = static_cast<StreamCallbacksSharedPtr*>(context);
  auto stream_callbacks = *stream_callbacks_ptr;
  if (stream_callbacks->on_error.has_value()) {
    EnvoyErrorSharedPtr error = std::make_shared<EnvoyError>();
    error->error_code = raw_error.error_code;
    error->message = Data::Utility::copyToString(raw_error.message);
    error->attempt_count = absl::optional<int>(raw_error.attempt_count);
    auto on_error = stream_callbacks->on_error.value();
    on_error(error, intel, final_intel);
  }
  release_envoy_error(raw_error);
  delete stream_callbacks_ptr;
  return nullptr;
}

void* c_on_complete(envoy_stream_intel intel, envoy_final_stream_intel final_intel, void* context) {
  auto stream_callbacks_ptr = static_cast<StreamCallbacksSharedPtr*>(context);
  auto stream_callbacks = *stream_callbacks_ptr;
  if (stream_callbacks->on_complete.has_value()) {
    auto on_complete = stream_callbacks->on_complete.value();
    on_complete(intel, final_intel);
  }
  delete stream_callbacks_ptr;
  return nullptr;
}

void* c_on_cancel(envoy_stream_intel intel, envoy_final_stream_intel final_intel, void* context) {
  auto stream_callbacks_ptr = static_cast<StreamCallbacksSharedPtr*>(context);
  auto stream_callbacks = *stream_callbacks_ptr;
  if (stream_callbacks->on_cancel.has_value()) {
    auto on_cancel = stream_callbacks->on_cancel.value();
    on_cancel(intel, final_intel);
  }
  delete stream_callbacks_ptr;
  return nullptr;
}

void* c_on_send_window_available(envoy_stream_intel intel, void* context) {
  auto stream_callbacks_ptr = static_cast<StreamCallbacksSharedPtr*>(context);
  auto stream_callbacks = *stream_callbacks_ptr;
  if (stream_callbacks->on_send_window_available.has_value()) {
    auto on_send_window_available = stream_callbacks->on_send_window_available.value();
    on_send_window_available(intel);
  }
  return nullptr;
}

} // namespace

envoy_http_callbacks StreamCallbacks::asEnvoyHttpCallbacks() {
  return envoy_http_callbacks{
      &c_on_headers,
      &c_on_data,
      nullptr,
      &c_on_trailers,
      &c_on_error,
      &c_on_complete,
      &c_on_cancel,
      &c_on_send_window_available,
      new StreamCallbacksSharedPtr(shared_from_this()),
  };
}

} // namespace Platform
} // namespace Envoy
#pragma once

#include "headers.h"

namespace Envoy {
namespace Platform {

class HeadersBuilder {
public:
  virtual ~HeadersBuilder() {}

  HeadersBuilder& add(std::string name, std::string value);
  HeadersBuilder& set(std::string name, std::vector<std::string> values);
  HeadersBuilder& remove(absl::string_view name);

protected:
  HeadersBuilder();
  HeadersBuilder& internalSet(std::string name, std::vector<std::string> values);
  const RawHeaderMap& allHeaders() const;

private:
  bool isRestrictedHeader(absl::string_view name) const;

  RawHeaderMap headers_;
};

} // namespace Platform
} // namespace Envoy
#pragma once

#include <vector>

#include "library/cc/request_headers.h"
#include "library/cc/request_trailers.h"
#include "library/cc/stream_callbacks.h"
#include "library/common/types/c_types.h"

namespace Envoy {
class Engine;
namespace Platform {

class Stream {
public:
  Stream(Envoy::Engine* engine, envoy_stream_t handle);

  Stream& sendHeaders(RequestHeadersSharedPtr headers, bool end_stream);
  Stream& sendData(envoy_data data);
  Stream& readData(size_t bytes_to_read);
  void close(RequestTrailersSharedPtr trailers);
  void close(envoy_data data);
  void cancel();

private:
  Envoy::Engine* engine_;
  envoy_stream_t handle_;
};

using StreamSharedPtr = std::shared_ptr<Stream>;

} // namespace Platform
} // namespace Envoy
#pragma once

#include "library/cc/response_trailers_builder.h"
#include "library/cc/trailers.h"

namespace Envoy {
namespace Platform {

class ResponseTrailersBuilder;

class ResponseTrailers : public Trailers {
public:
  ResponseTrailersBuilder toResponseTrailersBuilder();

private:
  ResponseTrailers(RawHeaderMap trailers) : Trailers(std::move(trailers)) {}

  friend class ResponseTrailersBuilder;
};

using ResponseTrailersSharedPtr = std::shared_ptr<ResponseTrailers>;

} // namespace Platform
} // namespace Envoy
#pragma once

#include <memory>

#include "envoy/common/pure.h"

#include "absl/types/optional.h"
#include "library/common/extensions/key_value/platform/c_types.h"

namespace Envoy {
namespace Platform {

/**
 * `KeyValueStore` is an interface that may be implemented to provide access to an arbitrary
 * key-value store implementation that may be made accessible to internal Envoy Mobile code.
 */
struct KeyValueStore : public std::enable_shared_from_this<KeyValueStore> {
public:
  virtual ~KeyValueStore() = default;

  /**
   * Returns the value associated with the provided key, if any.
   * @param key supplies a key to return the value of.
   * @return the value, if the key is in the store, absl::nullopt otherwise.
   */
  virtual absl::optional<std::string> read(const std::string& key) PURE;

  /**
   * Adds or updates a key:value pair in the store.
   * @param key supplies a key to add or update.
   * @param value supplies the value to set for that key.
   */
  virtual void save(std::string key, std::string value) PURE;

  /**
   * Removes a key:value pair from the store. This is a no-op if the key is not present.
   * @param key supplies a key to remove from the store.
   */
  virtual void remove(const std::string& key) PURE;

  /**
   * Maps an implementation to its internal representation.
   * @return portable internal type used to call an implementation.
   */
  virtual envoy_kv_store asEnvoyKeyValueStore() final;
};

using KeyValueStoreSharedPtr = std::shared_ptr<KeyValueStore>;

} // namespace Platform
} // namespace Envoy
#pragma once

#include <string>
#include <vector>

#include "absl/container/flat_hash_map.h"

namespace Envoy {
namespace Platform {

using RawHeaderMap = absl::flat_hash_map<std::string, std::vector<std::string>>;

class Headers {
public:
  class const_iterator {
  public:
    const_iterator(RawHeaderMap::const_iterator position) : position_(position){};

    using iterator_category = RawHeaderMap::const_iterator::iterator_category;
    using value_type = std::string;
    using reference = const value_type&;
    using pointer = const value_type*;
    using difference_type = std::ptrdiff_t;

    reference operator*() const { return position_->first; }
    pointer operator->() { return &position_->first; }

    const_iterator& operator++() {
      position_++;
      return *this;
    }
    const_iterator operator++(int) {
      auto tmp = *this;
      ++(*this);
      return tmp;
    }

    friend bool operator==(const const_iterator& a, const const_iterator& b) {
      return a.position_ == b.position_;
    }
    friend bool operator!=(const const_iterator& a, const const_iterator& b) {
      return a.position_ != b.position_;
    }

  private:
    RawHeaderMap::const_iterator position_;
  };

  virtual ~Headers() {}

  const_iterator begin() const;
  const_iterator end() const;

  const std::vector<std::string>& operator[](absl::string_view key) const;
  const RawHeaderMap& allHeaders() const;
  bool contains(const std::string& key) const;

protected:
  Headers(const RawHeaderMap& headers);

private:
  RawHeaderMap headers_;
};

} // namespace Platform
} // namespace Envoy
#include "library/cc/engine_callbacks.h"

namespace Envoy {
namespace Platform {

namespace {

void c_on_engine_running(void* context) {
  auto engine_callbacks = *static_cast<EngineCallbacksSharedPtr*>(context);
  std::function<void()> on_engine_running_cb = std::move(engine_callbacks->on_engine_running);
  engine_callbacks->on_engine_running = {};
  on_engine_running_cb();
}

void c_on_exit(void* context) {
  auto engine_callbacks_ptr = static_cast<EngineCallbacksSharedPtr*>(context);
  delete engine_callbacks_ptr;
}

} // namespace

envoy_engine_callbacks EngineCallbacks::asEnvoyEngineCallbacks() {
  return envoy_engine_callbacks{
      &c_on_engine_running,
      &c_on_exit,
      new EngineCallbacksSharedPtr(shared_from_this()),
  };
}

} // namespace Platform
} // namespace Envoy
#include "library/cc/response_headers_builder.h"

namespace Envoy {
namespace Platform {

ResponseHeadersBuilder& ResponseHeadersBuilder::addHttpStatus(int status) {
  internalSet(":status", std::vector<std::string>{std::to_string(status)});
  return *this;
}

ResponseHeadersSharedPtr ResponseHeadersBuilder::build() const {
  ResponseHeaders* headers = new ResponseHeaders(allHeaders());
  return ResponseHeadersSharedPtr(headers);
}

} // namespace Platform
} // namespace Envoy
#pragma once

#include <optional>
#include <vector>

#include "absl/types/optional.h"
#include "library/cc/headers.h"
#include "library/cc/request_headers.h"

namespace Envoy {
namespace Platform {

class RequestHeaders;

struct RetryPolicy {
  int max_retry_count;
  std::vector<std::string> retry_on;
  std::vector<int> retry_status_codes;
  absl::optional<int> per_try_timeout_ms;
  absl::optional<int> total_upstream_timeout_ms;

  RawHeaderMap asRawHeaderMap() const;
  static RetryPolicy fromRawHeaderMap(const RawHeaderMap& headers);
};

using RetryPolicySharedPtr = std::shared_ptr<RetryPolicy>;

} // namespace Platform
} // namespace Envoy
#include "bridge_utility.h"

#include <sstream>

#include "library/common/data/utility.h"

namespace Envoy {
namespace Platform {

envoy_headers rawHeaderMapAsEnvoyHeaders(const RawHeaderMap& headers) {
  size_t header_count = 0;
  for (const auto& pair : headers) {
    header_count += pair.second.size();
  }

  envoy_map_entry* headers_list =
      static_cast<envoy_map_entry*>(safe_malloc(sizeof(envoy_map_entry) * header_count));

  size_t i = 0;
  for (const auto& pair : headers) {
    const auto& key = pair.first;
    for (const auto& value : pair.second) {
      envoy_map_entry& header = headers_list[i++];
      header.key = Data::Utility::copyToBridgeData(key);
      header.value = Data::Utility::copyToBridgeData(value);
    }
  }

  envoy_headers raw_headers{
      static_cast<envoy_map_size_t>(header_count),
      headers_list,
  };
  return raw_headers;
}

RawHeaderMap envoyHeadersAsRawHeaderMap(envoy_headers raw_headers) {
  RawHeaderMap headers;
  for (auto i = 0; i < raw_headers.length; i++) {
    auto key = Data::Utility::copyToString(raw_headers.entries[i].key);
    auto value = Data::Utility::copyToString(raw_headers.entries[i].value);

    if (!headers.contains(key)) {
      headers.emplace(key, std::vector<std::string>());
    }
    headers[key].push_back(value);
  }
  // free instead of release_envoy_headers
  // because we already free each envoy_data individually
  // during calls to envoy_data_as_string
  release_envoy_headers(raw_headers);
  return headers;
}

} // namespace Platform
} // namespace Envoy
#include "library/cc/headers_builder.h"

namespace Envoy {
namespace Platform {

HeadersBuilder& HeadersBuilder::add(std::string name, std::string value) {
  if (isRestrictedHeader(name)) {
    return *this;
  }
  headers_[std::move(name)].push_back(std::move(value));
  return *this;
}

HeadersBuilder& HeadersBuilder::set(std::string name, std::vector<std::string> values) {
  if (isRestrictedHeader(name)) {
    return *this;
  }
  headers_[std::move(name)] = std::move(values);
  return *this;
}

HeadersBuilder& HeadersBuilder::remove(absl::string_view name) {
  if (isRestrictedHeader(name)) {
    return *this;
  }
  headers_.erase(name);
  return *this;
}

HeadersBuilder::HeadersBuilder() {}

HeadersBuilder& HeadersBuilder::internalSet(std::string name, std::vector<std::string> values) {
  headers_[std::move(name)] = std::move(values);
  return *this;
}

const RawHeaderMap& HeadersBuilder::allHeaders() const { return headers_; }

bool HeadersBuilder::isRestrictedHeader(absl::string_view name) const {
  return name.find(':') == 0 || name.find("x-envoy-mobile") == 0;
}

} // namespace Platform
} // namespace Envoy
#pragma once

#include <string>

#include "source/common/common/base_logger.h"

namespace Envoy {
namespace Platform {

enum class LogLevel {
  trace = Envoy::Logger::Logger::Levels::trace,
  debug = Envoy::Logger::Logger::Levels::debug,
  info = Envoy::Logger::Logger::Levels::info,
  warn = Envoy::Logger::Logger::Levels::warn,
  error = Envoy::Logger::Logger::Levels::error,
  critical = Envoy::Logger::Logger::Levels::critical,
  off = Envoy::Logger::Logger::Levels::off,
};

std::string logLevelToString(LogLevel method);
LogLevel logLevelFromString(const std::string& str);

} // namespace Platform
} // namespace Envoy
#pragma once

#include "library/cc/request_trailers_builder.h"
#include "library/cc/trailers.h"

namespace Envoy {
namespace Platform {

class RequestTrailersBuilder;

class RequestTrailers : public Trailers {
public:
  RequestTrailersBuilder toRequestTrailersBuilder() const;

private:
  RequestTrailers(RawHeaderMap headers) : Trailers(std::move(headers)) {}

  friend class RequestTrailersBuilder;
};

using RequestTrailersSharedPtr = std::shared_ptr<RequestTrailers>;

} // namespace Platform
} // namespace Envoy
#include "request_headers_builder.h"

#include "source/common/http/utility.h"

namespace Envoy {
namespace Platform {

RequestHeadersBuilder::RequestHeadersBuilder(RequestMethod request_method, std::string scheme,
                                             std::string authority, std::string path) {
  initialize(request_method, std::move(scheme), std::move(authority), std::move(path));
}

RequestHeadersBuilder::RequestHeadersBuilder(RequestMethod request_method, absl::string_view url) {
  Envoy::Http::Utility::Url parsed_url;
  if (!parsed_url.initialize(url, /*is_connect_request=*/false)) {
    initialize(request_method, "", "", "");
    return;
  }
  initialize(request_method, std::string(parsed_url.scheme()),
             std::string(parsed_url.hostAndPort()), std::string(parsed_url.pathAndQueryParams()));
}

void RequestHeadersBuilder::initialize(RequestMethod request_method, std::string scheme,
                                       std::string authority, std::string path) {
  internalSet(":method", {std::string(requestMethodToString(request_method))});
  internalSet(":scheme", {std::move(scheme)});
  internalSet(":authority", {std::move(authority)});
  internalSet(":path", {std::move(path)});
}

RequestHeadersBuilder& RequestHeadersBuilder::addRetryPolicy(const RetryPolicy& retry_policy) {
  const RawHeaderMap retry_policy_headers = retry_policy.asRawHeaderMap();
  for (const auto& pair : retry_policy_headers) {
    internalSet(pair.first, pair.second);
  }
  return *this;
}

RequestHeaders RequestHeadersBuilder::build() const { return RequestHeaders(allHeaders()); }

} // namespace Platform
} // namespace Envoy
#include "engine_builder.h"

#include "envoy/config/metrics/v3/metrics_service.pb.h"
#include "envoy/extensions/compression/brotli/decompressor/v3/brotli.pb.h"
#include "envoy/extensions/compression/gzip/decompressor/v3/gzip.pb.h"
#include "envoy/extensions/filters/http/alternate_protocols_cache/v3/alternate_protocols_cache.pb.h"
#include "envoy/extensions/filters/http/decompressor/v3/decompressor.pb.h"
#include "envoy/extensions/filters/http/dynamic_forward_proxy/v3/dynamic_forward_proxy.pb.h"
#include "envoy/extensions/http/header_formatters/preserve_case/v3/preserve_case.pb.h"

#if defined(__APPLE__)
#include "envoy/extensions/network/dns_resolver/apple/v3/apple_dns_resolver.pb.h"
#endif

#include "envoy/extensions/network/dns_resolver/getaddrinfo/v3/getaddrinfo_dns_resolver.pb.h"
#include "envoy/extensions/transport_sockets/http_11_proxy/v3/upstream_http_11_connect.pb.h"
#include "envoy/extensions/transport_sockets/quic/v3/quic_transport.pb.h"
#include "envoy/extensions/transport_sockets/raw_buffer/v3/raw_buffer.pb.h"

#include "source/common/http/matching/inputs.h"
#include "envoy/config/core/v3/base.pb.h"
#include "source/extensions/clusters/dynamic_forward_proxy/cluster.h"

#include "absl/strings/str_join.h"
#include "absl/strings/str_replace.h"
#include "fmt/core.h"
#include "library/common/engine.h"
#include "library/common/extensions/cert_validator/platform_bridge/platform_bridge.pb.h"
#include "library/common/extensions/filters/http/local_error/filter.pb.h"
#include "library/common/extensions/filters/http/network_configuration/filter.pb.h"
#include "library/common/extensions/filters/http/socket_tag/filter.pb.h"
#include "library/common/extensions/key_value/platform/platform.pb.h"

namespace Envoy {
namespace Platform {

#ifdef ENVOY_MOBILE_XDS
XdsBuilder::XdsBuilder(std::string xds_server_address, const uint32_t xds_server_port)
    : xds_server_address_(std::move(xds_server_address)), xds_server_port_(xds_server_port) {}

XdsBuilder& XdsBuilder::addInitialStreamHeader(std::string header, std::string value) {
  envoy::config::core::v3::HeaderValue header_value;
  header_value.set_key(std::move(header));
  header_value.set_value(std::move(value));
  xds_initial_grpc_metadata_.emplace_back(std::move(header_value));
  return *this;
}

XdsBuilder& XdsBuilder::setSslRootCerts(std::string root_certs) {
  ssl_root_certs_ = std::move(root_certs);
  return *this;
}

XdsBuilder& XdsBuilder::addRuntimeDiscoveryService(std::string resource_name,
                                                   const int timeout_in_seconds) {
  rtds_resource_name_ = std::move(resource_name);
  rtds_timeout_in_seconds_ = timeout_in_seconds > 0 ? timeout_in_seconds : DefaultXdsTimeout;
  return *this;
}

XdsBuilder& XdsBuilder::addClusterDiscoveryService(std::string cds_resources_locator,
                                                   const int timeout_in_seconds) {
  enable_cds_ = true;
  cds_resources_locator_ = std::move(cds_resources_locator);
  cds_timeout_in_seconds_ = timeout_in_seconds > 0 ? timeout_in_seconds : DefaultXdsTimeout;
  return *this;
}

void XdsBuilder::build(envoy::config::bootstrap::v3::Bootstrap& bootstrap) const {
  auto* ads_config = bootstrap.mutable_dynamic_resources()->mutable_ads_config();
  ads_config->set_transport_api_version(envoy::config::core::v3::ApiVersion::V3);
  ads_config->set_set_node_on_first_message_only(true);
  ads_config->set_api_type(envoy::config::core::v3::ApiConfigSource::GRPC);

  auto& grpc_service = *ads_config->add_grpc_services();
  grpc_service.mutable_envoy_grpc()->set_cluster_name("base");
  grpc_service.mutable_envoy_grpc()->set_authority(
      absl::StrCat(xds_server_address_, ":", xds_server_port_));

  if (!xds_initial_grpc_metadata_.empty()) {
    grpc_service.mutable_initial_metadata()->Assign(xds_initial_grpc_metadata_.begin(),
                                                    xds_initial_grpc_metadata_.end());
  }

  if (!rtds_resource_name_.empty()) {
    auto* layered_runtime = bootstrap.mutable_layered_runtime();
    auto* layer = layered_runtime->add_layers();
    layer->set_name("rtds_layer");
    auto* rtds_layer = layer->mutable_rtds_layer();
    rtds_layer->set_name(rtds_resource_name_);
    auto* rtds_config = rtds_layer->mutable_rtds_config();
    rtds_config->mutable_ads();
    rtds_config->set_resource_api_version(envoy::config::core::v3::ApiVersion::V3);
    rtds_config->mutable_initial_fetch_timeout()->set_seconds(rtds_timeout_in_seconds_);
  }

  if (enable_cds_) {
    auto* cds_config = bootstrap.mutable_dynamic_resources()->mutable_cds_config();
    if (cds_resources_locator_.empty()) {
      cds_config->mutable_ads();
    } else {
      bootstrap.mutable_dynamic_resources()->set_cds_resources_locator(cds_resources_locator_);
      cds_config->mutable_api_config_source()->set_api_type(
          envoy::config::core::v3::ApiConfigSource::AGGREGATED_GRPC);
      cds_config->mutable_api_config_source()->set_transport_api_version(
          envoy::config::core::v3::ApiVersion::V3);
    }
    cds_config->mutable_initial_fetch_timeout()->set_seconds(cds_timeout_in_seconds_);
    cds_config->set_resource_api_version(envoy::config::core::v3::ApiVersion::V3);
    bootstrap.add_node_context_params("cluster");
    // Stat prefixes that we use in tests.
    auto* list =
        bootstrap.mutable_stats_config()->mutable_stats_matcher()->mutable_inclusion_list();
    list->add_patterns()->set_exact("cluster_manager.active_clusters");
    list->add_patterns()->set_exact("cluster_manager.cluster_added");
    list->add_patterns()->set_exact("cluster_manager.cluster_updated");
    list->add_patterns()->set_exact("cluster_manager.cluster_removed");
    // Allow SDS related stats.
    list->add_patterns()->mutable_safe_regex()->set_regex("sds\\..*");
    list->add_patterns()->mutable_safe_regex()->set_regex(".*\\.ssl_context_update_by_sds");
  }
}
#endif

EngineBuilder::EngineBuilder() : callbacks_(std::make_shared<EngineCallbacks>()) {
#ifndef ENVOY_ENABLE_QUIC
  enable_http3_ = false;
#endif
}

EngineBuilder& EngineBuilder::addLogLevel(LogLevel log_level) {
  log_level_ = log_level;
  return *this;
}

EngineBuilder& EngineBuilder::setOnEngineRunning(std::function<void()> closure) {
  callbacks_->on_engine_running = std::move(closure);
  return *this;
}

EngineBuilder& EngineBuilder::addConnectTimeoutSeconds(int connect_timeout_seconds) {
  connect_timeout_seconds_ = connect_timeout_seconds;
  return *this;
}

EngineBuilder& EngineBuilder::addDnsRefreshSeconds(int dns_refresh_seconds) {
  dns_refresh_seconds_ = dns_refresh_seconds;
  return *this;
}

EngineBuilder& EngineBuilder::addDnsMinRefreshSeconds(int dns_min_refresh_seconds) {
  dns_min_refresh_seconds_ = dns_min_refresh_seconds;
  return *this;
}

EngineBuilder& EngineBuilder::addDnsFailureRefreshSeconds(int base, int max) {
  dns_failure_refresh_seconds_base_ = base;
  dns_failure_refresh_seconds_max_ = max;
  return *this;
}

EngineBuilder& EngineBuilder::addDnsQueryTimeoutSeconds(int dns_query_timeout_seconds) {
  dns_query_timeout_seconds_ = dns_query_timeout_seconds;
  return *this;
}

EngineBuilder& EngineBuilder::addDnsPreresolveHostnames(const std::vector<std::string>& hostnames) {
  // Add a default port of 443 for all hosts. We'll eventually change this API so it takes a single
  // {host, pair} and it can be called multiple times.
  dns_preresolve_hostnames_.clear();
  for (const std::string& hostname : hostnames) {
    dns_preresolve_hostnames_.push_back({hostname /* host */, 443 /* port */});
  }
  return *this;
}

EngineBuilder& EngineBuilder::addMaxConnectionsPerHost(int max_connections_per_host) {
  max_connections_per_host_ = max_connections_per_host;
  return *this;
}

EngineBuilder& EngineBuilder::useDnsSystemResolver(bool use_system_resolver) {
  use_system_resolver_ = use_system_resolver;
  return *this;
}

EngineBuilder& EngineBuilder::addH2ConnectionKeepaliveIdleIntervalMilliseconds(
    int h2_connection_keepalive_idle_interval_milliseconds) {
  h2_connection_keepalive_idle_interval_milliseconds_ =
      h2_connection_keepalive_idle_interval_milliseconds;
  return *this;
}

EngineBuilder&
EngineBuilder::addH2ConnectionKeepaliveTimeoutSeconds(int h2_connection_keepalive_timeout_seconds) {
  h2_connection_keepalive_timeout_seconds_ = h2_connection_keepalive_timeout_seconds;
  return *this;
}

EngineBuilder& EngineBuilder::addKeyValueStore(std::string name,
                                               KeyValueStoreSharedPtr key_value_store) {
  key_value_stores_[std::move(name)] = std::move(key_value_store);
  return *this;
}

EngineBuilder& EngineBuilder::setAppVersion(std::string app_version) {
  app_version_ = std::move(app_version);
  return *this;
}

EngineBuilder& EngineBuilder::setAppId(std::string app_id) {
  app_id_ = std::move(app_id);
  return *this;
}

EngineBuilder& EngineBuilder::setDeviceOs(std::string device_os) {
  device_os_ = std::move(device_os);
  return *this;
}

EngineBuilder& EngineBuilder::setStreamIdleTimeoutSeconds(int stream_idle_timeout_seconds) {
  stream_idle_timeout_seconds_ = stream_idle_timeout_seconds;
  return *this;
}

EngineBuilder& EngineBuilder::setPerTryIdleTimeoutSeconds(int per_try_idle_timeout_seconds) {
  per_try_idle_timeout_seconds_ = per_try_idle_timeout_seconds;
  return *this;
}

EngineBuilder& EngineBuilder::enableGzipDecompression(bool gzip_decompression_on) {
  gzip_decompression_filter_ = gzip_decompression_on;
  return *this;
}

EngineBuilder& EngineBuilder::enableBrotliDecompression(bool brotli_decompression_on) {
  brotli_decompression_filter_ = brotli_decompression_on;
  return *this;
}

EngineBuilder& EngineBuilder::enableSocketTagging(bool socket_tagging_on) {
  socket_tagging_filter_ = socket_tagging_on;
  return *this;
}

#ifdef ENVOY_ENABLE_QUIC
EngineBuilder& EngineBuilder::enableHttp3(bool http3_on) {
  enable_http3_ = http3_on;
  return *this;
}

EngineBuilder& EngineBuilder::setHttp3ConnectionOptions(std::string options) {
  http3_connection_options_ = std::move(options);
  return *this;
}

EngineBuilder& EngineBuilder::setHttp3ClientConnectionOptions(std::string options) {
  http3_client_connection_options_ = std::move(options);
  return *this;
}

EngineBuilder& EngineBuilder::addQuicHint(std::string host, int port) {
  quic_hints_.emplace_back(std::move(host), port);
  return *this;
}

EngineBuilder& EngineBuilder::addQuicCanonicalSuffix(std::string suffix) {
  quic_suffixes_.emplace_back(std::move(suffix));
  return *this;
}

#endif

EngineBuilder& EngineBuilder::setForceAlwaysUsev6(bool value) {
  always_use_v6_ = value;
  return *this;
}

EngineBuilder& EngineBuilder::enableInterfaceBinding(bool interface_binding_on) {
  enable_interface_binding_ = interface_binding_on;
  return *this;
}

EngineBuilder& EngineBuilder::enableDrainPostDnsRefresh(bool drain_post_dns_refresh_on) {
  enable_drain_post_dns_refresh_ = drain_post_dns_refresh_on;
  return *this;
}

EngineBuilder& EngineBuilder::enforceTrustChainVerification(bool trust_chain_verification_on) {
  enforce_trust_chain_verification_ = trust_chain_verification_on;
  return *this;
}

EngineBuilder& EngineBuilder::setNodeId(std::string node_id) {
  node_id_ = std::move(node_id);
  return *this;
}

EngineBuilder& EngineBuilder::setNodeLocality(std::string region, std::string zone,
                                              std::string sub_zone) {
  node_locality_ = {std::move(region), std::move(zone), std::move(sub_zone)};
  return *this;
}

EngineBuilder& EngineBuilder::setNodeMetadata(ProtobufWkt::Struct node_metadata) {
  node_metadata_ = std::move(node_metadata);
  return *this;
}

#ifdef ENVOY_MOBILE_XDS
EngineBuilder& EngineBuilder::setXds(XdsBuilder xds_builder) {
  xds_builder_ = std::move(xds_builder);
  // Add the XdsBuilder's xDS server hostname and port to the list of DNS addresses to preresolve in
  // the `base` DFP cluster.
  dns_preresolve_hostnames_.push_back(
      {xds_builder_->xds_server_address_ /* host */, xds_builder_->xds_server_port_ /* port */});
  return *this;
}
#endif

EngineBuilder&
EngineBuilder::enablePlatformCertificatesValidation(bool platform_certificates_validation_on) {
  platform_certificates_validation_on_ = platform_certificates_validation_on;
  return *this;
}

EngineBuilder& EngineBuilder::enableDnsCache(bool dns_cache_on, int save_interval_seconds) {
  dns_cache_on_ = dns_cache_on;
  dns_cache_save_interval_seconds_ = save_interval_seconds;
  return *this;
}

EngineBuilder& EngineBuilder::addStringAccessor(std::string name,
                                                StringAccessorSharedPtr accessor) {
  string_accessors_[std::move(name)] = std::move(accessor);
  return *this;
}

EngineBuilder& EngineBuilder::addNativeFilter(std::string name, std::string typed_config) {
  native_filter_chain_.emplace_back(std::move(name), std::move(typed_config));
  return *this;
}

EngineBuilder& EngineBuilder::addPlatformFilter(const std::string& name) {
  addNativeFilter(
      "envoy.filters.http.platform_bridge",
      absl::StrCat(
          "{'@type': "
          "type.googleapis.com/envoymobile.extensions.filters.http.platform_bridge.PlatformBridge, "
          "platform_filter_name: ",
          name, "}"));
  return *this;
}

EngineBuilder& EngineBuilder::setRuntimeGuard(std::string guard, bool value) {
  runtime_guards_.emplace_back(std::move(guard), value);
  return *this;
}

std::unique_ptr<envoy::config::bootstrap::v3::Bootstrap> EngineBuilder::generateBootstrap() const {
  // The yaml utilities have non-relevant thread asserts.
  Thread::SkipAsserts skip;

  std::unique_ptr<envoy::config::bootstrap::v3::Bootstrap> bootstrap =
      std::make_unique<envoy::config::bootstrap::v3::Bootstrap>();

  // Set up the HCM
  envoy::extensions::filters::network::http_connection_manager::v3::EnvoyMobileHttpConnectionManager
      api_listener_config;
  auto* hcm = api_listener_config.mutable_config();
  hcm->set_stat_prefix("hcm");
  hcm->set_server_header_transformation(
      envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
          PASS_THROUGH);
  hcm->mutable_stream_idle_timeout()->set_seconds(stream_idle_timeout_seconds_);
  auto* route_config = hcm->mutable_route_config();
  route_config->set_name("api_router");
  auto* remote_service = route_config->add_virtual_hosts();
  remote_service->set_name("remote_service");
  remote_service->add_domains("127.0.0.1");

  auto* route = remote_service->add_routes();
  route->mutable_match()->set_prefix("/");
  route->mutable_direct_response()->set_status(404);
  route->mutable_direct_response()->mutable_body()->set_inline_string("not found");
  route->add_request_headers_to_remove("x-forwarded-proto");
  route->add_request_headers_to_remove("x-envoy-mobile-cluster");
  auto* api_service = route_config->add_virtual_hosts();
  api_service->set_name("api");
  api_service->set_include_attempt_count_in_response(true);
  api_service->add_domains("*");

  route = api_service->add_routes();
  route->mutable_match()->set_prefix("/");
  route->add_request_headers_to_remove("x-forwarded-proto");
  route->add_request_headers_to_remove("x-envoy-mobile-cluster");
  auto* route_to = route->mutable_route();
  route_to->set_cluster_header("x-envoy-mobile-cluster");
  route_to->mutable_timeout()->set_seconds(0);
  route_to->mutable_retry_policy()->mutable_per_try_idle_timeout()->set_seconds(
      per_try_idle_timeout_seconds_);
  auto* backoff = route_to->mutable_retry_policy()->mutable_retry_back_off();
  backoff->mutable_base_interval()->set_nanos(250000000);
  backoff->mutable_max_interval()->set_seconds(60);

  for (auto filter = native_filter_chain_.rbegin(); filter != native_filter_chain_.rend();
       ++filter) {
#ifdef ENVOY_ENABLE_YAML
    auto* native_filter = hcm->add_http_filters();
    native_filter->set_name((*filter).name_);
    MessageUtil::loadFromYaml((*filter).typed_config_, *native_filter->mutable_typed_config(),
                              ProtobufMessage::getStrictValidationVisitor());
#else
    IS_ENVOY_BUG("native filter chains can not be added when YAML is compiled out.");
#endif
  }

  // Set up the optional filters
  if (enable_http3_) {
#ifdef ENVOY_ENABLE_QUIC
    envoy::extensions::filters::http::alternate_protocols_cache::v3::FilterConfig cache_config;
    cache_config.mutable_alternate_protocols_cache_options()->set_name(
        "default_alternate_protocols_cache");
    for (const auto& [host, port] : quic_hints_) {
      auto* entry =
          cache_config.mutable_alternate_protocols_cache_options()->add_prepopulated_entries();
      entry->set_hostname(host);
      entry->set_port(port);
    }
    for (const auto& suffix : quic_suffixes_) {
      cache_config.mutable_alternate_protocols_cache_options()->add_canonical_suffixes(suffix);
    }
    auto* cache_filter = hcm->add_http_filters();
    cache_filter->set_name("alternate_protocols_cache");
    cache_filter->mutable_typed_config()->PackFrom(cache_config);
#else
    throw std::runtime_error("http3 functionality was not compiled in this build of Envoy Mobile");
#endif
  }

  if (gzip_decompression_filter_) {
    envoy::extensions::compression::gzip::decompressor::v3::Gzip gzip_config;
    gzip_config.mutable_window_bits()->set_value(15);
    envoy::extensions::filters::http::decompressor::v3::Decompressor decompressor_config;
    decompressor_config.mutable_decompressor_library()->set_name("gzip");
    decompressor_config.mutable_decompressor_library()->mutable_typed_config()->PackFrom(
        gzip_config);
    auto* common_request =
        decompressor_config.mutable_request_direction_config()->mutable_common_config();
    common_request->mutable_enabled()->mutable_default_value();
    common_request->mutable_enabled()->set_runtime_key("request_decompressor_enabled");
    decompressor_config.mutable_response_direction_config()
        ->mutable_common_config()
        ->set_ignore_no_transform_header(true);
    auto* gzip_filter = hcm->add_http_filters();
    gzip_filter->set_name("envoy.filters.http.decompressor");
    gzip_filter->mutable_typed_config()->PackFrom(decompressor_config);
  }
  if (brotli_decompression_filter_) {
    envoy::extensions::compression::brotli::decompressor::v3::Brotli brotli_config;
    envoy::extensions::filters::http::decompressor::v3::Decompressor decompressor_config;
    decompressor_config.mutable_decompressor_library()->set_name("text_optimized");
    decompressor_config.mutable_decompressor_library()->mutable_typed_config()->PackFrom(
        brotli_config);
    auto* common_request =
        decompressor_config.mutable_request_direction_config()->mutable_common_config();
    common_request->mutable_enabled()->mutable_default_value();
    common_request->mutable_enabled()->set_runtime_key("request_decompressor_enabled");
    decompressor_config.mutable_response_direction_config()
        ->mutable_common_config()
        ->set_ignore_no_transform_header(true);
    auto* brotli_filter = hcm->add_http_filters();
    brotli_filter->set_name("envoy.filters.http.decompressor");
    brotli_filter->mutable_typed_config()->PackFrom(decompressor_config);
  }
  if (socket_tagging_filter_) {
    envoymobile::extensions::filters::http::socket_tag::SocketTag tag_config;
    auto* tag_filter = hcm->add_http_filters();
    tag_filter->set_name("envoy.filters.http.socket_tag");
    tag_filter->mutable_typed_config()->PackFrom(tag_config);
  }

  // Set up the always-present filters
  envoymobile::extensions::filters::http::network_configuration::NetworkConfiguration
      network_config;
  network_config.set_enable_drain_post_dns_refresh(enable_drain_post_dns_refresh_);
  network_config.set_enable_interface_binding(enable_interface_binding_);
  auto* network_filter = hcm->add_http_filters();
  network_filter->set_name("envoy.filters.http.network_configuration");
  network_filter->mutable_typed_config()->PackFrom(network_config);

  envoymobile::extensions::filters::http::local_error::LocalError local_config;
  auto* local_filter = hcm->add_http_filters();
  local_filter->set_name("envoy.filters.http.local_error");
  local_filter->mutable_typed_config()->PackFrom(local_config);

  envoy::extensions::filters::http::dynamic_forward_proxy::v3::FilterConfig dfp_config;
  auto* dns_cache_config = dfp_config.mutable_dns_cache_config();
  dns_cache_config->set_name("base_dns_cache");
  dns_cache_config->set_dns_lookup_family(envoy::config::cluster::v3::Cluster::ALL);
  dns_cache_config->mutable_host_ttl()->set_seconds(86400);
  dns_cache_config->mutable_dns_min_refresh_rate()->set_seconds(dns_min_refresh_seconds_);
  dns_cache_config->mutable_dns_refresh_rate()->set_seconds(dns_refresh_seconds_);
  dns_cache_config->mutable_dns_failure_refresh_rate()->mutable_base_interval()->set_seconds(
      dns_failure_refresh_seconds_base_);
  dns_cache_config->mutable_dns_failure_refresh_rate()->mutable_max_interval()->set_seconds(
      dns_failure_refresh_seconds_max_);
  dns_cache_config->mutable_dns_query_timeout()->set_seconds(dns_query_timeout_seconds_);
  if (dns_cache_on_) {
    envoymobile::extensions::key_value::platform::PlatformKeyValueStoreConfig kv_config;
    kv_config.set_key("dns_persistent_cache");
    kv_config.mutable_save_interval()->set_seconds(dns_cache_save_interval_seconds_);
    kv_config.set_max_entries(100);
    dns_cache_config->mutable_key_value_config()->mutable_config()->set_name(
        "envoy.key_value.platform");
    dns_cache_config->mutable_key_value_config()
        ->mutable_config()
        ->mutable_typed_config()
        ->PackFrom(kv_config);
  }

#if defined(__APPLE__)
  envoy::extensions::network::dns_resolver::apple::v3::AppleDnsResolverConfig resolver_config;
  dns_cache_config->mutable_typed_dns_resolver_config()->set_name(
      "envoy.network.dns_resolver.apple");
#else
  envoy::extensions::network::dns_resolver::getaddrinfo::v3::GetAddrInfoDnsResolverConfig
      resolver_config;
  dns_cache_config->mutable_typed_dns_resolver_config()->set_name(
      "envoy.network.dns_resolver.getaddrinfo");
#endif
  dns_cache_config->mutable_typed_dns_resolver_config()->mutable_typed_config()->PackFrom(
      resolver_config);

  for (const auto& [host, port] : dns_preresolve_hostnames_) {
    envoy::config::core::v3::SocketAddress* address = dns_cache_config->add_preresolve_hostnames();
    address->set_address(host);
    address->set_port_value(port);
  }

  auto* dfp_filter = hcm->add_http_filters();
  dfp_filter->set_name("envoy.filters.http.dynamic_forward_proxy");
  dfp_filter->mutable_typed_config()->PackFrom(dfp_config);

  auto* router_filter = hcm->add_http_filters();
  envoy::extensions::filters::http::router::v3::Router router_config;
  router_filter->set_name("envoy.router");
  router_filter->mutable_typed_config()->PackFrom(router_config);

  auto* static_resources = bootstrap->mutable_static_resources();

  // Finally create the base listener, and point it at the HCM.
  auto* base_listener = static_resources->add_listeners();
  base_listener->set_name("base_api_listener");
  auto* base_address = base_listener->mutable_address();
  base_address->mutable_socket_address()->set_protocol(envoy::config::core::v3::SocketAddress::TCP);
  base_address->mutable_socket_address()->set_address("0.0.0.0");
  base_address->mutable_socket_address()->set_port_value(10000);
  base_listener->mutable_per_connection_buffer_limit_bytes()->set_value(10485760);
  base_listener->mutable_api_listener()->mutable_api_listener()->PackFrom(api_listener_config);

  // Basic TLS config.
  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_socket;
  tls_socket.mutable_common_tls_context()->mutable_tls_params()->set_tls_maximum_protocol_version(
      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);
  auto* validation = tls_socket.mutable_common_tls_context()->mutable_validation_context();
  if (enforce_trust_chain_verification_) {
    validation->set_trust_chain_verification(envoy::extensions::transport_sockets::tls::v3::
                                                 CertificateValidationContext::VERIFY_TRUST_CHAIN);
  } else {
    validation->set_trust_chain_verification(envoy::extensions::transport_sockets::tls::v3::
                                                 CertificateValidationContext::ACCEPT_UNTRUSTED);
  }

  if (platform_certificates_validation_on_) {
    envoy_mobile::extensions::cert_validator::platform_bridge::PlatformBridgeCertValidator
        validator;
    validation->mutable_custom_validator_config()->set_name(
        "envoy_mobile.cert_validator.platform_bridge_cert_validator");
    validation->mutable_custom_validator_config()->mutable_typed_config()->PackFrom(validator);
  } else {
    std::string certs;
#ifdef ENVOY_MOBILE_XDS
    if (xds_builder_ && !xds_builder_->ssl_root_certs_.empty()) {
      certs = xds_builder_->ssl_root_certs_;
    }
#endif

    if (certs.empty()) {
      // The xDS builder doesn't supply root certs, so we'll use the certs packed with Envoy Mobile,
      // if the build config allows it.
      const char* inline_certs = ""
#ifndef EXCLUDE_CERTIFICATES
#include "library/common/config/certificates.inc"
#endif
                                 "";
      certs = inline_certs;
      // The certificates in certificates.inc are prefixed with 2 spaces per
      // line to be ingressed into YAML.
      absl::StrReplaceAll({{"\n  ", "\n"}}, &certs);
    }
    validation->mutable_trusted_ca()->set_inline_string(certs);
  }
  envoy::extensions::transport_sockets::http_11_proxy::v3::Http11ProxyUpstreamTransport
      ssl_proxy_socket;
  ssl_proxy_socket.mutable_transport_socket()->set_name("envoy.transport_sockets.tls");
  ssl_proxy_socket.mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_socket);

  envoy::config::core::v3::TransportSocket base_tls_socket;
  base_tls_socket.set_name("envoy.transport_sockets.http_11_proxy");
  base_tls_socket.mutable_typed_config()->PackFrom(ssl_proxy_socket);

  envoy::extensions::upstreams::http::v3::HttpProtocolOptions h2_protocol_options;
  h2_protocol_options.mutable_explicit_http_config()->mutable_http2_protocol_options();

  // Base cluster config (DFP cluster config)
  auto* base_cluster = static_resources->add_clusters();
  envoy::extensions::clusters::dynamic_forward_proxy::v3::ClusterConfig base_cluster_config;
  envoy::config::cluster::v3::Cluster::CustomClusterType base_cluster_type;
  base_cluster_config.mutable_dns_cache_config()->CopyFrom(*dns_cache_config);
  base_cluster_type.set_name("envoy.clusters.dynamic_forward_proxy");
  base_cluster_type.mutable_typed_config()->PackFrom(base_cluster_config);

  auto* upstream_opts = base_cluster->mutable_upstream_connection_options();
  upstream_opts->set_set_local_interface_name_on_upstream_connections(true);
  upstream_opts->mutable_tcp_keepalive()->mutable_keepalive_interval()->set_value(5);
  upstream_opts->mutable_tcp_keepalive()->mutable_keepalive_probes()->set_value(1);
  upstream_opts->mutable_tcp_keepalive()->mutable_keepalive_time()->set_value(10);

  auto* circuit_breaker_settings = base_cluster->mutable_circuit_breakers();
  auto* breaker1 = circuit_breaker_settings->add_thresholds();
  breaker1->set_priority(envoy::config::core::v3::RoutingPriority::DEFAULT);
  breaker1->mutable_retry_budget()->mutable_budget_percent()->set_value(100);
  breaker1->mutable_retry_budget()->mutable_min_retry_concurrency()->set_value(0xffffffff);
  auto* breaker2 = circuit_breaker_settings->add_per_host_thresholds();
  breaker2->set_priority(envoy::config::core::v3::RoutingPriority::DEFAULT);
  breaker2->mutable_max_connections()->set_value(max_connections_per_host_);

  envoy::extensions::upstreams::http::v3::HttpProtocolOptions alpn_options;
  alpn_options.mutable_upstream_http_protocol_options()->set_auto_sni(true);
  alpn_options.mutable_upstream_http_protocol_options()->set_auto_san_validation(true);
  auto* h2_options = alpn_options.mutable_auto_config()->mutable_http2_protocol_options();
  if (h2_connection_keepalive_idle_interval_milliseconds_ > 1000) {
    h2_options->mutable_connection_keepalive()->mutable_connection_idle_interval()->set_seconds(
        h2_connection_keepalive_idle_interval_milliseconds_ / 1000);
  } else {
    h2_options->mutable_connection_keepalive()->mutable_connection_idle_interval()->set_nanos(
        h2_connection_keepalive_idle_interval_milliseconds_ * 1000 * 1000);
  }
  h2_options->mutable_connection_keepalive()->mutable_timeout()->set_seconds(
      h2_connection_keepalive_timeout_seconds_);
  h2_options->mutable_max_concurrent_streams()->set_value(100);

  envoy::extensions::http::header_formatters::preserve_case::v3::PreserveCaseFormatterConfig
      preserve_case_config;
  preserve_case_config.set_forward_reason_phrase(false);
  preserve_case_config.set_formatter_type_on_envoy_headers(
      envoy::extensions::http::header_formatters::preserve_case::v3::PreserveCaseFormatterConfig::
          DEFAULT);

  auto* h1_options = alpn_options.mutable_auto_config()->mutable_http_protocol_options();
  auto* formatter = h1_options->mutable_header_key_format()->mutable_stateful_formatter();
  formatter->set_name("preserve_case");
  formatter->mutable_typed_config()->PackFrom(preserve_case_config);

  // Base cluster
  base_cluster->set_name("base");
  base_cluster->mutable_connect_timeout()->set_seconds(connect_timeout_seconds_);
  base_cluster->set_lb_policy(envoy::config::cluster::v3::Cluster::CLUSTER_PROVIDED);
  (*base_cluster->mutable_typed_extension_protocol_options())
      ["envoy.extensions.upstreams.http.v3.HttpProtocolOptions"]
          .PackFrom(alpn_options);
  base_cluster->mutable_cluster_type()->CopyFrom(base_cluster_type);
  base_cluster->mutable_transport_socket()->set_name("envoy.transport_sockets.http_11_proxy");
  base_cluster->mutable_transport_socket()->mutable_typed_config()->PackFrom(ssl_proxy_socket);

  // Base clear-text cluster set up
  envoy::extensions::transport_sockets::raw_buffer::v3::RawBuffer raw_buffer;
  envoy::extensions::transport_sockets::http_11_proxy::v3::Http11ProxyUpstreamTransport
      cleartext_proxy_socket;
  cleartext_proxy_socket.mutable_transport_socket()->mutable_typed_config()->PackFrom(raw_buffer);
  cleartext_proxy_socket.mutable_transport_socket()->set_name("envoy.transport_sockets.raw_buffer");
  envoy::extensions::upstreams::http::v3::HttpProtocolOptions h1_protocol_options;
  h1_protocol_options.mutable_upstream_http_protocol_options()->set_auto_sni(true);
  h1_protocol_options.mutable_upstream_http_protocol_options()->set_auto_san_validation(true);
  h1_protocol_options.mutable_explicit_http_config()->mutable_http_protocol_options()->CopyFrom(
      *alpn_options.mutable_auto_config()->mutable_http_protocol_options());

  // Base clear-text cluster.
  auto* base_clear = static_resources->add_clusters();
  base_clear->set_name("base_clear");
  base_clear->mutable_connect_timeout()->set_seconds(connect_timeout_seconds_);
  base_clear->set_lb_policy(envoy::config::cluster::v3::Cluster::CLUSTER_PROVIDED);
  base_clear->mutable_cluster_type()->CopyFrom(base_cluster_type);
  base_clear->mutable_transport_socket()->set_name("envoy.transport_sockets.http_11_proxy");
  base_clear->mutable_transport_socket()->mutable_typed_config()->PackFrom(cleartext_proxy_socket);
  base_clear->mutable_upstream_connection_options()->CopyFrom(
      *base_cluster->mutable_upstream_connection_options());
  base_clear->mutable_circuit_breakers()->CopyFrom(*base_cluster->mutable_circuit_breakers());
  (*base_clear->mutable_typed_extension_protocol_options())
      ["envoy.extensions.upstreams.http.v3.HttpProtocolOptions"]
          .PackFrom(h1_protocol_options);

  // Edit and re-pack
  tls_socket.mutable_common_tls_context()->add_alpn_protocols("h2");
  ssl_proxy_socket.mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_socket);

  // Edit base cluster to be an HTTP/3 cluster.
  if (enable_http3_) {
    envoy::extensions::transport_sockets::quic::v3::QuicUpstreamTransport h3_inner_socket;
    tls_socket.mutable_common_tls_context()->mutable_alpn_protocols()->Clear();
    h3_inner_socket.mutable_upstream_tls_context()->CopyFrom(tls_socket);
    envoy::extensions::transport_sockets::http_11_proxy::v3::Http11ProxyUpstreamTransport
        h3_proxy_socket;
    h3_proxy_socket.mutable_transport_socket()->mutable_typed_config()->PackFrom(h3_inner_socket);
    h3_proxy_socket.mutable_transport_socket()->set_name("envoy.transport_sockets.quic");
    alpn_options.mutable_auto_config()
        ->mutable_http3_protocol_options()
        ->mutable_quic_protocol_options()
        ->set_connection_options(http3_connection_options_);
    alpn_options.mutable_auto_config()
        ->mutable_http3_protocol_options()
        ->mutable_quic_protocol_options()
        ->set_client_connection_options(http3_client_connection_options_);
    alpn_options.mutable_auto_config()->mutable_alternate_protocols_cache_options()->set_name(
        "default_alternate_protocols_cache");
    for (const auto& [host, port] : quic_hints_) {
      auto* entry = alpn_options.mutable_auto_config()
                        ->mutable_alternate_protocols_cache_options()
                        ->add_prepopulated_entries();
      entry->set_hostname(host);
      entry->set_port(port);
    }
    for (const auto& suffix : quic_suffixes_) {
      alpn_options.mutable_auto_config()
          ->mutable_alternate_protocols_cache_options()
          ->add_canonical_suffixes(suffix);
    }

    base_cluster->mutable_transport_socket()->mutable_typed_config()->PackFrom(h3_proxy_socket);
    (*base_cluster->mutable_typed_extension_protocol_options())
        ["envoy.extensions.upstreams.http.v3.HttpProtocolOptions"]
            .PackFrom(alpn_options);
  }

  // Set up stats.
  auto* list = bootstrap->mutable_stats_config()->mutable_stats_matcher()->mutable_inclusion_list();
  list->add_patterns()->set_prefix("cluster.base.upstream_rq_");
  list->add_patterns()->set_prefix("cluster.stats.upstream_rq_");
  list->add_patterns()->set_prefix("cluster.base.upstream_cx_");
  list->add_patterns()->set_prefix("cluster.stats.upstream_cx_");
  list->add_patterns()->set_exact("cluster.base.http2.keepalive_timeout");
  list->add_patterns()->set_exact("cluster.stats.http2.keepalive_timeout");
  list->add_patterns()->set_prefix("http.hcm.downstream_rq_");
  list->add_patterns()->set_prefix("http.hcm.decompressor.");
  list->add_patterns()->set_prefix("pulse.");
  list->add_patterns()->set_prefix("runtime.load_success");
  list->add_patterns()->mutable_safe_regex()->set_regex(
      "^vhost\\.[\\w]+\\.vcluster\\.[\\w]+?\\.upstream_rq_(?:[12345]xx|[3-5][0-9][0-9]|retry|"
      "total)");
  bootstrap->mutable_stats_config()->mutable_use_all_default_tags()->set_value(false);

  // Set up watchdog
  auto* watchdog = bootstrap->mutable_watchdogs();
  watchdog->mutable_main_thread_watchdog()->mutable_megamiss_timeout()->set_seconds(60);
  watchdog->mutable_main_thread_watchdog()->mutable_miss_timeout()->set_seconds(60);
  watchdog->mutable_worker_watchdog()->mutable_megamiss_timeout()->set_seconds(60);
  watchdog->mutable_worker_watchdog()->mutable_miss_timeout()->set_seconds(60);

  // Set up node
  auto* node = bootstrap->mutable_node();
  node->set_id(node_id_.empty() ? "envoy-mobile" : node_id_);
  node->set_cluster("envoy-mobile");
  if (node_locality_ && !node_locality_->region.empty()) {
    node->mutable_locality()->set_region(node_locality_->region);
    node->mutable_locality()->set_zone(node_locality_->zone);
    node->mutable_locality()->set_sub_zone(node_locality_->sub_zone);
  }
  if (node_metadata_.has_value()) {
    *node->mutable_metadata() = *node_metadata_;
  }
  ProtobufWkt::Struct& metadata = *node->mutable_metadata();
  (*metadata.mutable_fields())["app_id"].set_string_value(app_id_);
  (*metadata.mutable_fields())["app_version"].set_string_value(app_version_);
  (*metadata.mutable_fields())["device_os"].set_string_value(device_os_);

  // Set up runtime.
  auto* runtime = bootstrap->mutable_layered_runtime()->add_layers();
  runtime->set_name("static_layer_0");
  ProtobufWkt::Struct envoy_layer;
  ProtobufWkt::Struct& runtime_values =
      *(*envoy_layer.mutable_fields())["envoy"].mutable_struct_value();
  ProtobufWkt::Struct& flags =
      *(*runtime_values.mutable_fields())["reloadable_features"].mutable_struct_value();
  for (auto& guard_and_value : runtime_guards_) {
    (*flags.mutable_fields())[guard_and_value.first].set_bool_value(guard_and_value.second);
  }
  (*flags.mutable_fields())["always_use_v6"].set_bool_value(always_use_v6_);
  (*runtime_values.mutable_fields())["disallow_global_stats"].set_bool_value(true);
  ProtobufWkt::Struct& overload_values =
      *(*envoy_layer.mutable_fields())["overload"].mutable_struct_value();
  (*overload_values.mutable_fields())["global_downstream_max_connections"].set_string_value(
      "4294967295");
  runtime->mutable_static_layer()->MergeFrom(envoy_layer);

  bootstrap->mutable_typed_dns_resolver_config()->CopyFrom(
      *dns_cache_config->mutable_typed_dns_resolver_config());

  bootstrap->mutable_dynamic_resources();
#ifdef ENVOY_MOBILE_XDS
  if (xds_builder_) {
    xds_builder_->build(*bootstrap);
  }
#endif

  envoy::config::listener::v3::ApiListenerManager api;
  auto* listener_manager = bootstrap->mutable_listener_manager();
  listener_manager->mutable_typed_config()->PackFrom(api);
  listener_manager->set_name("envoy.listener_manager_impl.api");

  return bootstrap;
}

EngineSharedPtr EngineBuilder::build() {
  envoy_logger null_logger;
  null_logger.log = nullptr;
  null_logger.release = envoy_noop_const_release;
  null_logger.context = nullptr;

  envoy_event_tracker null_tracker{};

  Envoy::Engine* envoy_engine =
      new Envoy::Engine(callbacks_->asEnvoyEngineCallbacks(), null_logger, null_tracker);

  for (const auto& [name, store] : key_value_stores_) {
    // TODO(goaway): This leaks, but it's tied to the life of the engine.
    if (!Api::External::retrieveApi(name, true)) {
      auto* api = new envoy_kv_store();
      *api = store->asEnvoyKeyValueStore();
      Envoy::Api::External::registerApi(name.c_str(), api);
    }
  }

  for (const auto& [name, accessor] : string_accessors_) {
    // TODO(RyanTheOptimist): This leaks, but it's tied to the life of the engine.
    if (!Api::External::retrieveApi(name, true)) {
      auto* api = new envoy_string_accessor();
      *api = StringAccessor::asEnvoyStringAccessor(accessor);
      Envoy::Api::External::registerApi(name.c_str(), api);
    }
  }

  Engine* engine = new Engine(envoy_engine);

  auto options = std::make_unique<Envoy::OptionsImplBase>();
  std::unique_ptr<envoy::config::bootstrap::v3::Bootstrap> bootstrap = generateBootstrap();
  if (bootstrap) {
    options->setConfigProto(std::move(bootstrap));
  }
  ENVOY_BUG(options->setLogLevel(logLevelToString(log_level_)).ok(), "invalid log level");
  options->setConcurrency(1);
  envoy_engine->run(std::move(options));

  // we can't construct via std::make_shared
  // because Engine is only constructible as a friend
  auto engine_ptr = EngineSharedPtr(engine);
  return engine_ptr;
}

} // namespace Platform
} // namespace Envoy
#include "log_level.h"

#include <stdexcept>

#include "source/common/common/assert.h"
#include "source/common/common/macros.h"

namespace Envoy {
namespace Platform {

static const std::pair<LogLevel, std::string> LOG_LEVEL_LOOKUP[]{
    {LogLevel::trace, "trace"}, {LogLevel::debug, "debug"}, {LogLevel::info, "info"},
    {LogLevel::warn, "warn"},   {LogLevel::error, "error"}, {LogLevel::critical, "critical"},
    {LogLevel::off, "off"},
};

std::string logLevelToString(LogLevel method) {
  for (const auto& pair : LOG_LEVEL_LOOKUP) {
    if (pair.first == method) {
      return pair.second;
    }
  }

  IS_ENVOY_BUG("unknown log level, defaulting to off");
  return LOG_LEVEL_LOOKUP[ARRAY_SIZE(LOG_LEVEL_LOOKUP) - 1].second;
}

LogLevel logLevelFromString(const std::string& str) {
  for (const auto& pair : LOG_LEVEL_LOOKUP) {
    if (pair.second == str) {
      return pair.first;
    }
  }

  IS_ENVOY_BUG("unknown log level, defaulting to off");
  return LOG_LEVEL_LOOKUP[ARRAY_SIZE(LOG_LEVEL_LOOKUP) - 1].first;
}

} // namespace Platform
} // namespace Envoy
#include "stream.h"

#include "library/cc/bridge_utility.h"
#include "library/common/engine.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Platform {

Stream::Stream(Envoy::Engine* engine, envoy_stream_t handle) : engine_(engine), handle_(handle) {}

Stream& Stream::sendHeaders(RequestHeadersSharedPtr headers, bool end_stream) {
  envoy_headers raw_headers = rawHeaderMapAsEnvoyHeaders(headers->allHeaders());
  engine_->sendHeaders(handle_, raw_headers, end_stream);
  return *this;
}

Stream& Stream::sendData(envoy_data data) {
  engine_->sendData(handle_, data, false);
  return *this;
}

Stream& Stream::readData(size_t bytes_to_read) {
  engine_->readData(handle_, bytes_to_read);
  return *this;
}

void Stream::close(RequestTrailersSharedPtr trailers) {
  envoy_headers raw_headers = rawHeaderMapAsEnvoyHeaders(trailers->allHeaders());
  engine_->sendTrailers(handle_, raw_headers);
}

void Stream::close(envoy_data data) { engine_->sendData(handle_, data, true); }

void Stream::cancel() { engine_->cancelStream(handle_); }

} // namespace Platform
} // namespace Envoy
#include "library/cc/response_trailers_builder.h"

namespace Envoy {
namespace Platform {

ResponseTrailersSharedPtr ResponseTrailersBuilder::build() const {
  ResponseTrailers* trailers = new ResponseTrailers(allHeaders());
  return ResponseTrailersSharedPtr(trailers);
}

} // namespace Platform
} // namespace Envoy
#include "library/cc/key_value_store.h"

#include "library/common/data/utility.h"

namespace Envoy {
namespace Platform {

namespace {

envoy_data c_kv_store_read(envoy_data key, const void* context) {
  auto kv_store = *static_cast<KeyValueStoreSharedPtr*>(const_cast<void*>(context));

  auto value = kv_store->read(Data::Utility::copyToString(key));
  release_envoy_data(key);

  return value.has_value() ? Data::Utility::copyToBridgeData(value.value()) : envoy_nodata;
}

void c_kv_store_save(envoy_data key, envoy_data value, const void* context) {
  auto kv_store = *static_cast<KeyValueStoreSharedPtr*>(const_cast<void*>(context));

  kv_store->save(Data::Utility::copyToString(key), Data::Utility::copyToString(value));
  release_envoy_data(key);
  release_envoy_data(value);
}

void c_kv_store_remove(envoy_data key, const void* context) {
  auto kv_store = *static_cast<KeyValueStoreSharedPtr*>(const_cast<void*>(context));

  kv_store->remove(Data::Utility::copyToString(key));
  release_envoy_data(key);
}

} // namespace

envoy_kv_store KeyValueStore::asEnvoyKeyValueStore() {
  return envoy_kv_store{
      &c_kv_store_read,
      &c_kv_store_save,
      &c_kv_store_remove,
      new KeyValueStoreSharedPtr(shared_from_this()),
  };
}

} // namespace Platform
} // namespace Envoy
#pragma once

#include <string>
#include <vector>

#include "absl/container/flat_hash_map.h"

namespace Envoy {
namespace DirectResponseTesting {

// The match operation to perform.
enum class MatchMode { Contains, Exact, Prefix, Suffix };

// A configuration for when a header should be matched.
struct HeaderMatcher {
  std::string name;
  std::string value;
  MatchMode mode;
};

// A configuration for when a route should be matched.
struct RouteMatcher {
  std::string fullPath;
  std::string pathPrefix;
  std::vector<HeaderMatcher> headers;
};

// A direct response to configure for testing.
struct DirectResponse {
  RouteMatcher matcher;
  unsigned int status;
  std::string body;
  absl::flat_hash_map<std::string, std::string> headers;
};

} // namespace DirectResponseTesting
} // namespace Envoy
#pragma once

#include <memory>

#include "library/cc/engine.h"
#include "library/cc/envoy_error.h"
#include "library/cc/response_headers.h"
#include "library/cc/response_trailers.h"
#include "library/cc/stream.h"
#include "library/cc/stream_callbacks.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Platform {

class Engine;
using EngineSharedPtr = std::shared_ptr<Engine>;

class StreamPrototype {
public:
  StreamPrototype(EngineSharedPtr engine);

  StreamSharedPtr start(bool explicit_flow_control = false);

  StreamPrototype& setOnHeaders(OnHeadersCallback closure);
  StreamPrototype& setOnData(OnDataCallback closure);
  StreamPrototype& setOnTrailers(OnTrailersCallback closure);
  StreamPrototype& setOnError(OnErrorCallback closure);
  StreamPrototype& setOnComplete(OnCompleteCallback closure);
  StreamPrototype& setOnCancel(OnCancelCallback closure);
  StreamPrototype& setOnSendWindowAvailable(OnSendWindowAvailableCallback closure);

private:
  EngineSharedPtr engine_;
  StreamCallbacksSharedPtr callbacks_;
};

using StreamPrototypeSharedPtr = std::shared_ptr<StreamPrototype>;

} // namespace Platform
} // namespace Envoy
#include "library/cc/request_headers.h"

namespace Envoy {
namespace Platform {

RequestMethod RequestHeaders::requestMethod() const {
  return requestMethodFromString((*this)[":method"][0]);
}

const std::string& RequestHeaders::scheme() const { return (*this)[":scheme"][0]; }

const std::string& RequestHeaders::authority() const { return (*this)[":authority"][0]; }

const std::string& RequestHeaders::path() const { return (*this)[":path"][0]; }

absl::optional<RetryPolicy> RequestHeaders::retryPolicy() const {
  return absl::optional<RetryPolicy>(RetryPolicy::fromRawHeaderMap(allHeaders()));
}

RequestHeadersBuilder RequestHeaders::toRequestHeadersBuilder() const {
  RequestHeadersBuilder builder(requestMethod(), scheme(), authority(), path());
  for (const auto& pair : allHeaders()) {
    builder.set(pair.first, pair.second);
  }
  return builder;
}

} // namespace Platform
} // namespace Envoy
#pragma once

#include <string>

#include "library/cc/headers_builder.h"
#include "library/cc/request_headers.h"
#include "library/cc/request_method.h"
#include "retry_policy.h"

namespace Envoy {
namespace Platform {

class RequestHeaders;
struct RetryPolicy;

class RequestHeadersBuilder : public HeadersBuilder {
public:
  RequestHeadersBuilder(RequestMethod request_method, std::string scheme, std::string authority,
                        std::string path);
  RequestHeadersBuilder(RequestMethod request_method, absl::string_view url);

  RequestHeadersBuilder& addRetryPolicy(const RetryPolicy& retry_policy);

  RequestHeaders build() const;

private:
  void initialize(RequestMethod request_method, std::string scheme, std::string authority,
                  std::string path);
};

using RequestHeadersBuilderSharedPtr = std::shared_ptr<RequestHeadersBuilder>;

} // namespace Platform
} // namespace Envoy
#include "library/cc/string_accessor.h"

#include "library/common/data/utility.h"

namespace Envoy {
namespace Platform {

namespace {

envoy_data c_string_accessor_read(const void* context) {
  auto accessor = *static_cast<const StringAccessorSharedPtr*>(context);
  return Data::Utility::copyToBridgeData(accessor->get());
}

} // namespace

envoy_string_accessor StringAccessor::asEnvoyStringAccessor(StringAccessorSharedPtr accessor) {
  return envoy_string_accessor{&c_string_accessor_read, new StringAccessorSharedPtr(accessor)};
}

} // namespace Platform
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_mobile_package",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "engine_builder_lib",
    srcs = [
        "engine_builder.cc",
    ],
    hdrs = [
        "engine_builder.h",
    ],
    copts = select({
        "//bazel:exclude_certificates": ["-DEXCLUDE_CERTIFICATES"],
        "//conditions:default": [],
    }),
    external_deps = ["abseil_optional"],
    repository = "@envoy",
    visibility = ["//visibility:public"],
    deps = [
        ":envoy_engine_cc_lib_no_stamp",
        "@envoy//source/common/common:assert_lib",
        "@envoy//source/common/protobuf",
        "@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/metrics/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/compression/brotli/decompressor/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/compression/gzip/decompressor/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/http/alternate_protocols_cache/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/http/decompressor/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/http/dynamic_forward_proxy/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/http/header_formatters/preserve_case/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/network/dns_resolver/apple/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/network/dns_resolver/getaddrinfo/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/transport_sockets/http_11_proxy/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/transport_sockets/quic/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/transport_sockets/raw_buffer/v3:pkg_cc_proto",
        "@envoy_mobile//library/common/config:certificates_lib",
        "@envoy_mobile//library/common/extensions/cert_validator/platform_bridge:platform_bridge_cc_proto",
        "@envoy_mobile//library/common/extensions/filters/http/local_error:filter_cc_proto",
        "@envoy_mobile//library/common/extensions/filters/http/network_configuration:filter_cc_proto",
        "@envoy_mobile//library/common/extensions/filters/http/socket_tag:filter_cc_proto",
        "@envoy_mobile//library/common/types:matcher_data_lib",
    ],
)

envoy_cc_library(
    name = "envoy_engine_cc_lib_no_stamp",
    srcs = [
        "bridge_utility.cc",
        "engine.cc",
        "engine_callbacks.cc",
        "headers.cc",
        "headers_builder.cc",
        "key_value_store.cc",
        "log_level.cc",
        "request_headers.cc",
        "request_headers_builder.cc",
        "request_method.cc",
        "request_trailers.cc",
        "request_trailers_builder.cc",
        "response_headers.cc",
        "response_headers_builder.cc",
        "response_trailers.cc",
        "response_trailers_builder.cc",
        "retry_policy.cc",
        "stream.cc",
        "stream_callbacks.cc",
        "stream_client.cc",
        "stream_prototype.cc",
        "string_accessor.cc",
    ],
    hdrs = [
        "bridge_utility.h",
        "direct_response_testing.h",
        "engine.h",
        "engine_callbacks.h",
        "envoy_error.h",
        "headers.h",
        "headers_builder.h",
        "key_value_store.h",
        "log_level.h",
        "request_headers.h",
        "request_headers_builder.h",
        "request_method.h",
        "request_trailers.h",
        "request_trailers_builder.h",
        "response_headers.h",
        "response_headers_builder.h",
        "response_trailers.h",
        "response_trailers_builder.h",
        "retry_policy.h",
        "stream.h",
        "stream_callbacks.h",
        "stream_client.h",
        "stream_prototype.h",
        "string_accessor.h",
        "trailers.h",
    ],
    external_deps = ["abseil_optional"],
    repository = "@envoy",
    visibility = ["//visibility:public"],
    deps = [
        "//library/common:engine_lib_no_stamp",
        "//library/common/api:c_types",
        "//library/common/data:utility_lib",
        "//library/common/extensions/key_value/platform:config",
        "@envoy//source/common/http:utility_lib",
    ],
)

envoy_cc_library(
    name = "envoy_engine_cc_lib",
    repository = "@envoy",
    visibility = ["//visibility:public"],
    deps = [
        ":engine_builder_lib",
        ":envoy_engine_cc_lib_no_stamp",
        "//library/common:engine_common_lib_stamped",
    ],
)
#pragma once

#include <functional>
#include <memory>

#include "library/cc/engine.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Platform {

struct EngineCallbacks : public std::enable_shared_from_this<EngineCallbacks> {
  std::function<void()> on_engine_running;
  // unused:
  // std::function<void()> on_exit;

  envoy_engine_callbacks asEnvoyEngineCallbacks();
};

using EngineCallbacksSharedPtr = std::shared_ptr<EngineCallbacks>;

} // namespace Platform
} // namespace Envoy
#pragma once

#include <map>
#include <memory>
#include <string>
#include <vector>

#include "envoy/config/bootstrap/v3/bootstrap.pb.h"
#include "envoy/config/core/v3/base.pb.h"

#include "source/common/protobuf/protobuf.h"

#include "absl/container/flat_hash_map.h"
#include "absl/types/optional.h"
#include "direct_response_testing.h"
#include "library/cc/engine.h"
#include "library/cc/engine_callbacks.h"
#include "library/cc/key_value_store.h"
#include "library/cc/log_level.h"
#include "library/cc/string_accessor.h"
#include "library/common/types/matcher_data.h"

namespace Envoy {
namespace Platform {

constexpr int DefaultXdsTimeout = 5;

// Forward declaration so it can be referenced by XdsBuilder.
class EngineBuilder;

// Represents the locality information in the Bootstrap's node, as defined in:
// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/base.proto#envoy-v3-api-msg-config-core-v3-locality
struct NodeLocality {
  std::string region;
  std::string zone;
  std::string sub_zone;
};

#ifdef ENVOY_MOBILE_XDS
// A class for building the xDS configuration for the Envoy Mobile engine.
// xDS is a protocol for dynamic configuration of Envoy instances, more information can be found in:
// https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol.
//
// This class is typically used as input to the EngineBuilder's setXds() method.
class XdsBuilder final {
public:
  // `xds_server_address`: the host name or IP address of the xDS management server. The xDS server
  //                       must support the ADS protocol
  //                       (https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/dynamic_configuration#aggregated-xds-ads).
  // `xds_server_port`: the port on which the xDS management server listens for ADS discovery
  //                    requests.
  XdsBuilder(std::string xds_server_address, const uint32_t xds_server_port);

  // Adds a header to the initial HTTP metadata headers sent on the gRPC stream.
  //
  // A common use for the initial metadata headers is for authentication to the xDS management
  // server.
  //
  // For example, if using API keys to authenticate to Traffic Director on GCP (see
  // https://cloud.google.com/docs/authentication/api-keys for details), invoke:
  //   builder.addInitialStreamHeader("x-goog-api-key", api_key_token)
  //          .addInitialStreamHeader("X-Android-Package", app_package_name)
  //          .addInitialStreamHeader("X-Android-Cert", sha1_key_fingerprint);
  XdsBuilder& addInitialStreamHeader(std::string header, std::string value);

  // Sets the PEM-encoded server root certificates used to negotiate the TLS handshake for the gRPC
  // connection. If no root certs are specified, the operating system defaults are used.
  XdsBuilder& setSslRootCerts(std::string root_certs);

  // Adds Runtime Discovery Service (RTDS) to the Runtime layers of the Bootstrap configuration,
  // to retrieve dynamic runtime configuration via the xDS management server.
  //
  // `resource_name`: The runtime config resource to subscribe to.
  // `timeout_in_seconds`: <optional> specifies the `initial_fetch_timeout` field on the
  //    api.v3.core.ConfigSource. Unlike the ConfigSource default of 15s, we set a default fetch
  //    timeout value of 5s, to prevent mobile app initialization from stalling. The default
  //    parameter value may change through the course of experimentation and no assumptions should
  //    be made of its exact value.
  XdsBuilder& addRuntimeDiscoveryService(std::string resource_name,
                                         int timeout_in_seconds = DefaultXdsTimeout);

  // Adds the Cluster Discovery Service (CDS) configuration for retrieving dynamic cluster resources
  // via the xDS management server.
  //
  // `cds_resources_locator`: <optional> the xdstp:// URI for subscribing to the cluster resources.
  //    If not using xdstp, then `cds_resources_locator` should be set to the empty string.
  // `timeout_in_seconds`: <optional> specifies the `initial_fetch_timeout` field on the
  //    api.v3.core.ConfigSource. Unlike the ConfigSource default of 15s, we set a default fetch
  //    timeout value of 5s, to prevent mobile app initialization from stalling. The default
  //    parameter value may change through the course of experimentation and no assumptions should
  //    be made of its exact value.
  XdsBuilder& addClusterDiscoveryService(std::string cds_resources_locator = "",
                                         int timeout_in_seconds = DefaultXdsTimeout);

protected:
  // Sets the xDS configuration specified on this XdsBuilder instance on the Bootstrap proto
  // provided as an input parameter.
  //
  // This method takes in a modifiable Bootstrap proto pointer because returning a new Bootstrap
  // proto would rely on proto's MergeFrom behavior, which can lead to unexpected results in the
  // Bootstrap config.
  void build(envoy::config::bootstrap::v3::Bootstrap& bootstrap) const;

private:
  // Required so that EngineBuilder can call the XdsBuilder's protected build() method.
  friend class EngineBuilder;

  std::string xds_server_address_;
  uint32_t xds_server_port_;
  std::vector<envoy::config::core::v3::HeaderValue> xds_initial_grpc_metadata_;
  std::string ssl_root_certs_;
  std::string rtds_resource_name_;
  int rtds_timeout_in_seconds_ = DefaultXdsTimeout;
  bool enable_cds_ = false;
  std::string cds_resources_locator_;
  int cds_timeout_in_seconds_ = DefaultXdsTimeout;
};
#endif

// The C++ Engine builder creates a structured bootstrap proto and modifies it through parameters
// set through the EngineBuilder API calls to produce the Bootstrap config that the Engine is
// created from.
class EngineBuilder {
public:
  EngineBuilder();
  virtual ~EngineBuilder() {}

  EngineBuilder& addLogLevel(LogLevel log_level);
  EngineBuilder& setOnEngineRunning(std::function<void()> closure);
  EngineBuilder& addConnectTimeoutSeconds(int connect_timeout_seconds);
  EngineBuilder& addDnsRefreshSeconds(int dns_refresh_seconds);
  EngineBuilder& addDnsFailureRefreshSeconds(int base, int max);
  EngineBuilder& addDnsQueryTimeoutSeconds(int dns_query_timeout_seconds);
  EngineBuilder& addDnsMinRefreshSeconds(int dns_min_refresh_seconds);
  EngineBuilder& addMaxConnectionsPerHost(int max_connections_per_host);
  EngineBuilder& useDnsSystemResolver(bool use_system_resolver);
  EngineBuilder& addH2ConnectionKeepaliveIdleIntervalMilliseconds(
      int h2_connection_keepalive_idle_interval_milliseconds);
  EngineBuilder&
  addH2ConnectionKeepaliveTimeoutSeconds(int h2_connection_keepalive_timeout_seconds);
  // Configures Envoy to use the PlatformBridge filter named `name`. An instance of
  // envoy_http_filter must be registered as a platform API with the same name.
  EngineBuilder& setAppVersion(std::string app_version);
  EngineBuilder& setAppId(std::string app_id);
  EngineBuilder& setDeviceOs(std::string app_id);
  EngineBuilder& setStreamIdleTimeoutSeconds(int stream_idle_timeout_seconds);
  EngineBuilder& setPerTryIdleTimeoutSeconds(int per_try_idle_timeout_seconds);
  EngineBuilder& enableGzipDecompression(bool gzip_decompression_on);
  EngineBuilder& enableBrotliDecompression(bool brotli_decompression_on);
  EngineBuilder& enableSocketTagging(bool socket_tagging_on);
#ifdef ENVOY_ENABLE_QUIC
  EngineBuilder& enableHttp3(bool http3_on);
  EngineBuilder& setHttp3ConnectionOptions(std::string options);
  EngineBuilder& setHttp3ClientConnectionOptions(std::string options);
  EngineBuilder& addQuicHint(std::string host, int port);
  EngineBuilder& addQuicCanonicalSuffix(std::string suffix);
#endif
  EngineBuilder& enableInterfaceBinding(bool interface_binding_on);
  EngineBuilder& enableDrainPostDnsRefresh(bool drain_post_dns_refresh_on);
  EngineBuilder& enforceTrustChainVerification(bool trust_chain_verification_on);
  EngineBuilder& enablePlatformCertificatesValidation(bool platform_certificates_validation_on);
  // Sets the node.id field in the Bootstrap configuration.
  EngineBuilder& setNodeId(std::string node_id);
  // Sets the node.locality field in the Bootstrap configuration.
  EngineBuilder& setNodeLocality(std::string region, std::string zone, std::string sub_zone);
  // Sets the node.metadata field in the Bootstrap configuration.
  EngineBuilder& setNodeMetadata(ProtobufWkt::Struct node_metadata);
#ifdef ENVOY_MOBILE_XDS
  // Sets the xDS configuration for the Envoy Mobile engine.
  //
  // `xds_builder`: the XdsBuilder instance used to specify the xDS configuration options.
  EngineBuilder& setXds(XdsBuilder xds_builder);
#endif
  EngineBuilder& enableDnsCache(bool dns_cache_on, int save_interval_seconds = 1);
  EngineBuilder& setForceAlwaysUsev6(bool value);
  // Adds the hostnames that should be pre-resolved by DNS prior to the first request issued for
  // that host. When invoked, any previous preresolve hostname entries get cleared and only the ones
  // provided in the hostnames argument get set.
  // TODO(abeyad): change this method and the other language APIs to take a {host,port} pair.
  // E.g. addDnsPreresolveHost(std::string host, uint32_t port);
  EngineBuilder& addDnsPreresolveHostnames(const std::vector<std::string>& hostnames);
  EngineBuilder& addNativeFilter(std::string name, std::string typed_config);

  EngineBuilder& addPlatformFilter(const std::string& name);

  EngineBuilder& setRuntimeGuard(std::string guard, bool value);

  // These functions don't affect the Bootstrap configuration but instead perform registrations.
  EngineBuilder& addKeyValueStore(std::string name, KeyValueStoreSharedPtr key_value_store);
  EngineBuilder& addStringAccessor(std::string name, StringAccessorSharedPtr accessor);

  // This is separated from build() for the sake of testability
  virtual std::unique_ptr<envoy::config::bootstrap::v3::Bootstrap> generateBootstrap() const;

  EngineSharedPtr build();

private:
  struct NativeFilterConfig {
    NativeFilterConfig(std::string name, std::string typed_config)
        : name_(std::move(name)), typed_config_(std::move(typed_config)) {}

    std::string name_;
    std::string typed_config_;
  };

  LogLevel log_level_ = LogLevel::info;
  EngineCallbacksSharedPtr callbacks_;

  int connect_timeout_seconds_ = 30;
  int dns_refresh_seconds_ = 60;
  int dns_failure_refresh_seconds_base_ = 2;
  int dns_failure_refresh_seconds_max_ = 10;
  int dns_query_timeout_seconds_ = 25;
  bool use_system_resolver_ = true;
  int h2_connection_keepalive_idle_interval_milliseconds_ = 100000000;
  int h2_connection_keepalive_timeout_seconds_ = 10;
  std::string app_version_ = "unspecified";
  std::string app_id_ = "unspecified";
  std::string device_os_ = "unspecified";
  int stream_idle_timeout_seconds_ = 15;
  int per_try_idle_timeout_seconds_ = 15;
  bool gzip_decompression_filter_ = true;
  bool brotli_decompression_filter_ = false;
  bool socket_tagging_filter_ = false;
  bool platform_certificates_validation_on_ = false;
  std::string node_id_;
  absl::optional<NodeLocality> node_locality_ = absl::nullopt;
  absl::optional<ProtobufWkt::Struct> node_metadata_ = absl::nullopt;
  bool dns_cache_on_ = false;
  int dns_cache_save_interval_seconds_ = 1;

  absl::flat_hash_map<std::string, KeyValueStoreSharedPtr> key_value_stores_{};

  bool enable_interface_binding_ = false;
  bool enable_drain_post_dns_refresh_ = false;
  bool enforce_trust_chain_verification_ = true;
  bool enable_http3_ = true;
  std::string http3_connection_options_ = "";
  std::string http3_client_connection_options_ = "";
  std::vector<std::pair<std::string, int>> quic_hints_;
  std::vector<std::string> quic_suffixes_;
  bool always_use_v6_ = false;
  int dns_min_refresh_seconds_ = 60;
  int max_connections_per_host_ = 7;

  std::vector<NativeFilterConfig> native_filter_chain_;
  std::vector<std::pair<std::string /* host */, uint32_t /* port */>> dns_preresolve_hostnames_;

  std::vector<std::pair<std::string, bool>> runtime_guards_;
  absl::flat_hash_map<std::string, StringAccessorSharedPtr> string_accessors_;

#ifdef ENVOY_MOBILE_XDS
  absl::optional<XdsBuilder> xds_builder_ = absl::nullopt;
#endif
};

using EngineBuilderSharedPtr = std::shared_ptr<EngineBuilder>;

} // namespace Platform
} // namespace Envoy
#pragma once

#include "library/cc/headers_builder.h"
#include "library/cc/response_trailers.h"

namespace Envoy {
namespace Platform {

class ResponseTrailers;
using ResponseTrailersSharedPtr = std::shared_ptr<ResponseTrailers>;

class ResponseTrailersBuilder : public HeadersBuilder {
public:
  ResponseTrailersBuilder() {}

  ResponseTrailersSharedPtr build() const;
};

using ResponseTrailersBuilderSharedPtr = std::shared_ptr<ResponseTrailersBuilder>;

} // namespace Platform
} // namespace Envoy
#pragma once

#include "library/cc/headers_builder.h"
#include "library/cc/response_headers.h"

namespace Envoy {
namespace Platform {

class ResponseHeaders;
using ResponseHeadersSharedPtr = std::shared_ptr<ResponseHeaders>;

class ResponseHeadersBuilder : public HeadersBuilder {
public:
  ResponseHeadersBuilder() {}

  ResponseHeadersBuilder& addHttpStatus(int status);
  ResponseHeadersSharedPtr build() const;
};

using ResponseHeadersBuilderSharedPtr = std::shared_ptr<ResponseHeadersBuilder>;

} // namespace Platform
} // namespace Envoy
#pragma once

#include "absl/strings/string_view.h"

namespace Envoy {
namespace Platform {

enum RequestMethod {
  DELETE,
  GET,
  HEAD,
  OPTIONS,
  PATCH,
  POST,
  PUT,
  TRACE,
};

absl::string_view requestMethodToString(RequestMethod method);
RequestMethod requestMethodFromString(absl::string_view str);

} // namespace Platform
} // namespace Envoy
#pragma once

#include "library/cc/headers_builder.h"
#include "library/cc/request_trailers.h"

namespace Envoy {
namespace Platform {

class RequestTrailers;

class RequestTrailersBuilder : public HeadersBuilder {
public:
  RequestTrailersBuilder() : HeadersBuilder() {}

  RequestTrailers build() const;
};

using RequestTrailersBuilderSharedPtr = std::shared_ptr<RequestTrailersBuilder>;

} // namespace Platform
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

filegroup(
    name = "proguard_rules",
    srcs = [
        "java_proto_proguard.txt",
        "proguard.txt",
    ],
    visibility = ["//visibility:public"],
)
#pragma once

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface EnvoyNativeFilterConfig : NSObject

@property (nonatomic, strong) NSString *name;
@property (nonatomic, strong) NSString *typedConfig;

- (instancetype)initWithName:(NSString *)name typedConfig:(NSString *)typedConfig;

@end

NS_ASSUME_NONNULL_END
#pragma once

#import <Foundation/Foundation.h>

@class EMODirectResponse;
@class EnvoyHTTPFilterFactory;
@class EnvoyNativeFilterConfig;
@class EnvoyStringAccessor;
@protocol EnvoyKeyValueStore;

NS_ASSUME_NONNULL_BEGIN

/// Typed configuration that may be used for starting Envoy.
@interface EnvoyConfiguration : NSObject

@property (nonatomic, assign) UInt32 connectTimeoutSeconds;
@property (nonatomic, assign) UInt32 dnsFailureRefreshSecondsBase;
@property (nonatomic, assign) UInt32 dnsFailureRefreshSecondsMax;
@property (nonatomic, assign) UInt32 dnsQueryTimeoutSeconds;
@property (nonatomic, assign) UInt32 dnsMinRefreshSeconds;
@property (nonatomic, strong) NSArray<NSString *> *dnsPreresolveHostnames;
@property (nonatomic, assign) UInt32 dnsRefreshSeconds;
@property (nonatomic, assign) BOOL enableDNSCache;
@property (nonatomic, assign) UInt32 dnsCacheSaveIntervalSeconds;
@property (nonatomic, assign) BOOL enableHttp3;
@property (nonatomic, strong) NSDictionary<NSString *, NSNumber *> *quicHints;
@property (nonatomic, strong) NSArray<NSString *> *quicCanonicalSuffixes;
@property (nonatomic, assign) BOOL enableGzipDecompression;
@property (nonatomic, assign) BOOL enableBrotliDecompression;
@property (nonatomic, assign) BOOL enableInterfaceBinding;
@property (nonatomic, assign) BOOL enableDrainPostDnsRefresh;
@property (nonatomic, assign) BOOL enforceTrustChainVerification;
@property (nonatomic, assign) BOOL forceIPv6;
@property (nonatomic, assign) BOOL enablePlatformCertificateValidation;
@property (nonatomic, assign) UInt32 h2ConnectionKeepaliveIdleIntervalMilliseconds;
@property (nonatomic, assign) UInt32 h2ConnectionKeepaliveTimeoutSeconds;
@property (nonatomic, assign) UInt32 maxConnectionsPerHost;
@property (nonatomic, assign) UInt32 streamIdleTimeoutSeconds;
@property (nonatomic, assign) UInt32 perTryIdleTimeoutSeconds;
@property (nonatomic, strong, nullable) NSString *appVersion;
@property (nonatomic, strong, nullable) NSString *appId;
@property (nonatomic, strong) NSDictionary<NSString *, NSString *> *runtimeGuards;
@property (nonatomic, strong) NSArray<EnvoyNativeFilterConfig *> *nativeFilterChain;
@property (nonatomic, strong) NSArray<EnvoyHTTPFilterFactory *> *httpPlatformFilterFactories;
@property (nonatomic, strong) NSDictionary<NSString *, EnvoyStringAccessor *> *stringAccessors;
@property (nonatomic, strong) NSDictionary<NSString *, id<EnvoyKeyValueStore>> *keyValueStores;
@property (nonatomic, strong, nullable) NSString *nodeId;
@property (nonatomic, strong, nullable) NSString *nodeRegion;
@property (nonatomic, strong, nullable) NSString *nodeZone;
@property (nonatomic, strong, nullable) NSString *nodeSubZone;
@property (nonatomic, strong, nullable) NSString *xdsServerAddress;
@property (nonatomic, assign) UInt32 xdsServerPort;
@property (nonatomic, strong) NSDictionary<NSString *, NSString *> *xdsGrpcInitialMetadata;
@property (nonatomic, strong, nullable) NSString *xdsSslRootCerts;
@property (nonatomic, strong, nullable) NSString *rtdsResourceName;
@property (nonatomic, assign) UInt32 rtdsTimeoutSeconds;
@property (nonatomic, assign) BOOL enableCds;
@property (nonatomic, strong, nullable) NSString *cdsResourcesLocator;
@property (nonatomic, assign) UInt32 cdsTimeoutSeconds;
@property (nonatomic, assign) intptr_t bootstrapPointer;

/**
 Create a new instance of the configuration.
 */
- (instancetype)initWithConnectTimeoutSeconds:(UInt32)connectTimeoutSeconds
                                dnsRefreshSeconds:(UInt32)dnsRefreshSeconds
                     dnsFailureRefreshSecondsBase:(UInt32)dnsFailureRefreshSecondsBase
                      dnsFailureRefreshSecondsMax:(UInt32)dnsFailureRefreshSecondsMax
                           dnsQueryTimeoutSeconds:(UInt32)dnsQueryTimeoutSeconds
                             dnsMinRefreshSeconds:(UInt32)dnsMinRefreshSeconds
                           dnsPreresolveHostnames:(NSArray<NSString *> *)dnsPreresolveHostnames
                                   enableDNSCache:(BOOL)enableDNSCache
                      dnsCacheSaveIntervalSeconds:(UInt32)dnsCacheSaveIntervalSeconds
                                      enableHttp3:(BOOL)enableHttp3
                                        quicHints:(NSDictionary<NSString *, NSNumber *> *)quicHints
                            quicCanonicalSuffixes:(NSArray<NSString *> *)quicCanonicalSuffixes
                          enableGzipDecompression:(BOOL)enableGzipDecompression
                        enableBrotliDecompression:(BOOL)enableBrotliDecompression
                           enableInterfaceBinding:(BOOL)enableInterfaceBinding
                        enableDrainPostDnsRefresh:(BOOL)enableDrainPostDnsRefresh
                    enforceTrustChainVerification:(BOOL)enforceTrustChainVerification
                                        forceIPv6:(BOOL)forceIPv6
              enablePlatformCertificateValidation:(BOOL)enablePlatformCertificateValidation
    h2ConnectionKeepaliveIdleIntervalMilliseconds:
        (UInt32)h2ConnectionKeepaliveIdleIntervalMilliseconds
              h2ConnectionKeepaliveTimeoutSeconds:(UInt32)h2ConnectionKeepaliveTimeoutSeconds
                            maxConnectionsPerHost:(UInt32)maxConnectionsPerHost
                         streamIdleTimeoutSeconds:(UInt32)streamIdleTimeoutSeconds
                         perTryIdleTimeoutSeconds:(UInt32)perTryIdleTimeoutSeconds
                                       appVersion:(NSString *)appVersion
                                            appId:(NSString *)appId
                                    runtimeGuards:
                                        (NSDictionary<NSString *, NSString *> *)runtimeGuards
                                nativeFilterChain:
                                    (NSArray<EnvoyNativeFilterConfig *> *)nativeFilterChain
                              platformFilterChain:
                                  (NSArray<EnvoyHTTPFilterFactory *> *)httpPlatformFilterFactories
                                  stringAccessors:
                                      (NSDictionary<NSString *, EnvoyStringAccessor *> *)
                                          stringAccessors
                                   keyValueStores:
                                       (NSDictionary<NSString *, id<EnvoyKeyValueStore>> *)
                                           keyValueStores
                                           nodeId:(nullable NSString *)nodeId
                                       nodeRegion:(nullable NSString *)nodeRegion
                                         nodeZone:(nullable NSString *)nodeZone
                                      nodeSubZone:(nullable NSString *)nodeSubZone
                                 xdsServerAddress:(nullable NSString *)xdsServerAddress
                                    xdsServerPort:(UInt32)xdsServerPort
                           xdsGrpcInitialMetadata:
                               (NSDictionary<NSString *, NSString *> *)xdsGrpcInitialMetadata
                                  xdsSslRootCerts:(nullable NSString *)xdsSslRootCerts
                                 rtdsResourceName:(nullable NSString *)rtdsResourceName
                               rtdsTimeoutSeconds:(UInt32)rtdsTimeoutSeconds
                                        enableCds:(BOOL)enableCds
                              cdsResourcesLocator:(nullable NSString *)cdsResourcesLocator
                                cdsTimeoutSeconds:(UInt32)cdsTimeoutSeconds;

/**
 Generate a string description of the C++ Envoy bootstrap from this configuration.
 For testing purposes only.
 */
- (NSString *)bootstrapDebugDescription;

@end

NS_ASSUME_NONNULL_END
#pragma once

#import <Foundation/Foundation.h>

@class EnvoyHTTPFilter;

NS_ASSUME_NONNULL_BEGIN

@interface EnvoyHTTPFilterFactory : NSObject

@property (nonatomic, strong) NSString *filterName;

@property (nonatomic, copy) EnvoyHTTPFilter * (^create)();

@end

NS_ASSUME_NONNULL_END
#import "library/objective-c/EnvoyEngine.h"

@implementation EnvoyHTTPCallbacks
@end
#pragma once

#import <Foundation/Foundation.h>

#import "library/objective-c/EnvoyEngine.h"

#import "library/common/extensions/filters/http/platform_bridge/c_types.h"

// Concrete implementation of the `EnvoyHTTPFilterCallbacks` protocol.
@interface EnvoyHTTPFilterCallbacksImpl : NSObject <EnvoyHTTPFilterCallbacks>

- (instancetype)initWithCallbacks:(envoy_http_filter_callbacks)callbacks;

@end
#pragma once

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

// Logging interface.
@interface EnvoyLogger : NSObject

@property (nonatomic, copy) void (^log)(NSString *);

/**
 Create a new instance of the logger.
 */
- (instancetype)initWithLogClosure:(void (^)(NSString *))log;

@end

NS_ASSUME_NONNULL_END
#import "library/objective-c/EnvoyEngine.h"
#import "library/objective-c/EnvoyBridgeUtility.h"
#import "library/objective-c/EnvoyHTTPFilterCallbacksImpl.h"
#import "library/objective-c/EnvoyKeyValueStoreBridgeImpl.h"

#include "library/common/api/c_types.h"

#import "library/common/types/c_types.h"
#import "library/common/extensions/key_value/platform/c_types.h"
#import "library/cc/engine_builder.h"
#import "library/common/engine.h"

#if TARGET_OS_IPHONE
#import <UIKit/UIKit.h>
#endif

@interface EnvoyConfiguration (CXX)
- (std::unique_ptr<envoy::config::bootstrap::v3::Bootstrap>)generateBootstrap;
@end

static void ios_on_engine_running(void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    EnvoyEngineImpl *engineImpl = (__bridge EnvoyEngineImpl *)context;
    if (engineImpl.onEngineRunning) {
      engineImpl.onEngineRunning();
    }
  }
}

static void ios_on_exit(void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    NSLog(@"[Envoy] library is exiting");
  }
}

static void ios_on_log(envoy_data data, const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    EnvoyLogger *logger = (__bridge EnvoyLogger *)context;
    logger.log(to_ios_string(data));
  }
}

static void ios_on_logger_release(const void *context) { CFRelease(context); }

static const void *ios_http_filter_init(const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    envoy_http_filter *c_filter = (envoy_http_filter *)context;

    EnvoyHTTPFilterFactory *filterFactory =
        (__bridge EnvoyHTTPFilterFactory *)c_filter->static_context;
    EnvoyHTTPFilter *filter = filterFactory.create();

    // Unset static functions on the c_struct based on the created filter
    if (filter.onRequestHeaders == nil) {
      c_filter->on_request_headers = NULL;
    }
    if (filter.onRequestData == nil) {
      c_filter->on_request_data = NULL;
    }
    if (filter.onRequestTrailers == nil) {
      c_filter->on_request_trailers = NULL;
    }

    if (filter.onResponseHeaders == nil) {
      c_filter->on_response_headers = NULL;
    }
    if (filter.onResponseData == nil) {
      c_filter->on_response_data = NULL;
    }
    if (filter.onResponseTrailers == nil) {
      c_filter->on_response_trailers = NULL;
    }

    if (filter.setRequestFilterCallbacks == nil) {
      c_filter->set_request_callbacks = NULL;
    }
    if (filter.onResumeRequest == nil) {
      c_filter->on_resume_request = NULL;
    }

    if (filter.setResponseFilterCallbacks == nil) {
      c_filter->set_response_callbacks = NULL;
    }
    if (filter.onResumeResponse == nil) {
      c_filter->on_resume_response = NULL;
    }

    if (filter.onCancel == nil) {
      c_filter->on_cancel = NULL;
    }
    if (filter.onError == nil) {
      c_filter->on_error = NULL;
    }

    return CFBridgingRetain(filter);
  }
}

static envoy_filter_headers_status
ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream,
                                   envoy_stream_intel stream_intel, const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    // TODO(goaway): optimize unmodified case
    EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;
    if (filter.onRequestHeaders == nil) {
      return (envoy_filter_headers_status){/*status*/ kEnvoyFilterHeadersStatusContinue,
                                           /*headers*/ headers};
    }

    EnvoyHeaders *platformHeaders = to_ios_headers(headers);
    // TODO(goaway): consider better solution for compound return
    NSArray *result = filter.onRequestHeaders(platformHeaders, end_stream, stream_intel);
    return (envoy_filter_headers_status){/*status*/ [result[0] intValue],
                                         /*headers*/ toNativeHeaders(result[1])};
  }
}

static envoy_filter_headers_status
ios_http_filter_on_response_headers(envoy_headers headers, bool end_stream,
                                    envoy_stream_intel stream_intel, const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    // TODO(goaway): optimize unmodified case
    EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;
    if (filter.onResponseHeaders == nil) {
      return (envoy_filter_headers_status){/*status*/ kEnvoyFilterHeadersStatusContinue,
                                           /*headers*/ headers};
    }

    EnvoyHeaders *platformHeaders = to_ios_headers(headers);
    NSArray *result = filter.onResponseHeaders(platformHeaders, end_stream, stream_intel);
    return (envoy_filter_headers_status){/*status*/ [result[0] intValue],
                                         /*headers*/ toNativeHeaders(result[1])};
  }
}

static envoy_filter_data_status ios_http_filter_on_request_data(envoy_data data, bool end_stream,
                                                                envoy_stream_intel stream_intel,
                                                                const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;
    if (filter.onRequestData == nil) {
      return (envoy_filter_data_status){/*status*/ kEnvoyFilterDataStatusContinue,
                                        /*data*/ data,
                                        /*pending_headers*/ NULL};
    }

    NSData *platformData = to_ios_data(data);
    NSArray *result = filter.onRequestData(platformData, end_stream, stream_intel);
    // Result is typically a pair of status and entity, but uniquely in the case of
    // ResumeIteration it will (optionally) contain additional pending elements.
    envoy_headers *pending_headers = toNativeHeadersPtr(result.count == 3 ? result[2] : nil);
    return (envoy_filter_data_status){/*status*/ [result[0] intValue],
                                      /*data*/ toNativeData(result[1]),
                                      /*pending_headers*/ pending_headers};
  }
}

static envoy_filter_data_status ios_http_filter_on_response_data(envoy_data data, bool end_stream,
                                                                 envoy_stream_intel stream_intel,
                                                                 const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;
    if (filter.onResponseData == nil) {
      return (envoy_filter_data_status){/*status*/ kEnvoyFilterDataStatusContinue,
                                        /*data*/ data,
                                        /*pending_headers*/ NULL};
    }

    NSData *platformData = to_ios_data(data);
    NSArray *result = filter.onResponseData(platformData, end_stream, stream_intel);
    // Result is typically a pair of status and entity, but uniquely in the case of
    // ResumeIteration it will (optionally) contain additional pending elements.
    envoy_headers *pending_headers = toNativeHeadersPtr(result.count == 3 ? result[2] : nil);
    return (envoy_filter_data_status){/*status*/ [result[0] intValue],
                                      /*data*/ toNativeData(result[1]),
                                      /*pending_headers*/ pending_headers};
  }
}

static envoy_filter_trailers_status
ios_http_filter_on_request_trailers(envoy_headers trailers, envoy_stream_intel stream_intel,
                                    const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;
    if (filter.onRequestTrailers == nil) {
      return (envoy_filter_trailers_status){/*status*/ kEnvoyFilterTrailersStatusContinue,
                                            /*trailers*/ trailers,
                                            /*pending_headers*/ NULL,
                                            /*pending_trailers*/ NULL};
    }

    EnvoyHeaders *platformTrailers = to_ios_headers(trailers);
    NSArray *result = filter.onRequestTrailers(platformTrailers, stream_intel);
    envoy_headers *pending_headers = NULL;
    envoy_data *pending_data = NULL;
    // Result is typically a pair of status and entity, but uniquely in the case of
    // ResumeIteration it will (optionally) contain additional pending elements.
    if (result.count == 4) {
      pending_headers = toNativeHeadersPtr(result[2]);
      pending_data = toNativeDataPtr(result[3]);
    }
    return (envoy_filter_trailers_status){/*status*/ [result[0] intValue],
                                          /*trailers*/ toNativeHeaders(result[1]),
                                          /*pending_headers*/ pending_headers,
                                          /*pending_data*/ pending_data};
  }
}

static envoy_filter_trailers_status
ios_http_filter_on_response_trailers(envoy_headers trailers, envoy_stream_intel stream_intel,
                                     const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;
    if (filter.onResponseTrailers == nil) {
      return (envoy_filter_trailers_status){/*status*/ kEnvoyFilterTrailersStatusContinue,
                                            /*trailers*/ trailers,
                                            /*pending_headers*/ NULL,
                                            /*pending_data*/ NULL};
    }

    EnvoyHeaders *platformTrailers = to_ios_headers(trailers);
    NSArray *result = filter.onResponseTrailers(platformTrailers, stream_intel);
    envoy_headers *pending_headers = NULL;
    envoy_data *pending_data = NULL;
    // Result is typically a pair of status and entity, but uniquely in the case of
    // ResumeIteration it will (optionally) contain additional pending elements.
    if (result.count == 4) {
      pending_headers = toNativeHeadersPtr(result[2]);
      pending_data = toNativeDataPtr(result[3]);
    }
    return (envoy_filter_trailers_status){/*status*/ [result[0] intValue],
                                          /*trailers*/ toNativeHeaders(result[1]),
                                          /*pending_headers*/ pending_headers,
                                          /*pending_data*/ pending_data};
  }
}

static envoy_filter_resume_status
ios_http_filter_on_resume_request(envoy_headers *headers, envoy_data *data, envoy_headers *trailers,
                                  bool end_stream, envoy_stream_intel stream_intel,
                                  const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;
    if (filter.onResumeRequest == nil) {
      return (envoy_filter_resume_status){/*status*/ kEnvoyFilterResumeStatusResumeIteration,
                                          /*pending_headers*/ headers,
                                          /*pending_data*/ data,
                                          /*pending_trailers*/ trailers};
    }

    EnvoyHeaders *pendingHeaders = headers ? to_ios_headers(*headers) : nil;
    NSData *pendingData = data ? to_ios_data(*data) : nil;
    EnvoyHeaders *pendingTrailers = trailers ? to_ios_headers(*trailers) : nil;
    NSArray *result = filter.onResumeRequest(pendingHeaders, pendingData, pendingTrailers,
                                             end_stream, stream_intel);
    return (envoy_filter_resume_status){/*status*/ [result[0] intValue],
                                        /*pending_headers*/ toNativeHeadersPtr(result[1]),
                                        /*pending_data*/ toNativeDataPtr(result[2]),
                                        /*pending_trailers*/ toNativeHeadersPtr(result[3])};
  }
}

static envoy_filter_resume_status
ios_http_filter_on_resume_response(envoy_headers *headers, envoy_data *data,
                                   envoy_headers *trailers, bool end_stream,
                                   envoy_stream_intel stream_intel, const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;
    if (filter.onResumeResponse == nil) {
      return (envoy_filter_resume_status){/*status*/ kEnvoyFilterResumeStatusResumeIteration,
                                          /*pending_headers*/ headers,
                                          /*pending_data*/ data,
                                          /*pending_trailers*/ trailers};
    }

    EnvoyHeaders *pendingHeaders = headers ? to_ios_headers(*headers) : nil;
    NSData *pendingData = data ? to_ios_data(*data) : nil;
    EnvoyHeaders *pendingTrailers = trailers ? to_ios_headers(*trailers) : nil;
    NSArray *result = filter.onResumeResponse(pendingHeaders, pendingData, pendingTrailers,
                                              end_stream, stream_intel);
    return (envoy_filter_resume_status){/*status*/ [result[0] intValue],
                                        /*pending_headers*/ toNativeHeadersPtr(result[1]),
                                        /*pending_data*/ toNativeDataPtr(result[2]),
                                        /*pending_trailers*/ toNativeHeadersPtr(result[3])};
  }
}

static void ios_http_filter_set_request_callbacks(envoy_http_filter_callbacks callbacks,
                                                  const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;
    if (filter.setRequestFilterCallbacks == nil) {
      return;
    }

    EnvoyHTTPFilterCallbacksImpl *requestFilterCallbacks =
        [[EnvoyHTTPFilterCallbacksImpl alloc] initWithCallbacks:callbacks];
    filter.setRequestFilterCallbacks(requestFilterCallbacks);
  }
}

static void ios_http_filter_set_response_callbacks(envoy_http_filter_callbacks callbacks,
                                                   const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;
    if (filter.setResponseFilterCallbacks == nil) {
      return;
    }

    EnvoyHTTPFilterCallbacksImpl *responseFilterCallbacks =
        [[EnvoyHTTPFilterCallbacksImpl alloc] initWithCallbacks:callbacks];
    filter.setResponseFilterCallbacks(responseFilterCallbacks);
  }
}

static void ios_http_filter_on_cancel(envoy_stream_intel stream_intel,
                                      envoy_final_stream_intel final_stream_intel,
                                      const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;
    if (filter.onCancel == nil) {
      return;
    }
    filter.onCancel(stream_intel, final_stream_intel);
  }
}

static void ios_http_filter_on_error(envoy_error error, envoy_stream_intel stream_intel,
                                     envoy_final_stream_intel final_stream_intel,
                                     const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;
    if (filter.onError == nil) {
      release_envoy_error(error);
      return;
    }

    NSString *errorMessage = [[NSString alloc] initWithBytes:error.message.bytes
                                                      length:error.message.length
                                                    encoding:NSUTF8StringEncoding];

    release_envoy_error(error);
    filter.onError(error.error_code, errorMessage, error.attempt_count, stream_intel,
                   final_stream_intel);
  }
}

static void ios_http_filter_release(const void *context) {
  CFRelease(context);
  return;
}

static envoy_data ios_get_string(const void *context) {
  EnvoyStringAccessor *accessor = (__bridge EnvoyStringAccessor *)context;
  return toManagedNativeString(accessor.getEnvoyString());
}

static void ios_track_event(envoy_map map, const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    EnvoyEventTracker *eventTracker = (__bridge EnvoyEventTracker *)context;
    eventTracker.track(to_ios_map(map));
  }
}

@implementation EnvoyEngineImpl {
  envoy_engine_t _engineHandle;
  Envoy::Engine *_engine;
  EnvoyNetworkMonitor *_networkMonitor;
}

- (instancetype)initWithRunningCallback:(nullable void (^)())onEngineRunning
                                 logger:(nullable void (^)(NSString *))logger
                           eventTracker:(nullable void (^)(EnvoyEvent *))eventTracker
                  networkMonitoringMode:(int)networkMonitoringMode {
  self = [super init];
  if (!self) {
    return nil;
  }

  self.onEngineRunning = onEngineRunning;
  envoy_engine_callbacks native_callbacks = {ios_on_engine_running, ios_on_exit,
                                             (__bridge void *)(self)};

  envoy_logger native_logger = {NULL, NULL, NULL};
  if (logger) {
    EnvoyLogger *objcLogger = [[EnvoyLogger alloc] initWithLogClosure:logger];
    native_logger.log = ios_on_log;
    native_logger.release = ios_on_logger_release;
    native_logger.context = CFBridgingRetain(objcLogger);
  }

  // TODO(Augustyniak): Everything here leaks, but it's all tied to the life of the engine.
  // This will need to be updated for https://github.com/envoyproxy/envoy-mobile/issues/332.
  envoy_event_tracker native_event_tracker = {NULL, NULL};
  if (eventTracker) {
    EnvoyEventTracker *objcEventTracker =
        [[EnvoyEventTracker alloc] initWithEventTrackingClosure:eventTracker];
    native_event_tracker.track = ios_track_event;
    native_event_tracker.context = CFBridgingRetain(objcEventTracker);
  }

  _engine = new Envoy::Engine(native_callbacks, native_logger, native_event_tracker);
  _engineHandle = reinterpret_cast<envoy_engine_t>(_engine);

  if (networkMonitoringMode == 1) {
    [_networkMonitor startReachability];
  } else if (networkMonitoringMode == 2) {
    [_networkMonitor startPathMonitor];
  }

  return self;
}

- (void)dealloc {
  [[NSNotificationCenter defaultCenter] removeObserver:self];
}

- (int)registerFilterFactory:(EnvoyHTTPFilterFactory *)filterFactory {
  // TODO(goaway): Everything here leaks, but it's all be tied to the life of the engine.
  // This will need to be updated for https://github.com/envoyproxy/envoy-mobile/issues/332
  envoy_http_filter *api = (envoy_http_filter *)safe_malloc(sizeof(envoy_http_filter));
  api->init_filter = ios_http_filter_init;
  api->on_request_headers = ios_http_filter_on_request_headers;
  api->on_request_data = ios_http_filter_on_request_data;
  api->on_request_trailers = ios_http_filter_on_request_trailers;
  api->on_response_headers = ios_http_filter_on_response_headers;
  api->on_response_data = ios_http_filter_on_response_data;
  api->on_response_trailers = ios_http_filter_on_response_trailers;
  api->set_request_callbacks = ios_http_filter_set_request_callbacks;
  api->on_resume_request = ios_http_filter_on_resume_request;
  api->set_response_callbacks = ios_http_filter_set_response_callbacks;
  api->on_resume_response = ios_http_filter_on_resume_response;
  // TODO(goaway) HTTP filter on_complete not currently implemented.
  // api->on_complete = ios_http_filter_on_complete;
  api->on_cancel = ios_http_filter_on_cancel;
  api->on_error = ios_http_filter_on_error;
  api->release_filter = ios_http_filter_release;
  api->static_context = CFBridgingRetain(filterFactory);
  api->instance_context = NULL;

  Envoy::Api::External::registerApi(filterFactory.filterName.UTF8String, api);
  return kEnvoySuccess;
}

- (int)registerStringAccessor:(NSString *)name accessor:(EnvoyStringAccessor *)accessor {
  // TODO(goaway): Everything here leaks, but it's all tied to the life of the engine.
  // This will need to be updated for https://github.com/envoyproxy/envoy-mobile/issues/332
  envoy_string_accessor *accessorStruct =
      (envoy_string_accessor *)safe_malloc(sizeof(envoy_string_accessor));
  accessorStruct->get_string = ios_get_string;
  accessorStruct->context = CFBridgingRetain(accessor);

  Envoy::Api::External::registerApi(name.UTF8String, accessorStruct);
  return ENVOY_SUCCESS;
}

- (int)registerKeyValueStore:(NSString *)name keyValueStore:(id<EnvoyKeyValueStore>)keyValueStore {
  envoy_kv_store *api = (envoy_kv_store *)safe_malloc(sizeof(envoy_kv_store));
  api->save = ios_kv_store_save;
  api->read = ios_kv_store_read;
  api->remove = ios_kv_store_remove;
  api->context = CFBridgingRetain(keyValueStore);

  Envoy::Api::External::registerApi(name.UTF8String, api);
  return ENVOY_SUCCESS;
}

- (void)performRegistrationsForConfig:(EnvoyConfiguration *)config {
  for (EnvoyHTTPFilterFactory *filterFactory in config.httpPlatformFilterFactories) {
    [self registerFilterFactory:filterFactory];
  }

  for (NSString *name in config.stringAccessors) {
    [self registerStringAccessor:name accessor:config.stringAccessors[name]];
  }

  for (NSString *name in config.keyValueStores) {
    [self registerKeyValueStore:name keyValueStore:config.keyValueStores[name]];
  }
}

- (int)runWithConfig:(EnvoyConfiguration *)config logLevel:(NSString *)logLevel {
  std::unique_ptr<envoy::config::bootstrap::v3::Bootstrap> bootstrap;
  if (config.bootstrapPointer > 0) {
    bootstrap = absl::WrapUnique(
        reinterpret_cast<envoy::config::bootstrap::v3::Bootstrap *>(config.bootstrapPointer));
  } else {
    bootstrap = [config generateBootstrap];
  }

  if (bootstrap == nullptr) {
    return kEnvoyFailure;
  }

  [self performRegistrationsForConfig:config];
  [self startObservingLifecycleNotifications];

  @try {
    auto options = std::make_unique<Envoy::OptionsImplBase>();
    options->setConfigProto(std::move(bootstrap));
    ENVOY_BUG(options->setLogLevel(logLevel.UTF8String).ok(), "invalid log level");
    options->setConcurrency(1);
    return _engine->run(std::move(options));
  } @catch (NSException *exception) {
    [self logException:exception];
    return kEnvoyFailure;
  }
}

- (int)runWithYAML:(NSString *)yaml
            config:(EnvoyConfiguration *)config
          logLevel:(NSString *)logLevel {
  [self performRegistrationsForConfig:config];
  [self startObservingLifecycleNotifications];

  @try {
    return _engine->run(yaml.UTF8String, logLevel.UTF8String);
  } @catch (NSException *exception) {
    [self logException:exception];
    return kEnvoyFailure;
  }
}

- (id<EnvoyHTTPStream>)startStreamWithCallbacks:(EnvoyHTTPCallbacks *)callbacks
                            explicitFlowControl:(BOOL)explicitFlowControl {
  return [[EnvoyHTTPStreamImpl alloc] initWithHandle:_engine->initStream()
                                              engine:reinterpret_cast<envoy_engine_t>(_engine)
                                           callbacks:callbacks
                                 explicitFlowControl:explicitFlowControl];
}

- (int)recordCounterInc:(NSString *)elements tags:(EnvoyTags *)tags count:(NSUInteger)count {
  // TODO: update to use real tag array when the API layer change is ready.
  return _engine->recordCounterInc(elements.UTF8String, toNativeStatsTags(tags), count);
}

- (NSString *)dumpStats {
  envoy_data data;
  envoy_status_t status = _engine->dumpStats(&data);
  if (status != ENVOY_SUCCESS) {
    return @"";
  }

  NSString *stringCopy = [[NSString alloc] initWithBytes:data.bytes
                                                  length:data.length
                                                encoding:NSUTF8StringEncoding];
  release_envoy_data(data);
  return stringCopy;
}

- (void)terminate {
  _engine->terminate();
}

- (void)resetConnectivityState {
  _engine->resetConnectivityState();
}

#pragma mark - Private

- (void)startObservingLifecycleNotifications {
#if TARGET_OS_IPHONE
  // re-enable lifecycle-based stat flushing when
  // https://github.com/envoyproxy/envoy-mobile/issues/748 gets fixed.
  NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
  [notificationCenter addObserver:self
                         selector:@selector(terminateNotification:)
                             name:UIApplicationWillTerminateNotification
                           object:nil];
#endif
}

- (void)terminateNotification:(NSNotification *)notification {
  NSLog(@"[Envoy %ld] terminating engine (%@)", _engineHandle, notification.name);
  _engine->terminate();
}

- (void)logException:(NSException *)exception {
  NSLog(@"[Envoy] exception caught: %@", exception);

  NSString *message = [NSString stringWithFormat:@"%@;%@;%@", exception.name, exception.reason,
                                                 exception.callStackSymbols.description];
  ENVOY_LOG_EVENT_TO_LOGGER(Envoy::Logger::Registry::getLog(Envoy::Logger::Id::misc), error,
                            "handled_cxx_exception", [message UTF8String]);

  [NSNotificationCenter.defaultCenter postNotificationName:@"EnvoyHandledCXXException"
                                                    object:exception];
}

@end
#pragma once

#import "library/common/types/c_types.h"
#import "library/objective-c/EnvoyKeyValueStore.h"

/// Save a value to the key value store that's passed as an opaque context.
void ios_kv_store_save(envoy_data native_key, envoy_data native_value, const void* context);

/// Read a value from the key value store that's passed as an opaque context.
envoy_data ios_kv_store_read(envoy_data native_key, const void* context);

/// Remove a value from the key value store that's passed as an opaque context.
void ios_kv_store_remove(envoy_data native_key, const void* context);
#pragma once

#import <Foundation/Foundation.h>

#import "library/objective-c/EnvoyAliases.h"

#import "library/common/types/c_types.h"

NS_ASSUME_NONNULL_BEGIN

#pragma mark - EnvoyHTTPStream

@protocol EnvoyHTTPStream

/**
 Open an underlying HTTP stream.

 @param handle Underlying handle of the HTTP stream owned by an Envoy engine.
 @param engine Underlying handle of the Envoy engine.
 @param callbacks The callbacks for the stream.
 @param explicitFlowControl Whether explicit flow control will be enabled for this stream.
 */
- (instancetype)initWithHandle:(intptr_t)handle
                        engine:(intptr_t)engineHandle
                     callbacks:(EnvoyHTTPCallbacks *)callbacks
           explicitFlowControl:(BOOL)explicitFlowControl;

/**
 Send headers over the provided stream.

 @param headers Headers to send over the stream.
 @param close True if the stream should be closed after sending.
 */
- (void)sendHeaders:(EnvoyHeaders *)headers close:(BOOL)close;

/**
 Read data from the response stream. Returns immediately.
 Has no effect if explicit flow control is not enabled.

 @param byteCount Maximum number of bytes that may be be passed by the next data callback.
 */
- (void)readData:(size_t)byteCount;

/**
 Send data over the provided stream.

 @param data Data to send over the stream.
 @param close True if the stream should be closed after sending.
 */
- (void)sendData:(NSData *)data close:(BOOL)close;

/**
 Send trailers over the provided stream.

 @param trailers Trailers to send over the stream.
 */
- (void)sendTrailers:(EnvoyHeaders *)trailers;

/**
 Cancel the stream. This functions as an interrupt, and aborts further callbacks and handling of the
 stream.

 @return Success unless the stream has already been canceled.
 */
- (int)cancel;

/**
 Clean up the stream after it's closed (by completion, cancellation, or error).
 */
- (void)cleanUp;

@end

#pragma mark - EnvoyHTTPStreamImpl

// Concrete implementation of the `EnvoyHTTPStream` protocol.
@interface EnvoyHTTPStreamImpl : NSObject <EnvoyHTTPStream>

@end

NS_ASSUME_NONNULL_END
#import "library/objective-c/EnvoyEngine.h"

@implementation EnvoyStringAccessor

- (instancetype)initWithBlock:(NSString * (^)())block {
  self = [super init];
  if (!self) {
    return nil;
  }

  self.getEnvoyString = block;
  return self;
}

@end
#import "library/objective-c/EnvoyEngine.h"

@implementation EnvoyHTTPFilter
@end
#import "library/objective-c/EnvoyEngine.h"

#import "library/common/engine.h"

#import <Foundation/Foundation.h>
#import <Network/Network.h>
#import <SystemConfiguration/SystemConfiguration.h>

@implementation EnvoyNetworkMonitor {
  Envoy::Engine *_engine;
  nw_path_monitor_t _path_monitor;
  SCNetworkReachabilityRef _reachability_ref;
}

- (instancetype)initWithEngine:(envoy_engine_t)engineHandle {
  self = [super init];
  if (!self) {
    return nil;
  }

  _engine = reinterpret_cast<Envoy::Engine *>(engineHandle);
  return self;
}

- (void)dealloc {
  if (_path_monitor) {
    nw_path_monitor_cancel(_path_monitor);
  }
  if (_reachability_ref) {
    SCNetworkReachabilitySetCallback(_reachability_ref, nil, nil);
    SCNetworkReachabilitySetDispatchQueue(_reachability_ref, nil);
    CFRelease(_reachability_ref);
  }
}

- (void)startPathMonitor {
  _path_monitor = nw_path_monitor_create();

  dispatch_queue_attr_t attrs = dispatch_queue_attr_make_with_qos_class(
      DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, DISPATCH_QUEUE_PRIORITY_DEFAULT);
  dispatch_queue_t queue =
      dispatch_queue_create("io.envoyproxy.envoymobile.EnvoyNetworkMonitor", attrs);
  nw_path_monitor_set_queue(_path_monitor, queue);

  __block envoy_network_t previousNetworkType = (envoy_network_t)-1;
  Envoy::Engine *engine = _engine;
  nw_path_monitor_set_update_handler(_path_monitor, ^(nw_path_t _Nonnull path) {
    BOOL isSatisfied = nw_path_get_status(path) == nw_path_status_satisfied;
    if (!isSatisfied) {
      // TODO(jpsim): Handle all possible path status values
      //
      // - nw_path_status_invalid: The path is not valid.
      // - nw_path_status_unsatisfied: The path is not available for use.
      // - nw_path_status_satisfied: The path is available to establish connections and send data.
      // - nw_path_status_satisfiable: The path is not currently available, but establishing a new
      // connection may activate the path.
      return;
    }

    BOOL isCellular = nw_path_uses_interface_type(path, nw_interface_type_cellular);
    envoy_network_t network = ENVOY_NET_WWAN;
    if (!isCellular) {
      BOOL isWifi = nw_path_uses_interface_type(path, nw_interface_type_wifi);
      network = isWifi ? ENVOY_NET_WLAN : ENVOY_NET_GENERIC;
    }

    if (network != previousNetworkType) {
      NSLog(@"[Envoy] setting preferred network to %d", network);
      engine->setPreferredNetwork(network);
      previousNetworkType = network;
    }

    // TODO(jpsim): Should we shadow or otherwise compare these results with the reachability
    // flags?

    // TODO(jpsim): Should we report back other properties of the reachable path?
    //
    // - nw_path_get_status:
    // https://developer.apple.com/documentation/network/2976886-nw_path_get_status
    // - nw_path_uses_interface_type:
    // https://developer.apple.com/documentation/network/2976898-nw_path_uses_interface_type
    // - nw_path_enumerate_gateways:
    // https://developer.apple.com/documentation/network/3175017-nw_path_enumerate_gateways
    // - nw_path_has_ipv4:
    // https://developer.apple.com/documentation/network/2976888-nw_path_has_ipv4
    // - nw_path_has_ipv6:
    // https://developer.apple.com/documentation/network/2976889-nw_path_has_ipv6
    // - nw_path_has_dns:
    // https://developer.apple.com/documentation/network/2976887-nw_path_has_dns
    // - nw_path_is_constrained:
    // https://developer.apple.com/documentation/network/3131049-nw_path_is_constrained
    // - nw_path_is_expensive:
    // https://developer.apple.com/documentation/network/2976891-nw_path_is_expensive
    // - nw_path_copy_effective_remote_endpoint:
    // https://developer.apple.com/documentation/network/2976883-nw_path_copy_effective_remote_en
  });

  nw_path_monitor_start(_path_monitor);
}

- (void)startReachability {
  NSString *name = @"io.envoyproxy.envoymobile.EnvoyNetworkMonitor";
  SCNetworkReachabilityRef reachability =
      SCNetworkReachabilityCreateWithName(nil, [name UTF8String]);
  if (!reachability) {
    return;
  }

  _reachability_ref = reachability;

  SCNetworkReachabilityContext context = {0, (__bridge void *)self, NULL, NULL, NULL};
  if (!SCNetworkReachabilitySetCallback(_reachability_ref, _reachability_callback, &context)) {
    return;
  }

  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);
  if (!SCNetworkReachabilitySetDispatchQueue(_reachability_ref, queue)) {
    SCNetworkReachabilitySetCallback(_reachability_ref, NULL, NULL);
  }
}

#pragma mark - Private

static void _reachability_callback(SCNetworkReachabilityRef target,
                                   SCNetworkReachabilityFlags flags, void *info) {
  if (flags == 0) {
    return;
  }

#if TARGET_OS_IPHONE
  BOOL isUsingWWAN = flags & kSCNetworkReachabilityFlagsIsWWAN;
#else
  BOOL isUsingWWAN = NO; // Macs don't have WWAN interfaces
#endif

  NSLog(@"[Envoy] setting preferred network to %@", isUsingWWAN ? @"WWAN" : @"WLAN");
  EnvoyNetworkMonitor *monitor = (__bridge EnvoyNetworkMonitor *)info;
  monitor->_engine->setPreferredNetwork(isUsingWWAN ? ENVOY_NET_WWAN : ENVOY_NET_WLAN);
}

@end
#pragma once

#import <Foundation/Foundation.h>

#import "library/common/types/c_types.h"
#import "library/objective-c/EnvoyAliases.h"

static inline envoy_data toNativeData(NSData *data) {
  if (data == nil || [data isEqual:[NSNull null]]) {
    return envoy_nodata;
  }

  uint8_t *native_bytes = (uint8_t *)safe_malloc(sizeof(uint8_t) * data.length);
  memcpy(native_bytes, data.bytes, data.length); // NOLINT(safe-memcpy)
  envoy_data ret = {data.length, native_bytes, free, native_bytes};
  return ret;
}

static inline envoy_data *toNativeDataPtr(NSData *data) {
  if (data == nil || [data isEqual:[NSNull null]]) {
    return NULL;
  }

  envoy_data *ret = (envoy_data *)safe_malloc(sizeof(envoy_data));
  *ret = toNativeData(data);
  return ret;
}

static inline envoy_data toManagedNativeString(NSString *s) {
  size_t length = [s lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);
  memcpy(native_string, s.UTF8String, length); // NOLINT(safe-memcpy)
  envoy_data ret = {length, native_string, free, native_string};
  return ret;
}

static inline envoy_headers toNativeHeaders(EnvoyHeaders *headers) {
  if (headers == nil || [headers isEqual:[NSNull null]]) {
    return envoy_noheaders;
  }

  envoy_map_size_t length = 0;
  for (NSString *headerKey in headers) {
    length += [headers[headerKey] count];
  }
  envoy_map_entry *header_array = (envoy_map_entry *)safe_malloc(sizeof(envoy_map_entry) * length);
  envoy_map_size_t header_index = 0;
  for (id headerKey in headers) {
    NSArray *headerList = headers[headerKey];
    for (NSString *headerValue in headerList) {
      envoy_map_entry new_header = {toManagedNativeString(headerKey),
                                    toManagedNativeString(headerValue)};
      header_array[header_index++] = new_header;
    }
  }
  // TODO: ASSERT(header_index == length);
  envoy_headers ret = {length, header_array};
  return ret;
}

static inline envoy_headers *toNativeHeadersPtr(EnvoyHeaders *headers) {
  if (headers == nil || [headers isEqual:[NSNull null]]) {
    return NULL;
  }

  envoy_headers *ret = (envoy_headers *)safe_malloc(sizeof(envoy_headers));
  *ret = toNativeHeaders(headers);
  return ret;
}

static inline envoy_stats_tags toNativeStatsTags(EnvoyTags *tags) {
  if (tags == nil || [tags isEqual:[NSNull null]]) {
    return envoy_stats_notags;
  }

  int length = (int)[tags count];

  envoy_map_entry *tag_array = (envoy_map_entry *)safe_malloc(sizeof(envoy_map_entry) * length);
  envoy_map_size_t tag_index = 0;
  for (id tagKey in tags) {
    NSString *tagValue = tags[tagKey];

    envoy_map_entry new_tag = {toManagedNativeString(tagKey), toManagedNativeString(tagValue)};
    tag_array[tag_index++] = new_tag;
  }
  envoy_stats_tags ret = {tag_index, tag_array};
  return ret;
}

static inline NSData *to_ios_data(envoy_data data) {
  // TODO: we are copying from envoy_data to NSData.
  // https://github.com/envoyproxy/envoy-mobile/issues/398
  NSData *platformData = [NSData dataWithBytes:(void *)data.bytes length:data.length];
  release_envoy_data(data);
  return platformData;
}

static inline NSString *to_ios_string_no_release(envoy_data data) {
  NSString *platformString = [[NSString alloc] initWithBytes:data.bytes
                                                      length:data.length
                                                    encoding:NSUTF8StringEncoding];

  if (platformString == nil) {
    NSData *bridgedData = [NSData dataWithBytes:(void *)data.bytes length:data.length];
    BOOL usedLossyConversion = NO;
    NSStringEncoding guessedEncoding = [NSString stringEncodingForData:bridgedData
                                                       encodingOptions:@{}
                                                       convertedString:&platformString
                                                   usedLossyConversion:&usedLossyConversion];
    // TODO(jpsim): Use ENVOY_LOG_EVENT to emit log events instead of NSLog.
    // We can't right now because we're not in a C++ context.
    if (platformString == nil) {
      NSLog(@"Could not convert envoy_data (%@ bytes) to NSString", @(data.length));
    } else {
      NSLog(@"envoy_data was converted to NSString using encoding %@: %@", @(guessedEncoding),
            platformString);
    }
  }

  return platformString;
}

static inline NSString *to_ios_string(envoy_data data) {
  NSString *platformString = to_ios_string_no_release(data);
  release_envoy_data(data);
  return platformString;
}

static inline EnvoyEvent *to_ios_map(envoy_map map) {
  NSMutableDictionary *newMap = [NSMutableDictionary new];
  for (envoy_map_size_t i = 0; i < map.length; i++) {
    envoy_map_entry entry = map.entries[i];
    NSString *entryKey = to_ios_string_no_release(entry.key);
    NSString *entryValue = to_ios_string_no_release(entry.value);
    newMap[entryKey] = entryValue;
  }

  release_envoy_map(map);
  return newMap;
}

static inline EnvoyHeaders *to_ios_headers(envoy_headers headers) {
  NSMutableDictionary *headerDict = [NSMutableDictionary new];
  for (envoy_map_size_t i = 0; i < headers.length; i++) {
    envoy_map_entry header = headers.entries[i];
    NSString *headerKey = to_ios_string_no_release(header.key);
    NSString *headerValue = to_ios_string_no_release(header.value);
    // TODO: https://github.com/envoyproxy/envoy-mobile/issues/1825. All header values passed in
    // here should be valid.
    if (headerKey != nil && headerValue != nil) {
      // Ensure list is present in dictionary value
      NSMutableArray *headerValueList = headerDict[headerKey];
      if (headerValueList == nil) {
        headerValueList = [NSMutableArray new];
        headerDict[headerKey] = headerValueList;
      }
      [headerValueList addObject:headerValue];
    }
  }
  // The C envoy_headers struct can be released now because the headers have been copied.
  release_envoy_headers(headers);
  return headerDict;
}
#import "library/objective-c/EnvoyEngine.h"

@implementation EnvoyEventTracker

- (instancetype)initWithEventTrackingClosure:(void (^)(EnvoyEvent *))track {
  self = [super init];
  if (!self) {
    return nil;
  }

  self.track = track;
  return self;
}

@end
#pragma once

#import <Foundation/Foundation.h>

#import "library/objective-c/EnvoyAliases.h"

NS_ASSUME_NONNULL_BEGIN

#pragma mark - EnvoyHTTPCallbacks

/// Interface that can handle callbacks from an HTTP stream.
@interface EnvoyHTTPCallbacks : NSObject

/**
 * Dispatch queue provided to handle callbacks.
 */
@property (nonatomic, assign) dispatch_queue_t dispatchQueue;

/**
 * Called when all headers get received on the async HTTP stream.
 * @param headers the headers received.
 * @param endStream whether the response is headers-only.
 * @param streamIntel internal HTTP stream metrics, context, and other details.
 */
@property (nonatomic, copy, nullable) void (^onHeaders)
    (EnvoyHeaders *headers, BOOL endStream, EnvoyStreamIntel streamIntel);

/**
 * Called when a data frame gets received on the async HTTP stream.
 * This callback can be invoked multiple times if the data gets streamed.
 * @param data the data received.
 * @param endStream whether the data is the last data frame.
 * @param streamIntel internal HTTP stream metrics, context, and other details.
 */
@property (nonatomic, copy, nullable) void (^onData)
    (NSData *data, BOOL endStream, EnvoyStreamIntel streamIntel);

/**
 * Called when all trailers get received on the async HTTP stream.
 * Note that end stream is implied when on_trailers is called.
 * @param trailers the trailers received.
 * @param streamIntel internal HTTP stream metrics, context, and other details.
 */
@property (nonatomic, copy, nullable) void (^onTrailers)
    (EnvoyHeaders *trailers, EnvoyStreamIntel streamIntel);

/**
 * Called to signal there is buffer space available for continued request body upload.
 *
 * This is only ever called when the library is in explicit flow control mode. When enabled,
 * the issuer should wait for this callback after calling sendData, before making another call
 * to sendData.
 * @param streamIntel internal HTTP stream metrics, context, and other details.
 */
@property (nonatomic, copy, nullable) void (^onSendWindowAvailable)(EnvoyStreamIntel streamIntel);

/**
 * Called when the async HTTP stream has an error.
 * @param streamIntel internal HTTP stream metrics, context, and other details.
 * @param finalStreamIntel one time HTTP stream metrics, context, and other details.
 */
@property (nonatomic, copy, nullable) void (^onError)
    (uint64_t errorCode, NSString *message, int32_t attemptCount, EnvoyStreamIntel streamIntel,
     EnvoyFinalStreamIntel finalStreamIntel);

/**
 * Called when the async HTTP stream is canceled.
 * Note this callback will ALWAYS be fired if a stream is canceled, even if the request and/or
 * response is already complete. It will fire no more than once, and no other callbacks for the
 * stream will be issued afterwards.
 * @param streamIntel internal HTTP stream metrics, context, and other details.
 * @param finalStreamIntel one time HTTP stream metrics, context, and other details.
 */
@property (nonatomic, copy, nullable) void (^onCancel)
    (EnvoyStreamIntel streamIntel, EnvoyFinalStreamIntel finalStreamIntel);

/**
 * Final call made when an HTTP stream is closed gracefully.
 * Note this may already be inferred from a prior callback with endStream=TRUE, and this only needs
 * to be handled if information from finalStreamIntel is desired.
 * @param streamIntel internal HTTP stream metrics, context, and other details.
 * @param finalStreamIntel one time HTTP stream metrics, context, and other details.
 */
@property (nonatomic, copy, nullable) void (^onComplete)
    (EnvoyStreamIntel streamIntel, EnvoyFinalStreamIntel finalStreamIntel);

@end

NS_ASSUME_NONNULL_END
#import "library/objective-c/EnvoyEngine.h"

@implementation EnvoyHTTPFilterFactory
@end
#import "library/objective-c/EnvoyEngine.h"

@implementation EnvoyNativeFilterConfig

- (instancetype)initWithName:(NSString *)name typedConfig:(NSString *)typedConfig {
  self = [super init];
  if (!self) {
    return nil;
  }

  self.name = name;
  self.typedConfig = typedConfig;
  return self;
}

@end
#pragma once

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@protocol EnvoyKeyValueStore

/// Read a value from the key value store implementation.
- (NSString *_Nullable)readValueForKey:(NSString *)key;

/// Save a value to the key value store implementation.
- (void)saveValue:(NSString *)value toKey:(NSString *)key;

/// Remove a value from the key value store implementation.
- (void)removeKey:(NSString *)key;

@end

NS_ASSUME_NONNULL_END
#import "library/objective-c/EnvoyKeyValueStoreBridgeImpl.h"

#import "library/objective-c/EnvoyBridgeUtility.h"

envoy_data ios_kv_store_read(envoy_data native_key, const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    id<EnvoyKeyValueStore> keyValueStore = (__bridge id<EnvoyKeyValueStore>)context;
    NSString *key = [[NSString alloc] initWithBytes:native_key.bytes
                                             length:native_key.length
                                           encoding:NSUTF8StringEncoding];
    NSString *value = [keyValueStore readValueForKey:key];
    return value != nil ? toManagedNativeString(value) : envoy_nodata;
  }
}

void ios_kv_store_save(envoy_data native_key, envoy_data native_value, const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    id<EnvoyKeyValueStore> keyValueStore = (__bridge id<EnvoyKeyValueStore>)context;
    NSString *key = [[NSString alloc] initWithBytes:native_key.bytes
                                             length:native_key.length
                                           encoding:NSUTF8StringEncoding];
    NSString *value = [[NSString alloc] initWithBytes:native_value.bytes
                                               length:native_value.length
                                             encoding:NSUTF8StringEncoding];
    [keyValueStore saveValue:value toKey:key];
  }
}

void ios_kv_store_remove(envoy_data native_key, const void *context) {
  // This code block runs inside the Envoy event loop. Therefore, an explicit autoreleasepool block
  // is necessary to act as a breaker for any Objective-C allocation that happens.
  @autoreleasepool {
    id<EnvoyKeyValueStore> keyValueStore = (__bridge id<EnvoyKeyValueStore>)context;
    NSString *key = [[NSString alloc] initWithBytes:native_key.bytes
                                             length:native_key.length
                                           encoding:NSUTF8StringEncoding];
    [keyValueStore removeKey:key];
  }
}
#pragma once

#import <Foundation/Foundation.h>

#import "library/common/types/c_types.h"

NS_ASSUME_NONNULL_BEGIN

/// Return codes for Engine interface. @see /library/common/types/c_types.h
extern const int kEnvoySuccess;
extern const int kEnvoyFailure;

/// A set of headers that may be passed to/from an Envoy stream.
typedef NSDictionary<NSString *, NSArray<NSString *> *> EnvoyHeaders;

typedef NSDictionary<NSString *, NSString *> EnvoyTags;

/// A set of key-value pairs describing an event.
typedef NSDictionary<NSString *, NSString *> EnvoyEvent;

/// Contains internal HTTP stream metrics, context, and other details.
typedef envoy_stream_intel EnvoyStreamIntel;

// Contains one time HTTP stream metrics, context, and other details.
typedef envoy_final_stream_intel EnvoyFinalStreamIntel;

NS_ASSUME_NONNULL_END
#import "library/objective-c/EnvoyEngine.h"

@implementation EnvoyLogger

- (instancetype)initWithLogClosure:(void (^)(NSString *))log {
  self = [super init];
  if (!self) {
    return nil;
  }

  self.log = log;
  return self;
}
@end
#import "library/objective-c/EnvoyHTTPFilterCallbacksImpl.h"

#pragma mark - EnvoyHTTPFilterCallbacksImpl

@implementation EnvoyHTTPFilterCallbacksImpl {
  envoy_http_filter_callbacks _callbacks;
}

- (instancetype)initWithCallbacks:(envoy_http_filter_callbacks)callbacks {
  self = [super init];
  if (!self) {
    return nil;
  }

  _callbacks = callbacks;
  return self;
}

- (void)resumeIteration {
  _callbacks.resume_iteration(_callbacks.callback_context);
}

- (void)resetIdleTimer {
  _callbacks.reset_idle(_callbacks.callback_context);
}

- (void)dealloc {
  _callbacks.release_callbacks(_callbacks.callback_context);
}

@end
#pragma once

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

typedef NS_ENUM(NSInteger, EMOMatchMode) {
  EMOMatchModeContains,
  EMOMatchModeExact,
  EMOMatchModePrefix,
  EMOMatchModeSuffix
};

@interface EMOHeaderMatcher : NSObject

@property (nonatomic, strong) NSString *name;
@property (nonatomic, strong) NSString *value;
@property (nonatomic) EMOMatchMode mode;

@end

@interface EMORouteMatcher : NSObject

@property (nonatomic, strong, nullable) NSString *fullPath;
@property (nonatomic, strong, nullable) NSString *pathPrefix;
@property (nonatomic, strong) NSArray<EMOHeaderMatcher *> *headers;

@end

@interface EMODirectResponse : NSObject

@property (nonatomic, strong) EMORouteMatcher *matcher;
@property (nonatomic) NSUInteger status;
@property (nonatomic, strong, nullable) NSString *body;
@property (nonatomic, strong) NSDictionary<NSString *, NSString *> *headers;

@end

NS_ASSUME_NONNULL_END
#pragma once

#import <Foundation/Foundation.h>

#import "library/objective-c/EnvoyAliases.h"

#import "library/common/types/c_types.h"

NS_ASSUME_NONNULL_BEGIN

/// Return codes for on-headers filter invocations. @see envoy/http/filter.h
extern const int kEnvoyFilterHeadersStatusContinue;
extern const int kEnvoyFilterHeadersStatusStopIteration;
extern const int kEnvoyFilterHeadersStatusStopAllIterationAndBuffer;

/// Return codes for on-data filter invocations. @see envoy/http/filter.h
extern const int kEnvoyFilterDataStatusContinue;
extern const int kEnvoyFilterDataStatusStopIterationAndBuffer;
extern const int kEnvoyFilterDataStatusStopIterationNoBuffer;
extern const int kEnvoyFilterDataStatusResumeIteration;

/// Return codes for on-trailers filter invocations. @see envoy/http/filter.h
extern const int kEnvoyFilterTrailersStatusContinue;
extern const int kEnvoyFilterTrailersStatusStopIteration;
extern const int kEnvoyFilterTrailersStatusResumeIteration;

/// Return codes for on-resume filter invocations. These are unique to platform filters,
/// and used exclusively after an asynchronous request to resume iteration via callbacks.
extern const int kEnvoyFilterResumeStatusStopIteration;
extern const int kEnvoyFilterResumeStatusResumeIteration;

/// Callbacks for asynchronous interaction with the filter.
@protocol EnvoyHTTPFilterCallbacks

/// Resume filter iteration asynchronously. This will result in an on-resume invocation of the
/// filter.
- (void)resumeIteration;

/// Reset the underlying stream idle timeout to its configured threshold. This may be useful if
/// a filter stops iteration for an extended period of time, since ordinarily timeouts will still
/// apply. This may be called periodically to continue to indicate "activity" on the stream.
- (void)resetIdleTimer;

@end

@interface EnvoyHTTPFilter : NSObject

/// Returns tuple of:
/// 0 - NSNumber *,filter status
/// 1 - EnvoyHeaders *, forward headers
@property (nonatomic, copy, nullable) NSArray * (^onRequestHeaders)
    (EnvoyHeaders *headers, BOOL endStream, EnvoyStreamIntel streamIntel);

/// Returns tuple of:
/// 0 - NSNumber *,filter status
/// 1 - NSData *, forward data
/// 2 - EnvoyHeaders *, optional pending headers
@property (nonatomic, copy, nullable) NSArray * (^onRequestData)
    (NSData *data, BOOL endStream, EnvoyStreamIntel streamIntel);

/// Returns tuple of:
/// 0 - NSNumber *,filter status
/// 1 - EnvoyHeaders *, forward trailers
/// 2 - EnvoyHeaders *, optional pending headers
/// 3 - NSData *, optional pending data
@property (nonatomic, copy, nullable) NSArray * (^onRequestTrailers)
    (EnvoyHeaders *trailers, EnvoyStreamIntel streamIntel);

/// Returns tuple of:
/// 0 - NSNumber *,filter status
/// 1 - EnvoyHeaders *, forward headers
@property (nonatomic, copy, nullable) NSArray * (^onResponseHeaders)
    (EnvoyHeaders *headers, BOOL endStream, EnvoyStreamIntel streamIntel);

/// Returns tuple of:
/// 0 - NSNumber *,filter status
/// 1 - NSData *, forward data
/// 2 - EnvoyHeaders *, optional pending headers
@property (nonatomic, copy, nullable) NSArray * (^onResponseData)
    (NSData *data, BOOL endStream, EnvoyStreamIntel streamIntel);

/// Returns tuple of:
/// 0 - NSNumber *,filter status
/// 1 - EnvoyHeaders *, forward trailers
/// 2 - EnvoyHeaders *, optional pending headers
/// 3 - NSData *, optional pending data
@property (nonatomic, copy, nullable) NSArray * (^onResponseTrailers)
    (EnvoyHeaders *trailers, EnvoyStreamIntel streamIntel);

@property (nonatomic, copy, nullable) void (^onCancel)
    (EnvoyStreamIntel streamIntel, EnvoyFinalStreamIntel finalStreamIntel);

@property (nonatomic, copy, nullable) void (^onError)
    (uint64_t errorCode, NSString *message, int32_t attemptCount, EnvoyStreamIntel streamIntel,
     EnvoyFinalStreamIntel finalStreamIntel);

@property (nonatomic, copy, nullable) void (^onComplete)
    (EnvoyStreamIntel streamIntel, EnvoyFinalStreamIntel finalStreamIntel);

@property (nonatomic, copy, nullable) void (^setRequestFilterCallbacks)
    (id<EnvoyHTTPFilterCallbacks> callbacks);

/// Returns tuple of:
/// 0 - NSNumber *,filter status
/// 1 - EnvoyHeaders *, optional pending headers
/// 2 - NSData *, optional pending data
/// 3 - EnvoyHeaders *, optional pending trailers
@property (nonatomic, copy, nullable) NSArray * (^onResumeRequest)
    (EnvoyHeaders *_Nullable headers, NSData *_Nullable data, EnvoyHeaders *_Nullable trailers,
     BOOL endStream, EnvoyStreamIntel streamIntel);

@property (nonatomic, copy, nullable) void (^setResponseFilterCallbacks)
    (id<EnvoyHTTPFilterCallbacks> callbacks);

/// Returns tuple of:
/// 0 - NSNumber *,filter status
/// 1 - EnvoyHeaders *, optional pending headers
/// 2 - NSData *, optional pending data
/// 3 - EnvoyHeaders *, optional pending trailers
@property (nonatomic, copy, nullable) NSArray * (^onResumeResponse)
    (EnvoyHeaders *_Nullable headers, NSData *_Nullable data, EnvoyHeaders *_Nullable trailers,
     BOOL endStream, EnvoyStreamIntel streamIntel);

@end

NS_ASSUME_NONNULL_END
#import "library/objective-c/EnvoyEngine.h"

#import "library/cc/engine_builder.h"
#include "source/common/protobuf/utility.h"

@implementation NSString (CXX)
- (std::string)toCXXString {
  return std::string([self UTF8String],
                     (int)[self lengthOfBytesUsingEncoding:NSUTF8StringEncoding]);
}
@end

@implementation EMOHeaderMatcher
- (Envoy::DirectResponseTesting::HeaderMatcher)toCXX {
  Envoy::DirectResponseTesting::HeaderMatcher result;
  result.name = [self.name toCXXString];
  result.value = [self.value toCXXString];
  switch (self.mode) {
  case EMOMatchModeContains:
    result.mode = Envoy::DirectResponseTesting::MatchMode::Contains;
    break;
  case EMOMatchModeExact:
    result.mode = Envoy::DirectResponseTesting::MatchMode::Exact;
    break;
  case EMOMatchModePrefix:
    result.mode = Envoy::DirectResponseTesting::MatchMode::Prefix;
    break;
  case EMOMatchModeSuffix:
    result.mode = Envoy::DirectResponseTesting::MatchMode::Suffix;
    break;
  }
  return result;
}
@end

@implementation EMORouteMatcher
- (Envoy::DirectResponseTesting::RouteMatcher)toCXX {
  Envoy::DirectResponseTesting::RouteMatcher result;
  result.fullPath = [self.fullPath toCXXString];
  result.pathPrefix = [self.pathPrefix toCXXString];
  std::vector<Envoy::DirectResponseTesting::HeaderMatcher> headers;
  headers.reserve(self.headers.count);
  for (EMOHeaderMatcher *matcher in self.headers) {
    headers.push_back([matcher toCXX]);
  }
  result.headers = headers;
  return result;
}
@end

@implementation EMODirectResponse
- (Envoy::DirectResponseTesting::DirectResponse)toCXX {
  Envoy::DirectResponseTesting::DirectResponse result;
  result.matcher = [self.matcher toCXX];
  result.status = (unsigned int)self.status;
  result.body = [self.body toCXXString];
  absl::flat_hash_map<std::string, std::string> headers;
  NSArray *keys = [self.headers allKeys];
  for (NSString *key in keys) {
    headers[[key toCXXString]] = [[self.headers objectForKey:key] toCXXString];
  }
  result.headers = headers;
  return result;
}
@end

@implementation EnvoyConfiguration

- (instancetype)initWithConnectTimeoutSeconds:(UInt32)connectTimeoutSeconds
                                dnsRefreshSeconds:(UInt32)dnsRefreshSeconds
                     dnsFailureRefreshSecondsBase:(UInt32)dnsFailureRefreshSecondsBase
                      dnsFailureRefreshSecondsMax:(UInt32)dnsFailureRefreshSecondsMax
                           dnsQueryTimeoutSeconds:(UInt32)dnsQueryTimeoutSeconds
                             dnsMinRefreshSeconds:(UInt32)dnsMinRefreshSeconds
                           dnsPreresolveHostnames:(NSArray<NSString *> *)dnsPreresolveHostnames
                                   enableDNSCache:(BOOL)enableDNSCache
                      dnsCacheSaveIntervalSeconds:(UInt32)dnsCacheSaveIntervalSeconds
                                      enableHttp3:(BOOL)enableHttp3
                                        quicHints:(NSDictionary<NSString *, NSNumber *> *)quicHints
                            quicCanonicalSuffixes:(NSArray<NSString *> *)quicCanonicalSuffixes
                          enableGzipDecompression:(BOOL)enableGzipDecompression
                        enableBrotliDecompression:(BOOL)enableBrotliDecompression
                           enableInterfaceBinding:(BOOL)enableInterfaceBinding
                        enableDrainPostDnsRefresh:(BOOL)enableDrainPostDnsRefresh
                    enforceTrustChainVerification:(BOOL)enforceTrustChainVerification
                                        forceIPv6:(BOOL)forceIPv6
              enablePlatformCertificateValidation:(BOOL)enablePlatformCertificateValidation
    h2ConnectionKeepaliveIdleIntervalMilliseconds:
        (UInt32)h2ConnectionKeepaliveIdleIntervalMilliseconds
              h2ConnectionKeepaliveTimeoutSeconds:(UInt32)h2ConnectionKeepaliveTimeoutSeconds
                            maxConnectionsPerHost:(UInt32)maxConnectionsPerHost
                         streamIdleTimeoutSeconds:(UInt32)streamIdleTimeoutSeconds
                         perTryIdleTimeoutSeconds:(UInt32)perTryIdleTimeoutSeconds
                                       appVersion:(NSString *)appVersion
                                            appId:(NSString *)appId
                                    runtimeGuards:
                                        (NSDictionary<NSString *, NSString *> *)runtimeGuards
                                nativeFilterChain:
                                    (NSArray<EnvoyNativeFilterConfig *> *)nativeFilterChain
                              platformFilterChain:
                                  (NSArray<EnvoyHTTPFilterFactory *> *)httpPlatformFilterFactories
                                  stringAccessors:
                                      (NSDictionary<NSString *, EnvoyStringAccessor *> *)
                                          stringAccessors
                                   keyValueStores:
                                       (NSDictionary<NSString *, id<EnvoyKeyValueStore>> *)
                                           keyValueStores
                                           nodeId:(nullable NSString *)nodeId
                                       nodeRegion:(nullable NSString *)nodeRegion
                                         nodeZone:(nullable NSString *)nodeZone
                                      nodeSubZone:(nullable NSString *)nodeSubZone
                                 xdsServerAddress:(nullable NSString *)xdsServerAddress
                                    xdsServerPort:(UInt32)xdsServerPort
                           xdsGrpcInitialMetadata:
                               (NSDictionary<NSString *, NSString *> *)xdsGrpcInitialMetadata
                                  xdsSslRootCerts:(nullable NSString *)xdsSslRootCerts
                                 rtdsResourceName:(nullable NSString *)rtdsResourceName
                               rtdsTimeoutSeconds:(UInt32)rtdsTimeoutSeconds
                                        enableCds:(BOOL)enableCds
                              cdsResourcesLocator:(nullable NSString *)cdsResourcesLocator
                                cdsTimeoutSeconds:(UInt32)cdsTimeoutSeconds {
  self = [super init];
  if (!self) {
    return nil;
  }

  self.connectTimeoutSeconds = connectTimeoutSeconds;
  self.dnsRefreshSeconds = dnsRefreshSeconds;
  self.dnsFailureRefreshSecondsBase = dnsFailureRefreshSecondsBase;
  self.dnsFailureRefreshSecondsMax = dnsFailureRefreshSecondsMax;
  self.dnsQueryTimeoutSeconds = dnsQueryTimeoutSeconds;
  self.dnsMinRefreshSeconds = dnsMinRefreshSeconds;
  self.dnsPreresolveHostnames = dnsPreresolveHostnames;
  self.enableDNSCache = enableDNSCache;
  self.dnsCacheSaveIntervalSeconds = dnsCacheSaveIntervalSeconds;
  self.enableHttp3 = enableHttp3;
  self.quicHints = quicHints;
  self.quicCanonicalSuffixes = quicCanonicalSuffixes;
  self.enableGzipDecompression = enableGzipDecompression;
  self.enableBrotliDecompression = enableBrotliDecompression;
  self.enableInterfaceBinding = enableInterfaceBinding;
  self.enableDrainPostDnsRefresh = enableDrainPostDnsRefresh;
  self.enforceTrustChainVerification = enforceTrustChainVerification;
  self.forceIPv6 = forceIPv6;
  self.enablePlatformCertificateValidation = enablePlatformCertificateValidation;
  self.h2ConnectionKeepaliveIdleIntervalMilliseconds =
      h2ConnectionKeepaliveIdleIntervalMilliseconds;
  self.h2ConnectionKeepaliveTimeoutSeconds = h2ConnectionKeepaliveTimeoutSeconds;
  self.maxConnectionsPerHost = maxConnectionsPerHost;
  self.streamIdleTimeoutSeconds = streamIdleTimeoutSeconds;
  self.perTryIdleTimeoutSeconds = perTryIdleTimeoutSeconds;
  self.appVersion = appVersion;
  self.appId = appId;
  self.runtimeGuards = runtimeGuards;
  self.nativeFilterChain = nativeFilterChain;
  self.httpPlatformFilterFactories = httpPlatformFilterFactories;
  self.stringAccessors = stringAccessors;
  self.keyValueStores = keyValueStores;
  self.nodeId = nodeId;
  self.nodeRegion = nodeRegion;
  self.nodeZone = nodeZone;
  self.nodeSubZone = nodeSubZone;
  self.xdsServerAddress = xdsServerAddress;
  self.xdsServerPort = xdsServerPort;
  self.xdsGrpcInitialMetadata = xdsGrpcInitialMetadata;
  self.xdsSslRootCerts = xdsSslRootCerts;
  self.rtdsResourceName = rtdsResourceName;
  self.rtdsTimeoutSeconds = rtdsTimeoutSeconds;
  self.cdsResourcesLocator = cdsResourcesLocator;
  self.cdsTimeoutSeconds = cdsTimeoutSeconds;
  self.enableCds = enableCds;
  self.bootstrapPointer = 0;

  return self;
}

- (Envoy::Platform::EngineBuilder)applyToCXXBuilder {
  Envoy::Platform::EngineBuilder builder;

  for (EnvoyNativeFilterConfig *nativeFilterConfig in
       [self.nativeFilterChain reverseObjectEnumerator]) {
    builder.addNativeFilter(
        /* name */ [nativeFilterConfig.name toCXXString],
        /* typed_config */ [nativeFilterConfig.typedConfig toCXXString]);
  }
  for (EnvoyHTTPFilterFactory *filterFactory in
       [self.httpPlatformFilterFactories reverseObjectEnumerator]) {
    builder.addPlatformFilter([filterFactory.filterName toCXXString]);
  }

#ifdef ENVOY_ENABLE_QUIC
  builder.enableHttp3(self.enableHttp3);
  for (NSString *host in self.quicHints) {
    builder.addQuicHint([host toCXXString], [[self.quicHints objectForKey:host] intValue]);
  }
  for (NSString *suffix in self.quicCanonicalSuffixes) {
    builder.addQuicCanonicalSuffix([suffix toCXXString]);
  }
#endif

  builder.enableGzipDecompression(self.enableGzipDecompression);
  builder.enableBrotliDecompression(self.enableBrotliDecompression);

  for (NSString *key in self.runtimeGuards) {
    BOOL value = [[self.runtimeGuards objectForKey:key] isEqualToString:@"true"];
    builder.setRuntimeGuard([key toCXXString], value);
  }

  builder.addConnectTimeoutSeconds(self.connectTimeoutSeconds);

  builder.addDnsFailureRefreshSeconds(self.dnsFailureRefreshSecondsBase,
                                      self.dnsFailureRefreshSecondsMax);

  builder.addDnsQueryTimeoutSeconds(self.dnsQueryTimeoutSeconds);
  builder.addDnsMinRefreshSeconds(self.dnsMinRefreshSeconds);
  if (self.dnsPreresolveHostnames.count > 0) {
    std::vector<std::string> hostnames;
    hostnames.reserve(self.dnsPreresolveHostnames.count);
    for (NSString *hostname in self.dnsPreresolveHostnames) {
      hostnames.push_back([hostname toCXXString]);
    }
    builder.addDnsPreresolveHostnames(hostnames);
  }
  builder.addDnsRefreshSeconds(self.dnsRefreshSeconds);
  builder.enableDrainPostDnsRefresh(self.enableDrainPostDnsRefresh);
  builder.enableInterfaceBinding(self.enableInterfaceBinding);
  builder.enforceTrustChainVerification(self.enforceTrustChainVerification);
  builder.setForceAlwaysUsev6(self.forceIPv6);
  builder.addH2ConnectionKeepaliveIdleIntervalMilliseconds(
      self.h2ConnectionKeepaliveIdleIntervalMilliseconds);
  builder.addH2ConnectionKeepaliveTimeoutSeconds(self.h2ConnectionKeepaliveTimeoutSeconds);
  builder.addMaxConnectionsPerHost(self.maxConnectionsPerHost);
  builder.setStreamIdleTimeoutSeconds(self.streamIdleTimeoutSeconds);
  builder.setPerTryIdleTimeoutSeconds(self.perTryIdleTimeoutSeconds);
  builder.setAppVersion([self.appVersion toCXXString]);
  builder.setAppId([self.appId toCXXString]);
  builder.setDeviceOs("iOS");
  builder.enablePlatformCertificatesValidation(self.enablePlatformCertificateValidation);
  builder.enableDnsCache(self.enableDNSCache, self.dnsCacheSaveIntervalSeconds);

  if (self.nodeRegion != nil) {
    builder.setNodeLocality([self.nodeRegion toCXXString], [self.nodeZone toCXXString],
                            [self.nodeSubZone toCXXString]);
  }
  if (self.nodeId != nil) {
    builder.setNodeId([self.nodeId toCXXString]);
  }

#ifdef ENVOY_MOBILE_XDS
  if (self.xdsServerAddress != nil) {
    Envoy::Platform::XdsBuilder xdsBuilder([self.xdsServerAddress toCXXString], self.xdsServerPort);
    for (NSString *header in self.xdsGrpcInitialMetadata) {
      xdsBuilder.addInitialStreamHeader(
          [header toCXXString], [[self.xdsGrpcInitialMetadata objectForKey:header] toCXXString]);
    }
    if (self.xdsSslRootCerts != nil) {
      xdsBuilder.setSslRootCerts([self.xdsSslRootCerts toCXXString]);
    }
    if (self.rtdsResourceName != nil) {
      xdsBuilder.addRuntimeDiscoveryService([self.rtdsResourceName toCXXString],
                                            self.rtdsTimeoutSeconds);
    }
    if (self.enableCds) {
      xdsBuilder.addClusterDiscoveryService(
          self.cdsResourcesLocator != nil ? [self.cdsResourcesLocator toCXXString] : "",
          self.cdsTimeoutSeconds);
    }
    builder.setXds(xdsBuilder);
  }
#endif

  return builder;
}

- (std::unique_ptr<envoy::config::bootstrap::v3::Bootstrap>)generateBootstrap {
  try {
    Envoy::Platform::EngineBuilder builder = [self applyToCXXBuilder];
    return builder.generateBootstrap();
  } catch (const std::exception &e) {
    NSLog(@"[Envoy] error generating bootstrap: %@", @(e.what()));
    return nullptr;
  }
}

- (NSString *)bootstrapDebugDescription {
  std::unique_ptr<envoy::config::bootstrap::v3::Bootstrap> bootstrap = [self generateBootstrap];
  return @(bootstrap->ShortDebugString().c_str());
}

@end
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("//bazel:apple.bzl", "envoy_objc_library")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

exports_files([
    "EnvoyEngine.h",
])

envoy_objc_library(
    name = "envoy_engine_objc_lib",
    srcs = [
        "EMODirectResponse.h",
        "EnvoyConfiguration.h",
        "EnvoyConfiguration.mm",
        "EnvoyEngineImpl.mm",
        "EnvoyEventTracker.h",
        "EnvoyEventTracker.m",
        "EnvoyHTTPCallbacks.h",
        "EnvoyHTTPCallbacks.m",
        "EnvoyHTTPFilter.h",
        "EnvoyHTTPFilter.m",
        "EnvoyHTTPFilterCallbacksImpl.h",
        "EnvoyHTTPFilterCallbacksImpl.m",
        "EnvoyHTTPFilterFactory.h",
        "EnvoyHTTPFilterFactory.m",
        "EnvoyHTTPStream.h",
        "EnvoyHTTPStreamImpl.mm",
        "EnvoyLogger.h",
        "EnvoyLogger.m",
        "EnvoyNativeFilterConfig.h",
        "EnvoyNativeFilterConfig.m",
        "EnvoyNetworkMonitor.h",
        "EnvoyNetworkMonitor.mm",
        "EnvoyStringAccessor.h",
        "EnvoyStringAccessor.m",
    ],
    hdrs = [
        "EnvoyEngine.h",
    ],
    module_name = "EnvoyEngine",
    sdk_frameworks = [
        "Network",
        "SystemConfiguration",
    ] + select({
        "@platforms//os:macos": [
        ],
        "//conditions:default": [
            "UIKit",
        ],
    }),
    visibility = ["//visibility:public"],
    deps = [
        ":envoy_key_value_store_bridge_impl_lib",
        ":envoy_key_value_store_lib",
        ":envoy_objc_bridge_lib",
        "//library/cc:engine_builder_lib",
        "//library/common:engine_lib",
        "//library/common/api:c_types",
        "//library/common/network:apple_platform_cert_verifier",
    ],
)

envoy_objc_library(
    name = "envoy_objc_bridge_lib",
    hdrs = ["EnvoyBridgeUtility.h"],
    visibility = ["//visibility:public"],
    deps = [
        ":envoy_aliases_lib",
        "//library/common/types:c_types_lib",
    ],
)

envoy_objc_library(
    name = "envoy_aliases_lib",
    hdrs = ["EnvoyAliases.h"],
    visibility = ["//visibility:public"],
)

envoy_objc_library(
    name = "envoy_key_value_store_bridge_impl_lib",
    srcs = ["EnvoyKeyValueStoreBridgeImpl.m"],
    hdrs = ["EnvoyKeyValueStoreBridgeImpl.h"],
    visibility = ["//visibility:public"],
    deps = [
        ":envoy_key_value_store_lib",
        ":envoy_objc_bridge_lib",
    ],
)

envoy_objc_library(
    name = "envoy_key_value_store_lib",
    hdrs = ["EnvoyKeyValueStore.h"],
    visibility = ["//visibility:public"],
)
#pragma once

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface EnvoyStringAccessor : NSObject

@property (nonatomic, copy) NSString * (^getEnvoyString)();

- (instancetype)initWithBlock:(NSString * (^)())block;

@end

NS_ASSUME_NONNULL_END
#pragma once

#import <Foundation/Foundation.h>

#import "library/objective-c/EMODirectResponse.h"
#import "library/objective-c/EnvoyAliases.h"
#import "library/objective-c/EnvoyConfiguration.h"
#import "library/objective-c/EnvoyEventTracker.h"
#import "library/objective-c/EnvoyHTTPCallbacks.h"
#import "library/objective-c/EnvoyHTTPFilter.h"
#import "library/objective-c/EnvoyHTTPFilterFactory.h"
#import "library/objective-c/EnvoyHTTPStream.h"
#import "library/objective-c/EnvoyKeyValueStore.h"
#import "library/objective-c/EnvoyLogger.h"
#import "library/objective-c/EnvoyNativeFilterConfig.h"
#import "library/objective-c/EnvoyNetworkMonitor.h"
#import "library/objective-c/EnvoyStringAccessor.h"

#import "library/common/types/c_types.h"

NS_ASSUME_NONNULL_BEGIN

#pragma mark - EnvoyEngine

/// Wrapper layer for calling into Envoy's C/++ API.
@protocol EnvoyEngine

/**
 Create a new instance of the engine.

 @param onEngineRunning Closure called when the engine finishes its async startup and begins
 running.
 @param logger Logging interface.
 @param eventTracker Event tracking interface.
 @param networkMonitoringMode Configure how the engines observe network reachability.
 */
- (instancetype)initWithRunningCallback:(nullable void (^)())onEngineRunning
                                 logger:(nullable void (^)(NSString *))logger
                           eventTracker:(nullable void (^)(EnvoyEvent *))eventTracker
                  networkMonitoringMode:(int)networkMonitoringMode;
/**
 Run the Envoy engine with the provided configuration and log level.

 @param config The EnvoyConfiguration used to start Envoy.
 @param logLevel The log level to use when starting Envoy.
 @return A status indicating if the action was successful.
 */
- (int)runWithConfig:(EnvoyConfiguration *)config logLevel:(NSString *)logLevel;

/**
 Run the Envoy engine with the provided yaml string and log level.

 @param yaml The configuration yaml with which to start Envoy.
 @param config The EnvoyConfiguration used to start Envoy.
 @param logLevel The log level to use when starting Envoy.
 @return A status indicating if the action was successful.
 */
- (int)runWithYAML:(NSString *)yaml
            config:(EnvoyConfiguration *)config
          logLevel:(NSString *)logLevel;

/**
 Opens a new HTTP stream attached to this engine.

 @param callbacks Handler for observing stream events.
 @param explicitFlowControl Whether explicit flow control will be enabled for the stream.
 */
- (id<EnvoyHTTPStream>)startStreamWithCallbacks:(EnvoyHTTPCallbacks *)callbacks
                            explicitFlowControl:(BOOL)explicitFlowControl;

/**
 Increments a counter with the given count.

 @param elements Elements of the counter stat.
 @param count Amount to add to the counter.
 @return A status indicating if the action was successful.
 */
- (int)recordCounterInc:(NSString *)elements tags:(EnvoyTags *)tags count:(NSUInteger)count;

/**
 Retrieve the value of all active stats. Note that this function may block for some time.
 @return The list of active stats and their values, or empty string of the operation failed
 */
- (NSString *)dumpStats;

- (void)terminate;

- (void)resetConnectivityState;

@end

#pragma mark - EnvoyEngineImpl

// Concrete implementation of the `EnvoyEngine` interface.
@interface EnvoyEngineImpl : NSObject <EnvoyEngine>

@property (nonatomic, copy, nullable) void (^onEngineRunning)();

@end

NS_ASSUME_NONNULL_END
#pragma once

#import <Foundation/Foundation.h>

#import "library/objective-c/EnvoyAliases.h"

NS_ASSUME_NONNULL_BEGIN

@interface EnvoyEventTracker : NSObject

@property (nonatomic, copy) void (^track)(EnvoyEvent *);

- (instancetype)initWithEventTrackingClosure:(void (^)(EnvoyEvent *))track;

@end

NS_ASSUME_NONNULL_END
#pragma once

#import <Foundation/Foundation.h>

#import "library/common/types/c_types.h"

NS_ASSUME_NONNULL_BEGIN

// Monitors network changes in order to update Envoy network cluster preferences.
@interface EnvoyNetworkMonitor : NSObject

/**
 Create a new instance of the network monitor.
 */
- (instancetype)initWithEngine:(envoy_engine_t)engineHandle;

// Start monitoring reachability using `SCNetworkReachability`, updating the
// preferred Envoy network cluster on changes.
// This is typically called by `EnvoyEngine` automatically on startup.
- (void)startReachability;

// Start monitoring reachability using `NWPathMonitor`, updating the
// preferred Envoy network cluster on changes.
// This is typically called by `EnvoyEngine` automatically on startup.
- (void)startPathMonitor;

@end

NS_ASSUME_NONNULL_END
#import "library/objective-c/EnvoyEngine.h"
#import "library/objective-c/EnvoyBridgeUtility.h"

#import "library/common/types/c_types.h"
#import "library/common/engine.h"

#import <stdatomic.h>

#pragma mark - Utility types

typedef struct {
  // The stream is kept in memory through a strong reference to itself. In order to free the
  // stream when it finishes, it is stored in this context so that it can be called when it
  // is safe to be cleaned up.
  // This approach allows `EnvoyHTTPCallbacks` to be agnostic of associated streams, enabling
  // instances to be reused with multiple streams if desired.
  __unsafe_unretained EnvoyHTTPStreamImpl *stream;
  __unsafe_unretained EnvoyHTTPCallbacks *callbacks;
  atomic_bool *closed;
} ios_context;

#pragma mark - C callbacks

static void *ios_on_headers(envoy_headers headers, bool end_stream, envoy_stream_intel stream_intel,
                            void *context) {
  ios_context *c = (ios_context *)context;
  EnvoyHTTPCallbacks *callbacks = c->callbacks;
  dispatch_async(callbacks.dispatchQueue, ^{
    if (callbacks.onHeaders) {
      callbacks.onHeaders(to_ios_headers(headers), end_stream, stream_intel);
    }
  });
  return NULL;
}

static void *ios_on_data(envoy_data data, bool end_stream, envoy_stream_intel stream_intel,
                         void *context) {
  ios_context *c = (ios_context *)context;
  EnvoyHTTPCallbacks *callbacks = c->callbacks;
  dispatch_async(callbacks.dispatchQueue, ^{
    if (callbacks.onData) {
      callbacks.onData(to_ios_data(data), end_stream, stream_intel);
    }
  });
  return NULL;
}

static void *ios_on_metadata(envoy_headers metadata, envoy_stream_intel stream_intel,
                             void *context) {
  return NULL;
}

static void *ios_on_trailers(envoy_headers trailers, envoy_stream_intel stream_intel,
                             void *context) {
  ios_context *c = (ios_context *)context;
  EnvoyHTTPCallbacks *callbacks = c->callbacks;
  dispatch_async(callbacks.dispatchQueue, ^{
    if (callbacks.onTrailers) {
      callbacks.onTrailers(to_ios_headers(trailers), stream_intel);
    }
  });
  return NULL;
}

static void *ios_on_send_window_available(envoy_stream_intel stream_intel, void *context) {
  ios_context *c = (ios_context *)context;
  EnvoyHTTPCallbacks *callbacks = c->callbacks;
  dispatch_async(callbacks.dispatchQueue, ^{
    if (callbacks.onSendWindowAvailable) {
      callbacks.onSendWindowAvailable(stream_intel);
    }
  });
  return NULL;
}

static void *ios_on_complete(envoy_stream_intel stream_intel,
                             envoy_final_stream_intel final_stream_intel, void *context) {
  ios_context *c = (ios_context *)context;
  EnvoyHTTPCallbacks *callbacks = c->callbacks;
  EnvoyHTTPStreamImpl *stream = c->stream;
  dispatch_async(callbacks.dispatchQueue, ^{
    if (callbacks.onComplete) {
      callbacks.onComplete(stream_intel, final_stream_intel);
    }

    assert(stream);
    [stream cleanUp];
  });
  return NULL;
}

static void *ios_on_cancel(envoy_stream_intel stream_intel,
                           envoy_final_stream_intel final_stream_intel, void *context) {
  // This call is atomically gated at the call-site and will only happen once. It may still fire
  // after a complete response or error callback, but no other callbacks for the stream will ever
  // fire AFTER the cancellation callback.
  ios_context *c = (ios_context *)context;
  EnvoyHTTPCallbacks *callbacks = c->callbacks;
  EnvoyHTTPStreamImpl *stream = c->stream;
  dispatch_async(callbacks.dispatchQueue, ^{
    if (callbacks.onCancel) {
      callbacks.onCancel(stream_intel, final_stream_intel);
    }

    // TODO: If the callback queue is not serial, clean up is not currently thread-safe.
    assert(stream);
    [stream cleanUp];
  });
  return NULL;
}

static void *ios_on_error(envoy_error error, envoy_stream_intel stream_intel,
                          envoy_final_stream_intel final_stream_intel, void *context) {
  ios_context *c = (ios_context *)context;
  EnvoyHTTPCallbacks *callbacks = c->callbacks;
  EnvoyHTTPStreamImpl *stream = c->stream;
  dispatch_async(callbacks.dispatchQueue, ^{
    if (callbacks.onError) {
      NSString *errorMessage = [[NSString alloc] initWithBytes:error.message.bytes
                                                        length:error.message.length
                                                      encoding:NSUTF8StringEncoding];
      release_envoy_error(error);
      callbacks.onError(error.error_code, errorMessage, error.attempt_count, stream_intel,
                        final_stream_intel);
    }

    // TODO: If the callback queue is not serial, clean up is not currently thread-safe.
    assert(stream);
    [stream cleanUp];
  });
  return NULL;
}

#pragma mark - EnvoyHTTPStreamImpl

@implementation EnvoyHTTPStreamImpl {
  EnvoyHTTPStreamImpl *_strongSelf;
  EnvoyHTTPCallbacks *_platformCallbacks;
  envoy_http_callbacks _nativeCallbacks;
  envoy_stream_t _streamHandle;
  Envoy::Engine *_engine;
}

- (instancetype)initWithHandle:(envoy_stream_t)handle
                        engine:(intptr_t)engine
                     callbacks:(EnvoyHTTPCallbacks *)callbacks
           explicitFlowControl:(BOOL)explicitFlowControl {
  self = [super init];
  if (!self) {
    return nil;
  }

  // Retain platform callbacks
  _platformCallbacks = callbacks;
  _streamHandle = handle;

  // Create callback context
  ios_context *context = (ios_context *)safe_malloc(sizeof(ios_context));
  context->callbacks = callbacks;
  context->stream = self;
  context->closed = (atomic_bool *)safe_malloc(sizeof(atomic_bool));
  atomic_store(context->closed, NO);

  // Create native callbacks
  envoy_http_callbacks native_callbacks = {
      ios_on_headers, ios_on_data,     ios_on_metadata, ios_on_trailers,
      ios_on_error,   ios_on_complete, ios_on_cancel,   ios_on_send_window_available,
      context};
  _nativeCallbacks = native_callbacks;

  _engine = reinterpret_cast<Envoy::Engine *>(engine);

  // We need create the native-held strong ref on this stream before we call start_stream because
  // start_stream could result in a reset that would release the native ref.
  _strongSelf = self;
  _streamHandle = _engine->initStream();
  _engine->startStream(_streamHandle, native_callbacks, explicitFlowControl);

  return self;
}

- (void)dealloc {
  ios_context *context = (ios_context *)_nativeCallbacks.context;
  free(context->closed);
  free(context);
}

- (void)sendHeaders:(EnvoyHeaders *)headers close:(BOOL)close {
  _engine->sendHeaders(_streamHandle, toNativeHeaders(headers), close);
}

- (void)sendData:(NSData *)data close:(BOOL)close {
  _engine->sendData(_streamHandle, toNativeData(data), close);
}

- (void)readData:(size_t)byteCount {
  _engine->readData(_streamHandle, byteCount);
}

- (void)sendTrailers:(EnvoyHeaders *)trailers {
  _engine->sendTrailers(_streamHandle, toNativeHeaders(trailers));
}

- (int)cancel {
  _engine->cancelStream(_streamHandle);
  return ENVOY_SUCCESS;
}

- (void)cleanUp {
  _strongSelf = nil;
}

@end
# -*- coding: utf-8 -*-
#
# envoy documentation build configuration file, created by
# sphinx-quickstart on Sat May 28 10:51:27 2016.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

from datetime import datetime
import os
import sys
from sphinx.directives.code import CodeBlock
import sphinx_rtd_theme


# https://stackoverflow.com/questions/44761197/how-to-use-substitution-definitions-with-code-blocks
class SubstitutionCodeBlock(CodeBlock):
    """
  Similar to CodeBlock but replaces placeholders with variables. See "substitutions" below.
  """

    def run(self):
        """
    Replace placeholders with given variables.
    """
        app = self.state.document.settings.env.app
        new_content = []
        existing_content = self.content
        for item in existing_content:
            for pair in app.config.substitutions:
                original, replacement = pair
                item = item.replace(original, replacement)
            new_content.append(item)

        self.content = new_content
        return list(CodeBlock.run(self))


def setup(app):
    app.add_config_value('release_level', '', 'env')
    app.add_config_value('substitutions', [], 'html')
    app.add_directive('substitution-code-block', SubstitutionCodeBlock)


if not (release_level := os.environ.get('ENVOY_DOCS_RELEASE_LEVEL')):
    raise Exception("ENVOY_DOCS_RELEASE_LEVEL env var must be defined")

if not (blob_sha := os.environ.get("ENVOY_BLOB_SHA")):
    raise Exception("ENVOY_BLOB_SHA env var must be defined")

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinxcontrib.httpdomain', 'sphinx.ext.extlinks', 'sphinx.ext.ifconfig',
    'sphinxcontrib.googleanalytics'
]
extlinks = {
    'issue': ('https://github.com/envoyproxy/envoy-mobile/issues/%s', '%s'),
    'repo': ('https://github.com/envoyproxy/envoy-mobile/blob/{}/%s'.format(blob_sha), '%s'),
    'tree': ('https://github.com/envoyproxy/envoy-mobile/tree/%s', '%s'),
}

# Set up global substitutions
# substitutions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
# source_suffix = ['.rst', '.md']
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'envoy-mobile'
author = u'Lyft, Inc.'
copyright = u'{} {}'.format(datetime.now().year, author)

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.

# The short X.Y version.
if not (version := os.environ.get("ENVOY_DOCS_VERSION_STRING")):
    raise Exception("ENVOY_DOCS_VERSION_STRING env var must be defined")

# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = 'en'

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This patterns also effect to html_static_path and html_extra_path
exclude_patterns = ['_build', '_venv', 'Thumbs.db', '.DS_Store']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
#pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False

# If true, `todo` and `todoList` produce output, else they produce nothing.
todo_include_todos = False

# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'sphinx_rtd_theme'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]

# The name for this set of Sphinx documents.
# "<project> v<release> documentation" by default.
#html_title = u'envoy v1.0.0'

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (relative to this directory) to use as a favicon of
# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = 'favicon.ico'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

html_style = 'css/envoy.css'

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not None, a 'Last updated on:' timestamp is inserted at every page
# bottom, using the given strftime format.
# The empty string is equivalent to '%b %d, %Y'.
#html_last_updated_fmt = None

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Language to be used for generating the HTML full-text search index.
# Sphinx supports the following languages:
#   'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja'
#   'nl', 'no', 'pt', 'ro', 'ru', 'sv', 'tr', 'zh'
#html_search_language = 'en'

# A dictionary with options for the search language support, empty by default.
# 'ja' uses this config value.
# 'zh' user can custom change `jieba` dictionary path.
#html_search_options = {'type': 'default'}

# The name of a javascript file (relative to the configuration directory) that
# implements a search results scorer. If empty, the default will be used.
#html_search_scorer = 'scorer.js'

# Output file base name for HTML help builder.
htmlhelp_basename = 'envoydoc'

# Google Analytics tag ID
googleanalytics_id = 'G-DXJEH1ZRXX'
#!/bin/bash -e

# This is run on every commit that GitHub Actions picks up. It assumes that docs have already been
# built via docs/build.sh. The commit behavior differs depending on the nature of the commit:
# * Tag commit (e.g. v1.6.0): commits docs to versioned location.
# * Main commit: commits docs to latest. Note that envoy-mobile.github.io uses `master` rather than
#                `main` because using `main` as the default branch currently results in 404s.
# * Otherwise: noop.

set -o pipefail

DOCS_DIR=generated/docs
BUILD_SHA="$(git rev-parse HEAD)"

if [[ -z "$MOBILE_DOCS_CHECKOUT_DIR" ]]; then
    echo "MOBILE_DOCS_CHECKOUT_DIR is not set, exiting" >&2
    exit 1
fi

if [[ "$GITHUB_REF_TYPE" == "tag" ]]; then
    PUBLISH_DIR="$MOBILE_DOCS_CHECKOUT_DIR"/docs/envoy-mobile/"$GITHUB_REF_NAME"
else
    PUBLISH_DIR="$MOBILE_DOCS_CHECKOUT_DIR"/docs/envoy-mobile/latest
fi

echo "Publishing docs in ${PUBLISH_DIR}"

git -C "$MOBILE_DOCS_CHECKOUT_DIR" checkout -B master origin/master
rm -fr "$PUBLISH_DIR"
mkdir -p "$PUBLISH_DIR"
cp -r "$DOCS_DIR"/* "$PUBLISH_DIR"

git -C "${MOBILE_DOCS_CHECKOUT_DIR}" config user.name "envoy-mobile-docs(ci)"
git -C "${MOBILE_DOCS_CHECKOUT_DIR}" config user.email envoy-mobile-docs@users.noreply.github.com
echo 'add'
git -C "${MOBILE_DOCS_CHECKOUT_DIR}" add .

if [[ "$(git -C "${MOBILE_DOCS_CHECKOUT_DIR}" status --porcelain)" ]]; then
    echo 'commit'
    git -C "${MOBILE_DOCS_CHECKOUT_DIR}" commit -m "docs envoy-mobile@$BUILD_SHA"
fi
# Envoy Mobile docs

Envoy Mobile's docs are generated using [Sphinx](http://www.sphinx-doc.org),
and are published
[here](https://envoymobile.io/docs/envoy-mobile/latest/index.html).

## Generating docs locally

To generate the docs locally, run:

```bash
./docs/build.sh
```

The output can be then be found in `generated/docs`.

## Updating the Envoy Mobile website and docs

The docs website is automatically updated with the latest docs when a commit is
merged to main. This is done via the [publish script](./publish.sh).
# Support Rotation

Envoy Mobile has a support rotation system to ensure that discussions,
issues and pull requests are handled in a timely manner from someone who
works on Envoy Mobile at Lyft.

## Who's this week's current support maintainer?

The current support maintainer's GitHub username is defined
[here](https://github.com/envoyproxy/envoy-mobile/blob/main/.github/lyft_maintainers.yml#L1).

## Responsibilities

* **Monitor GitHub Issues & Pull Requests:** Ensure that discussions on
  GitHub are engaged with in a prompt manner.
* **Monitor Slack:** Engage with Slack discussions in the Envoy slack
  org ([#envoy-mobile](https://envoyproxy.slack.com/archives/CKQ2LK23G),
  [#envoy-mobile-engflow-ci](https://envoyproxy.slack.com/archives/C02QMNG92A3)).

Even though there is no concrete SLA, the support maintainer will make a
reasonable effort to engage with discussions within 1 business day.

## Why is the rotation limited to Lyft employees?

Envoy Mobile is a project maintained by contributors from multiple
companies, as highlighted in [OWNERS.md](../OWNERS.md), but as the
project grows we believe it will be helpful to have a point of contact
within a company that has been using Envoy Mobile in production.
#!/bin/bash

set -e

# We need to set ENVOY_DOCS_VERSION_STRING and ENVOY_DOCS_RELEASE_LEVEL for Sphinx.
# We also validate that the tag and version match at this point if needed.

# Docs for release tags are reserved for vX.Y.Z versions.
# vX.Y.Z.ddmmyy do not publish tagged docs.
VERSION_NUMBER=$(cat VERSION)
if [[ "$GITHUB_REF_TYPE" == "tag" ]] && [[ "${VERSION_NUMBER}" =~ ^[0-9]+\.[0-9]+\.[0-9]$ ]]
then
  # Check the git tag matches the version number in the VERSION file.
  if [ "v${VERSION_NUMBER}" != "${GITHUB_REF_NAME}" ]; then
    echo "Given git tag does not match the VERSION file content:"
    echo "${GITHUB_REF_NAME} vs $(cat VERSION)"
    exit 1
  fi
  # Check the version_history.rst contains current release version.
  grep --fixed-strings "$VERSION_NUMBER" docs/root/intro/version_history.rst \
    || (echo "Git tag not found in version_history.rst" && exit 1)
  DOCS_TARGET=//docs
else
  DOCS_TARGET=//docs:html
fi

[[ -z "${DOCS_OUTPUT_DIR}" ]] && DOCS_OUTPUT_DIR=generated/docs

rm -rf "${DOCS_OUTPUT_DIR}"
mkdir -p "${DOCS_OUTPUT_DIR}"
DOCS_OUTPUT_DIR="$(realpath "$DOCS_OUTPUT_DIR")"

./bazelw run \
         "--@envoy//tools/tarball:target=$DOCS_TARGET" \
         @envoy//tools/tarball:unpack \
         "$DOCS_OUTPUT_DIR"
Envoy Mobile Documentation
==========================

.. ifconfig:: release_level in ('pre-release')

  .. attention::

    This is pre-release documentation. There is risk of it not being consistent with what is
    currently implemented in Envoy Mobile, though we try to make things consistent as quickly as
    possible.

  .. toctree::
    :maxdepth: 2

    intro/intro
    start/start
    api/api
    development/development
          (    (                                                                                                                                                                                                                                                                                 " X     S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                1 J x     t H /                                                                                                                                                                                                                                                                                                                                                                                                                                                              
 1 Y          ~ W / 	                                                                                                                                                                                                                                                                                                                                                                                                                                                  - a             ^ ,                                                                                                                                                                                                                                                                                                                                                                                                                                      % C k                 i @ #                                                                                                                                                                                                                                                                                                                                                                                                                       K y                   u H                                                                                                                                                                                                                                                                                                                                                                                                           1 V {                       x T .                                                                                                                                                                                                                                                                                                                                                                                                 0 \                           X .                                                                                                                                                                                                                                                                                                                                                                                 # C d                               b A !                                                                                                                                                                                                                                                                                                                                                                     G                                   C  
                                                                                                                                                                                                                                                                                                                                                    2 P o                                     m N 0                                                                                                                                                                                                                                                                                                                                      8 j                                         g 4                                                                                                                                                                                                                                                                                                                         " < V ~                                           { T : !                                                                                                                                                                                                                                                                                                            * O                       U @ @ X                       L (                                                                                                                                                                                                                                                                                             * B h                      | Q $   ' T ~                      f @ )  
                                                                                                                                                                                                                                                                            : n                      l L .       0 N p                      j 6                                                                                                                                                                                                                                                               2 P u                      e 1                             4 i                      r N 0                                                                                                                                                                                                                                               , Y                       a < '  	                           
  ( > d                       V )                                                                                                                                                                                                                                     " 6 ^                      { H $                                                              & J                       Z 4 !                                                                                                                                                                                                                     " D k                      w R 8                                                                   9 T z                      h B                                                                                                                                                                                                        I z                      b /                                                                                    	 2 e                      w E                                                                                                                                                                                           / V }                      j J .                                                                                       0 L l                      { S -                                                                                                                                                                             3 Z                      z <                                                                                                                   	  @ ~                      W 1 
                                                                                                                                                             B e                       ^ =                                                                                                                        ? `                       c @                                                                                                                                                      =                       Q +                                                                                                                                             - U                      | 9                                                                                                                                      3 Q q                      v Q +                                                                                                                                                     . S x                      o N 1                                                                                                                      / h                      p C                                                                                                                                                                 F t                      d +                                                                                                         $ > Z }                      e =                                                                                                                                                                                     ! ? g                      { X < #                                                                                         % P                       Y +                                                                                                                                                                                               , \                      ~ M "                                                                             , C h                      z R * 	                                                                                                                                                                                                           
 - U }                      e B +                                                                    8 j                      o G -                                                                                                                                                                                                                   / H s                      f 8                                                                  ; v                      i 8  	                                                                                                                                                                                                                                         
  ; l                      v ;                                                                 e                     ` = %                                                                                                                                                                                                                                               & @ b                     e                                                                 }                    I &                                                                                                                                                                                                                                                                           ( L                    }                                                                 }                 w O 5                                                                                                                                                                                                                                                                               7 R z                 }                                                                 }                b 5 	                                                                                                                                                                                                                                                                                                    8 e                }                                                                 }              g I ,                                                                                                                                                                                                                                                                                                             - K i              }                                                                 }             F  	                                                                                                                                                                                                                                                                                                                                 
  J             }                                                                 }            @ "                                                                                                                                                                                                                                                                                                                                     $ B            }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }           Z                                                                                                                                                                                                                                                                                                                                                     b           }                                                                 }            @ "                                                                                                                                                                                                                                                                                                                                     $ B            }                                                                 }             F  	                                                                                                                                                                                                                                                                                                                                 
  J             }                                                                 }              g J -                                                                                                                                                                                                                                                                                                           . L i              }                                                                 }                c 6 
                                                                                                                                                                                                                                                                                                    9 f                }                                                                 }                 x P 6                                                                                                                                                                                                                                                                                8 S {                 }                                                                 }                    K (                                                                                                                                                                                                                                                                           ) N                    }                                                                 e                     b ? &                                                                                                                                                                                                                                               ' A d                     e                                                                 ; w                      i 8  	                                                                                                                                                                                                                                         
  ; l                      w ;                                                                  8 l                      p G -                                                                                                                                                                                                                  / H s                      f 8                                                                    - E g                      { S + 	                                                                                                                                                                                                           
 - V ~                      e B +                                                                             % O                       Y +                                                                                                                                                                                               , \                      } L "                                                                                         # = Z }                      e >                                                                                                                                                                                     " @ h                      { X ; "                                                                                                         / g                      q D                                                                                                                                                                 G u                      d +                                                                                                                      2 P q                      v Q +                                                                                                                                                     . S x                      o N 0                                                                                                                                      =                       Q +                                                                                                                                             - U                      { 9                                                                                                                                                       B e                       _ >                                                                                                                      ! @ a                       c @                                                                                                                                                              3 Y                      | =  	                                                                                                                 
  A                       V 0 
                                                                                                                                                                            . U |                      k K .                                                                                       0 M m                      z R ,                                                                                                                                                                                           H y                      c /                                                                                    	 3 f                      u E                                                                                                                                                                                                       ! C j                      x S 8                                                                     : T {                      g @                                                                                                                                                                                                                      " 6 ^                      | J %                                                              ' L                       Z 4 !                                                                                                                                                                                                                                     + X                       b < '  	                           
  ( > e                       U (                                                                                                                                                                                                                                               2 P u                      e 1                             5 i                      r N 0                                                                                                                                                                                                                                                               9 n                      m L .       0 N q                      j 6                                                                                                                                                                                                                                                                            
  * B h                      } Q $   ' T                       e @ )  	                                                                                                                                                                                                                                                                                           * N                       U @ @ Y                       K '                                                                                                                                                                                                                                                                                                            ! < V ~                                           { T :                                                                                                                                                                                                                                                                                                                           7 i                                         f 4                                                                                                                                                                                                                                                                                                                                      2 P o                                     m N 0                                                                                                                                                                                                                                                                                                                                                    
  F                                   B  	                                                                                                                                                                                                                                                                                                                                                                   # C d                               b A !                                                                                                                                                                                                                                                                                                                                                                                 0 \                           X .                                                                                                                                                                                                                                                                                                                                                                                                 1 V z                       x T .                                                                                                                                                                                                                                                                                                                                                                                                        J x                   t G                                                                                                                                                                                                                                                                                                                                                                                                                          $ B k                 h ? "                                                                                                                                                                                                                                                                                                                                                                                                                                      - a             ^ ,                                                                                                                                                                                                                                                                                                                                                                                                                                                  
 2 Z           V / 	                                                                                                                                                                                                                                                                                                                                                                                                                                                              3 L y     u I 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " X     R                                                                                                                                                                                                                                               ??                  ?                  ?                ?  ?                ?              ?                                ?                  ?            ?      ?            ?                      ?              ??What is Envoy Mobile?
=====================

.. attention::

  Envoy Mobile is currently in a very early stage of development. This page should be read as a set
  of aspirational project goals.

Envoy Mobile is an iOS and Android client networking library built using
`Envoy <https://www.envoyproxy.io/>`_ as its core.

Envoy's `project goals <https://www.envoyproxy.io/docs/envoy/latest/intro/what_is_envoy>`_ are
simply stated as:

  *The network should be transparent to applications. When network and application problems do occur
  it should be easy to determine the source of the problem.*

As fundamental as Envoy has become in scaling many organizations distributed architectures, the
reality is that three 9s at the server-side edge is meaningless if the user of a mobile application
is only able to complete the desired product flows a fraction of the time. This may be due to a
combination of network and application errors. Thus, in order to fully achieve the Envoy projects
goal of making the network transparent to applications, the service mesh and its inherent benefits
(observability, consistency, etc.) must expand beyond the edge all the way to the mobile
applications that are so critical to the end users experience. Envoy Mobile in conjunction with
Envoy in the data center will provide the ability to reason about the entire distributed system
network, not just the server-side portion.

Whereas server-side Envoy proxy is a self-contained process that is meant to be deployed alongside a
polyglot architecture, Envoy Mobile is distributed as a library meant to be compiled directly into
client mobile applications. The library approach is required due to the practicalities of how
applications are written and distributed on both the iOS and Android platforms. The high level goals
of the library are discussed in the following subsections.

Ubiquitous API and abstraction for networking
---------------------------------------------

With the industry progressively moving towards specifying APIs via a strongly typed IDL such as
`protocol buffers <https://developers.google.com/protocol-buffers/>`_, Envoy Mobile will standardize
and abstract how mobile developers interact with IDL exposed endpoints. Via `intelligent protobuf
code generation <https://github.com/lyft/protoc-gen-star>`_ and an abstract transport, both iOS and
Android can provide similar interfaces and ergonomics for consuming APIs. Initially we are planning
on focusing our efforts on Swift APIs for iOS and Kotlin APIs for Android, but depending on
community interest we will consider adding support for additional languages in the future. Our
ultimate goal is to make the low-level Envoy common C++ code an implementation detail that the
average mobile developer does not need to be aware of. Instead, mobile developers will interact with
high-level language specific APIs that encapsulate common concerns such as making API calls,
analytics, tracing, etc.

Simple and explicit system for supporting advanced networking features
----------------------------------------------------------------------

With protocol buffers powerful annotation/extension system, Envoy Mobile can add sophisticated
cross-platform functionality in a simple and explicit way when using strongly typed IDL APIs.
Examples of annotations that are planned on our roadmap include marking an API as offline/deferred
capable, caching, priority, streaming, marking fields for exclusion both on the request and response
in poor network conditions, as well as general Envoy policies such as retry and timeout
specifications.

Much like Envoys use in a server-side service mesh, the goal is to push as much functionality as
possible into the common core so as to avoid reimplementing it in every mobile application language.

Furthermore, it is an explicit goal of Envoy Mobile to maintain consistent 1:1 APIs between
the native mobile languages that it supports.

Our long-term plans include evolving the `gRPC Server Reflection Protocol
<https://github.com/grpc/grpc/blob/master/doc/server-reflection.md>`_ into a streaming reflection
service API. This API will allow both Envoy and Envoy Mobile to fetch generic protobuf definitions
from a central IDL service, which can then be used to implement annotation driven networking via
reflection. This model means that Envoy Mobile will not necessarily need to have prior knowledge of
an organizations APIs in order to provide enhanced cross-platform networking functionality.

xDS driven mobile client policy
-------------------------------

One of the reasons that Envoy has become so popular as a platform is its rich configuration
discovery APIs which are collectively known as `xDS
<https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/dynamic_configuration>`_. These
APIs allow a distributed set of Envoys to be managed by an eventually consistent control plane. One
of the long term goals of Envoy Mobile is to bring xDS configuration all the way to mobile clients,
in the form of routing, authentication, failover, load balancing, and other policies driven by a
global load balancing system. This will be an extremely powerful mechanism for bringing layer 7 /
application networking concepts all the way to the mobile client.
.. _intro:

Introduction
============

.. toctree::
  :maxdepth: 2

  what_is_envoy_mobile
  comparison
  getting_help
  version_history
  additional_resources
Com