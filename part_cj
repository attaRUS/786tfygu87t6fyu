 does not exist.
   * @param name supplies the key name.
   * @param default_value supplies the value to return if name does not exist.
   * @return int64_t the value.
   */
  virtual int64_t getInteger(const std::string& name, int64_t default_value) const PURE;

  /**
   * Get a sub-object by name.
   * @param name supplies the key name.
   * @param allow_empty supplies whether to return an empty object if the key does not
   * exist.
   * @return ObjectObjectSharedPtr the sub-object.
   * @throws Json::Exception if unable to get the attribute or the type is not an object.
   */
  virtual ObjectSharedPtr getObject(const std::string& name, bool allow_empty = false) const PURE;

  /**
   * Get a sub-object by name.
   * @param name supplies the key name.
   * @param allow_empty supplies whether to return an empty object if the key does not
   * exist.
   * @return ObjectObjectSharedPtr the sub-object.
   */
  virtual absl::StatusOr<ObjectSharedPtr> getObjectNoThrow(const std::string& name,
                                                           bool allow_empty = false) const PURE;

  /**
   * Determine if an object has type Object.
   * @return bool is the object an Object?
   */
  virtual bool isObject() const PURE;

  /**
   * Determine if an object has type Array.
   * @return bool is the object an Array?
   */
  virtual bool isArray() const PURE;

  /**
   * Get an array by name.
   * @param name supplies the key name.
   * @param allow_empty specifies whether to return an empty array if the key does not exist.
   * @return std::vector<ObjectSharedPtr> the array of JSON  objects.
   */
  virtual std::vector<ObjectSharedPtr> getObjectArray(const std::string& name,
                                                      bool allow_empty = false) const PURE;

  /**
   * Get a string value by name.
   * @param name supplies the key name.
   * @return std::string the value.
   */
  virtual std::string getString(const std::string& name) const PURE;

  /**
   * Get a string value by name or return a default if name does not exist.
   * @param name supplies the key name.
   * @param default_value supplies the value to return if name does not exist.
   * @return std::string the value.
   */
  virtual std::string getString(const std::string& name,
                                const std::string& default_value) const PURE;

  /**
   * Get a string array by name.
   * @param name supplies the key name.
   * @param allow_empty specifies whether to return an empty array if the key does not exist.
   * @return std::vector<std::string> the array of strings.
   */
  virtual std::vector<std::string> getStringArray(const std::string& name,
                                                  bool allow_empty = false) const PURE;

  /**
   * Get a double value by name.
   * @param name supplies the key name.
   * @return double the value.
   */
  virtual double getDouble(const std::string& name) const PURE;

  /**
   * Get a double value by name.
   * @param name supplies the key name.
   * @param default_value supplies the value to return if name does not exist.
   * @return double the value.
   */
  virtual double getDouble(const std::string& name, double default_value) const PURE;

  /**
   * @return a hash of the JSON object.
   * Per RFC 7159:
   *    An object is an unordered collection of zero or more name/value
   *    pairs, where a name is a string and a value is a string, number,
   *    boolean, null, object, or array.
   * Objects with fields in different orders are equivalent and produce the same hash.
   * It does not consider white space that was originally in the parsed JSON.
   */
  virtual uint64_t hash() const PURE;

  /**
   * Iterate over key-value pairs in an Object and call callback on each pair.
   */
  virtual void iterate(const ObjectCallback& callback) const PURE;

  /**
   * @return TRUE if the Object contains the key.
   * @param name supplies the key name to lookup.
   */
  virtual bool hasObject(const std::string& name) const PURE;

  /**
   * Validates JSON object against passed in schema.
   * @param schema supplies the schema in string format. A Json::Exception will be thrown if
   *        the JSON object doesn't conform to the supplied schema or the schema itself is not
   *        valid.
   */
  virtual void validateSchema(const std::string& schema) const PURE;

  /**
   * @return the value of the object as a string (where the object is a string).
   */
  virtual std::string asString() const PURE;

  /**
   * @return the JSON string representation of the object.
   */
  virtual std::string asJsonString() const PURE;

  /**
   * @return true if the JSON object is empty;
   */
  virtual bool empty() const PURE;
};

} // namespace Json
} // namespace Envoy
#pragma once

#include <string>

#include "envoy/common/pure.h"
#include "envoy/config/context_provider.h"
#include "envoy/config/core/v3/base.pb.h"
#include "envoy/network/address.h"
#include "envoy/stats/stats.h"

namespace Envoy {
namespace LocalInfo {

/**
 * Information about the local environment.
 */
class LocalInfo {
public:
  virtual ~LocalInfo() = default;

  /**
   * @return the local (non-loopback) address of the server.
   */
  virtual Network::Address::InstanceConstSharedPtr address() const PURE;

  /**
   * @return the human readable zone name. E.g., "us-east-1a".
   */
  virtual const std::string& zoneName() const PURE;

  /**
   * @return the zone name as a stat name.
   */
  virtual const Stats::StatName& zoneStatName() const PURE;

  /**
   * @return the human readable cluster name. E.g., "eta".
   */
  virtual const std::string& clusterName() const PURE;

  /**
   * @return the human readable individual node name. E.g., "i-123456".
   */
  virtual const std::string& nodeName() const PURE;

  /**
   * @return the full node identity presented to management servers.
   */
  virtual const envoy::config::core::v3::Node& node() const PURE;

  /**
   * @return the xDS context provider for the node.
   */
  virtual Config::ContextProvider& contextProvider() PURE;
  virtual const Config::ContextProvider& contextProvider() const PURE;
};

using LocalInfoPtr = std::unique_ptr<LocalInfo>;

} // namespace LocalInfo
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "local_info_interface",
    hdrs = ["local_info.h"],
    deps = [
        "//envoy/config:context_provider_interface",
        "//envoy/network:address_interface",
        "//envoy/stats:stats_interface",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)
#pragma once

#include "envoy/buffer/buffer.h"
#include "envoy/network/connection.h"

namespace Envoy {
namespace Tcp {

/*
 * AsyncTcpClientOptions for the creation of async tcp client;
 */
struct AsyncTcpClientOptions {
  AsyncTcpClientOptions(bool enable_half_close) : enable_half_close(enable_half_close){};
  bool enable_half_close;
};

using AsyncTcpClientOptionsConstSharedPtr = std::shared_ptr<const AsyncTcpClientOptions>;

/*
 * AsyncTcpClientCallbacks for peer connection callbacks and data.
 */
class AsyncTcpClientCallbacks : public Network::ConnectionCallbacks {
public:
  ~AsyncTcpClientCallbacks() override = default;

  /*
   * Invoked when data is delivered from the peer connection.
   * @param data supplies data from the peer.
   * @param end_stream whether the data is the last data frame.
   */
  virtual void onData(Buffer::Instance& data, bool end_stream) PURE;
};

/**
 * An async TCP client with connection to peers.
 */
class AsyncTcpClient {
public:
  virtual ~AsyncTcpClient() = default;

  /**
   * Connect to a remote host. Errors or connection events are reported via the
   * event callback registered via setAsyncTcpClientCallbacks().
   */
  virtual bool connect() PURE;

  /**
   * Close the client. It closes the connection based on close type.
   * The underlying connection will be defer deleted when a Close event is received.
   * Abrt/NoFlush will abortively closes the connection discarding any unsent data.
   * @param type the connection close type.
   */
  virtual void close(Network::ConnectionCloseType type) PURE;

  /**
   * @return the detected close type from socket.
   */
  virtual Network::DetectedCloseType detectedCloseType() const PURE;

  /**
   * Write data through the client.
   * @param data the bufferred data.
   * @param end_stream indicates if this is the end of the stream, half close
   * should be enabled by setting end_stream to true.
   */
  virtual void write(Buffer::Instance& data, bool end_stream) PURE;

  /**
   * Disable socket reads on the connection, applying external back pressure.
   * @param disable supplies TRUE is reads should be disabled, FALSE if they
   * should be enabled.
   */
  virtual void readDisable(bool disable) PURE;

  /**
   * Add AsyncTcpClientCallbacks to the client
   * @param callbacks the client callbacks.
   */
  virtual void setAsyncTcpClientCallbacks(AsyncTcpClientCallbacks& callbacks) PURE;

  /**
   * @return Event::Dispatcher& the dispatcher backing this client.
   */
  virtual Event::Dispatcher& dispatcher() PURE;

  /**
   * @return if the client connects to a peer host.
   */
  virtual bool connected() PURE;

  /**
   * @return the streamInfo of the current connection if there is any.
   */
  virtual OptRef<StreamInfo::StreamInfo> getStreamInfo() PURE;
};

using AsyncTcpClientPtr = std::unique_ptr<AsyncTcpClient>;

} // namespace Tcp
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "conn_pool_interface",
    hdrs = ["conn_pool.h"],
    deps = [
        "//envoy/buffer:buffer_interface",
        "//envoy/common:conn_pool_interface",
        "//envoy/event:deferred_deletable",
        "//envoy/upstream:upstream_interface",
    ],
)

envoy_cc_library(
    name = "upstream_interface",
    hdrs = ["upstream.h"],
    deps = [
        "//envoy/http:header_evaluator",
        "//envoy/tcp:conn_pool_interface",
        "//envoy/upstream:upstream_interface",
        "@envoy_api//envoy/extensions/filters/network/tcp_proxy/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "async_tcp_client_interface",
    hdrs = ["async_tcp_client.h"],
    deps = [
        "//envoy/buffer:buffer_interface",
        "//envoy/network:connection_interface",
    ],
)
#pragma once

#include "envoy/buffer/buffer.h"
#include "envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.pb.h"
#include "envoy/http/header_evaluator.h"
#include "envoy/stream_info/stream_info.h"
#include "envoy/tcp/conn_pool.h"
#include "envoy/upstream/upstream.h"

namespace Envoy {

namespace Upstream {
class LoadBalancerContext;
class ThreadLocalCluster;
} // namespace Upstream

namespace TcpProxy {

class GenericConnectionPoolCallbacks;
class GenericUpstream;

/**
 * A configuration for an individual tunneling TCP over HTTP protocols.
 */
class TunnelingConfigHelper {
public:
  virtual ~TunnelingConfigHelper() = default;

  // The host name of the tunneling upstream HTTP request.
  // This function evaluates command operators if specified. Otherwise it returns host name as is.
  virtual std::string host(const StreamInfo::StreamInfo& stream_info) const PURE;

  // The method of the upstream HTTP request. True if using POST method, CONNECT otherwise.
  virtual bool usePost() const PURE;

  // The path used for POST method.
  virtual const std::string& postPath() const PURE;

  // The evaluator to add additional HTTP request headers to the upstream request.
  virtual Envoy::Http::HeaderEvaluator& headerEvaluator() const PURE;

  // Save HTTP response headers to the downstream filter state.
  virtual void
  propagateResponseHeaders(Http::ResponseHeaderMapPtr&& headers,
                           const StreamInfo::FilterStateSharedPtr& filter_state) const PURE;

  // Save HTTP response trailers to the downstream filter state.
  virtual void
  propagateResponseTrailers(Http::ResponseTrailerMapPtr&& trailers,
                            const StreamInfo::FilterStateSharedPtr& filter_state) const PURE;
};

using TunnelingConfigHelperOptConstRef = OptRef<const TunnelingConfigHelper>;

// An API for wrapping either a TCP or an HTTP connection pool.
class GenericConnPool : public Logger::Loggable<Logger::Id::router> {
public:
  virtual ~GenericConnPool() = default;

  /**
   * Called to create a TCP connection or HTTP stream for "CONNECT" streams.
   *
   * The implementation is then responsible for calling either onGenericPoolReady or
   * onGenericPoolFailure on the supplied GenericConnectionPoolCallbacks.
   *
   * @param callbacks callbacks to communicate stream failure or creation on.
   */
  virtual void newStream(GenericConnectionPoolCallbacks& callbacks) PURE;
};

// An API for the UpstreamRequest to get callbacks from either an HTTP or TCP
// connection pool.
class GenericConnectionPoolCallbacks {
public:
  virtual ~GenericConnectionPoolCallbacks() = default;

  /**
   * Called when GenericConnPool::newStream has established a new stream.
   *
   * @param info supplies the stream info object associated with the upstream connection.
   * @param upstream supplies the generic upstream for the stream.
   * @param host supplies the description of the host that will carry the request.
   * @param address_provider supplies the address provider of the upstream connection.
   * @param ssl_info supplies the ssl information of the upstream connection.
   */
  virtual void onGenericPoolReady(StreamInfo::StreamInfo* info,
                                  std::unique_ptr<GenericUpstream>&& upstream,
                                  Upstream::HostDescriptionConstSharedPtr& host,
                                  const Network::ConnectionInfoProvider& address_provider,
                                  Ssl::ConnectionInfoConstSharedPtr ssl_info) PURE;

  /**
   * Called to indicate a failure for GenericConnPool::newStream to establish a stream.
   *
   * @param reason supplies the failure reason.
   * @param failure_reason failure reason string (Note: it is expected that the caller will provide
   * matching `reason` and `failure_reason`).
   * @param host supplies the description of the host that caused the failure. This may be nullptr
   *             if no host was involved in the failure (for example overflow).
   */
  virtual void onGenericPoolFailure(ConnectionPool::PoolFailureReason reason,
                                    absl::string_view failure_reason,
                                    Upstream::HostDescriptionConstSharedPtr host) PURE;
};

// Interface for a generic Upstream, which can communicate with a TCP or HTTP
// upstream.
class GenericUpstream {
public:
  virtual ~GenericUpstream() = default;

  /**
   * Enable/disable further data from this stream.
   *
   * @param disable true if the stream should be read disabled, false otherwise.
   * @return returns true if the disable is performed, false otherwise
   *         (e.g. if the connection is closed)
   */
  virtual bool readDisable(bool disable) PURE;

  /**
   * Encodes data upstream.
   * @param data supplies the data to encode. The data may be moved by the encoder.
   * @param end_stream supplies whether this is the last data to encode.
   */
  virtual void encodeData(Buffer::Instance& data, bool end_stream) PURE;

  /**
   * Adds a callback to be called when the data is sent to the kernel.
   * @param cb supplies the callback to be called
   */
  virtual void addBytesSentCallback(Network::Connection::BytesSentCb cb) PURE;

  /**
   * Called when an event is received on the downstream connection
   * @param event supplies the event which occurred.
   * @return the underlying ConnectionData if the event is not "Connected" and draining
             is supported for this upstream.
   */
  virtual Tcp::ConnectionPool::ConnectionData*
  onDownstreamEvent(Network::ConnectionEvent event) PURE;

  /* Called to convert underlying transport socket from non-secure mode
   * to secure mode. Implemented only by start_tls transport socket.
   */
  virtual bool startUpstreamSecureTransport() PURE;

  /**
   * Called when upstream starttls socket is converted to tls and upstream ssl info
   * needs to be set in the connection's stream_info.
   * @return the const SSL connection data of upstream.
   */
  virtual Ssl::ConnectionInfoConstSharedPtr getUpstreamConnectionSslInfo() PURE;
};

using GenericConnPoolPtr = std::unique_ptr<GenericConnPool>;

/*
 * A factory for creating generic connection pools.
 */
class GenericConnPoolFactory : public Envoy::Config::TypedFactory {
public:
  ~GenericConnPoolFactory() override = default;

  /*
   * @param thread_local_cluster the thread local cluster to use for conn pool creation.
   * @param config the tunneling config, if doing connect tunneling.
   * @param context the load balancing context for this connection.
   * @param upstream_callbacks the callbacks to provide to the connection if successfully created.
   * @param downstream_info is the downstream connection stream info.
   * @return may be null if there is no cluster with the given name.
   */
  virtual GenericConnPoolPtr
  createGenericConnPool(Upstream::ThreadLocalCluster& thread_local_cluster,
                        TunnelingConfigHelperOptConstRef config,
                        Upstream::LoadBalancerContext* context,
                        Tcp::ConnectionPool::UpstreamCallbacks& upstream_callbacks,
                        StreamInfo::StreamInfo& downstream_info) const PURE;
};

using GenericConnPoolFactoryPtr = std::unique_ptr<GenericConnPoolFactory>;

} // namespace TcpProxy
} // namespace Envoy
#pragma once

#include <functional>
#include <memory>

#include "envoy/buffer/buffer.h"
#include "envoy/common/conn_pool.h"
#include "envoy/common/pure.h"
#include "envoy/event/deferred_deletable.h"
#include "envoy/upstream/upstream.h"

namespace Envoy {
namespace Tcp {
namespace ConnectionPool {

/*
 * UpstreamCallbacks for connection pool upstream connection callbacks and data. Note that
 * onEvent(Connected) is never triggered since the event always occurs before a ConnectionPool
 * caller is assigned a connection.
 */
class UpstreamCallbacks : public Network::ConnectionCallbacks {
public:
  ~UpstreamCallbacks() override = default;

  /*
   * Invoked when data is delivered from the upstream connection while the connection is owned by a
   * ConnectionPool::Instance caller.
   * @param data supplies data from the upstream
   * @param end_stream whether the data is the last data frame
   */
  virtual void onUpstreamData(Buffer::Instance& data, bool end_stream) PURE;
};

/**
 * ConnectionState is a base class for connection state maintained across requests. For example, a
 * protocol may maintain a connection-specific request sequence number or negotiate options that
 * affect the behavior of requests for the duration of the connection. A ConnectionState subclass
 * is assigned to the ConnectionData to track this state when the connection is returned to the
 * pool so that the state is available when the connection is re-used for a subsequent request.
 * The ConnectionState assigned to a connection is automatically destroyed when the connection is
 * closed.
 */
class ConnectionState {
public:
  virtual ~ConnectionState() = default;
};

using ConnectionStatePtr = std::unique_ptr<ConnectionState>;

/*
 * ConnectionData wraps a ClientConnection allocated to a caller. Open ClientConnections are
 * released back to the pool for re-use when their containing ConnectionData is destroyed.
 */
class ConnectionData {
public:
  virtual ~ConnectionData() = default;

  /**
   * @return the ClientConnection for the connection.
   */
  virtual Network::ClientConnection& connection() PURE;

  /**
   * Sets the ConnectionState for this connection. Any existing ConnectionState is destroyed.
   * @param ConnectionStatePtr&& new ConnectionState for this connection.
   */
  virtual void setConnectionState(ConnectionStatePtr&& state) PURE;

  /**
   * @return T* the current ConnectionState or nullptr if no state is set or if the state's type
   *            is not T.
   */
  template <class T> T* connectionStateTyped() { return dynamic_cast<T*>(connectionState()); }

  /**
   * Sets the ConnectionPool::UpstreamCallbacks for the connection. If no callback is attached,
   * data from the upstream will cause the connection to be closed. Callbacks cease when the
   * connection is released.
   * @param callback the UpstreamCallbacks to invoke for upstream data
   */
  virtual void addUpstreamCallbacks(ConnectionPool::UpstreamCallbacks& callback) PURE;

protected:
  /**
   * @return ConnectionState* pointer to the current ConnectionState or nullptr if not set
   */
  virtual ConnectionState* connectionState() PURE;
};

using ConnectionDataPtr = std::unique_ptr<ConnectionData>;
using PoolFailureReason = ::Envoy::ConnectionPool::PoolFailureReason;
using Cancellable = ::Envoy::ConnectionPool::Cancellable;
using CancelPolicy = ::Envoy::ConnectionPool::CancelPolicy;

/**
 * Pool callbacks invoked in the context of a newConnection() call, either synchronously or
 * asynchronously.
 */
class Callbacks {
public:
  virtual ~Callbacks() = default;

  /**
   * Called when a pool error occurred and no connection could be acquired for making the request.
   * @param reason supplies the failure reason.
   * @param transport_failure_reason supplies the details of the transport failure reason.
   * @param host supplies the description of the host that caused the failure. This may be nullptr
   *             if no host was involved in the failure (for example overflow).
   */
  virtual void onPoolFailure(PoolFailureReason reason, absl::string_view transport_failure_reason,
                             Upstream::HostDescriptionConstSharedPtr host) PURE;

  /**
   * Called when a connection is available to process a request/response. Connections may be
   * released back to the pool for re-use by resetting the ConnectionDataPtr. If the connection is
   * no longer viable for reuse (e.g. due to some kind of protocol error), the underlying
   * ClientConnection should be closed to prevent its reuse.
   *
   * @param conn supplies the connection data to use.
   * @param host supplies the description of the host that will carry the request. For logical
   *             connection pools the description may be different each time this is called.
   */
  virtual void onPoolReady(ConnectionDataPtr&& conn,
                           Upstream::HostDescriptionConstSharedPtr host) PURE;
};

/**
 * An instance of a generic connection pool.
 */
class Instance : public Envoy::ConnectionPool::Instance, public Event::DeferredDeletable {
public:
  /**
   * Immediately close all existing connection pool connections. This method can be used in cases
   * where the connection pool is not being destroyed, but the caller wishes to terminate all
   * existing connections. For example, when a health check failure occurs.
   */
  virtual void closeConnections() PURE;

  /**
   * Create a new connection on the pool.
   * @param cb supplies the callbacks to invoke when the connection is ready or has failed. The
   *           callbacks may be invoked immediately within the context of this call if there is a
   *           ready connection or an immediate failure. In this case, the routine returns nullptr.
   * @return Cancellable* If no connection is ready, the callback is not invoked, and a handle
   *                      is returned that can be used to cancel the request. Otherwise, one of the
   *                      callbacks is called and the routine returns nullptr. NOTE: Once a callback
   *                      is called, the handle is no longer valid and any further cancellation
   *                      should be done by resetting the connection.
   */
  virtual Cancellable* newConnection(Callbacks& callbacks) PURE;
};

using InstancePtr = std::unique_ptr<Instance>;

} // namespace ConnectionPool
} // namespace Tcp
} // namespace Envoy
#pragma once

#include <memory>
#include <string>

#include "envoy/common/pure.h"
#include "envoy/config/typed_config.h"
#include "envoy/http/header_map.h"
#include "envoy/server/factory_context.h"
#include "envoy/upstream/upstream.h"

namespace Envoy {
namespace Http {

/**
 * Interface class for session state. Session state is used to get address of upstream host
 * assigned to the session.
 */
class SessionState {
public:
  virtual ~SessionState() = default;

  /**
   * Get address of upstream host that the current session stuck on.
   *
   * @return absl::optional<absl::string_view> optional upstream address. If there is no available
   * session or no available address, absl::nullopt will be returned.
   */
  virtual absl::optional<absl::string_view> upstreamAddress() const PURE;

  /**
   * Called when a request is completed to update the session state.
   *
   * @param host the upstream host that was finally selected.
   * @param headers the response headers.
   */
  virtual void onUpdate(const Upstream::HostDescription& host, ResponseHeaderMap& headers) PURE;
};

using SessionStatePtr = std::unique_ptr<SessionState>;

/**
 * Interface class for creating session state from request headers.
 */
class SessionStateFactory {
public:
  virtual ~SessionStateFactory() = default;

  /**
   * Create session state from request headers.
   *
   * @param headers request headers.
   */
  virtual SessionStatePtr create(const RequestHeaderMap& headers) const PURE;
};

using SessionStateFactorySharedPtr = std::shared_ptr<SessionStateFactory>;

/*
 * Extension configuration for session state factory.
 */
class SessionStateFactoryConfig : public Envoy::Config::TypedFactory {
public:
  ~SessionStateFactoryConfig() override = default;

  /**
   * Creates a particular session state factory implementation.
   *
   * @param config supplies the configuration for the session state factory extension.
   * @param context supplies the factory context. Please don't store the reference to
   * the context as it is only valid during the call.
   * @return SessionStateFactorySharedPtr the session state factory.
   */
  virtual SessionStateFactorySharedPtr
  createSessionStateFactory(const Protobuf::Message& config,
                            Server::Configuration::GenericFactoryContext& context) PURE;

  std::string category() const override { return "envoy.http.stateful_session"; }
};

using SessionStateFactoryConfigPtr = std::unique_ptr<SessionStateFactoryConfig>;

} // namespace Http
} // namespace Envoy
#pragma once

#include <string>

#include "source/common/singleton/const_singleton.h"

namespace Envoy {
namespace Http {

struct UhvResponseCodeDetailValues {
  const std::string InvalidNameCharacters = "uhv.invalid_name_characters";
  const std::string InvalidValueCharacters = "uhv.invalid_value_characters";
  const std::string InvalidUrl = "uhv.invalid_url";
  const std::string InvalidHost = "uhv.invalid_host";
  const std::string InvalidScheme = "uhv.invalid_scheme";
  const std::string InvalidMethod = "uhv.invalid_method";
  const std::string InvalidContentLength = "uhv.invalid_content_length";
  const std::string InvalidUnderscore = "uhv.unexpected_underscore";
  const std::string InvalidStatus = "uhv.invalid_status";
  const std::string EmptyHeaderName = "uhv.empty_header_name";
  const std::string InvalidPseudoHeader = "uhv.invalid_pseudo_header";
  const std::string InvalidHostDeprecatedUserInfo = "uhv.invalid_host_deprecated_user_info";
  const std::string FragmentInUrlPath = "uhv.fragment_in_url_path";
  const std::string EscapedSlashesInPath = "uhv.escaped_slashes_in_url_path";
  const std::string Percent00InPath = "uhv.percent_00_in_url_path";
};

using UhvResponseCodeDetail = ConstSingleton<UhvResponseCodeDetailValues>;

struct Http1ResponseCodeDetailValues {
  const std::string InvalidTransferEncoding = "http1.invalid_transfer_encoding";
  const std::string TransferEncodingNotAllowed = "uhv.http1.transfer_encoding_not_allowed";
  const std::string ContentLengthNotAllowed = "uhv.http1.content_length_not_allowed";
  const std::string ChunkedContentLength = "http1.content_length_and_chunked_not_allowed";
};

using Http1ResponseCodeDetail = ConstSingleton<Http1ResponseCodeDetailValues>;

struct PathNormalizerResponseCodeDetailValues {
  const std::string RedirectNormalized = "uhv.path_normalization_redirect";
};

using PathNormalizerResponseCodeDetail = ConstSingleton<PathNormalizerResponseCodeDetailValues>;

} // namespace Http
} // namespace Envoy
#pragma once

#include <cstddef>
#include <cstdint>

namespace Envoy {
namespace Http {

/**
 * Possible HTTP connection/request protocols. The parallel NumProtocols constant allows defining
 * fixed arrays for each protocol, but does not pollute the enum.
 */
enum class Protocol : uint8_t { Http10, Http11, Http2, Http3 };
const size_t NumProtocols = 4;

} // namespace Http
} // namespace Envoy
#pragma once

#include "envoy/http/codec.h"

namespace Envoy {
namespace Http {

class RequestDecoderHandle {
public:
  virtual ~RequestDecoderHandle() = default;

  /**
   * @return a reference to the underlying decoder if it is still valid.
   */
  virtual OptRef<RequestDecoder> get() PURE;
};
using RequestDecoderHandlePtr = std::unique_ptr<RequestDecoderHandle>;

/**
 * ApiListener that allows consumers to interact with HTTP streams via API calls.
 */
// TODO(junr03): this is a replica of the functions in ServerConnectionCallbacks. It would be nice
// to not duplicate this interface layout.
class ApiListener {
public:
  virtual ~ApiListener() = default;

  /**
   * Invoked when a new request stream is initiated by the remote.
   * @param response_encoder supplies the encoder to use for creating the response. The request and
   *                         response are backed by the same Stream object.
   * @param is_internally_created indicates if this stream was originated by a
   *   client, or was created by Envoy, by example as part of an internal redirect.
   * @return RequestDecoderHandle supplies the decoder callbacks to fire into for stream
   *   decoding events.
   */
  virtual RequestDecoderHandlePtr newStreamHandle(ResponseEncoder& response_encoder,
                                                  bool is_internally_created = false) PURE;
};

using ApiListenerPtr = std::unique_ptr<ApiListener>;
using ApiListenerOptRef = absl::optional<std::reference_wrapper<ApiListener>>;

} // namespace Http
} // namespace Envoy
#pragma once

#include <chrono>

#include "envoy/stats/scope.h"

namespace Envoy {
namespace Http {

/**
 * HTTP response codes.
 * http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
 */
enum class Code : uint16_t {
  // clang-format off
  Continue                      = 100,
  SwitchingProtocols            = 101,

  OK                            = 200,
  Created                       = 201,
  Accepted                      = 202,
  NonAuthoritativeInformation   = 203,
  NoContent                     = 204,
  ResetContent                  = 205,
  PartialContent                = 206,
  MultiStatus                   = 207,
  AlreadyReported               = 208,
  IMUsed                        = 226,

  MultipleChoices               = 300,
  MovedPermanently              = 301,
  Found                         = 302,
  SeeOther                      = 303,
  NotModified                   = 304,
  UseProxy                      = 305,
  TemporaryRedirect             = 307,
  PermanentRedirect             = 308,

  BadRequest                    = 400,
  Unauthorized                  = 401,
  PaymentRequired               = 402,
  Forbidden                     = 403,
  NotFound                      = 404,
  MethodNotAllowed              = 405,
  NotAcceptable                 = 406,
  ProxyAuthenticationRequired   = 407,
  RequestTimeout                = 408,
  Conflict                      = 409,
  Gone                          = 410,
  LengthRequired                = 411,
  PreconditionFailed            = 412,
  PayloadTooLarge               = 413,
  URITooLong                    = 414,
  UnsupportedMediaType          = 415,
  RangeNotSatisfiable           = 416,
  ExpectationFailed             = 417,
  MisdirectedRequest            = 421,
  UnprocessableEntity           = 422,
  Locked                        = 423,
  FailedDependency              = 424,
  TooEarly                      = 425,
  UpgradeRequired               = 426,
  PreconditionRequired          = 428,
  TooManyRequests               = 429,
  RequestHeaderFieldsTooLarge   = 431,

  InternalServerError           = 500,
  NotImplemented                = 501,
  BadGateway                    = 502,
  ServiceUnavailable            = 503,
  GatewayTimeout                = 504,
  HTTPVersionNotSupported       = 505,
  VariantAlsoNegotiates         = 506,
  InsufficientStorage           = 507,
  LoopDetected                  = 508,
  NotExtended                   = 510,
  NetworkAuthenticationRequired = 511
  // clang-format on
};

/**
 * Manages updating of statistics for HTTP Status Codes. Sets up string-tokens
 * for fast combining of tokens based on scope, status-code buckets (2xx,
 * 4xx...), and exact status code.
 */
class CodeStats {
public:
  virtual ~CodeStats() = default;

  struct ResponseStatInfo;
  struct ResponseTimingInfo;

  /**
   * Charge a simple response stat to an upstream. exclude_http_code_stats will skip charging
   * HTTP group/individual status code stats if set to True.
   */
  virtual void chargeBasicResponseStat(Stats::Scope& scope, Stats::StatName prefix,
                                       Code response_code, bool exclude_http_code_stats) const PURE;

  /**
   * Charge a response stat to both agg counters (*xx) as well as code specific counters. This
   * routine also looks for the x-envoy-upstream-canary header and if it is set, also charges
   * canary stats. exclude_http_code_stats will skip charging HTTP group/individual status
   * code stats if set to True.
   */
  virtual void chargeResponseStat(const ResponseStatInfo& info,
                                  bool exclude_http_code_stats) const PURE;

  /**
   * Charge a response timing to the various dynamic stat postfixes.
   */
  virtual void chargeResponseTiming(const ResponseTimingInfo& info) const PURE;
};

} // namespace Http
} // namespace Envoy
#pragma once

#include "envoy/formatter/substitution_formatter.h"
#include "envoy/http/header_map.h"
#include "envoy/stream_info/stream_info.h"

namespace Envoy {
namespace Http {

// The interface of applying operations to a header map.
class HeaderEvaluator {
public:
  virtual ~HeaderEvaluator() = default;
  /**
   * Apply the header operations that are saved in the HeaderEvaluator. An example of the operation
   * is to add a new header name `foo` to the target header map and the header value is extracted
   * from the `bar` field in the stream_info, request headers or response headers.
   *
   * @param headers the target header map to be mutated.
   * @param context context to format the header value.
   * @param stream_info the source of values that can be used in the evaluation.
   */
  virtual void evaluateHeaders(Http::HeaderMap& headers,
                               const Formatter::HttpFormatterContext& context,
                               const StreamInfo::StreamInfo& stream_info) const PURE;
};
} // namespace Http
} // namespace Envoy
#pragma once

#include <functional>
#include <map>

#include "envoy/common/pure.h"

#include "absl/strings/string_view.h"
#include "absl/types/optional.h"

namespace Envoy {
namespace Http {

class FilterChainFactoryCallbacks;

/**
 * This function is used to wrap the creation of an HTTP filter chain for new streams as they
 * come in. Filter factories create the function at configuration initialization time, and then
 * they are used at runtime.
 * @param callbacks supplies the callbacks for the stream to install filters to. Typically the
 * function will install a single filter, but it's technically possibly to install more than one
 * if desired.
 */
using FilterFactoryCb = std::function<void(FilterChainFactoryCallbacks& callbacks)>;

/**
 * Simple struct of additional contextual information of HTTP filter, e.g. filter config name
 * from configuration, canonical filter name, etc.
 */
struct FilterContext {
  // The name of the filter configuration that used to create related filter factory function.
  // This could be any legitimate non-empty string.
  std::string config_name;
  // Filter extension qualified name. This is used as a fallback of `config_name`. E.g.,
  // "envoy.filters.http.buffer" for the HTTP buffer filter.
  std::string filter_name;
};

/**
 * Additional options for creating HTTP filter chain.
 * TODO(wbpcode): it is possible to add more options to customize HTTP filter chain creation.
 * For example, we can add related options here to tell FilterChainFactory to create
 * upgrade filter chain or not.
 */
class FilterChainOptions {
public:
  virtual ~FilterChainOptions() = default;

  /**
   * Skip filter creation if the filter is explicitly disabled after the filter chain is
   * selected.
   *
   * @param config_name the config name of the filter.
   * @return whether the filter should be disabled or enabled based on the config name.
   *         nullopt if no decision can be made explicitly for the filter.
   */
  virtual absl::optional<bool> filterDisabled(absl::string_view config_name) const PURE;
};

class EmptyFilterChainOptions : public FilterChainOptions {
public:
  absl::optional<bool> filterDisabled(absl::string_view) const override { return {}; }
};

/**
 * The filter chain manager is provided by the connection manager to the filter chain factory.
 * The filter chain factory will post the filter factory context and filter factory to the
 * filter chain manager to create filter and construct HTTP stream filter chain.
 */
class FilterChainManager {
public:
  virtual ~FilterChainManager() = default;

  /**
   * Post filter factory context and filter factory to the filter chain manager. The filter
   * chain manager will create filter instance based on the context and factory internally.
   * @param context supplies additional contextual information of filter factory.
   * @param factory factory function used to create filter instances.
   */
  virtual void applyFilterFactoryCb(FilterContext context, FilterFactoryCb& factory) PURE;
};

/**
 * A FilterChainFactory is used by a connection manager to create an HTTP level filter chain when a
 * new stream is created on the connection (either locally or remotely). Typically it would be
 * implemented by a configuration engine that would install a set of filters that are able to
 * process an application scenario on top of a stream.
 */
class FilterChainFactory {
public:
  virtual ~FilterChainFactory() = default;

  /**
   * Called when a new HTTP stream is created on the connection.
   * @param manager supplies the "sink" that is used for actually creating the filter chain. @see
   *                FilterChainManager.
   * @param only_create_if_configured if true, only creates filter chain if there is a non-default
   *                                  configured filter chain. Default false.
   * @param options additional options for creating a filter chain.
   * @return whather a filter chain has been created.
   */
  virtual bool
  createFilterChain(FilterChainManager& manager, bool only_create_if_configured = false,
                    const FilterChainOptions& options = EmptyFilterChainOptions{}) const PURE;

  /**
   * Called when a new upgrade stream is created on the connection.
   * @param upgrade supplies the upgrade header from downstream
   * @param per_route_upgrade_map supplies the upgrade map, if any, for this route.
   * @param manager supplies the "sink" that is used for actually creating the filter chain. @see
   *                FilterChainManager.
   * @return true if upgrades of this type are allowed and the filter chain has been created.
   *    returns false if this upgrade type is not configured, and no filter chain is created.
   */
  using UpgradeMap = std::map<std::string, bool>;
  virtual bool createUpgradeFilterChain(absl::string_view upgrade,
                                        const UpgradeMap* per_route_upgrade_map,
                                        FilterChainManager& manager) const PURE;
};

} // namespace Http
} // namespace Envoy
#pragma once

#include <memory>
#include <string>

#include "envoy/common/pure.h"
#include "envoy/config/typed_config.h"
#include "envoy/http/codes.h"
#include "envoy/http/header_map.h"
#include "envoy/network/address.h"
#include "envoy/server/factory_context.h"

namespace Envoy {
namespace Http {

struct OriginalIPDetectionParams {
  // The request headers from downstream.
  //
  // Note that while extensions can modify the headers, they will undergo standard Envoy
  // sanitation after the detect() call so additions made here may be removed before
  // filters have access to headers.
  Http::RequestHeaderMap& request_headers;
  // The downstream directly connected address.
  const Network::Address::InstanceConstSharedPtr& downstream_remote_address;
};

// Parameters to be used for sending a local reply when detection fails.
struct OriginalIPRejectRequestOptions {
  Code response_code;
  std::string body;
};

struct OriginalIPDetectionResult {
  // An address that represents the detected address or nullptr if detection failed.
  Network::Address::InstanceConstSharedPtr detected_remote_address;
  // Is the detected address trusted (e.g.: can it be used to determine if this is an internal
  // request).
  bool allow_trusted_address_checks;
  // If set, these parameters will be used to signal that detection failed and the request should
  // be rejected.
  absl::optional<OriginalIPRejectRequestOptions> reject_options;
};

/**
 * Interface class for original IP detection extensions.
 */
class OriginalIPDetection {
public:
  virtual ~OriginalIPDetection() = default;

  /**
   * Detect the final remote address.
   *
   * If the call to this method succeeds in detecting the remote IP address or
   * fails and is configured to reject the request in that case, no other
   * configured extensions will be called (if any).
   *
   * @param param supplies the OriginalIPDetectionParams params for detection.
   * @return OriginalIPDetectionResult the result of the extension's attempt to detect
   * the final remote address.
   */
  virtual OriginalIPDetectionResult detect(OriginalIPDetectionParams& params) PURE;
};

using OriginalIPDetectionSharedPtr = std::shared_ptr<OriginalIPDetection>;

/*
 * A factory for creating original IP detection extensions.
 */
class OriginalIPDetectionFactory : public Envoy::Config::TypedFactory {
public:
  ~OriginalIPDetectionFactory() override = default;

  /**
   * Creates a particular extension implementation.
   *
   * @param config supplies the configuration for the original IP detection extension.
   * @return OriginalIPDetectionSharedPtr the extension instance.
   */
  virtual OriginalIPDetectionSharedPtr
  createExtension(const Protobuf::Message& config,
                  Server::Configuration::FactoryContext& context) PURE;

  std::string category() const override { return "envoy.http.original_ip_detection"; }
};

using OriginalIPDetectionFactoryPtr = std::unique_ptr<OriginalIPDetectionFactory>;

} // namespace Http
} // namespace Envoy
#pragma once

#include <map>
#include <string>
#include <vector>

#include "absl/container/btree_map.h"
#include "absl/strings/string_view.h"
#include "absl/types/optional.h"
#include "header_map.h"

namespace Envoy {
namespace Http {
namespace Utility {

using QueryParamsVector = std::vector<std::pair<std::string, std::string>>;

class QueryParamsMulti {
private:
  absl::btree_map<std::string, std::vector<std::string>> data_;

public:
  void remove(absl::string_view key);
  void add(absl::string_view key, absl::string_view value);
  void overwrite(absl::string_view key, absl::string_view value);
  std::string toString() const;
  std::string replaceQueryString(const HeaderString& path) const;
  absl::optional<std::string> getFirstValue(absl::string_view key) const;

  const absl::btree_map<std::string, std::vector<std::string>>& data() const { return data_; }

  static QueryParamsMulti parseParameters(absl::string_view data, size_t start, bool decode_params);
  static QueryParamsMulti parseQueryString(absl::string_view url);
  static QueryParamsMulti parseAndDecodeQueryString(absl::string_view url);
};

} // namespace Utility
} // namespace Http
} // namespace Envoy
#pragma once

#include <memory>

#include "envoy/config/trace/v3/http_tracer.pb.h"
#include "envoy/http/codes.h"

namespace Envoy {
namespace Http {

struct UserAgentContext;

/**
 * Captures http-related structures with cardinality of one per server.
 */
class Context {
public:
  virtual ~Context() = default;

  /**
   * Get the default tracing configuration, i.e. one from the bootstrap config.
   *
   * Once deprecation window for the tracer provider configuration in the bootstrap config is over,
   * this method will no longer be necessary.
   *
   * @return Tracing.
   */
  virtual const envoy::config::trace::v3::Tracing& defaultTracingConfig() PURE;

  virtual CodeStats& codeStats() PURE;
  virtual const UserAgentContext& userAgentContext() const PURE;
  virtual const Stats::StatName& asyncClientStatPrefix() const PURE;
};

using ContextPtr = std::unique_ptr<Context>;

} // namespace Http
} // namespace Envoy
#pragma once

#include <memory>
#include <string>

#include "envoy/buffer/buffer.h"
#include "envoy/http/header_map.h"

namespace Envoy {
namespace Http {

/**
 * Wraps an HTTP message including its headers, body, and any trailers.
 */
template <class HeaderType, class TrailerType> class Message {
public:
  virtual ~Message() = default;

  /**
   * @return HeaderType& the message headers.
   */
  virtual HeaderType& headers() PURE;

  /**
   * @return Buffer::Instance the message body, if any. Callers are free to modify the body.
   */
  virtual Buffer::Instance& body() PURE;

  /**
   * @return TrailerType* the message trailers, if any.
   */
  virtual TrailerType* trailers() PURE;

  /**
   * Set the trailers.
   * @param trailers supplies the new trailers.
   */
  virtual void trailers(std::unique_ptr<TrailerType>&& trailers) PURE;

  /**
   * @return std::string the message body as a std::string.
   */
  virtual std::string bodyAsString() const PURE;
};

using RequestMessage = Message<RequestHeaderMap, RequestTrailerMap>;
using RequestMessagePtr = std::unique_ptr<RequestMessage>;
using ResponseMessage = Message<ResponseHeaderMap, ResponseTrailerMap>;
using ResponseMessagePtr = std::unique_ptr<ResponseMessage>;

} // namespace Http
} // namespace Envoy
#pragma once

#include <memory>
#include <string>

#include "envoy/common/pure.h"
#include "envoy/http/header_map.h"
#include "envoy/tracing/trace_reason.h"

namespace Envoy {
namespace Http {

/**
 * Abstract request id utilities for getting/setting the request IDs and tracing status of requests
 */
class RequestIDExtension {
public:
  virtual ~RequestIDExtension() = default;

  /**
   *  Get the request ID from the request headers.
   * @param request_headers supplies the incoming request headers for retrieving the request ID.
   * @return the string view or nullopt if the request ID is invalid.
   */
  virtual absl::optional<absl::string_view>
  get(const Http::RequestHeaderMap& request_headers) const PURE;

  /**
   * Get and convert the request ID to a 64-bit integer representation for using in modulo, etc.
   * calculations.
   * @param request_headers supplies the incoming request headers for retrieving the request ID.
   * @return the integer or nullopt if the request ID is invalid.
   */
  virtual absl::optional<uint64_t>
  getInteger(const Http::RequestHeaderMap& request_headers) const PURE;

  /**
   * Directly set a request ID into the provided request headers. Override any previous request ID
   * if any.
   * @param request_headers supplies the incoming request headers for setting a request ID.
   * @param force specifies if a new request ID should be forcefully set if one is already present.
   */
  virtual void set(Http::RequestHeaderMap& request_headers, bool force) PURE;

  /**
   * Preserve request ID in response headers if any is set in the request headers.
   * @param response_headers supplies the downstream response headers for setting the request ID.
   * @param request_headers supplies the incoming request headers for retrieving the request ID.
   */
  virtual void setInResponse(Http::ResponseHeaderMap& response_headers,
                             const Http::RequestHeaderMap& request_headers) PURE;

  /**
   * Get the current tracing reason of a request given its headers.
   * @param request_headers supplies the incoming request headers for retrieving the request ID.
   * @return trace reason of the request based on the given headers.
   */
  virtual Tracing::Reason getTraceReason(const Http::RequestHeaderMap& request_headers) PURE;

  /**
   * Set the tracing status of a request.
   * @param request_headers supplies the incoming request headers for setting the trace reason.
   * @param status the trace reason that should be set for this request.
   */
  virtual void setTraceReason(Http::RequestHeaderMap& request_headers, Tracing::Reason reason) PURE;

  /**
   * Get whether to use request_id based sampling policy or not.
   * @return whether to use request_id based sampling policy or not.
   */
  virtual bool useRequestIdForTraceSampling() const PURE;
};

using RequestIDExtensionSharedPtr = std::shared_ptr<RequestIDExtension>;

} // namespace Http
} // namespace Envoy
#pragma once

#include "envoy/common/optref.h"
#include "envoy/config/typed_config.h"

namespace Envoy {
namespace Http {

/**
 * Interface for generic header key formatting.
 */
class HeaderKeyFormatter {
public:
  virtual ~HeaderKeyFormatter() = default;

  /**
   * Given an input key return the formatted key to encode.
   */
  virtual std::string format(absl::string_view key) const PURE;
};

using HeaderKeyFormatterConstPtr = std::unique_ptr<const HeaderKeyFormatter>;
using HeaderKeyFormatterOptConstRef = OptRef<const HeaderKeyFormatter>;

/**
 * Interface for header key formatters that are stateful. A formatter is created during decoding
 * headers, attached to the header map, and can then be used during encoding for reverse
 * translations if applicable.
 */
class StatefulHeaderKeyFormatter : public HeaderKeyFormatter {
public:
  /**
   * Called for each header key received by the codec.
   */
  virtual void processKey(absl::string_view key) PURE;

  /**
   * Called to save received reason phrase
   */
  virtual void setReasonPhrase(absl::string_view reason_phrase) PURE;

  /**
   * Called to get saved reason phrase
   */
  virtual absl::string_view getReasonPhrase() const PURE;
};

using StatefulHeaderKeyFormatterPtr = std::unique_ptr<StatefulHeaderKeyFormatter>;
using StatefulHeaderKeyFormatterOptRef = OptRef<StatefulHeaderKeyFormatter>;
using StatefulHeaderKeyFormatterOptConstRef = OptRef<const StatefulHeaderKeyFormatter>;

/**
 * Interface for creating stateful header key formatters.
 */
class StatefulHeaderKeyFormatterFactory {
public:
  virtual ~StatefulHeaderKeyFormatterFactory() = default;

  /**
   * Create a new formatter.
   */
  virtual StatefulHeaderKeyFormatterPtr create() PURE;
};

using StatefulHeaderKeyFormatterFactorySharedPtr =
    std::shared_ptr<StatefulHeaderKeyFormatterFactory>;

/**
 * Extension configuration for stateful header key formatters.
 */
class StatefulHeaderKeyFormatterFactoryConfig : public Config::TypedFactory {
public:
  virtual StatefulHeaderKeyFormatterFactorySharedPtr
  createFromProto(const Protobuf::Message& config) PURE;

  std::string category() const override { return "envoy.http.stateful_header_formatters"; }
};

} // namespace Http
} // namespace Envoy
#pragma once

#include <memory>

namespace Envoy {
namespace Http {

// Store quic helpers which can be shared between connections and must live beyond the lifetime of
// individual connections. When used in HTTP/3 upstream, it should be owned by cluster and shared
// across its HTTP/3 connection pools. This an opaque placeholder is needed so that an
// implementation can be passed around while the QUICHE members which are behind ENVOY_ENABLE_QUIC
// preprocessor in the actual implementation can be hidden from the Envoy intefaces.
struct PersistentQuicInfo {
  virtual ~PersistentQuicInfo() = default;
};

using PersistentQuicInfoPtr = std::unique_ptr<PersistentQuicInfo>;

} // namespace Http
} // namespace Envoy
#pragma once

#include <string>
#include <tuple>

#include "envoy/http/header_map.h"
#include "envoy/http/protocol.h"

namespace Envoy {
namespace Http {

/**
 * Common interface for server and client header validators.
 */
class HeaderValidator {
public:
  virtual ~HeaderValidator() = default;

  // A class that holds either success condition or an error condition with tuple of
  // action and error details.
  template <typename ActionType> class Result {
  public:
    using Action = ActionType;

    // Helper for constructing successful results
    static Result success() { return Result(ActionType::Accept, absl::string_view()); }

    Result(ActionType action, absl::string_view details) : result_(action, details) {
      ENVOY_BUG(action == ActionType::Accept || !details.empty(),
                "Error details must not be empty in case of an error");
    }

    bool ok() const { return std::get<0>(result_) == ActionType::Accept; }
    operator bool() const { return ok(); }
    absl::string_view details() const { return std::get<1>(result_); }
    Action action() const { return std::get<0>(result_); }

  private:
    const std::tuple<ActionType, std::string> result_;
  };

  enum class RejectAction { Accept, Reject };
  enum class RejectOrRedirectAction { Accept, Reject, Redirect };
  using RejectResult = Result<RejectAction>;
  using RejectOrRedirectResult = Result<RejectOrRedirectAction>;
  using TransformationResult = RejectResult;

  /**
   * Validate the entire request header map.
   * Returning the Reject value form this method causes the HTTP request to be rejected with 400
   * status, and the gRPC request with the INTERNAL (13) error code.
   */
  using ValidationResult = RejectResult;
  virtual ValidationResult validateRequestHeaders(const RequestHeaderMap& header_map) PURE;

  /**
   * Validate the entire response header map.
   * Returning the Reject value causes the HTTP request to be rejected with the 502 status,
   * and the gRPC request with the UNAVAILABLE (14) error code.
   */
  virtual ValidationResult validateResponseHeaders(const ResponseHeaderMap& header_map) PURE;

  /**
   * Validate the entire request trailer map.
   * Returning the Reject value causes the HTTP request to be rejected with the 502 status,
   * and the gRPC request with the UNAVAILABLE (14) error code.
   * If response headers have already been sent the request is reset.
   */
  virtual ValidationResult validateRequestTrailers(const RequestTrailerMap& trailer_map) PURE;

  /**
   * Validate the entire response trailer map.
   * Returning the Reject value causes the HTTP request to be reset.
   */
  virtual ValidationResult validateResponseTrailers(const ResponseTrailerMap& trailer_map) PURE;
};

/**
 * Interface for server header validators.
 */
class ServerHeaderValidator : public HeaderValidator {
public:
  ~ServerHeaderValidator() override = default;

  /**
   * Transform the entire request header map.
   * This method transforms the header map, for example by normalizing URI path, before processing
   * by the filter chain.
   * Returning the Reject value from this method causes the HTTP request to be rejected with 400
   * status, and the gRPC request with the INTERNAL (13) error code. Returning the Redirect
   * value causes the HTTP request to be redirected to the :path presudo header in the request map.
   * The gRPC request will still be rejected with the INTERNAL (13) error code.
   */
  using RequestHeadersTransformationResult = RejectOrRedirectResult;
  virtual RequestHeadersTransformationResult
  transformRequestHeaders(RequestHeaderMap& header_map) PURE;

  /**
   * Transform the entire request trailer map.
   * Returning the Reject value causes the HTTP request to be rejected with the 502 status,
   * and the gRPC request with the UNAVAILABLE (14) error code.
   * If response headers have already been sent the request is reset.
   */
  virtual TransformationResult transformRequestTrailers(RequestTrailerMap& header_map) PURE;

  /**
   * Transform the entire response header map.
   * HTTP/2 and HTTP/3 server header validator may transform the HTTP/1 upgrade response
   * to HTTP/2 extended CONNECT response, iff it transformed extended CONNECT to upgrade request
   * during request validation.
   * Returning the Reject value causes the HTTP request to be rejected with the 502 status,
   * and the gRPC request with the UNAVAILABLE (14) error code.
   */
  struct ResponseHeadersTransformationResult {
    static ResponseHeadersTransformationResult success() {
      return ResponseHeadersTransformationResult{RejectResult::success(), nullptr};
    }
    RejectResult status;
    ResponseHeaderMapPtr new_headers;
  };
  virtual ResponseHeadersTransformationResult
  transformResponseHeaders(const ResponseHeaderMap& header_map) PURE;
};

/**
 * Interface for server header validators.
 */
class ClientHeaderValidator : public HeaderValidator {
public:
  ~ClientHeaderValidator() override = default;

  /**
   * Transform the entire request header map.
   * This method can not mutate the header map as it is immutable after the terminal decoder filter.
   * However HTTP/2 and HTTP/3 header validators may need to change the request from the HTTP/1
   * upgrade to to the extended CONNECT. In this case the new header map is returned in the
   * `new_headers` member of the returned structure. Returning the Reject value form this method
   * causes the HTTP request to be rejected with 400 status, and the gRPC request with the INTERNAL
   * (13) error code.
   */
  struct RequestHeadersTransformationResult {
    static RequestHeadersTransformationResult success() {
      return RequestHeadersTransformationResult{RejectResult::success(), nullptr};
    }
    RejectResult status;
    RequestHeaderMapPtr new_headers;
  };
  virtual RequestHeadersTransformationResult
  transformRequestHeaders(const RequestHeaderMap& header_map) PURE;

  /**
   * Transform the entire response header map.
   * HTTP/2 and HTTP/3 client header validator may transform the extended CONNECT response
   * to HTTP/1 upgrade response, iff it transformed upgrade request to extended CONNECT
   * during request validation.
   * Returning the Reject value causes the HTTP request to be rejected with the 502 status,
   * and the gRPC request with the UNAVAILABLE (14) error code.
   */
  virtual TransformationResult transformResponseHeaders(ResponseHeaderMap& header_map) PURE;
};

using ServerHeaderValidatorPtr = std::unique_ptr<ServerHeaderValidator>;
using ClientHeaderValidatorPtr = std::unique_ptr<ClientHeaderValidator>;

/**
 * Interface for stats.
 */
class HeaderValidatorStats {
public:
  virtual ~HeaderValidatorStats() = default;

  virtual void incDroppedHeadersWithUnderscores() PURE;
  virtual void incRequestsRejectedWithUnderscoresInHeaders() PURE;
  virtual void incMessagingError() PURE;
};

/**
 * Interface for creating header validators.
 * TODO(yanavlasov): split into factories dedicated to server and client header validators.
 */
class HeaderValidatorFactory {
public:
  virtual ~HeaderValidatorFactory() = default;

  /**
   * Create a new header validator for the specified protocol.
   */
  virtual ServerHeaderValidatorPtr createServerHeaderValidator(Protocol protocol,
                                                               HeaderValidatorStats& stats) PURE;
  virtual ClientHeaderValidatorPtr createClientHeaderValidator(Protocol protocol,
                                                               HeaderValidatorStats& stats) PURE;
};

using HeaderValidatorFactoryPtr = std::unique_ptr<HeaderValidatorFactory>;

} // namespace Http
} // namespace Envoy
#pragma once

#include <cstdint>
#include <limits>
#include <memory>

#include "envoy/access_log/access_log.h"
#include "envoy/buffer/buffer.h"
#include "envoy/common/pure.h"
#include "envoy/grpc/status.h"
#include "envoy/http/header_formatter.h"
#include "envoy/http/header_map.h"
#include "envoy/http/metadata_interface.h"
#include "envoy/http/protocol.h"
#include "envoy/http/stream_reset_handler.h"
#include "envoy/network/address.h"
#include "envoy/stream_info/stream_info.h"

#include "source/common/http/status.h"

namespace Envoy {
namespace Http {

enum class CodecType { HTTP1, HTTP2, HTTP3 };

namespace Http1 {
struct CodecStats;
}

namespace Http2 {
struct CodecStats;
}

namespace Http3 {
struct CodecStats;
}

// Legacy default value of 60K is safely under both codec default limits.
static constexpr uint32_t DEFAULT_MAX_REQUEST_HEADERS_KB = 60;
// Default maximum number of headers.
static constexpr uint32_t DEFAULT_MAX_HEADERS_COUNT = 100;

const char MaxRequestHeadersCountOverrideKey[] =
    "envoy.reloadable_features.max_request_headers_count";
const char MaxResponseHeadersCountOverrideKey[] =
    "envoy.reloadable_features.max_response_headers_count";
const char MaxRequestHeadersSizeOverrideKey[] =
    "envoy.reloadable_features.max_request_headers_size_kb";

class Stream;
class RequestDecoder;

/**
 * Error codes used to convey the reason for a GOAWAY.
 */
enum class GoAwayErrorCode {
  NoError,
  Other,
};

/**
 * Stream encoder options specific to HTTP/1.
 */
class Http1StreamEncoderOptions {
public:
  virtual ~Http1StreamEncoderOptions() = default;

  /**
   * Force disable chunk encoding, even if there is no known content length. This effectively forces
   * HTTP/1.0 behavior in which the connection will need to be closed to indicate end of stream.
   */
  virtual void disableChunkEncoding() PURE;
};

using Http1StreamEncoderOptionsOptRef =
    absl::optional<std::reference_wrapper<Http1StreamEncoderOptions>>;

/**
 * Encodes an HTTP stream. This interface contains methods common to both the request and response
 * path.
 * TODO(mattklein123): Consider removing the StreamEncoder interface entirely and just duplicating
 * the methods in both the request/response path for simplicity.
 */
class StreamEncoder {
public:
  virtual ~StreamEncoder() = default;

  /**
   * Encode a data frame.
   * @param data supplies the data to encode. The data may be moved by the encoder.
   * @param end_stream supplies whether this is the last data frame.
   */
  virtual void encodeData(Buffer::Instance& data, bool end_stream) PURE;

  /**
   * @return Stream& the backing stream.
   */
  virtual Stream& getStream() PURE;

  /**
   * Encode metadata.
   * @param metadata_map_vector is the vector of metadata maps to encode.
   */
  virtual void encodeMetadata(const MetadataMapVector& metadata_map_vector) PURE;

  /**
   * Return the HTTP/1 stream encoder options if applicable. If the stream is not HTTP/1 returns
   * absl::nullopt.
   */
  virtual Http1StreamEncoderOptionsOptRef http1StreamEncoderOptions() PURE;
};

/**
 * Stream encoder used for sending a request (client to server). Virtual inheritance is required
 * due to a parallel implementation split between the shared base class and the derived class.
 */
class RequestEncoder : public virtual StreamEncoder {
public:
  /**
   * Encode headers, optionally indicating end of stream.
   * @param headers supplies the header map to encode. Must have required HTTP headers.
   * @param end_stream supplies whether this is a header only request.
   * @return Status indicating whether encoding succeeded. Encoding will fail if request
   * headers are missing required HTTP headers (method, path for non-CONNECT, host for CONNECT).
   */
  virtual Status encodeHeaders(const RequestHeaderMap& headers, bool end_stream) PURE;

  /**
   * Encode trailers. This implicitly ends the stream.
   * @param trailers supplies the trailers to encode.
   */
  virtual void encodeTrailers(const RequestTrailerMap& trailers) PURE;

  /**
   * Enable TCP Tunneling.
   */
  virtual void enableTcpTunneling() PURE;
};

/**
 * Stream encoder used for sending a response (server to client). Virtual inheritance is required
 * due to a parallel implementation split between the shared base class and the derived class.
 */
class ResponseEncoder : public virtual StreamEncoder {
public:
  /**
   * Encode supported 1xx headers.
   * Currently 100-Continue, 102-Processing, and 103-Early-Data headers are supported.
   * @param headers supplies the 1xx header map to encode.
   */
  virtual void encode1xxHeaders(const ResponseHeaderMap& headers) PURE;

  /**
   * Encode headers, optionally indicating end of stream. Response headers must
   * have a valid :status set.
   * @param headers supplies the header map to encode.
   * @param end_stream supplies whether this is a header only response.
   */
  virtual void encodeHeaders(const ResponseHeaderMap& headers, bool end_stream) PURE;

  /**
   * Encode trailers. This implicitly ends the stream.
   * @param trailers supplies the trailers to encode.
   */
  virtual void encodeTrailers(const ResponseTrailerMap& trailers) PURE;

  /**
   * Indicates whether invalid HTTP messaging should be handled with a stream error or a connection
   * error.
   */
  virtual bool streamErrorOnInvalidHttpMessage() const PURE;

  /**
   * Set a new request decoder for this ResponseEncoder. This is helpful in the case of an internal
   * redirect, in which a new request decoder is created in the context of the same downstream
   * request.
   * @param decoder new request decoder.
   */
  virtual void setRequestDecoder(RequestDecoder& decoder) PURE;

  /**
   * Set headers, trailers, and stream info for deferred logging. This allows HCM to hand off
   * stream-level details to the codec for logging after the stream may be destroyed (e.g. on
   * receiving the final ack packet from the client). Note that headers and trailers are const
   * as they will not be modified after this point.
   * @param request_header_map Request headers for this stream.
   * @param response_header_map Response headers for this stream.
   * @param response_trailer_map Response trailers for this stream.
   * @param stream_info Stream info for this stream.
   */
  virtual void
  setDeferredLoggingHeadersAndTrailers(Http::RequestHeaderMapConstSharedPtr request_header_map,
                                       Http::ResponseHeaderMapConstSharedPtr response_header_map,
                                       Http::ResponseTrailerMapConstSharedPtr response_trailer_map,
                                       StreamInfo::StreamInfo& stream_info) PURE;
};

/**
 * Decodes an HTTP stream. These are callbacks fired into a sink. This interface contains methods
 * common to both the request and response path.
 * TODO(mattklein123): Consider removing the StreamDecoder interface entirely and just duplicating
 * the methods in both the request/response path for simplicity.
 */
class StreamDecoder {
public:
  virtual ~StreamDecoder() = default;

  /**
   * Called with a decoded data frame.
   * @param data supplies the decoded data.
   * @param end_stream supplies whether this is the last data frame.
   */
  virtual void decodeData(Buffer::Instance& data, bool end_stream) PURE;

  /**
   * Called with decoded METADATA.
   * @param decoded METADATA.
   */
  virtual void decodeMetadata(MetadataMapPtr&& metadata_map) PURE;
};

/**
 * Stream decoder used for receiving a request (client to server). Virtual inheritance is required
 * due to a parallel implementation split between the shared base class and the derived class.
 */
class RequestDecoder : public virtual StreamDecoder {
public:
  /**
   * Called with decoded headers, optionally indicating end of stream.
   * @param headers supplies the decoded headers map.
   * @param end_stream supplies whether this is a header only request.
   */
  virtual void decodeHeaders(RequestHeaderMapSharedPtr&& headers, bool end_stream) PURE;

  /**
   * Called with a decoded trailers frame. This implicitly ends the stream.
   * @param trailers supplies the decoded trailers.
   */
  virtual void decodeTrailers(RequestTrailerMapPtr&& trailers) PURE;

  /**
   * Called if the codec needs to send a protocol error.
   * @param code supplies the HTTP error code to send.
   * @param body supplies an optional body to send with the local reply.
   * @param modify_headers supplies a way to edit headers before they are sent downstream.
   * @param grpc_status an optional gRPC status for gRPC requests
   * @param details details about the source of the error, for debug purposes
   */
  virtual void sendLocalReply(Code code, absl::string_view body,
                              const std::function<void(ResponseHeaderMap& headers)>& modify_headers,
                              const absl::optional<Grpc::Status::GrpcStatus> grpc_status,
                              absl::string_view details) PURE;

  /**
   * @return StreamInfo::StreamInfo& the stream_info for this stream.
   */
  virtual StreamInfo::StreamInfo& streamInfo() PURE;

  /**
   * @return List of shared pointers to access loggers for this stream.
   */
  virtual std::list<AccessLog::InstanceSharedPtr> accessLogHandlers() PURE;
};

/**
 * Stream decoder used for receiving a response (server to client). Virtual inheritance is required
 * due to a parallel implementation split between the shared base class and the derived class.
 */
class ResponseDecoder : public virtual StreamDecoder {
public:
  /**
   * Called with decoded 1xx headers.
   * Currently 100-Continue, 102-Processing, and 103-Early-Data headers are supported.
   * @param headers supplies the decoded 1xx headers map.
   */
  virtual void decode1xxHeaders(ResponseHeaderMapPtr&& headers) PURE;

  /**
   * Called with decoded headers, optionally indicating end of stream.
   * @param headers supplies the decoded headers map.
   * @param end_stream supplies whether this is a header only response.
   */
  virtual void decodeHeaders(ResponseHeaderMapPtr&& headers, bool end_stream) PURE;

  /**
   * Called with a decoded trailers frame. This implicitly ends the stream.
   * @param trailers supplies the decoded trailers.
   */
  virtual void decodeTrailers(ResponseTrailerMapPtr&& trailers) PURE;

  /**
   * Dump the response decoder to the specified ostream.
   *
   * @param os the ostream to dump state to
   * @param indent_level the depth, for pretty-printing.
   *
   * This function is called on Envoy fatal errors so should avoid memory allocation.
   */
  virtual void dumpState(std::ostream& os, int indent_level = 0) const PURE;
};

/**
 * Callbacks that fire against a stream.
 */
class StreamCallbacks {
public:
  virtual ~StreamCallbacks() = default;

  /**
   * Fires when a stream has been remote reset.
   * @param reason supplies the reset reason.
   * @param transport_failure_reason supplies underlying transport failure reason.
   */
  virtual void onResetStream(StreamResetReason reason,
                             absl::string_view transport_failure_reason) PURE;

  /**
   * Fires when a stream, or the connection the stream is sending to, goes over its high watermark.
   */
  virtual void onAboveWriteBufferHighWatermark() PURE;

  /**
   * Fires when a stream, or the connection the stream is sending to, goes from over its high
   * watermark to under its low watermark.
   */
  virtual void onBelowWriteBufferLowWatermark() PURE;
};

/**
 * Codec event callbacks for a given HTTP Stream.
 * This can be used to tightly couple an entity with a streams low-level events.
 */
class CodecEventCallbacks {
public:
  virtual ~CodecEventCallbacks() = default;
  /**
   * Called when the the underlying codec finishes encoding.
   */
  virtual void onCodecEncodeComplete() PURE;

  /**
   * Called when the underlying codec has a low level reset.
   * e.g. Envoy serialized the response but it has not been flushed.
   */
  virtual void onCodecLowLevelReset() PURE;
};

/**
 * An HTTP stream (request, response, and push).
 */
class Stream : public StreamResetHandler {
public:
  /**
   * Add stream callbacks.
   * @param callbacks supplies the callbacks to fire on stream events.
   */
  virtual void addCallbacks(StreamCallbacks& callbacks) PURE;

  /**
   * Remove stream callbacks.
   * @param callbacks supplies the callbacks to remove.
   */
  virtual void removeCallbacks(StreamCallbacks& callbacks) PURE;

  /**
   * Register the codec event callbacks for this stream.
   * The stream can only have a single registered callback at a time.
   * @param codec_callbacks the codec callbacks for this stream.
   * @return CodecEventCallbacks* the prior registered codec callbacks.
   */
  virtual CodecEventCallbacks*
  registerCodecEventCallbacks(CodecEventCallbacks* codec_callbacks) PURE;

  /**
   * Enable/disable further data from this stream.
   * Cessation of data may not be immediate. For example, for HTTP/2 this may stop further flow
   * control window updates which will result in the peer eventually stopping sending data.
   * @param disable informs if reads should be disabled (true) or re-enabled (false).
   *
   * Note that this function reference counts calls. For example
   * readDisable(true);  // Disables data
   * readDisable(true);  // Notes the stream is blocked by two sources
   * readDisable(false);  // Notes the stream is blocked by one source
   * readDisable(false);  // Marks the stream as unblocked, so resumes reading.
   */
  virtual void readDisable(bool disable) PURE;

  /**
   * Return the number of bytes this stream is allowed to buffer, or 0 if there is no limit
   * configured.
   * @return uint32_t the stream's configured buffer limits.
   */
  virtual uint32_t bufferLimit() const PURE;

  /**
   * @return string_view optionally return the reason behind codec level errors.
   *
   * This information is communicated via direct accessor rather than passed with the
   * CodecProtocolException so that the error can be associated only with the problematic stream and
   * not associated with every stream on the connection.
   */
  virtual absl::string_view responseDetails() { return ""; }

  /**
   * @return const Network::ConnectionInfoProvider& the adderess provider  of the connection
   * associated with the stream.
   */
  virtual const Network::ConnectionInfoProvider& connectionInfoProvider() PURE;

  /**
   * Set the flush timeout for the stream. At the codec level this is used to bound the amount of
   * time the codec will wait to flush body data pending open stream window. It does *not* count
   * small window updates as satisfying the idle timeout as this is a potential DoS vector.
   */
  virtual void setFlushTimeout(std::chrono::milliseconds timeout) PURE;

  /**
   * @return the account, if any, used by this stream.
   */
  virtual Buffer::BufferMemoryAccountSharedPtr account() const PURE;

  /**
   * Sets the account for this stream, propagating it to all of its buffers.
   * @param the account to assign this stream.
   */
  virtual void setAccount(Buffer::BufferMemoryAccountSharedPtr account) PURE;

  /**
   * Get the bytes meter for this stream.
   */
  virtual const StreamInfo::BytesMeterSharedPtr& bytesMeter() PURE;
};

/**
 * A class for sharing what HTTP/2 SETTINGS were received from the peer.
 */
class ReceivedSettings {
public:
  virtual ~ReceivedSettings() = default;

  /**
   * @return value of SETTINGS_MAX_CONCURRENT_STREAMS, or absl::nullopt if it was not present.
   */
  virtual const absl::optional<uint32_t>& maxConcurrentStreams() const PURE;
};

/**
 * Connection level callbacks.
 */
class ConnectionCallbacks {
public:
  virtual ~ConnectionCallbacks() = default;

  /**
   * Fires when the remote indicates "go away." No new streams should be created.
   */
  virtual void onGoAway(GoAwayErrorCode error_code) PURE;

  /**
   * Fires when the peer settings frame is received from the peer.
   * This may occur multiple times across the lifetime of the connection.
   * @param ReceivedSettings the settings received from the peer.
   */
  virtual void onSettings(ReceivedSettings& settings) { UNREFERENCED_PARAMETER(settings); }

  /**
   * Fires when the MAX_STREAMS frame is received from the peer.
   * This is an HTTP/3 frame, indicating the new maximum stream ID which can be opened.
   * This may occur multiple times across the lifetime of an HTTP/3 connection.
   * @param num_streams the number of streams now allowed to be opened.
   */
  virtual void onMaxStreamsChanged(uint32_t num_streams) { UNREFERENCED_PARAMETER(num_streams); }
};

/**
 * HTTP/1.* Codec settings
 */
struct Http1Settings {
  // Enable codec to parse absolute URIs. This enables forward/explicit proxy support for non TLS
  // traffic
  bool allow_absolute_url_{false};
  // Allow HTTP/1.0 from downstream.
  bool accept_http_10_{false};
  // Set a default host if no Host: header is present for HTTP/1.0 requests.`
  std::string default_host_for_http_10_;
  // Encode trailers in Http. By default the HTTP/1 codec drops proxied trailers.
  // Note that this only happens when Envoy is chunk encoding which occurs when:
  //  - The request is HTTP/1.1
  //  - Is neither a HEAD only request nor a HTTP Upgrade
  //  - Not a HEAD request
  bool enable_trailers_{false};
  // Allows Envoy to process requests/responses with both `Content-Length` and `Transfer-Encoding`
  // headers set. By default such messages are rejected, but if option is enabled - Envoy will
  // remove Content-Length header and process message.
  bool allow_chunked_length_{false};

  enum class HeaderKeyFormat {
    // By default no formatting is performed, presenting all headers in lowercase (as Envoy
    // internals normalize everything to lowercase.)
    Default,
    // Performs proper casing of header keys: the first and all alpha characters following a
    // non-alphanumeric character is capitalized.
    ProperCase,
    // A stateful formatter extension has been configured.
    StatefulFormatter,
  };

  // How header keys should be formatted when serializing HTTP/1.1 headers.
  HeaderKeyFormat header_key_format_{HeaderKeyFormat::Default};

  // Non-null IFF header_key_format_ is configured to StatefulFormatter.
  StatefulHeaderKeyFormatterFactorySharedPtr stateful_header_key_formatter_;

  // Behaviour on invalid HTTP messaging:
  // - if true, the HTTP/1.1 connection is left open (where possible)
  // - if false, the HTTP/1.1 connection is terminated
  bool stream_error_on_invalid_http_message_{false};

  // True if this is an edge Envoy (using downstream address, no trusted hops)
  // and https:// URLs should be rejected over unencrypted connections.
  bool validate_scheme_{false};

  // If true, Envoy will send a fully qualified URL in the firstline of the request.
  bool send_fully_qualified_url_{false};

  // If true, BalsaParser is used for HTTP/1 parsing; if false, http-parser is
  // used. See issue #21245.
  bool use_balsa_parser_{false};

  // If true, any non-empty method composed of valid characters is accepted.
  // If false, only methods from a hard-coded list of known methods are accepted.
  // Only implemented in BalsaParser. http-parser only accepts known methods.
  bool allow_custom_methods_{false};
};

/**
 * A connection (client or server) that owns multiple streams.
 */
class Connection {
public:
  virtual ~Connection() = default;

  /**
   * Dispatch incoming connection data.
   * @param data supplies the data to dispatch. The codec will drain as many bytes as it processes.
   * @return Status indicating the status of the codec. Holds any errors encountered while
   * processing the incoming data.
   */
  virtual Status dispatch(Buffer::Instance& data) PURE;

  /**
   * Indicate "go away" to the remote. No new streams can be created beyond this point.
   */
  virtual void goAway() PURE;

  /**
   * @return the protocol backing the connection. This can change if for example an HTTP/1.1
   *         connection gets an HTTP/1.0 request on it.
   */
  virtual Protocol protocol() PURE;

  /**
   * Indicate a "shutdown notice" to the remote. This is a hint that the remote should not send
   * any new streams, but if streams do arrive that will not be reset.
   */
  virtual void shutdownNotice() PURE;

  /**
   * @return bool whether the codec has data that it wants to write but cannot due to protocol
   *              reasons (e.g, needing window updates).
   */
  virtual bool wantsToWrite() PURE;

  /**
   * Called when the underlying Network::Connection goes over its high watermark.
   */
  virtual void onUnderlyingConnectionAboveWriteBufferHighWatermark() PURE;

  /**
   * Called when the underlying Network::Connection goes from over its high watermark to under its
   * low watermark.
   */
  virtual void onUnderlyingConnectionBelowWriteBufferLowWatermark() PURE;
};

/**
 * Callbacks for downstream connection watermark limits.
 */
class DownstreamWatermarkCallbacks {
public:
  virtual ~DownstreamWatermarkCallbacks() = default;

  /**
   * Called when the downstream connection or stream goes over its high watermark. Note that this
   * may be called separately for both the stream going over and the connection going over. It
   * is the responsibility of the DownstreamWatermarkCallbacks implementation to handle unwinding
   * multiple high and low watermark calls.
   */
  virtual void onAboveWriteBufferHighWatermark() PURE;

  /**
   * Called when the downstream connection or stream goes from over its high watermark to under its
   * low watermark. As with onAboveWriteBufferHighWatermark above, this may be called independently
   * when both the stream and the connection go under the low watermark limit, and the callee must
   * ensure that the flow of data does not resume until all callers which were above their high
   * watermarks have gone below.
   */
  virtual void onBelowWriteBufferLowWatermark() PURE;
};

/**
 * Callbacks for server connections.
 */
class ServerConnectionCallbacks : public virtual ConnectionCallbacks {
public:
  /**
   * Invoked when a new request stream is initiated by the remote.
   * @param response_encoder supplies the encoder to use for creating the response. The request and
   *                         response are backed by the same Stream object.
   * @param is_internally_created indicates if this stream was originated by a
   *   client, or was created by Envoy, by example as part of an internal redirect.
   * @return RequestDecoder& supplies the decoder callbacks to fire into for stream decoding
   *   events.
   */
  virtual RequestDecoder& newStream(ResponseEncoder& response_encoder,
                                    bool is_internally_created = false) PURE;
};

/**
 * A server side HTTP connection.
 */
class ServerConnection : public virtual Connection {};
using ServerConnectionPtr = std::unique_ptr<ServerConnection>;

/**
 * A client side HTTP connection.
 */
class ClientConnection : public virtual Connection {
public:
  /**
   * Create a new outgoing request stream.
   * @param response_decoder supplies the decoder callbacks to fire response events into.
   * @return RequestEncoder& supplies the encoder to write the request into.
   */
  virtual RequestEncoder& newStream(ResponseDecoder& response_decoder) PURE;
};

using ClientConnectionPtr = std::unique_ptr<ClientConnection>;

} // namespace Http
} // namespace Envoy
#pragma once

#include "envoy/config/typed_config.h"
#include "envoy/http/header_validator.h"
#include "envoy/server/factory_context.h"

namespace Envoy {
namespace Http {

/**
 * Extension configuration for header validators.
 */
class HeaderValidatorFactoryConfig : public Config::TypedFactory {
public:
  virtual HeaderValidatorFactoryPtr
  createFromProto(const Protobuf::Message& config,
                  Server::Configuration::ServerFactoryContext& server_context) PURE;

  std::string category() const override { return "envoy.http.header_validators"; }
};

} // namespace Http
} // namespace Envoy
#pragma once

#include <algorithm>
#include <cstdint>
#include <cstring>
#include <iostream>
#include <memory>
#include <string>
#include <type_traits>
#include <vector>

#include "envoy/common/optref.h"
#include "envoy/common/pure.h"
#include "envoy/common/union_string.h"
#include "envoy/http/header_formatter.h"

#include "source/common/common/assert.h"
#include "source/common/common/hash.h"
#include "source/common/common/macros.h"

#include "absl/container/inlined_vector.h"
#include "absl/strings/string_view.h"

namespace Envoy {
namespace Http {

// Used by ASSERTs to validate internal consistency. E.g. valid HTTP header keys/values should
// never contain embedded NULLs.
static inline bool validHeaderString(absl::string_view s) {
  // If you modify this list of illegal embedded characters you will probably
  // want to change header_map_fuzz_impl_test at the same time.
  for (const char c : s) {
    switch (c) {
    case '\0':
      FALLTHRU;
    case '\r':
      FALLTHRU;
    case '\n':
      return false;
    default:
      continue;
    }
  }
  return true;
}

/**
 * Wrapper for a lower case string used in header operations to generally avoid needless case
 * insensitive compares.
 */
class LowerCaseString {
public:
  LowerCaseString(LowerCaseString&& rhs) noexcept : string_(std::move(rhs.string_)) {
    ASSERT(valid());
  }
  LowerCaseString& operator=(LowerCaseString&& rhs) noexcept {
    string_ = std::move(rhs.string_);
    ASSERT(valid());
    return *this;
  }

  LowerCaseString(const LowerCaseString& rhs) : string_(rhs.string_) { ASSERT(valid()); }
  LowerCaseString& operator=(const LowerCaseString& rhs) {
    string_ = std::move(rhs.string_);
    ASSERT(valid());
    return *this;
  }

  explicit LowerCaseString(absl::string_view new_string) : string_(new_string) {
    ASSERT(valid());
    lower();
  }

  const std::string& get() const { return string_; }
  bool operator==(const LowerCaseString& rhs) const { return string_ == rhs.string_; }
  bool operator!=(const LowerCaseString& rhs) const { return string_ != rhs.string_; }
  bool operator<(const LowerCaseString& rhs) const { return string_.compare(rhs.string_) < 0; }

  friend std::ostream& operator<<(std::ostream& os, const LowerCaseString& lower_case_string) {
    return os << lower_case_string.string_;
  }

  // Implicit conversion to absl::string_view.
  operator absl::string_view() const { return string_; }

private:
  void lower() {
    std::transform(string_.begin(), string_.end(), string_.begin(), absl::ascii_tolower);
  }
  bool valid() const { return validHeaderString(string_); }

  std::string string_;
};

/**
 * Convenient type for a vector of lower case string and string pair.
 */
using LowerCaseStrPairVector =
    std::vector<std::pair<const Http::LowerCaseString, const std::string>>;

class HeaderStringValidator {
public:
  bool operator()(absl::string_view view) {
    return disable_validation_for_tests_ ? true : validHeaderString(view);
  }

  // This flag allows disabling the check for the NUL, CR and LF characters in the
  // header names or values in the DEBUG builds to prevent the `ASSERT(valid())` in the
  // HeaderString constructor from failing tests.
  static bool disable_validation_for_tests_;
};

class HeaderString : public UnionStringBase<HeaderStringValidator> {
public:
  using UnionStringBase::UnionStringBase;

  /**
   * Constructor for a lower case string reference.
   * @param ref_value MUST point to data that will live beyond the lifetime of any request/response
   *        using the string (since a codec may optimize for zero copy).
   */
  explicit HeaderString(const LowerCaseString& ref_value) noexcept;

  /**
   * Constructor for normal UnionString instance.
   * @param move_value moveable UnionString. The string value MUST be valid header string.
   */
  explicit HeaderString(UnionString&& move_value) noexcept;
};

/**
 * Encapsulates an individual header entry (including both key and value).
 */
class HeaderEntry {
public:
  virtual ~HeaderEntry() = default;

  /**
   * @return the header key.
   */
  virtual const HeaderString& key() const PURE;

  /**
   * Set the header value by copying data into it.
   */
  virtual void value(absl::string_view value) PURE;

  /**
   * Set the header value by copying an integer into it.
   */
  virtual void value(uint64_t value) PURE;

  /**
   * Set the header value by copying the value in another header entry.
   */
  virtual void value(const HeaderEntry& header) PURE;

  /**
   * @return the header value.
   */
  virtual const HeaderString& value() const PURE;

  /**
   * @return the header value.
   */
  virtual HeaderString& value() PURE;

private:
  void value(const char*); // Do not allow auto conversion to std::string
};

/**
 * The following defines all default request headers that Envoy allows direct access to inside of
 * the header map. In practice, these are all headers used during normal Envoy request flow
 * processing. This allows O(1) access to these headers without even a hash lookup.
 *
 */
#define INLINE_REQ_STRING_HEADERS(HEADER_FUNC)                                                     \
  HEADER_FUNC(ClientTraceId)                                                                       \
  HEADER_FUNC(EnvoyDownstreamServiceCluster)                                                       \
  HEADER_FUNC(EnvoyDownstreamServiceNode)                                                          \
  HEADER_FUNC(EnvoyExternalAddress)                                                                \
  HEADER_FUNC(EnvoyForceTrace)                                                                     \
  HEADER_FUNC(EnvoyHedgeOnPerTryTimeout)                                                           \
  HEADER_FUNC(EnvoyInternalRequest)                                                                \
  HEADER_FUNC(EnvoyIpTags)                                                                         \
  HEADER_FUNC(EnvoyRetryOn)                                                                        \
  HEADER_FUNC(EnvoyRetryGrpcOn)                                                                    \
  HEADER_FUNC(EnvoyRetriableStatusCodes)                                                           \
  HEADER_FUNC(EnvoyRetriableHeaderNames)                                                           \
  HEADER_FUNC(EnvoyIsTimeoutRetry)                                                                 \
  HEADER_FUNC(EnvoyOriginalPath)                                                                   \
  HEADER_FUNC(EnvoyOriginalUrl)                                                                    \
  HEADER_FUNC(EnvoyUpstreamAltStatName)                                                            \
  HEADER_FUNC(EnvoyUpstreamRequestTimeoutAltResponse)                                              \
  HEADER_FUNC(Expect)                                                                              \
  HEADER_FUNC(ForwardedClientCert)                                                                 \
  HEADER_FUNC(ForwardedFor)                                                                        \
  HEADER_FUNC(ForwardedHost)                                                                       \
  HEADER_FUNC(ForwardedProto)                                                                      \
  HEADER_FUNC(GrpcTimeout)                                                                         \
  HEADER_FUNC(Host)                                                                                \
  HEADER_FUNC(Method)                                                                              \
  HEADER_FUNC(Path)                                                                                \
  HEADER_FUNC(Protocol)                                                                            \
  HEADER_FUNC(Scheme)                                                                              \
  HEADER_FUNC(TE)                                                                                  \
  HEADER_FUNC(UserAgent)

#define INLINE_REQ_NUMERIC_HEADERS(HEADER_FUNC)                                                    \
  HEADER_FUNC(EnvoyExpectedRequestTimeoutMs)                                                       \
  HEADER_FUNC(EnvoyMaxRetries)                                                                     \
  HEADER_FUNC(EnvoyUpstreamRequestTimeoutMs)                                                       \
  HEADER_FUNC(EnvoyUpstreamRequestPerTryTimeoutMs)                                                 \
  HEADER_FUNC(EnvoyUpstreamStreamDurationMs)                                                       \
  HEADER_FUNC(ForwardedPort)

#define INLINE_REQ_HEADERS(HEADER_FUNC)                                                            \
  INLINE_REQ_STRING_HEADERS(HEADER_FUNC)                                                           \
  INLINE_REQ_NUMERIC_HEADERS(HEADER_FUNC)

/**
 * Default O(1) response headers.
 */
#define INLINE_RESP_STRING_HEADERS(HEADER_FUNC)                                                    \
  HEADER_FUNC(Date)                                                                                \
  HEADER_FUNC(EnvoyDegraded)                                                                       \
  HEADER_FUNC(EnvoyImmediateHealthCheckFail)                                                       \
  HEADER_FUNC(EnvoyRateLimited)                                                                    \
  HEADER_FUNC(EnvoyUpstreamCanary)                                                                 \
  HEADER_FUNC(EnvoyUpstreamHealthCheckedCluster)                                                   \
  HEADER_FUNC(Location)                                                                            \
  HEADER_FUNC(Server)

#define INLINE_RESP_NUMERIC_HEADERS(HEADER_FUNC)                                                   \
  HEADER_FUNC(EnvoyUpstreamServiceTime)                                                            \
  HEADER_FUNC(Status)

#define INLINE_RESP_HEADERS(HEADER_FUNC)                                                           \
  INLINE_RESP_STRING_HEADERS(HEADER_FUNC)                                                          \
  INLINE_RESP_NUMERIC_HEADERS(HEADER_FUNC)

/**
 * Default O(1) request and response headers.
 */
#define INLINE_REQ_RESP_STRING_HEADERS(HEADER_FUNC)                                                \
  HEADER_FUNC(Connection)                                                                          \
  HEADER_FUNC(ContentType)                                                                         \
  HEADER_FUNC(EnvoyDecoratorOperation)                                                             \
  HEADER_FUNC(KeepAlive)                                                                           \
  HEADER_FUNC(ProxyConnection)                                                                     \
  HEADER_FUNC(ProxyStatus)                                                                         \
  HEADER_FUNC(RequestId)                                                                           \
  HEADER_FUNC(TransferEncoding)                                                                    \
  HEADER_FUNC(Upgrade)                                                                             \
  HEADER_FUNC(Via)

#define INLINE_REQ_RESP_NUMERIC_HEADERS(HEADER_FUNC)                                               \
  HEADER_FUNC(ContentLength)                                                                       \
  HEADER_FUNC(EnvoyAttemptCount)

#define INLINE_REQ_RESP_HEADERS(HEADER_FUNC)                                                       \
  INLINE_REQ_RESP_STRING_HEADERS(HEADER_FUNC)                                                      \
  INLINE_REQ_RESP_NUMERIC_HEADERS(HEADER_FUNC)

/**
 * Default O(1) response headers and trailers.
 */
#define INLINE_RESP_STRING_HEADERS_TRAILERS(HEADER_FUNC) HEADER_FUNC(GrpcMessage)

#define INLINE_RESP_NUMERIC_HEADERS_TRAILERS(HEADER_FUNC) HEADER_FUNC(GrpcStatus)

#define INLINE_RESP_HEADERS_TRAILERS(HEADER_FUNC)                                                  \
  INLINE_RESP_STRING_HEADERS_TRAILERS(HEADER_FUNC)                                                 \
  INLINE_RESP_NUMERIC_HEADERS_TRAILERS(HEADER_FUNC)

/**
 * The following functions are defined for each inline header above.

 * E.g., for path we have:
 * Path() -> returns the header entry if it exists or nullptr.
 * removePath() -> removes the header if it exists.
 * setPath(path_string) -> sets the header value to the string path_string by copying the data.
 *
 */
#define DEFINE_INLINE_HEADER(name)                                                                 \
  virtual const HeaderEntry* name() const PURE;                                                    \
  virtual size_t remove##name() PURE;                                                              \
  virtual absl::string_view get##name##Value() const PURE;                                         \
  virtual void set##name(absl::string_view value) PURE;

/*
 * For inline headers that have string values, there are also:
 * appendPath(path, "/") -> appends the string path with delimiter "/" to the header value.
 * setReferencePath(PATH) -> sets header value to reference string PATH.
 *
 */
#define DEFINE_INLINE_STRING_HEADER(name)                                                          \
  DEFINE_INLINE_HEADER(name)                                                                       \
  virtual void append##name(absl::string_view data, absl::string_view delimiter) PURE;             \
  virtual void setReference##name(absl::string_view value) PURE;

/*
 * For inline headers that use integers, there is:
 * setContentLength(5) -> sets the header value to the integer 5.
 */
#define DEFINE_INLINE_NUMERIC_HEADER(name)                                                         \
  DEFINE_INLINE_HEADER(name)                                                                       \
  virtual void set##name(uint64_t) PURE;

/**
 * Wraps a set of HTTP headers.
 */
class HeaderMap {
public:
  virtual ~HeaderMap() = default;

  /**
   * For testing. This is an exact match comparison (order matters).
   */
  virtual bool operator==(const HeaderMap& rhs) const PURE;
  virtual bool operator!=(const HeaderMap& rhs) const PURE;

  /**
   * Add a header via full move. This is the expected high performance paths for codecs populating
   * a map when receiving.
   * @param key supplies the header key.
   * @param value supplies the header value.
   */
  virtual void addViaMove(HeaderString&& key, HeaderString&& value) PURE;

  /**
   * Add a reference header to the map. Both key and value MUST point to data that will live beyond
   * the lifetime of any request/response using the string (since a codec may optimize for zero
   * copy). The key will not be copied and a best effort will be made not to
   * copy the value (but this may happen when comma concatenating, see below).
   *
   * Calling addReference multiple times for the same header will result in:
   * - Comma concatenation for predefined inline headers.
   * - Multiple headers being present in the HeaderMap for other headers.
   *
   * @param key specifies the name of the header to add; it WILL NOT be copied.
   * @param value specifies the value of the header to add; it WILL NOT be copied.
   */
  virtual void addReference(const LowerCaseString& key, absl::string_view value) PURE;

  /**
   * Add a header with a reference key to the map. The key MUST point to data that will live beyond
   * the lifetime of any request/response using the string (since a codec may optimize for zero
   * copy). The value will be copied.
   *
   * Calling addReference multiple times for the same header will result in:
   * - Comma concatenation for predefined inline headers.
   * - Multiple headers being present in the HeaderMap for other headers.
   *
   * @param key specifies the name of the header to add; it WILL NOT be copied.
   * @param value specifies the value of the header to add; it WILL be copied.
   */
  virtual void addReferenceKey(const LowerCaseString& key, uint64_t value) PURE;

  /**
   * Add a header with a reference key to the map. The key MUST point to data that will
   * live beyond the lifetime of any request/response using the string (since a codec may optimize
   * for zero copy). The value will be copied.
   *
   * Calling addReference multiple times for the same header will result in:
   * - Comma concatenation for predefined inline headers.
   * - Multiple headers being present in the HeaderMap for other headers.
   *
   * @param key specifies the name of the header to add; it WILL NOT be copied.
   * @param value specifies the value of the header to add; it WILL be copied.
   */
  virtual void addReferenceKey(const LowerCaseString& key, absl::string_view value) PURE;

  /**
   * Add a header by copying both the header key and the value.
   *
   * Calling addCopy multiple times for the same header will result in:
   * - Comma concatenation for predefined inline headers.
   * - Multiple headers being present in the HeaderMap for other headers.
   *
   * @param key specifies the name of the header to add; it WILL be copied.
   * @param value specifies the value of the header to add; it WILL be copied.
   */
  virtual void addCopy(const LowerCaseString& key, uint64_t value) PURE;

  /**
   * Add a header by copying both the header key and the value.
   *
   * Calling addCopy multiple times for the same header will result in:
   * - Comma concatenation for predefined inline headers.
   * - Multiple headers being present in the HeaderMap for other headers.
   *
   * @param key specifies the name of the header to add; it WILL be copied.
   * @param value specifies the value of the header to add; it WILL be copied.
   */
  virtual void addCopy(const LowerCaseString& key, absl::string_view value) PURE;

  /**
   * Appends data to header. If header already has a value, the string "," is added between the
   * existing value and data.
   *
   * @param key specifies the name of the header to append; it WILL be copied.
   * @param value specifies the value of the header to add; it WILL be copied.
   *
   * Caution: This iterates over the HeaderMap to find the header to append. This will modify only
   * the first occurrence of the header.
   * TODO(asraa): Investigate whether necessary to append to all headers with the key.
   */
  virtual void appendCopy(const LowerCaseString& key, absl::string_view value) PURE;

  /**
   * Set a reference header in the map. Both key and value MUST point to data that will live beyond
   * the lifetime of any request/response using the string (since a codec may optimize for zero
   * copy). Nothing will be copied.
   *
   * Calling setReference multiple times for the same header will result in only the last header
   * being present in the HeaderMap.
   *
   * @param key specifies the name of the header to set; it WILL NOT be copied.
   * @param value specifies the value of the header to set; it WILL NOT be copied.
   */
  virtual void setReference(const LowerCaseString& key, absl::string_view value) PURE;

  /**
   * Set a header with a reference key in the map. The key MUST point to point to data that will
   * live beyond the lifetime of any request/response using the string (since a codec may optimize
   * for zero copy). The value will be copied.
   *
   * Calling setReferenceKey multiple times for the same header will result in only the last header
   * being present in the HeaderMap.
   *
   * @param key specifies the name of the header to set; it WILL NOT be copied.
   * @param value specifies the value of the header to set; it WILL be copied.
   */
  virtual void setReferenceKey(const LowerCaseString& key, absl::string_view value) PURE;

  /**
   * Replaces a header value by copying the value. Copies the key if the key does not exist.
   * If there are multiple values for one header, this removes all existing values and add
   * the new one.
   *
   * Calling setCopy multiple times for the same header will result in only the last header
   * being present in the HeaderMap.
   *
   * @param key specifies the name of the header to set; it WILL be copied.
   * @param value specifies the value of the header to set; it WILL be copied.
   * TODO(asraa): Investigate whether necessary to set all headers with the key.
   */
  virtual void setCopy(const LowerCaseString& key, absl::string_view value) PURE;

  /**
   * @return uint64_t the size of the header map in bytes. This is the sum of the header keys and
   * values and does not account for data structure overhead.
   */
  virtual uint64_t byteSize() const PURE;

  /**
   * @return uint32_t the max size of the header map in kilobyte.
   */
  virtual uint32_t maxHeadersKb() const PURE;

  /**
   * @return uint32_t the max count of headers in a header map.
   */
  virtual uint32_t maxHeadersCount() const PURE;

  /**
   * This is a wrapper for the return result from get(). It avoids a copy when translating from
   * non-const HeaderEntry to const HeaderEntry and only provides const access to the result.
   */
  using NonConstGetResult = absl::InlinedVector<HeaderEntry*, 1>;
  class GetResult {
  public:
    GetResult() = default;
    explicit GetResult(NonConstGetResult&& result) : result_(std::move(result)) {}
    void operator=(GetResult&& rhs) noexcept { result_ = std::move(rhs.result_); }

    bool empty() const { return result_.empty(); }
    size_t size() const { return result_.size(); }
    const HeaderEntry* operator[](size_t i) const { return result_[i]; }

  private:
    NonConstGetResult result_;
  };

  /**
   * Get a header by key.
   * @param key supplies the header key.
   * @return all header entries matching the key.
   */
  virtual GetResult get(const LowerCaseString& key) const PURE;

  // aliases to make iterate() and iterateReverse() callbacks easier to read
  enum class Iterate { Continue, Break };

  /**
   * Callback when calling iterate() over a const header map.
   * @param header supplies the header entry.
   * @return Iterate::Continue to continue iteration, or Iterate::Break to stop;
   */
  using ConstIterateCb = std::function<Iterate(const HeaderEntry&)>;

  /**
   * Iterate over a constant header map.
   * @param cb supplies the iteration callback.
   */
  virtual void iterate(ConstIterateCb cb) const PURE;

  /**
   * Iterate over a constant header map in reverse order.
   * @param cb supplies the iteration callback.
   */
  virtual void iterateReverse(ConstIterateCb cb) const PURE;

  /**
   * Clears the headers in the map.
   */
  virtual void clear() PURE;

  /**
   * Remove all instances of a header by key.
   * @param key supplies the header key to remove.
   * @return the number of headers removed.
   */
  virtual size_t remove(const LowerCaseString& key) PURE;

  /**
   * Remove all instances of headers where the header matches the predicate.
   * @param predicate supplies the predicate to match headers against.
   * @return the number of headers removed.
   */
  using HeaderMatchPredicate = std::function<bool(const HeaderEntry&)>;
  virtual size_t removeIf(const HeaderMatchPredicate& predicate) PURE;

  /**
   * Remove all instances of headers where the key begins with the supplied prefix.
   * @param prefix supplies the prefix to match header keys against.
   * @return the number of headers removed.
   */
  virtual size_t removePrefix(const LowerCaseString& prefix) PURE;

  /**
   * @return the number of headers in the map.
   */
  virtual size_t size() const PURE;

  /**
   * @return true if the map is empty, false otherwise.
   */
  virtual bool empty() const PURE;

  /**
   * Dump the header map to the ostream specified
   *
   * @param os the stream to dump state to
   * @param indent_level the depth, for pretty-printing.
   *
   * This function is called on Envoy fatal errors so should avoid memory allocation where possible.
   */
  virtual void dumpState(std::ostream& os, int indent_level = 0) const PURE;

  /**
   * Allow easy pretty-printing of the key/value pairs in HeaderMap
   * @param os supplies the ostream to print to.
   * @param headers the headers to print.
   */
  friend std::ostream& operator<<(std::ostream& os, const HeaderMap& headers) {
    headers.dumpState(os);
    return os;
  }

  /**
   * Return the optional stateful formatter attached to this header map.
   *
   * Filters can use the non-const version to process additional header keys during operation if
   * they wish. The sequence of events would be to first add/modify the header map, and then call
   * processKey(), similar to what is done when headers are received by the codec.
   *
   * TODO(mattklein123): The above sequence will not work for headers added via route (headers to
   * add, etc.). We can potentially add direct processKey() calls in these places as a follow up.
   */
  virtual StatefulHeaderKeyFormatterOptConstRef formatter() const PURE;
  virtual StatefulHeaderKeyFormatterOptRef formatter() PURE;
};

using HeaderMapPtr = std::unique_ptr<HeaderMap>;

/**
 * Wraps a set of header modifications.
 */
struct HeaderTransforms {
  std::vector<std::pair<Http::LowerCaseString, std::string>> headers_to_append_or_add;
  std::vector<std::pair<Http::LowerCaseString, std::string>> headers_to_overwrite_or_add;
  std::vector<std::pair<Http::LowerCaseString, std::string>> headers_to_add_if_absent;
  std::vector<Http::LowerCaseString> headers_to_remove;
};

/**
 * Registry for custom headers. Headers can be registered multiple times in independent
 * compilation units and will still point to the same slot. Headers are registered independently
 * for each concrete header map type and do not overlap. Handles are strongly typed and do not
 * allow mixing.
 */
class CustomInlineHeaderRegistry {
public:
  enum class Type { RequestHeaders, RequestTrailers, ResponseHeaders, ResponseTrailers };
  using RegistrationMap = std::map<LowerCaseString, size_t>;

  // A "phantom" type is used here to force the compiler to verify that handles are not mixed
  // between concrete header map types.
  template <Type type> struct Handle {
    Handle(RegistrationMap::const_iterator it) : it_(it) {}
    bool operator==(const Handle& rhs) const { return it_ == rhs.it_; }

    RegistrationMap::const_iterator it_;
  };

  /**
   * Register an inline header and return a handle for use in inline header calls. Must be called
   * prior to finalize().
   */
  template <Type type>
  static Handle<type> registerInlineHeader(const LowerCaseString& header_name) {
    static size_t inline_header_index = 0;

    ASSERT(!mutableFinalized<type>());
    auto& map = mutableRegistrationMap<type>();
    auto entry = map.find(header_name);
    if (entry == map.end()) {
      map[header_name] = inline_header_index++;
    }
    return Handle<type>(map.find(header_name));
  }

  /**
   * Fetch the handle for a registered inline header. May only be called after finalized().
   */
  template <Type type>
  static absl::optional<Handle<type>> getInlineHeader(const LowerCaseString& header_name) {
    ASSERT(mutableFinalized<type>());
    auto& map = mutableRegistrationMap<type>();
    auto entry = map.find(header_name);
    if (entry != map.end()) {
      return Handle<type>(entry);
    }
    return absl::nullopt;
  }

  /**
   * Fetch all registered headers. May only be called after finalized().
   */
  template <Type type> static const RegistrationMap& headers() {
    ASSERT(mutableFinalized<type>());
    return mutableRegistrationMap<type>();
  }

  /**
   * Finalize the custom header registrations. No further changes are allowed after this point.
   * This guaranteed that all header maps created by the process have the same variable size and
   * custom registrations.
   */
  template <Type type> static void finalize() {
    ASSERT(!mutableFinalized<type>());
    mutableFinalized<type>() = true;
  }

private:
  template <Type type> static RegistrationMap& mutableRegistrationMap() {
    MUTABLE_CONSTRUCT_ON_FIRST_USE(RegistrationMap);
  }
  template <Type type> static bool& mutableFinalized() { MUTABLE_CONSTRUCT_ON_FIRST_USE(bool); }
};

/**
 * Static initializer to register a custom header in a compilation unit. This can be used by
 * extensions to register custom headers.
 */
template <CustomInlineHeaderRegistry::Type type> class RegisterCustomInlineHeader {
public:
  RegisterCustomInlineHeader(const LowerCaseString& header)
      : handle_(CustomInlineHeaderRegistry::registerInlineHeader<type>(header)) {}

  typename CustomInlineHeaderRegistry::Handle<type> handle() { return handle_; }

private:
  const typename CustomInlineHeaderRegistry::Handle<type> handle_;
};

/**
 * The following functions allow O(1) access for custom inline headers.
 */
template <CustomInlineHeaderRegistry::Type type> class CustomInlineHeaderBase {
public:
  virtual ~CustomInlineHeaderBase() = default;

  static constexpr CustomInlineHeaderRegistry::Type header_map_type = type;
  using Handle = CustomInlineHeaderRegistry::Handle<header_map_type>;

  virtual const HeaderEntry* getInline(Handle handle) const PURE;
  virtual void appendInline(Handle handle, absl::string_view data,
                            absl::string_view delimiter) PURE;
  virtual void setReferenceInline(Handle, absl::string_view value) PURE;
  virtual void setInline(Handle, absl::string_view value) PURE;
  virtual void setInline(Handle, uint64_t value) PURE;
  virtual size_t removeInline(Handle handle) PURE;
  absl::string_view getInlineValue(Handle handle) const {
    const auto header = getInline(handle);
    if (header != nullptr) {
      return header->value().getStringView();
    }
    return {};
  }
};

/**
 * Typed derived classes for all header map types.
 */

// Base class for both request and response headers.
class RequestOrResponseHeaderMap : public HeaderMap {
public:
  INLINE_REQ_RESP_STRING_HEADERS(DEFINE_INLINE_STRING_HEADER)
  INLINE_REQ_RESP_NUMERIC_HEADERS(DEFINE_INLINE_NUMERIC_HEADER)
};

// Request headers.
class RequestHeaderMap
    : public RequestOrResponseHeaderMap,
      public CustomInlineHeaderBase<CustomInlineHeaderRegistry::Type::RequestHeaders> {
public:
  INLINE_REQ_STRING_HEADERS(DEFINE_INLINE_STRING_HEADER)
  INLINE_REQ_NUMERIC_HEADERS(DEFINE_INLINE_NUMERIC_HEADER)
};
using RequestHeaderMapPtr = std::unique_ptr<RequestHeaderMap>;
using RequestHeaderMapSharedPtr = std::shared_ptr<RequestHeaderMap>;
using RequestHeaderMapConstSharedPtr = std::shared_ptr<const RequestHeaderMap>;
using RequestHeaderMapOptRef = OptRef<RequestHeaderMap>;
using RequestHeaderMapOptConstRef = OptRef<const RequestHeaderMap>;

// Request trailers.
class RequestTrailerMap
    : public HeaderMap,
      public CustomInlineHeaderBase<CustomInlineHeaderRegistry::Type::RequestTrailers> {};
using RequestTrailerMapPtr = std::unique_ptr<RequestTrailerMap>;
using RequestTrailerMapOptRef = OptRef<RequestTrailerMap>;
using RequestTrailerMapOptConstRef = OptRef<const RequestTrailerMap>;

// Base class for both response headers and trailers.
class ResponseHeaderOrTrailerMap {
public:
  virtual ~ResponseHeaderOrTrailerMap() = default;

  INLINE_RESP_STRING_HEADERS_TRAILERS(DEFINE_INLINE_STRING_HEADER)
  INLINE_RESP_NUMERIC_HEADERS_TRAILERS(DEFINE_INLINE_NUMERIC_HEADER)
};

// Response headers.
class ResponseHeaderMap
    : public RequestOrResponseHeaderMap,
      public ResponseHeaderOrTrailerMap,
      public CustomInlineHeaderBase<CustomInlineHeaderRegistry::Type::ResponseHeaders> {
public:
  INLINE_RESP_STRING_HEADERS(DEFINE_INLINE_STRING_HEADER)
  INLINE_RESP_NUMERIC_HEADERS(DEFINE_INLINE_NUMERIC_HEADER)
};
using ResponseHeaderMapPtr = std::unique_ptr<ResponseHeaderMap>;
using ResponseHeaderMapSharedPtr = std::shared_ptr<ResponseHeaderMap>;
using ResponseHeaderMapConstSharedPtr = std::shared_ptr<const ResponseHeaderMap>;
using ResponseHeaderMapOptRef = OptRef<ResponseHeaderMap>;
using ResponseHeaderMapOptConstRef = OptRef<const ResponseHeaderMap>;

// Response trailers.
class ResponseTrailerMap
    : public ResponseHeaderOrTrailerMap,
      public HeaderMap,
      public CustomInlineHeaderBase<CustomInlineHeaderRegistry::Type::ResponseTrailers> {};
using ResponseTrailerMapPtr = std::unique_ptr<ResponseTrailerMap>;
using ResponseTrailerMapSharedPtr = std::shared_ptr<ResponseTrailerMap>;
using ResponseTrailerMapConstSharedPtr = std::shared_ptr<const ResponseTrailerMap>;
using ResponseTrailerMapOptRef = OptRef<ResponseTrailerMap>;
using ResponseTrailerMapOptConstRef = OptRef<const ResponseTrailerMap>;

/**
 * Convenient container type for storing Http::LowerCaseString and std::string key/value pairs.
 */
using HeaderVector = std::vector<std::pair<LowerCaseString, std::string>>;

/**
 * An interface to be implemented by header matchers.
 */
class HeaderMatcher {
public:
  virtual ~HeaderMatcher() = default;

  /**
   * Check whether header matcher matches any headers in a given HeaderMap.
   */
  virtual bool matchesHeaders(const HeaderMap& headers) const PURE;
};

using HeaderMatcherSharedPtr = std::shared_ptr<HeaderMatcher>;

} // namespace Http
} // namespace Envoy

// NOLINT(namespace-envoy)
namespace fmt {
// Allow fmtlib to use operator << defined in HeaderMap and LowerCaseString
template <> struct formatter<::Envoy::Http::LowerCaseString> : ostream_formatter {};

template <typename HeaderMapType>
struct formatter<
    HeaderMapType,
    std::enable_if_t<std::is_base_of<::Envoy::Http::HeaderMap, HeaderMapType>::value, char>>
    : ostream_formatter {};
} // namespace fmt
#pragma once

#include <chrono>
#include <memory>

#include "envoy/buffer/buffer.h"
#include "envoy/config/route/v3/route_components.pb.h"
#include "envoy/event/dispatcher.h"
#include "envoy/http/filter.h"
#include "envoy/http/header_map.h"
#include "envoy/http/message.h"
#include "envoy/stream_info/stream_info.h"
#include "envoy/tracing/tracer.h"

#include "source/common/protobuf/protobuf.h"

#include "absl/types/optional.h"

namespace Envoy {
namespace Router {
class FilterConfig;
}
namespace Http {

/**
 * Supports sending an HTTP request message and receiving a response asynchronously.
 */
class AsyncClient {
public:
  /**
   * An in-flight HTTP request.
   */
  class Request {
  public:
    virtual ~Request() = default;

    /**
     * Signals that the request should be cancelled.
     */
    virtual void cancel() PURE;
  };

  /**
   * Async Client failure reasons.
   */
  enum class FailureReason {
    // The stream has been reset.
    Reset
  };

  /**
   * Notifies caller of async HTTP request status.
   *
   * To support a use case where a caller makes multiple requests in parallel,
   * individual callback methods provide request context corresponding to that response.
   */
  class Callbacks {
  public:
    virtual ~Callbacks() = default;

    /**
     * Called when the async HTTP request succeeds.
     * @param request  request handle.
     *                 NOTE: request handle is passed for correlation purposes only, e.g.
     *                 for client code to be able to exclude that handle from a list of
     *                 requests in progress.
     * @param response the HTTP response
     */
    virtual void onSuccess(const Request& request, ResponseMessagePtr&& response) PURE;

    /**
     * Called when the async HTTP request fails.
     * @param request request handle.
     *                NOTE: request handle is passed for correlation purposes only, e.g.
     *                for client code to be able to exclude that handle from a list of
     *                requests in progress.
     * @param reason  failure reason
     */
    virtual void onFailure(const Request& request, FailureReason reason) PURE;

    /**
     * Called before finalizing upstream span when the request is complete or reset.
     * @param span a tracing span to fill with extra tags.
     * @param response_headers the response headers.
     */
    virtual void onBeforeFinalizeUpstreamSpan(Envoy::Tracing::Span& span,
                                              const Http::ResponseHeaderMap* response_headers) PURE;
  };

  /**
   * Notifies caller of async HTTP stream status.
   * Note the HTTP stream is full-duplex, even if the local to remote stream has been ended
   * by Stream.sendHeaders/sendData with end_stream=true or sendTrailers,
   * StreamCallbacks can continue to receive events until the remote to local stream is closed,
   * and vice versa.
   */
  class StreamCallbacks {
  public:
    virtual ~StreamCallbacks() = default;

    /**
     * Called when all headers get received on the async HTTP stream.
     * @param headers the headers received
     * @param end_stream whether the response is header only
     */
    virtual void onHeaders(ResponseHeaderMapPtr&& headers, bool end_stream) PURE;

    /**
     * Called when a data frame get received on the async HTTP stream.
     * This can be invoked multiple times if the data get streamed.
     * @param data the data received
     * @param end_stream whether the data is the last data frame
     */
    virtual void onData(Buffer::Instance& data, bool end_stream) PURE;

    /**
     * Called when all trailers get received on the async HTTP stream.
     * @param trailers the trailers received.
     */
    virtual void onTrailers(ResponseTrailerMapPtr&& trailers) PURE;

    /**
     * Called when both the local and remote have gracefully closed the stream.
     * Useful for asymmetric cases where end_stream may not be bidirectionally observable.
     * Note this is NOT called on stream reset.
     */
    virtual void onComplete() PURE;

    /**
     * Called when the async HTTP stream is reset.
     */
    virtual void onReset() PURE;
  };

  using StreamDestructorCallbacks = std::function<void()>;

  /**
   * An in-flight HTTP stream.
   */
  class Stream {
  public:
    virtual ~Stream() = default;

    /***
     * Send headers to the stream. This method cannot be invoked more than once and
     * need to be called before sendData.
     * @param headers supplies the headers to send.
     * @param end_stream supplies whether this is a header only request.
     */
    virtual void sendHeaders(RequestHeaderMap& headers, bool end_stream) PURE;

    /***
     * Send data to the stream. This method can be invoked multiple times if it get streamed.
     * To end the stream without data, call this method with empty buffer.
     * @param data supplies the data to send.
     * @param end_stream supplies whether this is the last data.
     */
    virtual void sendData(Buffer::Instance& data, bool end_stream) PURE;

    /***
     * Send trailers. This method cannot be invoked more than once, and implicitly ends the stream.
     * @param trailers supplies the trailers to send.
     */
    virtual void sendTrailers(RequestTrailerMap& trailers) PURE;

    /***
     * Reset the stream.
     */
    virtual void reset() PURE;

    /***
     * Register callback to be called on stream destruction. This callback must persist beyond the
     * lifetime of the stream or be unregistered via removeDestructorCallback. If there's already a
     * destructor callback registered, this method will ASSERT-fail.
     */
    virtual void setDestructorCallback(StreamDestructorCallbacks callback) PURE;

    /***
     * Remove previously set destructor callback. Calling this without having previously set a
     * Destructor callback will ASSERT-fail.
     */
    virtual void removeDestructorCallback() PURE;

    /***
     * Register a callback to be called when high/low write buffer watermark events occur on the
     * stream. This callback must persist beyond the lifetime of the stream or be unregistered via
     * removeWatermarkCallbacks. If there's already a watermark callback registered, this method
     * will ASSERT-fail.
     */
    virtual void setWatermarkCallbacks(DecoderFilterWatermarkCallbacks& callbacks) PURE;

    /***
     * Remove previously set watermark callbacks.
     */
    virtual void removeWatermarkCallbacks() PURE;

    /***
     * @returns if the stream has enough buffered outbound data to be over the configured buffer
     * limits
     */
    virtual bool isAboveWriteBufferHighWatermark() const PURE;

    /***
     * @returns the stream info object associated with the stream.
     */
    virtual const StreamInfo::StreamInfo& streamInfo() const PURE;
  };

  /***
   * An in-flight HTTP request to which additional data and trailers can be sent, as well as resets
   * and other stream-cancelling events. Must be terminated by sending trailers or data with
   * end_stream.
   */
  class OngoingRequest : public virtual Request, public virtual Stream {
  public:
    /***
     * Takes ownership of trailers, and sends it to the underlying stream.
     * @param trailers owned trailers to pass to upstream.
     */
    virtual void captureAndSendTrailers(RequestTrailerMapPtr&& trailers) PURE;
  };

  virtual ~AsyncClient() = default;

  /**
   * A context from the caller of an async client.
   */
  struct ParentContext {
    const StreamInfo::StreamInfo* stream_info{nullptr};
  };

  /**
   * A structure to hold the options for AsyncStream object.
   */
  struct StreamOptions {
    StreamOptions& setTimeout(const absl::optional<std::chrono::milliseconds>& v) {
      timeout = v;
      return *this;
    }
    StreamOptions& setTimeout(const std::chrono::milliseconds& v) {
      timeout = v;
      return *this;
    }
    StreamOptions& setBufferBodyForRetry(bool v) {
      buffer_body_for_retry = v;
      return *this;
    }
    StreamOptions& setSendXff(bool v) {
      send_xff = v;
      return *this;
    }
    StreamOptions& setHashPolicy(
        const Protobuf::RepeatedPtrField<envoy::config::route::v3::RouteAction::HashPolicy>& v) {
      hash_policy = v;
      return *this;
    }
    StreamOptions& setParentContext(const ParentContext& v) {
      parent_context = v;
      return *this;
    }
    // Set dynamic metadata of async stream. If a metadata record with filter name 'envoy.lb' is
    // provided, metadata match criteria of async stream route will be overridden by the metadata
    // and then used by the subset load balancer.
    StreamOptions& setMetadata(const envoy::config::core::v3::Metadata& m) {
      metadata = m;
      return *this;
    }

    // Set buffer restriction and accounting for the stream.
    StreamOptions& setBufferAccount(const Buffer::BufferMemoryAccountSharedPtr& account) {
      account_ = account;
      return *this;
    }
    StreamOptions& setBufferLimit(uint32_t limit) {
      buffer_limit_ = limit;
      return *this;
    }

    // this should be done with setBufferedBodyForRetry=true ?
    StreamOptions& setRetryPolicy(const envoy::config::route::v3::RetryPolicy& p) {
      retry_policy = p;
      return *this;
    }
    StreamOptions& setFilterConfig(Router::FilterConfig& config) {
      filter_config_ = config;
      return *this;
    }

    StreamOptions& setIsShadow(bool s) {
      is_shadow = s;
      return *this;
    }

    // For gmock test
    bool operator==(const StreamOptions& src) const {
      return timeout == src.timeout && buffer_body_for_retry == src.buffer_body_for_retry &&
             send_xff == src.send_xff;
    }

    // The timeout supplies the stream timeout, measured since when the frame with
    // end_stream flag is sent until when the first frame is received.
    absl::optional<std::chrono::milliseconds> timeout;

    // The buffer_body_for_retry specifies whether the streamed body will be buffered so that
    // it can be retried. In general, this should be set to false for a true stream. However,
    // streaming is also used in certain cases such as gRPC unary calls, where retry can
    // still be useful.
    bool buffer_body_for_retry{false};

    // If true, x-forwarded-for header will be added.
    bool send_xff{true};

    // Provides the hash policy for hashing load balancing strategies.
    Protobuf::RepeatedPtrField<envoy::config::route::v3::RouteAction::HashPolicy> hash_policy;

    // Provides parent context. Currently, this holds stream info from the caller.
    ParentContext parent_context;

    envoy::config::core::v3::Metadata metadata;

    // Buffer memory account for tracking bytes.
    Buffer::BufferMemoryAccountSharedPtr account_{nullptr};

    absl::optional<uint32_t> buffer_limit_;

    absl::optional<envoy::config::route::v3::RetryPolicy> retry_policy;

    OptRef<Router::FilterConfig> filter_config_;

    bool is_shadow{false};
  };

  /**
   * A structure to hold the options for AsyncRequest object.
   */
  struct RequestOptions : public StreamOptions {
    RequestOptions& setTimeout(const absl::optional<std::chrono::milliseconds>& v) {
      StreamOptions::setTimeout(v);
      return *this;
    }
    RequestOptions& setTimeout(const std::chrono::milliseconds& v) {
      StreamOptions::setTimeout(v);
      return *this;
    }
    RequestOptions& setBufferBodyForRetry(bool v) {
      StreamOptions::setBufferBodyForRetry(v);
      return *this;
    }
    RequestOptions& setSendXff(bool v) {
      StreamOptions::setSendXff(v);
      return *this;
    }
    RequestOptions& setHashPolicy(
        const Protobuf::RepeatedPtrField<envoy::config::route::v3::RouteAction::HashPolicy>& v) {
      StreamOptions::setHashPolicy(v);
      return *this;
    }
    RequestOptions& setParentContext(const ParentContext& v) {
      StreamOptions::setParentContext(v);
      return *this;
    }
    RequestOptions& setMetadata(const envoy::config::core::v3::Metadata& m) {
      StreamOptions::setMetadata(m);
      return *this;
    }
    RequestOptions& setRetryPolicy(const envoy::config::route::v3::RetryPolicy& p) {
      StreamOptions::setRetryPolicy(p);
      return *this;
    }
    RequestOptions& setIsShadow(bool s) {
      StreamOptions::setIsShadow(s);
      return *this;
    }
    RequestOptions& setParentSpan(Tracing::Span& parent_span) {
      parent_span_ = &parent_span;
      return *this;
    }
    RequestOptions& setChildSpanName(const std::string& child_span_name) {
      child_span_name_ = child_span_name;
      return *this;
    }
    RequestOptions& setSampled(absl::optional<bool> sampled) {
      sampled_ = sampled;
      return *this;
    }
    RequestOptions& setBufferAccount(const Buffer::BufferMemoryAccountSharedPtr& account) {
      account_ = account;
      return *this;
    }
    RequestOptions& setBufferLimit(uint32_t limit) {
      buffer_limit_ = limit;
      return *this;
    }

    // For gmock test
    bool operator==(const RequestOptions& src) const {
      return StreamOptions::operator==(src) && parent_span_ == src.parent_span_ &&
             child_span_name_ == src.child_span_name_ && sampled_ == src.sampled_;
    }

    // The parent span that child spans are created under to trace egress requests/responses.
    // If not set, requests will not be traced.
    Tracing::Span* parent_span_{nullptr};
    // The name to give to the child span that represents the async http request.
    // If left empty and parent_span_ is set, then the default name will have the cluster name.
    // Only used if parent_span_ is set.
    std::string child_span_name_{""};
    // Sampling decision for the tracing span. The span is sampled by default.
    absl::optional<bool> sampled_{true};
  };

  /**
   * Send an HTTP request asynchronously
   * @param request the request to send.
   * @param callbacks the callbacks to be notified of request status.
   * @param options the data struct to control the request sending.
   * @return a request handle or nullptr if no request could be created. NOTE: In this case
   *         onFailure() has already been called inline. The client owns the request and the
   *         handle should just be used to cancel.
   */

  virtual Request* send(RequestMessagePtr&& request, Callbacks& callbacks,
                        const RequestOptions& options) PURE;

  /**
   * Starts a new OngoingRequest asynchronously with the given headers.
   *
   * @param request_headers headers to send.
   * @param callbacks the callbacks to be notified of request status.
   * @param options the data struct to control the request sending.
   * @return a request handle or nullptr if no request could be created. See note attached to
   * `send`. Calling startRequest will not trigger end stream. For header-only requests, `send`
   * should be called instead.
   */
  virtual OngoingRequest* startRequest(RequestHeaderMapPtr&& request_headers, Callbacks& callbacks,
                                       const RequestOptions& options) PURE;

  /**
   * Start an HTTP stream asynchronously, without an associated HTTP request.
   * @param callbacks the callbacks to be notified of stream status.
   * @param options the data struct to control the stream.
   * @return a stream handle or nullptr if no stream could be started. NOTE: In this case
   *         onResetStream() has already been called inline. The client owns the stream and
   *         the handle can be used to send more messages or close the stream.
   */
  virtual Stream* start(StreamCallbacks& callbacks, const StreamOptions& options) PURE;

  /**
   * @return Event::Dispatcher& the dispatcher backing this client.
   */
  virtual Event::Dispatcher& dispatcher() PURE;
};

using AsyncClientPtr = std::unique_ptr<AsyncClient>;

} // namespace Http
} // namespace Envoy
#pragma once

#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <vector>

#include "absl/container/node_hash_map.h"
#include "absl/strings/escaping.h"
#include "fmt/format.h"
#include "fmt/ostream.h"

namespace Envoy {
namespace Http {

/**
 * Please refer to #2394 for more info about Envoy METADATA.
 * Envoy metadata docs can be found at source/docs/h2_metadata.md.
 */
constexpr uint8_t METADATA_FRAME_TYPE = 0x4d;
constexpr uint8_t END_METADATA_FLAG = 0x4;

// NGHTTP2_MAX_PAYLOADLEN in nghttp2.
// TODO(soya3129): Respect max_frame_size after nghttp2 #1250 is resolved.
constexpr uint64_t METADATA_MAX_PAYLOAD_SIZE = 16384;

using UnorderedStringMap = absl::node_hash_map<std::string, std::string>;

class MetadataMap : public UnorderedStringMap {
public:
  using UnorderedStringMap::UnorderedStringMap;

  friend std::ostream& operator<<(std::ostream& out, const MetadataMap& metadata_map) {
    out << "metadata map:";
    for (const auto& metadata : metadata_map) {
      out << "\nkey: " << absl::CEscape(metadata.first)
          << ", value: " << absl::CEscape(metadata.second) << std::endl;
    }
    return out;
  }
};

using MetadataMapPtr = std::unique_ptr<MetadataMap>;

using VectorMetadataMapPtr = std::vector<MetadataMapPtr>;

class MetadataMapVector : public VectorMetadataMapPtr {
public:
  using VectorMetadataMapPtr::VectorMetadataMapPtr;

  friend std::ostream& operator<<(std::ostream& out, const MetadataMapVector& metadata_map_vector) {
    out << "metadata_map_vector:\n";
    for (const auto& metadata_map : metadata_map_vector) {
      out << *metadata_map;
    }
    return out;
  }
};

using MetadataCallback = std::function<void(MetadataMapPtr&&)>;

} // namespace Http
} // namespace Envoy

// NOLINT(namespace-envoy)
namespace fmt {

// Specialize printing Envoy::Http::MetadataMap as we need to escape possible
// invalid utf8 string contained in MetadataMap.
template <> struct formatter<Envoy::Http::MetadataMap> {
  template <typename ParseContext>
  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
    return ctx.begin();
  }

  template <typename FormatContext>
  auto format(const Envoy::Http::MetadataMap& map, FormatContext& ctx) -> decltype(ctx.out()) {
    std::ostringstream out;
    out << map;
    auto str = out.str();
    return fmt::formatter<std::string>().format(str, ctx);
  }
};

template <> struct formatter<::Envoy::Http::MetadataMapVector> : fmt::ostream_formatter {};

} // namespace fmt
#pragma once

#include "envoy/http/header_map.h"
#include "envoy/network/address.h"
#include "envoy/stream_info/filter_state.h"

#include "absl/types/optional.h"

namespace Envoy {
namespace Http {

/**
 * CookieAttribute that stores the name and value of a cookie.
 */
class CookieAttribute {
public:
  CookieAttribute(const std::string& name, const std::string& value) : name_(name), value_(value) {}

  std::string name() const { return name_; }
  std::string value() const { return value_; }

private:
  std::string name_;
  std::string value_;
};

using CookieAttributeRefVector = std::vector<std::reference_wrapper<const CookieAttribute>>;

/**
 * Request hash policy. I.e., if using a hashing load balancer, how a request should be hashed onto
 * an upstream host.
 */
class HashPolicy {
public:
  virtual ~HashPolicy() = default;

  /**
   * A callback used for requesting that a cookie be set with the given lifetime.
   * @param key the name of the cookie to be set
   * @param path the path of the cookie, or the empty string if no path should be set.
   * @param ttl the lifetime of the cookie
   * @return std::string the opaque value of the cookie that will be set
   */
  using AddCookieCallback = std::function<std::string(
      const std::string& key, const std::string& path, std::chrono::seconds ttl,
      const CookieAttributeRefVector attributes)>;

  /**
   * @param downstream_address is the address of the connected client host, or nullptr if the
   * request is initiated from within this host
   * @param headers stores the HTTP headers for the stream
   * @param add_cookie is called to add a set-cookie header on the reply sent to the downstream
   * host
   * @return absl::optional<uint64_t> an optional hash value to route on. A hash value might not be
   * returned if for example the specified HTTP header does not exist.
   */
  virtual absl::optional<uint64_t>
  generateHash(const Network::Address::Instance* downstream_address,
               const RequestHeaderMap& headers, AddCookieCallback add_cookie,
               const StreamInfo::FilterStateSharedPtr filter_state) const PURE;
};

} // namespace Http
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "http_server_properties_cache_interface",
    hdrs = ["http_server_properties_cache.h"],
    deps = [
        "//envoy/common:time_interface",
        "//envoy/event:dispatcher_interface",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "api_listener_interface",
    hdrs = ["api_listener.h"],
    deps = [":codec_interface"],
)

envoy_cc_library(
    name = "async_client_interface",
    hdrs = ["async_client.h"],
    external_deps = ["abseil_optional"],
    deps = [
        ":filter_interface",
        ":message_interface",
        "//envoy/event:dispatcher_interface",
        "//envoy/stream_info:stream_info_interface",
        "//envoy/tracing:tracer_interface",
        "//source/common/protobuf",
        "//source/common/protobuf:utility_lib",
        "@envoy_api//envoy/config/route/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "codec_interface",
    hdrs = ["codec.h"],
    deps = [
        ":header_map_interface",
        ":metadata_interface",
        ":protocol_interface",
        ":stream_reset_handler_interface",
        "//envoy/access_log:access_log_interface",
        "//envoy/buffer:buffer_interface",
        "//envoy/grpc:status",
        "//envoy/network:address_interface",
        "//envoy/stream_info:stream_info_interface",
        "//source/common/http:status_lib",
    ],
)

envoy_cc_library(
    name = "stream_reset_handler_interface",
    hdrs = ["stream_reset_handler.h"],
)

envoy_cc_library(
    name = "codes_interface",
    hdrs = ["codes.h"],
    deps = ["//envoy/stats:stats_interface"],
)

envoy_cc_library(
    name = "conn_pool_interface",
    hdrs = ["conn_pool.h"],
    deps = [
        ":codec_interface",
        "//envoy/common:conn_pool_interface",
        "//envoy/event:deferred_deletable",
        "//envoy/upstream:upstream_interface",
    ],
)

envoy_cc_library(
    name = "context_interface",
    hdrs = ["context.h"],
    deps = [
        ":codes_interface",
        "@envoy_api//envoy/config/trace/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "filter_factory_interface",
    hdrs = ["filter_factory.h"],
    external_deps = ["abseil_optional"],
    deps = [
        ":header_map_interface",
        "//envoy/access_log:access_log_interface",
        "//envoy/grpc:status",
    ],
)

envoy_cc_library(
    name = "filter_interface",
    hdrs = ["filter.h"],
    external_deps = ["abseil_optional"],
    deps = [
        ":codec_interface",
        ":filter_factory_interface",
        ":header_map_interface",
        "//envoy/access_log:access_log_interface",
        "//envoy/common:scope_tracker_interface",
        "//envoy/event:dispatcher_interface",
        "//envoy/grpc:status",
        "//envoy/matcher:matcher_interface",
        "//envoy/router:router_interface",
        "//envoy/ssl:connection_interface",
        "//envoy/stream_info:stream_info_interface",
        "//envoy/tracing:tracer_interface",
        "//envoy/upstream:load_balancer_interface",
        "//source/common/common:scope_tracked_object_stack",
    ],
)

envoy_cc_library(
    name = "hash_policy_interface",
    hdrs = ["hash_policy.h"],
    deps = [
        ":header_map_interface",
        "//envoy/network:address_interface",
        "//envoy/stream_info:filter_state_interface",
    ],
)

envoy_cc_library(
    name = "header_map_interface",
    hdrs = ["header_map.h"],
    external_deps = [
        "abseil_inlined_vector",
    ],
    deps = [
        ":header_formatter_interface",
        "//envoy/common:union_string",
        "//source/common/common:assert_lib",
        "//source/common/common:hash_lib",
    ],
)

envoy_cc_library(
    name = "message_interface",
    hdrs = ["message.h"],
    deps = [
        ":header_map_interface",
        "//envoy/buffer:buffer_interface",
    ],
)

envoy_cc_library(
    name = "protocol_interface",
    hdrs = ["protocol.h"],
)

envoy_cc_library(
    name = "query_params_interface",
    hdrs = ["query_params.h"],
    external_deps = ["abseil_btree"],
)

envoy_cc_library(
    name = "metadata_interface",
    hdrs = ["metadata_interface.h"],
    external_deps = ["abseil_node_hash_map"],
)

envoy_cc_library(
    name = "request_id_extension_interface",
    hdrs = ["request_id_extension.h"],
    deps = [
        ":header_map_interface",
        "//envoy/tracing:trace_reason_interface",
    ],
)

envoy_cc_library(
    name = "header_formatter_interface",
    hdrs = ["header_formatter.h"],
    deps = [
        "//envoy/common:optref_lib",
        "//envoy/config:typed_config_interface",
    ],
)

envoy_cc_library(
    name = "original_ip_detection_interface",
    hdrs = ["original_ip_detection.h"],
    deps = [
        ":codes_interface",
        ":header_map_interface",
        "//envoy/config:typed_config_interface",
        "//envoy/network:address_interface",
        "//envoy/server:factory_context_interface",
    ],
)

envoy_cc_library(
    name = "early_header_mutation_interface",
    hdrs = ["early_header_mutation.h"],
    deps = [
        ":header_map_interface",
        "//envoy/config:typed_config_interface",
        "//envoy/server:factory_context_interface",
        "//envoy/stream_info:stream_info_interface",
    ],
)

envoy_cc_library(
    name = "header_evaluator",
    hdrs = ["header_evaluator.h"],
    deps = [
        "//envoy/formatter:substitution_formatter_interface",
        "//envoy/http:header_map_interface",
        "//envoy/stream_info:stream_info_interface",
    ],
)

envoy_cc_library(
    name = "stateful_session_interface",
    hdrs = ["stateful_session.h"],
    deps = [
        ":header_map_interface",
        "//envoy/config:typed_config_interface",
        "//envoy/server:factory_context_interface",
        "//envoy/upstream:upstream_interface",
    ],
)

envoy_cc_library(
    name = "persistent_quic_info_interface",
    hdrs = ["persistent_quic_info.h"],
)

envoy_cc_library(
    name = "header_validator_interface",
    hdrs = ["header_validator.h"],
    deps = [
        "//envoy/http:header_map_interface",
        "//envoy/http:protocol_interface",
    ],
)

envoy_cc_library(
    name = "header_validator_factory_interface",
    hdrs = ["header_validator_factory.h"],
    deps = [
        ":header_validator_interface",
        "//envoy/config:typed_config_interface",
        "//envoy/server:factory_context_interface",
    ],
)

envoy_cc_library(
    name = "header_validator_errors",
    hdrs = [
        "header_validator_errors.h",
    ],
    deps = [
        "//source/common/singleton:const_singleton",
    ],
)
#pragma once

#include <cstdint>
#include <functional>
#include <memory>
#include <string>

#include "envoy/access_log/access_log.h"
#include "envoy/buffer/buffer.h"
#include "envoy/common/scope_tracker.h"
#include "envoy/event/dispatcher.h"
#include "envoy/grpc/status.h"
#include "envoy/http/codec.h"
#include "envoy/http/filter_factory.h"
#include "envoy/http/header_map.h"
#include "envoy/matcher/matcher.h"
#include "envoy/router/router.h"
#include "envoy/ssl/connection.h"
#include "envoy/tracing/tracer.h"
#include "envoy/upstream/load_balancer.h"
#include "envoy/upstream/upstream.h"

#include "source/common/common/scope_tracked_object_stack.h"

#include "absl/types/optional.h"

namespace Envoy {
namespace Http {

/**
 * Return codes for encode/decode headers filter invocations. The connection manager bases further
 * filter invocations on the return code of the previous filter.
 */
enum class FilterHeadersStatus {
  // Continue filter chain iteration.
  Continue,
  // Do not iterate for headers on any of the remaining filters in the chain.
  //
  // Returning FilterDataStatus::Continue from decodeData()/encodeData() or calling
  // continueDecoding()/continueEncoding() MUST be called if continued filter iteration is desired.
  //
  // Note that if a local reply was sent, no further iteration for headers as well as data and
  // trailers for the current filter and the filters following will happen. A local reply can be
  // triggered via sendLocalReply() or encodeHeaders().
  StopIteration,
  // Continue headers iteration to remaining filters, but delay ending the stream. This status MUST
  // NOT be returned when end_stream is already set to false.
  //
  // Used when a filter wants to add a body to a headers-only request/response, but this body is not
  // readily available. Delaying end_stream allows the filter to add the body once it's available
  // without stopping headers iteration.
  //
  // The filter is responsible to continue the stream by providing a body through calling
  // injectDecodedDataToFilterChain()/injectEncodedDataToFilterChain(), possibly multiple times
  // if the body needs to be divided into several chunks. The filter may need to handle
  // watermark events when injecting a body, see:
  // https://github.com/envoyproxy/envoy/blob/main/source/docs/flow_control.md.
  //
  // The last call to inject data MUST have end_stream set to true to conclude the stream.
  // If the filter cannot provide a body the stream should be reset.
  //
  // Adding a body through calling addDecodedData()/addEncodedData() then
  // continueDecoding()/continueEncoding() is currently NOT supported and causes an assert failure.
  //
  // Adding trailers in this scenario is currently NOT supported.
  //
  // The filter MUST NOT attempt to continue the stream without providing a body using
  // continueDecoding()/continueEncoding().
  //
  // TODO(yosrym93): Support adding a body in this case by calling addDecodedData()/addEncodedData()
  // then continueDecoding()/continueEncoding(). To support this a new FilterManager::IterationState
  // needs to be added and set when a filter returns this status in
  // FilterManager::decodeHeaders/FilterManager::encodeHeaders()
  // Currently, when a filter returns this, the IterationState is Continue. This causes ASSERTs in
  // FilterManager::commonContinue() to fail when continueDecoding()/continueEncoding() is called;
  // due to trying to continue iteration when the IterationState is already Continue.
  // In this case, a different ASSERT will be needed to make sure the filter does not try to
  // continue without adding a body first.
  //
  // TODO(yosrym93): Support adding trailers in this case by implementing new functions to inject
  // trailers, similar to the inject data functions.
  ContinueAndDontEndStream,
  // Do not iterate for headers as well as data and trailers for the current filter and the filters
  // following, and buffer body data for later dispatching. ContinueDecoding() MUST
  // be called if continued filter iteration is desired.
  //
  // Used when a filter wants to stop iteration on data and trailers while waiting for headers'
  // iteration to resume.
  //
  // If buffering the request causes buffered data to exceed the configured buffer limit, a 413 will
  // be sent to the user. On the response path exceeding buffer limits will result in a 500.
  //
  // TODO(soya3129): stop metadata parsing when StopAllIterationAndBuffer is set.
  StopAllIterationAndBuffer,
  // Do not iterate for headers as well as data and trailers for the current filter and the filters
  // following, and buffer body data for later dispatching. continueDecoding() MUST
  // be called if continued filter iteration is desired.
  //
  // Used when a filter wants to stop iteration on data and trailers while waiting for headers'
  // iteration to resume.
  //
  // This will cause the flow of incoming data to cease until continueDecoding() function is called.
  //
  // TODO(soya3129): stop metadata parsing when StopAllIterationAndWatermark is set.
  StopAllIterationAndWatermark,
};

/**
 * Return codes for encode on informative headers filter invocations.
 */
enum class Filter1xxHeadersStatus {
  // Continue filter chain iteration.
  Continue,
  // Do not iterate for informative headers on any of the remaining filters in the chain.
  //
  // Returning FilterDataStatus::Continue from encodeData() or calling
  // continueEncoding() MUST be called if continued filter iteration is desired.
  StopIteration
};

/**
 * Return codes for encode/decode data filter invocations. The connection manager bases further
 * filter invocations on the return code of the previous filter.
 */
enum class FilterDataStatus {
  // Continue filter chain iteration. If headers have not yet been sent to the next filter, they
  // will be sent first via decodeHeaders()/encodeHeaders(). If data has previously been buffered,
  // the data in this callback will be added to the buffer before the entirety is sent to the next
  // filter.
  Continue,
  // Do not iterate to any of the remaining filters in the chain, and buffer body data for later
  // dispatching. Returning FilterDataStatus::Continue from decodeData()/encodeData() or calling
  // continueDecoding()/continueEncoding() MUST be called if continued filter iteration is desired.
  //
  // This should be called by filters which must parse a larger block of the incoming data before
  // continuing processing and so can not push back on streaming data via watermarks.
  //
  // If buffering the request causes buffered data to exceed the configured buffer limit, a 413 will
  // be sent to the user. On the response path exceeding buffer limits will result in a 500.
  StopIterationAndBuffer,
  // Do not iterate to any of the remaining filters in the chain, and buffer body data for later
  // dispatching. Returning FilterDataStatus::Continue from decodeData()/encodeData() or calling
  // continueDecoding()/continueEncoding() MUST be called if continued filter iteration is desired.
  //
  // This will cause the flow of incoming data to cease until one of the continue.*() functions is
  // called.
  //
  // This should be returned by filters which can nominally stream data but have a transient back-up
  // such as the configured delay of the fault filter, or if the router filter is still fetching an
  // upstream connection.
  StopIterationAndWatermark,
  // Do not iterate to any of the remaining filters in the chain, but do not buffer any of the
  // body data for later dispatching. Returning FilterDataStatus::Continue from
  // decodeData()/encodeData() or calling continueDecoding()/continueEncoding() MUST be called if
  // continued filter iteration is desired.
  //
  // Note that if a local reply was sent, no further iteration for either data or trailers
  // for the current filter and the filters following will happen. A local reply can be
  // triggered via sendLocalReply() or encodeHeaders().
  StopIterationNoBuffer
};

/**
 * Return codes for encode/decode trailers filter invocations. The connection manager bases further
 * filter invocations on the return code of the previous filter.
 */
enum class FilterTrailersStatus {
  // Continue filter chain iteration.
  Continue,
  // Do not iterate to any of the remaining filters in the chain. Calling
  // continueDecoding()/continueEncoding() MUST be called if continued filter iteration is desired.
  StopIteration
};

/**
 * Return codes for encode metadata filter invocations. Metadata currently can not stop filter
 * iteration except in the case of local replies.
 */
enum class FilterMetadataStatus {
  // Continue filter chain iteration for metadata only. Does not unblock returns of StopIteration*
  // from (decode|encode)(Headers|Data).
  Continue,

  // Continue filter chain iteration. If headers have not yet been sent to the next filter, they
  // will be sent first via (decode|encode)Headers().
  ContinueAll,

  // Stops iteration of the entire filter chain. Only to be used in the case of sending a local
  // reply from (decode|encode)Metadata.
  StopIterationForLocalReply,
};

/**
 * Return codes for onLocalReply filter invocations.
 */
enum class LocalErrorStatus {
  // Continue sending the local reply after onLocalReply has been sent to all filters.
  Continue,

  // Continue sending onLocalReply to all filters, but reset the stream once all filters have been
  // informed rather than sending the local reply.
  ContinueAndResetStream,
};

// These are events that upstream HTTP filters can register for, via the addUpstreamCallbacks
// function.
class UpstreamCallbacks {
public:
  virtual ~UpstreamCallbacks() = default;

  // Called when the upstream connection is established and
  // UpstreamStreamFilterCallbacks::upstream should be available.
  //
  // This indicates that data may begin flowing upstream.
  virtual void onUpstreamConnectionEstablished() PURE;
};

// These are filter callbacks specific to upstream HTTP filters, accessible via
// StreamFilterCallbacks::upstreamCallbacks()
class UpstreamStreamFilterCallbacks {
public:
  virtual ~UpstreamStreamFilterCallbacks() = default;

  // Returns a handle to the upstream stream's stream info.
  virtual StreamInfo::StreamInfo& upstreamStreamInfo() PURE;

  // Returns a handle to the generic upstream.
  virtual OptRef<Router::GenericUpstream> upstream() PURE;

  // Dumps state for the upstream request.
  virtual void dumpState(std::ostream& os, int indent_level = 0) const PURE;

  // Setters and getters to determine if sending body payload is paused on
  // confirmation of a CONNECT upgrade. These should only be used by the upstream codec filter.
  // TODO(alyssawilk) after deprecating the classic path, move this logic to the
  // upstream codec filter and remove these APIs
  virtual bool pausedForConnect() const PURE;
  virtual void setPausedForConnect(bool value) PURE;

  // Return the upstreamStreamOptions for this stream.
  virtual const Http::ConnectionPool::Instance::StreamOptions& upstreamStreamOptions() const PURE;

  // Adds the supplied UpstreamCallbacks to the list of callbacks to be called
  // as various upstream events occur. Callbacks should persist for the lifetime
  // of the upstream stream.
  virtual void addUpstreamCallbacks(UpstreamCallbacks& callbacks) PURE;

  // This should only be called by the UpstreamCodecFilter, and is used to let the
  // UpstreamCodecFilter supply the interface used by the GenericUpstream to receive
  // response data from the upstream stream once it is established.
  virtual void
  setUpstreamToDownstream(Router::UpstreamToDownstream& upstream_to_downstream_interface) PURE;
};

/**
 * RouteConfigUpdatedCallback is used to notify an OnDemandRouteUpdate filter about completion of a
 * RouteConfig update. The filter (and the associated ActiveStream) where the original on-demand
 * request was originated can be destroyed before a response to an on-demand update request is
 * received and updates are propagated. To handle this:
 *
 * OnDemandRouteUpdate filter instance holds a RouteConfigUpdatedCallbackSharedPtr to a callback.
 * Envoy::Router::RdsRouteConfigProviderImpl holds a weak pointer to the RouteConfigUpdatedCallback
 * above in an Envoy::Router::UpdateOnDemandCallback struct
 *
 * In RdsRouteConfigProviderImpl::onConfigUpdate(), before invoking the callback, a check is made to
 * verify if the callback is still available.
 */
using RouteConfigUpdatedCallback = std::function<void(bool)>;
using RouteConfigUpdatedCallbackSharedPtr = std::shared_ptr<RouteConfigUpdatedCallback>;

class DownstreamStreamFilterCallbacks {
public:
  virtual ~DownstreamStreamFilterCallbacks() = default;

  /**
   * Sets the cached route for the current request to the passed-in RouteConstSharedPtr parameter.
   *
   * Similar to route(const Router::RouteCallback& cb), this route that is set will be
   * overridden by clearRouteCache() in subsequent filters. Usage is intended for filters at the end
   * of the filter chain.
   *
   * NOTE: Passing nullptr in as the route parameter is equivalent to route resolution being
   * attempted and failing to find a route. An example of when this happens is when
   * RouteConstSharedPtr route(const RouteCallback& cb, const Http::RequestHeaderMap& headers, const
   * StreamInfo::StreamInfo& stream_info, uint64_t random_value) returns nullptr during a
   * refreshCachedRoute. It is important to note that setRoute(nullptr) is different from a
   * clearRouteCache(), because clearRouteCache() wants route resolution to be attempted again.
   * clearRouteCache() achieves this by setting cached_route_ and cached_cluster_info_ to
   * absl::optional ptrs instead of null ptrs.
   */
  virtual void setRoute(Router::RouteConstSharedPtr route) PURE;

  /**
   * Invokes callback with a matched route, callback can choose to accept this route by returning
   * Router::RouteMatchStatus::Accept or continue route match from last matched route by returning
   * Router::RouteMatchStatus::Continue, if there are more routes available.
   *
   * Returns route accepted by the callback or nullptr if no match found or none of route is
   * accepted by the callback.
   *
   * NOTE: clearRouteCache() must be called before invoking this method otherwise cached route will
   * be returned directly to the caller and the callback will not be invoked.
   *
   * Currently a route callback's decision is overridden by clearRouteCache() / route() call in the
   * subsequent filters. We may want to persist callbacks so they always participate in later route
   * resolution or make it an independent entity like filters that gets called on route resolution.
   */
  virtual Router::RouteConstSharedPtr route(const Router::RouteCallback& cb) PURE;

  /**
   * Clears the route cache for the current request. This must be called when a filter has modified
   * the headers in a way that would affect routing.
   */
  virtual void clearRouteCache() PURE;

  /**
   * Schedules a request for a RouteConfiguration update from the management server.
   * @param route_config_updated_cb callback to be called when the configuration update has been
   * propagated to the worker thread.
   */
  virtual void
  requestRouteConfigUpdate(RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) PURE;
};

/**
 * The stream filter callbacks are passed to all filters to use for writing response data and
 * interacting with the underlying stream in general.
 */
class StreamFilterCallbacks {
public:
  virtual ~StreamFilterCallbacks() = default;

  /**
   * @return OptRef<const Network::Connection> the downstream connection, or nullptr if there is
   * none.
   */
  virtual OptRef<const Network::Connection> connection() PURE;

  /**
   * @return Event::Dispatcher& the thread local dispatcher for allocating timers, etc.
   */
  virtual Event::Dispatcher& dispatcher() PURE;

  /**
   * Reset the underlying stream.
   */
  virtual void
  resetStream(Http::StreamResetReason reset_reason = Http::StreamResetReason::LocalReset,
              absl::string_view transport_failure_reason = "") PURE;

  /**
   * Returns the route for the current request. The assumption is that the implementation can do
   * caching where applicable to avoid multiple lookups. If a filter has modified the headers in
   * a way that affects routing, clearRouteCache() must be called to clear the cache.
   */
  virtual Router::RouteConstSharedPtr route() PURE;

  /**
   * Returns the clusterInfo for the cached route.
   * This method is to avoid multiple look ups in the filter chain, it also provides a consistent
   * view of clusterInfo after a route is picked/repicked.
   * NOTE: Cached clusterInfo and route will be updated the same time.
   */
  virtual Upstream::ClusterInfoConstSharedPtr clusterInfo() PURE;

  /**
   * @return uint64_t the ID of the originating stream for logging purposes.
   */
  virtual uint64_t streamId() const PURE;

  /**
   * @return streamInfo for logging purposes. Individual filter may add specific information to be
   * put into the access log.
   */
  virtual StreamInfo::StreamInfo& streamInfo() PURE;

  /**
   * @return span context used for tracing purposes. Individual filters may add or modify
   *              information in the span context.
   */
  virtual Tracing::Span& activeSpan() PURE;

  /**
   * @return tracing configuration if present.
   */
  virtual OptRef<const Tracing::Config> tracingConfig() const PURE;

  /**
   * @return the ScopeTrackedObject for this stream.
   */
  virtual const ScopeTrackedObject& scope() PURE;

  /**
   * Should be used when we continue processing a request or response by invoking a filter directly
   * from an asynchronous callback to restore crash context. If not explicitly used by the filter
   * itself, this gets invoked in ActiveStreamFilterBase::commonContinue().
   *
   * @param tracked_object_stack ScopeTrackedObjectStack where relevant ScopeTrackedObjects will be
   * added to.
   */
  virtual void restoreContextOnContinue(ScopeTrackedObjectStack& tracked_object_stack) PURE;

  /**
   * Called when filter activity indicates that the stream idle timeout should be reset.
   */
  virtual void resetIdleTimer() PURE;

  /**
   * This is a helper to get the route's per-filter config if it exists, otherwise the virtual
   * host's. Or nullptr if none of them exist.
   */
  virtual const Router::RouteSpecificFilterConfig* mostSpecificPerFilterConfig() const PURE;

  /**
   * Find all the available per route filter configs, invoking the callback with each config (if
   * it is present). Iteration of the configs is in order of specificity. That means that the
   * callback will be called first for a config on a Virtual host, then a route, and finally a route
   * entry (weighted cluster). If a config is not present, the callback will not be invoked.
   */
  virtual void traversePerFilterConfig(
      std::function<void(const Router::RouteSpecificFilterConfig&)> cb) const PURE;

  /**
   * Return the HTTP/1 stream encoder options if applicable. If the stream is not HTTP/1 returns
   * absl::nullopt.
   */
  virtual Http1StreamEncoderOptionsOptRef http1StreamEncoderOptions() PURE;

  /**
   * Return a handle to the upstream callbacks. This is valid for upstream HTTP filters, and nullopt
   * for downstream HTTP filters.
   */
  virtual OptRef<UpstreamStreamFilterCallbacks> upstreamCallbacks() PURE;

  /**
   * Return a handle to the downstream callbacks. This is valid for downstream HTTP filters, and
   * nullopt for upstream HTTP filters.
   */
  virtual OptRef<DownstreamStreamFilterCallbacks> downstreamCallbacks() PURE;

  /**
   * @return absl::string_view the name of the filter as configured in the filter chain.
   */
  virtual absl::string_view filterConfigName() const PURE;

  /**
   * The downstream request headers if present.
   */
  virtual RequestHeaderMapOptRef requestHeaders() PURE;

  /**
   * The downstream request trailers if present.
   */
  virtual RequestTrailerMapOptRef requestTrailers() PURE;

  /**
   * Retrieves a pointer to the continue headers if present.
   */
  virtual ResponseHeaderMapOptRef informationalHeaders() PURE;

  /**
   * Retrieves a pointer to the response headers if present.
   * Note that response headers might be set multiple times (e.g. if a local reply is issued after
   * headers have been received but before headers have been encoded), so it is not safe in general
   * to assume that any set of headers will be valid for the duration of the stream.
   */
  virtual ResponseHeaderMapOptRef responseHeaders() PURE;

  /**
   * Retrieves a pointer to the last response trailers if present.
   * Note that response headers might be set multiple times (e.g. if a local reply is issued after
   * headers have been received but before headers have been encoded), so it is not safe in general
   * to assume that any set of headers will be valid for the duration of the stream.
   */
  virtual ResponseTrailerMapOptRef responseTrailers() PURE;
};

class DecoderFilterWatermarkCallbacks {
public:
  virtual ~DecoderFilterWatermarkCallbacks() = default;

  /**
   * Called when the buffer for a decoder filter or any buffers the filter sends data to go over
   * their high watermark.
   *
   * In the case of a filter such as the router filter, which spills into multiple buffers (codec,
   * connection etc.) this may be called multiple times. Any such filter is responsible for calling
   * the low watermark callbacks an equal number of times as the respective buffers are drained.
   */
  virtual void onDecoderFilterAboveWriteBufferHighWatermark() PURE;

  /**
   * Called when a decoder filter or any buffers the filter sends data to go from over its high
   * watermark to under its low watermark.
   */
  virtual void onDecoderFilterBelowWriteBufferLowWatermark() PURE;
};
/**
 * Stream decoder filter callbacks add additional callbacks that allow a
 * decoding filter to restart decoding if they decide to hold data (e.g. for
 * buffering or rate limiting).
 */
class StreamDecoderFilterCallbacks : public virtual StreamFilterCallbacks,
                                     public virtual DecoderFilterWatermarkCallbacks {
public:
  /**
   * Continue iterating through the filter chain with buffered headers and body data. This routine
   * can only be called if the filter has previously returned StopIteration from decodeHeaders()
   * AND one of StopIterationAndBuffer, StopIterationAndWatermark, or StopIterationNoBuffer
   * from each previous call to decodeData().
   *
   * The connection manager will dispatch headers and any buffered body data to the
   * next filter in the chain. Further note that if the request is not complete, this filter will
   * still receive decodeData() calls and must return an appropriate status code depending on what
   * the filter needs to do.
   */
  virtual void continueDecoding() PURE;

  /**
   * @return const Buffer::Instance* the currently buffered data as buffered by this filter or
   *         previous ones in the filter chain. May be nullptr if nothing has been buffered yet.
   */
  virtual const Buffer::Instance* decodingBuffer() PURE;

  /**
   * Allows modifying the decoding buffer. May only be called before any data has been continued
   * past the calling filter.
   */
  virtual void modifyDecodingBuffer(std::function<void(Buffer::Instance&)> callback) PURE;

  /**
   * Add buffered body data. This method is used in advanced cases where returning
   * StopIterationAndBuffer from decodeData() is not sufficient.
   *
   * 1) If a headers only request needs to be turned into a request with a body, this method can
   * be called to add body in the decodeHeaders() callback. Subsequent filters will receive
   * decodeHeaders(..., false) followed by decodeData(..., true). This works both in the direct
   * iteration as well as the continuation case.
   *
   * 2) If a filter is going to look at all buffered data from within a data callback with end
   * stream set, this method can be called to immediately buffer the data. This avoids having
   * to deal with the existing buffered data and the data from the current callback.
   *
   * 3) If additional buffered body data needs to be added by a filter before continuation of data
   * to further filters (outside of callback context).
   *
   * 4) If additional data needs to be added in the decodeTrailers() callback, this method can be
   * called in the context of the callback. All further filters will receive decodeData(..., false)
   * followed by decodeTrailers(). However if the iteration is stopped, the added data will
   * buffered, so that the further filters will not receive decodeData() before decodeHeaders().
   *
   * It is an error to call this method in any other case.
   *
   * See also injectDecodedDataToFilterChain() for a different way of passing data to further
   * filters and also how the two methods are different.
   *
   * @param data Buffer::Instance supplies the data to be decoded.
   * @param streaming_filter boolean supplies if this filter streams data or buffers the full body.
   */
  virtual void addDecodedData(Buffer::Instance& data, bool streaming_filter) PURE;

  /**
   * Decode data directly to subsequent filters in the filter chain. This method is used in
   * advanced cases in which a filter needs full control over how subsequent filters view data,
   * and does not want to make use of HTTP connection manager buffering. Using this method allows
   * a filter to buffer data (or not) and then periodically inject data to subsequent filters,
   * indicating end_stream at an appropriate time. This can be used to implement rate limiting,
   * periodic data emission, etc.
   *
   * This method should only be called outside of callback context. I.e., do not call this method
   * from within a filter's decodeData() call.
   *
   * When using this callback, filters should generally only return
   * FilterDataStatus::StopIterationNoBuffer from their decodeData() call, since use of this method
   * indicates that a filter does not wish to participate in standard HTTP connection manager
   * buffering and continuation and will perform any necessary buffering and continuation on its
   * own.
   *
   * This callback is different from addDecodedData() in that the specified data and end_stream
   * status will be propagated directly to further filters in the filter chain. This is different
   * from addDecodedData() where data is added to the HTTP connection manager's buffered data with
   * the assumption that standard HTTP connection manager buffering and continuation are being used.
   */
  virtual void injectDecodedDataToFilterChain(Buffer::Instance& data, bool end_stream) PURE;

  /**
   * Adds decoded trailers. May only be called in decodeData when end_stream is set to true.
   * If called in any other context, an assertion will be triggered.
   *
   * When called in decodeData, the trailers map will be initialized to an empty map and returned by
   * reference. Calling this function more than once is invalid.
   *
   * @return a reference to the newly created trailers map.
   */
  virtual RequestTrailerMap& addDecodedTrailers() PURE;

  /**
   * Attempts to create a locally generated response using the provided response_code and body_text
   * parameters. If the request was a gRPC request the local reply will be encoded as a gRPC
   * response with a 200 HTTP response code and grpc-status and grpc-message headers mapped from the
   * provided parameters.
   *
   * If a response has already started (e.g. if the router calls sendLocalReply after encoding
   * headers) this will either ship the reply directly to the downstream codec, or reset the stream.
   *
   * @param response_code supplies the HTTP response code.
   * @param body_text supplies the optional body text which is sent using the text/plain content
   *                  type, or encoded in the grpc-message header.
   * @param modify_headers supplies an optional callback function that can modify the
   *                       response headers.
   * @param grpc_status the gRPC status code to override the httpToGrpcStatus mapping with.
   * @param details a string detailing why this local reply was sent.
   */
  virtual void sendLocalReply(Code response_code, absl::string_view body_text,
                              std::function<void(ResponseHeaderMap& headers)> modify_headers,
                              const absl::optional<Grpc::Status::GrpcStatus> grpc_status,
                              absl::string_view details) PURE;

  /**
   * Adds decoded metadata. This function can only be called in
   * StreamDecoderFilter::decodeHeaders/Data/Trailers(). Do not call in
   * StreamDecoderFilter::decodeMetadata().
   *
   * @return a reference to metadata map vector, where new metadata map can be added.
   */
  virtual MetadataMapVector& addDecodedMetadata() PURE;

  /**
   * Called with 1xx headers to be encoded.
   *
   * Currently supported codes for this function include 100.
   *
   * This is not folded into encodeHeaders because most Envoy users and filters will not be proxying
   * 1xx headers and with it split out, can ignore the complexity of multiple encodeHeaders calls.
   *
   * This is currently only called once per request but implementations should
   * handle multiple calls as multiple 1xx headers are legal.
   *
   * @param headers supplies the headers to be encoded.
   */
  virtual void encode1xxHeaders(ResponseHeaderMapPtr&& headers) PURE;

  /**
   * Called with headers to be encoded, optionally indicating end of stream.
   *
   * The connection manager inspects certain pseudo headers that are not actually sent downstream.
   * - See source/common/http/headers.h
   *
   * The only 1xx that may be provided to encodeHeaders() is a 101 upgrade, which will be the final
   * encodeHeaders() for a response.
   *
   * @param headers supplies the headers to be encoded.
   * @param end_stream supplies whether this is a header only request/response.
   * @param details supplies the details of why this response was sent.
   */
  virtual void encodeHeaders(ResponseHeaderMapPtr&& headers, bool end_stream,
                             absl::string_view details) PURE;

  /**
   * Called with data to be encoded, optionally indicating end of stream.
   * @param data supplies the data to be encoded.
   * @param end_stream supplies whether this is the last data frame.
   */
  virtual void encodeData(Buffer::Instance& data, bool end_stream) PURE;

  /**
   * Called with trailers to be encoded. This implicitly ends the stream.
   * @param trailers supplies the trailers to encode.
   */
  virtual void encodeTrailers(ResponseTrailerMapPtr&& trailers) PURE;

  /**
   * Called with metadata to be encoded.
   *
   * @param metadata_map supplies the unique_ptr of the metadata to be encoded.
   */
  virtual void encodeMetadata(MetadataMapPtr&& metadata_map) PURE;

  /**
   * This routine can be called by a filter to subscribe to watermark events on the downstream
   * stream and downstream connection.
   *
   * Immediately after subscribing, the filter will get a high watermark callback for each
   * outstanding backed up buffer.
   */
  virtual void addDownstreamWatermarkCallbacks(DownstreamWatermarkCallbacks& callbacks) PURE;

  /**
   * This routine can be called by a filter to stop subscribing to watermark events on the
   * downstream stream and downstream connection.
   *
   * It is not safe to call this from under the stack of a DownstreamWatermarkCallbacks callback.
   */
  virtual void removeDownstreamWatermarkCallbacks(DownstreamWatermarkCallbacks& callbacks) PURE;

  /**
   * This routine may be called to change the buffer limit for decoder filters.
   *
   * It is recommended (but not required) that filters calling this function should
   * generally only perform increases to the buffer limit, to avoid potentially
   * conflicting with the buffer requirements of other filters in the chain, i.e.
   *
   * if (desired_limit > decoderBufferLimit()) {setDecoderBufferLimit(desired_limit);}
   *
   * @param limit supplies the desired buffer limit.
   */
  virtual void setDecoderBufferLimit(uint32_t limit) PURE;

  /**
   * This routine returns the current buffer limit for decoder filters. Filters should abide by
   * this limit or change it via setDecoderBufferLimit.
   * A buffer limit of 0 bytes indicates no limits are applied.
   *
   * @return the buffer limit the filter should apply.
   */
  virtual uint32_t decoderBufferLimit() PURE;

  /**
   * @return the account, if any, used by this stream.
   */
  virtual Buffer::BufferMemoryAccountSharedPtr account() const PURE;

  /**
   * Takes a stream, and acts as if the headers are newly arrived.
   * On success, this will result in a creating a new filter chain and likely
   * upstream request associated with the original downstream stream. On
   * failure, if the preconditions outlined below are not met, the caller is
   * responsible for handling or terminating the original stream.
   *
   * This is currently limited to
   *   - streams which are completely read
   *   - streams which do not have a request body.
   *
   * Note that HttpConnectionManager sanitization will *not* be performed on the
   * recreated stream, as it is assumed that sanitization has already been done.
   *
   * @param original_response_headers Headers used for logging in the access logs and for charging
   * stats. Ignored if null.
   */
  virtual bool recreateStream(const ResponseHeaderMap* original_response_headers) PURE;

  /**
   * Adds socket options to be applied to any connections used for upstream requests. Note that
   * unique values for the options will likely lead to many connection pools being created. The
   * added options are appended to any previously added.
   *
   * @param options The options to be added.
   */
  virtual void addUpstreamSocketOptions(const Network::Socket::OptionsSharedPtr& options) PURE;

  /**
   * @return The socket options to be applied to the upstream request.
   */
  virtual Network::Socket::OptionsSharedPtr getUpstreamSocketOptions() const PURE;

  /**
   * Set override host to be used by the upstream load balancing. If the target host exists in the
   * host list of the routed cluster, the host should be selected first.
   * @param host The override host address.
   */
  virtual void setUpstreamOverrideHost(Upstream::LoadBalancerContext::OverrideHost) PURE;

  /**
   * @return absl::optional<absl::string_view> optional override host for the upstream
   * load balancing.
   */
  virtual absl::optional<Upstream::LoadBalancerContext::OverrideHost>
  upstreamOverrideHost() const PURE;
};

/**
 * Common base class for both decoder and encoder filters. Functions here are related to the
 * lifecycle of a filter. Currently the life cycle is as follows:
 * - All filters receive onStreamComplete()
 * - All log handlers receive final log()
 * - All filters receive onDestroy()
 *
 * This means:
 * - onStreamComplete can be used to make state changes that are intended to appear in the final
 * access logs (like streamInfo().dynamicMetadata() or streamInfo().filterState()).
 * - onDestroy is used to cleanup all pending filter resources like pending http requests and
 * timers.
 */
class StreamFilterBase {
public:
  virtual ~StreamFilterBase() = default;

  /**
   * This routine is called before the access log handlers' final log() is called. Filters can use
   * this callback to enrich the data passed in to the log handlers.
   */
  virtual void onStreamComplete() {}

  /**
   * This routine is called prior to a filter being destroyed. This may happen after normal stream
   * finish (both downstream and upstream) or due to reset. Every filter is responsible for making
   * sure that any async events are cleaned up in the context of this routine. This includes timers,
   * network calls, etc. The reason there is an onDestroy() method vs. doing this type of cleanup
   * in the destructor is due to the deferred deletion model that Envoy uses to avoid stack unwind
   * complications. Filters must not invoke either encoder or decoder filter callbacks after having
   * onDestroy() invoked. Filters that cross-register as access log handlers receive log() before
   * onDestroy().
   */
  virtual void onDestroy() PURE;

  /**
   * Called when a match result occurs that isn't handled by the filter manager.
   * @param action the resulting match action
   */
  virtual void onMatchCallback(const Matcher::Action&) {}

  struct LocalReplyData {
    // The error code which (barring reset) will be sent to the client.
    Http::Code code_;
    // The gRPC status set in local reply.
    absl::optional<Grpc::Status::GrpcStatus> grpc_status_;
    // The details of why a local reply is being sent.
    absl::string_view details_;
    // True if a reset will occur rather than the local reply (some prior filter
    // has returned ContinueAndResetStream)
    bool reset_imminent_;
  };

  /**
   * Called after sendLocalReply is called, and before any local reply is
   * serialized either to filters, or downstream.
   * This will be called on both encoder and decoder filters starting at the
   * terminal filter (generally the router filter) and working towards the first filter configured.
   *
   * Note that in some circumstances, onLocalReply may be called more than once
   * for a given stream, because it is possible that a filter call
   * sendLocalReply while processing the original local reply response.
   *
   * Filters implementing onLocalReply are responsible for never calling sendLocalReply
   * from onLocalReply, as that has the potential for looping.
   *
   * @param data data associated with the sendLocalReply call.
   * @param LocalErrorStatus the action to take after onLocalReply completes.
   */
  virtual LocalErrorStatus onLocalReply(const LocalReplyData&) {
    return LocalErrorStatus::Continue;
  }
};

/**
 * Stream decoder filter interface.
 */
class StreamDecoderFilter : public StreamFilterBase {
public:
  /**
   * Called with decoded headers, optionally indicating end of stream.
   * @param headers supplies the decoded headers map.
   * @param end_stream supplies whether this is a header only request/response.
   * @return FilterHeadersStatus determines how filter chain iteration proceeds.
   */
  virtual FilterHeadersStatus decodeHeaders(RequestHeaderMap& headers, bool end_stream) PURE;

  /**
   * Called with a decoded data frame.
   * @param data supplies the decoded data.
   * @param end_stream supplies whether this is the last data frame.
   * Further note that end_stream is only true if there are no trailers.
   * @return FilterDataStatus determines how filter chain iteration proceeds.
   */
  virtual FilterDataStatus decodeData(Buffer::Instance& data, bool end_stream) PURE;

  /**
   * Called with decoded trailers, implicitly ending the stream.
   * @param trailers supplies the decoded trailers.
   */
  virtual FilterTrailersStatus decodeTrailers(RequestTrailerMap& trailers) PURE;

  /**
   * Called with decoded metadata. Add new metadata to metadata_map directly. Do not call
   * StreamDecoderFilterCallbacks::addDecodedMetadata() to add new metadata.
   *
   * Note: decodeMetadata() currently cannot stop the filter iteration, and always returns Continue.
   * That means metadata will go through the complete filter chain at once, even if the other frame
   * types return StopIteration. If metadata should not pass through all filters at once, users
   * should consider using StopAllIterationAndBuffer or StopAllIterationAndWatermark in
   * decodeHeaders() to prevent metadata passing to the following filters.
   *
   * @param metadata_map supplies the decoded metadata.
   */
  virtual FilterMetadataStatus decodeMetadata(MetadataMap& /* metadata_map */) {
    return Http::FilterMetadataStatus::Continue;
  }

  /**
   * Called by the filter manager once to initialize the filter decoder callbacks that the
   * filter should use. Callbacks will not be invoked by the filter after onDestroy() is called.
   */
  virtual void setDecoderFilterCallbacks(StreamDecoderFilterCallbacks& callbacks) PURE;

  /**
   * Called at the end of the stream, when all data has been decoded.
   */
  virtual void decodeComplete() {}
};

using StreamDecoderFilterSharedPtr = std::shared_ptr<StreamDecoderFilter>;

/**
 * Stream encoder filter callbacks add additional callbacks that allow a encoding filter to restart
 * encoding if they decide to hold data (e.g. for buffering or rate limiting).
 */
class StreamEncoderFilterCallbacks : public virtual StreamFilterCallbacks {
public:
  /**
   * Continue iterating through the filter chain with buffered headers and body data. This routine
   * can only be called if the filter has previously returned StopIteration from encodeHeaders() AND
   * one of StopIterationAndBuffer, StopIterationAndWatermark, or StopIterationNoBuffer
   * from each previous call to encodeData().
   *
   * The connection manager will dispatch headers and any buffered body data to the next filter in
   * the chain. Further note that if the response is not complete, this filter will still receive
   * encodeData() calls and must return an appropriate status code depending on what the filter
   * needs to do.
   */
  virtual void continueEncoding() PURE;

  /**
   * @return const Buffer::Instance* the currently buffered data as buffered by this filter or
   *         previous ones in the filter chain. May be nullptr if nothing has been buffered yet.
   */
  virtual const Buffer::Instance* encodingBuffer() PURE;

  /**
   * Allows modifying the encoding buffer. May only be called before any data has been continued
   * past the calling filter.
   */
  virtual void modifyEncodingBuffer(std::function<void(Buffer::Instance&)> callback) PURE;

  /**
   * Add buffered body data. This method is used in advanced cases where returning
   * StopIterationAndBuffer from encodeData() is not sufficient.
   *
   * 1) If a headers only response needs to be turned into a response with a body, this method can
   * be called to add body in the encodeHeaders() callback. Subsequent filters will receive
   * encodeHeaders(..., false) followed by encodeData(..., true). This works both in the direct
   * iteration as well as the continuation case.
   *
   * 2) If a filter is going to look at all buffered data from within a data callback with end
   * stream set, this method can be called to immediately buffer the data. This avoids having
   * to deal with the existing buffered data and the data from the current callback.
   *
   * 3) If additional buffered body data needs to be added by a filter before continuation of data
   * to further filters (outside of callback context).
   *
   * 4) If additional data needs to be added in the encodeTrailers() callback, this method can be
   * called in the context of the callback. All further filters will receive encodeData(..., false)
   * followed by encodeTrailers(). However if the iteration is stopped, the added data will
   * buffered, so that the further filters will not receive encodeData() before encodeHeaders().
   *
   * It is an error to call this method in any other case.
   *
   * See also injectEncodedDataToFilterChain() for a different way of passing data to further
   * filters and also how the two methods are different.
   *
   * @param data Buffer::Instance supplies the data to be encoded.
   * @param streaming_filter boolean supplies if this filter streams data or buffers the full body.
   */
  virtual void addEncodedData(Buffer::Instance& data, bool streaming_filter) PURE;

  /**
   * Encode data directly to subsequent filters in the filter chain. This method is used in
   * advanced cases in which a filter needs full control over how subsequent filters view data,
   * and does not want to make use of HTTP connection manager buffering. Using this method allows
   * a filter to buffer data (or not) and then periodically inject data to subsequent filters,
   * indicating end_stream at an appropriate time. This can be used to implement rate limiting,
   * periodic data emission, etc.
   *
   * This method should only be called outside of callback context. I.e., do not call this method
   * from within a filter's encodeData() call.
   *
   * When using this callback, filters should generally only return
   * FilterDataStatus::StopIterationNoBuffer from their encodeData() call, since use of this method
   * indicates that a filter does not wish to participate in standard HTTP connection manager
   * buffering and continuation and will perform any necessary buffering and continuation on its
   * own.
   *
   * This callback is different from addEncodedData() in that the specified data and end_stream
   * status will be propagated directly to further filters in the filter chain. This is different
   * from addEncodedData() where data is added to the HTTP connection manager's buffered data with
   * the assumption that standard HTTP connection manager buffering and continuation are being used.
   */
  virtual void injectEncodedDataToFilterChain(Buffer::Instance& data, bool end_stream) PURE;

  /**
   * Adds encoded trailers. May only be called in encodeData when end_stream is set to true.
   * If called in any other context, an assertion will be triggered.
   *
   * When called in encodeData, the trailers map will be initialized to an empty map and returned by
   * reference. Calling this function more than once is invalid.
   *
   * @return a reference to the newly created trailers map.
   */
  virtual ResponseTrailerMap& addEncodedTrailers() PURE;

  /**
   * Attempts to create a locally generated response using the provided response_code and body_text
   * parameters. If the request was a gRPC request the local reply will be encoded as a gRPC
   * response with a 200 HTTP response code and grpc-status and grpc-message headers mapped from the
   * provided parameters.
   *
   * If a response has already started (e.g. if the router calls sendLocalReply after encoding
   * headers) this will either ship the reply directly to the downstream codec, or reset the stream.
   *
   * @param response_code supplies the HTTP response code.
   * @param body_text supplies the optional body text which is sent using the text/plain content
   *                  type, or encoded in the grpc-message header.
   * @param modify_headers supplies an optional callback function that can modify the
   *                       response headers.
   * @param grpc_status the gRPC status code to override the httpToGrpcStatus mapping with.
   * @param details a string detailing why this local reply was sent.
   */
  virtual void sendLocalReply(Code response_code, absl::string_view body_text,
                              std::function<void(ResponseHeaderMap& headers)> modify_headers,
                              const absl::optional<Grpc::Status::GrpcStatus> grpc_status,
                              absl::string_view details) PURE;
  /**
   * Adds new metadata to be encoded.
   *
   * @param metadata_map supplies the unique_ptr of the metadata to be encoded.
   */
  virtual void addEncodedMetadata(MetadataMapPtr&& metadata_map) PURE;

  /**
   * Called when an encoder filter goes over its high watermark.
   */
  virtual void onEncoderFilterAboveWriteBufferHighWatermark() PURE;

  /**
   * Called when a encoder filter goes from over its high watermark to under its low watermark.
   */
  virtual void onEncoderFilterBelowWriteBufferLowWatermark() PURE;

  /**
   * This routine may be called to change the buffer limit for encoder filters.
   *
   * It is recommended (but not required) that filters calling this function should
   * generally only perform increases to the buffer limit, to avoid potentially
   * conflicting with the buffer requirements of other filters in the chain, i.e.
   *
   * if (desired_limit > encoderBufferLimit()) {setEncoderBufferLimit(desired_limit);}
   *
   * @param limit supplies the desired buffer limit.
   */
  virtual void setEncoderBufferLimit(uint32_t limit) PURE;

  /**
   * This routine returns the current buffer limit for encoder filters. Filters should abide by
   * this limit or change it via setEncoderBufferLimit.
   * A buffer limit of 0 bytes indicates no limits are applied.
   *
   * @return the buffer limit the filter should apply.
   */
  virtual uint32_t encoderBufferLimit() PURE;
};

/**
 * Stream encoder filter interface.
 */
class StreamEncoderFilter : public StreamFilterBase {
public:
  /**
   * Called with supported 1xx headers.
   *
   * This is not folded into encodeHeaders because most Envoy users and filters
   * will not be proxying 1xxs and with it split out, can ignore the
   * complexity of multiple encodeHeaders calls.
   *
   * This will only be invoked once per request.
   *
   * @param headers supplies the 1xx response headers to be encoded.
   * @return Filter1xxHeadersStatus determines how filter chain iteration proceeds.
   *
   */
  virtual Filter1xxHeadersStatus encode1xxHeaders(ResponseHeaderMap& headers) PURE;

  /**
   * Called with headers to be encoded, optionally indicating end of stream.
   *
   * The only 1xx that may be provided to encodeHeaders() is a 101 upgrade, which will be the final
   * encodeHeaders() for a response.
   *
   * @param headers supplies the headers to be encoded.
   * @param end_stream supplies whether this is a header only request/response.
   * @return FilterHeadersStatus determines how filter chain iteration proceeds.
   */
  virtual FilterHeadersStatus encodeHeaders(ResponseHeaderMap& headers, bool end_stream) PURE;

  /**
   * Called with data to be encoded, optionally indicating end of stream.
   * @param data supplies the data to be encoded.
   * @param end_stream supplies whether this is the last data frame.
   * Further note that end_stream is only true if there are no trailers.
   * @return FilterDataStatus determines how filter chain iteration proceeds.
   */
  virtual FilterDataStatus encodeData(Buffer::Instance& data, bool end_stream) PURE;

  /**
   * Called with trailers to be encoded, implicitly ending the stream.
   * @param trailers supplies the trailers to be encoded.
   */
  virtual FilterTrailersStatus encodeTrailers(ResponseTrailerMap& trailers) PURE;

  /**
   * Called with metadata to be encoded. New metadata should be added directly to metadata_map. DO
   * NOT call StreamDecoderFilterCallbacks::encodeMetadata() interface to add new metadata.
   *
   * @param metadata_map supplies the metadata to be encoded.
   * @return FilterMetadataStatus, which currently is always FilterMetadataStatus::Continue;
   */
  virtual FilterMetadataStatus encodeMetadata(MetadataMap& metadata_map) PURE;

  /**
   * Called by the filter manager once to initialize the filter callbacks that the filter should
   * use. Callbacks will not be invoked by the filter after onDestroy() is called.
   */
  virtual void setEncoderFilterCallbacks(StreamEncoderFilterCallbacks& callbacks) PURE;

  /**
   * Called at the end of the stream, when all data has been encoded.
   */
  virtual void encodeComplete() {}
};

using StreamEncoderFilterSharedPtr = std::shared_ptr<StreamEncoderFilter>;

/**
 * A filter that handles both encoding and decoding.
 */
class StreamFilter : public virtual StreamDecoderFilter, public virtual StreamEncoderFilter {};

using StreamFilterSharedPtr = std::shared_ptr<StreamFilter>;

class HttpMatchingData {
public:
  static absl::string_view name() { return "http"; }

  virtual ~HttpMatchingData() = default;

  virtual RequestHeaderMapOptConstRef requestHeaders() const PURE;
  virtual RequestTrailerMapOptConstRef requestTrailers() const PURE;
  virtual ResponseHeaderMapOptConstRef responseHeaders() const PURE;
  virtual ResponseTrailerMapOptConstRef responseTrailers() const PURE;
  virtual const StreamInfo::StreamInfo& streamInfo() const PURE;
  virtual const Network::ConnectionInfoProvider& connectionInfoProvider() const PURE;

  const Network::Address::Instance& localAddress() const {
    return *connectionInfoProvider().localAddress();
  }

  const Network::Address::Instance& remoteAddress() const {
    return *connectionInfoProvider().remoteAddress();
  }

  Ssl::ConnectionInfoConstSharedPtr ssl() const { return connectionInfoProvider().sslConnection(); }
};

/**
 * These callbacks are provided by the connection manager to the factory so that the factory can
 * build the filter chain in an application specific way.
 */
class FilterChainFactoryCallbacks {
public:
  virtual ~FilterChainFactoryCallbacks() = default;

  /**
   * Add a decoder filter that is used when reading stream data.
   * @param filter supplies the filter to add.
   */
  virtual void addStreamDecoderFilter(Http::StreamDecoderFilterSharedPtr filter) PURE;

  /**
   * Add an encoder filter that is used when writing stream data.
   * @param filter supplies the filter to add.
   */
  virtual void addStreamEncoderFilter(Http::StreamEncoderFilterSharedPtr filter) PURE;

  /**
   * Add a decoder/encoder filter that is used both when reading and writing stream data.
   * @param filter supplies the filter to add.
   */
  virtual void addStreamFilter(Http::StreamFilterSharedPtr filter) PURE;

  /**
   * Add an access log handler that is called when the stream is destroyed.
   * @param handler supplies the handler to add.
   */
  virtual void addAccessLogHandler(AccessLog::InstanceSharedPtr handler) PURE;

  /**
   * Allows filters to access the thread local dispatcher.
   * @param return the worker thread's dispatcher.
   */
  virtual Event::Dispatcher& dispatcher() PURE;
};
} // namespace Http
} // namespace Envoy
#pragma once

#include <functional>
#include <memory>

#include "envoy/common/conn_pool.h"
#include "envoy/common/pure.h"
#include "envoy/event/deferred_deletable.h"
#include "envoy/http/codec.h"
#include "envoy/upstream/upstream.h"

namespace Envoy {
namespace Http {
namespace ConnectionPool {

using PoolFailureReason = ::Envoy::ConnectionPool::PoolFailureReason;
using Cancellable = ::Envoy::ConnectionPool::Cancellable;

/**
 * Pool callbacks invoked in the context of a newStream() call, either synchronously or
 * asynchronously.
 */
class Callbacks {
public:
  virtual ~Callbacks() = default;

  /**
   * Called when a pool error occurred and no connection could be acquired for making the request.
   * @param reason supplies the failure reason.
   * @param transport_failure_reason supplies the details of the transport failure reason.
   * @param host supplies the description of the host that caused the failure. This may be nullptr
   *             if no host was involved in the failure (for example overflow).
   */
  virtual void onPoolFailure(PoolFailureReason reason, absl::string_view transport_failure_reason,
                             Upstream::HostDescriptionConstSharedPtr host) PURE;

  /**
   * Called when a connection is available to process a request/response.
   * @param encoder supplies the request encoder to use.
   * @param host supplies the description of the host that will carry the request. For logical
   *             connection pools the description may be different each time this is called.
   * @param info supplies the stream info object associated with the upstream L4 connection.
   * @param protocol supplies the protocol associated with the stream, or absl::nullopt for raw TCP.
   */
  virtual void onPoolReady(RequestEncoder& encoder, Upstream::HostDescriptionConstSharedPtr host,
                           StreamInfo::StreamInfo& info,
                           absl::optional<Http::Protocol> protocol) PURE;
};

class Instance;

/**
 * Pool callbacks invoked to track the lifetime of connections in the pool.
 */
class ConnectionLifetimeCallbacks {
public:
  virtual ~ConnectionLifetimeCallbacks() = default;

  /**
   * Called when a connection is open for requests in a pool.
   * @param pool which the connection is associated with.
   * @param hash_key the hash key used for this connection.
   * @param connection newly open connection.
   */
  virtual void onConnectionOpen(Instance& pool, std::vector<uint8_t>& hash_key,
                                const Network::Connection& connection) PURE;

  /**
   * Called when a connection is draining and may no longer be used for requests.
   * @param pool which the connection is associated with.
   * @param hash_key the hash key used for this connection.
   * @param connection newly open connection.
   */
  virtual void onConnectionDraining(Instance& pool, std::vector<uint8_t>& hash_key,
                                    const Network::Connection& connection) PURE;
};

/**
 * An instance of a generic connection pool.
 */
class Instance : public Envoy::ConnectionPool::Instance, public Event::DeferredDeletable {
public:
  struct StreamOptions {
    // True if the request can be sent as early data.
    bool can_send_early_data_;
    // True if the request can be sent over HTTP/3.
    bool can_use_http3_;
  };

  ~Instance() override = default;

  /**
   * Determines whether the connection pool is actively processing any requests.
   * @return true if the connection pool has any pending requests or any active requests.
   */
  virtual bool hasActiveConnections() const PURE;

  /**
   * Create a new stream on the pool.
   * @param response_decoder supplies the decoder events to fire when the response is
   *                         available.
   * @param cb supplies the callbacks to invoke when the connection is ready or has failed. The
   *           callbacks may be invoked immediately within the context of this call if there is a
   *           ready connection or an immediate failure. In this case, the routine returns nullptr.
   * @param options specifies how to create the requested stream.
   * @return Cancellable* If no connection is ready, the callback is not invoked, and a handle
   *                      is returned that can be used to cancel the request. Otherwise, one of the
   *                      callbacks is called and the routine returns nullptr. NOTE: Once a callback
   *                      is called, the handle is no longer valid and any further cancellation
   *                      should be done by resetting the stream.
   * @warning Do not call cancel() from the callbacks, as the request is implicitly canceled when
   *          the callbacks are called.
   */
  virtual Cancellable* newStream(Http::ResponseDecoder& response_decoder, Callbacks& callbacks,
                                 const StreamOptions& options) PURE;

  /**
   * Returns a user-friendly protocol description for logging.
   * @return absl::string_view a protocol description for logging.
   */
  virtual absl::string_view protocolDescription() const PURE;
};

using InstancePtr = std::unique_ptr<Instance>;

} // namespace ConnectionPool
} // namespace Http
} // namespace Envoy
#pragma once

#include <map>
#include <memory>
#include <string>
#include <tuple>
#include <vector>

#include "envoy/common/optref.h"
#include "envoy/common/time.h"
#include "envoy/config/core/v3/protocol.pb.h"
#include "envoy/event/dispatcher.h"

#include "absl/strings/string_view.h"

namespace Envoy {
namespace Http {

/**
 * Tracks information used to make an HTTP connection to an origin server.
 *
 * This includes Alternate protocols, SRTT, Quic brokenness, etc.
 *
 * See https://tools.ietf.org/html/rfc7838 for HTTP Alternative Services and
 * https://datatracker.ietf.org/doc/html/draft-ietf-dnsop-svcb-https-04 for the
 * "HTTPS" DNS resource record.
 */
class HttpServerPropertiesCache {
public:
  /**
   * Represents an HTTP origin to be connected too.
   */
  struct Origin {
  public:
    Origin() = default;
    Origin(const Origin& other) = default;
    Origin(absl::string_view scheme, absl::string_view hostname, uint32_t port)
        : scheme_(scheme), hostname_(hostname), port_(port) {}
    Origin& operator=(const Origin&) = default;

    bool operator==(const Origin& other) const {
      return std::tie(scheme_, hostname_, port_) ==
             std::tie(other.scheme_, other.hostname_, other.port_);
    }

    bool operator!=(const Origin& other) const { return !this->operator==(other); }

    bool operator<(const Origin& other) const {
      return std::tie(scheme_, hostname_, port_) <
             std::tie(other.scheme_, other.hostname_, other.port_);
    }

    bool operator>(const Origin& other) const {
      return std::tie(scheme_, hostname_, port_) >
             std::tie(other.scheme_, other.hostname_, other.port_);
    }

    bool operator<=(const Origin& other) const {
      return std::tie(scheme_, hostname_, port_) <=
             std::tie(other.scheme_, other.hostname_, other.port_);
    }

    bool operator>=(const Origin& other) const {
      return std::tie(scheme_, hostname_, port_) >=
             std::tie(other.scheme_, other.hostname_, other.port_);
    }

    std::string scheme_;
    std::string hostname_;
    uint32_t port_{};
  };

  /**
   * Represents an alternative protocol that can be used to connect to an origin
   * with a specified expiration time.
   */
  struct AlternateProtocol {
  public:
    AlternateProtocol(absl::string_view alpn, absl::string_view hostname, uint32_t port,
                      MonotonicTime expiration)
        : alpn_(alpn), hostname_(hostname), port_(port), expiration_(expiration) {}

    bool operator==(const AlternateProtocol& other) const {
      return std::tie(alpn_, hostname_, port_, expiration_) ==
             std::tie(other.alpn_, other.hostname_, other.port_, other.expiration_);
    }

    bool operator!=(const AlternateProtocol& other) const { return !this->operator==(other); }

    std::string alpn_;
    std::string hostname_;
    uint32_t port_;
    MonotonicTime expiration_;
  };

  class Http3StatusTracker {
  public:
    virtual ~Http3StatusTracker() = default;

    // Returns true if HTTP/3 is broken.
    virtual bool isHttp3Broken() const PURE;
    // Returns true if HTTP/3 is confirmed to be working.
    virtual bool isHttp3Confirmed() const PURE;
    // Returns true if HTTP/3 has failed recently.
    virtual bool hasHttp3FailedRecently() const PURE;
    // Marks HTTP/3 broken for a period of time, subject to backoff.
    virtual void markHttp3Broken() PURE;
    // Marks HTTP/3 as confirmed to be working and resets the backoff timeout.
    virtual void markHttp3Confirmed() PURE;
    // Marks HTTP/3 as failed recently.
    virtual void markHttp3FailedRecently() PURE;
  };

  virtual ~HttpServerPropertiesCache() = default;

  /**
   * Sets the possible alternative protocols which can be used to connect to the
   * specified origin. Expires after the specified expiration time.
   * @param origin The origin to set alternate protocols for.
   * @param protocols A list of alternate protocols. This list may be truncated
   * by the cache.
   */
  virtual void setAlternatives(const Origin& origin,
                               std::vector<AlternateProtocol>& protocols) PURE;

  /**
   * Sets the srtt estimate for an origin.
   * @param origin The origin to set network characteristics for.
   * @param srtt The smothed round trip time for the origin.
   */
  virtual void setSrtt(const Origin& origin, std::chrono::microseconds srtt) PURE;

  /**
   * Returns the srtt estimate for an origin, or zero, if no srtt is cached.
   * @param origin The origin to get network characteristics for.
   */
  virtual std::chrono::microseconds getSrtt(const Origin& origin) const PURE;

  /**
   * Sets the number of concurrent streams allowed by the last connection to this origin.
   * @param origin The origin to set network characteristics for.
   * @param srtt The number of concurrent streams allowed.
   */
  virtual void setConcurrentStreams(const Origin& origin, uint32_t concurrent_streams) PURE;

  /**
   * Returns the number of concurrent streams allowed by the last connection to this origin,
   * or zero if no limit was set.
   * Note that different servers serving a given origin may have different
   * characteristics, so this is a best guess estimate not a guarantee.
   * @param origin The origin to get network characteristics for.
   */
  virtual uint32_t getConcurrentStreams(const Origin& origin) const PURE;

  /**
   * Returns the possible alternative protocols which can be used to connect to the
   * specified origin, or nullptr if not alternatives are found. The returned reference
   * is owned by the HttpServerPropertiesCache and is valid until the next operation on the
   * HttpServerPropertiesCache.
   * @param origin The origin to find alternate protocols for.
   * @return An optional list of alternate protocols for the given origin.
   */
  virtual OptRef<const std::vector<AlternateProtocol>> findAlternatives(const Origin& origin) PURE;

  /**
   * Returns the number of entries in the map.
   * @return the number if entries in the map.
   */
  virtual size_t size() const PURE;

  /**
   * @param origin The origin to get HTTP/3 status tracker for.
   * @return the existing status tracker or creating a new one if there is none.
   */
  virtual HttpServerPropertiesCache::Http3StatusTracker&
  getOrCreateHttp3StatusTracker(const Origin& origin) PURE;
};

using HttpServerPropertiesCacheSharedPtr = std::shared_ptr<HttpServerPropertiesCache>;
using Http3StatusTrackerPtr = std::unique_ptr<HttpServerPropertiesCache::Http3StatusTracker>;

/**
 * A manager for multiple alternate protocols caches.
 */
class HttpServerPropertiesCacheManager {
public:
  virtual ~HttpServerPropertiesCacheManager() = default;

  /**
   * Get an alternate protocols cache.
   * @param config supplies the cache parameters. If a cache exists with the same parameters it
   *               will be returned, otherwise a new one will be created.
   * @param dispatcher supplies the current thread's dispatcher, for cache creation.
   */
  virtual HttpServerPropertiesCacheSharedPtr
  getCache(const envoy::config::core::v3::AlternateProtocolsCacheOptions& config,
           Event::Dispatcher& dispatcher) PURE;
};

using HttpServerPropertiesCacheManagerSharedPtr = std::shared_ptr<HttpServerPropertiesCacheManager>;

/**
 * Factory for getting an alternate protocols cache manager.
 */
class HttpServerPropertiesCacheManagerFactory {
public:
  virtual ~HttpServerPropertiesCacheManagerFactory() = default;

  /**
   * Get the alternate protocols cache manager.
   */
  virtual HttpServerPropertiesCacheManagerSharedPtr get() PURE;
};

} // namespace Http
} // namespace Envoy
#pragma once

#include <memory>
#include <string>

#include "envoy/common/pure.h"
#include "envoy/config/typed_config.h"
#include "envoy/http/header_map.h"
#include "envoy/server/factory_context.h"
#include "envoy/stream_info/stream_info.h"

namespace Envoy {
namespace Http {

/**
 * Interface class for early header mutation extensions.
 */
class EarlyHeaderMutation {
public:
  virtual ~EarlyHeaderMutation() = default;

  /**
   * Mutate the request headers before routing, tracing or any filter processing.
   *
   * @param headers request headers to be mutated.
   * @param stream_info stream info.
   * @return true if the mutation is could be continued for the flollowing extensions.
   * Make no sense if there is no following extensions.
   */
  virtual bool mutate(RequestHeaderMap& headers,
                      const StreamInfo::StreamInfo& stream_info) const PURE;
};

using EarlyHeaderMutationPtr = std::unique_ptr<EarlyHeaderMutation>;

/*
 * A factory for creating early header mutation extensions.
 */
class EarlyHeaderMutationFactory : public Envoy::Config::TypedFactory {
public:
  ~EarlyHeaderMutationFactory() override = default;

  /**
   * Creates a particular extension implementation.
   *
   * @param config supplies the configuration for the early mutation extension.
   * @return EarlyHeaderMutationPtr the extension instance.
   */
  virtual EarlyHeaderMutationPtr
  createExtension(const Protobuf::Message& config,
                  Server::Configuration::FactoryContext& context) PURE;

  std::string category() const override { return "envoy.http.early_header_mutation"; }
};

using EarlyHeaderMutationFactoryPtr = std::unique_ptr<EarlyHeaderMutationFactory>;

} // namespace Http
} // namespace Envoy
#pragma once

#include "envoy/common/pure.h"

// Stream Reset is refactored from the codec to avoid cyclical dependencies with
// the BufferMemoryAccount interface.
namespace Envoy {
namespace Http {

/**
 * Stream reset reasons.
 */
enum class StreamResetReason {
  // If a local codec level reset was sent on the stream.
  LocalReset,
  // If a local codec level refused stream reset was sent on the stream (allowing for retry).
  LocalRefusedStreamReset,
  // If a remote codec level reset was received on the stream.
  RemoteReset,
  // If a remote codec level refused stream reset was received on the stream (allowing for retry).
  RemoteRefusedStreamReset,
  // If the stream was locally reset by a connection pool due to an initial local connection
  // failure.
  LocalConnectionFailure,
  // If the stream was locally reset by a connection pool due to an initial remote connection
  // failure.
  RemoteConnectionFailure,
  // If the stream was reset due to timing out while creating a new connection.
  ConnectionTimeout,
  // If the stream was locally reset due to connection termination.
  ConnectionTermination,
  // The stream was reset because of a resource overflow.
  Overflow,
  // Either there was an early TCP error for a CONNECT request or the peer reset with CONNECT_ERROR
  ConnectError,
  // Received payload did not conform to HTTP protocol.
  ProtocolError,
  // If the stream was locally reset by the Overload Manager.
  OverloadManager
};

/**
 * Handler to reset an underlying HTTP stream.
 */
class StreamResetHandler {
public:
  virtual ~StreamResetHandler() = default;
  /**
   * Reset the stream. No events will fire beyond this point.
   * @param reason supplies the reset reason.
   */
  virtual void resetStream(StreamResetReason reason) PURE;
};

} // namespace Http
} // namespace Envoy
#pragma once

#include <functional>
#include <memory>
#include <string>

#include "envoy/common/pure.h"
#include "envoy/config/typed_config.h"
#include "envoy/registry/registry.h"
#include "envoy/singleton/instance.h"

namespace Envoy {
namespace Singleton {

/**
 * An abstract registration for a singleton entry.
 */
class Registration : public Config::UntypedFactory {
public:
  std::string category() const override { return "envoy.singleton"; }
};

/**
 * A concrete implementation of a singleton registration. All singletons are referenced by name
 * and must be statically registered ahead of time. This can be done like so:
 *
 * static constexpr char foo_singleton_name[] = "foo_singleton";
 * static Registry::RegisterFactory<Singleton::RegistrationImpl<foo_singleton_name>,
 *                                  Singleton::Registration>
 *     date_provider_singleton_registered_;
 *
 * Once this is done, the singleton can be get/set via the manager. See the Manager interface
 * for more information.
 */
template <const char* name_param> class RegistrationImpl : public Registration {
public:
  std::string name() const override { return name_param; }
};

/**
 * Macro used to statically register singletons managed by the singleton manager
 * defined in envoy/singleton/manager.h. After the NAME has been registered use the
 * SINGLETON_MANAGER_REGISTERED_NAME macro to access the name registered with the
 * singleton manager.
 */
#define SINGLETON_MANAGER_REGISTRATION(NAME)                                                       \
  static constexpr char NAME##_singleton_name[] = #NAME "_singleton";                              \
  static Envoy::Registry::RegisterInternalFactory<                                                 \
      Envoy::Singleton::RegistrationImpl<NAME##_singleton_name>, Envoy::Singleton::Registration>   \
      NAME##_singleton_registered_;

#define SINGLETON_MANAGER_REGISTERED_NAME(NAME) NAME##_singleton_name

/**
 * Callback function used to create a singleton.
 */
using SingletonFactoryCb = std::function<InstanceSharedPtr()>;

/**
 * A manager for all server-side singletons.
 */
class Manager {
public:
  virtual ~Manager() = default;

  /**
   * This is a helper on top of get() that casts the object stored to the specified type. Since the
   * manager only stores pointers to the base interface, dynamic_cast provides some level of
   * protection via RTTI.
   * @param name the unique name of the singleton instance. This should be provided by the macro
   * SINGLETON_MANAGER_REGISTERED_NAME.
   * @param cb supplies the singleton creation callback. This will only be called if the singleton
   * does not already exist.
   * @param pin supplies whether the singleton should be pinned. By default, the manager only stores
   * a weak pointer. This allows a singleton to be cleaned up if it is not needed any more. All code
   * that uses singletons must store the shared_ptr for as long as the singleton is needed. But if
   * the pin is set to true, the singleton will be stored as a shared_ptr. This is useful if the
   * users want to keep the singleton around for the lifetime of the server even if it is not used
   * for a while.
   * @return InstancePtr the singleton cast to the specified type. nullptr if the singleton does not
   * exist.
   */
  template <class T>
  std::shared_ptr<T> getTyped(const std::string& name, SingletonFactoryCb cb, bool pin = false) {
    return std::dynamic_pointer_cast<T>(get(name, cb, pin));
  }

  /**
   * This is a non-constructing getter. Use when the caller can deal with instances where
   * the singleton being accessed may not have been constructed previously.
   * @param name the unique name of singleton instance. This should be provided by the macro
   * SINGLETON_MANAGER_REGISTERED_NAME.
   * @return InstancePtr the singleton cast to the specified type. nullptr if the singleton does not
   * exist.
   */
  template <class T> std::shared_ptr<T> getTyped(const std::string& name) {
    return std::dynamic_pointer_cast<T>(get(
        name, [] { return nullptr; }, false));
  }

  /**
   * Get a singleton and create it if it does not exist.
   * @param name the unique name of the singleton instance. This should be provided by the macro
   * SINGLETON_MANAGER_REGISTERED_NAME.
   * @param cb supplies the singleton creation callback. This will only be called if the singleton
   * does not already exist.
   * @param pin supplies whether the singleton should be pinned. By default, the manager only stores
   * a weak pointer. This allows a singleton to be cleaned up if it is not needed any more. All code
   * that uses singletons must store the shared_ptr for as long as the singleton is needed. But if
   * the pin is set to true, the singleton will be stored as a shared_ptr. This is useful if the
   * users want to keep the singleton around for the lifetime of the server even if it is not used
   * for a while.
   * @return InstancePtr the singleton cast to the specified type. nullptr if the singleton does not
   * exist.
   */
  virtual InstanceSharedPtr get(const std::string& name, SingletonFactoryCb cb, bool pin) PURE;
};

using ManagerPtr = std::unique_ptr<Manager>;

} // namespace Singleton
} // namespace Envoy
#pragma once

#include <memory>

namespace Envoy {
namespace Singleton {

/**
 * All singletons must derive from this type.
 */
class Instance {
public:
  virtual ~Instance() = default;
};

using InstanceSharedPtr = std::shared_ptr<Instance>;

} // namespace Singleton
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "instance_interface",
    hdrs = ["instance.h"],
)

envoy_cc_library(
    name = "manager_interface",
    hdrs = ["manager.h"],
    deps = [
        ":instance_interface",
        "//envoy/config:typed_config_interface",
        "//envoy/registry",
    ],
)
#pragma once

#include "envoy/buffer/buffer.h"

namespace Envoy {
namespace Compression {
namespace Decompressor {

/**
 * Allows decompressing data.
 */
class Decompressor {
public:
  virtual ~Decompressor() = default;

  /**
   * Decompresses data from one buffer into another buffer.
   * @param input_buffer supplies the buffer with compressed data.
   * @param output_buffer supplies the buffer to output decompressed data.
   */
  virtual void decompress(const Buffer::Instance& input_buffer,
                          Buffer::Instance& output_buffer) PURE;
};

using DecompressorPtr = std::unique_ptr<Decompressor>;

} // namespace Decompressor
} // namespace Compression
} // namespace Envoy
#pragma once

#include "envoy/compression/decompressor/factory.h"
#include "envoy/config/typed_config.h"
#include "envoy/server/filter_config.h"

namespace Envoy {
namespace Compression {
namespace Decompressor {

class NamedDecompressorLibraryConfigFactory : public Config::TypedFactory {
public:
  ~NamedDecompressorLibraryConfigFactory() override = default;

  virtual DecompressorFactoryPtr
  createDecompressorFactoryFromProto(const Protobuf::Message& config,
                                     Server::Configuration::FactoryContext& context) PURE;

  std::string category() const override { return "envoy.compression.decompressor"; }
};

} // namespace Decompressor
} // namespace Compression
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "decompressor_config_interface",
    hdrs = ["config.h"],
    deps = [
        ":decompressor_factory_interface",
        "//envoy/config:typed_config_interface",
        "//envoy/server:filter_config_interface",
    ],
)

envoy_cc_library(
    name = "decompressor_factory_interface",
    hdrs = ["factory.h"],
    deps = [
        ":decompressor_interface",
    ],
)

envoy_cc_library(
    name = "decompressor_interface",
    hdrs = ["decompressor.h"],
    deps = [
        "//envoy/buffer:buffer_interface",
    ],
)
#pragma once

#include "envoy/compression/decompressor/decompressor.h"

namespace Envoy {
namespace Compression {
namespace Decompressor {

class DecompressorFactory {
public:
  virtual ~DecompressorFactory() = default;

  virtual DecompressorPtr createDecompressor(const std::string& stats_prefix) PURE;
  virtual const std::string& statsPrefix() const PURE;
  // TODO(junr03): this method assumes that decompressors are used on http messages.
  // A more generic method might be `hint()` which gives the user of the decompressor a hint about
  // the type of decompression that it can perform.
  virtual const std::string& contentEncoding() const PURE;
};

using DecompressorFactoryPtr = std::unique_ptr<DecompressorFactory>;

} // namespace Decompressor
} // namespace Compression
} // namespace Envoy
#pragma once

#include "envoy/compression/compressor/factory.h"
#include "envoy/config/typed_config.h"
#include "envoy/server/filter_config.h"

namespace Envoy {
namespace Compression {
namespace Compressor {

class NamedCompressorLibraryConfigFactory : public Config::TypedFactory {
public:
  ~NamedCompressorLibraryConfigFactory() override = default;

  virtual CompressorFactoryPtr
  createCompressorFactoryFromProto(const Protobuf::Message& config,
                                   Server::Configuration::FactoryContext& context) PURE;

  std::string category() const override { return "envoy.compression.compressor"; }
};

} // namespace Compressor
} // namespace Compression
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "compressor_interface",
    hdrs = ["compressor.h"],
    deps = [
        "//envoy/buffer:buffer_interface",
    ],
)

envoy_cc_library(
    name = "compressor_factory_interface",
    hdrs = ["factory.h"],
    deps = [
        ":compressor_interface",
    ],
)

envoy_cc_library(
    name = "compressor_config_interface",
    hdrs = ["config.h"],
    deps = [
        ":compressor_factory_interface",
        "//envoy/config:typed_config_interface",
        "//envoy/server:filter_config_interface",
    ],
)
#pragma once

#include "envoy/buffer/buffer.h"

namespace Envoy {
namespace Compression {
namespace Compressor {

/**
 * Compressor state whether to flush the compressor or to finish the compression stream.
 */
enum class State { Flush, Finish };

/**
 * Allows compressing data.
 */
class Compressor {
public:
  virtual ~Compressor() = default;

  /**
   * Compresses data buffer.
   * @param buffer supplies the reference to data to be compressed. The content of the buffer will
   *        be replaced inline with the compressed data.
   * @param state supplies the compressor state.
   */
  virtual void compress(Buffer::Instance& buffer, State state) PURE;
};

using CompressorPtr = std::unique_ptr<Compressor>;

} // namespace Compressor
} // namespace Compression
} // namespace Envoy
#pragma once

#include "envoy/compression/compressor/compressor.h"

namespace Envoy {
namespace Compression {
namespace Compressor {

class CompressorFactory {
public:
  virtual ~CompressorFactory() = default;

  virtual CompressorPtr createCompressor() PURE;
  virtual const std::string& statsPrefix() const PURE;
  virtual const std::string& contentEncoding() const PURE;
};

using CompressorFactoryPtr = std::unique_ptr<CompressorFactory>;

} // namespace Compressor
} // namespace Compression
} // namespace Envoy
#pragma once

#include <algorithm>
#include <functional>
#include <map>
#include <string>
#include <vector>

#include "envoy/common/exception.h"
#include "envoy/config/core/v3/base.pb.h"

#include "source/common/common/assert.h"
#include "source/common/common/fmt.h"
#include "source/common/common/logger.h"
#include "source/common/common/utility.h"
#include "source/common/protobuf/utility.h"

#include "absl/base/attributes.h"
#include "absl/container/flat_hash_map.h"
#include "absl/strings/str_join.h"
#include "absl/strings/string_view.h"
#include "fmt/ranges.h"

namespace Envoy {
namespace Registry {

template <class Base> class FactoryRegistry;
template <class T, class Base> class RegisterFactory;

/**
 * FactoryRegistryProxy is a proxy object that provides access to the
 * static methods of a strongly-typed factory registry.
 */
class FactoryRegistryProxy {
public:
  virtual ~FactoryRegistryProxy() = default;
  virtual std::vector<absl::string_view> registeredNames() const PURE;
  // Return all registered factory names, including disabled factories.
  virtual std::vector<absl::string_view> allRegisteredNames() const PURE;
  virtual absl::optional<envoy::config::core::v3::BuildVersion>
  getFactoryVersion(absl::string_view name) const PURE;
  virtual bool disableFactory(absl::string_view) PURE;
  virtual bool isFactoryDisabled(absl::string_view) const PURE;
  virtual absl::flat_hash_map<std::string, std::vector<std::string>> registeredTypes() const PURE;
  virtual absl::string_view canonicalFactoryName(absl::string_view) const PURE;
};

template <class Base> class FactoryRegistryProxyImpl : public FactoryRegistryProxy {
public:
  using FactoryRegistry = Envoy::Registry::FactoryRegistry<Base>;

  std::vector<absl::string_view> registeredNames() const override {
    return FactoryRegistry::registeredNames();
  }

  std::vector<absl::string_view> allRegisteredNames() const override {
    return FactoryRegistry::registeredNames(true);
  }

  absl::optional<envoy::config::core::v3::BuildVersion>
  getFactoryVersion(absl::string_view name) const override {
    return FactoryRegistry::getFactoryVersion(name);
  }

  bool disableFactory(absl::string_view name) override {
    return FactoryRegistry::disableFactory(name);
  }

  bool isFactoryDisabled(absl::string_view name) const override {
    return FactoryRegistry::isFactoryDisabled(name);
  }

  absl::flat_hash_map<std::string, std::vector<std::string>> registeredTypes() const override {
    return FactoryRegistry::registeredTypes();
  }

  absl::string_view canonicalFactoryName(absl::string_view name) const override {
    return FactoryRegistry::canonicalFactoryName(name);
  }
};

/**
 * BaseFactoryCategoryRegistry holds the static factory map for
 * FactoryCategoryRegistry, ensuring that friends of that class
 * cannot get non-const access to it.
 */
class BaseFactoryCategoryRegistry {
protected:
  using MapType = absl::flat_hash_map<std::string, FactoryRegistryProxy*>;

  static MapType& factories() {
    static auto* factories = new MapType();
    return *factories;
  }
};

/**
 * FactoryCategoryRegistry registers factory registries by their
 * declared category. The category is exposed by a static category()
 * method on the factory base type.
 *
 * Only RegisterFactory instances are able to register factory registries.
 */
class FactoryCategoryRegistry : public BaseFactoryCategoryRegistry {
public:
  /**
   * @return a read-only reference to the map of registered factory
   * registries.
   */
  static const MapType& registeredFactories() { return factories(); }

  /**
   * @return whether the given category name is already registered.
   */
  static bool isRegistered(absl::string_view category) {
    return factories().find(category) != factories().end();
  }

  static bool disableFactory(absl::string_view category, absl::string_view name) {
    auto registry = factories().find(category);

    if (registry != factories().end()) {
      return registry->second->disableFactory(name);
    }

    return false;
  }

private:
  // Allow RegisterFactory and the test helper InjectFactoryCategory to register a category, but
  // no-one else. This enforces correct use of the registration machinery.
  template <class T, class Base> friend class RegisterFactory;
  template <class Base> friend class InjectFactoryCategory;

  static void registerCategory(const std::string& category, FactoryRegistryProxy* factory_names) {
    auto result = factories().emplace(std::make_pair(category, factory_names));
    RELEASE_ASSERT(result.second == true,
                   fmt::format("Double registration for category: '{}'", category));
  }

  static void deregisterCategoryForTest(const std::string& category) {
    factories().erase(category);
    RELEASE_ASSERT(factories().find(category) == factories().end(),
                   fmt::format("Deregistration for category '{}' failed", category));
  }
};

// Forward declaration of test class for friend declaration below.
template <typename T> class InjectFactory;

/**
 * General registry for implementation factories. The registry is templated by the Base class that a
 * set of factories conforms to.
 *
 * Classes are found by name, so a single name cannot be registered twice for the same Base class.
 * Factories are registered by reference and this reference is expected to be valid through the life
 * of the program. Factories cannot be deregistered.
 * Factories should generally be registered by statically instantiating the RegisterFactory class.
 *
 * Note: This class is not thread safe, so registration should only occur in a single threaded
 * environment, which is guaranteed by the static instantiation mentioned above.
 *
 * Example lookup: BaseFactoryType *factory =
 * FactoryRegistry<BaseFactoryType>::getFactory("example_factory_name");
 */
template <class Base> class FactoryRegistry : public Logger::Loggable<Logger::Id::config> {
public:
  /**
   * Return a sorted vector of registered factory names.
   */
  static std::vector<absl::string_view> registeredNames(bool include_disabled = false) {
    std::vector<absl::string_view> ret;

    ret.reserve(factories().size());

    for (const auto& [factory_name, factory] : factories()) {
      if (factory || include_disabled) {
        ret.push_back(factory_name);
      }
    }

    std::sort(ret.begin(), ret.end());

    return ret;
  }

  /**
   * Gets the current map of factory implementations.
   */
  static absl::flat_hash_map<std::string, Base*>& factories() {
    static auto* factories = new absl::flat_hash_map<std::string, Base*>;
    return *factories;
  }

  /**
   * Gets the current map of vendor specific factory versions.
   */
  static absl::flat_hash_map<std::string, envoy::config::core::v3::BuildVersion>&
  versionedFactories() {
    using VersionedFactoryMap =
        absl::flat_hash_map<std::string, envoy::config::core::v3::BuildVersion>;
    MUTABLE_CONSTRUCT_ON_FIRST_USE(VersionedFactoryMap);
  }

  static absl::flat_hash_map<std::string, std::string>& deprecatedFactoryNames() {
    static auto* deprecated_factory_names = new absl::flat_hash_map<std::string, std::string>;
    return *deprecated_factory_names;
  }

  /**
   * Lazily constructs a mapping from the configuration message type to a factory,
   * including the deprecated configuration message types.
   * Must be invoked after factory registration is completed.
   */
  static absl::flat_hash_map<std::string, Base*>& factoriesByType() {
    static absl::flat_hash_map<std::string, Base*>* factories_by_type =
        buildFactoriesByType().release();

    return *factories_by_type;
  }

  /**
   * instead_value are used when passed name was deprecated.
   */
  static void registerFactory(Base& factory, absl::string_view name,
                              absl::string_view instead_value = "") {
    auto result = factories().emplace(std::make_pair(name, &factory));
    if (!result.second) {
      ExceptionUtil::throwEnvoyException(
          fmt::format("Double registration for name: '{}'", factory.name()));
    }

    if (!instead_value.empty()) {
      deprecatedFactoryNames().emplace(std::make_pair(name, instead_value));
    }
  }

  /**
   * version is used for registering vendor specific factories that are versioned
   * independently of Envoy.
   */
  static void registerFactory(Base& factory, absl::string_view name,
                              const envoy::config::core::v3::BuildVersion& version,
                              absl::string_view instead_value = "") {
    auto result = factories().emplace(std::make_pair(name, &factory));
    if (!result.second) {
      ExceptionUtil::throwEnvoyException(
          fmt::format("Double registration for name: '{}'", factory.name()));
    }
    versionedFactories().emplace(std::make_pair(name, version));
    if (!instead_value.empty()) {
      deprecatedFactoryNames().emplace(std::make_pair(name, instead_value));
    }
  }

  /**
   * Permanently disables the named factory by setting the corresponding
   * factory pointer to null. If the factory is registered under multiple
   * (deprecated) names, all the possible names are disabled.
   */
  static bool disableFactory(absl::string_view name) {
    const auto disable = [](absl::string_view name) -> bool {
      auto it = factories().find(name);
      if (it != factories().end()) {
        it->second = nullptr;
        return true;
      }
      return false;
    };

    // First, find the canonical name for this factory.
    absl::string_view canonicalName = canonicalFactoryName(name);

    // Next, disable the factory by all its deprecated names.
    for (const auto& [deprecated_name, mapped_canonical_name] : deprecatedFactoryNames()) {
      if (mapped_canonical_name == canonicalName) {
        disable(deprecated_name);
      }
    }

    // Finally, disable the factory by its canonical name.
    return disable(canonicalName);
  }

  /**
   * Gets a factory by name. If the name isn't found in the registry, returns nullptr.
   */
  static Base* getFactory(absl::string_view name) {
    auto it = factories().find(name);
    if (it == factories().end()) {
      return nullptr;
    }

    return it->second;
  }

  static Base* getFactoryByType(absl::string_view type) {
    auto it = factoriesByType().find(type);
    if (it == factoriesByType().end()) {
      return nullptr;
    }
    return it->second;
  }

  /**
   * @return the canonical name of the factory. If the given name is a
   * deprecated factory name, the canonical name is returned instead.
   */
  static absl::string_view canonicalFactoryName(absl::string_view name) {
    const auto it = deprecatedFactoryNames().find(name);
    return (it == deprecatedFactoryNames().end()) ? name : it->second;
  }

  /**
   * @return true if the named factory was disabled.
   */
  static bool isFactoryDisabled(absl::string_view name) {
    auto it = factories().find(name);
    ASSERT(it != factories().end());
    return it->second == nullptr;
  }

  /**
   * @return vendor specific version of a factory.
   */
  static absl::optional<envoy::config::core::v3::BuildVersion>
  getFactoryVersion(absl::string_view name) {
    auto it = versionedFactories().find(name);
    if (it == versionedFactories().end()) {
      return absl::nullopt;
    }
    return it->second;
  }

  /**
   * @return set of config type names indexed by the factory name.
   */
  static absl::flat_hash_map<std::string, std::vector<std::string>> registeredTypes() {
    absl::flat_hash_map<std::string, std::vector<std::string>> mapping;
    for (const auto& [config_type, factory] : factoriesByType()) {
      mapping[factory->name()].push_back(config_type);
    }
    return mapping;
  }

private:
  // Allow factory injection only in tests.
  friend class InjectFactory<Base>;

  static std::unique_ptr<absl::flat_hash_map<std::string, Base*>> buildFactoriesByType() {
    auto mapping = std::make_unique<absl::flat_hash_map<std::string, Base*>>();

    for (const auto& [factory_name, factory] : factories()) {
      UNREFERENCED_PARAMETER(factory_name);
      if (factory == nullptr) {
        continue;
      }

      for (const auto& config_type : factory->configTypes()) {
        ASSERT(!config_type.empty(), "Extension config types can never be empty string");

        // Register config types in the mapping.
        auto it = mapping->find(config_type);
        if (it != mapping->end() && it->second != factory) {
          // Mark double-registered types with a nullptr for tests only.
          // See issue https://github.com/envoyproxy/envoy/issues/9643.
          RELEASE_ASSERT(false, fmt::format("Double registration for type: '{}' by '{}' and '{}'",
                                            config_type, factory->name(),
                                            it->second ? it->second->name() : ""));
          it->second = nullptr;
        } else {
          mapping->emplace(std::make_pair(config_type, factory));
        }
      }
    }

    return mapping;
  }

  // Rebuild the factories-by-type map based on the current factories.
  static void rebuildFactoriesByTypeForTest() {
    auto& mapping = factoriesByType();
    auto updated_mapping = buildFactoriesByType();

    // Copy the updated mapping over the old one.
    mapping = *updated_mapping;
  }

  /**
   * Replaces a factory by name. This method should only be used for testing purposes.
   * @param factory is the factory to inject.
   * @param deprecated_names install the given deprecated names for this factory.
   * @return std::function<void()> a function that will restore the previously registered factories
   *         (by name or type).
   */
  static std::function<void()>
  replaceFactoryForTest(Base& factory,
                        std::initializer_list<absl::string_view> deprecated_names = {}) {
    using DeprecatedNamesVector = std::vector<std::pair<std::string, std::string>>;

    // If an existing factory is registered with this name, track it for later restoration.
    Base* prev_by_name = nullptr;
    auto it = factories().find(factory.name());
    if (it != factories().end()) {
      prev_by_name = it->second;
      factories().erase(it);

      ENVOY_LOG(
          info, "Factory '{}' (type '{}') displaced-by-name with test factory '{}' (type '{}')",
          prev_by_name->name(), prev_by_name->configTypes(), factory.name(), factory.configTypes());
    } else {
      ENVOY_LOG(info, "Factory '{}' (type '{}') registered for tests", factory.name(),
                factory.configTypes());
    }

    factories().emplace(factory.name(), &factory);
    RELEASE_ASSERT(getFactory(factory.name()) == &factory,
                   "test factory by-name registration failed");

    DeprecatedNamesVector prev_deprecated_names;
    if (deprecated_names.size() > 0) {
      for (auto deprecated_name : deprecated_names) {
        auto it = deprecatedFactoryNames().find(deprecated_name);
        if (it != deprecatedFactoryNames().end()) {
          prev_deprecated_names.emplace_back(std::make_pair(it->first, it->second));
          deprecatedFactoryNames().erase(it);

          ENVOY_LOG(
              info,
              "Deprecated name '{}' (mapped to '{}') displaced with test factory '{}' (type '{}')",
              it->first, it->second, factory.name(), factory.configTypes());
        } else {
          // Name not previously mapped, remember to remove it.
          prev_deprecated_names.emplace_back(std::make_pair(deprecated_name, ""));

          ENVOY_LOG(info, "Deprecated name '{}' (mapped to '{}')", deprecated_name, factory.name());
        }

        // Register the replacement factory with a deprecated name.
        factories().emplace(deprecated_name, &factory);
        RELEASE_ASSERT(getFactory(deprecated_name) == &factory,
                       "test factory registration by deprecated name failed");

        // Register the replacement factory's deprecated name.
        deprecatedFactoryNames().emplace(std::make_pair(deprecated_name, factory.name()));
      }
    }

    rebuildFactoriesByTypeForTest();

    return [replacement = &factory, prev_by_name, prev_deprecated_names]() {
      // Unregister the replacement factory by name.
      factories().erase(replacement->name());

      ENVOY_LOG(info, "Removed test factory '{}' (type '{}')", replacement->name(),
                replacement->configTypes());

      if (prev_by_name) {
        // Restore any factory displaced by name, but only register the type if it's non-empty.
        factories().emplace(prev_by_name->name(), prev_by_name);

        ENVOY_LOG(info, "Restored factory '{}' (type '{}'), formerly displaced-by-name",
                  prev_by_name->name(), prev_by_name->configTypes());
      }

      for (auto [prev_deprecated_name, mapped_canonical_name] : prev_deprecated_names) {
        deprecatedFactoryNames().erase(prev_deprecated_name);

        ENVOY_LOG(info, "Removed deprecated name '{}'", prev_deprecated_name);

        if (!mapped_canonical_name.empty()) {
          deprecatedFactoryNames().emplace(
              std::make_pair(prev_deprecated_name, mapped_canonical_name));

          auto* deprecated_factory = getFactory(mapped_canonical_name);
          RELEASE_ASSERT(deprecated_factory != nullptr,
                         "failed to restore deprecated factory name");
          factories().emplace(mapped_canonical_name, deprecated_factory);

          ENVOY_LOG(info, "Restored deprecated name '{}' (mapped to '{}'", prev_deprecated_name,
                    mapped_canonical_name);
        }
      }

      rebuildFactoriesByTypeForTest();
    };
  }
};

/**
 * Factory registration template. Enables users to register a particular implementation factory with
 * the FactoryRegistry by instantiating this templated class with the specific factory class and the
 * general Base class to which that factory conforms.
 *
 * Because factories are generally registered once and live for the length of the program, the
 * standard use of this class is static instantiation within a linked implementation's translation
 * unit. For an example of a typical use case, @see NamedNetworkFilterConfigFactory.
 *
 * Example registration: REGISTER_FACTORY(SpecificFactory, BaseFactory);
 *                       LEGACY_REGISTER_FACTORY(SpecificFactory, BaseFactory, "deprecated_name");
 */
template <class T, class Base> class RegisterFactory {
public:
  /**
   * Constructor that registers an instance of the factory with the FactoryRegistry.
   */
  RegisterFactory() {
    ASSERT(!instance_.name().empty());
    FactoryRegistry<Base>::registerFactory(instance_, instance_.name());

    // Also register this factory with its category.
    //
    // Each time a factory registers, the registry will attempt to
    // register its category here. This means that we have to ignore
    // multiple attempts to register the same category and can't detect
    // duplicate categories.
    if (!FactoryCategoryRegistry::isRegistered(instance_.category())) {
      FactoryCategoryRegistry::registerCategory(instance_.category(),
                                                new FactoryRegistryProxyImpl<Base>());
    }
  }

  /**
   * Constructor that registers an instance of the factory with the FactoryRegistry along with
   * deprecated names.
   */
  explicit RegisterFactory(std::initializer_list<absl::string_view> deprecated_names) {
    if (!instance_.name().empty()) {
      FactoryRegistry<Base>::registerFactory(instance_, instance_.name());
    } else {
      ASSERT(deprecated_names.size() != 0,
             "Attempted to register a factory without a name or deprecated name");
    }

    for (auto deprecated_name : deprecated_names) {
      ASSERT(!deprecated_name.empty());
      FactoryRegistry<Base>::registerFactory(instance_, deprecated_name, instance_.name());
    }

    if (!FactoryCategoryRegistry::isRegistered(instance_.category())) {
      FactoryCategoryRegistry::registerCategory(instance_.category(),
                                                new FactoryRegistryProxyImpl<Base>());
    }
  }

  /**
   * Constructor that registers an instance of the factory with the FactoryRegistry along with
   * vendor specific version.
   */
  RegisterFactory(uint32_t major, uint32_t minor, uint32_t patch,
                  const std::map<std::string, std::string>& version_metadata)
      : RegisterFactory(major, minor, patch, version_metadata, {}) {}

  /**
   * Constructor that registers an instance of the factory with the FactoryRegistry along with
   * vendor specific version and deprecated names.
   */
  RegisterFactory(uint32_t major, uint32_t minor, uint32_t patch,
                  const std::map<std::string, std::string>& version_metadata,
                  std::initializer_list<absl::string_view> deprecated_names) {
    auto version = makeBuildVersion(major, minor, patch, version_metadata);
    if (instance_.name().empty()) {
      ASSERT(deprecated_names.size() != 0);
    } else {
      FactoryRegistry<Base>::registerFactory(instance_, instance_.name(), version);
    }

    for (auto deprecated_name : deprecated_names) {
      ASSERT(!deprecated_name.empty());
      FactoryRegistry<Base>::registerFactory(instance_, deprecated_name, version, instance_.name());
    }

    if (!FactoryCategoryRegistry::isRegistered(instance_.category())) {
      FactoryCategoryRegistry::registerCategory(instance_.category(),
                                                new FactoryRegistryProxyImpl<Base>());
    }
  }

private:
  static envoy::config::core::v3::BuildVersion
  makeBuildVersion(uint32_t major, uint32_t minor, uint32_t patch,
                   const std::map<std::string, std::string>& metadata) {
    envoy::config::core::v3::BuildVersion version;
    version.mutable_version()->set_major_number(major);
    version.mutable_version()->set_minor_number(minor);
    version.mutable_version()->set_patch(patch);
    *version.mutable_metadata() = MessageUtil::keyValueStruct(metadata);
    return version;
  }

  T instance_{};
};

/**
 * RegisterInternalFactory is a special case for registering factories
 * that are considered internal implementation details that should
 * not be exposed to operators via the factory categories.
 *
 * There is no corresponding REGISTER_INTERNAL_FACTORY because
 * this should be used sparingly and only in special cases.
 */
template <class T, class Base> class RegisterInternalFactory {
public:
  RegisterInternalFactory() {
    ASSERT(!instance_.name().empty());
    FactoryRegistry<Base>::registerFactory(instance_, instance_.name());
  }

private:
  T instance_{};
};

#ifdef ENVOY_STATIC_EXTENSION_REGISTRATION
/**
 * Macro used for static registration.
 */
#define REGISTER_FACTORY(FACTORY, BASE)                                                            \
  ABSL_ATTRIBUTE_UNUSED void forceRegister##FACTORY() {}                                           \
  static Envoy::Registry::RegisterFactory</* NOLINT(fuchsia-statically-constructed-objects) */     \
                                          FACTORY, BASE>                                           \
      FACTORY##_registered
/**
 * Macro used for static registration with deprecated name.
 */
#define LEGACY_REGISTER_FACTORY(FACTORY, BASE, DEPRECATED_NAME)                                    \
  ABSL_ATTRIBUTE_UNUSED void forceRegister##FACTORY() {}                                           \
  static Envoy::Registry::RegisterFactory</* NOLINT(fuchsia-statically-constructed-objects) */     \
                                          FACTORY, BASE>                                           \
      FACTORY##_registered {                                                                       \
    DEPRECATED_NAME                                                                                \
  }
#else
/**
 * Macro used to define a registration function.
 */
#define REGISTER_FACTORY(FACTORY, BASE)                                                            \
  ABSL_ATTRIBUTE_UNUSED void forceRegister##FACTORY() {                                            \
    ABSL_ATTRIBUTE_UNUSED static auto registered =                                                 \
        new Envoy::Registry::RegisterFactory<FACTORY, BASE>();                                     \
  }
/**
 * Macro used to define a registration function with deprecated name.
 */
#define LEGACY_REGISTER_FACTORY(FACTORY, BASE, DEPRECATED_NAME)                                    \
  ABSL_ATTRIBUTE_UNUSED void forceRegister##FACTORY() {                                            \
    ABSL_ATTRIBUTE_UNUSED static auto registered =                                                 \
        new Envoy::Registry::RegisterFactory<FACTORY, BASE>({DEPRECATED_NAME});                    \
  }
#endif

#define FACTORY_VERSION(major, minor, patch, ...) major, minor, patch, __VA_ARGS__

/**
 * Macro used for static registration declaration.
 * Calling forceRegister...(); can be used to force the static factory initializer to run in a
 * setting in which Envoy is bundled as a static archive. In this case, the static initializer is
 * not run until a function in the compilation unit is invoked. The force function can be invoked
 * from a static library wrapper.
 */
#define DECLARE_FACTORY(FACTORY) ABSL_ATTRIBUTE_UNUSED void forceRegister##FACTORY()

} // namespace Registry
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "registry",
    hdrs = ["registry.h"],
    deps = [
        "//source/common/common:assert_lib",
        "//source/common/common:minimal_logger_lib",
        "//source/common/protobuf:utility_lib",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)
#pragma once

#include <memory>
#include <string>

#include "envoy/common/platform.h"

namespace Envoy {
namespace Api {
/**
 * SysCallResult holds the rc and errno values resulting from a system call.
 */
template <typename T> struct SysCallResult {

  /**
   * The return code from the system call.
   */
  T return_value_;

  /**
   * The errno value as captured after the system call.
   */
  int errno_;
};

using SysCallIntResult = SysCallResult<int>;
using SysCallSizeResult = SysCallResult<ssize_t>;
using SysCallPtrResult = SysCallResult<void*>;
using SysCallStringResult = SysCallResult<std::string>;
using SysCallBoolResult = SysCallResult<bool>;
using SysCallSocketResult = SysCallResult<os_fd_t>;

} // namespace Api
} // namespace Envoy
#pragma once

#include <memory>
#include <string>

#include "envoy/common/random_generator.h"
#include "envoy/common/time.h"
#include "envoy/config/bootstrap/v3/bootstrap.pb.h"
#include "envoy/event/dispatcher.h"
#include "envoy/event/scaled_range_timer_manager.h"
#include "envoy/filesystem/filesystem.h"
#include "envoy/server/process_context.h"
#include "envoy/stats/custom_stat_namespaces.h"
#include "envoy/stats/store.h"
#include "envoy/thread/thread.h"

namespace Envoy {
namespace Api {

/**
 * "Public" API that different components use to interact with the various system abstractions.
 */
class Api {
public:
  virtual ~Api() = default;

  /**
   * Allocate a dispatcher.
   * @param name the identity name for a dispatcher, e.g. "worker_2" or "main_thread".
   *             This name will appear in per-handler/worker statistics, such as
   *             "server.worker_2.watchdog_miss".
   * @return Event::DispatcherPtr which is owned by the caller.
   */
  virtual Event::DispatcherPtr allocateDispatcher(const std::string& name) PURE;

  /**
   * Allocate a dispatcher.
   * @param name the identity name for a dispatcher, e.g. "worker_2" or "main_thread".
   *             This name will appear in per-handler/worker statistics, such as
   *             "server.worker_2.watchdog_miss".
   * @param scaled_timer_factory the factory to use when creating the scaled timer manager.
   * @return Event::DispatcherPtr which is owned by the caller.
   */
  virtual Event::DispatcherPtr
  allocateDispatcher(const std::string& name,
                     const Event::ScaledRangeTimerManagerFactory& scaled_timer_factory) PURE;

  /**
   * Allocate a dispatcher.
   * @param name the identity name for a dispatcher, e.g. "worker_2" or "main_thread".
   *             This name will appear in per-handler/worker statistics, such as
   *             "server.worker_2.watchdog_miss".
   * @param watermark_factory the watermark factory, ownership is transferred to the dispatcher.
   * @return Event::DispatcherPtr which is owned by the caller.
   */
  virtual Event::DispatcherPtr
  allocateDispatcher(const std::string& name, Buffer::WatermarkFactoryPtr&& watermark_factory) PURE;

  /**
   * @return a reference to the ThreadFactory
   */
  virtual Thread::ThreadFactory& threadFactory() PURE;

  /**
   * @return a reference to the Filesystem::Instance
   */
  virtual Filesystem::Instance& fileSystem() PURE;

  /**
   * @return a reference to the TimeSource
   */
  virtual TimeSource& timeSource() PURE;

  /**
   * @return a reference to the root Stats::Scope
   */
  virtual Stats::Scope& rootScope() PURE;

  /**
   * @return a reference to the RandomGenerator.
   */
  virtual Random::RandomGenerator& randomGenerator() PURE;

  /**
   * @return an optional reference to the ProcessContext
   */
  virtual ProcessContextOptRef processContext() PURE;

  /**
   * @return the bootstrap Envoy started with.
   */
  virtual const envoy::config::bootstrap::v3::Bootstrap& bootstrap() const PURE;

  /**
   * @return a reference to the Stats::CustomStatNamespaces.
   */
  virtual Stats::CustomStatNamespaces& customStatNamespaces() PURE;
};

using ApiPtr = std::unique_ptr<Api>;

} // namespace Api
} // namespace Envoy
#pragma once

#if !defined(__linux__)
#error "Linux platform file is part of non-Linux build."
#endif

#include <sched.h>

#include "envoy/api/os_sys_calls_common.h"
#include "envoy/common/pure.h"

namespace Envoy {
namespace Api {

class LinuxOsSysCalls {
public:
  virtual ~LinuxOsSysCalls() = default;

  /**
   * @see sched_getaffinity (man 2 sched_getaffinity)
   */
  virtual SysCallIntResult sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t* mask) PURE;
};

using LinuxOsSysCallsPtr = std::unique_ptr<LinuxOsSysCalls>;

} // namespace Api
} // namespace Envoy
#pragma once

#include <memory>
#include <string>

#include "envoy/common/platform.h"
#include "envoy/common/pure.h"

namespace Envoy {
namespace Api {

class IoError;

using IoErrorDeleterType = void (*)(IoError*);
using IoErrorPtr = std::unique_ptr<IoError, IoErrorDeleterType>;

/**
 * Base class for any I/O error.
 */
class IoError {
public:
  enum class IoErrorCode {
    // No data available right now, try again later.
    Again,
    // Not supported.
    NoSupport,
    // Address family not supported.
    AddressFamilyNoSupport,
    // During non-blocking connect, the connection cannot be completed immediately.
    InProgress,
    // Permission denied.
    Permission,
    // Message too big to send.
    MessageTooBig,
    // Kernel interrupt.
    Interrupt,
    // Requested a nonexistent interface or a non-local source address.
    AddressNotAvailable,
    // Bad file descriptor.
    BadFd,
    // An existing connection was forcibly closed by the remote host.
    ConnectionReset,
    // Network is unreachable due to network settings.
    NetworkUnreachable,
    // Invalid arguments passed in.
    InvalidArgument,
    // Other error codes cannot be mapped to any one above in getErrorCode().
    UnknownError
  };
  virtual ~IoError() = default;

  virtual IoErrorCode getErrorCode() const PURE;
  virtual std::string getErrorDetails() const PURE;
  virtual int getSystemErrorCode() const PURE;

  // Wrap an IoError* in unique_ptr with custom deleter that doesn't delete.
  static IoErrorPtr reusedStatic(IoError* err) {
    return {err, [](IoError*) {}};
  }
  // Wrap an IoError* in unique_ptr with custom deleter.
  static IoErrorPtr wrap(IoError* err) {
    return {err, [](IoError* err) { delete err; }};
  }
  // Use this non-error for the success case.
  static IoErrorPtr none() {
    return {nullptr, [](IoError*) {}};
  }
};

/**
 * Basic type for return result which has a return code and error code defined
 * according to different implementations.
 * If the call succeeds, ok() should return true and |return_value_| is valid. Otherwise |err_|
 * can be passed into IoError::getErrorCode() to extract the error. In this
 * case, |return_value_| is invalid.
 */
template <typename ReturnValue> struct IoCallResult {
  IoCallResult(ReturnValue return_value, IoErrorPtr err)
      : return_value_(return_value), err_(std::move(err)) {}

  IoCallResult(IoCallResult<ReturnValue>&& result) noexcept
      : return_value_(std::move(result.return_value_)), err_(std::move(result.err_)) {}

  virtual ~IoCallResult() = default;

  IoCallResult& operator=(IoCallResult&& result) noexcept {
    return_value_ = result.return_value_;
    err_ = std::move(result.err_);
    return *this;
  }

  /**
   * @return true if the call succeeds.
   */
  bool ok() const { return err_ == nullptr; }

  /**
   * This return code is frequent enough that we have a separate function to check.
   * @return true if the system call failed because the socket would block.
   */
  bool wouldBlock() const { return !ok() && err_->getErrorCode() == IoError::IoErrorCode::Again; }

  ReturnValue return_value_;
  IoErrorPtr err_;
};

using IoCallBoolResult = IoCallResult<bool>;
using IoCallSizeResult = IoCallResult<ssize_t>;
using IoCallUint64Result = IoCallResult<uint64_t>;

inline Api::IoCallUint64Result ioCallUint64ResultNoError() {
  return {0, IoErrorPtr(nullptr, [](IoError*) {})};
}

} // namespace Api
} // namespace Envoy
#pragma once

#ifndef WIN32
#include <sys/mman.h> // for mode_t

#endif

#include "envoy/api/os_sys_calls_common.h"
#include "envoy/common/pure.h"

namespace Envoy {
namespace Api {

class HotRestartOsSysCalls {
public:
  virtual ~HotRestartOsSysCalls() = default;

  /**
   * @see shm_open (man 3 shm_open)
   */
  virtual SysCallIntResult shmOpen(const char* name, int oflag, mode_t mode) PURE;

  /**
   * @see shm_unlink (man 3 shm_unlink)
   */
  virtual SysCallIntResult shmUnlink(const char* name) PURE;
};

using HotRestartOsSysCallsPtr = std::unique_ptr<HotRestartOsSysCalls>;

} // namespace Api
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "api_interface",
    hdrs = ["api.h"],
    deps = [
        "//envoy/common:random_generator_interface",
        "//envoy/event:dispatcher_interface",
        "//envoy/event:scaled_range_timer_manager_interface",
        "//envoy/filesystem:filesystem_interface",
        "//envoy/server:process_context_interface",
        "//envoy/stats:custom_stat_namespaces_interface",
        "//envoy/thread:thread_interface",
        "@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "io_error_interface",
    hdrs = ["io_error.h"],
)

envoy_cc_library(
    name = "os_sys_calls_interface",
    hdrs = [
        "os_sys_calls.h",
        "os_sys_calls_common.h",
        "os_sys_calls_hot_restart.h",
        "os_sys_calls_linux.h",
    ],
    external_deps = ["abseil_optional"],
    deps = [
        "//envoy/network:address_interface",
    ],
)
#pragma once

#include <sys/stat.h>

#include <chrono>
#include <memory>
#include <string>
#include <vector>

#include "envoy/api/os_sys_calls_common.h"
#include "envoy/common/platform.h"
#include "envoy/common/pure.h"
#include "envoy/network/address.h"

#include "absl/types/optional.h"

namespace Envoy {
namespace Api {

struct EnvoyTcpInfo {
  std::chrono::microseconds tcpi_rtt;
  // Congestion window, in bytes. Note that posix's TCP_INFO socket option returns cwnd in packets,
  // we multiply it by MSS to get bytes.
  uint32_t tcpi_snd_cwnd = 0;
};

// Small struct to avoid exposing ifaddrs -- which is not defined in all platforms -- to the
// codebase.
struct InterfaceAddress {
  InterfaceAddress(absl::string_view interface_name, unsigned int interface_flags,
                   Envoy::Network::Address::InstanceConstSharedPtr interface_addr)
      : interface_name_(interface_name), interface_flags_(interface_flags),
        interface_addr_(interface_addr) {}

  std::string interface_name_;
  unsigned int interface_flags_;
  Envoy::Network::Address::InstanceConstSharedPtr interface_addr_;
};

using InterfaceAddressVector = std::vector<InterfaceAddress>;

class OsSysCalls {
public:
  virtual ~OsSysCalls() = default;

  /**
   * @see bind (man 2 bind)
   */
  virtual SysCallIntResult bind(os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) PURE;

  /**
   * @see chmod (man 2 chmod)
   */
  virtual SysCallIntResult chmod(const std::string& path, mode_t mode) PURE;

  /**
   * This interface is based on Windows `WSAIoctl`. It becomes equivalent with the POSIX interface
   * with `in_buffer` as `argp` and the rest of the parameters ignored.
   * @see ioctl (man 2 ioctl)
   * @see WSAIoctl (MSDN)
   */
  virtual SysCallIntResult ioctl(os_fd_t sockfd, unsigned long control_code, void* in_buffer,
                                 unsigned long in_buffer_len, void* out_buffer,
                                 unsigned long out_buffer_len, unsigned long* bytes_returned) PURE;

  /**
   * @see writev (man 2 writev)
   */
  virtual SysCallSizeResult writev(os_fd_t fd, const iovec* iov, int num_iov) PURE;

  /**
   * @see readv (man 2 readv)
   */
  virtual SysCallSizeResult readv(os_fd_t fd, const iovec* iov, int num_iov) PURE;

  /**
   * @see man 2 pwrite
   */
  virtual SysCallSizeResult pwrite(os_fd_t fd, const void* buffer, size_t length,
                                   off_t offset) const PURE;

  /**
   * @see man 2 pread
   */
  virtual SysCallSizeResult pread(os_fd_t fd, void* buffer, size_t length, off_t offset) const PURE;

  /**
   * @see send (man 2 send)
   */
  virtual SysCallSizeResult send(os_fd_t socket, void* buffer, size_t length, int flags) PURE;

  /**
   * @see recv (man 2 recv)
   */
  virtual SysCallSizeResult recv(os_fd_t socket, void* buffer, size_t length, int flags) PURE;

  /**
   * @see recvmsg (man 2 recvmsg)
   */
  virtual SysCallSizeResult recvmsg(os_fd_t sockfd, msghdr* msg, int flags) PURE;

  /**
   * @see recvmmsg (man 2 recvmmsg)
   */
  virtual SysCallIntResult recvmmsg(os_fd_t sockfd, struct mmsghdr* msgvec, unsigned int vlen,
                                    int flags, struct timespec* timeout) PURE;

  /**
   * return true if the OS supports recvmmsg() and sendmmsg().
   */
  virtual bool supportsMmsg() const PURE;

  /**
   * return true if the OS supports UDP GRO.
   */
  virtual bool supportsUdpGro() const PURE;

  /**
   * return true if the OS supports UDP GSO
   */
  virtual bool supportsUdpGso() const PURE;

  /**
   * return true if the OS support IP_TRANSPARENT or IPV6_TRANSPARENT options by the ip version.
   */
  virtual bool supportsIpTransparent(Network::Address::IpVersion version) const PURE;

  /**
   * return true if the OS supports multi-path TCP
   */
  virtual bool supportsMptcp() const PURE;

  /**
   * Release all resources allocated for fd.
   * @return zero on success, -1 returned otherwise.
   */
  virtual SysCallIntResult close(os_fd_t fd) PURE;

  /**
   * @see man 2 ftruncate
   */
  virtual SysCallIntResult ftruncate(int fd, off_t length) PURE;

  /**
   * @see man 2 mmap
   */
  virtual SysCallPtrResult mmap(void* addr, size_t length, int prot, int flags, int fd,
                                off_t offset) PURE;

  /**
   * @see man 2 stat
   */
  virtual SysCallIntResult stat(const char* pathname, struct stat* buf) PURE;

  /**
   * @see man 2 fstat
   */
  virtual SysCallIntResult fstat(os_fd_t fd, struct stat* buf) PURE;

  /**
   * @see man 2 setsockopt
   */
  virtual SysCallIntResult setsockopt(os_fd_t sockfd, int level, int optname, const void* optval,
                                      socklen_t optlen) PURE;

  /**
   * @see man 2 getsockopt
   */
  virtual SysCallIntResult getsockopt(os_fd_t sockfd, int level, int optname, void* optval,
                                      socklen_t* optlen) PURE;

  /**
   * @see man 2 socket
   */
  virtual SysCallSocketResult socket(int domain, int type, int protocol) PURE;

  /**
   * @see man 2 sendmsg
   */
  virtual SysCallSizeResult sendmsg(os_fd_t sockfd, const msghdr* message, int flags) PURE;

  /**
   * @see man 2 getsockname
   */
  virtual SysCallIntResult getsockname(os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) PURE;

  /**
   * @see man 2 gethostname
   */
  virtual SysCallIntResult gethostname(char* name, size_t length) PURE;

  /**
   * @see man 2 getpeername
   */
  virtual SysCallIntResult getpeername(os_fd_t sockfd, sockaddr* name, socklen_t* namelen) PURE;

  /**
   * Toggle the blocking state bit using fcntl
   */
  virtual SysCallIntResult setsocketblocking(os_fd_t sockfd, bool blocking) PURE;

  /**
   * @see man 2 connect
   */
  virtual SysCallIntResult connect(os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) PURE;

  /**
   * @see man 2 open
   */
  virtual SysCallIntResult open(const char* pathname, int flags) const PURE;

  /**
   * @see man 2 open
   */
  virtual SysCallIntResult open(const char* pathname, int flags, mode_t mode) const PURE;

  /**
   * @see man 2 unlink
   */
  virtual SysCallIntResult unlink(const char* pathname) const PURE;

  /**
   * @see man 2 unlink
   */
  virtual SysCallIntResult linkat(os_fd_t olddirfd, const char* oldpath, os_fd_t newdirfd,
                                  const char* newpath, int flags) const PURE;

  /**
   * @see man 2 mkstemp
   */
  virtual SysCallIntResult mkstemp(char* tmplate) const PURE;

  /**
   * Returns true if mkstemp, linkat, unlink, open, close, pread and pwrite are fully supported.
   */
  virtual bool supportsAllPosixFileOperations() const PURE;

  /**
   * @see man 2 shutdown
   */
  virtual SysCallIntResult shutdown(os_fd_t sockfd, int how) PURE;

  /**
   * @see man 2 socketpair
   */
  virtual SysCallIntResult socketpair(int domain, int type, int protocol, os_fd_t sv[2]) PURE;

  /**
   * @see man 2 listen
   */
  virtual SysCallIntResult listen(os_fd_t sockfd, int backlog) PURE;

  /**
   * @see man 2 write
   */
  virtual SysCallSizeResult write(os_fd_t socket, const void* buffer, size_t length) PURE;

  /**
   * @see man 2 accept. The fds returned are configured to be non-blocking.
   */
  virtual SysCallSocketResult accept(os_fd_t socket, sockaddr* addr, socklen_t* addrlen) PURE;

  /**
   * @see man 2 dup(2).
   */
  virtual SysCallSocketResult duplicate(os_fd_t oldfd) PURE;

  /**
   * @see man TCP_INFO. Get the tcp info for the socket.
   */
  virtual SysCallBoolResult socketTcpInfo(os_fd_t sockfd, EnvoyTcpInfo* tcp_info) PURE;

  /**
   * return true if the OS supports getifaddrs.
   */
  virtual bool supportsGetifaddrs() const PURE;

  /**
   * @see man getifaddrs
   */
  virtual SysCallIntResult getifaddrs(InterfaceAddressVector& interfaces) PURE;

  /**
   * @see man getaddrinfo
   */
  virtual SysCallIntResult getaddrinfo(const char* node, const char* service, const addrinfo* hints,
                                       addrinfo** res) PURE;

  /**
   * @see man freeaddrinfo
   */
  virtual void freeaddrinfo(addrinfo* res) PURE;
};

using OsSysCallsPtr = std::unique_ptr<OsSysCalls>;

} // namespace Api
} // namespace Envoy
#pragma once

#include <string>

#include "envoy/config/core/v3/config_source.pb.h"
#include "envoy/extensions/transport_sockets/tls/v3/cert.pb.h"
#include "envoy/secret/secret_provider.h"

namespace Envoy {

namespace Server {
namespace Configuration {
class TransportSocketFactoryContext;
} // namespace Configuration
} // namespace Server

namespace Secret {

/**
 * A manager for static and dynamic secrets.
 */
class SecretManager {
public:
  virtual ~SecretManager() = default;

  /**
   * @param add a static secret from envoy::extensions::transport_sockets::tls::v3::Secret.
   * @return a status indicating if the function completed successfully.
   */
  virtual absl::Status
  addStaticSecret(const envoy::extensions::transport_sockets::tls::v3::Secret& secret) PURE;

  /**
   * @param name a name of the static TlsCertificateConfigProvider.
   * @return the TlsCertificateConfigProviderSharedPtr. Returns nullptr if the static secret is not
   * found.
   */
  virtual TlsCertificateConfigProviderSharedPtr
  findStaticTlsCertificateProvider(const std::string& name) const PURE;

  /**
   * @param name a name of the static CertificateValidationContextConfigProviderSharedPtr.
   * @return the CertificateValidationContextConfigProviderSharedPtr. Returns nullptr
   * if the static certificate validation context is not found.
   */
  virtual CertificateValidationContextConfigProviderSharedPtr
  findStaticCertificateValidationContextProvider(const std::string& name) const PURE;

  /**
   * @param name a name of the static TlsSessionTicketKeysConfigProviderSharedPtr.
   * @return the TlsSessionTicketKeysConfigProviderSharedPtr. Returns nullptr
   * if the static tls session ticket keys are not found.
   */
  virtual TlsSessionTicketKeysConfigProviderSharedPtr
  findStaticTlsSessionTicketKeysContextProvider(const std::string& name) const PURE;

  /**
   * @param name a name of the static GenericSecretConfigProvider.
   * @return the GenericSecretConfigProviderSharedPtr. Returns nullptr if the static secret is not
   * found.
   */
  virtual GenericSecretConfigProviderSharedPtr
  findStaticGenericSecretProvider(const std::string& name) const PURE;

  /**
   * @param tls_certificate the protobuf config of the TLS certificate.
   * @return a TlsCertificateConfigProviderSharedPtr created from tls_certificate.
   */
  virtual TlsCertificateConfigProviderSharedPtr createInlineTlsCertificateProvider(
      const envoy::extensions::transport_sockets::tls::v3::TlsCertificate& tls_certificate) PURE;

  /**
   * @param certificate_validation_context the protobuf config of the certificate validation
   * context.
   * @return a CertificateValidationContextConfigProviderSharedPtr created from
   * certificate_validation_context.
   */
  virtual CertificateValidationContextConfigProviderSharedPtr
  createInlineCertificateValidationContextProvider(
      const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext&
          certificate_validation_context) PURE;

  /**
   * @param tls_certificate the protobuf config of the TLS session ticket keys.
   * @return a TlsSessionTicketKeysConfigProviderSharedPtr created from session_ticket_keys.
   */
  virtual TlsSessionTicketKeysConfigProviderSharedPtr createInlineTlsSessionTicketKeysProvider(
      const envoy::extensions::transport_sockets::tls::v3::TlsSessionTicketKeys& tls_certificate)
      PURE;

  /**
   * @param generic_secret the protobuf config of the generic secret.
   * @return a GenericSecretConfigProviderSharedPtr created from tls_certificate.
   */
  virtual GenericSecretConfigProviderSharedPtr createInlineGenericSecretProvider(
      const envoy::extensions::transport_sockets::tls::v3::GenericSecret& generic_secret) PURE;

  /**
   * Finds and returns a dynamic secret provider associated to SDS config. Create
   * a new one if such provider does not exist.
   *
   * @param config_source a protobuf message object containing a SDS config source.
   * @param config_name a name that uniquely refers to the SDS config source.
   * @param secret_provider_context context that provides components for creating and initializing
   * secret provider.
   * @return TlsCertificateConfigProviderSharedPtr the dynamic TLS secret provider.
   */
  virtual TlsCertificateConfigProviderSharedPtr findOrCreateTlsCertificateProvider(
      const envoy::config::core::v3::ConfigSource& config_source, const std::string& config_name,
      Server::Configuration::TransportSocketFactoryContext& secret_provider_context,
      Init::Manager& init_manager) PURE;

  /**
   * Finds and returns a dynamic secret provider associated to SDS config. Create
   * a new one if such provider does not exist.
   *
   * @param config_source a protobuf message object containing a SDS config source.
   * @param config_name a name that uniquely refers to the SDS config source.
   * @param secret_provider_context context that provides components for creating and initializing
   * secret provider.
   * @return CertificateValidationContextConfigProviderSharedPtr the dynamic certificate validation
   * context secret provider.
   */
  virtual CertificateValidationContextConfigProviderSharedPtr
  findOrCreateCertificateValidationContextProvider(
      const envoy::config::core::v3::ConfigSource& config_source, const std::string& config_name,
      Server::Configuration::TransportSocketFactoryContext& secret_provider_context,
      Init::Manager& init_manager) PURE;

  /**
   * Finds and returns a dynamic secret provider associated to SDS config. Create
   * a new one if such provider does not exist.
   *
   * @param config_source a protobuf message object containing a SDS config source.
   * @param config_name a name that uniquely refers to the SDS config source.
   * @param secret_provider_context context that provides components for creating and initializing
   * secret provider.
   * @return TlsSessionTicketKeysConfigProviderSharedPtr the dynamic tls session ticket keys secret
   * provider.
   */
  virtual TlsSessionTicketKeysConfigProviderSharedPtr
  findOrCreateTlsSessionTicketKeysContextProvider(
      const envoy::config::core::v3::ConfigSource& config_source, const std::string& config_name,
      Server::Configuration::TransportSocketFactoryContext& secret_provider_context,
      Init::Manager& init_manager) PURE;

  /**
   * Finds and returns a dynamic secret provider associated to SDS config. Create a new one if such
   * provider does not exist.
   *
   * @param config_source a protobuf message object containing a SDS config source.
   * @param config_name a name that uniquely refers to the SDS config source.
   * @param secret_provider_context context that provides components for creating and initializing
   * secret provider.
   * @return GenericSecretConfigProviderSharedPtr the dynamic generic secret provider.
   */
  virtual GenericSecretConfigProviderSharedPtr findOrCreateGenericSecretProvider(
      const envoy::config::core::v3::ConfigSource& config_source, const std::string& config_name,
      Server::Configuration::TransportSocketFactoryContext& secret_provider_context,
      Init::Manager& init_manager) PURE;
};

using SecretManagerPtr = std::unique_ptr<SecretManager>;

} // namespace Secret
} // namespace Envoy
#pragma once

#include "envoy/common/pure.h"

namespace Envoy {
namespace Secret {

/**
 * Callbacks invoked by a dynamic secret provider.
 */
class SecretCallbacks {
public:
  virtual ~SecretCallbacks() = default;

  virtual void onAddOrUpdateSecret() PURE;
};

} // namespace Secret
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "secret_callbacks_interface",
    hdrs = ["secret_callbacks.h"],
)

envoy_cc_library(
    name = "secret_provider_interface",
    hdrs = ["secret_provider.h"],
    deps = [
        ":secret_callbacks_interface",
        "//envoy/common:callback",
        "//envoy/ssl:certificate_validation_context_config_interface",
        "//envoy/ssl:tls_certificate_config_interface",
        "@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "secret_manager_interface",
    hdrs = ["secret_manager.h"],
    deps = [
        ":secret_provider_interface",
        "//envoy/init:target_interface",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto",
    ],
)
#pragma once

#include <functional>

#include "envoy/common/callback.h"
#include "envoy/common/pure.h"
#include "envoy/extensions/transport_sockets/tls/v3/cert.pb.h"
#include "envoy/init/target.h"
#include "envoy/ssl/certificate_validation_context_config.h"
#include "envoy/ssl/tls_certificate_config.h"

namespace Envoy {
namespace Secret {

/**
 * A secret provider for each kind of secret.
 */
template <class SecretType> class SecretProvider {
public:
  virtual ~SecretProvider() = default;

  /**
   * @return the secret. Returns nullptr if the secret is not ready.
   */
  virtual const SecretType* secret() const PURE;

  /**
   * Add secret validation callback into secret provider.
   * It is safe to call this method by main thread and callback is safe to be invoked
   * on main thread.
   * @param callback callback that is executed by secret provider.
   * @return CallbackHandle the handle which can remove that validation callback.
   */
  ABSL_MUST_USE_RESULT virtual Common::CallbackHandlePtr
  addValidationCallback(std::function<void(const SecretType&)> callback) PURE;

  /**
   * Add secret update callback into secret provider.
   * It is safe to call this method by main thread and callback is safe to be invoked
   * on main thread.
   * @param callback callback that is executed by secret provider.
   * @return CallbackHandle the handle which can remove that update callback.
   */
  ABSL_MUST_USE_RESULT virtual Common::CallbackHandlePtr
  addUpdateCallback(std::function<void()> callback) PURE;

  /**
   * @return const Init::Target* A shared init target that can be used by multiple init managers.
   * nullptr if the provider isn't dynamic.
   */
  virtual const Init::Target* initTarget() { return nullptr; }
};

using TlsCertificatePtr =
    std::unique_ptr<envoy::extensions::transport_sockets::tls::v3::TlsCertificate>;
using CertificateValidationContextPtr =
    std::unique_ptr<envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext>;
using TlsSessionTicketKeysPtr =
    std::unique_ptr<envoy::extensions::transport_sockets::tls::v3::TlsSessionTicketKeys>;
using GenericSecretPtr =
    std::unique_ptr<envoy::extensions::transport_sockets::tls::v3::GenericSecret>;

using TlsCertificateConfigProvider =
    SecretProvider<envoy::extensions::transport_sockets::tls::v3::TlsCertificate>;
using TlsCertificateConfigProviderSharedPtr = std::shared_ptr<TlsCertificateConfigProvider>;

using CertificateValidationContextConfigProvider =
    SecretProvider<envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext>;
using CertificateValidationContextConfigProviderSharedPtr =
    std::shared_ptr<CertificateValidationContextConfigProvider>;

using TlsSessionTicketKeysConfigProvider =
    SecretProvider<envoy::extensions::transport_sockets::tls::v3::TlsSessionTicketKeys>;
using TlsSessionTicketKeysConfigProviderSharedPtr =
    std::shared_ptr<TlsSessionTicketKeysConfigProvider>;

using GenericSecretConfigProvider =
    SecretProvider<envoy::extensions::transport_sockets::tls::v3::GenericSecret>;
using GenericSecretConfigProviderSharedPtr = std::shared_ptr<GenericSecretConfigProvider>;

} // namespace Secret
} // namespace Envoy
#pragma once

#include "envoy/config/core/v3/config_source.pb.h"
#include "envoy/config/dynamic_extension_config_provider.h"
#include "envoy/init/manager.h"
#include "envoy/server/filter_config.h"
#include "envoy/upstream/cluster_manager.h"

#include "absl/types/optional.h"

namespace Envoy {
namespace Filter {

template <class FactoryCb>
using FilterConfigProvider = Envoy::Config::ExtensionConfigProvider<FactoryCb>;
template <class FactoryCb>
using FilterConfigProviderPtr = std::unique_ptr<FilterConfigProvider<FactoryCb>>;
template <class FactoryCb>
using DynamicFilterConfigProvider = Envoy::Config::DynamicExtensionConfigProvider<FactoryCb>;
template <class FactoryCb>
using DynamicFilterConfigProviderPtr = std::unique_ptr<DynamicFilterConfigProvider<FactoryCb>>;

// Network filter config provider aliases
using NetworkFilterFactoriesList = std::vector<FilterConfigProviderPtr<Network::FilterFactoryCb>>;

// Listener filter config provider aliases
using ListenerFilterFactoriesList =
    std::vector<FilterConfigProviderPtr<Network::ListenerFilterFactoryCb>>;
using QuicListenerFilterFactoriesList =
    std::vector<FilterConfigProviderPtr<Network::QuicListenerFilterFactoryCb>>;

/**
 * The FilterConfigProviderManager exposes the ability to get an FilterConfigProvider
 * for both static and dynamic filter config providers.
 */
template <class FactoryCb, class FactoryCtx> class FilterConfigProviderManager {
public:
  virtual ~FilterConfigProviderManager() = default;

  /**
   * Get an FilterConfigProviderPtr for a filter config. The config providers may share
   * the underlying subscriptions to the filter config discovery service.
   * @param config_source supplies the extension configuration source for the filter configs.
   * @param filter_config_name the filter config resource name.
   * @param factory_context is the context to use for the filter config provider.
   * @param last_filter_in_filter_chain indicates whether this filter is the last filter in the
   * configured chain
   * @param filter_chain_type is the filter chain type
   * @param listener_filter_matcher is the filter matcher for TCP listener filter. nullptr for other
   * filter types.
   */
  virtual DynamicFilterConfigProviderPtr<FactoryCb> createDynamicFilterConfigProvider(
      const envoy::config::core::v3::ExtensionConfigSource& config_source,
      const std::string& filter_config_name,
      Server::Configuration::ServerFactoryContext& server_context, FactoryCtx& factory_context,
      Upstream::ClusterManager& cluster_manager, bool last_filter_in_filter_chain,
      const std::string& filter_chain_type,
      const Network::ListenerFilterMatcherSharedPtr& listener_filter_matcher) PURE;

  /**
   * Get an FilterConfigProviderPtr for a statically inlined filter config.
   * @param config is a fully resolved filter instantiation factory.
   * @param filter_config_name is the name of the filter configuration resource.
   */
  virtual FilterConfigProviderPtr<FactoryCb>
  createStaticFilterConfigProvider(const FactoryCb& config,
                                   const std::string& filter_config_name) PURE;

  /**
   * Get the stat prefix for the scope of the filter provider manager.
   */
  virtual absl::string_view statPrefix() const PURE;
};

} // namespace Filter
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "config_provider_manager_interface",
    hdrs = ["config_provider_manager.h"],
    deps = [
        "//envoy/config:dynamic_extension_config_provider_interface",
        "//envoy/init:manager_interface",
        "//envoy/server:filter_config_interface",
        "//envoy/upstream:cluster_manager_interface",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)
#pragma once

#include <functional>
#include <limits>
#include <memory>
#include <string>

#include "envoy/common/pure.h"

#include "source/common/common/thread_annotations.h"

#include "absl/strings/string_view.h"
#include "absl/types/optional.h"

namespace Envoy {
namespace Thread {

/**
 * An id for a thread.
 */
class ThreadId {
public:
  ThreadId() : id_(std::numeric_limits<int64_t>::min()) {}
  explicit ThreadId(int64_t id) : id_(id) {}

  int64_t getId() const { return id_; }
  std::string debugString() const { return std::to_string(id_); }
  bool isEmpty() const { return *this == ThreadId(); }
  friend bool operator==(ThreadId lhs, ThreadId rhs) { return lhs.id_ == rhs.id_; }
  friend bool operator!=(ThreadId lhs, ThreadId rhs) { return lhs.id_ != rhs.id_; }
  template <typename H> friend H AbslHashValue(H h, ThreadId id) {
    return H::combine(std::move(h), id.id_);
  }

private:
  int64_t id_;
};

class Thread {
public:
  virtual ~Thread() = default;

  /**
   * @return the name of the thread.
   */
  virtual std::string name() const PURE;

  /**
   * Blocks until the thread exits.
   */
  virtual void join() PURE;
};

using ThreadPtr = std::unique_ptr<Thread>;

// Options specified during thread creation.
struct Options {
  std::string name_; // A name supplied for the thread. On Linux this is limited to 15 chars.
};

using OptionsOptConstRef = const absl::optional<Options>&;

/**
 * Interface providing a mechanism for creating threads.
 */
class ThreadFactory {
public:
  virtual ~ThreadFactory() = default;

  /**
   * Creates a thread, immediately starting the thread_routine.
   *
   * @param thread_routine supplies the function to invoke in the thread.
   * @param options supplies options specified on thread creation.
   */
  virtual ThreadPtr createThread(std::function<void()> thread_routine,
                                 OptionsOptConstRef options = absl::nullopt) PURE;

  /**
   * Return the current system thread ID
   */
  virtual ThreadId currentThreadId() PURE;
};

using ThreadFactoryPtr = std::unique_ptr<ThreadFactory>;

/**
 * Like the C++11 "basic lockable concept" but a pure virtual interface vs. a template, and
 * with thread annotations.
 */
class ABSL_LOCKABLE BasicLockable {
public:
  virtual ~BasicLockable() = default;

  virtual void lock() ABSL_EXCLUSIVE_LOCK_FUNCTION() PURE;
  virtual bool tryLock() ABSL_EXCLUSIVE_TRYLOCK_FUNCTION(true) PURE;
  virtual void unlock() ABSL_UNLOCK_FUNCTION() PURE;
};

} // namespace Thread
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "thread_interface",
    hdrs = ["thread.h"],
    deps = [
        "//envoy/common:pure_lib",
        "//source/common/common:thread_annotations",
    ],
)
#pragma once

#include <memory>

namespace Envoy {
namespace Rds {

/**
 * Base class for router configuration classes used with Rds.
 */
class Config {
public:
  virtual ~Config() = default;
};

using ConfigConstSharedPtr = std::shared_ptr<const Config>;

} // namespace Rds
} // namespace Envoy
#pragma once

#include <memory>

#include "envoy/common/time.h"
#include "envoy/rds/config.h"

#include "source/common/protobuf/protobuf.h"

#include "absl/types/optional.h"

namespace Envoy {
namespace Rds {

/**
 * A provider for constant route configurations.
 */
class RouteConfigProvider {
public:
  struct ConfigInfo {
    // A reference to the currently loaded route configuration. Do not hold this reference beyond
    // the caller of configInfo()'s scope.
    const Protobuf::Message& config_;

    // The discovery version that supplied this route. This will be set to "" in the case of
    // static clusters.
    const std::string version_;
  };

  virtual ~RouteConfigProvider() = default;

  /**
   * @return ConfigConstSharedPtr a route configuration for use during a single request. The
   * returned config may be different on a subsequent call, so a new config should be acquired for
   * each request flow.
   */
  virtual ConfigConstSharedPtr config() const PURE;

  /**
   * @return the configuration information for the currently loaded route configuration. Note that
   * if the provider has not yet performed an initial configuration load, no information will be
   * returned.
   */
  virtual const absl::optional<ConfigInfo>& configInfo() const PURE;

  /**
   * @return the last time this RouteConfigProvider was updated. Used for config dumps.
   */
  virtual SystemTime lastUpdated() const PURE;

  /**
   * Callback used to notify RouteConfigProvider about configuration changes.
   * @return Status indicating if the call was successful or had graceful error handling.
   */
  virtual absl::Status onConfigUpdate() PURE;
};

using RouteConfigProviderPtr = std::unique_ptr<RouteConfigProvider>;
using RouteConfigProviderSharedPtr = std::shared_ptr<RouteConfigProvider>;

} // namespace Rds
} // namespace Envoy
#pragma once

#include <memory>

#include "envoy/common/pure.h"
#include "envoy/rds/config.h"
#include "envoy/server/factory_context.h"

#include "source/common/protobuf/protobuf.h"

namespace Envoy {
namespace Rds {

/**
 * Traits of the protocol specific route configuration and proto.
 * The generic rds classes will call the methods of this interface
 * to get information which is not visible for them directly.
 */
class ProtoTraits {
public:
  virtual ~ProtoTraits() = default;

  /**
   * Give the full name of the route configuration proto description.
   * For example 'envoy.config.route.v3.RouteConfiguration'
   */
  virtual const std::string& resourceType() const PURE;

  /**
   * Gives back the name field tag number of the route configuration proto.
   */
  virtual int resourceNameFieldNumber() const PURE;

  /**
   * Create an empty route configuration proto object.
   */
  virtual ProtobufTypes::MessagePtr createEmptyProto() const PURE;
};

class ConfigTraits {
public:
  virtual ~ConfigTraits() = default;

  /**
   * Create a dummy config object without actual route configuration.
   * This object will be used before the first valid route configuration is fetched.
   */
  virtual ConfigConstSharedPtr createNullConfig() const PURE;

  /**
   * Create a config object based on a route configuration.
   * The full name of the type of the parameter message is
   * guaranteed to match with the return value of ProtoTraits::resourceType.
   * Both dynamic or static cast can be applied to downcast the message
   * to the corresponding route configuration class.
   * @param rc supplies the RouteConfiguration.
   * @param context supplies the context of the server factory.
   * @param validate_clusters_default specifies whether the clusters that the route
   *    table refers to will be validated by the cluster manager. Currently thrift
   *    route config provider manager validates the clusters for static route config
   *    by default but doesn't validate the clusters for TRDS.
   * @throw EnvoyException if the new config can't be applied of.
   */
  virtual ConfigConstSharedPtr createConfig(const Protobuf::Message& rc,
                                            Server::Configuration::ServerFactoryContext& context,
                                            bool validate_clusters_default) const PURE;
};

} // namespace Rds
} // namespace Envoy
#pragma once

#include <memory>

#include "envoy/common/pure.h"
#include "envoy/common/time.h"
#include "envoy/rds/route_config_provider.h"

#include "absl/types/optional.h"

namespace Envoy {
namespace Rds {

/**
 * A primitive that keeps track of updates to a RouteConfiguration.
 */
class RouteConfigUpdateReceiver {
public:
  virtual ~RouteConfigUpdateReceiver() = default;

  /**
   * Called on updates via RDS.
   * @param rc supplies the RouteConfiguration.
   * @param version_info supplies RouteConfiguration version.
   * @return bool whether the hash of the new config has been different than
   * the hash of the current one and RouteConfiguration has been updated.
   * @throw EnvoyException if the new config is invalid and can't be applied.
   */
  virtual bool onRdsUpdate(const Protobuf::Message& rc, const std::string& version_info) PURE;

  /**
   * @return uint64_t the hash value of RouteConfiguration.
   */
  virtual uint64_t configHash() const PURE;

  /**
   * @return absl::optional<RouteConfigProvider::ConfigInfo> containing an instance of
   * RouteConfigProvider::ConfigInfo if RouteConfiguration has been updated at least once. Otherwise
   * returns an empty absl::optional<RouteConfigProvider::ConfigInfo>.
   */
  virtual const absl::optional<RouteConfigProvider::ConfigInfo>& configInfo() const PURE;

  /**
   * @return Protobuf::Message& current RouteConfiguration.
   */
  virtual const Protobuf::Message& protobufConfiguration() const PURE;

  /**
   * @return ConfigConstSharedPtr a parsed and validated copy of current RouteConfiguration.
   * @see protobufConfiguration()
   */
  virtual ConfigConstSharedPtr parsedConfiguration() const PURE;

  /**
   * @return SystemTime the time of the last update.
   */
  virtual SystemTime lastUpdated() const PURE;
};

using RouteConfigUpdatePtr = std::unique_ptr<RouteConfigUpdateReceiver>;

} // namespace Rds
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "rds_config_interface",
    hdrs = [
        "config.h",
    ],
)

envoy_cc_library(
    name = "rds_interface",
    hdrs = [
        "config_traits.h",
        "route_config_provider.h",
        "route_config_update_receiver.h",
    ],
    deps = [
        ":rds_config_interface",
        "//envoy/server:factory_context_interface",
    ],
)
#pragma once

#include <cstdint>
#include <functional>
#include <memory>

#include "envoy/common/pure.h"

namespace Envoy {
namespace Event {

struct FileReadyType {
  // File is ready for reading.
  static constexpr uint32_t Read = 0x1;
  // File is ready for writing.
  static constexpr uint32_t Write = 0x2;
  // File has been remote closed.
  static constexpr uint32_t Closed = 0x4;
};

enum class FileTriggerType {
  // See @man 7 epoll(7)
  // They are used on all platforms for DNS and TCP listeners.
  Level,
  // See @man 7 epoll(7)
  // They are used on all platforms that support Edge triggering as the default trigger type.
  Edge,
  // These are synthetic edge events managed by Envoy. They are based on level events and when they
  // are activated they are immediately disabled. This makes them behave like Edge events. Then it
  // is is the responsibility of the consumer of the event to reactivate the event
  // when the socket operation would block.
  //
  // Their main application in Envoy is for Win32 which does not support edge-triggered events. They
  // should be used in Win32 instead of level events. They can only be used in platforms where
  // `PlatformDefaultTriggerType` is `FileTriggerType::EmulatedEdge`.
  EmulatedEdge
};

// For POSIX developers to get the Windows behavior of file events
// you need to add the following definition:
// `FORCE_LEVEL_EVENTS`
// You can do this with bazel if you add the following build/test options
// `--copt="-DFORCE_LEVEL_EVENTS"`
constexpr FileTriggerType determinePlatformPreferredEventType() {
#if defined(WIN32) || defined(FORCE_LEVEL_EVENTS)
  return FileTriggerType::EmulatedEdge;
#else
  return FileTriggerType::Edge;
#endif
}

static constexpr FileTriggerType PlatformDefaultTriggerType = determinePlatformPreferredEventType();

/**
 * Callback invoked when a FileEvent is ready for reading or writing.
 */
using FileReadyCb = std::function<void(uint32_t events)>;

/**
 * Wrapper for file based (read/write) event notifications.
 */
class FileEvent {
public:
  virtual ~FileEvent() = default;

  /**
   * Activate the file event explicitly for a set of events. Should be a logical OR of FileReadyType
   * events. This method "injects" the event (and fires callbacks) regardless of whether the event
   * is actually ready on the underlying file.
   */
  virtual void activate(uint32_t events) PURE;

  /**
   * Enable the file event explicitly for a set of events. Should be a logical OR of FileReadyType
   * events. As opposed to activate(), this routine causes the file event to listen for the
   * registered events and fire callbacks when they are active.
   */
  virtual void setEnabled(uint32_t events) PURE;

  /**
   * Add a single event from the event registration mark.
   */
  virtual void registerEventIfEmulatedEdge(uint32_t event) PURE;

  /**
   * Remove a single event from the event registration mark.
   */
  virtual void unregisterEventIfEmulatedEdge(uint32_t event) PURE;
};

using FileEventPtr = std::unique_ptr<FileEvent>;

} // namespace Event
} // namespace Envoy
#pragma once

#include <memory>

namespace Envoy {
namespace Event {

/**
 * If an object derives from this class, it can be passed to the destination dispatcher who
 * guarantees to delete it in that dispatcher thread. The common use case is to ensure config
 * related objects are deleted in the main thread.
 */
class DispatcherThreadDeletable {
public:
  virtual ~DispatcherThreadDeletable() = default;
};

using DispatcherThreadDeletableConstPtr = std::unique_ptr<const DispatcherThreadDeletable>;

} // namespace Event
} // namespace Envoy
#pragma once

#include <memory>

namespace Envoy {
namespace Event {

/**
 * If an object derives from this class, it can be passed to the dispatcher who guarantees to delete
 * it in a future event loop cycle. This allows clear ownership with unique_ptr while not having
 * to worry about stack unwind issues during event processing.
 */
class DeferredDeletable {
public:
  virtual ~DeferredDeletable() = default;

  /**
   * Called when an object is passed to `deferredDelete`. This signals that the object will soon
   * be deleted.
   */
  virtual void deleteIsPending() {}
};

using DeferredDeletablePtr = std::unique_ptr<DeferredDeletable>;

} // namespace Event
} // namespace Envoy
#pragma once

#include "envoy/common/pure.h"
#include "envoy/event/scaled_timer.h"
#include "envoy/event/timer.h"

#include "source/common/common/interval_value.h"

#include "absl/types/variant.h"

namespace Envoy {
namespace Event {

/**
 * Class for creating Timer objects that can be adjusted towards either the minimum or maximum
 * of their range by the owner of the manager object. Users of this class can call createTimer() to
 * receive a new Timer object that they can then enable or disable at will (but only on the same
 * dispatcher), and setScaleFactor() to change the scaling factor. The current scale factor is
 * applied to all timers, including those that are created later.
 */
class ScaledRangeTimerManager {
public:
  virtual ~ScaledRangeTimerManager() = default;

  /**
   * Creates a new timer backed by the manager. Calling enableTimer on the returned object sets the
   * maximum duration, while the first argument here controls the minimum. Passing a value of
   * ScaleFactor(x) sets the min to (x * max) when the timer is enabled, while AbsoluteValue(y) sets
   * the min to the duration y.
   */
  virtual TimerPtr createTimer(ScaledTimerMinimum minimum, TimerCb callback) PURE;

  /**
   * Creates a new timer backed by the manager using the provided timer type to
   * determine the minimum.
   */
  virtual TimerPtr createTimer(ScaledTimerType timer_type, TimerCb callback) PURE;

  /**
   * Sets the scale factor for all timers created through this manager. The value should be between
   * 0 and 1, inclusive. The scale factor affects the amount of time timers spend in their target
   * range. The timers returned by createTimer will fire after (min + (max - min) * scale_factor).
   * This means that a scale factor of 0 causes timers to fire immediately at the min duration, a
   * factor of 0.5 causes firing halfway between min and max, and a factor of 1 causes firing at
   * max.
   */
  virtual void setScaleFactor(UnitFloat scale_factor) PURE;
};

using ScaledRangeTimerManagerPtr = std::unique_ptr<ScaledRangeTimerManager>;

class Dispatcher;
using ScaledRangeTimerManagerFactory = std::function<ScaledRangeTimerManagerPtr(Dispatcher&)>;

} // namespace Event
} // namespace Envoy
#pragma once

#include <functional>
#include <memory>

namespace Envoy {
namespace Event {

/**
 * Callback invoked when a signal event fires.
 */
using SignalCb = std::function<void()>;

/**
 * An abstract signal event. Free the event to stop listening on the signal.
 */
class SignalEvent {
public:
  virtual ~SignalEvent() = default;
};

using SignalEventPtr = std::unique_ptr<SignalEvent>;

} // namespace Event
} // namespace Envoy
#pragma once

#include <cstdint>
#include <functional>
#include <memory>
#include <string>
#include <vector>

#include "envoy/common/scope_tracker.h"
#include "envoy/common/time.h"
#include "envoy/config/core/v3/resolver.pb.h"
#include "envoy/config/core/v3/udp_socket_config.pb.h"
#include "envoy/event/dispatcher_thread_deletable.h"
#include "envoy/event/file_event.h"
#include "envoy/event/scaled_timer.h"
#include "envoy/event/schedulable_cb.h"
#include "envoy/event/signal.h"
#include "envoy/event/timer.h"
#include "envoy/filesystem/watcher.h"
#include "envoy/network/connection.h"
#include "envoy/network/connection_handler.h"
#include "envoy/network/dns.h"
#include "envoy/network/listen_socket.h"
#include "envoy/network/listener.h"
#include "envoy/network/transport_socket.h"
#include "envoy/server/overload/thread_local_overload_state.h"
#include "envoy/server/watchdog.h"
#include "envoy/stats/scope.h"
#include "envoy/stats/stats_macros.h"
#include "envoy/stream_info/stream_info.h"
#include "envoy/thread/thread.h"

#include "absl/functional/any_invocable.h"

namespace Envoy {
namespace Event {

/**
 * All dispatcher stats. @see stats_macros.h
 */
#define ALL_DISPATCHER_STATS(HISTOGRAM)                                                            \
  HISTOGRAM(loop_duration_us, Microseconds)                                                        \
  HISTOGRAM(poll_delay_us, Microseconds)

/**
 * Struct definition for all dispatcher stats. @see stats_macros.h
 */
struct DispatcherStats {
  ALL_DISPATCHER_STATS(GENERATE_HISTOGRAM_STRUCT)
};

using DispatcherStatsPtr = std::unique_ptr<DispatcherStats>;

/**
 * Callback invoked when a dispatcher post() runs.
 */
using PostCb = absl::AnyInvocable<void()>;

using PostCbSharedPtr = std::shared_ptr<PostCb>;

/**
 * Minimal interface to the dispatching loop used to create low-level primitives. See Dispatcher
 * below for the full interface.
 */
class DispatcherBase {
public:
  virtual ~DispatcherBase() = default;

  /**
   * Posts a functor to the dispatcher. This is safe cross thread. The functor runs in the context
   * of the dispatcher event loop which may be on a different thread than the caller.
   */
  virtual void post(PostCb callback) PURE;

  /**
   * Validates that an operation is thread-safe with respect to this dispatcher; i.e. that the
   * current thread of execution is on the same thread upon which the dispatcher loop is running.
   */
  virtual bool isThreadSafe() const PURE;
};

/**
 * Minimal interface to support ScopeTrackedObjects.
 */
class ScopeTracker {
public:
  virtual ~ScopeTracker() = default;

  /**
   * Appends a tracked object to the current stack of tracked objects operating
   * in the dispatcher.
   *
   * It's recommended to use ScopeTrackerScopeState to manage the object's tracking. If directly
   * invoking, there needs to be a subsequent call to popTrackedObject().
   */
  virtual void pushTrackedObject(const ScopeTrackedObject* object) PURE;

  /**
   * Removes the top of the stack of tracked object and asserts that it was expected.
   */
  virtual void popTrackedObject(const ScopeTrackedObject* expected_object) PURE;

  /**
   * Whether the tracked object stack is empty.
   */
  virtual bool trackedObjectStackIsEmpty() const PURE;
};

/**
 * Abstract event dispatching loop.
 */
class Dispatcher : public DispatcherBase, public ScopeTracker {
public:
  /**
   * Returns the name that identifies this dispatcher, such as "worker_2" or "main_thread".
   * @return const std::string& the name that identifies this dispatcher.
   */
  virtual const std::string& name() PURE;

  /**
   * Creates a file event that will signal when a file is readable or writable. On UNIX systems this
   * can be used for any file like interface (files, sockets, etc.).
   * @param fd supplies the fd to watch.
   * @param cb supplies the callback to fire when the file is ready.
   * @param trigger specifies whether to edge or level trigger.
   * @param events supplies a logical OR of FileReadyType events that the file event should
   *               initially listen on.
   */
  virtual FileEventPtr createFileEvent(os_fd_t fd, FileReadyCb cb, FileTriggerType trigger,
                                       uint32_t events) PURE;

  /**
   * Allocates a timer. @see Timer for docs on how to use the timer.
   * @param cb supplies the callback to invoke when the timer fires.
   */
  virtual Event::TimerPtr createTimer(TimerCb cb) PURE;

  /**
   * Allocates a scaled timer. @see Timer for docs on how to use the timer.
   * @param timer_type the type of timer to create.
   * @param cb supplies the callback to invoke when the timer fires.
   */
  virtual Event::TimerPtr createScaledTimer(Event::ScaledTimerType timer_type, TimerCb cb) PURE;

  /**
   * Allocates a scaled timer. @see Timer for docs on how to use the timer.
   * @param minimum the rule for computing the minimum value of the timer.
   * @param cb supplies the callback to invoke when the timer fires.
   */
  virtual Event::TimerPtr createScaledTimer(Event::ScaledTimerMinimum minimum, TimerCb cb) PURE;

  /**
   * Allocates a schedulable callback. @see SchedulableCallback for docs on how to use the wrapped
   * callback.
   * @param cb supplies the callback to invoke when the SchedulableCallback is triggered on the
   * event loop.
   */
  virtual Event::SchedulableCallbackPtr createSchedulableCallback(std::function<void()> cb) PURE;

  /**
   * Register a watchdog for this dispatcher. The dispatcher is responsible for touching the
   * watchdog at least once per touch interval. Dispatcher implementations may choose to touch more
   * often to avoid spurious miss events when processing long callback queues.
   * @param min_touch_interval Touch interval for the watchdog.
   */
  virtual void registerWatchdog(const Server::WatchDogSharedPtr& watchdog,
                                std::chrono::milliseconds min_touch_interval) PURE;

  /**
   * Returns a time-source to use with this dispatcher.
   */
  virtual TimeSource& timeSource() PURE;

  /**
   * Returns a recently cached MonotonicTime value.
   */
  virtual MonotonicTime approximateMonotonicTime() const PURE;

  /**
   * Initializes stats for this dispatcher. Note that this can't generally be done at construction
   * time, since the main and worker thread dispatchers are constructed before
   * ThreadLocalStoreImpl::initializeThreading.
   * @param scope the scope to contain the new per-dispatcher stats created here.
   * @param prefix the stats prefix to identify this dispatcher. If empty, the dispatcher will be
   *               identified by its name.
   */
  virtual void initializeStats(Stats::Scope& scope,
                               const absl::optional<std::string>& prefix = absl::nullopt) PURE;

  /**
   * Clears any items in the deferred deletion queue.
   */
  virtual void clearDeferredDeleteList() PURE;

  /**
   * Wraps an already-accepted socket in an instance of Envoy's server Network::Connection.
   * @param socket supplies an open file descriptor and connection metadata to use for the
   *        connection. Takes ownership of the socket.
   * @param transport_socket supplies a transport socket to be used by the connection.
   * @param stream_info info object for the server connection
   * @return Network::ConnectionPtr a server connection that is owned by the caller.
   */
  virtual Network::ServerConnectionPtr
  createServerConnection(Network::ConnectionSocketPtr&& socket,
                         Network::TransportSocketPtr&& transport_socket,
                         StreamInfo::StreamInfo& stream_info) PURE;

  /**
   * Creates an instance of Envoy's Network::ClientConnection. Does NOT initiate the connection;
   * the caller must then call connect() on the returned Network::ClientConnection.
   * @param address supplies the address to connect to.
   * @param source_address supplies an address to bind to or nullptr if no bind is necessary.
   * @param transport_socket supplies a transport socket to be used by the connection.
   * @param options the socket options to be set on the underlying socket before anything is sent
   *        on the socket.
   * @param transport socket options used to create the transport socket.
   * @return Network::ClientConnectionPtr a client connection that is owned by the caller.
   */
  virtual Network::ClientConnectionPtr createClientConnection(
      Network::Address::InstanceConstSharedPtr address,
      Network::Address::InstanceConstSharedPtr source_address,
      Network::TransportSocketPtr&& transport_socket,
      const Network::ConnectionSocket::OptionsSharedPtr& options,
      const Network::TransportSocketOptionsConstSharedPtr& transport_options) PURE;

  /**
   * @return Filesystem::WatcherPtr a filesystem watcher owned by the caller.
   */
  virtual Filesystem::WatcherPtr createFilesystemWatcher() PURE;

  /**
   * Submits an item for deferred delete. @see DeferredDeletable.
   */
  virtual void deferredDelete(DeferredDeletablePtr&& to_delete) PURE;

  /**
   * Exits the event loop.
   */
  virtual void exit() PURE;

  /**
   * Listens for a signal event. Only a single dispatcher in the process can listen for signals.
   * If more than one dispatcher calls this routine in the process the behavior is undefined.
   *
   * @param signal_num supplies the signal to listen on.
   * @param cb supplies the callback to invoke when the signal fires.
   * @return SignalEventPtr a signal event that is owned by the caller.
   */
  virtual SignalEventPtr listenForSignal(signal_t signal_num, SignalCb cb) PURE;

  /**
   * Post the deletable to this dispatcher. The deletable objects are guaranteed to be destroyed on
   * the dispatcher's thread before dispatcher destroy. This is safe cross thread.
   */
  virtual void deleteInDispatcherThread(DispatcherThreadDeletableConstPtr deletable) PURE;

  /**
   * Runs the event loop. This will not return until exit() is called either from within a callback
   * or from a different thread.
   * @param type specifies whether to run in blocking mode (run() will not return until exit() is
   *              called) or non-blocking mode where only active events will be executed and then
   *              run() will return.
   */
  enum class RunType {
    Block,       // Runs the event-loop until there are no pending events.
    NonBlock,    // Checks for any pending events to activate, executes them,
                 // then exits. Exits immediately if there are no pending or
                 // active events.
    RunUntilExit // Runs the event-loop until loopExit() is called, blocking
                 // until there are pending or active events.
  };
  virtual void run(RunType type) PURE;

  /**
   * Returns a factory which connections may use for watermark buffer creation.
   * @return the watermark buffer factory for this dispatcher.
   */
  virtual Buffer::WatermarkFactory& getWatermarkFactory() PURE;

  /**
   * Updates approximate monotonic time to current value.
   */
  virtual void updateApproximateMonotonicTime() PURE;

  /**
   * Shutdown the dispatcher by clear dispatcher thread deletable.
   */
  virtual void shutdown() PURE;
};

using DispatcherPtr = std::unique_ptr<Dispatcher>;

} // namespace Event
} // namespace Envoy
#pragma once

#include <chrono>
#include <functional>
#include <memory>

#include "envoy/common/pure.h"
#include "envoy/common/time.h"
#include "envoy/event/schedulable_cb.h"

namespace Envoy {

class ScopeTrackedObject;

namespace Event {

class Dispatcher;

/**
 * Callback invoked when a timer event fires.
 */
using TimerCb = std::function<void()>;

/**
 * An abstract timer event. Free the timer to unregister any pending timeouts. Must be freed before
 * the dispatcher is torn down.
 */
class Timer {
public:
  virtual ~Timer() = default;

  /**
   * Disable a pending timeout without destroying the underlying timer.
   */
  virtual void disableTimer() PURE;

  /**
   * Enable a pending timeout. If a timeout is already pending, it will be reset to the new timeout.
   *
   * @param ms supplies the duration of the alarm in milliseconds.
   * @param object supplies an optional scope for the duration of the alarm.
   */
  virtual void enableTimer(std::chrono::milliseconds ms,
                           const ScopeTrackedObject* object = nullptr) PURE;

  /**
   * Enable a pending high resolution timeout. If a timeout is already pending, it will be reset to
   * the new timeout.
   *
   * @param us supplies the duration of the alarm in microseconds.
   * @param object supplies an optional scope for the duration of the alarm.
   */
  virtual void enableHRTimer(std::chrono::microseconds us,
                             const ScopeTrackedObject* object = nullptr) PURE;
  /**
   * Return whether the timer is currently armed.
   */
  virtual bool enabled() PURE;
};

using TimerPtr = std::unique_ptr<Timer>;

class Scheduler {
public:
  virtual ~Scheduler() = default;

  /**
   * Creates a timer.
   */
  virtual TimerPtr createTimer(const TimerCb& cb, Dispatcher& dispatcher) PURE;
};

using SchedulerPtr = std::unique_ptr<Scheduler>;

/**
 * Interface providing a mechanism to measure time and set timers that run callbacks
 * when the timer fires.
 */
class TimeSystem : public TimeSource {
public:
  ~TimeSystem() override = default;

  using Duration = MonotonicTime::duration;
  using Nanoseconds = std::chrono::nanoseconds;
  using Microseconds = std::chrono::microseconds;
  using Milliseconds = std::chrono::milliseconds;
  using Seconds = std::chrono::seconds;

  /**
   * Creates a timer factory. This indirection enables thread-local timer-queue management,
   * so servers can have a separate timer-factory in each thread.
   */
  virtual SchedulerPtr createScheduler(Scheduler& base_scheduler,
                                       CallbackScheduler& cb_scheduler) PURE;
};

} // namespace Event
} // namespace Envoy
#pragma once

#include <chrono>
#include <ostream>

#include "source/common/common/interval_value.h"

#include "absl/container/flat_hash_map.h"
#include "absl/types/variant.h"

namespace Envoy {
namespace Event {

/**
 * Describes a minimum timer value that is equal to a scale factor applied to the maximum.
 */
struct ScaledMinimum {
  explicit constexpr ScaledMinimum(UnitFloat scale_factor) : scale_factor_(scale_factor) {}
  inline bool operator==(const ScaledMinimum& other) const {
    return other.scale_factor_.value() == scale_factor_.value();
  }
  const UnitFloat scale_factor_;
};

/**
 * Describes a minimum timer value that is an absolute duration.
 */
struct AbsoluteMinimum {
  explicit constexpr AbsoluteMinimum(std::chrono::milliseconds value) : value_(value) {}
  inline bool operator==(const AbsoluteMinimum& other) const { return other.value_ == value_; }
  const std::chrono::milliseconds value_;
};

/**
 * Class that describes how to compute a minimum timeout given a maximum timeout value. It wraps
 * ScaledMinimum and AbsoluteMinimum and provides a single computeMinimum() method.
 */
class ScaledTimerMinimum {
public:
  // Forward arguments to impl_'s constructor.
  constexpr ScaledTimerMinimum(AbsoluteMinimum arg) : impl_(arg) {}
  constexpr ScaledTimerMinimum(ScaledMinimum arg) : impl_(arg) {}

  // Computes the minimum value for a given maximum timeout. If this object was constructed with a
  // - ScaledMinimum value:
  //     the return value is the scale factor applied to the provided maximum.
  // - AbsoluteMinimum:
  //     the return value is that minimum, and the provided maximum is ignored.
  std::chrono::milliseconds computeMinimum(std::chrono::milliseconds maximum) const {
    struct Visitor {
      explicit Visitor(std::chrono::milliseconds value) : value_(value) {}
      std::chrono::milliseconds operator()(ScaledMinimum scale_factor) {
        return std::chrono::duration_cast<std::chrono::milliseconds>(
            scale_factor.scale_factor_.value() * value_);
      }
      std::chrono::milliseconds operator()(AbsoluteMinimum absolute_value) {
        return absolute_value.value_;
      }
      const std::chrono::milliseconds value_;
    };
    return absl::visit(Visitor(maximum), impl_);
  }

  inline bool operator==(const ScaledTimerMinimum& other) const { return impl_ == other.impl_; }

private:
  absl::variant<ScaledMinimum, AbsoluteMinimum> impl_;
};

enum class ScaledTimerType {
  // Timers created with this type will never be scaled. This should only be used for testing.
  UnscaledRealTimerForTest,
  // The amount of time an HTTP connection to a downstream client can remain idle (no streams). This
  // corresponds to the HTTP_DOWNSTREAM_CONNECTION_IDLE TimerType in overload.proto.
  HttpDownstreamIdleConnectionTimeout,
  // The amount of time an HTTP stream from a downstream client can remain idle. This corresponds to
  // the HTTP_DOWNSTREAM_STREAM_IDLE TimerType in overload.proto.
  HttpDownstreamIdleStreamTimeout,
  // The amount of time a connection to a downstream client can spend waiting for the transport to
  // report connection establishment before the connection is closed. This corresponds to the
  // TRANSPORT_SOCKET_CONNECT_TIMEOUT TimerType in overload.proto.
  TransportSocketConnectTimeout,
};

using ScaledTimerTypeMap = absl::flat_hash_map<ScaledTimerType, ScaledTimerMinimum>;
using ScaledTimerTypeMapConstSharedPtr = std::shared_ptr<const ScaledTimerTypeMap>;

} // namespace Event
} // namespace Envoy
#pragma once

#include <functional>
#include <memory>

#include "envoy/common/pure.h"

namespace Envoy {
namespace Event {

/**
 * Callback wrapper that allows direct scheduling of callbacks in the event loop.
 */
class SchedulableCallback {
public:
  virtual ~SchedulableCallback() = default;

  /**
   * Schedule the callback so it runs in the current iteration of the event loop after all events
   * scheduled in the current event loop have had a chance to execute.
   */
  virtual void scheduleCallbackCurrentIteration() PURE;

  /**
   * Schedule the callback so it runs in the next iteration of the event loop. There are no
   * ordering guarantees for callbacks scheduled for the next iteration, not even among
   * next-iteration callbacks.
   */
  virtual void scheduleCallbackNextIteration() PURE;

  /**
   * Cancel pending execution of the callback.
   */
  virtual void cancel() PURE;

  /**
   * Return true whether the SchedulableCallback is scheduled for execution.
   */
  virtual bool enabled() PURE;
};

using SchedulableCallbackPtr = std::unique_ptr<SchedulableCallback>;

/**
 * SchedulableCallback factory.
 */
class CallbackScheduler {
public:
  virtual ~CallbackScheduler() = default;

  /**
   * Create a schedulable callback.
   */
  virtual SchedulableCallbackPtr createSchedulableCallback(const std::function<void()>& cb) PURE;
};

} // namespace Event
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "deferred_deletable",
    hdrs = ["deferred_deletable.h"],
)

envoy_cc_library(
    name = "dispatcher_thread_deletable",
    hdrs = ["dispatcher_thread_deletable.h"],
)

envoy_cc_library(
    name = "dispatcher_interface",
    hdrs = ["dispatcher.h"],
    deps = [
        ":deferred_deletable",
        ":dispatcher_thread_deletable",
        ":file_event_interface",
        ":scaled_timer",
        ":schedulable_cb_interface",
        ":signal_interface",
        ":timer_interface",
        "//envoy/common:scope_tracker_interface",
        "//envoy/common:time_interface",
        "//envoy/filesystem:watcher_interface",
        "//envoy/network:connection_handler_interface",
        "//envoy/network:connection_interface",
        "//envoy/network:dns_interface",
        "//envoy/network:listen_socket_interface",
        "//envoy/network:listener_interface",
        "//envoy/network:transport_socket_interface",
        "//envoy/server:watchdog_interface",
        "//envoy/server/overload:thread_local_overload_state",
        "//envoy/thread:thread_interface",
        "@com_google_absl//absl/functional:any_invocable",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "file_event_interface",
    hdrs = ["file_event.h"],
)

envoy_cc_library(
    name = "scaled_timer",
    hdrs = ["scaled_timer.h"],
    deps = [
        "//source/common/common:interval_value",
    ],
)

envoy_cc_library(
    name = "scaled_range_timer_manager_interface",
    hdrs = ["scaled_range_timer_manager.h"],
    deps = [
        ":scaled_timer",
        ":timer_interface",
    ],
)

envoy_cc_library(
    name = "schedulable_cb_interface",
    hdrs = ["schedulable_cb.h"],
    deps = ["//envoy/common:pure_lib"],
)

envoy_cc_library(
    name = "signal_interface",
    hdrs = ["signal.h"],
)

envoy_cc_library(
    name = "timer_interface",
    hdrs = ["timer.h"],
    deps = [
        ":schedulable_cb_interface",
        "//envoy/common:time_interface",
    ],
)
#pragma once

#include "envoy/common/exception.h"
#include "envoy/common/optref.h"
#include "envoy/common/pure.h"
#include "envoy/runtime/runtime.h"

#include "source/common/protobuf/protobuf.h"

#include "absl/strings/string_view.h"

namespace Envoy {
namespace ProtobufMessage {

/**
 * Exception class for reporting validation errors due to the presence of unknown
 * fields in a protobuf.
 */
class UnknownProtoFieldException : public EnvoyException {
public:
  UnknownProtoFieldException(const std::string& message) : EnvoyException(message) {}
};

/**
 * Exception class for reporting validation errors due to the presence of deprecated
 * fields in a protobuf.
 */
class DeprecatedProtoFieldException : public EnvoyException {
public:
  DeprecatedProtoFieldException(const std::string& message) : EnvoyException(message) {}
};

/**
 * Visitor interface for a Protobuf::Message. The methods of ValidationVisitor are invoked to
 * perform validation based on events encountered during or after the parsing of proto binary
 * or JSON/YAML.
 */
class ValidationVisitor {
public:
  virtual ~ValidationVisitor() = default;

  /**
   * Invoked when an unknown field is encountered.
   * @param description human readable description of the field.
   */
  virtual void onUnknownField(absl::string_view description) PURE;

  /**
   * If true, skip this validation visitor in the interest of speed when
   * possible.
   **/
  virtual bool skipValidation() PURE;

  /**
   * Invoked when deprecated field is encountered.
   * @param description human readable description of the field.
   * @param soft_deprecation is set to true, visitor would log a warning message, otherwise would
   * throw an exception.
   */
  virtual void onDeprecatedField(absl::string_view description, bool soft_deprecation) PURE;

  /**
   * Called when a message or field is marked as work in progress or a message is contained in a
   * proto file marked as work in progress.
   */
  virtual void onWorkInProgress(absl::string_view description) PURE;

  /**
   * Called to update runtime stats on deprecated fields.
   */
  virtual OptRef<Runtime::Loader> runtime() PURE;
};

class ValidationContext {
public:
  virtual ~ValidationContext() = default;

  /**
   * @return ValidationVisitor& the validation visitor for static configuration.
   */
  virtual ValidationVisitor& staticValidationVisitor() PURE;

  /**
   * @return ValidationVisitor& the validation visitor for dynamic configuration.
   */
  virtual ValidationVisitor& dynamicValidationVisitor() PURE;
};

} // namespace ProtobufMessage
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "message_validator_interface",
    hdrs = ["message_validator.h"],
    deps = [
        "//envoy/common:exception_lib",
        "//envoy/runtime:runtime_interface",
        "//source/common/protobuf",
    ],
)
#pragma once

#include <atomic>

#include "envoy/common/pure.h"

#include "source/common/common/assert.h"

namespace Envoy {
namespace Stats {

// Implements a reference-counted pointer to a class, so that its external usage
// model is identical to std::shared_ptr, but the reference count itself is held
// in the class. The class is expected to implement three methods:
//    void incRefCount()
//    bool decRefCount()  -- returns true if the reference count goes to zero.
//    uint32_t use_count()
// It may implement them by delegating to RefcountHelper (see below), or by
// inheriting from RefcountInterface (see below).
//
// TODO(jmarantz): replace this with an absl or std implementation when
// available. See https://github.com/abseil/abseil-cpp/issues/344, issued June
// 26, 2019, and http://wg21.link/p0406, issued 2017. Note that the turnaround
// time for getting an absl API added is measurable in months, and for a std
// API in years.
template <class T> class RefcountPtr {
public:
  RefcountPtr() : ptr_(nullptr) {}

  // Constructing a reference-counted object from a pointer; this is safe to
  // do when the reference-count is held in the object. For example, this code
  // crashes:
  //   {
  //     std::shared_ptr<std::string> a = std::make_shared<std::string>("x");
  //     std::shared_ptr<std::string> b(a.get());
  //   }
  // whereas the analogous code for RefcountPtr works fine.
  RefcountPtr(T* ptr) : ptr_(ptr) {
    if (ptr_ != nullptr) {
      ptr_->incRefCount();
    }
  }

  RefcountPtr(const RefcountPtr& src) : RefcountPtr(src.get()) {}

  // Constructor for up-casting reference-counted pointers. This doesn't change
  // the underlying object; it just upcasts the DerivedClass* in src.ptr_ to a
  // BaseClass* for assignment to this->ptr_. For usage of this to compile,
  // DerivedClass* must be assignable to BaseClass* without explicit casts.
  template <class DerivedClass>
  RefcountPtr(const RefcountPtr<DerivedClass>& src) : RefcountPtr(src.get()) {}

  // Move-construction is used by absl::flat_hash_map during resizes.
  RefcountPtr(RefcountPtr&& src) noexcept : ptr_(src.ptr_) { src.ptr_ = nullptr; }

  RefcountPtr& operator=(const RefcountPtr& src) {
    if (&src != this && src.ptr_ != ptr_) {
      resetInternal();
      ptr_ = src.get();
      if (ptr_ != nullptr) {
        ptr_->incRefCount();
      }
    }
    return *this;
  }

  // Move-assignment is used during std::vector resizes.
  RefcountPtr& operator=(RefcountPtr&& src) noexcept {
    if (&src != this && src.ptr_ != ptr_) {
      resetInternal();
      ptr_ = src.ptr_;
      src.ptr_ = nullptr;
    }
    return *this;
  }

  ~RefcountPtr() { resetInternal(); }

  // Implements required subset of the shared_ptr API;
  // see https://en.cppreference.com/w/cpp/memory/shared_ptr for details.
  T* operator->() const { return ptr_; }
  T* get() const { return ptr_; }
  T& operator*() const { return *ptr_; }
  operator bool() const { return ptr_ != nullptr; }
  bool operator==(const T* ptr) const { return ptr_ == ptr; }
// In C++20, operator!= can be defaulted and returns !(x == y) or !(y == x).
// Defining it prevents the compiler from considering the reversed-operand
// versions of equality comparisons, so leave it to be defaulted.
#if __cplusplus < 202002L
  bool operator!=(const T* ptr) const { return ptr_ != ptr; }
#endif
  bool operator==(const RefcountPtr& a) const { return ptr_ == a.ptr_; }
  bool operator!=(const RefcountPtr& a) const { return ptr_ != a.ptr_; }
  // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDelete)
  uint32_t use_count() const { return ptr_->use_count(); }
  void reset() {
    resetInternal();
    ptr_ = nullptr;
  }

private:
  // Like reset() but does not bother to clear ptr_, as it is about to be
  // overwritten or destroyed.
  void resetInternal() {
    if (ptr_ != nullptr && ptr_->decRefCount()) {
      delete ptr_;
    }
  }

  T* ptr_;
};

// In C++20, reversed-operand versions of comparison operators are considered
// during overload resolution, so these functions are no longer necessary and
// cause segfaults due to attempting to infinitely reverse the operands back and
// forth.
#if __cplusplus < 202002L
template <class T> static bool operator==(std::nullptr_t, const RefcountPtr<T>& a) {
  return a == nullptr; // NOLINT(clang-analyzer-cplusplus.Move)
}
template <class T> static bool operator!=(std::nullptr_t, const RefcountPtr<T>& a) {
  return a != nullptr;
}
#endif

// Helper interface for classes to derive from, enabling implementation of the
// three methods as part of derived classes. It is not necessary to inherit from
// this interface to wrap a class in RefcountPtr; instead the class can just
// implement the same method.
class RefcountInterface {
public:
  virtual ~RefcountInterface() = default;

  /**
   * Increments the reference count.
   */
  virtual void incRefCount() PURE;

  /**
   * Decrements the reference count.
   * @return true if the reference count has gone to zero, so the object should be freed.
   */
  virtual bool decRefCount() PURE;

  /**
   * @return the number of references to the object.
   */
  virtual uint32_t use_count() const PURE;
};

// Delegation helper for RefcountPtr. This can be instantiated in a class, but
// explicit delegation will be needed for each of the three methods.
struct RefcountHelper {
  // Implements the RefcountInterface API.
  void incRefCount() {
    // Note: The ++ref_count_ here and --ref_count_ below have implicit memory
    // orderings of sequentially consistent. Relaxed on addition and
    // acquire/release on subtraction is the typical use for reference
    // counting. On x86, the difference in instruction count is minimal, but the
    // savings are greater on other platforms.
    //
    // https://www.boost.org/doc/libs/1_69_0/doc/html/atomic/usage_examples.html#boost_atomic.usage_examples.example_reference_counters
    ++ref_count_;
  }
  bool decRefCount() {
    ASSERT(ref_count_ >= 1);
    return --ref_count_ == 0;
  }
  uint32_t use_count() const { return ref_count_; }

  std::atomic<uint32_t> ref_count_{0};
};

} // namespace Stats
} // namespace Envoy
#pragma once

#include <string>

#include "envoy/stats/tag.h"

#include "source/common/common/assert.h"
#include "source/common/common/non_copyable.h"

#include "absl/strings/string_view.h"

namespace Envoy {
namespace Stats {

/**
 * Primitive, low-memory-overhead counter with incrementing and latching capabilities. Each
 * increment is added both to a global counter as well as periodic counter. Calling latch()
 * returns the periodic counter and clears it.
 */
class PrimitiveCounter : NonCopyable {
public:
  PrimitiveCounter() = default;

  uint64_t value() const { return value_; }

  void add(uint64_t amount) {
    value_ += amount;
    pending_increment_ += amount;
  }
  void inc() { add(1); }
  void reset() { value_ = 0; }
  uint64_t latch() { return pending_increment_.exchange(0); }

private:
  std::atomic<uint64_t> value_{0};
  std::atomic<uint64_t> pending_increment_{0};
};

using PrimitiveCounterReference = std::reference_wrapper<PrimitiveCounter>;

/**
 * Primitive, low-memory-overhead gauge with increment and decrement capabilities.
 */
class PrimitiveGauge : NonCopyable {
public:
  PrimitiveGauge() = default;

  uint64_t value() const { return value_; }

  void add(uint64_t amount) { value_ += amount; }
  void dec() { sub(1); }
  void inc() { add(1); }
  void set(uint64_t value) { value_ = value; }
  void sub(uint64_t amount) {
    ASSERT(value_ >= amount);
    value_ -= amount;
  }

private:
  std::atomic<uint64_t> value_{0};
};

using PrimitiveGaugeReference = std::reference_wrapper<PrimitiveGauge>;

class PrimitiveMetricMetadata {
public:
  // Mirror some of the API for Stats::Metric for use in templates that
  // accept either Counter/Gauge or PrimitiveCounterSnapshot/PrimitiveGaugeSnapshot.
  const std::string& tagExtractedName() const { return tag_extracted_name_; }
  const std::string& name() const { return name_; }
  const Stats::TagVector& tags() const { return tags_; }
  bool used() const { return true; }
  bool hidden() const { return false; }

  void setName(std::string&& name) { name_ = std::move(name); }
  void setTagExtractedName(std::string&& tag_extracted_name) {
    tag_extracted_name_ = std::move(tag_extracted_name);
  }
  void setTags(const Stats::TagVector& tags) { tags_ = tags; }

private:
  std::string name_;
  std::string tag_extracted_name_;
  Stats::TagVector tags_;
};

class PrimitiveCounterSnapshot : public PrimitiveMetricMetadata {
public:
  PrimitiveCounterSnapshot(PrimitiveCounter& counter)
      : value_(counter.value()), delta_(counter.latch()) {}

  uint64_t value() const { return value_; }
  uint64_t delta() const { return delta_; }

private:
  const uint64_t value_;
  const uint64_t delta_;
};

class PrimitiveGaugeSnapshot : public PrimitiveMetricMetadata {
public:
  PrimitiveGaugeSnapshot(PrimitiveGauge& gauge) : value_(gauge.value()) {}

  uint64_t value() const { return value_; }

private:
  const uint64_t value_;
};

} // namespace Stats
} // namespace Envoy
#pragma once

#include <string>

#include "envoy/stats/histogram.h"
#include "envoy/stats/stats.h"

#include "source/common/stats/symbol_table.h"
#include "source/common/stats/utility.h"

#include "absl/strings/match.h"
#include "absl/strings/str_cat.h"

namespace Envoy {
/**
 * These are helper macros for allocating "fixed" stats throughout the code base in a way that
 * is also easy to mock and test. The general flow looks like this:
 *
 * Define a block of stats like this:
 *   #define MY_COOL_STATS(COUNTER, GAUGE, HISTOGRAM)     \
 *     COUNTER(counter1)                                  \
 *     GAUGE(gauge1, mode)                                \
 *     HISTOGRAM(histogram1, unit)
 *     ...
 *
 * By convention, starting with #7083, we sort the lines of this macro block, so
 * all the counters are grouped together, then all the gauges, etc. We do not
 * use clang-format-on/off etc. "bazel run //tools/code_format:check_format -- fix" will take
 * care of lining up the backslashes.
 *
 * Now actually put these stats somewhere, usually as a member of a struct:
 *   struct MyCoolStats {
 *     MY_COOL_STATS(GENERATE_COUNTER_STRUCT, GENERATE_GAUGE_STRUCT, GENERATE_HISTOGRAM_STRUCT)
 *   };
 *
 * Finally, when you want to actually instantiate the above struct using a Stats::Pool, you do:
 *   MyCoolStats stats{
 *     MY_COOL_STATS(POOL_COUNTER(...), POOL_GAUGE(...), POOL_HISTOGRAM(...))};
 *
 *
 * The above constructs are the simplest way to declare counters, gauges,
 * histograms, and text-readouts in your data structures. However they incur
 * some overhead to symbolize the names every time they are instantiated. For
 * data structures that are re-instantiated extensively during operation,
 * e.g. in response to an xDS update, We can separately instantiate a
 * StatNameStruct, containing symbolized names for each stat. That should be
 * instantiated once at startup and held in some context or factory. Do that
 * with:
 *
 *    MAKE_STAT_NAMES_STRUCT(MyStatNames, MY_COOL_STATS);
 *
 * This generates a structure definition with a constructor that requires a
 * SymbolTable. So you must, in a context instantiated once, initialize with:
 *
 *    : my_cool_stat_names_(stat_store.symbolTable())
 *
 * Once you have the StatNamesStruct instance declared, you can create a stats
 * struct efficiently during operation (e.g. in an xDS handler) with
 *
 *    MAKE_STATS_STRUCT(MyStats, MyStatNames, MY_COOL_STATS);
 *
 * This new structure is constructed with 2 or 3 args:
 *    1. The stat_names struct created from MAKE_STAT_NAMES_STRUCT
 *    2. The scope in which to instantiate the stats
 *    3. An optional prefix, which will be prepended to each stat name.
 * For example:
 *
 *    : my_cool_stats_(context.my_cool_stat_names_, scope, opt_prefix)
 */

// Fully-qualified for use in external callsites.
#define GENERATE_COUNTER_STRUCT(NAME) Envoy::Stats::Counter& NAME##_;
#define GENERATE_GAUGE_STRUCT(NAME, MODE) Envoy::Stats::Gauge& NAME##_;
#define GENERATE_HISTOGRAM_STRUCT(NAME, UNIT) Envoy::Stats::Histogram& NAME##_;
#define GENERATE_TEXT_READOUT_STRUCT(NAME) Envoy::Stats::TextReadout& NAME##_;

#define FINISH_STAT_DECL_(X) #X)),
#define FINISH_STAT_DECL_MODE_(X, MODE) #X), Envoy::Stats::Gauge::ImportMode::MODE),
#define FINISH_STAT_DECL_UNIT_(X, UNIT) #X), Envoy::Stats::Histogram::Unit::UNIT),

static inline std::string statPrefixJoin(absl::string_view prefix, absl::string_view token) {
  if (prefix.empty()) {
    return std::string(token);
  } else if (absl::EndsWith(prefix, ".")) {
    // TODO(jmarantz): eliminate this case -- remove all the trailing dots from prefixes.
    return absl::StrCat(prefix, token);
  }
  return absl::StrCat(prefix, ".", token);
}

#define POOL_COUNTER_PREFIX(POOL, PREFIX) (POOL).counterFromString(Envoy::statPrefixJoin(PREFIX, FINISH_STAT_DECL_
#define POOL_GAUGE_PREFIX(POOL, PREFIX) (POOL).gaugeFromString(Envoy::statPrefixJoin(PREFIX, FINISH_STAT_DECL_MODE_
#define POOL_HISTOGRAM_PREFIX(POOL, PREFIX) (POOL).histogramFromString(Envoy::statPrefixJoin(PREFIX, FINISH_STAT_DECL_UNIT_
#define POOL_TEXT_READOUT_PREFIX(POOL, PREFIX) (POOL).textReadoutFromString(Envoy::statPrefixJoin(PREFIX, FINISH_STAT_DECL_
#define POOL_STAT_NAME_PREFIX(POOL, PREFIX) (POOL).symbolTable().textReadoutFromString(Envoy::statPrefixJoin(PREFIX, FINISH_STAT_DECL_

#define POOL_COUNTER(POOL) POOL_COUNTER_PREFIX(POOL, "")
#define POOL_GAUGE(POOL) POOL_GAUGE_PREFIX(POOL, "")
#define POOL_HISTOGRAM(POOL) POOL_HISTOGRAM_PREFIX(POOL, "")
#define POOL_TEXT_READOUT(POOL) POOL_TEXT_READOUT_PREFIX(POOL, "")

#define NULL_STAT_DECL_(X) std::string(#X)),
#define NULL_STAT_DECL_IGNORE_MODE_(X, MODE) std::string(#X)),

#define NULL_POOL_GAUGE(POOL) (POOL).nullGauge(NULL_STAT_DECL_IGNORE_MODE_

// Used for declaring StatNames in a structure.
#define GENERATE_STAT_NAME_STRUCT(NAME, ...) Envoy::Stats::StatName NAME##_;
#define GENERATE_STAT_NAME_INIT(NAME, ...) , NAME##_(pool_.add(#NAME))

// Used for defining constrcutors of stat objects
#define GENERATE_CONSTRUCTOR_PARAM(NAME) Envoy::Stats::Counter &NAME,
#define GENERATE_CONSTRUCTOR_COUNTER_PARAM(NAME) Envoy::Stats::Counter &NAME,
#define GENERATE_CONSTRUCTOR_GAUGE_PARAM(NAME, ...) Envoy::Stats::Gauge &NAME,
#define GENERATE_CONSTRUCTOR_INIT_LIST(NAME, ...) , NAME##_(NAME)

// Macros for declaring stat-structures using StatNames, for those that must be
// instantiated during operation, and where speed and scale matters. These
// macros are not for direct use; they are only for use from
// MAKE_STAT_NAMES_STRUCT. and MAKE_STAT_STRUCT.
#define MAKE_STATS_STRUCT_COUNTER_HELPER_(NAME)                                                    \
  , NAME##_(Envoy::Stats::Utility::counterFromStatNames(scope, {prefix, stat_names.NAME##_}))
#define MAKE_STATS_STRUCT_GAUGE_HELPER_(NAME, MODE)                                                \
  , NAME##_(Envoy::Stats::Utility::gaugeFromStatNames(scope, {prefix, stat_names.NAME##_},         \
                                                      Envoy::Stats::Gauge::ImportMode::MODE))
#define MAKE_STATS_STRUCT_HISTOGRAM_HELPER_(NAME, UNIT)                                            \
  , NAME##_(Envoy::Stats::Utility::histogramFromStatNames(scope, {prefix, stat_names.NAME##_},     \
                                                          Envoy::Stats::Histogram::Unit::UNIT))
#define MAKE_STATS_STRUCT_TEXT_READOUT_HELPER_(NAME)                                               \
  , NAME##_(Envoy::Stats::Utility::textReadoutFromStatNames(scope, {prefix, stat_names.NAME##_}))

#define MAKE_STATS_STRUCT_STATNAME_HELPER_(name)
#define GENERATE_STATNAME_STRUCT(name)

/**
 * Generates a struct with StatNames for a subsystem, based on the stats macro
 * with COUNTER, GAUGE, HISTOGRAM, TEXT_READOUT, and STATNAME calls. The
 * ALL_STATS macro must have all 5 parameters.
 */
#define MAKE_STAT_NAMES_STRUCT(StatNamesStruct, ALL_STATS)                                         \
  struct StatNamesStruct {                                                                         \
    explicit StatNamesStruct(Envoy::Stats::SymbolTable& symbol_table)                              \
        : pool_(symbol_table)                                                                      \
              ALL_STATS(GENERATE_STAT_NAME_INIT, GENERATE_STAT_NAME_INIT, GENERATE_STAT_NAME_INIT, \
                        GENERATE_STAT_NAME_INIT, GENERATE_STAT_NAME_INIT) {}                       \
    Envoy::Stats::StatNamePool pool_;                                                              \
    ALL_STATS(GENERATE_STAT_NAME_STRUCT, GENERATE_STAT_NAME_STRUCT, GENERATE_STAT_NAME_STRUCT,     \
              GENERATE_STAT_NAME_STRUCT, GENERATE_STAT_NAME_STRUCT)                                \
  }

/**
 * Instantiates a structure of stats based on a new scope and optional prefix,
 * using a predefined structure of stat names. A reference to the stat_names is
 * also stored in the structure, for two reasons: (a) as a syntactic convenience
 * for using macros to generate the comma separators for the initializer and (b)
 * as a convenience at the call-site to access STATNAME-declared names from the
 * stats structure.
 */
#define MAKE_STATS_STRUCT(StatsStruct, StatNamesStruct, ALL_STATS)                                 \
  struct StatsStruct {                                                                             \
    /* Also referenced in Stats::createDeferredCompatibleStats. */                                 \
    using StatNameType = StatNamesStruct;                                                          \
    static const absl::string_view typeName() { return #StatsStruct; }                             \
    StatsStruct(const StatNamesStruct& stat_names, Envoy::Stats::Scope& scope,                     \
                Envoy::Stats::StatName prefix = Envoy::Stats::StatName())                          \
        : stat_names_(stat_names)                                                                  \
              ALL_STATS(MAKE_STATS_STRUCT_COUNTER_HELPER_, MAKE_STATS_STRUCT_GAUGE_HELPER_,        \
                        MAKE_STATS_STRUCT_HISTOGRAM_HELPER_,                                       \
                        MAKE_STATS_STRUCT_TEXT_READOUT_HELPER_,                                    \
                        MAKE_STATS_STRUCT_STATNAME_HELPER_) {}                                     \
    const StatNameType& stat_names_;                                                               \
    ALL_STATS(GENERATE_COUNTER_STRUCT, GENERATE_GAUGE_STRUCT, GENERATE_HISTOGRAM_STRUCT,           \
              GENERATE_TEXT_READOUT_STRUCT, GENERATE_STATNAME_STRUCT)                              \
  }
} // namespace Envoy
#pragma once

#include <string>

#include "absl/types/optional.h"

namespace Envoy {
namespace Stats {

class StatName;

/**
 * General representation of a tag.
 */
struct Tag {
  std::string name_;
  std::string value_;

  bool operator==(const Tag& other) const {
    return other.name_ == name_ && other.value_ == value_;
  };
};

using TagVector = std::vector<Tag>;

using StatNameTag = std::pair<StatName, StatName>;
using StatNameTagVector = std::vector<StatNameTag>;
using StatNameTagVectorOptConstRef =
    absl::optional<std::reference_wrapper<const StatNameTagVector>>;

} // namespace Stats
} // namespace Envoy
#pragma once

#include "envoy/stats/primitive_stats.h"

#include "absl/strings/string_view.h"

namespace Envoy {
/**
 * These are helper macros for allocating "fixed" stats throughout the code base in a way that
 * is also easy to mock and test. The general flow looks like this:
 *
 * Define a block of stats like this:
 *   #define MY_COOL_STATS(COUNTER, GAUGE)     \
 *     COUNTER(counter1)                       \
 *     GAUGE(gauge1)                           \
 *     ...
 *
 * By convention, starting with #7083, we sort the lines of this macro block, so
 * all the counters are grouped together, then all the gauges, etc. We do not
 * use clang-format-on/off etc. "bazel run //tools/code_format:check_format -- fix" will take
 * care of lining up the backslashes.
 *
 * Now actually put these stats somewhere, usually as a member of a struct:
 *   struct MyCoolStats {
 *     MY_COOL_STATS(GENERATE_PRIMITIVE_COUNTER_STRUCT, GENERATE_PRIMITIVE_GAUGE_STRUCT);
 *
 *     // Optional: Provide access to counters as a map.
 *     std::vector<std::pair<absl::string_view, PrimitiveCounterReference>> counters() const {
 *       return {MY_COOL_STATS(PRIMITIVE_COUNTER_NAME_AND_REFERENCE, IGNORE_PRIMITIVE_GAUGE)};
 *     }
 *
 *     // Optional: Provide access to gauges as a map.
 *     std::vector<std::pair<absl::string_view, PrimitiveGaugeReference>> gauges() const {
 *       return {MY_COOL_STATS(IGNORE_PRIMITIVE_COUNTER, PRIMITIVE_GAUGE_NAME_AND_REFERENCE)};
 *     }
 *   };
 *
 * Finally, when you want to actually instantiate the above struct you do:
 *   MyCoolStats stats;
 */

// Fully-qualified for use in external callsites.
#define GENERATE_PRIMITIVE_COUNTER_STRUCT(NAME) Envoy::Stats::PrimitiveCounter NAME##_;
#define GENERATE_PRIMITIVE_GAUGE_STRUCT(NAME) Envoy::Stats::PrimitiveGauge NAME##_;

// Name and counter/gauge reference pair used to construct map of counters/gauges.
#define PRIMITIVE_COUNTER_NAME_AND_REFERENCE(X) {absl::string_view(#X), std::ref(X##_)},
#define PRIMITIVE_GAUGE_NAME_AND_REFERENCE(X) {absl::string_view(#X), std::ref(X##_)},

// Ignore a counter or gauge.
#define IGNORE_PRIMITIVE_COUNTER(X)
#define IGNORE_PRIMITIVE_GAUGE(X)

} // namespace Envoy
#pragma once

#include <memory>
#include <string>
#include <vector>

#include "envoy/common/interval_set.h"
#include "envoy/common/pure.h"
#include "envoy/stats/tag.h"

#include "absl/strings/string_view.h"

namespace Envoy {
namespace Stats {

class TagExtractionContext;

/**
 * Class to extract tags from the stat names.
 */
class TagExtractor {
public:
  virtual ~TagExtractor() = default;

  /**
   * Identifier for the tag extracted by this object.
   */
  virtual absl::string_view name() const PURE;

  /**
   * Finds tags for stat_name and adds them to the tags vector. If the tag is not
   * represented in the name, the tags vector will remain unmodified. Also finds the
   * character indexes for the tags in stat_name and adds them to remove_characters (an
   * in/out arg). Returns true if a tag-match was found. The characters removed from the
   * name may be different from the values put into the tag vector for readability
   * purposes. Note: The extraction process is expected to be run iteratively, aggregating
   * the character intervals to be removed from the name after all the tag extractions are
   * complete. This approach simplifies the tag searching process because without mutations,
   * the tag extraction will be order independent, apart from the order of the tag array.
   * @param context identifies the name from which to extract tags.
   * @param tags list of tags updated with the tag name and value if found in the name.
   * @param remove_characters set of intervals of character-indices to be removed from name.
   * @return bool indicates whether a tag was found in the name.
   */
  virtual bool extractTag(TagExtractionContext& context, TagVector& tags,
                          IntervalSet<size_t>& remove_characters) const PURE;

  /**
   * Finds a prefix string associated with the matching criteria owned by the
   * extractor. This is used to reduce the number of extractors required for
   * processing each stat, by pulling the first "."-separated token on the tag.
   *
   * If a prefix cannot be extracted, an empty string_view is returned, and the
   * matcher must be applied on all inputs.
   *
   * The storage for the prefix is owned by the TagExtractor.
   *
   * @return absl::string_view the prefix, or an empty string_view if none was found.
   */
  virtual absl::string_view prefixToken() const PURE;

  virtual bool otherExtractorWithSameNameExists() const PURE;
  virtual void setOtherExtractorWithSameNameExists(bool e) PURE;
};

using TagExtractorPtr = std::unique_ptr<TagExtractor>;

} // namespace Stats
} // namespace Envoy
#pragma once

#include "envoy/common/pure.h"

#include "absl/strings/string_view.h"
#include "absl/types/optional.h"

namespace Envoy {
namespace Stats {

/**
 * CustomStatNamespaces manages custom stat namespaces. Custom stat namespaces are registered
 * by extensions that create user-defined metrics, and these metrics are all prefixed
 * by the namespace. For example, Wasm extension registers "wasmcustom" as a custom stat namespace,
 * and all the metrics created by user Wasm programs are prefixed by "wasmcustom." internally.
 * This is mainly for distinguishing these "custom metrics" defined outside Envoy codebase from
 * the native metrics defined by Envoy codebase, and this way stat sinks are able to determine
 * how to expose these two kinds of metrics.
 * Note that the implementation will not be thread-safe so users of this class must be in the main
 * thread.
 */
class CustomStatNamespaces {
public:
  virtual ~CustomStatNamespaces() = default;

  /**
   * @param name is the name to check.
   * @return true if the given name is registered as a custom stat namespace, false otherwise.
   */
  virtual bool registered(const absl::string_view name) const PURE;

  /**
   * Used to register a custom namespace by extensions.
   * @param name is the name to register.
   */
  virtual void registerStatNamespace(const absl::string_view name) PURE;

  /**
   * Strips the registered custom stat namespace from the given stat name's prefix if it lives in a
   * registered custom stat namespace, and the stripped string is returned. Otherwise return
   * nullopt.
   * @param stat_name is the view to modify. If it is not in any custom registered namespaces, it
   * will never be modified.
   * @return the stripped string if stat_name has a registered custom stat namespace. Otherwise,
   * return nullopt.
   */
  virtual absl::optional<absl::string_view>
  stripRegisteredPrefix(const absl::string_view stat_name) const PURE;
};

} // namespace Stats
} // namespace Envoy
#pragma once

#include <memory>
#include <string>
#include <vector>

#include "envoy/common/pure.h"

namespace Envoy {
namespace Stats {

class StatName;

class StatsMatcher {
public:
  // Holds the result of fastRejects(). This contains state that must be then
  // passed to slowRejects() for the final 2-phase determination of whether a
  // stat can be rejected.
  enum class FastResult {
    NoMatch,
    Rejects,
    Matches,
  };

  virtual ~StatsMatcher() = default;

  /**
   * Take a metric name and report whether or not it should be instantiated.
   * This may need to convert the StatName to a string. This is equivalent to
   * calling fastRejects() and then calling slowResults() if necessary.
   *
   * @param name the name of a Stats::Metric.
   * @return bool true if that stat should not be instantiated.
   */
  virtual bool rejects(StatName name) const PURE;

  /**
   * Takes a metric name and quickly determines whether it can be rejected based
   * purely on the StatName. If fastResults(stat_name).rejects() is 'false', we
   * will need to check slowRejects as well. It should not be necessary to cache
   * the result of fastRejects() -- it's cheap enough to recompute. However we
   * should protect slowRejects() by a cache due to its speed and the potential
   * need to take a symbol table lock.
   *
   * @param name the name of a Stats::Metric.
   * @return A result indicating whether the stat can be quickly rejected, as
   *         well as state that is then passed to slowRejects if rejection
   *         cannot be quickly determined.
   */
  virtual FastResult fastRejects(StatName name) const PURE;

  /**
   * Takes a metric name and converts it to a string, if needed, to determine
   * whether it needs to be rejected. This is intended to be used if
   * fastRejects() cannot determine an early rejection. It is a good idea to
   * cache the results of this, to avoid the stringification overhead, potential
   * regex overhead, plus a global symbol table lock.
   *
   * @param fast_result the result of fastRejects(), which must be called first.
   * @param name the name of a Stats::Metric.
   * @return bool true if that stat should not be instantiated.
   */
  virtual bool slowRejects(FastResult fast_result, StatName name) const PURE;

  /**
   * Helps determine whether the matcher needs to be called. This can be used
   * to short-circuit elaboration of stats names.
   *
   * @return bool whether StatsMatcher can be statically determined to accept
   *              all stats. It's possible to construct a matcher where
   *              acceptsAll() returns false, but rejects() is always false.
   */
  virtual bool acceptsAll() const PURE;

  /**
   * Helps determine whether the matcher needs to be called. This can be used
   * to short-circuit elaboration of stats names.
   *
   * @return bool whether StatsMatcher can be statically determined to reject
   *              all stats. It's possible to construct a matcher where
   *              rejectsAll() returns false, but rejects() is always true.
   */
  virtual bool rejectsAll() const PURE;
};

using StatsMatcherPtr = std::unique_ptr<const StatsMatcher>;

} // namespace Stats
} // namespace Envoy
#pragma once

#include <cstdint>
#include <memory>

#include "envoy/common/pure.h"
#include "envoy/common/time.h"
#include "envoy/stats/histogram.h"
#include "envoy/stats/primitive_stats.h"
#include "envoy/stats/stats.h"

namespace Envoy {
namespace Stats {

class Histogram;

class MetricSnapshot {
public:
  struct CounterSnapshot {
    uint64_t delta_;
    std::reference_wrapper<const Counter> counter_;
  };

  virtual ~MetricSnapshot() = default;

  /**
   * @return a snapshot of all counters with pre-latched deltas.
   */
  virtual const std::vector<CounterSnapshot>& counters() PURE;

  /**
   * @return a snapshot of all gauges.
   */
  virtual const std::vector<std::reference_wrapper<const Gauge>>& gauges() PURE;

  /**
   * @return a snapshot of all histograms.
   */
  virtual const std::vector<std::reference_wrapper<const ParentHistogram>>& histograms() PURE;

  /**
   * @return a snapshot of all text readouts.
   */
  virtual const std::vector<std::reference_wrapper<const TextReadout>>& textReadouts() PURE;

  /**
   * @return a snapshot of all host/endpoint-specific primitive counters.
   */
  virtual const std::vector<Stats::PrimitiveCounterSnapshot>& hostCounters() PURE;

  /**
   * @return a snapshot of all host/endpoint-specific primitive gauges.
   */
  virtual const std::vector<Stats::PrimitiveGaugeSnapshot>& hostGauges() PURE;

  /**
   * @return the time in UTC since epoch when the snapshot was created.
   */
  virtual SystemTime snapshotTime() const PURE;
};

/**
 * A class to define predicates to filter counters, gauges and text readouts for flushing to sinks.
 */
class SinkPredicates {
public:
  virtual ~SinkPredicates() = default;

  /**
   * @return true if @param counter needs to be flushed to sinks.
   */
  virtual bool includeCounter(const Counter& counter) PURE;

  /**
   * @return true if @param gauge needs to be flushed to sinks.
   */
  virtual bool includeGauge(const Gauge& gauge) PURE;

  /**
   * @return true if @param text_readout needs to be flushed to sinks.
   */
  virtual bool includeTextReadout(const TextReadout& text_readout) PURE;

  /*
   * @return true if @param histogram needs to be flushed to sinks.
   * Note that this is used only if runtime flag envoy.reloadable_features.enable_include_histograms
   * (which is false by default) is set to true.
   */
  virtual bool includeHistogram(const Histogram& histogram) PURE;
};

/**
 * A sink for stats. Each sink is responsible for writing stats to a backing store.
 */
class Sink {
public:
  virtual ~Sink() = default;

  /**
   * Periodic metric flush to the sink.
   * @param snapshot interface through which the sink can access all metrics being flushed.
   */
  virtual void flush(MetricSnapshot& snapshot) PURE;

  /**
   * Flush a single histogram sample. Note: this call is called synchronously as a part of recording
   * the metric, so implementations must be thread-safe.
   * @param histogram the histogram that this sample applies to.
   * @param value the value of the sample.
   */
  virtual void onHistogramComplete(const Histogram& histogram, uint64_t value) PURE;
};

using SinkPtr = std::unique_ptr<Sink>;

} // namespace Stats
} // namespace Envoy
#pragma once

#include <chrono>
#include <cstdint>
#include <functional>
#include <list>
#include <memory>
#include <string>
#include <vector>

#include "envoy/common/pure.h"
#include "envoy/stats/stats.h"
#include "envoy/stats/tag.h"

#include "absl/strings/string_view.h"

namespace Envoy {
namespace Stats {

class Sink;
class SinkPredicates;

/**
 * Abstract interface for allocating statistics. Implementations can
 * be created utilizing a single fixed-size block suitable for
 * shared-memory, or in the heap, allowing for pointers and sharing of
 * substrings, with an opportunity for reduced memory consumption.
 */
class Allocator {
public:
  virtual ~Allocator() = default;

  /**
   * @param name the full name of the stat.
   * @param tag_extracted_name the name of the stat with tag-values stripped out.
   * @param tags the tag values.
   * @return CounterSharedPtr a counter.
   */
  virtual CounterSharedPtr makeCounter(StatName name, StatName tag_extracted_name,
                                       const StatNameTagVector& stat_name_tags) PURE;

  /**
   * @param name the full name of the stat.
   * @param tag_extracted_name the name of the stat with tag-values stripped out.
   * @param stat_name_tags the tag values.
   * @return GaugeSharedPtr a gauge.
   */
  virtual GaugeSharedPtr makeGauge(StatName name, StatName tag_extracted_name,
                                   const StatNameTagVector& stat_name_tags,
                                   Gauge::ImportMode import_mode) PURE;

  /**
   * @param name the full name of the stat.
   * @param tag_extracted_name the name of the stat with tag-values stripped out.
   * @param tags the tag values.
   * @return TextReadoutSharedPtr a text readout.
   */
  virtual TextReadoutSharedPtr makeTextReadout(StatName name, StatName tag_extracted_name,
                                               const StatNameTagVector& stat_name_tags) PURE;
  virtual const SymbolTable& constSymbolTable() const PURE;
  virtual SymbolTable& symbolTable() PURE;

  /**
   * Mark rejected stats as deleted by moving them to a different vector, so they don't show up
   * when iterating over stats, but prevent crashes when trying to access references to them.
   * Note that allocating a stat with the same name after calling this will
   * return a new stat. Hence callers should seek to avoid this situation, as is
   * done in ThreadLocalStore.
   */
  virtual void markCounterForDeletion(const CounterSharedPtr& counter) PURE;
  virtual void markGaugeForDeletion(const GaugeSharedPtr& gauge) PURE;
  virtual void markTextReadoutForDeletion(const TextReadoutSharedPtr& text_readout) PURE;

  /**
   * Iterate over all stats. Note, that implementations can potentially hold on to a mutex that
   * will deadlock if the passed in functors try to create or delete a stat.
   * @param f_size functor that is provided the current number of all stats. Note that this is
   * called only once, prior to any calls to f_stat.
   * @param f_stat functor that is provided one stat at a time from the stats container.
   */
  virtual void forEachCounter(SizeFn f_size, StatFn<Counter> f_stat) const PURE;
  virtual void forEachGauge(SizeFn f_size, StatFn<Gauge> f_stat) const PURE;
  virtual void forEachTextReadout(SizeFn f_size, StatFn<TextReadout> f_stat) const PURE;

  /**
   * Iterate over all stats that need to be flushed to sinks. Note, that implementations can
   * potentially hold on to a mutex that will deadlock if the passed in functors try to create
   * or delete a stat.
   * @param f_size functor that is provided the number of all stats that will be flushed to sinks.
   * Note that this is called only once, prior to any calls to f_stat.
   * @param f_stat functor that is provided one stat that will be flushed to sinks, at a time.
   */
  virtual void forEachSinkedCounter(SizeFn f_size, StatFn<Counter> f_stat) const PURE;
  virtual void forEachSinkedGauge(SizeFn f_size, StatFn<Gauge> f_stat) const PURE;
  virtual void forEachSinkedTextReadout(SizeFn f_size, StatFn<TextReadout> f_stat) const PURE;

  /**
   * Set the predicates to filter stats for sink.
   */
  virtual void setSinkPredicates(std::unique_ptr<SinkPredicates>&& sink_predicates) PURE;

  // TODO(jmarantz): create a parallel mechanism to instantiate histograms. At
  // the moment, histograms don't fit the same pattern of counters and gauges
  // as they are not actually created in the context of a stats allocator.
};

} // namespace Stats
} // namespace Envoy
#pragma once

#include <cstdint>
#include <memory>
#include <vector>

#include "envoy/common/pure.h"
#include "envoy/stats/refcount_ptr.h"
#include "envoy/stats/stats.h"

namespace Envoy {
namespace Stats {

using ConstSupportedBuckets = const std::vector<double>;

class HistogramSettings {
public:
  virtual ~HistogramSettings() = default;

  /**
   * For formats like Prometheus where the entire histogram is published (but not
   * like statsd where each value to include in the histogram is emitted separately),
   * get the limits for each histogram bucket.
   * @return The buckets for the histogram. Each value is an upper bound of a bucket.
   */
  virtual ConstSupportedBuckets& buckets(absl::string_view stat_name) const PURE;
};

using HistogramSettingsConstPtr = std::unique_ptr<const HistogramSettings>;

/**
 * Holds the computed statistics for a histogram.
 */
class HistogramStatistics {
public:
  virtual ~HistogramStatistics() = default;

  /**
   * Returns quantile summary representation of the histogram.
   */
  virtual std::string quantileSummary() const PURE;

  /**
   * Returns bucket summary representation of the histogram.
   */
  virtual std::string bucketSummary() const PURE;

  /**
   * Returns supported quantiles.
   */
  virtual const std::vector<double>& supportedQuantiles() const PURE;

  /**
   * Returns computed quantile values during the period.
   */
  virtual const std::vector<double>& computedQuantiles() const PURE;

  /**
   * Returns supported buckets. Each value is the upper bound of the bucket
   * with 0 as the implicit lower bound. For timers, these bucket thresholds
   * are in milliseconds but the thresholds are applicable to all types of data.
   */
  virtual ConstSupportedBuckets& supportedBuckets() const PURE;

  /**
   * Returns computed bucket values during the period. The vector contains an approximation
   * of samples below each quantile bucket defined in supportedBuckets(). This vector is
   * guaranteed to be the same length as supportedBuckets().
   */
  virtual const std::vector<uint64_t>& computedBuckets() const PURE;

  /**
   * Returns version of computedBuckets() with disjoint buckets. This vector is
   * guaranteed to be the same length as supportedBuckets().
   */
  virtual std::vector<uint64_t> computeDisjointBuckets() const PURE;

  /**
   * Returns number of values during the period. This number may be an approximation
   * of the number of samples in the histogram, it is not guaranteed that this will be
   * 100% the number of samples observed.
   */
  virtual uint64_t sampleCount() const PURE;

  /**
   * Returns sum of all values during the period.
   */
  virtual double sampleSum() const PURE;

  /**
   * Returns the count of values which are out of the boundaries of the histogram bins.
   * I.e., the count of values in the (bound_of_last_bucket, +inf) bucket.
   */
  virtual uint64_t outOfBoundCount() const PURE;
};

/**
 * A histogram that records values one at a time.
 * Note: Histograms now incorporate what used to be timers because the only
 * difference between the two stat types was the units being represented.
 */
class Histogram : public Metric {
public:
  /**
   * Histogram values represent scalar quantity like time, length, mass,
   * distance, or in general anything which has only magnitude and no other
   * characteristics. These are often accompanied by a unit of measurement.
   * This enum defines units for commonly measured quantities. Base units
   * are preferred unless they are not granular enough to be useful as an
   * integer.
   */
  enum class Unit {
    Null,        // The histogram has been rejected, i.e. it's a null histogram and is not recording
                 // anything.
    Unspecified, // Measured quantity does not require a unit, e.g. "items".
    Bytes,
    Microseconds,
    Milliseconds,
    Percent, // A percent value stored as fixed-point, where the stored value is divided by
             // PercentScale to get the actual value, eg a value of 100% (or 1.0) is encoded as
             // PercentScale, 50% is encoded as PercentScale * 0.5. Encoding as fixed-point allows
             // enough dynamic range, without needing to support floating-point values in
             // histograms.
  };

  // The scaling factor for Unit::Percent.
  static constexpr uint64_t PercentScale = 1000000;

  ~Histogram() override = default;

  /**
   * @return the unit of measurement for values recorded by the histogram.
   */
  virtual Unit unit() const PURE;

  /**
   * Records an unsigned value in the unit specified during the construction.
   */
  virtual void recordValue(uint64_t value) PURE;
};

using HistogramSharedPtr = RefcountPtr<Histogram>;

/**
 * A histogram that is stored in main thread and provides summary view of the histogram.
 */
class ParentHistogram : public Histogram {
public:
  ~ParentHistogram() override = default;

  /**
   * This method is called during the main stats flush process for each of the histograms and used
   * to merge the histogram values.
   */
  virtual void merge() PURE;

  /**
   * Returns the interval histogram summary statistics for the flush interval.
   */
  virtual const HistogramStatistics& intervalStatistics() const PURE;

  /**
   * Returns the cumulative histogram summary statistics.
   */
  virtual const HistogramStatistics& cumulativeStatistics() const PURE;

  /**
   * Returns the quantile summary representation.
   */
  virtual std::string quantileSummary() const PURE;

  /**
   * Returns the bucket summary representation.
   */
  virtual std::string bucketSummary() const PURE;

  // Holds detailed value and counts for a histogram bucket.
  struct Bucket {
    double lower_bound_{0}; // Bound of bucket that's closest to zero.
    double width_{0};
    uint64_t count_{0};
  };

  /**
   * @return a vector of histogram buckets collected since binary start or reset.
   */
  virtual std::vector<Bucket> detailedTotalBuckets() const PURE;

  /**
   * @return bucket data collected since the most recent stat sink. Note that
   *         the number of interval buckets is likely to be much smaller than
   *         the number of detailed buckets.
   */
  virtual std::vector<Bucket> detailedIntervalBuckets() const PURE;
};

using ParentHistogramSharedPtr = RefcountPtr<ParentHistogram>;

} // namespace Stats
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "refcount_ptr_interface",
    hdrs = ["refcount_ptr.h"],
    deps = ["//source/common/common:assert_lib"],
)

envoy_cc_library(
    name = "tag_interface",
    hdrs = ["tag.h"],
)

# TODO(jmarantz): atomize the build rules to match the include files.
envoy_cc_library(
    name = "stats_interface",
    hdrs = [
        "allocator.h",
        "histogram.h",
        "scope.h",
        "stats.h",
        "stats_matcher.h",
        "store.h",
        "tag_extractor.h",
        "tag_producer.h",
    ],
    external_deps = ["abseil_inlined_vector"],
    deps = [
        ":refcount_ptr_interface",
        ":tag_interface",
        "//envoy/common:interval_set_interface",
        "//envoy/common:optref_lib",
        "//envoy/common:time_interface",
    ],
)

envoy_cc_library(
    name = "sink_interface",
    hdrs = ["sink.h"],
    deps = [
        ":primitive_stats_interface",
        ":stats_interface",
    ],
)

envoy_cc_library(
    name = "primitive_stats_interface",
    hdrs = [
        "primitive_stats.h",
    ],
    deps = [
        ":tag_interface",
        "//source/common/common:assert_lib",
        "//source/common/common:non_copyable",
    ],
)

envoy_cc_library(
    name = "timespan_interface",
    hdrs = ["timespan.h"],
)

envoy_cc_library(
    name = "stats_macros",
    hdrs = ["stats_macros.h"],
    deps = [
        ":stats_interface",
        "//source/common/stats:symbol_table_lib",
        "//source/common/stats:utility_lib",
    ],
)

envoy_cc_library(
    name = "primitive_stats_macros",
    hdrs = ["primitive_stats_macros.h"],
    deps = [":primitive_stats_interface"],
)

envoy_cc_library(
    name = "custom_stat_namespaces_interface",
    hdrs = ["custom_stat_namespaces.h"],
)
#pragma once

#include <cstdint>
#include <functional>
#include <memory>

#include "envoy/common/pure.h"
#include "envoy/stats/histogram.h"
#include "envoy/stats/tag.h"

#include "absl/types/optional.h"

namespace Envoy {
namespace Stats {

class Counter;
class Gauge;
class Histogram;
class NullGaugeImpl;
class Scope;
class Store;
class TextReadout;

using CounterOptConstRef = absl::optional<std::reference_wrapper<const Counter>>;
using GaugeOptConstRef = absl::optional<std::reference_wrapper<const Gauge>>;
using HistogramOptConstRef = absl::optional<std::reference_wrapper<const Histogram>>;
using TextReadoutOptConstRef = absl::optional<std::reference_wrapper<const TextReadout>>;
using ConstScopeSharedPtr = std::shared_ptr<const Scope>;
using ScopeSharedPtr = std::shared_ptr<Scope>;

template <class StatType> using IterateFn = std::function<bool(const RefcountPtr<StatType>&)>;

/**
 * A named scope for stats. Scopes are a grouping of stats that can be acted on
 * as a unit if needed (for example to free/delete all of them).
 *
 * Every counters, gauges, histograms, and text-readouts is managed by a Scope.
 *
 * Scopes are managed by shared pointers. This makes it possible for the admin
 * stats handler to safely capture all the scope references and remain robust to
 * other threads deleting those scopes while rendering an admin stats page.
 *
 * It is invalid to allocate a Scope using std::unique_ptr or directly on the
 * stack.
 *
 * We use std::shared_ptr rather than Stats::RefcountPtr, which we use for other
 * stats, because:
 *  * existing uses of shared_ptr<Scope> exist in the Wasm extension and would
 *    need to be rewritten to allow for RefcountPtr<Scope>.
 *  * the main advantage of RefcountPtr is it's smaller per instance by 16
 *    bytes, but there are not typically enough scopes that the extra per-scope
 *    overhead would matter.
 *  * It's a little less coding to use enable_shared_from_this compared to
 *    adding a ref_count to the scope object, for each of its implementations.
 */
class Scope : public std::enable_shared_from_this<Scope> {
public:
  virtual ~Scope() = default;

  /** @return a shared_ptr for this */
  ScopeSharedPtr getShared() { return shared_from_this(); }

  /** @return a const shared_ptr for this */
  ConstScopeSharedPtr getConstShared() const { return shared_from_this(); }

  /**
   * Allocate a new scope. NOTE: The implementation should correctly handle overlapping scopes
   * that point to the same reference counted backing stats. This allows a new scope to be
   * gracefully swapped in while an old scope with the same name is being destroyed.
   *
   * See also scopeFromStatName, which is preferred.
   *
   * @param name supplies the scope's namespace prefix.
   */
  virtual ScopeSharedPtr createScope(const std::string& name) PURE;

  /**
   * Allocate a new scope. NOTE: The implementation should correctly handle overlapping scopes
   * that point to the same reference counted backing stats. This allows a new scope to be
   * gracefully swapped in while an old scope with the same name is being destroyed.
   *
   * @param name supplies the scope's namespace prefix.
   */
  virtual ScopeSharedPtr scopeFromStatName(StatName name) PURE;

  /**
   * Creates a Counter from the stat name. Tag extraction will be performed on the name.
   * @param name The name of the stat, obtained from the SymbolTable.
   * @return a counter within the scope's namespace.
   */
  Counter& counterFromStatName(const StatName& name) {
    return counterFromStatNameWithTags(name, absl::nullopt);
  }
  /**
   * Creates a Counter from the stat name and tags. If tags are not provided, tag extraction
   * will be performed on the name.
   * @param name The name of the stat, obtained from the SymbolTable.
   * @param tags optionally specified tags.
   * @return a counter within the scope's namespace.
   */
  virtual Counter& counterFromStatNameWithTags(const StatName& name,
                                               StatNameTagVectorOptConstRef tags) PURE;

  /**
   * TODO(#6667): this variant is deprecated: use counterFromStatName.
   * @param name The name, expressed as a string.
   * @return a counter within the scope's namespace.
   */
  virtual Counter& counterFromString(const std::string& name) PURE;

  /**
   * Creates a Gauge from the stat name. Tag extraction will be performed on the name.
   * @param name The name of the stat, obtained from the SymbolTable.
   * @param import_mode Whether hot-restart should accumulate this value.
   * @return a gauge within the scope's namespace.
   */
  Gauge& gaugeFromStatName(const StatName& name, Gauge::ImportMode import_mode) {
    return gaugeFromStatNameWithTags(name, absl::nullopt, import_mode);
  }

  /**
   * Creates a Gauge from the stat name and tags. If tags are not provided, tag extraction
   * will be performed on the name.
   * @param name The name of the stat, obtained from the SymbolTable.
   * @param tags optionally specified tags.
   * @param import_mode Whether hot-restart should accumulate this value.
   * @return a gauge within the scope's namespace.
   */
  virtual Gauge& gaugeFromStatNameWithTags(const StatName& name, StatNameTagVectorOptConstRef tags,
                                           Gauge::ImportMode import_mode) PURE;

  /**
   * TODO(#6667): this variant is deprecated: use gaugeFromStatName.
   * @param name The name, expressed as a string.
   * @param import_mode Whether hot-restart should accumulate this value.
   * @return a gauge within the scope's namespace.
   */
  virtual Gauge& gaugeFromString(const std::string& name, Gauge::ImportMode import_mode) PURE;

  /**
   * Creates a Histogram from the stat name. Tag extraction will be performed on the name.
   * @param name The name of the stat, obtained from the SymbolTable.
   * @param unit The unit of measurement.
   * @return a histogram within the scope's namespace with a particular value type.
   */
  Histogram& histogramFromStatName(const StatName& name, Histogram::Unit unit) {
    return histogramFromStatNameWithTags(name, absl::nullopt, unit);
  }

  /**
   * Creates a Histogram from the stat name and tags. If tags are not provided, tag extraction
   * will be performed on the name.
   * @param name The name of the stat, obtained from the SymbolTable.
   * @param tags optionally specified tags.
   * @param unit The unit of measurement.
   * @return a histogram within the scope's namespace with a particular value type.
   */
  virtual Histogram& histogramFromStatNameWithTags(const StatName& name,
                                                   StatNameTagVectorOptConstRef tags,
                                                   Histogram::Unit unit) PURE;

  /**
   * TODO(#6667): this variant is deprecated: use histogramFromStatName.
   * @param name The name, expressed as a string.
   * @param unit The unit of measurement.
   * @return a histogram within the scope's namespace with a particular value type.
   */
  virtual Histogram& histogramFromString(const std::string& name, Histogram::Unit unit) PURE;

  /**
   * Creates a TextReadout from the stat name. Tag extraction will be performed on the name.
   * @param name The name of the stat, obtained from the SymbolTable.
   * @return a text readout within the scope's namespace.
   */
  TextReadout& textReadoutFromStatName(const StatName& name) {
    return textReadoutFromStatNameWithTags(name, absl::nullopt);
  }

  /**
   * Creates a TextReadout from the stat name and tags. If tags are not provided, tag extraction
   * will be performed on the name.
   * @param name The name of the stat, obtained from the SymbolTable.
   * @param tags optionally specified tags.
   * @return a text readout within the scope's namespace.
   */
  virtual TextReadout& textReadoutFromStatNameWithTags(const StatName& name,
                                                       StatNameTagVectorOptConstRef tags) PURE;

  /**
   * TODO(#6667): this variant is deprecated: use textReadoutFromStatName.
   * @param name The name, expressed as a string.
   * @return a text readout within the scope's namespace.
   */
  virtual TextReadout& textReadoutFromString(const std::string& name) PURE;

  /**
   * @param The name of the stat, obtained from the SymbolTable.
   * @return a reference to a counter within the scope's namespace, if it exists.
   */
  virtual CounterOptConstRef findCounter(StatName name) const PURE;

  /**
   * @param The name of the stat, obtained from the SymbolTable.
   * @return a reference to a gauge within the scope's namespace, if it exists.
   */
  virtual GaugeOptConstRef findGauge(StatName name) const PURE;

  /**
   * @param The name of the stat, obtained from the SymbolTable.
   * @return a reference to a histogram within the scope's namespace, if it
   * exists.
   */
  virtual HistogramOptConstRef findHistogram(StatName name) const PURE;

  /**
   * @param The name of the stat, obtained from the SymbolTable.
   * @return a reference to a text readout within the scope's namespace, if it exists.
   */
  virtual TextReadoutOptConstRef findTextReadout(StatName name) const PURE;

  /**
   * @return a reference to the symbol table.
   */
  virtual const SymbolTable& constSymbolTable() const PURE;
  virtual SymbolTable& symbolTable() PURE;

  /**
   * Calls 'fn' for every counter. Iteration stops if `fn` returns false;
   *
   * @param fn Function to be run for every counter, or until fn return false.
   * @return false if fn(counter) return false during iteration, true if every counter was hit.
   */
  virtual bool iterate(const IterateFn<Counter>& fn) const PURE;

  /**
   * Calls 'fn' for every gauge. Iteration stops if `fn` returns false;
   *
   * @param fn Function to be run for every gauge, or until fn return false.
   * @return false if fn(gauge) return false during iteration, true if every gauge was hit.
   */
  virtual bool iterate(const IterateFn<Gauge>& fn) const PURE;

  /**
   * Calls 'fn' for every histogram. Iteration stops if `fn` returns false;
   *
   * @param fn Function to be run for every histogram, or until fn return false.
   * @return false if fn(histogram) return false during iteration, true if every histogram was hit.
   */
  virtual bool iterate(const IterateFn<Histogram>& fn) const PURE;

  /**
   * Calls 'fn' for every text readout. Note that in the case of overlapping
   * scopes, the implementation may call fn more than one time for each
   * text readout. Iteration stops if `fn` returns false;
   *
   * @param fn Function to be run for every text readout, or until fn return false.
   * @return false if fn(text_readout) return false during iteration, true if every text readout
   *         was hit.
   */
  virtual bool iterate(const IterateFn<TextReadout>& fn) const PURE;

  /**
   * @return the aggregated prefix for this scope. A trailing dot is not
   * included, even if one was supplied when creating the scope. If this is a
   * nested scope, it will include names from every level. E.g.
   *     store.createScope("foo").createScope("bar").prefix() will be the StatName "foo.bar"
   */
  virtual StatName prefix() const PURE;

  /**
   * @return a reference to the Store object that owns this scope.
   */
  virtual Store& store() PURE;
  virtual const Store& constStore() const PURE;
};

} // namespace Stats
} // namespace Envoy
#pragma once

#include <memory>
#include <string>
#include <vector>

#include "envoy/common/pure.h"
#include "envoy/stats/tag.h"

#include "absl/strings/string_view.h"

namespace Envoy {
namespace Stats {

class TagProducer {
public:
  virtual ~TagProducer() = default;

  /**
   * Take a metric name and a vector then add proper tags into the vector and
   * return an extracted metric name. The tags array will be populated with
   * name/value pairs extracted from the full metric name, using the regular
   * expressions in source/common/config/well_known_names.cc. For example, the
   * stat name "vhost.foo.vcluster.bar.c1" would have "foo" extracted as the
   * value of tag "vhost" and "bar" extracted as the value of tag
   * "vcluster", so this will populate tags with {"vhost", "foo"} and
   * {"vcluster", "bar"}, and return "vhost.vcluster.c1".
   *
   * @param metric_name std::string a name of Stats::Metric (Counter, Gauge, Histogram).
   * @param tags TagVector a set of Stats::Tag.
   */
  virtual std::string produceTags(absl::string_view metric_name, TagVector& tags) const PURE;

  virtual const TagVector& fixedTags() const PURE;
};

using TagProducerPtr = std::unique_ptr<const TagProducer>;

} // namespace Stats
} // namespace Envoy
#pragma once

#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#include "envoy/common/pure.h"
#include "envoy/stats/refcount_ptr.h"
#include "envoy/stats/tag.h"

#include "absl/strings/string_view.h"

namespace Envoy {
namespace Stats {

/**
 * Runtime representation of an encoded stat name.
 */
class StatName;

/**
 * Holds a set of symbols used to compose hierarhical names.
 */
class SymbolTable;

/**
 * General interface for all stats objects.
 *
 * Note: some methods must match those in `PrimitiveMetricMetadata` because stats sinks
 * use templates to handle either type. The interface is not used for size/performance
 * reasons.
 */
class Metric : public RefcountInterface {
public:
  ~Metric() override = default;
  /**
   * Returns the full name of the Metric. This is intended for most uses, such
   * as streaming out the name to a stats sink or admin request, or comparing
   * against it in a test. Independent of the evolution of the data
   * representation for the name, this method will be available. For storing the
   * name as a map key, however, nameCStr() is a better choice, albeit one that
   * might change in the future to return a symbolized representation of the
   * elaborated string.
   */
  virtual std::string name() const PURE;

  /**
   * Returns the full name of the Metric as an encoded array of symbols.
   */
  virtual StatName statName() const PURE;

  /**
   * Returns a vector of configurable tags to identify this Metric.
   */
  virtual TagVector tags() const PURE;

  /**
   * See a more detailed description in tagExtractedStatName(), which is the
   * preferred API to use when feasible. This API needs to compose the
   * std::string on the fly, and return it by value.
   *
   * @return The stat name with all tag values extracted, as a std::string.
   */
  virtual std::string tagExtractedName() const PURE;

  /**
   * Returns the name of the Metric with the portions designated as tags removed
   * as a string. For example, The stat name "vhost.foo.vcluster.bar.c1" would
   * have "foo" extracted as the value of tag "vhost" and "bar" extracted as the
   * value of tag "vcluster". Thus the tagExtractedName is simply
   * "vhost.vcluster.c1".
   *
   * @return the name of the Metric with the portions designated as tags
   *     removed.
   */
  virtual StatName tagExtractedStatName() const PURE;

  // Function to be called from iterateTagStatNames passing name and value as StatNames.
  using TagStatNameIterFn = std::function<bool(StatName, StatName)>;

  /**
   * Iterates over all tags, calling a functor for each name/value pair. The
   * functor can return 'true' to continue or 'false' to stop the
   * iteration.
   *
   * @param fn The functor to call for StatName pair.
   */
  virtual void iterateTagStatNames(const TagStatNameIterFn& fn) const PURE;

  // Function to be called from iterateTags passing name and value as const Tag&.
  using TagIterFn = std::function<bool(const Tag&)>;

  /**
   * Indicates whether this metric has been updated since the server was started.
   */
  virtual bool used() const PURE;

  /**
   * Indicates whether this metric is hidden.
   */
  virtual bool hidden() const PURE;

  /**
   * Flags:
   * Used: used by all stats types to figure out whether they have been used.
   * Logic...: used by gauges to cache how they should be combined with a parent's value.
   */
  struct Flags {
    static constexpr uint8_t Used = 0x01;
    static constexpr uint8_t LogicAccumulate = 0x02;
    static constexpr uint8_t NeverImport = 0x04;
    static constexpr uint8_t Hidden = 0x08;
  };
  virtual SymbolTable& symbolTable() PURE;
  virtual const SymbolTable& constSymbolTable() const PURE;
};

/**
 * An always incrementing counter with latching capability. Each increment is added both to a
 * global counter as well as periodic counter. Calling latch() returns the periodic counter and
 * clears it.
 */
class Counter : public Metric {
public:
  ~Counter() override = default;

  virtual void add(uint64_t amount) PURE;
  virtual void inc() PURE;
  virtual uint64_t latch() PURE;
  virtual void reset() PURE;
  virtual uint64_t value() const PURE;
};

using CounterSharedPtr = RefcountPtr<Counter>;

/**
 * A gauge that can both increment and decrement.
 */
class Gauge : public Metric {
public:
  // TODO(diazalan): Rename ImportMode to more generic name
  enum class ImportMode {
    Uninitialized,    // Gauge was discovered during hot-restart transfer.
    NeverImport,      // On hot-restart, each process starts with gauge at 0.
    Accumulate,       // Transfers gauge state on hot-restart.
    HiddenAccumulate, // Will be transferred on hot-restart and ignored by admin/stats-sink
  };

  ~Gauge() override = default;

  virtual void add(uint64_t amount) PURE;
  virtual void dec() PURE;
  virtual void inc() PURE;
  virtual void set(uint64_t value) PURE;
  virtual void sub(uint64_t amount) PURE;
  virtual uint64_t value() const PURE;

  /**
   * Sets a value from a hot-restart parent. This parent contribution must be
   * kept distinct from the child value, so that when we erase the value it
   * is not commingled with the child value, which may have been set() directly.
   *
   * @param parent_value the value from the hot-restart parent.
   */
  virtual void setParentValue(uint64_t parent_value) PURE;

  /**
   * @return the import mode, dictating behavior of the gauge across hot restarts.
   */
  virtual ImportMode importMode() const PURE;

  /**
   * Gauges can be created with ImportMode::Uninitialized during hot-restart
   * merges, if they haven't yet been instantiated by the child process. When
   * they finally get instantiated, mergeImportMode should be called to
   * initialize the gauge's import mode. It is only valid to call
   * mergeImportMode when the current mode is ImportMode::Uninitialized.
   *
   * @param import_mode the new import mode.
   */
  virtual void mergeImportMode(ImportMode import_mode) PURE;
};

using GaugeSharedPtr = RefcountPtr<Gauge>;

/**
 * A string, possibly non-ASCII.
 */
class TextReadout : public virtual Metric {
public:
  // Text readout type is used internally to disambiguate isolated store
  // constructors. In the future we can extend it to specify text encoding or
  // some such.
  enum class Type {
    Default, // No particular meaning.
  };

  ~TextReadout() override = default;

  /**
   * Sets the value of this TextReadout by moving the input |value| to minimize
   * buffer copies under the lock.
   */
  virtual void set(absl::string_view value) PURE;
  /**
   * @return the copy of this TextReadout value.
   */
  virtual std::string value() const PURE;
};

using TextReadoutSharedPtr = RefcountPtr<TextReadout>;

/**
 * Callback invoked to provide size of stats container.
 */
using SizeFn = std::function<void(std::size_t)>;

/**
 * Callback invoked for each stat during iteration.
 */
template <typename Stat> using StatFn = std::function<void(Stat&)>;

/**
 * Interface for stats lazy initialization.
 * To save memory and CPU consumption on blocks of stats that are never referenced throughout the
 * process lifetime, they can be encapsulated in a DeferredCreationCompatibleInterface. Then the
Envoy
 * bootstrap configuration can be set to defer the instantiation of those block. Note that when the
 * blocks of stats are created, they carry an extra 60~100 byte overhead (depending on worker thread
 * count) due to internal bookkeeping data structures. The overhead when deferred stats are disabled
 * is just 8 bytes.
* See more context: https://github.com/envoyproxy/envoy/issues/23575
 */
template <typename StatsStructType> class DeferredCreationCompatibleInterface {
public:
  // Helper function to get-or-create and return the StatsStructType object.
  virtual StatsStructType& getOrCreate() PURE;

  virtual ~DeferredCreationCompatibleInterface() = default;
};

// A helper class for a lazy compatible stats struct type.
template <typename StatsStructType> class DeferredCreationCompatibleStats {
public:
  explicit DeferredCreationCompatibleStats(
      std::unique_ptr<DeferredCreationCompatibleInterface<StatsStructType>> d)
      : data_(std::move(d)) {}
  // Allows move construct and assign.
  DeferredCreationCompatibleStats& operator=(DeferredCreationCompatibleStats&&) noexcept = default;
  DeferredCreationCompatibleStats(DeferredCreationCompatibleStats&&) noexcept = default;

  inline StatsStructType* operator->() { return &data_->getOrCreate(); };
  inline StatsStructType& operator*() { return data_->getOrCreate(); };

private:
  std::unique_ptr<DeferredCreationCompatibleInterface<StatsStructType>> data_;
};
} // namespace Stats
} // namespace Envoy
#pragma once

#include <chrono>
#include <memory>

#include "envoy/common/pure.h"

namespace Envoy {
namespace Stats {

/**
 * An abstraction of timespan which can be completed.
 */
class CompletableTimespan {
public:
  virtual ~CompletableTimespan() = default;

  /**
   * Time elapsed since the creation of the timespan.
   */
  virtual std::chrono::milliseconds elapsed() const PURE;

  /**
   * Complete the timespan.
   */
  virtual void complete() PURE;
};

using Timespan = CompletableTimespan;
using TimespanPtr = std::unique_ptr<Timespan>;

} // namespace Stats
} // namespace Envoy
#pragma once

#include <functional>
#include <memory>
#include <vector>

#include "envoy/common/optref.h"
#include "envoy/common/pure.h"
#include "envoy/stats/histogram.h"
#include "envoy/stats/scope.h"
#include "envoy/stats/stats.h"
#include "envoy/stats/stats_matcher.h"
#include "envoy/stats/tag_producer.h"

namespace Envoy {
namespace Event {

class Dispatcher;
}

namespace ThreadLocal {
class Instance;
}

namespace Stats {

class Sink;
class SinkPredicates;
class StatNamePool;

/**
 * Store keeps track of all Scopes created in it, and the Scopes manage
 * individual stats. Each stat is defined in a scope. There is a single root
 * scope created in the Store, and more sub-scopes can be created. Scopes do not
 * own the scopes created underneath; they are managed by the return
 * SharePtr. However, sub-scopes combine the prefixes from their parental chain.
 *
 * Stores enable iteration over all stats in its transitively owned Scopes,
 *
 * There is typically one Store instance in a test or binary, though Isolated
 * Stores can be created in some scenarios. Stores are typically allocated
 * as part of other objects or via std::unique_ptr.
 *
 * In contrast, Scopes are managed via shared_ptr, unique nickname
 * ScopeSharedPtr, and should not be directly instantiated or allocated via
 * std::unique_ptr.
 *
 * A reference to the root-scope held by the Store until it shuts down. Holding
 * onto a reference to the root-scope's shared_ptr that outlives the Store is
 * not allowed.
 */
class Store {
public:
  virtual ~Store() = default;

  /**
   * @return the root scope (creating it if necessary)
   */
  virtual ScopeSharedPtr rootScope() PURE;

  /**
   * @return the root scope (creating it if necessary)
   */
  virtual ConstScopeSharedPtr constRootScope() const PURE;

  /**
   * @return The symbol table.
   **/
  virtual const SymbolTable& constSymbolTable() const PURE;

  /**
   * @return The symbol table.
   **/
  virtual SymbolTable& symbolTable() PURE;

  /**
   * Deliver an individual histogram value to all registered sinks.
   */
  virtual void deliverHistogramToSinks(const Histogram& histogram, uint64_t value) PURE;

  /**
   * @return a list of all known counters.
   */
  virtual std::vector<CounterSharedPtr> counters() const PURE;

  /**
   * @return a list of all known gauges.
   */
  virtual std::vector<GaugeSharedPtr> gauges() const PURE;

  /**
   * @return a list of all known text readouts.
   */
  virtual std::vector<TextReadoutSharedPtr> textReadouts() const PURE;

  /**
   * @return a list of all known histograms.
   */
  virtual std::vector<ParentHistogramSharedPtr> histograms() const PURE;

  /**
   * Iterate over all stats. Note, that implementations can potentially hold on
   * to a mutex that will deadlock if the passed in functors try to create or
   * delete a stat. Also note that holding onto the stat or scope reference
   * after forEach* is not supported, as scope/stat deletions can occur in any
   * thread. Implementation locks ensures the stat/scope is valid until the
   * f_stat returns.
   *
   * @param f_size functor that is provided the current number of all
   * stats. Note that this is called only once, prior to any calls to f_stat.
   * @param f_stat functor that is provided one stat at a time from the stats
   * container.
   */
  virtual void forEachCounter(SizeFn f_size, StatFn<Counter> f_stat) const PURE;
  virtual void forEachGauge(SizeFn f_size, StatFn<Gauge> f_stat) const PURE;
  virtual void forEachTextReadout(SizeFn f_size, StatFn<TextReadout> f_stat) const PURE;
  virtual void forEachHistogram(SizeFn f_size, StatFn<ParentHistogram> f_stat) const PURE;
  virtual void forEachScope(SizeFn f_size, StatFn<const Scope> f_stat) const PURE;

  /**
   * @return a null counter that will ignore increments and always return 0.
   */
  virtual Counter& nullCounter() PURE;

  /**
   * @return a null gauge that will ignore set() calls and always return 0.
   */
  virtual Gauge& nullGauge() PURE;

  /**
   * Iterate over all stats that need to be flushed to sinks. Note, that implementations can
   * potentially hold on to a mutex that will deadlock if the passed in functors try to create
   * or delete a stat.
   * @param f_size functor that is provided the number of all stats that will be flushed to sinks.
   * Note that this is called only once, prior to any calls to f_stat.
   * @param f_stat functor that is provided one stat that will be flushed to sinks, at a time.
   */
  virtual void forEachSinkedCounter(SizeFn f_size, StatFn<Counter> f_stat) const PURE;
  virtual void forEachSinkedGauge(SizeFn f_size, StatFn<Gauge> f_stat) const PURE;
  virtual void forEachSinkedTextReadout(SizeFn f_size, StatFn<TextReadout> f_stat) const PURE;
  virtual void forEachSinkedHistogram(SizeFn f_size, StatFn<ParentHistogram> f_stat) const PURE;

  /**
   * Calls 'fn' for every stat. Note that in the case of overlapping scopes, the
   * implementation may call fn more than one time for each counter. Iteration
   * stops if `fn` returns false;
   *
   * @param fn Function to be run for every counter, or until fn return false.
   * @return false if fn(counter) return false during iteration, true if every counter was hit.
   */
  virtual bool iterate(const IterateFn<Counter>& fn) const PURE;
  virtual bool iterate(const IterateFn<Gauge>& fn) const PURE;
  virtual bool iterate(const IterateFn<Histogram>& fn) const PURE;
  virtual bool iterate(const IterateFn<TextReadout>& fn) const PURE;

  // Delegate some methods to the root scope; these are exposed to make it more
  // convenient to use stats_macros.h. We may consider dropping them if desired,
  // when we resolve #24007 or in the next follow-up.
  Counter& counterFromString(const std::string& name) {
    return rootScope()->counterFromString(name);
  }
  Gauge& gaugeFromString(const std::string& name, Gauge::ImportMode import_mode) {
    return rootScope()->gaugeFromString(name, import_mode);
  }
  TextReadout& textReadoutFromString(const std::string& name) {
    return rootScope()->textReadoutFromString(name);
  }
  Histogram& histogramFromString(const std::string& name, Histogram::Unit unit) {
    return rootScope()->histogramFromString(name, unit);
  }

  /**
   * @return a scope of the given name.
   */
  ScopeSharedPtr createScope(const std::string& name) { return rootScope()->createScope(name); }

  /**
   * Extracts tags from the name and appends them to the provided StatNameTagVector.
   *     The StatName for the extracted tags will be saved in the provided pool.
   * @param name The stat name.
   * @param pool The pool to create the tags in.
   * @param stat_tags The stat name tags vector to append the tags to.
   */
  virtual void extractAndAppendTags(StatName name, StatNamePool& pool,
                                    StatNameTagVector& stat_tags) PURE;

  /**
   * Extracts tags from the name and appends them to the provided StatNameTagVector.
   *     The StatName for the extracted tags will be saved in the provided pool.
   * @param name The stat name.
   * @param pool The pool to create the tags in.
   * @param stat_tags The stat name tags vector to append the tags to.
   */
  virtual void extractAndAppendTags(absl::string_view name, StatNamePool& pool,
                                    StatNameTagVector& stat_tags) PURE;

  /**
   * Returns the configured fixed tags (which don't depend on the name of the stat).
   */
  virtual const TagVector& fixedTags() PURE;
};

using StorePtr = std::unique_ptr<Store>;

/**
 * Callback invoked when a store's mergeHistogram() runs.
 */
using PostMergeCb = std::function<void()>;

/**
 * The root of the stat store.
 */
class StoreRoot : public Store {
public:
  /**
   * Add a sink that is used for stat flushing.
   */
  virtual void addSink(Sink& sink) PURE;

  /**
   * Set the given tag producer to control tags.
   */
  virtual void setTagProducer(TagProducerPtr&& tag_producer) PURE;

  /**
   * Attach a StatsMatcher to this StoreRoot to prevent the initialization of stats according to
   * some ruleset.
   * @param stats_matcher a StatsMatcher to attach to this StoreRoot.
   */
  virtual void setStatsMatcher(StatsMatcherPtr&& stats_matcher) PURE;

  /**
   * Attach a HistogramSettings to this StoreRoot to generate histogram configurations
   * according to some ruleset.
   */
  virtual void setHistogramSettings(HistogramSettingsConstPtr&& histogram_settings) PURE;

  /**
   * Initialize the store for threading. This will be called once after all worker threads have
   * been initialized. At this point the store can initialize itself for multi-threaded operation.
   */
  virtual void initializeThreading(Event::Dispatcher& main_thread_dispatcher,
                                   ThreadLocal::Instance& tls) PURE;

  /**
   * Shutdown threading support in the store. This is called once when the server is about to shut
   * down.
   */
  virtual void shutdownThreading() PURE;

  /**
   * Called during the flush process to merge all the thread local histograms. The passed in
   * callback will be called on the main thread, but it will happen after the method returns
   * which means that the actual flush process will happen on the main thread after this method
   * returns. It is expected that only one merge runs at any time and concurrent calls to this
   * method would be asserted.
   */
  virtual void mergeHistograms(PostMergeCb merge_complete_cb) PURE;

  /**
   * Set predicates for filtering stats to be flushed to sinks.
   * Note that if the sink predicates object is set, we do not send non-sink stats over to the
   * child process during hot restart. This will result in the admin stats console being wrong
   * during hot restart.
   */
  virtual void setSinkPredicates(std::unique_ptr<SinkPredicates>&& sink_predicates) PURE;

  virtual OptRef<SinkPredicates> sinkPredicates() PURE;
};

using StoreRootPtr = std::unique_ptr<StoreRoot>;

} // namespace Stats
} // namespace Envoy
#pragma once

#include <cstdint>
#include <functional>
#include <memory>

#include "envoy/common/optref.h"
#include "envoy/common/pure.h"
#include "envoy/event/dispatcher.h"
#include "envoy/thread_local/thread_local_object.h"

#include "source/common/common/assert.h"

namespace Envoy {
namespace ThreadLocal {

/**
 * An individual allocated TLS slot. When the slot is destroyed the stored thread local will
 * be freed on each thread.
 */
class Slot {
public:
  virtual ~Slot() = default;

  /**
   * Returns if there is thread local data for this thread.
   *
   * This should return true for Envoy worker threads and false for threads which do not have thread
   * local storage allocated.
   *
   * @return true if registerThread has been called for this thread, false otherwise.
   */
  virtual bool currentThreadRegistered() PURE;

  /**
   * @return ThreadLocalObjectSharedPtr a thread local object stored in the slot.
   */
  virtual ThreadLocalObjectSharedPtr get() PURE;

  /**
   * This is a helper on top of get() that casts the object stored in the slot to the specified
   * type. Since the slot only stores pointers to the base interface, the static_cast operates
   * in production for performance, and the dynamic_cast validates correctness in tests and debug
   * builds.
   */
  template <class T> T& getTyped() {
    ASSERT(std::dynamic_pointer_cast<T>(get()) != nullptr);
    return *static_cast<T*>(get().get());
  }

  /**
   * Set thread local data on all threads previously registered via registerThread().
   * @param initializeCb supplies the functor that will be called *on each thread*. The functor
   *                     returns the thread local object which is then stored. The storage is via
   *                     a shared_ptr. Thus, this is a flexible mechanism that can be used to share
   *                     the same data across all threads or to share different data on each thread.
   *
   * NOTE: The initialize callback is not supposed to capture the Slot, or its owner, as the owner
   * may be destructed in main thread before the update_cb gets called in a worker thread.
   */
  using InitializeCb = std::function<ThreadLocalObjectSharedPtr(Event::Dispatcher& dispatcher)>;
  virtual void set(InitializeCb cb) PURE;

protected:
  template <class T> friend class TypedSlot;

  /**
   * UpdateCb takes is passed a shared point to the current stored data. Use of
   * this API is deprecated; please use TypedSlot::runOnAllThreads instead.
   *
   * NOTE: The update callback is not supposed to capture the Slot, or its
   * owner, as the owner may be destructed in main thread before the update_cb
   * gets called in a worker thread.
   **/
  using UpdateCb = std::function<void(ThreadLocalObjectSharedPtr)>;

  // Callers must use the TypedSlot API, below.
  virtual void runOnAllThreads(const UpdateCb& update_cb) PURE;
  virtual void runOnAllThreads(const UpdateCb& update_cb,
                               const std::function<void()>& complete_cb) PURE;

  /**
   * Returns whether or not global threading has been shutdown.
   *
   * @return true if global threading has been shutdown or false if not.
   */
  virtual bool isShutdown() const PURE;
};

using SlotPtr = std::unique_ptr<Slot>;

/**
 * Interface used to allocate thread local slots.
 */
class SlotAllocator {
public:
  virtual ~SlotAllocator() = default;

  /**
   * @return SlotPtr a dedicated slot for use in further calls to get(), set(), etc.
   */
  virtual SlotPtr allocateSlot() PURE;
};

// Provides a typesafe API for slots. The slot data must be derived from
// ThreadLocalObject. If there is no slot data, you can instantiated TypedSlot
// with the default type param: TypedSlot<> tls_;
//
// TODO(jmarantz): Rename the Slot class to something like RawSlot, where the
// only reference is from TypedSlot, which we can then rename to Slot.
template <class T> class TypedSlot {
public:
  /**
   * Helper method to create a unique_ptr for a typed slot. This helper
   * reduces some verbose parameterization at call-sites.
   *
   * @param allocator factory to allocate untyped Slot objects.
   * @return a TypedSlotPtr<T> (the type is defined below).
   */
  static std::unique_ptr<TypedSlot> makeUnique(SlotAllocator& allocator) {
    return std::make_unique<TypedSlot>(allocator);
  }

  explicit TypedSlot(SlotAllocator& allocator) : slot_(allocator.allocateSlot()) {}

  /**
   * Returns if there is thread local data for this thread.
   *
   * This should return true for Envoy worker threads and false for threads which do not have thread
   * local storage allocated.
   *
   * @return true if registerThread has been called for this thread, false otherwise.
   */
  bool currentThreadRegistered() { return slot_->currentThreadRegistered(); }

  /**
   * Set thread local data on all threads previously registered via registerThread().
   * @param initializeCb supplies the functor that will be called *on each thread*. The functor
   *                     returns the thread local object which is then stored. The storage is via
   *                     a shared_ptr. Thus, this is a flexible mechanism that can be used to share
   *                     the same data across all threads or to share different data on each thread.
   *
   * NOTE: The initialize callback is not supposed to capture the Slot, or its owner, as the owner
   * may be destructed in main thread before the update_cb gets called in a worker thread.
   */
  using InitializeCb = std::function<std::shared_ptr<T>(Event::Dispatcher& dispatcher)>;
  void set(InitializeCb cb) { slot_->set(cb); }

  /**
   * @return an optional reference to the thread local object.
   */
  OptRef<T> get() { return getOpt(slot_->get()); }
  const OptRef<T> get() const { return getOpt(slot_->get()); }

  /**
   * Helper function to call methods on T. The caller is responsible
   * for ensuring that get().has_value() is true.
   *
   * @return a pointer to the thread local object.
   */
  T* operator->() { return &(slot_->getTyped<T>()); }
  const T* operator->() const { return &(slot_->getTyped<T>()); }

  /**
   * Helper function to get access to a T&. The caller is responsible for
   * ensuring that get().has_value() is true.
   *
   * @return a reference to the thread local object.
   */
  T& operator*() { return slot_->getTyped<T>(); }
  const T& operator*() const { return slot_->getTyped<T>(); }

  /**
   * UpdateCb is passed a mutable pointer to the current stored data. Callers
   * can assume that the passed-in OptRef has a value if they have called set(),
   * yielding a non-null shared_ptr, prior to runOnAllThreads().
   *
   * NOTE: The update callback is not supposed to capture the TypedSlot, or its
   * owner, as the owner may be destructed in main thread before the update_cb
   * gets called in a worker thread.
   */
  using UpdateCb = std::function<void(OptRef<T> obj)>;
  void runOnAllThreads(const UpdateCb& cb) { slot_->runOnAllThreads(makeSlotUpdateCb(cb)); }
  void runOnAllThreads(const UpdateCb& cb, const std::function<void()>& complete_cb) {
    slot_->runOnAllThreads(makeSlotUpdateCb(cb), complete_cb);
  }

  /**
   * Returns whether or not global threading has been shutdown.
   *
   * @return true if global threading has been shutdown or false if not.
   */
  bool isShutdown() const { return slot_->isShutdown(); };

private:
  static OptRef<T> getOpt(ThreadLocalObjectSharedPtr obj) {
    if (obj) {
      return OptRef<T>(obj->asType<T>());
    }
    return OptRef<T>();
  }

  Slot::UpdateCb makeSlotUpdateCb(UpdateCb cb) {
    return [cb](ThreadLocalObjectSharedPtr obj) { cb(getOpt(obj)); };
  }

  const SlotPtr slot_;
};

template <class T = ThreadLocalObject> using TypedSlotPtr = std::unique_ptr<TypedSlot<T>>;

/**
 * Interface for getting and setting thread local data as well as registering a thread
 */
class Instance : public SlotAllocator {
public:
  /**
   * A thread (via its dispatcher) must be registered before set() is called on any allocated slots
   * to receive thread local data updates.
   * @param dispatcher supplies the thread's dispatcher.
   * @param main_thread supplies whether this is the main program thread or not. (The only
   *                    difference is that callbacks fire immediately on the main thread when posted
   *                    from the main thread).
   */
  virtual void registerThread(Event::Dispatcher& dispatcher, bool main_thread) PURE;

  /**
   * This should be called by the main thread before any worker threads start to exit. This will
   * block TLS removal during slot destruction, given that worker threads are about to call
   * shutdownThread(). This avoids having to implement de-registration of threads.
   */
  virtual void shutdownGlobalThreading() PURE;

  /**
   * The owning thread is about to exit. This will free all thread local variables. It must be
   * called on the thread that is shutting down.
   */
  virtual void shutdownThread() PURE;

  /**
   * @return Event::Dispatcher& the thread local dispatcher.
   */
  virtual Event::Dispatcher& dispatcher() PURE;

  /**
   * Returns whether or not global threading has been shutdown.
   *
   * @return true if global threading has been shutdown or false if not.
   */
  virtual bool isShutdown() const PURE;
};

} // namespace ThreadLocal
} // namespace Envoy
#pragma once

#include <cstdint>
#include <functional>
#include <memory>

#include "source/common/common/assert.h"

namespace Envoy {
namespace ThreadLocal {

/**
 * All objects that are stored via the ThreadLocal interface must derive from this type.
 */
class ThreadLocalObject {
public:
  virtual ~ThreadLocalObject() = default;

  /**
   * Return the object casted to a concrete type. See getTyped() below for comments on the casts.
   */
  template <class T> T& asType() {
    ASSERT(dynamic_cast<T*>(this) != nullptr);
    return *static_cast<T*>(this);
  }
};

using ThreadLocalObjectSharedPtr = std::shared_ptr<ThreadLocalObject>;

template <class T = ThreadLocalObject> class TypedSlot;

} // namespace ThreadLocal
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "thread_local_interface",
    hdrs = ["thread_local.h"],
    deps = [
        ":thread_local_object",
        "//envoy/event:dispatcher_interface",
        "//source/common/common:assert_lib",
    ],
)

envoy_cc_library(
    name = "thread_local_object",
    hdrs = ["thread_local_object.h"],
    deps = ["//source/common/common:assert_lib"],
)
#pragma once

#include <cstdint>
#include <memory>

#include "envoy/common/pure.h"
#include "envoy/network/transport_socket.h"
#include "envoy/router/router.h"
#include "envoy/stream_info/stream_info.h"
#include "envoy/upstream/types.h"
#include "envoy/upstream/upstream.h"

namespace Envoy {
namespace Http {
namespace ConnectionPool {
class ConnectionLifetimeCallbacks;
} // namespace ConnectionPool
} // namespace Http
namespace Upstream {

/**
 * Context information passed to a load balancer to use when choosing a host. Not all load
 * balancers make use of all context information.
 */
class LoadBalancerContext {
public:
  virtual ~LoadBalancerContext() = default;

  /**
   * Compute and return an optional hash key to use during load balancing. This
   * method may modify internal state so it should only be called once per
   * routing attempt.
   * @return absl::optional<uint64_t> the optional hash key to use.
   */
  virtual absl::optional<uint64_t> computeHashKey() PURE;

  /**
   * @return Router::MetadataMatchCriteria* metadata for use in selecting a subset of hosts
   *         during load balancing.
   */
  virtual const Router::MetadataMatchCriteria* metadataMatchCriteria() PURE;

  /**
   * @return const Network::Connection* the incoming connection or nullptr to use during load
   * balancing.
   */
  virtual const Network::Connection* downstreamConnection() const PURE;

  /**
   * @return const StreamInfo* the incoming request stream info or nullptr to use during load
   * balancing.
   */
  virtual const StreamInfo::StreamInfo* requestStreamInfo() const PURE;

  /**
   * @return const Http::HeaderMap* the incoming headers or nullptr to use during load
   * balancing.
   */
  virtual const Http::RequestHeaderMap* downstreamHeaders() const PURE;

  /**
   * Called to retrieve a reference to the priority load data that should be used when selecting a
   * priority. Implementations may return the provided original reference to make no changes, or
   * return a reference to alternative PriorityLoad held internally.
   *
   * @param priority_state current priority state of the cluster being being load balanced.
   * @param original_priority_load the cached priority load for the cluster being load balanced.
   * @param priority_mapping_func see @Upstream::RetryPriority::PriorityMappingFunc.
   * @return a reference to the priority load data that should be used to select a priority.
   *
   */
  virtual const HealthyAndDegradedLoad& determinePriorityLoad(
      const PrioritySet& priority_set, const HealthyAndDegradedLoad& original_priority_load,
      const Upstream::RetryPriority::PriorityMappingFunc& priority_mapping_func) PURE;

  /**
   * Called to determine whether we should reperform host selection. The load balancer
   * will retry host selection until either this function returns true or hostSelectionRetryCount is
   * reached.
   */
  virtual bool shouldSelectAnotherHost(const Host& host) PURE;

  /**
   * Called to determine how many times host selection should be retried until the filter is
   * ignored.
   */
  virtual uint32_t hostSelectionRetryCount() const PURE;

  /**
   * Returns the set of socket options which should be applied on upstream connections
   */
  virtual Network::Socket::OptionsSharedPtr upstreamSocketOptions() const PURE;

  /**
   * Returns the transport socket options which should be applied on upstream connections
   */
  virtual Network::TransportSocketOptionsConstSharedPtr upstreamTransportSocketOptions() const PURE;

  using OverrideHost = std::pair<absl::string_view, bool>;
  /**
   * Returns the host the load balancer should select directly. If the expected host exists and
   * the host can be selected directly, the load balancer can bypass the load balancing algorithm
   * and return the corresponding host directly.
   */
  virtual absl::optional<OverrideHost> overrideHostToSelect() const PURE;
};

/**
 * Identifies a specific connection within a pool.
 */
struct SelectedPoolAndConnection {
  Envoy::ConnectionPool::Instance& pool_;
  const Network::Connection& connection_;
};

/**
 * Abstract load balancing interface.
 */
class LoadBalancer {
public:
  virtual ~LoadBalancer() = default;

  /**
   * Ask the load balancer for the next host to use depending on the underlying LB algorithm.
   * @param context supplies the load balancer context. Not all load balancers make use of all
   *        context information. Load balancers should be written to assume that context information
   *        is missing and use sensible defaults.
   */
  virtual HostConstSharedPtr chooseHost(LoadBalancerContext* context) PURE;

  /**
   * Returns a best effort prediction of the next host to be picked, or nullptr if not predictable.
   * Advances with subsequent calls, so while the first call will return the next host to be picked,
   * a subsequent call will return the second host to be picked.
   * @param context supplies the context which is used in host selection.
   */
  virtual HostConstSharedPtr peekAnotherHost(LoadBalancerContext* context) PURE;

  /**
   * Returns connection lifetime callbacks that may be used to inform the load balancer of
   * connection events. Load balancers which do not intend to track connection lifetime events
   * will return nullopt.
   * @return optional lifetime callbacks for this load balancer.
   */
  virtual OptRef<Envoy::Http::ConnectionPool::ConnectionLifetimeCallbacks> lifetimeCallbacks() PURE;

  /**
   * Returns a specific pool and existing connection to be used for the specified host.
   *
   * @return selected pool and connection to be used, or nullopt if no selection is made,
   *         for example if no matching connection is found.
   */
  virtual absl::optional<SelectedPoolAndConnection>
  selectExistingConnection(LoadBalancerContext* context, const Host& host,
                           std::vector<uint8_t>& hash_key) PURE;
};

using LoadBalancerPtr = std::unique_ptr<LoadBalancer>;

/**
 * Necessary parameters for creating a worker local load balancer.
 */
struct LoadBalancerParams {
  // The worker local priority set of the target cluster.
  const PrioritySet& priority_set;
  // The worker local priority set of the local cluster.
  const PrioritySet* local_priority_set{};
};

/**
 * Factory for load balancers.
 */
class LoadBalancerFactory {
public:
  virtual ~LoadBalancerFactory() = default;

  /**
   * @return LoadBalancerPtr a new worker local load balancer.
   */
  virtual LoadBalancerPtr create(LoadBalancerParams params) PURE;

  /**
   * @return bool whether the load balancer should be recreated when the host set changes.
   */
  virtual bool recreateOnHostChange() const { return true; }
};

using LoadBalancerFactorySharedPtr = std::shared_ptr<LoadBalancerFactory>;

/**
 * A thread aware load balancer is a load balancer that is global to all workers on behalf of a
 * cluster. These load balancers are harder to write so not every load balancer has to be one.
 * If a load balancer is a thread aware load balancer, the following semantics are used:
 * 1) A single instance is created on the main thread.
 * 2) The shared factory is passed to all workers.
 * 3) Every time there is a host set update on the main thread, all workers will create a new
 *    worker local load balancer via the factory.
 *
 * The above semantics mean that any global state in the factory must be protected by appropriate
 * locks. Additionally, the factory *must not* refer back to the owning thread aware load
 * balancer. If a cluster is removed via CDS, the thread aware load balancer can be destroyed
 * before cluster destruction reaches each worker. See the ring hash load balancer for one
 * example of how this pattern is used in practice. The common expected pattern is that the
 * factory will be consuming shared immutable state from the main thread
 *
 * TODO(mattklein123): The reason that locking is used in the above threading model vs. pure TLS
 * has to do with the lack of a TLS function that does the following:
 * 1) Create a per-worker data structure on the main thread. E.g., allocate 4 objects for 4
 *    workers.
 * 2) Then fan those objects out to each worker.
 * With the existence of a function like that, the callback locking from the worker to the main
 * thread could be removed. We can look at this in a follow up. The reality though is that the
 * locking is currently only used to protect some small bits of data on host set update and will
 * never be contended.
 */
class ThreadAwareLoadBalancer {
public:
  virtual ~ThreadAwareLoadBalancer() = default;

  /**
   * @return LoadBalancerFactorySharedPtr the shared factory to use for creating new worker local
   * load balancers.
   */
  virtual LoadBalancerFactorySharedPtr factory() PURE;

  /**
   * When a thread aware load balancer is constructed, it should return nullptr for any created
   * load balancer chooseHost() calls. Once initialize is called, the load balancer should
   * instantiate any needed structured and prepare for further updates. The cluster manager
   * will do this at the appropriate time.
   */
  virtual void initialize() PURE;
};

using ThreadAwareLoadBalancerPtr = std::unique_ptr<ThreadAwareLoadBalancer>;

/*
 * Parsed load balancer configuration that will be used to create load balancer.
 */
class LoadBalancerConfig {
public:
  virtual ~LoadBalancerConfig() = default;
};
using LoadBalancerConfigPtr = std::unique_ptr<LoadBalancerConfig>;

/**
 * Factory config for load balancers. To support a load balancing policy of
 * LOAD_BALANCING_POLICY_CONFIG, at least one load balancer factory corresponding to a policy in
 * load_balancing_policy must be registered with Envoy. Envoy will use the first policy for which
 * it has a registered factory.
 */
class TypedLoadBalancerFactory : public Config::TypedFactory {
public:
  ~TypedLoadBalancerFactory() override = default;

  /**
   * @return ThreadAwareLoadBalancerPtr a new thread-aware load balancer.
   *
   * @param lb_config supplies the parsed config of the load balancer.
   * @param cluster_info supplies the cluster info.
   * @param priority_set supplies the priority set on the main thread.
   * @param runtime supplies the runtime loader.
   * @param random supplies the random generator.
   * @param time_source supplies the time source.
   */
  virtual ThreadAwareLoadBalancerPtr
  create(OptRef<const LoadBalancerConfig> lb_config, const ClusterInfo& cluster_info,
         const PrioritySet& priority_set, Runtime::Loader& runtime, Random::RandomGenerator& random,
         TimeSource& time_source) PURE;

  /**
   * This method is used to validate and create load balancer config from typed proto config.
   *
   * @return LoadBalancerConfigPtr a new load balancer config.
   *
   * @param config supplies the typed proto config of the load balancer. A dynamic_cast could
   *        be performed on the config to the expected proto type.
   * @param visitor supplies the validation visitor that will be used to validate the embedded
   *        Any proto message.
   */
  virtual LoadBalancerConfigPtr loadConfig(const Protobuf::Message& config,
                                           ProtobufMessage::ValidationVisitor& visitor) PURE;

  std::string category() const override { return "envoy.load_balancing_policies"; }
};

/**
 * Factory config for non-thread-aware load balancers. To support a load balancing policy of
 * LOAD_BALANCING_POLICY_CONFIG, at least one load balancer factory corresponding to a policy in
 * load_balancing_policy must be registered with Envoy. Envoy will use the first policy for which
 * it has a registered factory.
 */
class NonThreadAwareLoadBalancerFactory : public Config::UntypedFactory {
public:
  ~NonThreadAwareLoadBalancerFactory() override = default;

  /**
   * @return LoadBalancerPtr a new non-thread-aware load balancer.
   *
   * @param cluster_info supplies the cluster info.
   * @param priority_set supplies the priority set.
   * @param local_priority_set supplies the local priority set.
   * @param runtime supplies the runtime loader.
   * @param random supplies the random generator.
   * @param time_source supplies the time source.
   */
  virtual LoadBalancerPtr create(const ClusterInfo& cluster_info, const PrioritySet& priority_set,
                                 const PrioritySet* local_priority_set, Runtime::Loader& runtime,
                                 Random::RandomGenerator& random, TimeSource& time_source) PURE;

  std::string category() const override { return "envoy.load_balancing_policies"; }
};

} // namespace Upstream
} // namespace Envoy
#pragma once

#include <cstdint>
#include <vector>

#include "source/common/common/phantom.h"

namespace Envoy {
namespace Upstream {

// Phantom type indicating that the type is related to load.
struct Load {};

// Mapping from a priority to how much of the total traffic load should be directed to this
// priority. For example, {50, 30, 20} means that 50% of traffic should go to P0, 30% to P1
// and 20% to P2.
//
// This should either sum to 100 or consist of all zeros.
using PriorityLoad = Phantom<std::vector<uint32_t>, Load>;

// PriorityLoad specific to degraded hosts.
struct DegradedLoad : PriorityLoad {
  using PriorityLoad::PriorityLoad;
};

// PriorityLoad specific to healthy hosts.
struct HealthyLoad : PriorityLoad {
  using PriorityLoad::PriorityLoad;
};

struct HealthyAndDegradedLoad {
  HealthyLoad healthy_priority_load_;
  DegradedLoad degraded_priority_load_;
};

// Phantom type indicating that the type is related to host availability.
struct Availability {};

// Mapping from a priority how available the given priority is, e.g., the ratio of healthy host to
// total hosts.
using PriorityAvailability = Phantom<std::vector<uint32_t>, Availability>;

// Availability specific to degraded hosts.
struct DegradedAvailability : PriorityAvailability {
  using PriorityAvailability::PriorityAvailability;
};

// Availability specific to healthy hosts.
struct HealthyAvailability : PriorityAvailability {
  using PriorityAvailability::PriorityAvailability;
};

// Phantom type indicating that the type is related to healthy hosts.
struct Healthy {};
// Phantom type indicating that the type is related to degraded hosts.
struct Degraded {};
// Phantom type indicating that the type is related to excluded hosts.
struct Excluded {};

} // namespace Upstream
} // namespace Envoy
#pragma once

#include <map>
#include <memory>
#include <string>
#include <vector>

#include "envoy/common/time.h"
#include "envoy/config/core/v3/base.pb.h"
#include "envoy/network/address.h"
#include "envoy/network/transport_socket.h"
#include "envoy/stats/primitive_stats_macros.h"
#include "envoy/stats/stats_macros.h"
#include "envoy/upstream/health_check_host_monitor.h"
#include "envoy/upstream/outlier_detection.h"
#include "envoy/upstream/resource_manager.h"

#include "absl/strings/string_view.h"

namespace Envoy {
namespace Upstream {

using MetadataConstSharedPtr = std::shared_ptr<const envoy::config::core::v3::Metadata>;

/**
 * All per host stats. @see stats_macros.h
 *
 * {rq_success, rq_error} have specific semantics driven by the needs of EDS load reporting. See
 * envoy.api.v2.endpoint.UpstreamLocalityStats for the definitions of success/error. These are
 * latched by LoadStatsReporter, independent of the normal stats sink flushing.
 */
#define ALL_HOST_STATS(COUNTER, GAUGE)                                                             \
  COUNTER(cx_connect_fail)                                                                         \
  COUNTER(cx_total)                                                                                \
  COUNTER(rq_error)                                                                                \
  COUNTER(rq_success)                                                                              \
  COUNTER(rq_timeout)                                                                              \
  COUNTER(rq_total)                                                                                \
  GAUGE(cx_active)                                                                                 \
  GAUGE(rq_active)

/**
 * All per host stats defined. @see stats_macros.h
 */
struct HostStats {
  ALL_HOST_STATS(GENERATE_PRIMITIVE_COUNTER_STRUCT, GENERATE_PRIMITIVE_GAUGE_STRUCT);

  // Provide access to name,counter pairs.
  std::vector<std::pair<absl::string_view, Stats::PrimitiveCounterReference>> counters() {
    return {ALL_HOST_STATS(PRIMITIVE_COUNTER_NAME_AND_REFERENCE, IGNORE_PRIMITIVE_GAUGE)};
  }

  // Provide access to name,gauge pairs.
  std::vector<std::pair<absl::string_view, Stats::PrimitiveGaugeReference>> gauges() {
    return {ALL_HOST_STATS(IGNORE_PRIMITIVE_COUNTER, PRIMITIVE_GAUGE_NAME_AND_REFERENCE)};
  }
};

/**
 * Weakly-named load metrics to be reported as EndpointLoadMetricStats. Individual stats are
 * accumulated by calling add(), which combines stats with the same name. The aggregated stats are
 * retrieved by calling latch(), which also clears the current load metrics.
 */
class LoadMetricStats {
public:
  virtual ~LoadMetricStats() = default;

  struct Stat {
    uint64_t num_requests_with_metric = 0;
    double total_metric_value = 0.0;
  };

  using StatMap = absl::flat_hash_map<std::string, Stat>;
  using StatMapPtr = std::unique_ptr<StatMap>;

  // Adds the given stat to the map. If the stat already exists in the map, then the stat is
  // combined with the existing map entry by incrementing num_requests_with_metric and summing the
  // total_metric_value fields. Otherwise, the stat is added with the provided value to the map,
  // which retains all entries until the next call to latch(). This allows metrics to be added
  // whose keys may not necessarily be known at startup time.
  virtual void add(const absl::string_view key, double value) PURE;

  // Returns an owning pointer to the current load metrics and clears the map.
  virtual StatMapPtr latch() PURE;
};

class ClusterInfo;

/**
 * A description of an upstream host.
 */
class HostDescription {
public:
  virtual ~HostDescription() = default;

  /**
   * @return whether the host is a canary.
   */
  virtual bool canary() const PURE;

  /**
   * Update the canary status of the host.
   */
  virtual void canary(bool is_canary) PURE;

  /**
   * @return the metadata associated with this host
   */
  virtual MetadataConstSharedPtr metadata() const PURE;

  /**
   * Set the current metadata.
   */
  virtual void metadata(MetadataConstSharedPtr new_metadata) PURE;

  /**
   * @return the cluster the host is a member of.
   */
  virtual const ClusterInfo& cluster() const PURE;

  /**
   * @return true if the cluster can create a connection for this priority, false otherwise.
   * @param priority the priority the connection would have.
   */
  virtual bool canCreateConnection(Upstream::ResourcePriority priority) const PURE;

  /**
   * @return the host's outlier detection monitor.
   */
  virtual Outlier::DetectorHostMonitor& outlierDetector() const PURE;

  /**
   * @return the host's health checker monitor.
   */
  virtual HealthCheckHostMonitor& healthChecker() const PURE;

  /**
   * @return The hostname used as the host header for health checking.
   */
  virtual const std::string& hostnameForHealthChecks() const PURE;

  /**
   * @return the hostname associated with the host if any.
   * Empty string "" indicates that hostname is not a DNS name.
   */
  virtual const std::string& hostname() const PURE;

  /**
   * @return the transport socket factory responsible for this host.
   */
  virtual Network::UpstreamTransportSocketFactory& transportSocketFactory() const PURE;

  /**
   * @return the address used to connect to the host.
   */
  virtual Network::Address::InstanceConstSharedPtr address() const PURE;

  /**
   * @return a optional list of additional addresses which the host resolved to. These addresses
   *         may be used to create upstream connections if the primary address is unreachable.
   */
  virtual const std::vector<Network::Address::InstanceConstSharedPtr>& addressList() const PURE;

  /**
   * @return host specific stats.
   */
  virtual HostStats& stats() const PURE;

  /**
   * @return custom stats for multi-dimensional load balancing.
   */
  virtual LoadMetricStats& loadMetricStats() const PURE;

  /**
   * @return the locality of the host (deployment specific). This will be the default instance if
   *         unknown.
   */
  virtual const envoy::config::core::v3::Locality& locality() const PURE;

  /**
   * @return the human readable name of the host's locality zone as a StatName.
   */
  virtual Stats::StatName localityZoneStatName() const PURE;

  /**
   * @return the address used to health check the host.
   */
  virtual Network::Address::InstanceConstSharedPtr healthCheckAddress() const PURE;

  /**
   * @return the priority of the host.
   */
  virtual uint32_t priority() const PURE;

  /**
   * Set the current priority.
   */
  virtual void priority(uint32_t) PURE;

  /**
   * @return timestamp of when host has transitioned from unhealthy to
   *         healthy state via an active healthchecking.
   */
  virtual absl::optional<MonotonicTime> lastHcPassTime() const PURE;
};

using HostDescriptionConstSharedPtr = std::shared_ptr<const HostDescription>;

#define ALL_TRANSPORT_SOCKET_MATCH_STATS(COUNTER) COUNTER(total_match_count)

/**
 * The stats for transport socket match.
 */
struct TransportSocketMatchStats {
  ALL_TRANSPORT_SOCKET_MATCH_STATS(GENERATE_COUNTER_STRUCT)
};

/**
 * Library to determine what transport socket configuration to use for a given host.
 */
class TransportSocketMatcher {
public:
  struct MatchData {
    MatchData(Network::UpstreamTransportSocketFactory& factory, TransportSocketMatchStats& stats,
              std::string name)
        : factory_(factory), stats_(stats), name_(std::move(name)) {}
    Network::UpstreamTransportSocketFactory& factory_;
    TransportSocketMatchStats& stats_;
    std::string name_;
  };
  virtual ~TransportSocketMatcher() = default;

  /**
   * Resolve the transport socket configuration for a particular host.
   * @param metadata the metadata of the given host.
   * @return the match information of the transport socket selected.
   */
  virtual MatchData resolve(const envoy::config::core::v3::Metadata* metadata) const PURE;

  /*
   * return true if all matches support ALPN, false otherwise.
   */
  virtual bool allMatchesSupportAlpn() const PURE;
};

using TransportSocketMatcherPtr = std::unique_ptr<TransportSocketMatcher>;

} // namespace Upstream
} // namespace Envoy
#pragma once

#include <functional>
#include <memory>

namespace Envoy {
namespace Upstream {

/**
 * The base class for scheduler implementations used in various load balancers.
 */
template <class C> class Scheduler {
public:
  virtual ~Scheduler() = default;

  /**
   * Each time peekAgain is called, it will return the best-effort subsequent
   * pick, popping and reinserting the entry as if it had been picked.
   * The first time peekAgain is called, it will return the
   * first item which will be picked, the second time it is called it will
   * return the second item which will be picked. As picks occur, that window
   * will shrink.
   *
   * @param calculate_weight for implementations that choose to support it, this predicate specifies
   * the new weight of the entry.
   * @return std::shared_ptr<C> the best effort subsequent pick.
   */

  virtual std::shared_ptr<C> peekAgain(std::function<double(const C&)> calculate_weight) = 0;

  /**
   * Pick a queue entry with closest deadline.
   *
   * @param calculate_weight for implementations that choose to support it, this predicate specifies
   * the new weight of the entry.
   * @return std::shared_ptr<C> to next valid the queue entry if or nullptr if none exists.
   */
  virtual std::shared_ptr<C> pickAndAdd(std::function<double(const C&)> calculate_weight) = 0;

  /**
   * Insert entry into queue with a given weight.
   *
   * @param weight entry weight.
   * @param entry shared pointer to entry.
   */
  virtual void add(double weight, std::shared_ptr<C> entry) = 0;

  /**
   * Returns true if the scheduler is empty and nothing has been added.
   *
   * @return bool whether or not the internal container is empty.
   */
  virtual bool empty() const = 0;
};

} // namespace Upstream
} // namespace Envoy
#pragma once

#include <set>
#include <string>
#include <vector>

#include "envoy/common/pure.h"
#include "envoy/config/cluster/v3/cluster.pb.h"

#include "source/common/protobuf/protobuf.h"

namespace Envoy {
namespace Upstream {

/**
 * Type of load balancing to perform.
 */
enum class LoadBalancerType : uint8_t {
  RoundRobin,
  LeastRequest,
  Random,
  RingHash,
  OriginalDst,
  Maglev,
  ClusterProvided,
  LoadBalancingPolicyConfig
};

/**
 * Subset selector configuration
 */
class SubsetSelector {
public:
  virtual ~SubsetSelector() = default;

  /**
   * @return keys defined for this selector
   */
  virtual const std::set<std::string>& selectorKeys() const PURE;

  /**
   * @return fallback policy defined for this selector, or NOT_DEFINED
   */
  virtual envoy::config::cluster::v3::Cluster::LbSubsetConfig::LbSubsetSelector::
      LbSubsetSelectorFallbackPolicy
      fallbackPolicy() const PURE;

  /**
   * @return fallback keys subset defined for this selector, or empty set
   */
  virtual const std::set<std::string>& fallbackKeysSubset() const PURE;

  virtual bool singleHostPerSubset() const PURE;
};

using SubsetSelectorPtr = std::shared_ptr<SubsetSelector>;

/**
 * Load Balancer subset configuration.
 */
class LoadBalancerSubsetInfo {
public:
  virtual ~LoadBalancerSubsetInfo() = default;

  /**
   * @return bool true if load balancer subsets are configured.
   */
  virtual bool isEnabled() const PURE;

  /**
   * @return LbSubsetFallbackPolicy the fallback policy used when
   * route metadata does not match any subset.
   */
  virtual envoy::config::cluster::v3::Cluster::LbSubsetConfig::LbSubsetFallbackPolicy
  fallbackPolicy() const PURE;

  /**
   * @return LbSubsetMetadataFallbackPolicy the fallback policy used to try different route metadata
   * until a host is found
   */
  virtual envoy::config::cluster::v3::Cluster::LbSubsetConfig::LbSubsetMetadataFallbackPolicy
  metadataFallbackPolicy() const PURE;

  /**
   * @return ProtobufWkt::Struct the struct describing the metadata for a
   *         host to be included in the default subset.
   */
  virtual const ProtobufWkt::Struct& defaultSubset() const PURE;

  /*
   * @return const std:vector<std:set<std::string>>& a vector of
   * sorted keys used to define load balancer subsets.
   */
  virtual const std::vector<SubsetSelectorPtr>& subsetSelectors() const PURE;

  /*
   * @return bool whether routing to subsets should take locality weights into account.
   */
  virtual bool localityWeightAware() const PURE;

  /*
   * @return bool whether the locality weights should be scaled to compensate for the
   * fraction of hosts removed from the original host set.
   */
  virtual bool scaleLocalityWeight() const PURE;

  /*
   * @return bool whether to attempt to select a host from the entire cluster if host
   * selection from the fallback subset fails.
   */
  virtual bool panicModeAny() const PURE;

  /*
   * @return bool whether matching metadata should attempt to match against any of the
   * elements in a list value defined in endpoint metadata.
   */
  virtual bool listAsAny() const PURE;

  /*
   * @return bool whether redundant key/value pairs is allowed in the request metadata.
   */
  virtual bool allowRedundantKeys() const PURE;
};

} // namespace Upstream
} // namespace Envoy
#pragma once

#include <cstddef>
#include <cstdint>
#include <memory>

#include "envoy/common/pure.h"
#include "envoy/common/resource.h"

namespace Envoy {
namespace Upstream {

/**
 * Resource priority classes. The parallel NumResourcePriorities constant allows defining fixed
 * arrays for each priority, but does not pollute the enum.
 */
enum class ResourcePriority : uint8_t { Default, High };
const size_t NumResourcePriorities = 2;

/**
 * RAII wrapper that increments a resource on construction and decrements it on destruction.
 */
class ResourceAutoIncDec {
public:
  ResourceAutoIncDec(ResourceLimit& resource) : resource_(resource) { resource_.inc(); }
  ~ResourceAutoIncDec() { resource_.dec(); }

private:
  ResourceLimit& resource_;
};

using ResourceAutoIncDecPtr = std::unique_ptr<ResourceAutoIncDec>;

/**
 * Global resource manager that loosely synchronizes maximum connections, pending requests, etc.
 * NOTE: Currently this is used on a per cluster basis. In the future we may consider also chaining
 *       this with a global resource manager.
 */
class ResourceManager {
public:
  virtual ~ResourceManager() = default;

  /**
   * @return ResourceLimit& active TCP connections and UDP sessions.
   */
  virtual ResourceLimit& connections() PURE;

  /**
   * @return ResourceLimit& active pending requests (requests that have not yet been attached to a
   *         connection pool connection).
   */
  virtual ResourceLimit& pendingRequests() PURE;

  /**
   * @return ResourceLimit& active requests (requests that are currently bound to a connection pool
   *         connection and are awaiting response).
   */
  virtual ResourceLimit& requests() PURE;

  /**
   * @return ResourceLimit& active retries.
   */
  virtual ResourceLimit& retries() PURE;

  /**
   * @return ResourceLimit& active connection pools.
   */
  virtual ResourceLimit& connectionPools() PURE;

  /**
   * @return uint64_t the max number of connections per host.
   */
  virtual uint64_t maxConnectionsPerHost() PURE;
};

} // namespace Upstream
} // namespace Envoy
#pragma once

#include <chrono>
#include <functional>
#include <memory>
#include <string>

#include "envoy/access_log/access_log.h"
#include "envoy/api/api.h"
#include "envoy/common/random_generator.h"
#include "envoy/config/bootstrap/v3/bootstrap.pb.h"
#include "envoy/config/cluster/v3/cluster.pb.h"
#include "envoy/config/core/v3/address.pb.h"
#include "envoy/config/core/v3/config_source.pb.h"
#include "envoy/config/core/v3/protocol.pb.h"
#include "envoy/config/eds_resources_cache.h"
#include "envoy/config/grpc_mux.h"
#include "envoy/config/subscription_factory.h"
#include "envoy/grpc/async_client_manager.h"
#include "envoy/http/conn_pool.h"
#include "envoy/http/persistent_quic_info.h"
#include "envoy/local_info/local_info.h"
#include "envoy/runtime/runtime.h"
#include "envoy/secret/secret_manager.h"
#include "envoy/server/admin.h"
#include "envoy/server/options.h"
#include "envoy/singleton/manager.h"
#include "envoy/ssl/context_manager.h"
#include "envoy/stats/store.h"
#include "envoy/tcp/conn_pool.h"
#include "envoy/thread_local/thread_local.h"
#include "envoy/upstream/health_checker.h"
#include "envoy/upstream/load_balancer.h"
#include "envoy/upstream/thread_local_cluster.h"
#include "envoy/upstream/upstream.h"

#include "absl/container/flat_hash_set.h"
#include "absl/container/node_hash_map.h"

namespace Envoy {
namespace Upstream {

/**
 * ClusterUpdateCallbacks provide a way to expose Cluster lifecycle events in the
 * ClusterManager.
 */
using ThreadLocalClusterCommand = std::function<ThreadLocalCluster&()>;
class ClusterUpdateCallbacks {
public:
  virtual ~ClusterUpdateCallbacks() = default;

  /**
   * onClusterAddOrUpdate is called when a new cluster is added or an existing cluster
   * is updated in the ClusterManager.
   * @param cluster_name the name of the changed cluster.
   * @param get_cluster is a callable that will provide the ThreadLocalCluster that represents the
   * updated cluster. It should be used within the call or discarded.
   */
  virtual void onClusterAddOrUpdate(absl::string_view cluster_name,
                                    ThreadLocalClusterCommand& get_cluster) PURE;
  /**
   * onClusterRemoval is called when a cluster is removed; the argument is the cluster name.
   * @param cluster_name is the name of the removed cluster.
   */
  virtual void onClusterRemoval(const std::string& cluster_name) PURE;
};

/**
 * ClusterUpdateCallbacksHandle is a RAII wrapper for a ClusterUpdateCallbacks. Deleting
 * the ClusterUpdateCallbacksHandle will remove the callbacks from ClusterManager in O(1).
 */
class ClusterUpdateCallbacksHandle {
public:
  virtual ~ClusterUpdateCallbacksHandle() = default;
};

using ClusterUpdateCallbacksHandlePtr = std::unique_ptr<ClusterUpdateCallbacksHandle>;

/**
 * Status enum for the result of an attempted cluster discovery.
 */
enum class ClusterDiscoveryStatus {
  /**
   * The discovery process timed out. This means that we haven't yet received any reply from
   * on-demand CDS about it.
   */
  Timeout,
  /**
   * The discovery process has concluded and on-demand CDS has no such cluster.
   */
  Missing,
  /**
   * Cluster found and currently available through ClusterManager.
   */
  Available,
};

/**
 * ClusterDiscoveryCallback is a callback called at the end of the on-demand cluster discovery
 * process. The status of the discovery is sent as a parameter.
 */
using ClusterDiscoveryCallback = std::function<void(ClusterDiscoveryStatus)>;
using ClusterDiscoveryCallbackPtr = std::unique_ptr<ClusterDiscoveryCallback>;

/**
 * ClusterDiscoveryCallbackHandle is a RAII wrapper for a ClusterDiscoveryCallback. Deleting the
 * ClusterDiscoveryCallbackHandle will remove the callbacks from ClusterManager.
 */
class ClusterDiscoveryCallbackHandle {
public:
  virtual ~ClusterDiscoveryCallbackHandle() = default;
};

using ClusterDiscoveryCallbackHandlePtr = std::unique_ptr<ClusterDiscoveryCallbackHandle>;

/**
 * A handle to an on-demand CDS.
 */
class OdCdsApiHandle {
public:
  virtual ~OdCdsApiHandle() = default;

  /**
   * Request an on-demand discovery of a cluster with a passed name. This ODCDS may be used to
   * perform the discovery process in the main thread if there is no discovery going on for this
   * cluster. When the requested cluster is added and warmed up, the passed callback will be invoked
   * in the same thread that invoked this function.
   *
   * The returned handle can be destroyed to prevent the callback from being invoked. Note that the
   * handle can only be destroyed in the same thread that invoked the function. Destroying the
   * handle might not stop the discovery process, though. As soon as the callback is invoked,
   * destroying the handle does nothing. It is a responsibility of the caller to make sure that the
   * objects captured in the callback outlive the callback.
   *
   * This function is thread-safe.
   *
   * @param name is the name of the cluster to be discovered.
   * @param callback will be called when the discovery is finished.
   * @param timeout describes how long the operation may take before failing.
   * @return the discovery process handle.
   */
  virtual ClusterDiscoveryCallbackHandlePtr
  requestOnDemandClusterDiscovery(absl::string_view name, ClusterDiscoveryCallbackPtr callback,
                                  std::chrono::milliseconds timeout) PURE;
};

using OdCdsApiHandlePtr = std::unique_ptr<OdCdsApiHandle>;

class ClusterManagerFactory;

// These are per-cluster per-thread, so not "global" stats.
struct ClusterConnectivityState {
  ~ClusterConnectivityState() {
    ASSERT(pending_streams_ == 0);
    ASSERT(active_streams_ == 0);
    ASSERT(connecting_and_connected_stream_capacity_ == 0);
  }

  template <class T> void checkAndDecrement(T& value, uint32_t delta) {
    ASSERT(std::numeric_limits<T>::min() + delta <= value);
    value -= delta;
  }

  template <class T> void checkAndIncrement(T& value, uint32_t delta) {
    ASSERT(std::numeric_limits<T>::max() - delta >= value);
    value += delta;
  }

  void incrPendingStreams(uint32_t delta) { checkAndIncrement(pending_streams_, delta); }
  void decrPendingStreams(uint32_t delta) { checkAndDecrement(pending_streams_, delta); }
  void incrConnectingAndConnectedStreamCapacity(uint32_t delta) {
    checkAndIncrement(connecting_and_connected_stream_capacity_, delta);
  }
  void decrConnectingAndConnectedStreamCapacity(uint32_t delta) {
    checkAndDecrement(connecting_and_connected_stream_capacity_, delta);
  }
  void incrActiveStreams(uint32_t delta) { checkAndIncrement(active_streams_, delta); }
  void decrActiveStreams(uint32_t delta) { checkAndDecrement(active_streams_, delta); }

  // Tracks the number of pending streams for this ClusterManager.
  uint32_t pending_streams_{};
  // Tracks the number of active streams for this ClusterManager.
  uint32_t active_streams_{};
  // Tracks the available stream capacity if all connecting connections were connected.
  //
  // For example, if an H2 connection is started with concurrent stream limit of 100, this
  // goes up by 100. If the connection is established and 2 streams are in use, it
  // would be reduced to 98 (as 2 of the 100 are not available).
  //
  // Note that if more HTTP/2 streams have been established than are allowed by
  // a late-received SETTINGS frame, this MAY BE NEGATIVE.
  // Note this tracks the sum of multiple 32 bit stream capacities so must remain 64 bit.
  int64_t connecting_and_connected_stream_capacity_{};
};

/**
 * Manages connection pools and load balancing for upstream clusters. The cluster manager is
 * persistent and shared among multiple ongoing requests/connections.
 * Cluster manager is initialized in two phases. In the first phase which begins at the construction
 * all primary clusters (i.e. with endpoint assignments provisioned statically in bootstrap,
 * discovered through DNS or file based CDS) are initialized. This phase may complete synchronously
 * with cluster manager construction iff all clusters are STATIC and without health checks
 * configured. At the completion of the first phase cluster manager invokes callback set through the
 * `setPrimaryClustersInitializedCb` method.
 * After the first phase has completed the server instance initializes services (i.e. RTDS) needed
 * to successfully deploy the rest of dynamic configuration.
 * In the second phase all secondary clusters (with endpoint assignments provisioned by xDS servers)
 * are initialized and then the rest of the configuration provisioned through xDS.
 */
class ClusterManager {
public:
  using PrimaryClustersReadyCallback = std::function<void()>;
  using InitializationCompleteCallback = std::function<void()>;

  virtual ~ClusterManager() = default;

  /**
   * Add or update a cluster via API. The semantics of this API are:
   * 1) The hash of the config is used to determine if an already existing cluster has changed.
   *    Nothing is done if the hash matches the previously running configuration.
   * 2) Statically defined clusters (those present when Envoy starts) can not be updated via API.
   *
   * @param cluster supplies the cluster configuration.
   * @param version_info supplies the xDS version of the cluster.
   * @return true if the action results in an add/update of a cluster.
   */
  virtual bool addOrUpdateCluster(const envoy::config::cluster::v3::Cluster& cluster,
                                  const std::string& version_info) PURE;

  /**
   * Set a callback that will be invoked when all primary clusters have been initialized.
   */
  virtual void setPrimaryClustersInitializedCb(PrimaryClustersReadyCallback callback) PURE;

  /**
   * Set a callback that will be invoked when all owned clusters have been initialized.
   */
  virtual void setInitializedCb(InitializationCompleteCallback callback) PURE;

  /**
   * Start initialization of secondary clusters and then dynamically configured clusters.
   * The "initialized callback" set in the method above is invoked when secondary and
   * dynamically provisioned clusters have finished initializing.
   */
  virtual absl::Status
  initializeSecondaryClusters(const envoy::config::bootstrap::v3::Bootstrap& bootstrap) PURE;

  using ClusterInfoMap = absl::flat_hash_map<std::string, std::reference_wrapper<const Cluster>>;
  struct ClusterInfoMaps {
    bool hasCluster(absl::string_view cluster) const {
      return active_clusters_.find(cluster) != active_clusters_.end() ||
             warming_clusters_.find(cluster) != warming_clusters_.end();
    }

    ClusterConstOptRef getCluster(absl::string_view cluster) const {
      auto active_cluster = active_clusters_.find(cluster);
      if (active_cluster != active_clusters_.cend()) {
        return active_cluster->second;
      }
      auto warming_cluster = warming_clusters_.find(cluster);
      if (warming_cluster != warming_clusters_.cend()) {
        return warming_cluster->second;
      }
      return absl::nullopt;
    }

    ClusterInfoMap active_clusters_;
    ClusterInfoMap warming_clusters_;

    // Number of clusters that were dynamically added via API (xDS). This will be
    // less than or equal to the number of `active_clusters_` and `warming_clusters_`.
    uint32_t added_via_api_clusters_num_{0};
  };

  /**
   * @return ClusterInfoMap all current clusters including active and warming.
   *
   * NOTE: This method is only thread safe on the main thread. It should not be called elsewhere.
   */
  virtual ClusterInfoMaps clusters() const PURE;

  using ClusterSet = absl::flat_hash_set<std::string>;

  /**
   * @return const ClusterSet& providing the cluster names that are eligible as
   *         xDS API config sources. These must be static (i.e. in the
   *         bootstrap) and non-EDS.
   */
  virtual const ClusterSet& primaryClusters() PURE;

  /**
   * @return ThreadLocalCluster* the thread local cluster with the given name or nullptr if it
   * does not exist. This is thread safe.
   *
   * NOTE: The pointer returned by this function is ONLY safe to use in the context of the owning
   * call (or if the caller knows that the cluster is fully static and will never be deleted). In
   * the case of dynamic clusters, subsequent event loop iterations may invalidate this pointer.
   * If information about the cluster needs to be kept, use the ThreadLocalCluster::info() method to
   * obtain cluster information that is safe to store.
   *
   * NOTE: This method may return nullptr even if the cluster exists (if it hasn't been warmed yet,
   * propagated to workers, etc.). Use clusters() for general configuration checking on the main
   * thread.
   */
  virtual ThreadLocalCluster* getThreadLocalCluster(absl::string_view cluster) PURE;

  /**
   * Remove a cluster via API. Only clusters added via addOrUpdateCluster() can
   * be removed in this manner. Statically defined clusters present when Envoy starts cannot be
   * removed.
   *
   * @return true if the action results in the removal of a cluster.
   */
  virtual bool removeCluster(const std::string& cluster) PURE;

  /**
   * Shutdown the cluster manager prior to destroying connection pools and other thread local data.
   */
  virtual void shutdown() PURE;

  /**
   * @return whether the shutdown method has been called.
   */
  virtual bool isShutdown() PURE;

  /**
   * @return cluster manager wide bind configuration for new upstream connections.
   */
  virtual const absl::optional<envoy::config::core::v3::BindConfig>& bindConfig() const PURE;

  /**
   * Returns a shared_ptr to the singleton xDS-over-gRPC provider for upstream control plane muxing
   * of xDS. This is treated somewhat as a special case in ClusterManager, since it does not relate
   * logically to the management of clusters but instead is required early in ClusterManager/server
   * initialization and in various sites that need ClusterManager for xDS API interfacing.
   *
   * @return GrpcMux& ADS API provider referencee.
   */
  virtual Config::GrpcMuxSharedPtr adsMux() PURE;

  /**
   * @return Grpc::AsyncClientManager& the cluster manager's gRPC client manager.
   */
  virtual Grpc::AsyncClientManager& grpcAsyncClientManager() PURE;

  /**
   * Return the local cluster name, if it was configured.
   *
   * @return absl::optional<std::string> the local cluster name, or empty if no local cluster was
   * configured.
   */
  virtual const absl::optional<std::string>& localClusterName() const PURE;

  /**
   * This method allows to register callbacks for cluster lifecycle events in the ClusterManager.
   * The callbacks will be registered in a thread local slot and the callbacks will be executed
   * on the thread that registered them.
   * To be executed on all threads, Callbacks need to be registered on all threads.
   *
   * @param callbacks are the ClusterUpdateCallbacks to add or remove to the cluster manager.
   * @return ClusterUpdateCallbacksHandlePtr a RAII that needs to be deleted to
   * unregister the callback.
   */
  virtual ClusterUpdateCallbacksHandlePtr
  addThreadLocalClusterUpdateCallbacks(ClusterUpdateCallbacks& callbacks) PURE;

  /**
   * Return the factory to use for creating cluster manager related objects.
   */
  virtual ClusterManagerFactory& clusterManagerFactory() PURE;

  /**
   * Obtain the subscription factory for the cluster manager. Since subscriptions may have an
   * upstream component, the factory is a facet of the cluster manager.
   *
   * @return Config::SubscriptionFactory& the subscription factory.
   */
  virtual Config::SubscriptionFactory& subscriptionFactory() PURE;

  /**
   * Returns a struct with all the Stats::StatName objects needed by
   * Clusters. This helps factor out some relatively heavy name
   * construction which occur when there is a large CDS update during operation,
   * relative to recreating all stats from strings on-the-fly.
   *
   * @return the stat names.
   */
  virtual const ClusterTrafficStatNames& clusterStatNames() const PURE;
  virtual const ClusterConfigUpdateStatNames& clusterConfigUpdateStatNames() const PURE;
  virtual const ClusterLbStatNames& clusterLbStatNames() const PURE;
  virtual const ClusterEndpointStatNames& clusterEndpointStatNames() const PURE;
  virtual const ClusterLoadReportStatNames& clusterLoadReportStatNames() const PURE;
  virtual const ClusterCircuitBreakersStatNames& clusterCircuitBreakersStatNames() const PURE;
  virtual const ClusterRequestResponseSizeStatNames&
  clusterRequestResponseSizeStatNames() const PURE;
  virtual const ClusterTimeoutBudgetStatNames& clusterTimeoutBudgetStatNames() const PURE;

  /**
   * Predicate function used in drainConnections().
   * @param host supplies the host that is about to be drained.
   * @return true if the host should be drained, and false otherwise.
   *
   * IMPORTANT: This predicate must be completely self contained and thread safe. It will be posted
   * to all worker threads and run concurrently.
   */
  using DrainConnectionsHostPredicate = std::function<bool(const Host&)>;

  /**
   * Drain all connection pool connections owned by this cluster.
   * @param cluster, the cluster to drain.
   * @param predicate supplies the optional drain connections host predicate. If not supplied, all
   *                  hosts are drained.
   */
  virtual void drainConnections(const std::string& cluster,
                                DrainConnectionsHostPredicate predicate) PURE;

  /**
   * Drain all connection pool connections owned by all clusters in the cluster manager.
   * @param predicate supplies the optional drain connections host predicate. If not supplied, all
   *                  hosts are drained.
   */
  virtual void drainConnections(DrainConnectionsHostPredicate predicate) PURE;

  /**
   * Check if the cluster is active and statically configured, and if not, return an error
   * @param cluster, the cluster to check.
   */
  virtual absl::Status checkActiveStaticCluster(const std::string& cluster) PURE;

  /**
   * Allocates an on-demand CDS API provider from configuration proto or locator.
   *
   * @param odcds_config is a configuration proto. Used when odcds_resources_locator is a nullopt.
   * @param odcds_resources_locator is a locator for ODCDS. Used over odcds_config if not a nullopt.
   * @param validation_visitor
   * @return OdCdsApiHandlePtr the ODCDS handle.
   */
  virtual OdCdsApiHandlePtr
  allocateOdCdsApi(const envoy::config::core::v3::ConfigSource& odcds_config,
                   OptRef<xds::core::v3::ResourceLocator> odcds_resources_locator,
                   ProtobufMessage::ValidationVisitor& validation_visitor) PURE;

  /**
   * @param common_lb_config The config field to be stored
   * @return shared_ptr to the CommonLbConfig
   */
  virtual std::shared_ptr<const envoy::config::cluster::v3::Cluster::CommonLbConfig>
  getCommonLbConfigPtr(
      const envoy::config::cluster::v3::Cluster::CommonLbConfig& common_lb_config) PURE;

  /**
   * Returns an EdsResourcesCache that is unique for the cluster manager.
   */
  virtual Config::EdsResourcesCacheOptRef edsResourcesCache() PURE;
};

using ClusterManagerPtr = std::unique_ptr<ClusterManager>;

/**
 * Abstract interface for a CDS API provider.
 */
class CdsApi {
public:
  virtual ~CdsApi() = default;

  /**
   * Start the first fetch of CDS data.
   */
  virtual void initialize() PURE;

  /**
   * Set a callback that will be called when the CDS API has done an initial load from the remote
   * server. If the initial load fails, the callback will also be called.
   */
  virtual void setInitializedCb(std::function<void()> callback) PURE;

  /**
   * @return std::string last accepted version from fetch.
   */
  virtual const std::string versionInfo() const PURE;
};

using CdsApiPtr = std::unique_ptr<CdsApi>;

/**
 * Factory for objects needed during cluster manager operation.
 */
class ClusterManagerFactory {
public:
  virtual ~ClusterManagerFactory() = default;

  /**
   * Allocate a cluster manager from configuration proto.
   */
  virtual ClusterManagerPtr
  clusterManagerFromProto(const envoy::config::bootstrap::v3::Bootstrap& bootstrap) PURE;

  /**
   * Allocate an HTTP connection pool for the host. Pools are separated by 'priority',
   * 'protocol', and 'options->hashKey()', if any.
   */
  virtual Http::ConnectionPool::InstancePtr
  allocateConnPool(Event::Dispatcher& dispatcher, HostConstSharedPtr host,
                   ResourcePriority priority, std::vector<Http::Protocol>& protocol,
                   const absl::optional<envoy::config::core::v3::AlternateProtocolsCacheOptions>&
                       alternate_protocol_options,
                   const Network::ConnectionSocket::OptionsSharedPtr& options,
                   const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,
                   TimeSource& time_source, ClusterConnectivityState& state,
                   Http::PersistentQuicInfoPtr& quic_info) PURE;

  /**
   * Allocate a TCP connection pool for the host. Pools are separated by 'priority' and
   * 'options->hashKey()', if any.
   */
  virtual Tcp::ConnectionPool::InstancePtr
  allocateTcpConnPool(Event::Dispatcher& dispatcher, HostConstSharedPtr host,
                      ResourcePriority priority,
                      const Network::ConnectionSocket::OptionsSharedPtr& options,
                      Network::TransportSocketOptionsConstSharedPtr transport_socket_options,
                      ClusterConnectivityState& state,
                      absl::optional<std::chrono::milliseconds> tcp_pool_idle_timeout) PURE;

  /**
   * Allocate a cluster from configuration proto.
   */
  virtual absl::StatusOr<std::pair<ClusterSharedPtr, ThreadAwareLoadBalancerPtr>>
  clusterFromProto(const envoy::config::cluster::v3::Cluster& cluster, ClusterManager& cm,
                   Outlier::EventLoggerSharedPtr outlier_event_logger, bool added_via_api) PURE;

  /**
   * Create a CDS API provider from configuration proto.
   */
  virtual CdsApiPtr createCds(const envoy::config::core::v3::ConfigSource& cds_config,
                              const xds::core::v3::ResourceLocator* cds_resources_locator,
                              ClusterManager& cm) PURE;

  /**
   * Returns the secret manager.
   */
  virtual Secret::SecretManager& secretManager() PURE;

  /**
   * Returns the singleton manager.
   */
  virtual Singleton::Manager& singletonManager() PURE;
};

/**
 * Factory for creating ClusterInfo
 */
class ClusterInfoFactory {
public:
  virtual ~ClusterInfoFactory() = default;

  /**
   * Parameters for createClusterInfo().
   */
  struct CreateClusterInfoParams {
    Server::Configuration::ServerFactoryContext& server_context_;
    const envoy::config::cluster::v3::Cluster& cluster_;
    const envoy::config::core::v3::BindConfig& bind_config_;
    Stats::Store& stats_;
    Ssl::ContextManager& ssl_context_manager_;
    const bool added_via_api_;
    ThreadLocal::SlotAllocator& tls_;
  };

  /**
   * This method returns a Upstream::ClusterInfoConstSharedPtr given construction parameters.
   */
  virtual Upstream::ClusterInfoConstSharedPtr
  createClusterInfo(const CreateClusterInfoParams& params) PURE;
};

} // namespace Upstream
} // namespace Envoy
#pragma once

#include <functional>
#include <memory>

#include "envoy/data/core/v3/health_check_event.pb.h"
#include "envoy/upstream/upstream.h"

namespace Envoy {
namespace Upstream {

enum class HealthState { Unhealthy, Healthy };

enum class HealthTransition {
  /**
   * Used when the health state of a host hasn't changed.
   */
  Unchanged,
  /**
   * Used when the health state of a host has changed.
   */
  Changed,
  /**
   * Used when the health check result differs from the health state of a host, but a change to the
   * latter is delayed due to healthy/unhealthy threshold settings.
   */
  ChangePending
};

/**
 * Wraps active health checking of an upstream cluster.
 */
class HealthChecker {
public:
  virtual ~HealthChecker() = default;

  /**
   * Called when a host has been health checked.
   * @param host supplies the host that was just health checked.
   * @param changed_state supplies whether the health check resulted in a host moving from healthy
   *                       to not healthy or vice versa.
   */
  using HostStatusCb =
      std::function<void(const HostSharedPtr& host, HealthTransition changed_state)>;

  /**
   * Install a callback that will be invoked every time a health check round is completed for
   * a host. The host's health check state may not have changed.
   * @param callback supplies the callback to invoke.
   */
  virtual void addHostCheckCompleteCb(HostStatusCb callback) PURE;

  /**
   * Start cyclic health checking based on the provided settings and the type of health checker.
   */
  virtual void start() PURE;
};

using HealthCheckerSharedPtr = std::shared_ptr<HealthChecker>;

std::ostream& operator<<(std::ostream& out, HealthState state);
std::ostream& operator<<(std::ostream& out, HealthTransition changed_state);

/**
 * Sink for health check event logs.
 */
class HealthCheckEventLogger {
public:
  virtual ~HealthCheckEventLogger() = default;

  /**
   * Log an unhealthy host ejection event.
   * @param health_checker_type supplies the type of health checker that generated the event.
   * @param host supplies the host that generated the event.
   * @param failure_type supplies the type of health check failure.
   */
  virtual void logEjectUnhealthy(envoy::data::core::v3::HealthCheckerType health_checker_type,
                                 const HostDescriptionConstSharedPtr& host,
                                 envoy::data::core::v3::HealthCheckFailureType failure_type) PURE;

  /**
   * Log an unhealthy host event.
   * @param health_checker_type supplies the type of health checker that generated the event.
   * @param host supplies the host that generated the event.
   * @param failure_type supplies the type of health check failure.
   * @param first_check whether this is a failure on the first health check for this host.
   */
  virtual void logUnhealthy(envoy::data::core::v3::HealthCheckerType health_checker_type,
                            const HostDescriptionConstSharedPtr& host,
                            envoy::data::core::v3::HealthCheckFailureType failure_type,
                            bool first_check) PURE;

  /**
   * Log a healthy host addition event.
   * @param health_checker_type supplies the type of health checker that generated the event.
   * @param host supplies the host that generated the event.
   * @param healthy_threshold supplied the configured healthy threshold for this health check.
   * @param first_check whether this is a fast path success on the first health check for this host.
   */
  virtual void logAddHealthy(envoy::data::core::v3::HealthCheckerType health_checker_type,
                             const HostDescriptionConstSharedPtr& host, bool first_check) PURE;

  /**
   * Log a degraded healthy host event.
   * @param health_checker_type supplies the type of health checker that generated the event.
   * @param host supplies the host that generated the event.
   */
  virtual void logDegraded(envoy::data::core::v3::HealthCheckerType health_checker_type,
                           const HostDescriptionConstSharedPtr& host) PURE;
  /**
   * Log a no degraded healthy host event.
   * @param health_checker_type supplies the type of health checker that generated the event.
   * @param host supplies the host that generated the event.
   */
  virtual void logNoLongerDegraded(envoy::data::core::v3::HealthCheckerType health_checker_type,
                                   const HostDescriptionConstSharedPtr& host) PURE;
};

using HealthCheckEventLoggerPtr = std::unique_ptr<HealthCheckEventLogger>;

} // namespace Upstream
} // namespace Envoy
#pragma once

#include "envoy/common/pure.h"
#include "envoy/http/async_client.h"
#include "envoy/tcp/async_tcp_client.h"
#include "envoy/upstream/load_balancer.h"
#include "envoy/upstream/upstream.h"

namespace Envoy {
namespace Upstream {

// HttpPoolData returns information about a given pool as well as a function
// to create streams on that pool.
class HttpPoolData {
public:
  using OnNewStreamFn = std::function<void()>;

  HttpPoolData(OnNewStreamFn on_new_stream, Http::ConnectionPool::Instance* pool)
      : on_new_stream_(on_new_stream), pool_(pool) {}

  /**
   * See documentation of Http::ConnectionPool::Instance.
   */
  Envoy::Http::ConnectionPool::Cancellable*
  newStream(Http::ResponseDecoder& response_decoder,
            Envoy::Http::ConnectionPool::Callbacks& callbacks,
            const Http::ConnectionPool::Instance::StreamOptions& stream_options) {
    on_new_stream_();
    return pool_->newStream(response_decoder, callbacks, stream_options);
  }
  bool hasActiveConnections() const { return pool_->hasActiveConnections(); };

  /**
   * See documentation of Envoy::ConnectionPool::Instance.
   */
  void addIdleCallback(ConnectionPool::Instance::IdleCb cb) { pool_->addIdleCallback(cb); };
  void drainConnections(ConnectionPool::DrainBehavior drain_behavior) {
    pool_->drainConnections(drain_behavior);
  };

  Upstream::HostDescriptionConstSharedPtr host() const { return pool_->host(); }

private:
  friend class HttpPoolDataPeer;

  OnNewStreamFn on_new_stream_;
  Http::ConnectionPool::Instance* pool_;
};

// Tcp pool returns information about a given pool, as well as a function to
// create connections on that pool.
class TcpPoolData {
public:
  using OnNewConnectionFn = std::function<void()>;

  TcpPoolData(OnNewConnectionFn on_new_connection, Tcp::ConnectionPool::Instance* pool)
      : on_new_connection_(on_new_connection), pool_(pool) {}

  Envoy::Tcp::ConnectionPool::Cancellable*
  newConnection(Envoy::Tcp::ConnectionPool::Callbacks& callbacks) {
    on_new_connection_();
    return pool_->newConnection(callbacks);
  }

  Upstream::HostDescriptionConstSharedPtr host() const { return pool_->host(); }

private:
  friend class TcpPoolDataPeer;
  OnNewConnectionFn on_new_connection_;
  Tcp::ConnectionPool::Instance* pool_;
};

/**
 * A thread local cluster instance that can be used for direct load balancing and host set
 * interactions. In general, an instance of ThreadLocalCluster can only be safely used in the
 * direct call context after it is retrieved from the cluster manager. See ClusterManager::get()
 * for more information.
 */
class ThreadLocalCluster {
public:
  virtual ~ThreadLocalCluster() = default;

  /**
   * @return const PrioritySet& the backing priority set.
   */
  virtual const PrioritySet& prioritySet() PURE;

  /**
   * @return ClusterInfoConstSharedPtr the info for this cluster. The info is safe to store beyond
   * the lifetime of the ThreadLocalCluster instance itself.
   */
  virtual ClusterInfoConstSharedPtr info() PURE;

  /**
   * @return LoadBalancer& the backing load balancer.
   */
  virtual LoadBalancer& loadBalancer() PURE;

  /**
   * Allocate a load balanced HTTP connection pool for a cluster. This is *per-thread* so that
   * callers do not need to worry about per thread synchronization. The load balancing policy that
   * is used is the one defined on the cluster when it was created.
   *
   * @param priority the connection pool priority.
   * @param downstream_protocol the downstream protocol (if one exists) to use in protocol
   *        selection.
   * @param context the optional load balancer context. Must continue to be
   *        valid until newConnection is called on the pool (if it is to be called).
   * @return the connection pool data or nullopt if there is no host available in the cluster.
   */
  virtual absl::optional<HttpPoolData>
  httpConnPool(ResourcePriority priority, absl::optional<Http::Protocol> downstream_protocol,
               LoadBalancerContext* context) PURE;

  /**
   * Allocate a load balanced TCP connection pool for a cluster. This is *per-thread* so that
   * callers do not need to worry about per thread synchronization. The load balancing policy that
   * is used is the one defined on the cluster when it was created.
   *
   * @param priority the connection pool priority.
   * @param context the optional load balancer context. Must continue to be
   *        valid until newConnection is called on the pool (if it is to be called).
   * @return the connection pool data or nullopt if there is no host available in the cluster.
   */
  virtual absl::optional<TcpPoolData> tcpConnPool(ResourcePriority priority,
                                                  LoadBalancerContext* context) PURE;

  /**
   * Allocate a load balanced TCP connection for a cluster. The created connection is already
   * bound to the correct *per-thread* dispatcher, so no further synchronization is needed. The
   * load balancing policy that is used is the one defined on the cluster when it was created.
   *
   * @param context the optional load balancer context.
   * @return both a connection and the host that backs the connection. Both can be nullptr if there
   *         is no host available in the cluster.
   */
  virtual Host::CreateConnectionData tcpConn(LoadBalancerContext* context) PURE;

  /**
   * @return a client that can be used to make async HTTP calls against the given cluster. The
   * client may be backed by a connection pool or by a multiplexed connection. The cluster manager
   * owns the client.
   */
  virtual Http::AsyncClient& httpAsyncClient() PURE;

  /**
   * @param context the optional load balancer context.
   * @param options the tcp client creation config options.
   * @return a client that can be used to make async Tcp calls against the given cluster.
   */
  virtual Tcp::AsyncTcpClientPtr
  tcpAsyncClient(LoadBalancerContext* context,
                 Tcp::AsyncTcpClientOptionsConstSharedPtr options) PURE;

  /**
   * @return the thread local cluster drop_overload configuration.
   */
  virtual UnitFloat dropOverload() const PURE;

  /**
   * Set up the drop_overload value for the thread local cluster.
   */
  virtual void setDropOverload(UnitFloat drop_overload) PURE;
};

using ThreadLocalClusterOptRef = absl::optional<std::reference_wrapper<ThreadLocalCluster>>;

} // namespace Upstream
} // namespace Envoy
#pragma once

#include "envoy/config/typed_config.h"
#include "envoy/server/health_checker_config.h"

namespace Envoy {
namespace Upstream {

/**
 * Sink for health check event.
 */
class HealthCheckEventSink {
public:
  virtual ~HealthCheckEventSink() = default;

  virtual void log(envoy::data::core::v3::HealthCheckEvent event) PURE;
};

using HealthCheckEventSinkPtr = std::unique_ptr<HealthCheckEventSink>;
using HealthCheckEventSinkSharedPtr = std::shared_ptr<HealthCheckEventSink>;

/**
 * A factory abstract class for creating instances of HealthCheckEventSink.
 */
class HealthCheckEventSinkFactory : public Config::TypedFactory {
public:
  ~HealthCheckEventSinkFactory() override = default;

  /**
   * Creates an HealthCheckEventSink using the given config.
   */
  virtual HealthCheckEventSinkPtr
  createHealthCheckEventSink(const ProtobufWkt::Any& config,
                             Server::Configuration::HealthCheckerFactoryContext& context) PURE;

  std::string category() const override { return "envoy.health_check.event_sinks"; }
};

} // namespace Upstream
} // namespace Envoy
#pragma once

#include <chrono>
#include <cstdint>
#include <functional>
#include <list>
#include <memory>
#include <string>
#include <vector>

#include "envoy/access_log/access_log.h"
#include "envoy/api/api.h"
#include "envoy/common/random_generator.h"
#include "envoy/config/cluster/v3/cluster.pb.h"
#include "envoy/config/typed_config.h"
#include "envoy/event/dispatcher.h"
#include "envoy/local_info/local_info.h"
#include "envoy/network/dns.h"
#include "envoy/runtime/runtime.h"
#include "envoy/server/admin.h"
#include "envoy/server/factory_context.h"
#include "envoy/server/options.h"
#include "envoy/singleton/manager.h"
#include "envoy/ssl/context.h"
#include "envoy/ssl/context_manager.h"
#include "envoy/stats/stats.h"
#include "envoy/stats/store.h"
#include "envoy/thread_local/thread_local.h"
#include "envoy/upstream/cluster_manager.h"
#include "envoy/upstream/outlier_detection.h"

namespace Envoy {
namespace Upstream {

/**
 * Context passed to cluster factory to access Envoy resources. Cluster factory should only access
 * the rest of the server through this context object.
 */
class ClusterFactoryContext {
public:
  virtual ~ClusterFactoryContext() = default;

  /**
   * @return Server::Configuration::ServerFactoryContext& the server factory context. All the
   *         server-wide resources should be accessed through this context.
   */
  virtual Server::Configuration::ServerFactoryContext& serverFactoryContext() PURE;

  /**
   * @return Upstream::ClusterManager& singleton for use by the entire server.
   * TODO(wbpcode): clusterManager() of ServerFactoryContext still be invalid when loading
   * static cluster. So we need to provide an cluster manager reference here.
   * This could be removed after https://github.com/envoyproxy/envoy/issues/26653 is resolved.
   */
  virtual Upstream::ClusterManager& clusterManager() PURE;

  /**
   * @return ProtobufMessage::ValidationVisitor& validation visitor for cluster configuration
   * messages.
   */
  virtual ProtobufMessage::ValidationVisitor& messageValidationVisitor() PURE;

  /**
   * @return bool flag indicating whether the cluster is added via api.
   */
  virtual bool addedViaApi() PURE;

  /**
   * @return Network::DnsResolverSharedPtr the dns resolver for the server.
   */
  virtual Network::DnsResolverSharedPtr dnsResolver() PURE;

  /**
   * @return Ssl::ContextManager& the SSL context manager.
   */
  virtual Ssl::ContextManager& sslContextManager() PURE;

  /**
   * @return Outlier::EventLoggerSharedPtr sink for outlier detection event logs.
   */
  virtual Outlier::EventLoggerSharedPtr outlierEventLogger() PURE;
};

/**
 * Implemented by cluster and registered via Registry::registerFactory() or the convenience class
 * RegisterFactory.
 */
class ClusterFactory : public Config::UntypedFactory {
public:
  ~ClusterFactory() override = default;

  /**
   * Create a new instance of cluster. If the implementation is unable to produce a cluster instance
   * with the provided parameters, it should throw an EnvoyException in the case of general error.
   * @param cluster supplies the general protobuf configuration for the cluster.
   * @param context supplies the cluster's context.
   * @return a pair containing the cluster instance as well as an option thread aware load balancer
   * if this cluster has an integrated load balancer or an absl::Satus error on failure.
   */
  virtual absl::StatusOr<std::pair<ClusterSharedPtr, ThreadAwareLoadBalancerPtr>>
  create(const envoy::config::cluster::v3::Cluster& cluster, ClusterFactoryContext& context) PURE;

  std::string category() const override { return "envoy.clusters"; }
};

} // namespace Upstream
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "cluster_manager_interface",
    hdrs = ["cluster_manager.h"],
    external_deps = [
        "abseil_node_hash_map",
    ],
    deps = [
        ":health_checker_interface",
        ":load_balancer_interface",
        ":thread_local_cluster_interface",
        ":upstream_interface",
        "//envoy/access_log:access_log_interface",
        "//envoy/common:random_generator_interface",
        "//envoy/config:grpc_mux_interface",
        "//envoy/config:subscription_factory_interface",
        "//envoy/grpc:async_client_manager_interface",
        "//envoy/http:async_client_interface",
        "//envoy/http:conn_pool_interface",
        "//envoy/http:persistent_quic_info_interface",
        "//envoy/local_info:local_info_interface",
        "//envoy/runtime:runtime_interface",
        "//envoy/secret:secret_manager_interface",
        "//envoy/server:admin_interface",
        "//envoy/server:options_interface",
        "//envoy/singleton:manager_interface",
        "//envoy/tcp:conn_pool_interface",
        "//envoy/thread_local:thread_local_interface",
        "@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/cluster/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "health_check_event_sink_interface",
    hdrs = ["health_check_event_sink.h"],
    deps = [
        "//envoy/config:typed_config_interface",
        "//envoy/server:health_checker_config_interface",
    ],
)

envoy_cc_library(
    name = "health_checker_interface",
    hdrs = ["health_checker.h"],
    deps = [
        ":upstream_interface",
        "@envoy_api//envoy/data/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "health_check_host_monitor_interface",
    hdrs = ["health_check_host_monitor.h"],
)

envoy_cc_library(
    name = "host_description_interface",
    hdrs = ["host_description.h"],
    deps = [
        ":health_check_host_monitor_interface",
        ":outlier_detection_interface",
        ":resource_manager_interface",
        "//envoy/network:address_interface",
        "//envoy/network:transport_socket_interface",
        "//envoy/stats:primitive_stats_macros",
        "//envoy/stats:stats_macros",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "load_balancer_interface",
    hdrs = ["load_balancer.h"],
    deps = [
        ":upstream_interface",
        "//envoy/router:router_interface",
        "//envoy/upstream:types_interface",
    ],
)

envoy_cc_library(
    name = "load_balancer_type_interface",
    hdrs = ["load_balancer_type.h"],
    deps = [
        "//source/common/protobuf",
        "@envoy_api//envoy/config/cluster/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "locality_lib",
    hdrs = ["locality.h"],
    deps = [
        "//source/common/protobuf:utility_lib",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "outlier_detection_interface",
    hdrs = ["outlier_detection.h"],
    external_deps = ["abseil_optional"],
    deps = [
        "//envoy/common:time_interface",
        "@envoy_api//envoy/data/cluster/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "retry_interface",
    hdrs = ["retry.h"],
    deps = [
        "//envoy/config:typed_config_interface",
        "//envoy/upstream:types_interface",
        "//envoy/upstream:upstream_interface",
    ],
)

envoy_cc_library(
    name = "resource_manager_interface",
    hdrs = ["resource_manager.h"],
    deps = ["//envoy/common:resource_interface"],
)

envoy_cc_library(
    name = "thread_local_cluster_interface",
    hdrs = ["thread_local_cluster.h"],
    deps = [
        ":load_balancer_interface",
        ":upstream_interface",
        "//envoy/http:async_client_interface",
        "//envoy/tcp:async_tcp_client_interface",
    ],
)

envoy_cc_library(
    name = "types_interface",
    hdrs = ["types.h"],
    deps = [
        "//source/common/common:phantom",
    ],
)

envoy_cc_library(
    name = "upstream_interface",
    hdrs = ["upstream.h"],
    external_deps = ["abseil_optional"],
    deps = [
        ":health_check_host_monitor_interface",
        ":load_balancer_type_interface",
        ":locality_lib",
        ":resource_manager_interface",
        "//envoy/common:callback",
        "//envoy/config:subscription_interface",
        "//envoy/config:typed_metadata_interface",
        "//envoy/http:codec_interface",
        "//envoy/http:filter_factory_interface",
        "//envoy/http:header_validator_interface",
        "//envoy/network:connection_interface",
        "//envoy/network:transport_socket_interface",
        "//envoy/runtime:runtime_interface",
        "//envoy/ssl:context_interface",
        "//envoy/ssl:context_manager_interface",
        "//envoy/upstream:types_interface",
        "@envoy_api//envoy/config/cluster/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "cluster_factory_interface",
    hdrs = ["cluster_factory.h"],
    deps = [
        ":cluster_manager_interface",
        ":health_check_host_monitor_interface",
        ":load_balancer_type_interface",
        ":locality_lib",
        ":resource_manager_interface",
        ":upstream_interface",
        "//envoy/common:callback",
        "//envoy/config:typed_config_interface",
        "//envoy/config:typed_metadata_interface",
        "//envoy/http:codec_interface",
        "//envoy/network:connection_interface",
        "//envoy/network:transport_socket_interface",
        "//envoy/runtime:runtime_interface",
        "//envoy/ssl:context_interface",
        "//envoy/ssl:context_manager_interface",
        "@envoy_api//envoy/config/cluster/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "scheduler_interface",
    hdrs = ["scheduler.h"],
    deps = [
    ],
)
#pragma once

#include <memory>

#include "envoy/common/pure.h"

namespace Envoy {
namespace Upstream {

/**
 * A monitor for "passive" health check events that might happen on every thread. For example, if a
 * special HTTP header is received, the data plane may decide to fast fail a host to avoid waiting
 * for the full Health Check interval to elapse before determining the host is active health check
 * failed.
 */
class HealthCheckHostMonitor {
public:
  virtual ~HealthCheckHostMonitor() = default;

  /**
   * The reason the host is being set unhealthy via the monitor.
   */
  enum class UnhealthyType {
    // Protocol indication (e.g., x-envoy-immediate-health-check-fail) that the host should be
    // immediately taken out of rotation.
    ImmediateHealthCheckFail
  };

  /**
   * Mark the host as unhealthy. Note that this may not be immediate as events may need to be
   * propagated between multiple threads.
   * @param type specifies the reason the host is being marked unhealthy.
   */
  virtual void setUnhealthy(UnhealthyType type) PURE;
};

using HealthCheckHostMonitorPtr = std::unique_ptr<HealthCheckHostMonitor>;

} // namespace Upstream
} // namespace Envoy
#pragma once

#include <chrono>
#include <cstdint>
#include <functional>
#include <list>
#include <memory>
#include <string>
#include <vector>

#include "envoy/common/callback.h"
#include "envoy/common/optref.h"
#include "envoy/config/cluster/v3/cluster.pb.h"
#include "envoy/config/core/v3/base.pb.h"
#include "envoy/config/core/v3/protocol.pb.h"
#include "envoy/config/typed_metadata.h"
#include "envoy/http/codec.h"
#include "envoy/http/filter_factory.h"
#include "envoy/http/header_validator.h"
#include "envoy/network/connection.h"
#include "envoy/network/transport_socket.h"
#include "envoy/ssl/context.h"
#include "envoy/stats/scope.h"
#include "envoy/stats/stats.h"
#include "envoy/upstream/health_check_host_monitor.h"
#include "envoy/upstream/load_balancer_type.h"
#include "envoy/upstream/locality.h"
#include "envoy/upstream/outlier_detection.h"
#include "envoy/upstream/resource_manager.h"
#include "envoy/upstream/types.h"

#include "absl/strings/string_view.h"
#include "absl/types/optional.h"
#include "fmt/format.h"

namespace Envoy {
namespace Http {
class FilterChainManager;
}

namespace Upstream {

/**
 * A bundle struct for address and socket options.
 */
struct UpstreamLocalAddress {
public:
  Network::Address::InstanceConstSharedPtr address_;
  Network::ConnectionSocket::OptionsSharedPtr socket_options_;
};

/**
 * Interface to select upstream local address based on the endpoint address.
 */
class UpstreamLocalAddressSelector {
public:
  virtual ~UpstreamLocalAddressSelector() = default;

  /**
   * Return UpstreamLocalAddress based on the endpoint address.
   * @param endpoint_address is the address used to select upstream local address.
   * @param socket_options applied to the selected address.
   * @return UpstreamLocalAddress which includes the selected upstream local address and socket
   * options.
   */
  UpstreamLocalAddress
  getUpstreamLocalAddress(const Network::Address::InstanceConstSharedPtr& endpoint_address,
                          const Network::ConnectionSocket::OptionsSharedPtr& socket_options) const {
    UpstreamLocalAddress local_address = getUpstreamLocalAddressImpl(endpoint_address);
    Network::ConnectionSocket::OptionsSharedPtr connection_options =
        std::make_shared<Network::ConnectionSocket::Options>(
            socket_options ? *socket_options
                           : std::vector<Network::ConnectionSocket::OptionConstSharedPtr>{});
    return {local_address.address_,
            local_address.socket_options_ != nullptr
                ? Network::Socket::appendOptions(connection_options, local_address.socket_options_)
                : connection_options};
  }

private:
  /*
   * The implementation is responsible for picking the ``UpstreamLocalAddress``
   * based on the ``endpoint_address``. However adding the connection socket
   * options is the responsibility of the base class.
   */
  virtual UpstreamLocalAddress getUpstreamLocalAddressImpl(
      const Network::Address::InstanceConstSharedPtr& endpoint_address) const PURE;
};

using UpstreamLocalAddressSelectorConstSharedPtr =
    std::shared_ptr<const UpstreamLocalAddressSelector>;

class UpstreamLocalAddressSelectorFactory : public Config::TypedFactory {
public:
  ~UpstreamLocalAddressSelectorFactory() override = default;

  /**
   * @param cluster_name is set to the name of the cluster if ``bind_config`` is
   *   from cluster config. If the bind config from the cluster manager, the param
   *   is empty.
   */
  virtual absl::StatusOr<UpstreamLocalAddressSelectorConstSharedPtr>
  createLocalAddressSelector(std::vector<UpstreamLocalAddress> upstream_local_addresses,
                             absl::optional<std::string> cluster_name) const PURE;

  std::string category() const override { return "envoy.upstream.local_address_selector"; }
};

/**
 * RAII handle for tracking the host usage by the connection pools.
 **/
class HostHandle {
public:
  virtual ~HostHandle() = default;
};

using HostHandlePtr = std::unique_ptr<HostHandle>;

/**
 * An upstream host.
 */
class Host : virtual public HostDescription {
public:
  struct CreateConnectionData {
    Network::ClientConnectionPtr connection_;
    HostDescriptionConstSharedPtr host_description_;
  };

  // We use an X-macro here to make it easier to verify that all the enum values are accounted for.
  // clang-format off
#define HEALTH_FLAG_ENUM_VALUES(m)                                               \
  /* The host is currently failing active health checks. */                      \
  m(FAILED_ACTIVE_HC, 0x1)                                                       \
  /* The host is currently considered an outlier and has been ejected. */        \
  m(FAILED_OUTLIER_CHECK, 0x02)                                                  \
  /* The host is currently marked as unhealthy by EDS. */                        \
  m(FAILED_EDS_HEALTH, 0x04)                                                     \
  /* The host is currently marked as degraded through active health checking. */ \
  m(DEGRADED_ACTIVE_HC, 0x08)                                                    \
  /* The host is currently marked as degraded by EDS. */                         \
  m(DEGRADED_EDS_HEALTH, 0x10)                                                   \
  /* The host is pending removal from discovery but is stabilized due to */      \
  /* active HC. */                                                               \
  m(PENDING_DYNAMIC_REMOVAL, 0x20)                                               \
  /* The host is pending its initial active health check. */                     \
  m(PENDING_ACTIVE_HC, 0x40)                                                     \
  /* The host should be excluded from panic, spillover, etc. calculations */     \
  /* because it was explicitly taken out of rotation via protocol signal and */  \
  /* is not meant to be routed to. */                                            \
  m(EXCLUDED_VIA_IMMEDIATE_HC_FAIL, 0x80)                                        \
  /* The host failed active HC due to timeout. */                                \
  m(ACTIVE_HC_TIMEOUT, 0x100)
  // clang-format on

#define DECLARE_ENUM(name, value) name = value,

  enum class HealthFlag { HEALTH_FLAG_ENUM_VALUES(DECLARE_ENUM) };

#undef DECLARE_ENUM

  /**
   * @return host specific counters.
   */
  virtual std::vector<std::pair<absl::string_view, Stats::PrimitiveCounterReference>>
  counters() const PURE;

  /**
   * Create a connection for this host.
   * @param dispatcher supplies the owning dispatcher.
   * @param options supplies the socket options that will be set on the new connection.
   * @param transport_socket_options supplies the transport options that will be set on the new
   * connection.
   * @return the connection data which includes the raw network connection as well as the *real*
   *         host that backs it. The reason why a 2nd host is returned is that some hosts are
   *         logical and wrap multiple real network destinations. In this case, a different host
   *         will be returned along with the connection vs. the host the method was called on.
   *         If it matters, callers should not assume that the returned host will be the same.
   */
  virtual CreateConnectionData createConnection(
      Event::Dispatcher& dispatcher, const Network::ConnectionSocket::OptionsSharedPtr& options,
      Network::TransportSocketOptionsConstSharedPtr transport_socket_options) const PURE;

  /**
   * Create a health check connection for this host.
   * @param dispatcher supplies the owning dispatcher.
   * @param transport_socket_options supplies the transport options that will be set on the new
   * connection.
   * @return the connection data.
   */
  virtual CreateConnectionData createHealthCheckConnection(
      Event::Dispatcher& dispatcher,
      Network::TransportSocketOptionsConstSharedPtr transport_socket_options,
      const envoy::config::core::v3::Metadata* metadata) const PURE;

  /**
   * @return host specific gauges.
   */
  virtual std::vector<std::pair<absl::string_view, Stats::PrimitiveGaugeReference>>
  gauges() const PURE;

  /**
   * Atomically clear a health flag for a host. Flags are specified in HealthFlags.
   */
  virtual void healthFlagClear(HealthFlag flag) PURE;

  /**
   * Atomically get whether a health flag is set for a host. Flags are specified in HealthFlags.
   */
  virtual bool healthFlagGet(HealthFlag flag) const PURE;

  /**
   * Atomically set a health flag for a host. Flags are specified in HealthFlags.
   */
  virtual void healthFlagSet(HealthFlag flag) PURE;

  /**
   * Atomically get multiple health flags that are set for a host. Flags are specified
   * as a bitset of HealthFlags.
   */
  virtual uint32_t healthFlagsGetAll() const PURE;

  /**
   * Atomically set the health flag for a host. Flags are specified as a bitset
   * of HealthFlags.
   */
  virtual void healthFlagsSetAll(uint32_t bits) PURE;

  enum class Health {
    /**
     * Host is unhealthy and is not able to serve traffic. A host may be marked as unhealthy either
     * through EDS or through active health checking.
     */
    Unhealthy,
    /**
     * Host is healthy, but degraded. It is able to serve traffic, but hosts that aren't degraded
     * should be preferred. A host may be marked as degraded either through EDS or through active
     * health checking.
     */
    Degraded,
    /**
     * Host is healthy and is able to serve traffic.
     */
    Healthy,
  };

  /**
   * @return the coarse health status of the host.
   */
  virtual Health coarseHealth() const PURE;

  using HealthStatus = envoy::config::core::v3::HealthStatus;

  /**
   * @return more specific health status of host. This status is hybrid of EDS status and runtime
   * active status (from active health checker or outlier detection). Active status will be taken as
   * a priority.
   */
  virtual HealthStatus healthStatus() const PURE;

  /**
   * Set the EDS health status of the host. This is used when the host status is updated via EDS.
   */
  virtual void setEdsHealthStatus(HealthStatus health_status) PURE;

  /**
   * @return the EDS health status of the host.
   */
  virtual HealthStatus edsHealthStatus() const PURE;

  /**
   * Set the host's health checker monitor. Monitors are assumed to be thread safe, however
   * a new monitor must be installed before the host is used across threads. Thus,
   * this routine should only be called on the main thread before the host is used across threads.
   */
  virtual void setHealthChecker(HealthCheckHostMonitorPtr&& health_checker) PURE;

  /**
   * Set the host's outlier detector monitor. Outlier detector monitors are assumed to be thread
   * safe, however a new outlier detector monitor must be installed before the host is used across
   * threads. Thus, this routine should only be called on the main thread before the host is used
   * across threads.
   */
  virtual void setOutlierDetector(Outlier::DetectorHostMonitorPtr&& outlier_detector) PURE;

  /**
   * Set the timestamp of when the host has transitioned from unhealthy to healthy state via an
   * active health checking.
   */
  virtual void setLastHcPassTime(MonotonicTime last_hc_pass_time) PURE;

  /**
   * @return the current load balancing weight of the host, in the range 1-128 (see
   * envoy.api.v2.endpoint.Endpoint.load_balancing_weight).
   */
  virtual uint32_t weight() const PURE;

  /**
   * Set the current load balancing weight of the host, in the range 1-128 (see
   * envoy.api.v2.endpoint.Endpoint.load_balancing_weight).
   */
  virtual void weight(uint32_t new_weight) PURE;

  /**
   * @return the current boolean value of host being in use by any connection pool.
   */
  virtual bool used() const PURE;

  /**
   * Creates a handle for a host. Deletion of the handle signals that the
   * connection pools no longer need this host.
   */
  virtual HostHandlePtr acquireHandle() const PURE;

  /**
   * @return true if active health check is disabled.
   */
  virtual bool disableActiveHealthCheck() const PURE;

  /**
   * Set true to disable active health check for the host.
   */
  virtual void setDisableActiveHealthCheck(bool disable_active_health_check) PURE;
};

using HostConstSharedPtr = std::shared_ptr<const Host>;

using HostVector = std::vector<HostSharedPtr>;
using HealthyHostVector = Phantom<HostVector, Healthy>;
using DegradedHostVector = Phantom<HostVector, Degraded>;
using ExcludedHostVector = Phantom<HostVector, Excluded>;
using HostMap = absl::flat_hash_map<std::string, Upstream::HostSharedPtr>;
using HostMapSharedPtr = std::shared_ptr<HostMap>;
using HostMapConstSharedPtr = std::shared_ptr<const HostMap>;
using HostVectorSharedPtr = std::shared_ptr<HostVector>;
using HostVectorConstSharedPtr = std::shared_ptr<const HostVector>;

using HealthyHostVectorConstSharedPtr = std::shared_ptr<const HealthyHostVector>;
using DegradedHostVectorConstSharedPtr = std::shared_ptr<const DegradedHostVector>;
using ExcludedHostVectorConstSharedPtr = std::shared_ptr<const ExcludedHostVector>;

using HostListPtr = std::unique_ptr<HostVector>;
using LocalityWeightsMap =
    absl::node_hash_map<envoy::config::core::v3::Locality, uint32_t, LocalityHash, LocalityEqualTo>;
using PriorityState = std::vector<std::pair<HostListPtr, LocalityWeightsMap>>;

/**
 * Bucket hosts by locality.
 */
class HostsPerLocality {
public:
  virtual ~HostsPerLocality() = default;

  /**
   * @return bool is local locality one of the locality buckets? If so, the
   *         local locality will be the first in the get() vector.
   */
  virtual bool hasLocalLocality() const PURE;

  /**
   * @return const std::vector<HostVector>& list of hosts organized per
   *         locality. The local locality is the first entry if
   *         hasLocalLocality() is true. All hosts within the same entry have the same locality
   *         and all hosts with a given locality are in the same entry. With the exception of
   *         the local locality entry (if present), all entries are sorted by locality with
   *         those considered less by the LocalityLess comparator ordered earlier in the list.
   */
  virtual const std::vector<HostVector>& get() const PURE;

  /**
   * Clone object with multiple filter predicates. Returns a vector of clones, each with host that
   * match the provided predicates.
   * @param predicates vector of predicates on Host entries.
   * @return vector of HostsPerLocalityConstSharedPtr clones of the HostsPerLocality that match
   *         hosts according to predicates.
   */
  virtual std::vector<std::shared_ptr<const HostsPerLocality>>
  filter(const std::vector<std::function<bool(const Host&)>>& predicates) const PURE;

  /**
   * Clone object.
   * @return HostsPerLocalityConstSharedPtr clone of the HostsPerLocality.
   */
  std::shared_ptr<const HostsPerLocality> clone() const {
    return filter({[](const Host&) { return true; }})[0];
  }
};

using HostsPerLocalitySharedPtr = std::shared_ptr<HostsPerLocality>;
using HostsPerLocalityConstSharedPtr = std::shared_ptr<const HostsPerLocality>;

// Weight for each locality index in HostsPerLocality.
using LocalityWeights = std::vector<uint32_t>;
using LocalityWeightsSharedPtr = std::shared_ptr<LocalityWeights>;
using LocalityWeightsConstSharedPtr = std::shared_ptr<const LocalityWeights>;

/**
 * Base host set interface. This contains all of the endpoints for a given LocalityLbEndpoints
 * priority level.
 */
// TODO(snowp): Remove the const ref accessors in favor of the shared_ptr ones.
class HostSet {
public:
  virtual ~HostSet() = default;

  /**
   * @return all hosts that make up the set at the current time.
   */
  virtual const HostVector& hosts() const PURE;

  /**
   * @return a shared ptr to the vector returned by hosts().
   */
  virtual HostVectorConstSharedPtr hostsPtr() const PURE;

  /**
   * @return all healthy hosts contained in the set at the current time. NOTE: This set is
   *         eventually consistent. There is a time window where a host in this set may become
   *         unhealthy and calling healthy() on it will return false. Code should be written to
   *         deal with this case if it matters.
   */
  virtual const HostVector& healthyHosts() const PURE;

  /**
   * @return a shared ptr to the vector returned by healthyHosts().
   */
  virtual HealthyHostVectorConstSharedPtr healthyHostsPtr() const PURE;

  /**
   * @return all degraded hosts contained in the set at the current time. NOTE: This set is
   *         eventually consistent. There is a time window where a host in this set may become
   *         undegraded and calling degraded() on it will return false. Code should be written to
   *         deal with this case if it matters.
   */
  virtual const HostVector& degradedHosts() const PURE;

  /**
   * @return a shared ptr to the vector returned by degradedHosts().
   */
  virtual DegradedHostVectorConstSharedPtr degradedHostsPtr() const PURE;

  /*
   * @return all excluded hosts contained in the set at the current time. Excluded hosts should be
   * ignored when computing load balancing weights, but may overlap with hosts in hosts().
   */
  virtual const HostVector& excludedHosts() const PURE;

  /**
   * @return a shared ptr to the vector returned by excludedHosts().
   */
  virtual ExcludedHostVectorConstSharedPtr excludedHostsPtr() const PURE;

  /**
   * @return hosts per locality.
   */
  virtual const HostsPerLocality& hostsPerLocality() const PURE;

  /**
   * @return a shared ptr to the HostsPerLocality returned by hostsPerLocality().
   */
  virtual HostsPerLocalityConstSharedPtr hostsPerLocalityPtr() const PURE;

  /**
   * @return same as hostsPerLocality but only contains healthy hosts.
   */
  virtual const HostsPerLocality& healthyHostsPerLocality() const PURE;

  /**
   * @return a shared ptr to the HostsPerLocality returned by healthyHostsPerLocality().
   */
  virtual HostsPerLocalityConstSharedPtr healthyHostsPerLocalityPtr() const PURE;

  /**
   * @return same as hostsPerLocality but only contains degraded hosts.
   */
  virtual const HostsPerLocality& degradedHostsPerLocality() const PURE;

  /**
   * @return a shared ptr to the HostsPerLocality returned by degradedHostsPerLocality().
   */
  virtual HostsPerLocalityConstSharedPtr degradedHostsPerLocalityPtr() const PURE;

  /**
   * @return same as hostsPerLocality but only contains excluded hosts.
   */
  virtual const HostsPerLocality& excludedHostsPerLocality() const PURE;

  /**
   * @return a shared ptr to the HostsPerLocality returned by excludedHostsPerLocality().
   */
  virtual HostsPerLocalityConstSharedPtr excludedHostsPerLocalityPtr() const PURE;

  /**
   * @return weights for each locality in the host set.
   */
  virtual LocalityWeightsConstSharedPtr localityWeights() const PURE;

  /**
   * @return next locality index to route to if performing locality weighted balancing
   * against healthy hosts.
   */
  virtual absl::optional<uint32_t> chooseHealthyLocality() PURE;

  /**
   * @return next locality index to route to if performing locality weighted balancing
   * against degraded hosts.
   */
  virtual absl::optional<uint32_t> chooseDegradedLocality() PURE;

  /**
   * @return uint32_t the priority of this host set.
   */
  virtual uint32_t priority() const PURE;

  /**
   * @return uint32_t the overprovisioning factor of this host set.
   */
  virtual uint32_t overprovisioningFactor() const PURE;

  /**
   * @return true to use host weights to calculate the health of a priority.
   */
  virtual bool weightedPriorityHealth() const PURE;
};

using HostSetPtr = std::unique_ptr<HostSet>;

/**
 * This class contains all of the HostSets for a given cluster grouped by priority, for
 * ease of load balancing.
 */
class PrioritySet {
public:
  using MemberUpdateCb =
      std::function<void(const HostVector& hosts_added, const HostVector& hosts_removed)>;

  using PriorityUpdateCb = std::function<void(uint32_t priority, const HostVector& hosts_added,
                                              const HostVector& hosts_removed)>;

  virtual ~PrioritySet() = default;

  /**
   * Install a callback that will be invoked when any of the HostSets in the PrioritySet changes.
   * hosts_added and hosts_removed will only be populated when a host is added or completely removed
   * from the PrioritySet.
   * This includes when a new HostSet is created.
   *
   * @param callback supplies the callback to invoke.
   * @return Common::CallbackHandlePtr a handle which can be used to unregister the callback.
   */
  ABSL_MUST_USE_RESULT virtual Common::CallbackHandlePtr
  addMemberUpdateCb(MemberUpdateCb callback) const PURE;

  /**
   * Install a callback that will be invoked when a host set changes. Triggers when any change
   * happens to the hosts within the host set. If hosts are added/removed from the host set, the
   * added/removed hosts will be passed to the callback.
   *
   * @param callback supplies the callback to invoke.
   * @return Common::CallbackHandlePtr a handle which can be used to unregister the callback.
   */
  ABSL_MUST_USE_RESULT virtual Common::CallbackHandlePtr
  addPriorityUpdateCb(PriorityUpdateCb callback) const PURE;

  /**
   * @return const std::vector<HostSetPtr>& the host sets, ordered by priority.
   */
  virtual const std::vector<HostSetPtr>& hostSetsPerPriority() const PURE;

  /**
   * @return HostMapConstSharedPtr read only cross priority host map that indexed by host address
   * string.
   */
  virtual HostMapConstSharedPtr crossPriorityHostMap() const PURE;

  /**
   * Parameter class for updateHosts.
   */
  struct UpdateHostsParams {
    HostVectorConstSharedPtr hosts;
    HealthyHostVectorConstSharedPtr healthy_hosts;
    DegradedHostVectorConstSharedPtr degraded_hosts;
    ExcludedHostVectorConstSharedPtr excluded_hosts;
    HostsPerLocalityConstSharedPtr hosts_per_locality;
    HostsPerLocalityConstSharedPtr healthy_hosts_per_locality;
    HostsPerLocalityConstSharedPtr degraded_hosts_per_locality;
    HostsPerLocalityConstSharedPtr excluded_hosts_per_locality;
  };

  /**
   * Updates the hosts in a given host set.
   *
   * @param priority the priority of the host set to update.
   * @param update_hosts_param supplies the list of hosts and hosts per locality.
   * @param locality_weights supplies a map from locality to associated weight.
   * @param hosts_added supplies the hosts added since the last update.
   * @param hosts_removed supplies the hosts removed since the last update.
   * @param weighted_priority_health if present, overwrites the current weighted_priority_health.
   * @param overprovisioning_factor if present, overwrites the current overprovisioning_factor.
   * @param cross_priority_host_map read only cross-priority host map which is created in the main
   * thread and shared by all the worker threads.
   */
  virtual void updateHosts(uint32_t priority, UpdateHostsParams&& update_hosts_params,
                           LocalityWeightsConstSharedPtr locality_weights,
                           const HostVector& hosts_added, const HostVector& hosts_removed,
                           absl::optional<bool> weighted_priority_health,
                           absl::optional<uint32_t> overprovisioning_factor,
                           HostMapConstSharedPtr cross_priority_host_map = nullptr) PURE;

  /**
   * Callback provided during batch updates that can be used to update hosts.
   */
  class HostUpdateCb {
  public:
    virtual ~HostUpdateCb() = default;
    /**
     * Updates the hosts in a given host set.
     *
     * @param priority the priority of the host set to update.
     * @param update_hosts_param supplies the list of hosts and hosts per locality.
     * @param locality_weights supplies a map from locality to associated weight.
     * @param hosts_added supplies the hosts added since the last update.
     * @param hosts_removed supplies the hosts removed since the last update.
     * @param weighted_priority_health if present, overwrites the current weighted_priority_health.
     * @param overprovisioning_factor if present, overwrites the current overprovisioning_factor.
     */
    virtual void updateHosts(uint32_t priority, UpdateHostsParams&& update_hosts_params,
                             LocalityWeightsConstSharedPtr locality_weights,
                             const HostVector& hosts_added, const HostVector& hosts_removed,
                             absl::optional<bool> weighted_priority_health,
                             absl::optional<uint32_t> overprovisioning_factor) PURE;
  };

  /**
   * Callback that provides the mechanism for performing batch host updates for a PrioritySet.
   */
  class BatchUpdateCb {
  public:
    virtual ~BatchUpdateCb() = default;

    /**
     * Performs a batch host update. Implementors should use the provided callback to update hosts
     * in the PrioritySet.
     */
    virtual void batchUpdate(HostUpdateCb& host_update_cb) PURE;
  };

  /**
   * Allows updating hosts for multiple priorities at once, deferring the MemberUpdateCb from
   * triggering until all priorities have been updated. The resulting callback will take into
   * account hosts moved from one priority to another.
   *
   * @param callback callback to use to add hosts.
   */
  virtual void batchHostUpdate(BatchUpdateCb& callback) PURE;
};

/**
 * All cluster config update related stats.
 * See https://github.com/envoyproxy/envoy/issues/23575 for details. Stats from ClusterInfo::stats()
 * will be split into subgroups "config-update", "lb", "endpoint" and "the rest"(which are mainly
 * upstream related), roughly based on their semantics.
 */
#define ALL_CLUSTER_CONFIG_UPDATE_STATS(COUNTER, GAUGE, HISTOGRAM, TEXT_READOUT, STATNAME)         \
  COUNTER(assignment_stale)                                                                        \
  COUNTER(assignment_timeout_received)                                                             \
  COUNTER(assignment_use_cached)                                                                   \
  COUNTER(update_attempt)                                                                          \
  COUNTER(update_empty)                                                                            \
  COUNTER(update_failure)                                                                          \
  COUNTER(update_no_rebuild)                                                                       \
  COUNTER(update_success)                                                                          \
  GAUGE(version, NeverImport)                                                                      \
  GAUGE(warming_state, NeverImport)

/**
 * All cluster endpoints related stats.
 */
#define ALL_CLUSTER_ENDPOINT_STATS(COUNTER, GAUGE, HISTOGRAM, TEXT_READOUT, STATNAME)              \
  GAUGE(max_host_weight, NeverImport)                                                              \
  COUNTER(membership_change)                                                                       \
  GAUGE(membership_degraded, NeverImport)                                                          \
  GAUGE(membership_excluded, NeverImport)                                                          \
  GAUGE(membership_healthy, NeverImport)                                                           \
  GAUGE(membership_total, NeverImport)

/**
 * All cluster load balancing related stats.
 */
#define ALL_CLUSTER_LB_STATS(COUNTER, GAUGE, HISTOGRAM, TEXT_READOUT, STATNAME)                    \
  COUNTER(lb_healthy_panic)                                                                        \
  COUNTER(lb_local_cluster_not_ok)                                                                 \
  COUNTER(lb_recalculate_zone_structures)                                                          \
  COUNTER(lb_subsets_created)                                                                      \
  COUNTER(lb_subsets_fallback)                                                                     \
  COUNTER(lb_subsets_fallback_panic)                                                               \
  COUNTER(lb_subsets_removed)                                                                      \
  COUNTER(lb_subsets_selected)                                                                     \
  COUNTER(lb_zone_cluster_too_small)                                                               \
  COUNTER(lb_zone_no_capacity_left)                                                                \
  COUNTER(lb_zone_number_differs)                                                                  \
  COUNTER(lb_zone_routing_all_directly)                                                            \
  COUNTER(lb_zone_routing_cross_zone)                                                              \
  COUNTER(lb_zone_routing_sampled)                                                                 \
  GAUGE(lb_subsets_active, Accumulate)

/**
 * All cluster stats. @see stats_macros.h
 */
#define ALL_CLUSTER_TRAFFIC_STATS(COUNTER, GAUGE, HISTOGRAM, TEXT_READOUT, STATNAME)               \
  COUNTER(bind_errors)                                                                             \
  COUNTER(original_dst_host_invalid)                                                               \
  COUNTER(retry_or_shadow_abandoned)                                                               \
  COUNTER(upstream_cx_close_notify)                                                                \
  COUNTER(upstream_cx_connect_attempts_exceeded)                                                   \
  COUNTER(upstream_cx_connect_fail)                                                                \
  COUNTER(upstream_cx_connect_timeout)                                                             \
  COUNTER(upstream_cx_connect_with_0_rtt)                                                          \
  COUNTER(upstream_cx_destroy)                                                                     \
  COUNTER(upstream_cx_destroy_local)                                                               \
  COUNTER(upstream_cx_destroy_local_with_active_rq)                                                \
  COUNTER(upstream_cx_destroy_remote)                                                              \
  COUNTER(upstream_cx_destroy_remote_with_active_rq)                                               \
  COUNTER(upstream_cx_destroy_with_active_rq)                                                      \
  COUNTER(upstream_cx_http1_total)                                                                 \
  COUNTER(upstream_cx_http2_total)                                                                 \
  COUNTER(upstream_cx_http3_total)                                                                 \
  COUNTER(upstream_cx_idle_timeout)                                                                \
  COUNTER(upstream_cx_max_duration_reached)                                                        \
  COUNTER(upstream_cx_max_requests)                                                                \
  COUNTER(upstream_cx_none_healthy)                                                                \
  COUNTER(upstream_cx_overflow)                                                                    \
  COUNTER(upstream_cx_pool_overflow)                                                               \
  COUNTER(upstream_cx_protocol_error)                                                              \
  COUNTER(upstream_cx_rx_bytes_total)                                                              \
  COUNTER(upstream_cx_total)                                                                       \
  COUNTER(upstream_cx_tx_bytes_total)                                                              \
  COUNTER(upstream_flow_control_backed_up_total)                                                   \
  COUNTER(upstream_flow_control_drained_total)                                                     \
  COUNTER(upstream_flow_control_paused_reading_total)                                              \
  COUNTER(upstream_flow_control_resumed_reading_total)                                             \
  COUNTER(upstream_internal_redirect_failed_total)                                                 \
  COUNTER(upstream_internal_redirect_succeeded_total)                                              \
  COUNTER(upstream_rq_cancelled)                                                                   \
  COUNTER(upstream_rq_completed)                                                                   \
  COUNTER(upstream_rq_maintenance_mode)                                                            \
  COUNTER(upstream_rq_max_duration_reached)                                                        \
  COUNTER(upstream_rq_pending_failure_eject)                                                       \
  COUNTER(upstream_rq_pending_overflow)                                                            \
  COUNTER(upstream_rq_pending_total)                                                               \
  COUNTER(upstream_rq_0rtt)                                                                        \
  COUNTER(upstream_rq_per_try_timeout)                                                             \
  COUNTER(upstream_rq_per_try_idle_timeout)                                                        \
  COUNTER(upstream_rq_retry)                                                                       \
  COUNTER(upstream_rq_retry_backoff_exponential)                                                   \
  COUNTER(upstream_rq_retry_backoff_ratelimited)                                                   \
  COUNTER(upstream_rq_retry_limit_exceeded)                                                        \
  COUNTER(upstream_rq_retry_overflow)                                                              \
  COUNTER(upstream_rq_retry_success)                                                               \
  COUNTER(upstream_rq_rx_reset)                                                                    \
  COUNTER(upstream_rq_timeout)                                                                     \
  COUNTER(upstream_rq_total)                                                                       \
  COUNTER(upstream_rq_tx_reset)                                                                    \
  COUNTER(upstream_http3_broken)                                                                   \
  GAUGE(upstream_cx_active, Accumulate)                                                            \
  GAUGE(upstream_cx_rx_bytes_buffered, Accumulate)                                                 \
  GAUGE(upstream_cx_tx_bytes_buffered, Accumulate)                                                 \
  GAUGE(upstream_rq_active, Accumulate)                                                            \
  GAUGE(upstream_rq_pending_active, Accumulate)                                                    \
  HISTOGRAM(upstream_cx_connect_ms, Milliseconds)                                                  \
  HISTOGRAM(upstream_cx_length_ms, Milliseconds)

/**
 * All cluster load report stats. These are only use for EDS load reporting and not sent to the
 * stats sink. See envoy.config.endpoint.v3.ClusterStats for the definition of
 * total_dropped_requests and dropped_requests, which correspond to the upstream_rq_dropped and
 * upstream_rq_drop_overload counter here. These are latched by LoadStatsReporter, independent of
 * the normal stats sink flushing.
 */
#define ALL_CLUSTER_LOAD_REPORT_STATS(COUNTER, GAUGE, HISTOGRAM, TEXT_READOUT, STATNAME)           \
  COUNTER(upstream_rq_dropped)                                                                     \
  COUNTER(upstream_rq_drop_overload)

/**
 * Cluster circuit breakers gauges. Note that we do not generate a stats
 * structure from this macro. This is because depending on flags, we want to use
 * null gauges for all the "remaining" ones. This is hard to automate with the
 * 2-phase macros, so ClusterInfoImpl::generateCircuitBreakersStats is
 * hand-coded and must be changed if we alter the set of gauges in this macro.
 * We also include stat-names in this structure that are used when composing
 * the circuit breaker names, depending on priority settings.
 */
#define ALL_CLUSTER_CIRCUIT_BREAKERS_STATS(COUNTER, GAUGE, HISTOGRAM, TEXT_READOUT, STATNAME)      \
  GAUGE(cx_open, Accumulate)                                                                       \
  GAUGE(cx_pool_open, Accumulate)                                                                  \
  GAUGE(rq_open, Accumulate)                                                                       \
  GAUGE(rq_pending_open, Accumulate)                                                               \
  GAUGE(rq_retry_open, Accumulate)                                                                 \
  GAUGE(remaining_cx, Accumulate)                                                                  \
  GAUGE(remaining_cx_pools, Accumulate)                                                            \
  GAUGE(remaining_pending, Accumulate)                                                             \
  GAUGE(remaining_retries, Accumulate)                                                             \
  GAUGE(remaining_rq, Accumulate)                                                                  \
  STATNAME(circuit_breakers)                                                                       \
  STATNAME(default)                                                                                \
  STATNAME(high)

/**
 * All stats tracking request/response headers and body sizes. Not used by default.
 */
#define ALL_CLUSTER_REQUEST_RESPONSE_SIZE_STATS(COUNTER, GAUGE, HISTOGRAM, TEXT_READOUT, STATNAME) \
  HISTOGRAM(upstream_rq_headers_size, Bytes)                                                       \
  HISTOGRAM(upstream_rq_body_size, Bytes)                                                          \
  HISTOGRAM(upstream_rs_headers_size, Bytes)                                                       \
  HISTOGRAM(upstream_rs_body_size, Bytes)

/**
 * All stats around timeout budgets. Not used by default.
 */
#define ALL_CLUSTER_TIMEOUT_BUDGET_STATS(COUNTER, GAUGE, HISTOGRAM, TEXT_READOUT, STATNAME)        \
  HISTOGRAM(upstream_rq_timeout_budget_percent_used, Unspecified)                                  \
  HISTOGRAM(upstream_rq_timeout_budget_per_try_percent_used, Unspecified)

/**
 * Struct definition for cluster config update stats. @see stats_macros.h
 */
MAKE_STAT_NAMES_STRUCT(ClusterConfigUpdateStatNames, ALL_CLUSTER_CONFIG_UPDATE_STATS);
MAKE_STATS_STRUCT(ClusterConfigUpdateStats, ClusterConfigUpdateStatNames,
                  ALL_CLUSTER_CONFIG_UPDATE_STATS);

/**
 * Struct definition for cluster endpoint related stats. @see stats_macros.h
 */
MAKE_STAT_NAMES_STRUCT(ClusterEndpointStatNames, ALL_CLUSTER_ENDPOINT_STATS);
MAKE_STATS_STRUCT(ClusterEndpointStats, ClusterEndpointStatNames, ALL_CLUSTER_ENDPOINT_STATS);

/**
 * Struct definition for cluster load balancing stats. @see stats_macros.h
 */
MAKE_STAT_NAMES_STRUCT(ClusterLbStatNames, ALL_CLUSTER_LB_STATS);
MAKE_STATS_STRUCT(ClusterLbStats, ClusterLbStatNames, ALL_CLUSTER_LB_STATS);

/**
 * Struct definition for all cluster traffic stats. @see stats_macros.h
 */
MAKE_STAT_NAMES_STRUCT(ClusterTrafficStatNames, ALL_CLUSTER_TRAFFIC_STATS);
MAKE_STATS_STRUCT(ClusterTrafficStats, ClusterTrafficStatNames, ALL_CLUSTER_TRAFFIC_STATS);
using DeferredCreationCompatibleClusterTrafficStats =
    Stats::DeferredCreationCompatibleStats<ClusterTrafficStats>;

MAKE_STAT_NAMES_STRUCT(ClusterLoadReportStatNames, ALL_CLUSTER_LOAD_REPORT_STATS);
MAKE_STATS_STRUCT(ClusterLoadReportStats, ClusterLoadReportStatNames,
                  ALL_CLUSTER_LOAD_REPORT_STATS);

// We can't use macros to make the Stats class for circuit breakers due to
// the conditional inclusion of 'remaining' gauges. But we do auto-generate
// the StatNames struct.
MAKE_STAT_NAMES_STRUCT(ClusterCircuitBreakersStatNames, ALL_CLUSTER_CIRCUIT_BREAKERS_STATS);

MAKE_STAT_NAMES_STRUCT(ClusterRequestResponseSizeStatNames,
                       ALL_CLUSTER_REQUEST_RESPONSE_SIZE_STATS);
MAKE_STATS_STRUCT(ClusterRequestResponseSizeStats, ClusterRequestResponseSizeStatNames,
                  ALL_CLUSTER_REQUEST_RESPONSE_SIZE_STATS);

MAKE_STAT_NAMES_STRUCT(ClusterTimeoutBudgetStatNames, ALL_CLUSTER_TIMEOUT_BUDGET_STATS);
MAKE_STATS_STRUCT(ClusterTimeoutBudgetStats, ClusterTimeoutBudgetStatNames,
                  ALL_CLUSTER_TIMEOUT_BUDGET_STATS);

/**
 * Struct definition for cluster circuit breakers stats. @see stats_macros.h
 */
struct ClusterCircuitBreakersStats {
  ALL_CLUSTER_CIRCUIT_BREAKERS_STATS(c, GENERATE_GAUGE_STRUCT, h, tr, GENERATE_STATNAME_STRUCT)
};

using ClusterRequestResponseSizeStatsPtr = std::unique_ptr<ClusterRequestResponseSizeStats>;
using ClusterRequestResponseSizeStatsOptRef =
    absl::optional<std::reference_wrapper<ClusterRequestResponseSizeStats>>;

using ClusterTimeoutBudgetStatsPtr = std::unique_ptr<ClusterTimeoutBudgetStats>;
using ClusterTimeoutBudgetStatsOptRef =
    absl::optional<std::reference_wrapper<ClusterTimeoutBudgetStats>>;

/**
 * All extension protocol specific options returned by the method at
 *   NamedNetworkFilterConfigFactory::createProtocolOptions
 * must be derived from this class.
 */
class ProtocolOptionsConfig {
public:
  virtual ~ProtocolOptionsConfig() = default;
};
using ProtocolOptionsConfigConstSharedPtr = std::shared_ptr<const ProtocolOptionsConfig>;

/**
 *  Base class for all cluster typed metadata factory.
 */
class ClusterTypedMetadataFactory : public Envoy::Config::TypedMetadataFactory {};

class LoadBalancerConfig;
class TypedLoadBalancerFactory;

/**
 * This is a function used by upstream binding config to select the source address based on the
 * target address. Given the target address through the parameter expect the source address
 * returned.
 */
using AddressSelectFn = std::function<const Network::Address::InstanceConstSharedPtr(
    const Network::Address::InstanceConstSharedPtr&)>;

/**
 * Information about a given upstream cluster.
 * This includes the information and interfaces for building an upstream filter chain.
 */
class ClusterInfo : public Http::FilterChainFactory {
public:
  struct Features {
    // Whether the upstream supports HTTP2. This is used when creating connection pools.
    static constexpr uint64_t HTTP2 = 0x1;
    // Use the downstream protocol (HTTP1.1, HTTP2) for upstream connections as well, if available.
    // This is used when creating connection pools.
    static constexpr uint64_t USE_DOWNSTREAM_PROTOCOL = 0x2;
    // Whether connections should be immediately closed upon health failure.
    static constexpr uint64_t CLOSE_CONNECTIONS_ON_HOST_HEALTH_FAILURE = 0x4;
    // If USE_ALPN and HTTP2 are true, the upstream protocol will be negotiated using ALPN.
    // If ALPN is attempted but not supported by the upstream HTTP/1.1 is used.
    static constexpr uint64_t USE_ALPN = 0x8;
    // Whether the upstream supports HTTP3. This is used when creating connection pools.
    static constexpr uint64_t HTTP3 = 0x10;
  };

  ~ClusterInfo() override = default;

  /**
   * @return bool whether the cluster was added via API (if false the cluster was present in the
   *         initial configuration and cannot be removed or updated).
   */
  virtual bool addedViaApi() const PURE;

  /**
   * @return the connect timeout for upstream hosts that belong to this cluster.
   */
  virtual std::chrono::milliseconds connectTimeout() const PURE;

  /**
   * @return the idle timeout for upstream HTTP connection pool connections.
   */
  virtual const absl::optional<std::chrono::milliseconds> idleTimeout() const PURE;

  /**
   * @return the idle timeout for each connection in TCP connection pool.
   */
  virtual const absl::optional<std::chrono::milliseconds> tcpPoolIdleTimeout() const PURE;

  /**
   * @return optional maximum connection duration timeout for manager connections.
   */
  virtual const absl::optional<std::chrono::milliseconds> maxConnectionDuration() const PURE;

  /**
   * @return how many streams should be anticipated per each current stream.
   */
  virtual float perUpstreamPreconnectRatio() const PURE;

  /**
   * @return how many streams should be anticipated per each current stream.
   */
  virtual float peekaheadRatio() const PURE;

  /**
   * @return soft limit on size of the cluster's connections read and write buffers.
   */
  virtual uint32_t perConnectionBufferLimitBytes() const PURE;

  /**
   * @return uint64_t features supported by the cluster. @see Features.
   */
  virtual uint64_t features() const PURE;

  /**
   * @return const Http::Http1Settings& for HTTP/1.1 connections created on behalf of this cluster.
   *         @see Http::Http1Settings.
   */
  virtual const Http::Http1Settings& http1Settings() const PURE;

  /**
   * @return const envoy::config::core::v3::Http2ProtocolOptions& for HTTP/2 connections
   * created on behalf of this cluster.
   *         @see envoy::config::core::v3::Http2ProtocolOptions.
   */
  virtual const envoy::config::core::v3::Http2ProtocolOptions& http2Options() const PURE;

  /**
   * @return const envoy::config::core::v3::Http3ProtocolOptions& for HTTP/3 connections
   * created on behalf of this cluster. @see envoy::config::core::v3::Http3ProtocolOptions.
   */
  virtual const envoy::config::core::v3::Http3ProtocolOptions& http3Options() const PURE;

  /**
   * @return const envoy::config::core::v3::HttpProtocolOptions for all of HTTP versions.
   */
  virtual const envoy::config::core::v3::HttpProtocolOptions&
  commonHttpProtocolOptions() const PURE;

  /**
   * @param name std::string containing the well-known name of the extension for which protocol
   *        options are desired
   * @return std::shared_ptr<const Derived> where Derived is a subclass of ProtocolOptionsConfig
   *         and contains extension-specific protocol options for upstream connections.
   */
  template <class Derived>
  std::shared_ptr<const Derived> extensionProtocolOptionsTyped(const std::string& name) const {
    return std::dynamic_pointer_cast<const Derived>(extensionProtocolOptions(name));
  }

  /**
   * @return OptRef<const LoadBalancerConfig> the validated load balancing policy configuration to
   * use for this cluster.
   */
  virtual OptRef<const LoadBalancerConfig> loadBalancerConfig() const PURE;

  /**
   * @return the load balancer factory for this cluster if the load balancing type is
   * LOAD_BALANCING_POLICY_CONFIG.
   * TODO(wbpcode): change the return type to return a reference after
   * 'envoy_reloadable_features_convert_legacy_lb_config' is removed. The factory should never be
   * nullptr when the load balancing type is LOAD_BALANCING_POLICY_CONFIG.
   */
  virtual TypedLoadBalancerFactory* loadBalancerFactory() const PURE;

  /**
   * @return const envoy::config::cluster::v3::Cluster::CommonLbConfig& the common configuration for
   * all load balancers for this cluster.
   */
  virtual const envoy::config::cluster::v3::Cluster::CommonLbConfig& lbConfig() const PURE;

  /**
   * @return the type of load balancing that the cluster should use.
   */
  virtual LoadBalancerType lbType() const PURE;

  /**
   * @return the service discovery type to use for resolving the cluster.
   */
  virtual envoy::config::cluster::v3::Cluster::DiscoveryType type() const PURE;

  /**
   * @return the type of cluster, only used for custom discovery types.
   */
  virtual OptRef<const envoy::config::cluster::v3::Cluster::CustomClusterType>
  clusterType() const PURE;

  /**
   * @return configuration for round robin load balancing, only used if LB type is round robin.
   */
  virtual OptRef<const envoy::config::cluster::v3::Cluster::RoundRobinLbConfig>
  lbRoundRobinConfig() const PURE;

  /**
   * @return configuration for least request load balancing, only used if LB type is least request.
   */
  virtual OptRef<const envoy::config::cluster::v3::Cluster::LeastRequestLbConfig>
  lbLeastRequestConfig() const PURE;

  /**
   * @return configuration for ring hash load balancing, only used if type is set to ring_hash_lb.
   */
  virtual OptRef<const envoy::config::cluster::v3::Cluster::RingHashLbConfig>
  lbRingHashConfig() const PURE;

  /**
   * @return configuration for maglev load balancing, only used if type is set to maglev_lb.
   */
  virtual OptRef<const envoy::config::cluster::v3::Cluster::MaglevLbConfig>
  lbMaglevConfig() const PURE;

  /**
   * @return const absl::optional<envoy::config::cluster::v3::Cluster::OriginalDstLbConfig>& the
   * configuration for the Original Destination load balancing policy, only used if type is set to
   *         ORIGINAL_DST_LB.
   */
  virtual OptRef<const envoy::config::cluster::v3::Cluster::OriginalDstLbConfig>
  lbOriginalDstConfig() const PURE;

  /**
   * @return const absl::optional<envoy::config::core::v3::TypedExtensionConfig>& the configuration
   *         for the upstream, if a custom upstream is configured.
   */
  virtual OptRef<const envoy::config::core::v3::TypedExtensionConfig> upstreamConfig() const PURE;

  /**
   * @return Whether the cluster is currently in maintenance mode and should not be routed to.
   *         Different filters may handle this situation in different ways. The implementation
   *         of this routine is typically based on randomness and may not return the same answer
   *         on each call.
   */
  virtual bool maintenanceMode() const PURE;

  /**
   * @return uint64_t the maximum number of outbound requests that a connection pool will make on
   *         each upstream connection. This can be used to increase spread if the backends cannot
   *         tolerate imbalance. 0 indicates no maximum.
   */
  virtual uint64_t maxRequestsPerConnection() const PURE;

  /**
   * @return uint32_t the maximum number of response headers. The default value is 100. Results in a
   * reset if the number of headers exceeds this value.
   */
  virtual uint32_t maxResponseHeadersCount() const PURE;

  /**
   * @return the human readable name of the cluster.
   */
  virtual const std::string& name() const PURE;

  /**
   * @return the observability name associated to the cluster. Used in stats, tracing, logging, and
   * config dumps. The observability name is configured with :ref:`alt_stat_name
   * <envoy_api_field_config.cluster.v3.Cluster.alt_stat_name>`. If unprovided, the default value is
   * the cluster name.
   */
  virtual const std::string& observabilityName() const PURE;

  /**
   * @return ResourceManager& the resource manager to use by proxy agents for this cluster (at
   *         a particular priority).
   */
  virtual ResourceManager& resourceManager(ResourcePriority priority) const PURE;

  /**
   * @return TransportSocketMatcher& the transport socket matcher associated
   * factory.
   */
  virtual TransportSocketMatcher& transportSocketMatcher() const PURE;

  /**
   * @return ClusterConfigUpdateStats& config update stats for this cluster.
   */
  virtual ClusterConfigUpdateStats& configUpdateStats() const PURE;

  /**
   * @return ClusterLbStats& load-balancer-related stats for this cluster.
   */
  virtual ClusterLbStats& lbStats() const PURE;

  /**
   * @return ClusterEndpointStats& endpoint related stats for this cluster.
   */
  virtual ClusterEndpointStats& endpointStats() const PURE;

  /**
   * @return  all traffic related stats for this cluster.
   */
  virtual DeferredCreationCompatibleClusterTrafficStats& trafficStats() const PURE;
  /**
   * @return the stats scope that contains all cluster stats. This can be used to produce dynamic
   *         stats that will be freed when the cluster is removed.
   */
  virtual Stats::Scope& statsScope() const PURE;

  /**
   * @return ClusterLoadReportStats& load report stats for this cluster.
   */
  virtual ClusterLoadReportStats& loadReportStats() const PURE;

  /**
   * @return absl::optional<std::reference_wrapper<ClusterRequestResponseSizeStats>> stats to track
   * headers/body sizes of request/response for this cluster.
   */
  virtual ClusterRequestResponseSizeStatsOptRef requestResponseSizeStats() const PURE;

  /**
   * @return absl::optional<std::reference_wrapper<ClusterTimeoutBudgetStats>> stats on timeout
   * budgets for this cluster.
   */
  virtual ClusterTimeoutBudgetStatsOptRef timeoutBudgetStats() const PURE;

  /**
   * @return true if this cluster should produce per-endpoint stats.
   */
  virtual bool perEndpointStatsEnabled() const PURE;

  /**
   * @return std::shared_ptr<UpstreamLocalAddressSelector> as upstream local address selector.
   */
  virtual UpstreamLocalAddressSelectorConstSharedPtr getUpstreamLocalAddressSelector() const PURE;

  /**
   * @return the configuration for load balancer subsets.
   */
  virtual const LoadBalancerSubsetInfo& lbSubsetInfo() const PURE;

  /**
   * @return const envoy::config::core::v3::Metadata& the configuration metadata for this cluster.
   */
  virtual const envoy::config::core::v3::Metadata& metadata() const PURE;

  /**
   * @return const Envoy::Config::TypedMetadata&& the typed metadata for this cluster.
   */
  virtual const Envoy::Config::TypedMetadata& typedMetadata() const PURE;

  /**
   * @return whether to skip waiting for health checking before draining connections
   *         after a host is removed from service discovery.
   */
  virtual bool drainConnectionsOnHostRemoval() const PURE;

  /**
   *  @return whether to create a new connection pool for each downstream connection routed to
   *          the cluster
   */
  virtual bool connectionPoolPerDownstreamConnection() const PURE;

  /**
   * @return true if this cluster is configured to ignore hosts for the purpose of load balancing
   * computations until they have been health checked for the first time.
   */
  virtual bool warmHosts() const PURE;

  /**
   * @return true if this cluster is configured to set local interface name on upstream connections.
   */
  virtual bool setLocalInterfaceNameOnUpstreamConnections() const PURE;

  /**
   * @return const std::string& eds cluster service_name of the cluster. Empty if not an EDS
   * cluster or eds cluster service_name is not set.
   */
  virtual const std::string& edsServiceName() const PURE;

  /**
   * Create network filters on a new upstream connection.
   */
  virtual void createNetworkFilterChain(Network::Connection& connection) const PURE;

  /**
   * Calculate upstream protocol(s) based on features.
   */
  virtual std::vector<Http::Protocol>
  upstreamHttpProtocol(absl::optional<Http::Protocol> downstream_protocol) const PURE;

  /**
   * @return http protocol options for upstream connection
   */
  virtual const absl::optional<envoy::config::core::v3::UpstreamHttpProtocolOptions>&
  upstreamHttpProtocolOptions() const PURE;

  /**
   * @return alternate protocols cache options for upstream connections.
   */
  virtual const absl::optional<const envoy::config::core::v3::AlternateProtocolsCacheOptions>&
  alternateProtocolsCacheOptions() const PURE;

  /**
   * @return the Http1 Codec Stats.
   */
  virtual Http::Http1::CodecStats& http1CodecStats() const PURE;

  /**
   * @return the Http2 Codec Stats.
   */
  virtual Http::Http2::CodecStats& http2CodecStats() const PURE;

  /**
   * @return the Http3 Codec Stats.
   */
  virtual Http::Http3::CodecStats& http3CodecStats() const PURE;

  /**
   * @return create header validator based on cluster configuration. Returns nullptr if
   * ENVOY_ENABLE_UHV is undefined.
   */
  virtual Http::ClientHeaderValidatorPtr makeHeaderValidator(Http::Protocol protocol) const PURE;

protected:
  /**
   * Invoked by extensionProtocolOptionsTyped.
   * @param name std::string containing the well-known name of the extension for which protocol
   *        options are desired
   * @return ProtocolOptionsConfigConstSharedPtr with extension-specific protocol options for
   *         upstream connections.
   */
  virtual ProtocolOptionsConfigConstSharedPtr
  extensionProtocolOptions(const std::string& name) const PURE;
};

using ClusterInfoConstSharedPtr = std::shared_ptr<const ClusterInfo>;

class HealthChecker;

/**
 * An upstream cluster (group of hosts). This class is the "primary" singleton cluster used amongst
 * all forwarding threads/workers. Individual HostSets are used on the workers themselves.
 */
class Cluster {
public:
  virtual ~Cluster() = default;

  enum class InitializePhase { Primary, Secondary };

  /**
   * @return a pointer to the cluster's health checker. If a health checker has not been installed,
   *         returns nullptr.
   */
  virtual HealthChecker* healthChecker() PURE;

  /**
   * @return the information about this upstream cluster.
   */
  virtual ClusterInfoConstSharedPtr info() const PURE;

  /**
   * @return a pointer to the cluster's outlier detector. If an outlier detector has not been
   *         installed, returns nullptr.
   */
  virtual Outlier::Detector* outlierDetector() PURE;
  virtual const Outlier::Detector* outlierDetector() const PURE;

  /**
   * Initialize the cluster. This will be called either immediately at creation or after all primary
   * clusters have been initialized (determined via initializePhase()).
   * @param callback supplies a callback that will be invoked after the cluster has undergone first
   *        time initialization. E.g., for a dynamic DNS cluster the initialize callback will be
   *        called when initial DNS resolution is complete.
   */
  virtual void initialize(std::function<void()> callback) PURE;

  /**
   * @return the phase in which the cluster is initialized at boot. This mechanism is used such that
   *         clusters that depend on other clusters can correctly initialize. (E.g., an EDS cluster
   *         that depends on resolution of the EDS server itself).
   */
  virtual InitializePhase initializePhase() const PURE;

  /**
   * @return the PrioritySet for the cluster.
   */
  virtual PrioritySet& prioritySet() PURE;

  /**
   * @return the const PrioritySet for the cluster.
   */
  virtual const PrioritySet& prioritySet() const PURE;

  /**
   * @return the cluster drop_overload configuration.
   */
  virtual UnitFloat dropOverload() const PURE;

  /**
   * Set up the drop_overload value for the cluster.
   */
  virtual void setDropOverload(UnitFloat drop_overload) PURE;
};

using ClusterSharedPtr = std::shared_ptr<Cluster>;
using ClusterConstOptRef = absl::optional<std::reference_wrapper<const Cluster>>;

} // namespace Upstream
} // namespace Envoy

// NOLINT(namespace-envoy)
namespace fmt {

// fmt formatter class for Host
template <> struct formatter<Envoy::Upstream::Host> : formatter<absl::string_view> {
  template <typename FormatContext>
  auto format(const Envoy::Upstream::Host& host, FormatContext& ctx) -> decltype(ctx.out()) {
    absl::string_view out = !host.hostname().empty() ? host.hostname()
                            : host.address()         ? host.address()->asStringView()
                                                     : "<empty>";
    return formatter<absl::string_view>().format(out, ctx);
  }
};

} // namespace fmt
#pragma once

#include "envoy/config/typed_config.h"
#include "envoy/singleton/manager.h"
#include "envoy/upstream/types.h"
#include "envoy/upstream/upstream.h"

namespace Envoy {
namespace Upstream {

/**
 * Used to optionally modify the PriorityLoad when selecting a priority for
 * a retry attempt.
 *
 * Each RetryPriority will live throughout the lifetime of a request and updated
 * with attempted hosts through onHostAttempted.
 */
class RetryPriority {
public:
  virtual ~RetryPriority() = default;

  /**
   * Function that maps a HostDescription to it's effective priority level in a cluster.
   * For most cluster types, the mapping is simply `return host.priority()`, but some
   * cluster types require more complex mapping.
   * @return either the effective priority, or absl::nullopt if the mapping cannot be determined,
   *         which can happen if the host has been removed from the configurations since it was
   *         used.
   */
  using PriorityMappingFunc =
      std::function<absl::optional<uint32_t>(const Upstream::HostDescription&)>;

  static absl::optional<uint32_t> defaultPriorityMapping(const Upstream::HostDescription& host) {
    return host.priority();
  }

  /**
   * Determines what PriorityLoad to use.
   *
   * @param priority_set current priority set of cluster.
   * @param original_priority_load the unmodified HealthAndDegradedLoad.
   * @param priority_mapping_func a callback to get the priority of a host that has
   *        been attempted. This function may only be called on hosts that were
   *        passed to calls to `onHostAttempted()` on this object.
   * @return HealthAndDegradedLoad load that should be used for the next retry. Return
   * original_priority_load if the original load should be used. a pointer to original_priority,
   * original_degraded_priority if no changes should be made.
   */
  virtual const HealthyAndDegradedLoad&
  determinePriorityLoad(const PrioritySet& priority_set,
                        const HealthyAndDegradedLoad& original_priority_load,
                        const PriorityMappingFunc& priority_mapping_func) PURE;

  /**
   * Called after a host has been attempted but before host selection for the next attempt has
   * begun.
   *
   * @param attempted_host the host that was previously attempted.
   */
  virtual void onHostAttempted(HostDescriptionConstSharedPtr attempted_host) PURE;
};

using RetryPrioritySharedPtr = std::shared_ptr<RetryPriority>;

/**
 * Used to decide whether a selected host should be rejected during retries. Host selection will be
 * reattempted until either the host predicate accepts the host or a configured max number of
 * attempts is reached.
 *
 * Each RetryHostPredicate will live throughout the lifetime of a request and updated
 * with attempted hosts through onHostAttempted.
 */
class RetryHostPredicate {
public:
  virtual ~RetryHostPredicate() = default;

  /**
   * Determines whether a host should be rejected during host selection.
   *
   * @param candidate_host the host to either reject or accept.
   * @return whether the host should be rejected and host selection reattempted.
   */
  virtual bool shouldSelectAnotherHost(const Host& candidate_host) PURE;

  /**
   * Called after a host has been attempted but before host selection for the next attempt has
   * begun.
   *
   * @param attempted_host the host that was previously attempted.
   */
  virtual void onHostAttempted(HostDescriptionConstSharedPtr attempted_host) PURE;
};

using RetryHostPredicateSharedPtr = std::shared_ptr<RetryHostPredicate>;

/**
 * A predicate that is applied prior to retrying a request. Each predicate can customize request
 * behavior prior to the request being retried.
 */
class RetryOptionsPredicate {
public:
  struct UpdateOptionsParameters {
    // Stream info for the previous request attempt that is about to be retried.
    StreamInfo::StreamInfo& retriable_request_stream_info_;
    // The current upstream socket options that were used for connection pool selection on the
    // previous attempt, or the result of an updated set of options from a previously run
    // retry options predicate.
    Network::Socket::OptionsSharedPtr current_upstream_socket_options_;
  };

  struct UpdateOptionsReturn {
    // New upstream socket options to apply to the next request attempt. If changed, will affect
    // connection pool selection similar to that which was done for the initial request.
    absl::optional<Network::Socket::OptionsSharedPtr> new_upstream_socket_options_;
  };

  virtual ~RetryOptionsPredicate() = default;

  /**
   * Update request options.
   * @param parameters supplies the update parameters.
   * @return the new options to apply. Each option is wrapped in an optional and is only applied
   *         if valid.
   */
  virtual UpdateOptionsReturn updateOptions(const UpdateOptionsParameters& parameters) const PURE;
};

using RetryOptionsPredicateConstSharedPtr = std::shared_ptr<const RetryOptionsPredicate>;

/**
 * Context for all retry extensions.
 */
class RetryExtensionFactoryContext {
public:
  virtual ~RetryExtensionFactoryContext() = default;

  /**
   * @return Singleton::Manager& the server-wide singleton manager.
   */
  virtual Singleton::Manager& singletonManager() PURE;
};

/**
 * Factory for RetryPriority.
 */
class RetryPriorityFactory : public Config::TypedFactory {
public:
  virtual RetryPrioritySharedPtr
  createRetryPriority(const Protobuf::Message& config,
                      ProtobufMessage::ValidationVisitor& validation_visitor,
                      uint32_t retry_count) PURE;

  std::string category() const override { return "envoy.retry_priorities"; }
};

/**
 * Factory for RetryHostPredicate.
 */
class RetryHostPredicateFactory : public Config::TypedFactory {
public:
  virtual RetryHostPredicateSharedPtr createHostPredicate(const Protobuf::Message& config,
                                                          uint32_t retry_count) PURE;

  std::string category() const override { return "envoy.retry_host_predicates"; }
};

/**
 * Factory for RetryOptionsPredicate.
 */
class RetryOptionsPredicateFactory : public Config::TypedFactory {
public:
  virtual RetryOptionsPredicateConstSharedPtr
  createOptionsPredicate(const Protobuf::Message& config,
                         RetryExtensionFactoryContext& context) PURE;

  std::string category() const override { return "envoy.retry_options_predicates"; }
};

} // namespace Upstream
} // namespace Envoy
#pragma once

#include "envoy/config/core/v3/base.pb.h"

#include "source/common/protobuf/utility.h"

namespace Envoy {
namespace Upstream {

// We use a tuple representation for hashing/equality/comparison, since this
// ensures we are not subject to proto nuances like unknown fields (e.g. from
// original type information annotations).
using LocalityTuple = std::tuple<const std::string&, const std::string&, const std::string&>;

struct LocalityHash {
  size_t operator()(const envoy::config::core::v3::Locality& locality) const {
    return absl::Hash<LocalityTuple>()({locality.region(), locality.zone(), locality.sub_zone()});
  }
};

struct LocalityEqualTo {
  bool operator()(const envoy::config::core::v3::Locality& lhs,
                  const envoy::config::core::v3::Locality& rhs) const {
    const LocalityTuple lhs_tuple = LocalityTuple(lhs.region(), lhs.zone(), lhs.sub_zone());
    const LocalityTuple rhs_tuple = LocalityTuple(rhs.region(), rhs.zone(), rhs.sub_zone());
    return lhs_tuple == rhs_tuple;
  }
};

struct LocalityLess {
  bool operator()(const envoy::config::core::v3::Locality& lhs,
                  const envoy::config::core::v3::Locality& rhs) const {
    const LocalityTuple lhs_tuple = LocalityTuple(lhs.region(), lhs.zone(), lhs.sub_zone());
    const LocalityTuple rhs_tuple = LocalityTuple(rhs.region(), rhs.zone(), rhs.sub_zone());
    return lhs_tuple < rhs_tuple;
  }
};

// For tests etc. where this is convenient.
static inline envoy::config::core::v3::Locality
Locality(const std::string& region, const std::string& zone, const std::string sub_zone) {
  envoy::config::core::v3::Locality locality;
  locality.set_region(region);
  locality.set_zone(zone);
  locality.set_sub_zone(sub_zone);
  return locality;
}

} // namespace Upstream
} // namespace Envoy

// Something heinous this way comes. Required to allow == for LocalityWeightsMap.h in eds.h.
namespace envoy {
namespace config {
namespace core {
namespace v3 {

inline bool operator==(const envoy::config::core::v3::Locality& x,
                       const envoy::config::core::v3::Locality& y) {
  return Envoy::Upstream::LocalityEqualTo()(x, y);
}

} // namespace v3
} // namespace core
} // namespace config
} // namespace envoy
#pragma once

#include <chrono>
#include <cstdint>
#include <functional>
#include <memory>

#include "envoy/common/pure.h"
#include "envoy/common/time.h"
#include "envoy/data/cluster/v3/outlier_detection_event.pb.h"

#include "absl/types/optional.h"

namespace Envoy {
namespace Upstream {

class Host;
using HostSharedPtr = std::shared_ptr<Host>;

class HostDescription;
using HostDescriptionConstSharedPtr = std::shared_ptr<const HostDescription>;

namespace Outlier {

/**
 * Non-HTTP result of requests/operations.
 */
enum class Result {
  // Local origin errors detected by Envoy.
  LocalOriginTimeout,             // Timed out while connecting or executing a request.
  LocalOriginConnectFailed,       // Remote host rejected the connection.
  LocalOriginConnectSuccess,      // Successfully established a connection to upstream host.
                                  // Use this code when there is another protocol on top of
                                  // transport protocol. For example HTTP runs on top of tcp.
                                  // The same for redis. It first establishes TCP and then runs
                                  // a transaction.
  LocalOriginConnectSuccessFinal, // Successfully established a connection to upstream host
                                  // Use this code when there is no other protocol on top of the
                                  // protocol used by a filter. For example tcp_proxy filter
                                  // serves only tcp level. There is no other protocol on top of
                                  // tcp which the tcp_proxy filter is aware of.

  // The entries below only make sense when Envoy understands requests/responses for the
  // protocol being proxied. They do not make sense for TcpProxy, for example.
  // External origin errors.
  ExtOriginRequestFailed, // The server indicated it cannot process a request
  ExtOriginRequestSuccess // Request was completed successfully.
};

/**
 * Monitor for per host data. Proxy filters should send pertinent data when available.
 */
class DetectorHostMonitor {
public:
  // Types of Success Rate monitors.
  enum class SuccessRateMonitorType { ExternalOrigin, LocalOrigin };

  virtual ~DetectorHostMonitor() = default;

  /**
   * @return the number of times this host has been ejected.
   */
  virtual uint32_t numEjections() PURE;

  /**
   * Add an HTTP response code for a host.
   */
  virtual void putHttpResponseCode(uint64_t code) PURE;

  /**
   * Add a non-HTTP result for a host.
   * Some non-HTTP codes like TIMEOUT may require special mapping to HTTP code
   * and such code may be passed as optional parameter.
   */
  virtual void putResult(Result result, absl::optional<uint64_t> code) PURE;

  /**
   * Wrapper around putResult with 2 params when mapping to HTTP code is not
   * required.
   */
  void putResult(Result result) { putResult(result, absl::nullopt); }

  /**
   * Add a response time for a host (in this case response time is generic and might be used for
   * different operations including HTTP, Mongo, Redis, etc.).
   */
  virtual void putResponseTime(std::chrono::milliseconds time) PURE;

  /**
   * Get the time of last ejection.
   * @return the last time this host was ejected, if the host has been ejected previously.
   */
  virtual const absl::optional<MonotonicTime>& lastEjectionTime() PURE;

  /**
   * Get the time of last unejection.
   * @return the last time this host was unejected, if the host has been unejected previously.
   */
  virtual const absl::optional<MonotonicTime>& lastUnejectionTime() PURE;

  /**
   * @return the success rate of the host in the last calculated interval, in the range 0-100.
   *         -1 means that the host did not have enough request volume to calculate success rate
   *         or the cluster did not have enough hosts to run through success rate outlier ejection.
   * @param type specifies for which Success Rate Monitor the success rate value should be returned.
   *         If the outlier detector is configured not to split external and local origin errors,
   *         ExternalOrigin type returns success rate for all types of errors: external and local
   * origin and LocalOrigin type returns -1. If the outlier detector is configured to split external
   * and local origin errors, ExternalOrigin type returns success rate for external origin errors
   * and LocalOrigin type returns success rate for local origin errors.
   */
  virtual double successRate(SuccessRateMonitorType type) const PURE;
};

using DetectorHostMonitorPtr = std::unique_ptr<DetectorHostMonitor>;

/**
 * Interface for an outlier detection engine. Uses per host data to determine which hosts in a
 * cluster are outliers and should be ejected.
 */
class Detector {
public:
  virtual ~Detector() = default;

  /**
   * Outlier detection change state callback.
   */
  using ChangeStateCb = std::function<void(const HostSharedPtr& host)>;

  /**
   * Add a changed state callback to the detector. The callback will be called whenever any host
   * changes state (either ejected or brought back in) due to outlier status.
   */
  virtual void addChangedStateCb(ChangeStateCb cb) PURE;

  /**
   * Returns the average success rate of the hosts in the Detector for the last aggregation
   * interval.
   * @return the average success rate, or -1 if there were not enough hosts with enough request
   *         volume to proceed with success rate based outlier ejection.
   * @param type - see DetectorHostMonitor::successRate.
   */
  virtual double successRateAverage(DetectorHostMonitor::SuccessRateMonitorType) const PURE;

  /**
   * Returns the success rate threshold used in the last interval. The threshold is used to eject
   * hosts based on their success rate.
   * @return the threshold, or -1 if there were not enough hosts with enough request volume to
   *         proceed with success rate based outlier ejection.
   */
  virtual double
      successRateEjectionThreshold(DetectorHostMonitor::SuccessRateMonitorType) const PURE;
};

using DetectorSharedPtr = std::shared_ptr<Detector>;

/**
 * Sink for outlier detection event logs.
 */
class EventLogger {
public:
  virtual ~EventLogger() = default;

  /**
   * Log an ejection event.
   * @param host supplies the host that generated the event.
   * @param detector supplies the detector that is doing the ejection.
   * @param type supplies the type of the event.
   * @param enforced is true if the ejection took place; false, if only logging took place.
   */
  virtual void logEject(const HostDescriptionConstSharedPtr& host, Detector& detector,
                        envoy::data::cluster::v3::OutlierEjectionType type, bool enforced) PURE;

  /**
   * Log an unejection event.
   * @param host supplies the host that generated the event.
   */
  virtual void logUneject(const HostDescriptionConstSharedPtr& host) PURE;
};

using EventLoggerSharedPtr = std::shared_ptr<EventLogger>;

} // namespace Outlier
} // namespace Upstream
} // namespace Envoy
#pragma once

#include <cstdint>
#include <functional>
#include <memory>
#include <string>

#include "envoy/api/os_sys_calls.h"
#include "envoy/common/exception.h"
#include "envoy/common/platform.h"
#include "envoy/common/pure.h"
#include "envoy/http/stream_reset_handler.h"

#include "source/common/common/assert.h"
#include "source/common/common/byte_order.h"
#include "source/common/common/utility.h"

#include "absl/container/inlined_vector.h"
#include "absl/strings/string_view.h"
#include "absl/types/optional.h"
#include "absl/types/span.h"

namespace Envoy {
namespace Buffer {

/**
 * A raw memory data slice including location and length.
 */
struct RawSlice {
  void* mem_ = nullptr;
  size_t len_ = 0;

  bool operator==(const RawSlice& rhs) const { return mem_ == rhs.mem_ && len_ == rhs.len_; }
  bool operator!=(const RawSlice& rhs) const { return !(*this == rhs); }
};

/**
 * A const raw memory data slice including the location and length.
 */
struct ConstRawSlice {
  const void* mem_ = nullptr;
  size_t len_ = 0;

  bool operator==(const RawSlice& rhs) const { return mem_ == rhs.mem_ && len_ == rhs.len_; }
  bool operator!=(const RawSlice& rhs) const { return !(*this == rhs); }
};

using RawSliceVector = absl::InlinedVector<RawSlice, 16>;

/**
 * A wrapper class to facilitate passing in externally owned data to a buffer via addBufferFragment.
 * When the buffer no longer needs the data passed in through a fragment, it calls done() on it.
 */
class BufferFragment {
public:
  virtual ~BufferFragment() = default;
  /**
   * @return const void* a pointer to the referenced data.
   */
  virtual const void* data() const PURE;

  /**
   * @return size_t the size of the referenced data.
   */
  virtual size_t size() const PURE;

  /**
   * Called by a buffer when the referenced data is no longer needed.
   */
  virtual void done() PURE;
};

/**
 * A class to facilitate extracting buffer slices from a buffer instance.
 */
class SliceData {
public:
  virtual ~SliceData() = default;

  /**
   * @return a mutable view of the slice data.
   */
  virtual absl::Span<uint8_t> getMutableData() PURE;
};

using SliceDataPtr = std::unique_ptr<SliceData>;

class Reservation;
class ReservationSingleSlice;

// Base class for an object to manage the ownership for slices in a `Reservation` or
// `ReservationSingleSlice`.
class ReservationSlicesOwner {
public:
  virtual ~ReservationSlicesOwner() = default;
};

using ReservationSlicesOwnerPtr = std::unique_ptr<ReservationSlicesOwner>;

/**
 * An interface for accounting for the usage for byte tracking in buffers.
 *
 * Currently this is only used by L7 streams to track the amount of memory
 * allocated in buffers by the stream.
 */
class BufferMemoryAccount {
public:
  virtual ~BufferMemoryAccount() = default;

  /**
   * Charges the account for using the specified amount of memory.
   *
   * @param amount the amount to debit.
   */
  virtual void charge(uint64_t amount) PURE;

  /**
   * Called to credit the account for an amount of memory
   * is no longer used.
   *
   * @param amount the amount to credit.
   */
  virtual void credit(uint64_t amount) PURE;

  /**
   * Clears the associated downstream with this account.
   * After this has been called, calls to reset the downstream become no-ops.
   * Must be called before downstream is deleted.
   */
  virtual void clearDownstream() PURE;

  /**
   * Reset the downstream stream associated with this account. Resetting the downstream stream
   * should trigger a reset of the corresponding upstream stream if it exists.
   */
  virtual void resetDownstream() PURE;
};

using BufferMemoryAccountSharedPtr = std::shared_ptr<BufferMemoryAccount>;

/**
 * A basic buffer abstraction.
 */
class Instance {
public:
  virtual ~Instance() = default;

  /**
   * Register function to call when the last byte in the last slice of this
   * buffer has fully drained. Note that slices may be transferred to
   * downstream buffers, drain trackers are transferred along with the bytes
   * they track so the function is called only after the last byte is drained
   * from all buffers.
   */
  virtual void addDrainTracker(std::function<void()> drain_tracker) PURE;

  /**
   * Binds the account to be charged for resources used by the buffer. This
   * should only be called when the buffer is empty as existing slices
   * within the buffer won't retroactively get tagged.
   *
   * @param account a shared_ptr to the account to charge.
   */
  virtual void bindAccount(BufferMemoryAccountSharedPtr account) PURE;

  /**
   * Copy data into the buffer (deprecated, use absl::string_view variant
   * instead).
   * TODO(htuch): Cleanup deprecated call sites.
   * @param data supplies the data address.
   * @param size supplies the data size.
   */
  virtual void add(const void* data, uint64_t size) PURE;

  /**
   * Add externally owned data into the buffer. No copying is done. fragment is not owned. When
   * the fragment->data() is no longer needed, fragment->done() is called.
   * @param fragment the externally owned data to add to the buffer.
   */
  virtual void addBufferFragment(BufferFragment& fragment) PURE;

  /**
   * Copy a string into the buffer.
   * @param data supplies the string to copy.
   */
  virtual void add(absl::string_view data) PURE;

  /**
   * Copy another buffer into this buffer.
   * @param data supplies the buffer to copy.
   */
  virtual void add(const Instance& data) PURE;

  /**
   * Prepend a string_view to the buffer.
   * @param data supplies the string_view to copy.
   */
  virtual void prepend(absl::string_view data) PURE;

  /**
   * Prepend data from another buffer to this buffer.
   * The supplied buffer is drained after this operation.
   * @param data supplies the buffer to copy.
   */
  virtual void prepend(Instance& data) PURE;

  /**
   * Copy out a section of the buffer.
   * @param start supplies the buffer index to start copying from.
   * @param size supplies the size of the output buffer.
   * @param data supplies the output buffer to fill.
   */
  virtual void copyOut(size_t start, uint64_t size, void* data) const PURE;

  /**
   * Copy out a section of the buffer to  dynamic array of slices.
   * @param size supplies the size of the data that will be copied.
   * @param slices supplies the output slices to fill.
   * @param num_slice supplies the number of slices to fill.
   * @return the number of bytes copied.
   */
  virtual uint64_t copyOutToSlices(uint64_t size, Buffer::RawSlice* slices,
                                   uint64_t num_slice) const PURE;

  /**
   * Drain data from the buffer.
   * @param size supplies the length of data to drain.
   */
  virtual void drain(uint64_t size) PURE;

  /**
   * Fetch the raw buffer slices.
   * @param max_slices supplies an optional limit on the number of slices to fetch, for performance.
   * @return RawSliceVector with non-empty slices in the buffer.
   */
  virtual RawSliceVector
  getRawSlices(absl::optional<uint64_t> max_slices = absl::nullopt) const PURE;

  /**
   * Fetch the valid data pointer and valid data length of the first non-zero-length
   * slice in the buffer.
   * @return RawSlice the first non-empty slice in the buffer, or {nullptr, 0} if the buffer
   * is empty.
   */
  virtual RawSlice frontSlice() const PURE;

  /**
   * Transfer ownership of the front slice to the caller. Must only be called if the
   * buffer is not empty otherwise the implementation will have undefined behavior.
   * If the underlying slice is immutable then the implementation must create and return
   * a mutable slice that has a copy of the immutable data.
   * @return pointer to SliceData object that wraps the front slice
   */
  virtual SliceDataPtr extractMutableFrontSlice() PURE;

  /**
   * @return uint64_t the total length of the buffer (not necessarily contiguous in memory).
   */
  virtual uint64_t length() const PURE;

  /**
   * @return a pointer to the first byte of data that has been linearized out to size bytes.
   */
  virtual void* linearize(uint32_t size) PURE;

  /**
   * Move a buffer into this buffer. As little copying is done as possible.
   * @param rhs supplies the buffer to move.
   */
  virtual void move(Instance& rhs) PURE;

  /**
   * Move a portion of a buffer into this buffer. As little copying is done as possible.
   * @param rhs supplies the buffer to move.
   * @param length supplies the amount of data to move.
   */
  virtual void move(Instance& rhs, uint64_t length) PURE;

  /**
   * Move a portion of a buffer into this buffer. If reset_drain_trackers_and_accounting is true,
   * then any drain trackers on the source buffer are also called and cleared so that the
   * connection originating the source buffer (e.g. an internal listener connection) may be deleted
   * without causing a use-after-free.
   * @param rhs supplies the buffer to move.
   * @param length supplies the amount of data to move.
   * @param reset_drain_trackers_and_accounting whether the drain trackers on the source buffers
   * should be cleared, so that the source buffer is deletable.
   */
  virtual void move(Instance& rhs, uint64_t length, bool reset_drain_trackers_and_accounting) PURE;

  /**
   * Reserve space in the buffer for reading into. The amount of space reserved is determined
   * based on buffer settings and performance considerations.
   * @return a `Reservation`, on which `commit()` can be called, or which can
   *   be destructed to discard any resources in the `Reservation`.
   */
  virtual Reservation reserveForRead() PURE;

  /**
   * Reserve space in the buffer in a single slice.
   * @param length the exact length of the reservation.
   * @param separate_slice specifies whether the reserved space must be in a separate slice
   *   from any other data in this buffer.
   * @return a `ReservationSingleSlice` which has exactly one slice in it.
   */
  virtual ReservationSingleSlice reserveSingleSlice(uint64_t length,
                                                    bool separate_slice = false) PURE;

  /**
   * Search for an occurrence of data within the buffer.
   * @param data supplies the data to search for.
   * @param size supplies the length of the data to search for.
   * @param start supplies the starting index to search from.
   * @param length limits the search to specified number of bytes starting from start index.
   * When length value is zero, entire length of data from starting index to the end is searched.
   * @return the index where the match starts or -1 if there is no match.
   */
  virtual ssize_t search(const void* data, uint64_t size, size_t start, size_t length) const PURE;

  /**
   * Search for an occurrence of data within entire buffer.
   * @param data supplies the data to search for.
   * @param size supplies the length of the data to search for.
   * @param start supplies the starting index to search from.
   * @return the index where the match starts or -1 if there is no match.
   */
  ssize_t search(const void* data, uint64_t size, size_t start) const {
    return search(data, size, start, 0);
  }

  /**
   * Search for an occurrence of data at the start of a buffer.
   * @param data supplies the data to search for.
   * @return true if this buffer starts with data, false otherwise.
   */
  virtual bool startsWith(absl::string_view data) const PURE;

  /**
   * Constructs a flattened string from a buffer.
   * @return the flattened string.
   */
  virtual std::string toString() const PURE;

  /**
   * Copy an integer out of the buffer.
   * @param start supplies the buffer index to start copying from.
   * @param Size how many bytes to read out of the buffer.
   * @param Endianness specifies the byte order to use when decoding the integer.
   * @details Size parameter: Some protocols have integer fields whose size in bytes won't match the
   * size in bytes of C++'s integer types. Take a 3-byte integer field for example, which we want to
   * represent as a 32-bit (4 bytes) integer. One option to deal with that situation is to read 4
   * bytes from the buffer and ignore 1. There are a few problems with that solution, though.
   *   * The first problem is buffer underflow: there may not be more than Size bytes available
   * (say, last field in the payload), so that's an edge case to take into consideration.
   *   * The second problem is draining the buffer after reading. With the above solution we cannot
   *     read and discard in one go. We'd need to peek 4 bytes, ignore 1 and then drain 3. That not
   *     only looks hacky since the sizes don't match, but also produces less terse code and
   * requires the caller to propagate that logic to all call sites. Things complicate even further
   * when endianness is taken into consideration: should the most or least-significant bytes be
   * padded? Dealing with this situation requires a high level of care and attention to detail.
   * Properly calculating which bytes to discard and how to displace the data is not only error
   * prone, but also shifts to the caller a burden that could be solved in a much more generic,
   * transparent and well tested manner.
   *   * The last problem in the list is sign extension, which should be properly handled when
   * reading signed types with negative values. To make matters easier, the optional Size parameter
   * can be specified in those situations where there's a need to read less bytes than a C++'s
   * integer size in bytes. For the most common case when one needs to read exactly as many bytes as
   * the size of C++'s integer, this parameter can simply be omitted and it will be automatically
   * deduced from the size of the type T
   */
  template <typename T, ByteOrder Endianness = ByteOrder::Host, size_t Size = sizeof(T)>
  T peekInt(uint64_t start = 0) const {
    static_assert(Size <= sizeof(T), "requested size is bigger than integer being read");

    if (length() < start + Size) {
      ExceptionUtil::throwEnvoyException("buffer underflow");
    }

    constexpr const auto displacement = Endianness == ByteOrder::BigEndian ? sizeof(T) - Size : 0;

    auto result = static_cast<T>(0);
    constexpr const auto all_bits_enabled = static_cast<T>(~static_cast<T>(0));

    int8_t* bytes = reinterpret_cast<int8_t*>(std::addressof(result));
    copyOut(start, Size, &bytes[displacement]);

    constexpr const auto most_significant_read_byte =
        Endianness == ByteOrder::BigEndian ? displacement : Size - 1;

    // If Size == sizeof(T), we need to make sure we don't generate an invalid left shift
    // (e.g. int32 << 32), even though we know that that branch of the conditional will.
    // not be taken. Size % sizeof(T) gives us the correct left shift when Size < sizeof(T),
    // and generates a left shift of 0 bits when Size == sizeof(T)
    const auto sign_extension_bits =
        std::is_signed<T>::value && Size < sizeof(T) && bytes[most_significant_read_byte] < 0
            ? static_cast<T>(static_cast<typename std::make_unsigned<T>::type>(all_bits_enabled)
                             << ((Size % sizeof(T)) * CHAR_BIT))
            : static_cast<T>(0);

    return fromEndianness<Endianness>(static_cast<T>(result)) | sign_extension_bits;
  }

  /**
   * Copy a little endian integer out of the buffer.
   * @param start supplies the buffer index to start copying from.
   * @param Size how many bytes to read out of the buffer.
   */
  template <typename T, size_t Size = sizeof(T)> T peekLEInt(uint64_t start = 0) const {
    return peekInt<T, ByteOrder::LittleEndian, Size>(start);
  }

  /**
   * Copy a big endian integer out of the buffer.
   * @param start supplies the buffer index to start copying from.
   * @param Size how many bytes to read out of the buffer.
   */
  template <typename T, size_t Size = sizeof(T)> T peekBEInt(uint64_t start = 0) const {
    return peekInt<T, ByteOrder::BigEndian, Size>(start);
  }

  /**
   * Copy an integer out of the buffer and drain the read data.
   * @param Size how many bytes to read out of the buffer.
   * @param Endianness specifies the byte order to use when decoding the integer.
   */
  template <typename T, ByteOrder Endianness = ByteOrder::Host, size_t Size = sizeof(T)>
  T drainInt() {
    const auto result = peekInt<T, Endianness, Size>();
    drain(Size);
    return result;
  }

  /**
   * Copy a little endian integer out of the buffer and drain the read data.
   * @param Size how many bytes to read out of the buffer.
   */
  template <typename T, size_t Size = sizeof(T)> T drainLEInt() {
    return drainInt<T, ByteOrder::LittleEndian, Size>();
  }

  /**
   * Copy a big endian integer out of the buffer and drain the read data.
   * @param Size how many bytes to read out of the buffer.
   */
  template <typename T, size_t Size = sizeof(T)> T drainBEInt() {
    return drainInt<T, ByteOrder::BigEndian, Size>();
  }

  /**
   * Copy a byte into the buffer.
   * @param value supplies the byte to copy into the buffer.
   */
  void writeByte(uint8_t value) { add(std::addressof(value), 1); }

  /**
   * Copy value as a byte into the buffer.
   * @param value supplies the byte to copy into the buffer.
   */
  template <typename T> void writeByte(T value) { writeByte(static_cast<uint8_t>(value)); }

  /**
   * Copy an integer into the buffer.
   * @param value supplies the integer to copy into the buffer.
   * @param Size how many bytes to write from the requested integer.
   * @param Endianness specifies the byte order to use when encoding the integer.
   */
  template <ByteOrder Endianness = ByteOrder::Host, typename T, size_t Size = sizeof(T)>
  void writeInt(T value) {
    static_assert(Size <= sizeof(T), "requested size is bigger than integer being written");

    const auto data = toEndianness<Endianness>(value);
    constexpr const auto displacement = Endianness == ByteOrder::BigEndian ? sizeof(T) - Size : 0;
    add(reinterpret_cast<const char*>(std::addressof(data)) + displacement, Size);
  }

  /**
   * Copy an integer into the buffer in little endian byte order.
   * @param value supplies the integer to copy into the buffer.
   * @param Size how many bytes to write from the requested integer.
   */
  template <typename T, size_t Size = sizeof(T)> void writeLEInt(T value) {
    writeInt<ByteOrder::LittleEndian, T, Size>(value);
  }

  /**
   * Copy an integer into the buffer in big endian byte order.
   * @param value supplies the integer to copy into the buffer.
   * @param Size how many bytes to write from the requested integer.
   */
  template <typename T, size_t Size = sizeof(T)> void writeBEInt(T value) {
    writeInt<ByteOrder::BigEndian, T, Size>(value);
  }

  /**
   * Copy multiple string type fragments to the buffer.
   * @param fragments A sequence of string views with variable length.
   * @return The total size of the data copied to the buffer.
   */
  virtual size_t addFragments(absl::Span<const absl::string_view> fragments) PURE;

  /**
   * Set the buffer's high watermark. The buffer's low watermark is implicitly set to half the high
   * watermark. Setting the high watermark to 0 disables watermark functionality.
   * @param watermark supplies the buffer high watermark size threshold, in bytes.
   * @param watermark supplies the overflow multiplier, in bytes.
   *        If set to non-zero, overflow callbacks will be called if the
   *        buffered data exceeds watermark * overflow_multiplier.
   */
  virtual void setWatermarks(uint32_t watermark, uint32_t overflow_multiplier = 0) PURE;

  /**
   * Returns the configured high watermark. A return value of 0 indicates that watermark
   * functionality is disabled.
   */
  virtual uint32_t highWatermark() const PURE;
  /**
   * Determine if the buffer watermark trigger condition is currently set. The watermark trigger is
   * set when the buffer size exceeds the configured high watermark and is cleared once the buffer
   * size drops to the low watermark.
   * @return true if the buffer size once exceeded the high watermark and hasn't since dropped to
   * the low watermark.
   */
  virtual bool highWatermarkTriggered() const PURE;

private:
  friend Reservation;
  friend ReservationSingleSlice;

  /**
   * Called by a `Reservation` to commit `length` bytes of the
   * reservation.
   */
  virtual void commit(uint64_t length, absl::Span<RawSlice> slices,
                      ReservationSlicesOwnerPtr slices_owner) PURE;
};

using InstancePtr = std::unique_ptr<Instance>;

/**
 * An abstract factory for creating watermarked buffers and buffer memory
 * accounts. The factory also supports tracking active memory accounts.
 */
class WatermarkFactory {
public:
  virtual ~WatermarkFactory() = default;

  /**
   * Creates and returns a unique pointer to a new buffer.
   * @param below_low_watermark supplies a function to call if the buffer goes under a configured
   *   low watermark.
   * @param above_high_watermark supplies a function to call if the buffer goes over a configured
   *   high watermark.
   * @return a newly created InstancePtr.
   */
  virtual InstancePtr createBuffer(std::function<void()> below_low_watermark,
                                   std::function<void()> above_high_watermark,
                                   std::function<void()> above_overflow_watermark) PURE;

  /**
   * Create and returns a buffer memory account.
   *
   * @param reset_handler supplies the stream_reset_handler the account will
   * invoke to reset the stream.
   * @return a BufferMemoryAccountSharedPtr of the newly created account or
   * nullptr if tracking is disabled.
   */
  virtual BufferMemoryAccountSharedPtr createAccount(Http::StreamResetHandler& reset_handler) PURE;

  /**
   * Goes through the tracked accounts, resetting the accounts and their
   * corresponding stream depending on the pressure.
   *
   * @param pressure scaled threshold pressure used to compute the buckets to
   *  reset internally.
   * @return the number of streams reset
   */
  virtual uint64_t resetAccountsGivenPressure(float pressure) PURE;
};

using WatermarkFactoryPtr = std::unique_ptr<WatermarkFactory>;
using WatermarkFactorySharedPtr = std::shared_ptr<WatermarkFactory>;

/**
 * Holds an in-progress addition to a buffer.
 *
 * @note For performance reasons, this class is passed by value to
 * avoid an extra allocation, so it cannot have any virtual methods.
 */
class Reservation final {
public:
  Reservation(Reservation&&) = default;
  ~Reservation() = default;

  /**
   * @return an array of `RawSlice` of length `numSlices()`.
   */
  RawSlice* slices() { return slices_.data(); }
  const RawSlice* slices() const { return slices_.data(); }

  /**
   * @return the number of slices present.
   */
  uint64_t numSlices() const { return slices_.size(); }

  /**
   * @return the total length of the Reservation.
   */
  uint64_t length() const { return length_; }

  /**
   * Commits some or all of the data in the reservation.
   * @param length supplies the number of bytes to commit. This must be
   *   less than or equal to the size of the `Reservation`.
   *
   * @note No other methods should be called on the object after `commit()` is called.
   */
  void commit(uint64_t length) {
    ENVOY_BUG(length <= length_, "commit() length must be <= size of the Reservation");
    ASSERT(length == 0 || !slices_.empty(),
           "Reservation.commit() called on empty Reservation; possible double-commit().");
    buffer_.commit(length, absl::MakeSpan(slices_), std::move(slices_owner_));
    length_ = 0;
    slices_.clear();
    ASSERT(slices_owner_ == nullptr);
  }

  // Tuned to allow reads of 128k, using 16k slices.
  static constexpr uint32_t MAX_SLICES_ = 8;

private:
  Reservation(Instance& buffer) : buffer_(buffer) {}

  // The buffer that created this `Reservation`.
  Instance& buffer_;

  // The combined length of all slices in the Reservation.
  uint64_t length_;

  // The RawSlices in the reservation, usable by operations such as `::readv()`.
  absl::InlinedVector<RawSlice, MAX_SLICES_> slices_;

  // An owner that can be set by the creator of the `Reservation` to free slices upon
  // destruction.
  ReservationSlicesOwnerPtr slices_owner_;

public:
  // The following are for use only by implementations of Buffer. Because c++
  // doesn't allow inheritance of friendship, these are just trying to make
  // misuse easy to spot in a code review.
  static Reservation bufferImplUseOnlyConstruct(Instance& buffer) { return {buffer}; }
  decltype(slices_)& bufferImplUseOnlySlices() { return slices_; }
  ReservationSlicesOwnerPtr& bufferImplUseOnlySlicesOwner() { return slices_owner_; }
  void bufferImplUseOnlySetLength(uint64_t length) { length_ = length; }
};

/**
 * Holds an in-progress addition to a buffer, holding only a single slice.
 *
 * @note For performance reasons, this class is passed by value to
 * avoid an extra allocation, so it cannot have any virtual methods.
 */
class ReservationSingleSlice final {
public:
  ReservationSingleSlice(ReservationSingleSlice&&) = default;
  ~ReservationSingleSlice() = default;

  /**
   * @return the slice in the Reservation.
   */
  RawSlice slice() const { return slice_; }

  /**
   * @return the total length of the Reservation.
   */
  uint64_t length() const { return slice_.len_; }

  /**
   * Commits some or all of the data in the reservation.
   * @param length supplies the number of bytes to commit. This must be
   *   less than or equal to the size of the `Reservation`.
   *
   * @note No other methods should be called on the object after `commit()` is called.
   */
  void commit(uint64_t length) {
    ENVOY_BUG(length <= slice_.len_, "commit() length must be <= size of the Reservation");
    ASSERT(length == 0 || slice_.mem_ != nullptr,
           "Reservation.commit() called on empty Reservation; possible double-commit().");
    buffer_.commit(length, absl::MakeSpan(&slice_, 1), std::move(slice_owner_));
    slice_ = {nullptr, 0};
    ASSERT(slice_owner_ == nullptr);
  }

private:
  ReservationSingleSlice(Instance& buffer) : buffer_(buffer) {}

  // The buffer that created this `Reservation`.
  Instance& buffer_;

  // The RawSlice in the reservation, usable by anything needing the raw pointer
  // and length to read into.
  RawSlice slice_{};

  // An owner that can be set by the creator of the `ReservationSingleSlice` to free the slice upon
  // destruction.
  ReservationSlicesOwnerPtr slice_owner_;

public:
  // The following are for use only by implementations of Buffer. Because c++
  // doesn't allow inheritance of friendship, these are just trying to make
  // misuse easy to spot in a code review.
  static ReservationSingleSlice bufferImplUseOnlyConstruct(Instance& buffer) { return {buffer}; }
  RawSlice& bufferImplUseOnlySlice() { return slice_; }
  ReservationSlicesOwnerPtr& bufferImplUseOnlySliceOwner() { return slice_owner_; }
};

} // namespace Buffer
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "buffer_interface",
    hdrs = ["buffer.h"],
    external_deps = [
        "abseil_inlined_vector",
    ],
    deps = [
        "//envoy/api:os_sys_calls_interface",
        "//envoy/common:exception_lib",
        "//envoy/http:stream_reset_handler_interface",
        "//source/common/common:assert_lib",
        "//source/common/common:byte_order_lib",
        "//source/common/common:utility_lib",
    ],
)
#pragma once

#include "envoy/config/typed_config.h"
#include "envoy/router/path_matcher.h"

#include "source/common/common/logger.h"

#include "absl/status/statusor.h"
#include "absl/strings/string_view.h"

namespace Envoy {
namespace Router {

/**
 * Creates the new route path based on the provided rewrite pattern.
 * Subclassing Logger::Loggable so that implementations can log details.
 */
class PathRewriter : Logger::Loggable<Logger::Id::router> {
public:
  PathRewriter() = default;
  virtual ~PathRewriter() = default;

  /**
   * Determines if the matcher policy is compatible.
   *
   * @param path_match_policy current path match policy for route
   * @return true if current path match policy is acceptable
   */
  virtual absl::Status isCompatiblePathMatcher(PathMatcherSharedPtr path_matcher) const PURE;

  /**
   * Rewrites the current path to the specified output. Return a failure in case rewrite
   * is not successful.
   *
   * @param path current path of route
   * @param rewrite_pattern pattern to rewrite the path to
   * @return the rewritten path.
   */
  virtual absl::StatusOr<std::string> rewritePath(absl::string_view path,
                                                  absl::string_view rewrite_pattern) const PURE;

  /**
   * @return the rewrite uri_template.
   */
  virtual absl::string_view uriTemplate() const PURE;

  /**
   * @return the name of the pattern rewriter.
   */
  virtual absl::string_view name() const PURE;
};

using PathRewriterSharedPtr = std::shared_ptr<PathRewriter>;

/**
 * Factory for PathRewriter.
 */
class PathRewriterFactory : public Envoy::Config::TypedFactory {
public:
  ~PathRewriterFactory() override = default;

  /**
   * @param rewrite_config contains the proto stored in TypedExtensionConfig.
   * @return an PathRewriterSharedPtr.
   */
  virtual absl::StatusOr<PathRewriterSharedPtr>
  createPathRewriter(const Protobuf::Message& rewrite_config) PURE;

  ProtobufTypes::MessagePtr createEmptyConfigProto() override PURE;

  /**
   * @return the name of the pattern rewriter to be created.
   */
  std::string name() const override PURE;

  /**
   * @return the category of the pattern rewriter to be created.
   */
  std::string category() const override { return "envoy.path.rewrite"; }
};

} // namespace Router
} // namespace Envoy
#pragma once

#include "envoy/common/pure.h"
#include "envoy/stream_info/filter_state.h"

#include "absl/strings/string_view.h"

namespace Envoy {
namespace Router {

/**
 * Contains a string in a form which is usable with FilterState and
 * allows lazy evaluation if needed. All values meant to be accessible to the
 * custom request/response header mechanism must use this type.
 */
class StringAccessor : public StreamInfo::FilterState::Object {
public:
  /**
   * @return the string the accessor represents.
   */
  virtual absl::string_view asString() const PURE;
};

} // namespace Router
} // namespace Envoy
#pragma once

#include "envoy/config/typed_config.h"

#include "source/common/common/logger.h"

#include "absl/status/statusor.h"
#include "absl/strings/string_view.h"

namespace Envoy {
namespace Router {

/**
 * Decides if the target route path matches the provided pattern.
 * Subclassing Logger::Loggable so that implementations can log details.
 */
class PathMatcher : Logger::Loggable<Logger::Id::router> {
public:
  PathMatcher() = default;
  virtual ~PathMatcher() = default;

  /**
   * Returns true if path matches the pattern.
   *
   * @param path the path to be matched
   * @return true if path matches the pattern.
   */
  virtual bool match(absl::string_view path) const PURE;

  /**
   * @return the match uri_template.
   */
  virtual absl::string_view uriTemplate() const PURE;

  /**
   * @return the name of the path matcher.
   */
  virtual absl::string_view name() const PURE;
};

using PathMatcherSharedPtr = std::shared_ptr<PathMatcher>;

/**
 * Factory for PathMatcher.
 */
class PathMatcherFactory : public Envoy::Config::TypedFactory {
public:
  ~PathMatcherFactory() override = default;

  /**
   * @param config contains the proto stored in TypedExtensionConfig.
   * @return an PathMatcherSharedPtr.
   */
  virtual absl::StatusOr<PathMatcherSharedPtr>
  createPathMatcher(const Protobuf::Message& config) PURE;

  ProtobufTypes::MessagePtr createEmptyConfigProto() override PURE;

  /**
   * @return the name of the path matcher to be created.
   */
  std::string name() const override PURE;

  /**
   * @return the category of the path matcher to be created.
   */
  std::string category() const override { return "envoy.path.match"; }
};

} // namespace Router
} // namespace Envoy
#pragma once

#include <memory>
#include <string>

#include "envoy/config/route/v3/route.pb.h"
#include "envoy/event/dispatcher.h"
#include "envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h"
#include "envoy/json/json_object.h"
#include "envoy/local_info/local_info.h"
#include "envoy/router/rds.h"
#include "envoy/runtime/runtime.h"
#include "envoy/server/filter_config.h"
#include "envoy/thread_local/thread_local.h"
#include "envoy/upstream/cluster_manager.h"

namespace Envoy {
namespace Router {

/**
 * The RouteConfigProviderManager exposes the ability to get a RouteConfigProvider. This interface
 * is exposed to the Server's FactoryContext in order to allow HttpConnectionManagers to get
 * RouteConfigProviders.
 */
class RouteConfigProviderManager {
public:
  virtual ~RouteConfigProviderManager() = default;

  /**
   * Get a RouteConfigProviderPtr for a route from RDS. Ownership of the RouteConfigProvider is the
   * HttpConnectionManagers who calls this function. The RouteConfigProviderManager holds raw
   * pointers to the RouteConfigProviders. Clean up of the pointers happen from the destructor of
   * the RouteConfigProvider. This method creates a RouteConfigProvider which may share the
   * underlying RDS subscription with the same (route_config_name, cluster).
   * @param rds supplies the proto configuration of an RDS-configured RouteConfigProvider.
   * @param factory_context is the context to use for the route config provider.
   * @param stat_prefix supplies the stat_prefix to use for the provider stats.
   * @param init_manager the Init::Manager used to coordinate initialization of a the underlying RDS
   * subscription.
   */
  virtual RouteConfigProviderSharedPtr createRdsRouteConfigProvider(
      const envoy::extensions::filters::network::http_connection_manager::v3::Rds& rds,
      Server::Configuration::ServerFactoryContext& factory_context, const std::string& stat_prefix,
      Init::Manager& init_manager) PURE;

  /**
   * Get a RouteConfigSharedPtr for a statically defined route. Ownership is as described for
   * getRdsRouteConfigProvider above. This method always create a new RouteConfigProvider.
   * @param route_config supplies the RouteConfiguration for this route
   * @param factory_context is the context to use for the route config provider.
   * @param validator is the message validator for route config.
   */
  virtual RouteConfigProviderPtr
  createStaticRouteConfigProvider(const envoy::config::route::v3::RouteConfiguration& route_config,
                                  Server::Configuration::ServerFactoryContext& factory_context,
                                  ProtobufMessage::ValidationVisitor& validator) PURE;
};

using RouteConfigProviderManagerPtr = std::unique_ptr<RouteConfigProviderManager>;
using RouteConfigProviderManagerSharedPtr = std::shared_ptr<RouteConfigProviderManager>;

} // namespace Router
} // namespace Envoy
#pragma once

#include "envoy/config/typed_config.h"
#include "envoy/stream_info/filter_state.h"

#include "source/common/common/logger.h"

#include "absl/strings/string_view.h"

namespace Envoy {
namespace Router {

/**
 * Used to decide if an internal redirect is allowed to be followed based on the target route.
 * Subclassing Logger::Loggable so that implementations can log details.
 */
class InternalRedirectPredicate : Logger::Loggable<Logger::Id::router> {
public:
  virtual ~InternalRedirectPredicate() = default;

  /**
   * A FilterState is provided so that predicate implementation can use it to preserve state across
   * internal redirects.
   * @param filter_state supplies the filter state associated with the current request so that the
   *        predicates can use it to persist states across filter chains.
   * @param target_route_name indicates the route that an internal redirect is targeting.
   * @param downstream_is_https indicates the downstream request is using https.
   * @param target_is_https indicates the internal redirect target url has https in the url.
   * @return whether the route specified by target_route_name is allowed to be followed. Any
   *         predicate returning false will prevent the redirect from being followed, causing the
   *         response to be proxied downstream.
   */
  virtual bool acceptTargetRoute(StreamInfo::FilterState& filter_state,
                                 absl::string_view target_route_name, bool downstream_is_https,
                                 bool target_is_https) PURE;

  /**
   * @return the name of the current predicate.
   */
  virtual absl::string_view name() const PURE;
};

using InternalRedirectPredicateSharedPtr = std::shared_ptr<InternalRedirectPredicate>;

/**
 * Factory for InternalRedirectPredicate.
 */
class InternalRedirectPredicateFactory : public Config::TypedFactory {
public:
  ~InternalRedirectPredicateFactory() override = default;

  /**
   * @param config contains the proto stored in TypedExtensionConfig.typed_config for the predicate.
   * @param current_route_name stores the route name of the route where the predicate is installed.
   * @return an InternalRedirectPredicate. The given current_route_name is useful for predicates
   *         that need to create per-route FilterState.
   */
  virtual InternalRedirectPredicateSharedPtr
  createInternalRedirectPredicate(const Protobuf::Message& config,
                                  absl::string_view current_route_name) PURE;

  std::string category() const override { return "envoy.internal_redirect_predicates"; }
};

} // namespace Router
} // namespace Envoy
#pragma once

#include "envoy/common/pure.h"
#include "envoy/router/router.h"

namespace Envoy {
namespace Router {

struct StatNames;
struct VirtualClusterStatNames;
struct RouteStatNames;

class Context {
public:
  virtual ~Context() = default;

  /**
   * @return a struct containing StatNames for router stats.
   */
  virtual const StatNames& statNames() const PURE;

  /**
   * @return a struct containing StatNames for virtual cluster stats.
   */
  virtual const VirtualClusterStatNames& virtualClusterStatNames() const PURE;

  /**
   * @return a struct containing StatNames for route level stats.
   */
  virtual const RouteStatNames& routeStatNames() const PURE;

  /**
   * @return a reference to the default generic connection pool factory.
   */
  virtual GenericConnPoolFactory& genericConnPoolFactory() PURE;
};

/**
 * RouteStatsContext defines config needed to generate all route level stats.
 */
class RouteStatsContext {
public:
  virtual ~RouteStatsContext() = default;

  /**
   * @return stat name for route specific stats.
   */
  virtual Stats::StatName statName() const PURE;

  /**
   * @return a struct containing stats for route stats.
   */
  virtual const RouteStats& stats() const PURE;
};

} // namespace Router
} // namespace Envoy
#pragma once

#include <memory>

#include "envoy/common/pure.h"
#include "envoy/common/time.h"
#include "envoy/config/route/v3/route.pb.h"
#include "envoy/rds/route_config_update_receiver.h"
#include "envoy/service/discovery/v3/discovery.pb.h"

#include "source/common/protobuf/protobuf.h"

#include "absl/types/optional.h"

namespace Envoy {
namespace Router {

/**
 * A primitive that keeps track of updates to a RouteConfiguration.
 */
class RouteConfigUpdateReceiver : public Rds::RouteConfigUpdateReceiver {
public:
  /**
   * Same purpose as Rds::RouteConfigUpdateReceiver::protobufConfiguration()
   * but the return is downcasted to proper type.
   * @return current RouteConfiguration downcasted from Protobuf::Message&
   */
  virtual const envoy::config::route::v3::RouteConfiguration&
  protobufConfigurationCast() const PURE;

  using VirtualHostRefVector =
      std::vector<std::reference_wrapper<const envoy::config::route::v3::VirtualHost>>;

  /**
   * Called on updates via VHDS.
   * @param added_vhosts supplies VirtualHosts that have been added.
   * @param added_resource_ids set of resources IDs (names + aliases) added.
   * @param removed_resources supplies names of VirtualHosts that have been removed.
   * @param version_info supplies RouteConfiguration version.
   * @return bool whether RouteConfiguration has been updated.
   */
  virtual bool onVhdsUpdate(const VirtualHostRefVector& added_vhosts,
                            const std::set<std::string>& added_resource_ids,
                            const Protobuf::RepeatedPtrField<std::string>& removed_resources,
                            const std::string& version_info) PURE;

  /**
   * @return bool return whether VHDS configuration has been changed in the last RDS update.
   */
  // TODO(dmitri-d): Consider splitting RouteConfigUpdateReceiver into a RouteConfig state and a
  // last update state. The latter could be passed to callbacks as a parameter, which would make the
  // intent and the lifecycle of the "last update state" less muddled.
  virtual bool vhdsConfigurationChanged() const PURE;

  /**
   * @return the union of all resource names and aliases (if any) received with the last VHDS
   * update.
   */
  virtual const std::set<std::string>& resourceIdsInLastVhdsUpdate() PURE;
};

using RouteConfigUpdatePtr = std::unique_ptr<RouteConfigUpdateReceiver>;
} // namespace Router
} // namespace Envoy
#pragma once

#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#include "envoy/config/core/v3/base.pb.h"
#include "envoy/http/filter.h"
#include "envoy/ratelimit/ratelimit.h"

namespace Envoy {
namespace Router {

/**
 * Base interface for generic rate limit override action.
 */
class RateLimitOverrideAction {
public:
  virtual ~RateLimitOverrideAction() = default;

  /**
   * Potentially populate the descriptors 'limit' property with a RateLimitOverride instance
   * @param descriptor supplies the descriptor to optionally fill.
   * @param metadata supplies the dynamic metadata for the request.
   * @return true if RateLimitOverride was set in the descriptor.
   */
  virtual bool populateOverride(RateLimit::Descriptor& descriptor,
                                const envoy::config::core::v3::Metadata* metadata) const PURE;
};

using RateLimitOverrideActionPtr = std::unique_ptr<RateLimitOverrideAction>;

/**
 * Rate limit configuration.
 */
class RateLimitPolicyEntry {
public:
  virtual ~RateLimitPolicyEntry() = default;

  /**
   * @return the stage value that the configuration is applicable to.
   */
  virtual uint64_t stage() const PURE;

  /**
   * @return runtime key to be set to disable the configuration.
   */
  virtual const std::string& disableKey() const PURE;

  /**
   * Potentially populate the descriptor array with new descriptors to query.
   * @param descriptors supplies the descriptor array to optionally fill.
   * @param local_service_cluster supplies the name of the local service cluster.
   * @param headers supplies the header for the request.
   * @param info stream info associated with the request
   */
  virtual void populateDescriptors(std::vector<RateLimit::Descriptor>& descriptors,
                                   const std::string& local_service_cluster,
                                   const Http::RequestHeaderMap& headers,
                                   const StreamInfo::StreamInfo& info) const PURE;

  /**
   * Potentially populate the local descriptor array with new descriptors to query.
   * @param descriptors supplies the descriptor array to optionally fill.
   * @param local_service_cluster supplies the name of the local service cluster.
   * @param headers supplies the header for the request.
   * @param info stream info associated with the request
   */
  virtual void populateLocalDescriptors(std::vector<RateLimit::LocalDescriptor>& descriptors,
                                        const std::string& local_service_cluster,
                                        const Http::RequestHeaderMap& headers,
                                        const StreamInfo::StreamInfo& info) const PURE;
};

/**
 * Rate limiting policy.
 */
class RateLimitPolicy {
public:
  virtual ~RateLimitPolicy() = default;

  /**
   * @return true if there is no rate limit policy for all stage settings.
   */
  virtual bool empty() const PURE;

  /**
   * @param stage the value for finding applicable rate limit configurations.
   * @return set of RateLimitPolicyEntry that are applicable for a stage.
   */
  virtual const std::vector<std::reference_wrapper<const RateLimitPolicyEntry>>&
  getApplicableRateLimit(uint64_t stage) const PURE;
};

} // namespace Router
} // namespace Envoy
#pragma once

#include <memory>

#include "envoy/config/route/v3/route.pb.h"
#include "envoy/http/filter.h"
#include "envoy/rds/route_config_provider.h"
#include "envoy/router/router.h"

namespace Envoy {
namespace Router {

/**
 * A provider for constant route configurations.
 */
class RouteConfigProvider : public Rds::RouteConfigProvider {
public:
  /**
   * Same purpose as Rds::RouteConfigProvider::config()
   * but the return is downcasted to proper type.
   * @return downcasted ConfigConstSharedPtr from Rds::ConfigConstSharedPtr
   */
  virtual ConfigConstSharedPtr configCast() const PURE;

  /**
   * Callback used to request an update to the route configuration from the management server.
   * @param for_domain supplies the domain name that virtual hosts must match on
   * @param thread_local_dispatcher thread-local dispatcher
   * @param route_config_updated_cb callback to be called when the configuration update has been
   * propagated to worker threads
   */
  virtual void requestVirtualHostsUpdate(
      const std::string& for_domain, Event::Dispatcher& thread_local_dispatcher,
      std::weak_ptr<Http::RouteConfigUpdatedCallback> route_config_updated_cb) PURE;
};

using RouteConfigProviderPtr = std::unique_ptr<RouteConfigProvider>;
using RouteConfigProviderSharedPtr = std::shared_ptr<RouteConfigProvider>;

} // namespace Router
} // namespace Envoy
#pragma once

#include <memory>

#include "envoy/config/config_provider.h"
#include "envoy/router/router.h"

namespace Envoy {
namespace Router {

/**
 * Scope key fragment base class.
 */
class ScopeKeyFragmentBase {
public:
  bool operator!=(const ScopeKeyFragmentBase& other) const { return !(*this == other); }

  bool operator==(const ScopeKeyFragmentBase& other) const {
    if (typeid(*this) == typeid(other)) {
      return hash() == other.hash();
    }
    return false;
  }
  virtual ~ScopeKeyFragmentBase() = default;

  // Hash of the fragment.
  virtual uint64_t hash() const PURE;
};

/**
 *  Scope Key is composed of non-null fragments.
 **/
class ScopeKey {
public:
  ScopeKey() = default;
  ScopeKey(ScopeKey&& other) = default;

  // Scopekey is not copy-assignable and copy-constructible as it contains unique_ptr inside itself.
  ScopeKey(const ScopeKey&) = delete;
  ScopeKey operator=(const ScopeKey&) = delete;

  // Caller should guarantee the fragment is not nullptr.
  void addFragment(std::unique_ptr<ScopeKeyFragmentBase>&& fragment) {
    ASSERT(fragment != nullptr, "null fragment not allowed in ScopeKey.");
    updateHash(*fragment);
    fragments_.emplace_back(std::move(fragment));
  }

  uint64_t hash() const { return hash_; }
  bool operator!=(const ScopeKey& other) const;
  bool operator==(const ScopeKey& other) const;

private:
  // Update the key's hash with the new fragment hash.
  void updateHash(const ScopeKeyFragmentBase& fragment) {
    std::stringbuf buffer;
    buffer.sputn(reinterpret_cast<const char*>(&hash_), sizeof(hash_));
    const auto& fragment_hash = fragment.hash();
    buffer.sputn(reinterpret_cast<const char*>(&fragment_hash), sizeof(fragment_hash));
    hash_ = HashUtil::xxHash64(buffer.str());
  }

  uint64_t hash_{0};
  std::vector<std::unique_ptr<ScopeKeyFragmentBase>> fragments_;
};

using ScopeKeyPtr = std::unique_ptr<ScopeKey>;

// String fragment.
class StringKeyFragment : public ScopeKeyFragmentBase {
public:
  explicit StringKeyFragment(absl::string_view value)
      : value_(value), hash_(HashUtil::xxHash64(value_)) {}

  uint64_t hash() const override { return hash_; }

private:
  const std::string value_;
  const uint64_t hash_;
};

/**
 * The scoped key builder.
 */
class ScopeKeyBuilder {
public:
  virtual ~ScopeKeyBuilder() = default;

  /**
   * Based on the incoming HTTP request headers, returns the hash value of its scope key.
   * @param headers the request headers to match the scoped routing configuration against.
   * @return unique_ptr of the scope key computed from header.
   */
  virtual ScopeKeyPtr computeScopeKey(const Http::HeaderMap&) const PURE;
};

/**
 * The scoped routing configuration.
 */
class ScopedConfig : public Envoy::Config::ConfigProvider::Config {
public:
  ~ScopedConfig() override = default;

  /**
   * Based on the scope key, returns the configuration to use for selecting a target route.
   * The scope key can be got via ScopeKeyBuilder.
   *
   * @param scope_key the scope key. null config will be returned when null.
   * @return ConfigConstSharedPtr the router's Config matching the request headers.
   */
  virtual ConfigConstSharedPtr getRouteConfig(const ScopeKeyPtr& scope_key) const PURE;
};

using ScopedConfigConstSharedPtr = std::shared_ptr<const ScopedConfig>;
using ScopeKeyBuilderPtr = std::unique_ptr<const ScopeKeyBuilder>;

} // namespace Router
} // namespace Envoy
#pragma once

#include <functional>
#include <memory>
#include <string>

#include "envoy/common/pure.h"
#include "envoy/config/typed_config.h"
#include "envoy/router/router.h"
#include "envoy/server/factory_context.h"

namespace Envoy {
namespace Router {

/**
 * Interface class for creating cluster specifier plugin from related route entry.
 */
class ClusterSpecifierPlugin {
public:
  virtual ~ClusterSpecifierPlugin() = default;

  /**
   * Create route from related route entry and request headers.
   *
   * @param parent related route.
   * @param header request headers.
   * @return RouteConstSharedPtr final route with specific cluster.
   */
  virtual RouteConstSharedPtr route(RouteConstSharedPtr parent,
                                    const Http::RequestHeaderMap& header) const PURE;
};

using ClusterSpecifierPluginSharedPtr = std::shared_ptr<ClusterSpecifierPlugin>;

/*
 * Extension configuration for cluster specifier plugin factory.
 */
class ClusterSpecifierPluginFactoryConfig : public Envoy::Config::TypedFactory {
public:
  /**
   * Creates a particular cluster specifier plugin factory implementation.
   *
   * @param config supplies the configuration for the cluster specifier plugin factory extension.
   * @return ClusterSpecifierPluginSharedPtr cluster specifier plugin use to create final route from
   * request headers.
   */
  virtual ClusterSpecifierPluginSharedPtr
  createClusterSpecifierPlugin(const Protobuf::Message& config,
                               Server::Configuration::CommonFactoryContext& context) PURE;

  std::string category() const override { return "envoy.router.cluster_specifier_plugin"; }
};

using ClusterSpecifierPluginFactoryConfigPtr = std::unique_ptr<ClusterSpecifierPluginFactoryConfig>;

} // namespace Router
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_package",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "context_interface",
    hdrs = ["context.h"],
    deps = [
        ":router_interface",
    ],
)

envoy_cc_library(
    name = "rds_interface",
    hdrs = ["rds.h"],
    deps = [
        ":router_interface",
        "//envoy/http:filter_interface",
        "//envoy/rds:rds_interface",
        "@envoy_api//envoy/config/route/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "route_config_provider_manager_interface",
    hdrs = ["route_config_provider_manager.h"],
    deps = [
        ":rds_interface",
        "//envoy/event:dispatcher_interface",
        "//envoy/json:json_object_interface",
        "//envoy/local_info:local_info_interface",
        "//envoy/runtime:runtime_interface",
        "//envoy/server:filter_config_interface",
        "//envoy/stats:stats_interface",
        "//envoy/thread_local:thread_local_interface",
        "//envoy/upstream:cluster_manager_interface",
        "@envoy_api//envoy/config/route/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/filters/network/http_connection_manager/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "route_config_update_info_interface",
    hdrs = ["route_config_update_receiver.h"],
    external_deps = ["abseil_optional"],
    deps = [
        ":rds_interface",
        "//envoy/common:time_interface",
        "//source/common/protobuf",
        "@envoy_api//envoy/config/route/v3:pkg_cc_proto",
        "@envoy_api//envoy/service/discovery/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "router_filter_interface",
    hdrs = ["router_filter_interface.h"],
    external_deps = ["abseil_optional"],
    deps = [
        "//envoy/http:filter_interface",
        "//envoy/http:header_map_interface",
        "//envoy/stats:stats_interface",
        "//envoy/stream_info:stream_info_interface",
        "//envoy/upstream:cluster_manager_interface",
        "//envoy/upstream:host_description_interface",
    ],
)

envoy_cc_library(
    name = "router_interface",
    hdrs = ["router.h"],
    external_deps = ["abseil_optional"],
    deps = [
        ":internal_redirect_interface",
        ":path_matcher_interface",
        ":path_rewriter_interface",
        "//envoy/access_log:access_log_interface",
        "//envoy/common:conn_pool_interface",
        "//envoy/common:matchers_interface",
        "//envoy/common:time_interface",
        "//envoy/config:typed_metadata_interface",
        "//envoy/http:codec_interface",
        "//envoy/http:codes_interface",
        "//envoy/http:conn_pool_interface",
        "//envoy/http:hash_policy_interface",
        "//envoy/http:header_map_interface",
        "//envoy/rds:rds_config_interface",
        "//envoy/tcp:conn_pool_interface",
        "//envoy/tracing:tracer_interface",
        "//envoy/upstream:resource_manager_interface",
        "//envoy/upstream:retry_interface",
        "//source/common/protobuf",
        "//source/common/protobuf:utility_lib",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/route/v3:pkg_cc_proto",
        "@envoy_api//envoy/type/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "scopes_interface",
    hdrs = ["scopes.h"],
    deps = [
        ":router_interface",
        "//envoy/config:config_provider_interface",
        "//envoy/http:header_map_interface",
    ],
)

envoy_cc_library(
    name = "router_ratelimit_interface",
    hdrs = ["router_ratelimit.h"],
    deps = [
        "//envoy/http:filter_interface",
        "//envoy/ratelimit:ratelimit_interface",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "shadow_writer_interface",
    hdrs = ["shadow_writer.h"],
    deps = [
        "//envoy/http:async_client_interface",
        "//envoy/http:message_interface",
    ],
)

envoy_cc_library(
    name = "string_accessor_interface",
    hdrs = ["string_accessor.h"],
    external_deps = ["abseil_optional"],
    deps = [
        "//envoy/stream_info:filter_state_interface",
    ],
)

envoy_cc_library(
    name = "internal_redirect_interface",
    hdrs = ["internal_redirect.h"],
    deps = [
        "//envoy/config:typed_config_interface",
        "//envoy/stream_info:filter_state_interface",
        "//source/common/common:minimal_logger_lib",
    ],
)

envoy_cc_library(
    name = "cluster_specifier_plugin_interface",
    hdrs = ["cluster_specifier_plugin.h"],
    deps = [
        ":router_interface",
        "//envoy/config:typed_config_interface",
        "//envoy/server:factory_context_interface",
    ],
)

envoy_cc_library(
    name = "path_matcher_interface",
    hdrs = ["path_matcher.h"],
    deps = [
        "//envoy/config:typed_config_interface",
        "//source/common/common:minimal_logger_lib",
        "@com_google_absl//absl/status",
        "@com_google_absl//absl/status:statusor",
    ],
)

envoy_cc_library(
    name = "path_rewriter_interface",
    hdrs = ["path_rewriter.h"],
    deps = [
        "//envoy/config:typed_config_interface",
        "//source/common/common:minimal_logger_lib",
        "@com_google_absl//absl/status",
        "@com_google_absl//absl/status:statusor",
    ],
)
#pragma once

#include <chrono>
#include <cstdint>
#include <functional>
#include <list>
#include <map>
#include <memory>
#include <string>

#include "envoy/access_log/access_log.h"
#include "envoy/common/conn_pool.h"
#include "envoy/common/matchers.h"
#include "envoy/config/core/v3/base.pb.h"
#include "envoy/config/route/v3/route_components.pb.h"
#include "envoy/config/typed_metadata.h"
#include "envoy/http/codec.h"
#include "envoy/http/codes.h"
#include "envoy/http/conn_pool.h"
#include "envoy/http/hash_policy.h"
#include "envoy/rds/config.h"
#include "envoy/router/internal_redirect.h"
#include "envoy/router/path_matcher.h"
#include "envoy/router/path_rewriter.h"
#include "envoy/tcp/conn_pool.h"
#include "envoy/tracing/tracer.h"
#include "envoy/type/v3/percent.pb.h"
#include "envoy/upstream/resource_manager.h"
#include "envoy/upstream/retry.h"

#include "source/common/protobuf/protobuf.h"
#include "source/common/protobuf/utility.h"

#include "absl/types/optional.h"

namespace Envoy {

namespace Upstream {
class ClusterManager;
class LoadBalancerContext;
class ThreadLocalCluster;
} // namespace Upstream

namespace Router {

/**
 * Functionality common among routing primitives, such as DirectResponseEntry and RouteEntry.
 */
class ResponseEntry {
public:
  virtual ~ResponseEntry() = default;

  /**
   * Do potentially destructive header transforms on response headers prior to forwarding. For
   * example, adding or removing headers. This should only be called ONCE immediately after
   * obtaining the initial response headers.
   * @param headers supplies the response headers, which may be modified during this call.
   * @param stream_info holds additional information about the request.
   */
  virtual void finalizeResponseHeaders(Http::ResponseHeaderMap& headers,
                                       const StreamInfo::StreamInfo& stream_info) const PURE;

  /**
   * Returns the response header transforms that would be applied if finalizeResponseHeaders were
   * called now. This is useful if you want to obtain response header transforms at request time and
   * process them later. Note: do not use unless you are sure that there will be no route
   * modifications later in the filter chain.
   * @param stream_info holds additional information about the request.
   * @param do_formatting whether or not to evaluate configured transformations; if false, returns
   * original values instead.
   */
  virtual Http::HeaderTransforms responseHeaderTransforms(const StreamInfo::StreamInfo& stream_info,
                                                          bool do_formatting = true) const PURE;
};

/**
 * A routing primitive that specifies a direct (non-proxied) HTTP response.
 */
class DirectResponseEntry : public ResponseEntry {
public:
  ~DirectResponseEntry() override = default;

  /**
   * Returns the HTTP status code to return.
   * @return Http::Code the response Code.
   */
  virtual Http::Code responseCode() const PURE;

  /**
   * Returns the redirect URI based on the request headers.
   * @param headers supplies the request headers.
   * @return std::string the redirect URL if this DirectResponseEntry is a redirect,
   *         or an empty string otherwise.
   */
  virtual std::string newUri(const Http::RequestHeaderMap& headers) const PURE;

  /**
   * Returns the response body to send with direct responses.
   * @return std::string& the response body specified in the route configuration,
   *         or an empty string if no response body is specified.
   */
  virtual const std::string& responseBody() const PURE;

  /**
   * Do potentially destructive header transforms on Path header prior to redirection. For
   * example prefix rewriting for redirects etc. This should only be called ONCE
   * immediately prior to redirecting.
   * @param headers supplies the request headers, which may be modified during this call.
   * @param insert_envoy_original_path insert x-envoy-original-path header?
   */
  virtual void rewritePathHeader(Http::RequestHeaderMap& headers,
                                 bool insert_envoy_original_path) const PURE;
};

/**
 * All route specific config returned by the method at
 *   NamedHttpFilterConfigFactory::createRouteSpecificFilterConfig
 * should be derived from this class.
 */
class RouteSpecificFilterConfig {
public:
  virtual ~RouteSpecificFilterConfig() = default;
};
using RouteSpecificFilterConfigConstSharedPtr = std::shared_ptr<const RouteSpecificFilterConfig>;

/**
 * CorsPolicy for Route and VirtualHost.
 */
class CorsPolicy : public RouteSpecificFilterConfig {
public:
  /**
   * @return std::vector<StringMatcherPtr>& access-control-allow-origin matchers.
   */
  virtual const std::vector<Matchers::StringMatcherPtr>& allowOrigins() const PURE;

  /**
   * @return std::string access-control-allow-methods value.
   */
  virtual const std::string& allowMethods() const PURE;

  /**
   * @return std::string access-control-allow-headers value.
   */
  virtual const std::string& allowHeaders() const PURE;

  /**
   * @return std::string access-control-expose-headers value.
   */
  virtual const std::string& exposeHeaders() const PURE;

  /**
   * @return std::string access-control-max-age value.
   */
  virtual const std::string& maxAge() const PURE;

  /**
   * @return const absl::optional<bool>& Whether access-control-allow-credentials should be true.
   */
  virtual const absl::optional<bool>& allowCredentials() const PURE;

  /**
   * @return const absl::optional<bool>& How to handle access-control-request-private-network.
   */
  virtual const absl::optional<bool>& allowPrivateNetworkAccess() const PURE;

  /**
   * @return bool Whether CORS is enabled for the route or virtual host.
   */
  virtual bool enabled() const PURE;

  /**
   * @return bool Whether CORS policies are evaluated when filter is off.
   */
  virtual bool shadowEnabled() const PURE;
};

/**
 * An interface to be implemented by rate limited reset header parsers.
 */
class ResetHeaderParser {
public:
  virtual ~ResetHeaderParser() = default;

  /**
   * Iterate over the headers, choose the first one that matches by name, and try to parse its
   * value.
   */
  virtual absl::optional<std::chrono::milliseconds>
  parseInterval(TimeSource& time_source, const Http::HeaderMap& headers) const PURE;
};

using ResetHeaderParserSharedPtr = std::shared_ptr<ResetHeaderParser>;

/**
 * Route level retry policy.
 */
class RetryPolicy {
public:
  // clang-format off
  static constexpr uint32_t RETRY_ON_5XX                                = 0x1;
  static constexpr uint32_t RETRY_ON_GATEWAY_ERROR                      = 0x2;
  static constexpr uint32_t RETRY_ON_CONNECT_FAILURE                    = 0x4;
  static constexpr uint32_t RETRY_ON_RETRIABLE_4XX                      = 0x8;
  static constexpr uint32_t RETRY_ON_REFUSED_STREAM                     = 0x10;
  static constexpr uint32_t RETRY_ON_GRPC_CANCELLED                     = 0x20;
  static constexpr uint32_t RETRY_ON_GRPC_DEADLINE_EXCEEDED             = 0x40;
  static constexpr uint32_t RETRY_ON_GRPC_RESOURCE_EXHAUSTED            = 0x80;
  static constexpr uint32_t RETRY_ON_GRPC_UNAVAILABLE                   = 0x100;
  static constexpr uint32_t RETRY_ON_GRPC_INTERNAL                      = 0x200;
  static constexpr uint32_t RETRY_ON_RETRIABLE_STATUS_CODES             = 0x400;
  static constexpr uint32_t RETRY_ON_RESET                              = 0x800;
  static constexpr uint32_t RETRY_ON_RETRIABLE_HEADERS                  = 0x1000;
  static constexpr uint32_t RETRY_ON_ENVOY_RATE_LIMITED                 = 0x2000;
  static constexpr uint32_t RETRY_ON_HTTP3_POST_CONNECT_FAILURE         = 0x4000;
  // clang-format on

  virtual ~RetryPolicy() = default;

  /**
   * @return std::chrono::milliseconds timeout per retry attempt. 0 is disabled.
   */
  virtual std::chrono::milliseconds perTryTimeout() const PURE;

  /**
   * @return std::chrono::milliseconds the optional per try idle timeout. 0 is disabled.
   */
  virtual std::chrono::milliseconds perTryIdleTimeout() const PURE;

  /**
   * @return uint32_t the number of retries to allow against the route.
   */
  virtual uint32_t numRetries() const PURE;

  /**
   * @return uint32_t a local OR of RETRY_ON values above.
   */
  virtual uint32_t retryOn() const PURE;

  /**
   * Initializes a new set of RetryHostPredicates to be used when retrying with this retry policy.
   * @return list of RetryHostPredicates to use
   */
  virtual std::vector<Upstream::RetryHostPredicateSharedPtr> retryHostPredicates() const PURE;

  /**
   * Initializes a RetryPriority to be used when retrying with this retry policy.
   * @return the RetryPriority to use when determining priority load for retries, or nullptr
   * if none should be used.
   */
  virtual Upstream::RetryPrioritySharedPtr retryPriority() const PURE;

  /**
   * @return the retry options predicates for this policy. Each policy will be applied prior
   * to retrying a request, allowing for request behavior to be customized.
   */
  virtual absl::Span<const Upstream::RetryOptionsPredicateConstSharedPtr>
  retryOptionsPredicates() const PURE;

  /**
   * Number of times host selection should be reattempted when selecting a host
   * for a retry attempt.
   */
  virtual uint32_t hostSelectionMaxAttempts() const PURE;

  /**
   * List of status codes that should trigger a retry when the retriable-status-codes retry
   * policy is enabled.
   */
  virtual const std::vector<uint32_t>& retriableStatusCodes() const PURE;

  /**
   * @return std::vector<Http::HeaderMatcherSharedPtr>& list of response header matchers that
   * will be checked when the 'retriable-headers' retry policy is enabled.
   */
  virtual const std::vector<Http::HeaderMatcherSharedPtr>& retriableHeaders() const PURE;

  /**
   * @return std::vector<Http::HeaderMatcherSharedPt>& list of request header
   * matchers that will be checked before enabling retries.
   */
  virtual const std::vector<Http::HeaderMatcherSharedPtr>& retriableRequestHeaders() const PURE;

  /**
   * @return absl::optional<std::chrono::milliseconds> base retry interval
   */
  virtual absl::optional<std::chrono::milliseconds> baseInterval() const PURE;

  /**
   * @return absl::optional<std::chrono::milliseconds> maximum retry interval
   */
  virtual absl::optional<std::chrono::milliseconds> maxInterval() const PURE;

  /**
   * @return std::vector<Http::ResetHeaderParserSharedPtr>& list of reset header
   * parsers that will be used to extract a retry back-off interval from response headers.
   */
  virtual const std::vector<ResetHeaderParserSharedPtr>& resetHeaders() const PURE;

  /**
   * @return std::chrono::milliseconds upper limit placed on a retry
   * back-off interval parsed from response headers.
   */
  virtual std::chrono::milliseconds resetMaxInterval() const PURE;
};

/**
 * RetryStatus whether request should be retried or not.
 */
enum class RetryStatus { No, NoOverflow, NoRetryLimitExceeded, Yes };

/**
 * InternalRedirectPolicy from the route configuration.
 */
class InternalRedirectPolicy {
public:
  virtual ~InternalRedirectPolicy() = default;

  /**
   * @return whether internal redirect is enabled on this route.
   */
  virtual bool enabled() const PURE;

  /**
   * @param response_code the response code from the upstream.
   * @return whether the given response_code should trigger an internal redirect on this route.
   */
  virtual bool shouldRedirectForResponseCode(const Http::Code& response_code) const PURE;

  /**
   * Creates the target route predicates. This should really be called only once for each upstream
   * redirect response. Creating the predicates lazily to avoid wasting CPU cycles on non-redirect
   * responses, which should be the most common case.
   * @return a vector of newly constructed InternalRedirectPredicate instances.
   */
  virtual std::vector<InternalRedirectPredicateSharedPtr> predicates() const PURE;

  /**
   * @return a vector of response header names to preserve in the redirected request.
   */
  virtual const std::vector<Http::LowerCaseString>& responseHeadersToCopy() const PURE;

  /**
   * @return the maximum number of allowed internal redirects on this route.
   */
  virtual uint32_t maxInternalRedirects() const PURE;

  /**
   * @return if it is allowed to follow the redirect with a different scheme in
   *         the target URI than the downstream request.
   */
  virtual bool isCrossSchemeRedirectAllowed() const PURE;
};

/**
 * Wraps retry state for an active routed request.
 */
class RetryState {
public:
  enum class RetryDecision {
    // Retry the request immediately.
    RetryImmediately,
    // Retry the request with timed backoff delay.
    RetryWithBackoff,
    // Do not retry.
    NoRetry,
  };

  enum class Http3Used {
    Unknown,
    Yes,
    No,
  };

  using DoRetryCallback = std::function<void()>;
  /**
   * @param disabled_http3 indicates whether the retry should disable http3 or not.
   */
  using DoRetryResetCallback = std::function<void(bool disable_http3)>;
  /**
   * @param disable_early_data indicates whether the retry should disable early data or not.
   */
  using DoRetryHeaderCallback = std::function<void(bool disable_early_data)>;

  virtual ~RetryState() = default;

  /**
   * @return true if a policy is in place for the active request that allows retries.
   */
  virtual bool enabled() PURE;

  /**
   * Attempts to parse any matching rate limited reset headers (RFC 7231), either in the form of an
   * interval directly, or in the form of a unix timestamp relative to the current system time.
   * @return the interval if parsing was successful.
   */
  virtual absl::optional<std::chrono::milliseconds>
  parseResetInterval(const Http::ResponseHeaderMap& response_headers) const PURE;

  /**
   * Determine whether a request should be retried based on the response headers.
   * @param response_headers supplies the response headers.
   * @param original_request supplies the original request headers.
   * @param callback supplies the callback that will be invoked when the retry should take place.
   *                 This is used to add timed backoff, etc. The callback will never be called
   *                 inline.
   * @return RetryStatus if a retry should take place. @param callback will be called at some point
   *         in the future. Otherwise a retry should not take place and the callback will never be
   *         called. Calling code should proceed with error handling.
   */
  virtual RetryStatus shouldRetryHeaders(const Http::ResponseHeaderMap& response_headers,
                                         const Http::RequestHeaderMap& original_request,
                                         DoRetryHeaderCallback callback) PURE;

  /**
   * Determines whether given response headers would be retried by the retry policy, assuming
   * sufficient retry budget and circuit breaker headroom. This is useful in cases where
   * the information about whether a response is "good" or not is useful, but a retry should
   * not be attempted for other reasons.
   * @param response_headers supplies the response headers.
   * @param original_request supplies the original request headers.
   * @param retry_as_early_data output argument to tell the caller if a retry should be sent as
   *        early data if it is warranted.
   * @return RetryDecision if a retry would be warranted based on the retry policy and if it would
   *         be warranted with timed backoff.
   */
  virtual RetryDecision wouldRetryFromHeaders(const Http::ResponseHeaderMap& response_headers,
                                              const Http::RequestHeaderMap& original_request,
                                              bool& retry_as_early_data) PURE;

  /**
   * Determine whether a request should be retried after a reset based on the reason for the reset.
   * @param reset_reason supplies the reset reason.
   * @param http3_used whether the reset request was sent over http3 as alternate protocol or
   *                   not. nullopt means it wasn't sent at all before getting reset.
   * @param callback supplies the callback that will be invoked when the retry should take place.
   *                 This is used to add timed backoff, etc. The callback will never be called
   * inline.
   * @return RetryStatus if a retry should take place. @param callback will be called at some point
   *         in the future. Otherwise a retry should not take place and the callback will never be
   *         called. Calling code should proceed with error handling.
   */
  virtual RetryStatus shouldRetryReset(Http::StreamResetReason reset_reason, Http3Used http3_used,
                                       DoRetryResetCallback callback) PURE;

  /**
   * Determine whether a "hedged" retry should be sent after the per try
   * timeout expires. This means the original request is not canceled, but a
   * new one is sent to hedge against the original request taking even longer.
   * @param callback supplies the callback that will be invoked when the retry should take place.
   *                 This is used to add timed backoff, etc. The callback will never be called
   * inline.
   * @return RetryStatus if a retry should take place. @param callback will be called at some point
   *         in the future. Otherwise a retry should not take place and the callback will never be
   *         called. Calling code should proceed with error handling.
   */
  virtual RetryStatus shouldHedgeRetryPerTryTimeout(DoRetryCallback callback) PURE;

  /**
   * Called when a host was attempted but the request failed and is eligible for another retry.
   * Should be used to update whatever internal state depends on previously attempted hosts.
   * @param host the previously attempted host.
   */
  virtual void onHostAttempted(Upstream::HostDescriptionConstSharedPtr host) PURE;

  /**
   * Determine whether host selection should be reattempted. Applies to host selection during
   * retries, and is used to provide configurable host selection for retries.
   * @param host the host under consideration
   * @return whether host selection should be reattempted
   */
  virtual bool shouldSelectAnotherHost(const Upstream::Host& host) PURE;

  /**
   * Returns a reference to the PriorityLoad that should be used for the next retry.
   * @param priority_set current priority set.
   * @param original_priority_load original priority load.
   * @param priority_mapping_func see @Upstream::RetryPriority::PriorityMappingFunc.
   * @return HealthyAndDegradedLoad that should be used to select a priority for the next retry.
   */
  virtual const Upstream::HealthyAndDegradedLoad& priorityLoadForRetry(
      const Upstream::PrioritySet& priority_set,
      const Upstream::HealthyAndDegradedLoad& original_priority_load,
      const Upstream::RetryPriority::PriorityMappingFunc& priority_mapping_func) PURE;
  /**
   * return how many times host selection should be reattempted during host selection.
   */
  virtual uint32_t hostSelectionMaxAttempts() const PURE;
};

using RetryStatePtr = std::unique_ptr<RetryState>;

/**
 * Per route policy for request shadowing.
 */
class ShadowPolicy {
public:
  virtual ~ShadowPolicy() = default;

  /**
   * @return the name of the cluster that a matching request should be shadowed to.
   *         Only one of *cluster* and *cluster_header* can be specified. Returns empty
   *         string if no shadowing should take place.
   */
  virtual const std::string& cluster() const PURE;

  /**
   * @return the cluster header name that router can get the cluster name from request headers.
   *         Only one of *cluster* and *cluster_header* can be specified. Returns empty
   *         string if no shadowing should take place.
   */
  virtual const Http::LowerCaseString& clusterHeader() const PURE;

  /**
   * @return the runtime key that will be used to determine whether an individual request should
   *         be shadowed. The lack of a key means that all requests will be shadowed. If a key is
   *         present it will be used to drive random selection in the range 0-10000 for 0.01%
   *         increments.
   */
  virtual const std::string& runtimeKey() const PURE;

  /**
   * @return the default fraction of traffic the should be shadowed, if the runtime key is not
   *         present.
   */
  virtual const envoy::type::v3::FractionalPercent& defaultValue() const PURE;

  /**
   * @return true if the trace span should be sampled.
   */
  virtual bool traceSampled() const PURE;
};

using ShadowPolicyPtr = std::shared_ptr<ShadowPolicy>;

/**
 * All virtual cluster stats. @see stats_macro.h
 */
#define ALL_VIRTUAL_CLUSTER_STATS(COUNTER, GAUGE, HISTOGRAM, TEXT_READOUT, STATNAME)               \
  COUNTER(upstream_rq_retry)                                                                       \
  COUNTER(upstream_rq_retry_limit_exceeded)                                                        \
  COUNTER(upstream_rq_retry_overflow)                                                              \
  COUNTER(upstream_rq_retry_success)                                                               \
  COUNTER(upstream_rq_timeout)                                                                     \
  COUNTER(upstream_rq_total)                                                                       \
  STATNAME(other)                                                                                  \
  STATNAME(vcluster)                                                                               \
  STATNAME(vhost)

/**
 * All route level stats. @see stats_macro.h
 */
#define ALL_ROUTE_STATS(COUNTER, GAUGE, HISTOGRAM, TEXT_READOUT, STATNAME)                         \
  COUNTER(upstream_rq_retry)                                                                       \
  COUNTER(upstream_rq_retry_limit_exceeded)                                                        \
  COUNTER(upstream_rq_retry_overflow)                                                              \
  COUNTER(upstream_rq_retry_success)                                                               \
  COUNTER(upstream_rq_timeout)                                                                     \
  COUNTER(upstream_rq_total)                                                                       \
  STATNAME(route)                                                                                  \
  STATNAME(vhost)

/**
 * Struct definition for all virtual cluster stats. @see stats_macro.h
 */
MAKE_STAT_NAMES_STRUCT(VirtualClusterStatNames, ALL_VIRTUAL_CLUSTER_STATS);
MAKE_STATS_STRUCT(VirtualClusterStats, VirtualClusterStatNames, ALL_VIRTUAL_CLUSTER_STATS);

/**
 * Struct definition for all route level stats. @see stats_macro.h
 */
MAKE_STAT_NAMES_STRUCT(RouteStatNames, ALL_ROUTE_STATS);
MAKE_STATS_STRUCT(RouteStats, RouteStatNames, ALL_ROUTE_STATS);

/**
 * RouteStatsContext defines config needed to generate all route level stats.
 */
class RouteStatsContext;

using RouteStatsContextPtr = std::unique_ptr<RouteStatsContext>;
using RouteStatsContextOptRef = OptRef<RouteStatsContext>;

/**
 * Virtual cluster definition (allows splitting a virtual host into virtual clusters orthogonal to
 * routes for stat tracking and priority purposes).
 */
class VirtualCluster {
public:
  virtual ~VirtualCluster() = default;

  /**
   * @return the string name of the virtual cluster.
   */
  virtual const absl::optional<std::string>& name() const PURE;

  /**
   * @return the stat-name of the virtual cluster.
   */
  virtual Stats::StatName statName() const PURE;

  /**
   * @return VirtualClusterStats& strongly named stats for this virtual cluster.
   */
  virtual VirtualClusterStats& stats() const PURE;

  static VirtualClusterStats generateStats(Stats::Scope& scope,
                                           const VirtualClusterStatNames& stat_names) {
    return {stat_names, scope};
  }
};

class RateLimitPolicy;
class Config;
class CommonConfig;

/**
 * Virtual host definition.
 */
class VirtualHost {
public:
  virtual ~VirtualHost() = default;

  /**
   * @return const CorsPolicy* the CORS policy for this virtual host.
   */
  virtual const CorsPolicy* corsPolicy() const PURE;

  /**
   * @return the stat-name of the virtual host.
   */
  virtual Stats::StatName statName() const PURE;

  /**
   * @return const RateLimitPolicy& the rate limit policy for the virtual host.
   */
  virtual const RateLimitPolicy& rateLimitPolicy() const PURE;

  /**
   * @return const Config& the RouteConfiguration that owns this virtual host.
   */
  virtual const CommonConfig& routeConfig() const PURE;

  /**
   * @return bool whether to include the request count header in upstream requests.
   */
  virtual bool includeAttemptCountInRequest() const PURE;

  /**
   * @return bool whether to include the request count header in the downstream response.
   */
  virtual bool includeAttemptCountInResponse() const PURE;

  /**
   * @return bool whether to include the header in the upstream request to indicate it is a retry
   * initiated by a timeout.
   */
  virtual bool includeIsTimeoutRetryHeader() const PURE;

  /**
   * @return uint32_t any route cap on bytes which should be buffered for shadowing or retries.
   *         This is an upper bound so does not necessarily reflect the bytes which will be buffered
   *         as other limits may apply.
   *         If a per route limit exists, it takes precedence over this configuration.
   *         Unlike some other buffer limits, 0 here indicates buffering should not be performed
   *         rather than no limit applies.
   */
  virtual uint32_t retryShadowBufferLimit() const PURE;

  /**
   * This is a helper to get the route's per-filter config if it exists, up along the config
   * hierarchy (Route --> VirtualHost --> RouteConfiguration). Or nullptr if none of them exist.
   */
  virtual const RouteSpecificFilterConfig*
  mostSpecificPerFilterConfig(const std::string& name) const PURE;

  /**
   * Find all the available per route filter configs, invoking the callback with
   * each config (if it is present). Iteration of the configs is in order of
   * specificity. That means that the callback will be called first for a config on
   * a route configuration, virtual host, route, and finally a route entry (weighted cluster). If
   * a config is not present, the callback will not be invoked.
   */
  virtual void traversePerFilterConfig(
      const std::string& filter_name,
      std::function<void(const Router::RouteSpecificFilterConfig&)> cb) const PURE;

  /**
   * @return const envoy::config::core::v3::Metadata& return the metadata provided in the config for
   * this virtual host.
   */
  virtual const envoy::config::core::v3::Metadata& metadata() const PURE;

  /**
   * @return const Envoy::Config::TypedMetadata& return the typed metadata provided in the config
   * for this virtual host.
   */
  virtual const Envoy::Config::TypedMetadata& typedMetadata() const PURE;
};

/**
 * Route level hedging policy.
 */
class HedgePolicy {
public:
  virtual ~HedgePolicy() = default;

  /**
   * @return number of upstream requests that should be sent initially.
   */
  virtual uint32_t initialRequests() const PURE;

  /**
   * @return percent chance that an additional upstream request should be sent
   * on top of the value from initialRequests().
   */
  virtual const envoy::type::v3::FractionalPercent& additionalRequestChance() const PURE;

  /**
   * @return bool indicating whether request hedging should occur when a request
   * is retried due to a per try timeout. The alternative is the original request
   * will be canceled immediately.
   */
  virtual bool hedgeOnPerTryTimeout() const PURE;
};

class MetadataMatchCriterion {
public:
  virtual ~MetadataMatchCriterion() = default;

  /*
   * @return const std::string& the name of the metadata key
   */
  virtual const std::string& name() const PURE;

  /*
   * @return const Envoy::HashedValue& the value for the metadata key
   */
  virtual const HashedValue& value() const PURE;
};

using MetadataMatchCriterionConstSharedPtr = std::shared_ptr<const MetadataMatchCriterion>;

class MetadataMatchCriteria;
using MetadataMatchCriteriaConstPtr = std::unique_ptr<const MetadataMatchCriteria>;

class MetadataMatchCriteria {
public:
  virtual ~MetadataMatchCriteria() = default;

  /*
   * @return std::vector<MetadataMatchCriterionConstSharedPtr>& a vector of
   * metadata to be matched against upstream endpoints when load
   * balancing, sorted lexically by name.
   */
  virtual const std::vector<MetadataMatchCriterionConstSharedPtr>&
  metadataMatchCriteria() const PURE;

  /**
   * Creates a new MetadataMatchCriteria, merging existing
   * metadata criteria with the provided criteria. The result criteria is the
   * combination of both sets of criteria, with those from the metadata_matches
   * ProtobufWkt::Struct taking precedence.
   * @param metadata_matches supplies the new criteria.
   * @return MetadataMatchCriteriaConstPtr the result criteria.
   */
  virtual MetadataMatchCriteriaConstPtr
  mergeMatchCriteria(const ProtobufWkt::Struct& metadata_matches) const PURE;

  /**
   * Creates a new MetadataMatchCriteria with criteria vector reduced to given names
   * @param names names of metadata keys to preserve
   * @return MetadataMatchCriteriaConstPtr the result criteria. Returns nullptr if the result
   * criteria are empty.
   */
  virtual MetadataMatchCriteriaConstPtr
  filterMatchCriteria(const std::set<std::string>& names) const PURE;
};

/**
 * Criterion that a route entry uses for matching TLS connection context.
 */
class TlsContextMatchCriteria {
public:
  virtual ~TlsContextMatchCriteria() = default;

  /**
   * @return bool indicating whether the client presented credentials.
   */
  virtual const absl::optional<bool>& presented() const PURE;

  /**
   * @return bool indicating whether the client credentials successfully validated against the TLS
   * context validation context.
   */
  virtual const absl::optional<bool>& validated() const PURE;
};

using TlsContextMatchCriteriaConstPtr = std::unique_ptr<const TlsContextMatchCriteria>;

/**
 * Type of path matching that a route entry uses.
 */
enum class PathMatchType {
  None,
  Prefix,
  Exact,
  Regex,
  PathSeparatedPrefix,
  Template,
};

/**
 * Criterion that a route entry uses for matching a particular path.
 * Extensions can use this to gain better insights of chosen route paths,
 * see: https://github.com/envoyproxy/envoy/pull/2531.
 */
class PathMatchCriterion {
public:
  virtual ~PathMatchCriterion() = default;

  /**
   * @return PathMatchType type of path match.
   */
  virtual PathMatchType matchType() const PURE;

  /**
   * @return const std::string& the string with which to compare paths.
   */
  virtual const std::string& matcher() const PURE;
};

/**
 * Base class for all route typed metadata factories.
 */
class HttpRouteTypedMetadataFactory : public Envoy::Config::TypedMetadataFactory {};

/**
 * Base class for all early data option extensions.
 */
class EarlyDataPolicy {
public:
  virtual ~EarlyDataPolicy() = default;

  /**
   * @return bool whether the given request may be sent over early data.
   */
  virtual bool allowsEarlyDataForRequest(const Http::RequestHeaderMap& request_headers) const PURE;
};

using EarlyDataPolicyPtr = std::unique_ptr<EarlyDataPolicy>;

/**
 * Base class for all early data option factories.
 */
class EarlyDataPolicyFactory : public Envoy::Config::TypedFactory {
public:
  ~EarlyDataPolicyFactory() override = default;

  /**
   * @param config the typed config for early data option.
   * @return EarlyDataIOptionPtr an instance of EarlyDataPolicy.
   */
  virtual EarlyDataPolicyPtr createEarlyDataPolicy(const Protobuf::Message& config) PURE;

  // Config::UntypedFactory
  std::string category() const override { return "envoy.route.early_data_policy"; }
};

/**
 * An individual resolved route entry.
 */
class RouteEntry : public ResponseEntry {
public:
  ~RouteEntry() override = default;

  /**
   * @return const std::string& the upstream cluster that owns the route.
   */
  virtual const std::string& clusterName() const PURE;

  /**
   * Returns the HTTP status code to use when configured cluster is not found.
   * @return Http::Code to use when configured cluster is not found.
   */
  virtual Http::Code clusterNotFoundResponseCode() const PURE;

  /**
   * @return const CorsPolicy* the CORS policy for this virtual host.
   */
  virtual const CorsPolicy* corsPolicy() const PURE;

  /**
   * Returns the URL path as it will be calculated by finalizeRequestHeaders
   * using current values of headers. Note that final path may be different if
   * headers change before finalization.
   * @param headers supplies the request headers.
   * @return absl::optional<std::string> the value of the URL path after rewrite or absl::nullopt
   *         if rewrite is not configured.
   */
  virtual absl::optional<std::string>
  currentUrlPathAfterRewrite(const Http::RequestHeaderMap& headers) const PURE;

  /**
   * Do potentially destructive header transforms on request headers prior to forwarding. For
   * example URL prefix rewriting, adding headers, etc. This should only be called ONCE
   * immediately prior to forwarding. It is done this way vs. copying for performance reasons.
   * @param headers supplies the request headers, which may be modified during this call.
   * @param stream_info holds additional information about the request.
   * @param insert_envoy_original_path insert x-envoy-original-path header if path rewritten?
   */
  virtual void finalizeRequestHeaders(Http::RequestHeaderMap& headers,
                                      const StreamInfo::StreamInfo& stream_info,
                                      bool insert_envoy_original_path) const PURE;

  /**
   * Returns the request header transforms that would be applied if finalizeRequestHeaders were
   * called now. This is useful if you want to obtain request header transforms which was or will be
   * applied through finalizeRequestHeaders call. Note: do not use unless you are sure that there
   * will be no route modifications later in the filter chain.
   * @param stream_info holds additional information about the request.
   * @param do_formatting whether or not to evaluate configured transformations; if false, returns
   * original values instead.
   */
  virtual Http::HeaderTransforms requestHeaderTransforms(const StreamInfo::StreamInfo& stream_info,
                                                         bool do_formatting = true) const PURE;

  /**
   * @return const HashPolicy* the optional hash policy for the route.
   */
  virtual const Http::HashPolicy* hashPolicy() const PURE;

  /**
   * @return const HedgePolicy& the hedge policy for the route. All routes have a hedge policy even
   *         if it is empty and does not allow for hedged requests.
   */
  virtual const HedgePolicy& hedgePolicy() const PURE;

  /**
   * @return the priority of the route.
   */
  virtual Upstream::ResourcePriority priority() const PURE;

  /**
   * @return const RateLimitPolicy& the rate limit policy for the route.
   */
  virtual const RateLimitPolicy& rateLimitPolicy() const PURE;

  /**
   * @return const RetryPolicy& the retry policy for the route. All routes have a retry policy even
   *         if it is empty and does not allow retries.
   */
  virtual const RetryPolicy& retryPolicy() const PURE;

  /**
   * @return const InternalRedirectPolicy& the internal redirect policy for the route. All routes
   *         have a internal redirect policy even if it is not enabled, which means redirects are
   *         simply proxied as normal responses.
   */
  virtual const InternalRedirectPolicy& internalRedirectPolicy() const PURE;

  /**
   * @return const PathMatcherSharedPtr& the path match policy for the route.
   */
  virtual const PathMatcherSharedPtr& pathMatcher() const PURE;

  /**
   * @return const PathRewriterSharedPtr& the path match rewrite for the route.
   */
  virtual const PathRewriterSharedPtr& pathRewriter() const PURE;

  /**
   * @return uint32_t any route cap on bytes which should be buffered for shadowing or retries.
   *         This is an upper bound so does not necessarily reflect the bytes which will be buffered
   *         as other limits may apply.
   *         Unlike some other buffer limits, 0 here indicates buffering should not be performed
   *         rather than no limit applies.
   */
  virtual uint32_t retryShadowBufferLimit() const PURE;

  /**
   * @return const std::vector<ShadowPolicy>& the shadow policies for the route. The vector is empty
   *         if no shadowing takes place.
   */
  virtual const std::vector<ShadowPolicyPtr>& shadowPolicies() const PURE;

  /**
   * @return std::chrono::milliseconds the route's timeout.
   */
  virtual std::chrono::milliseconds timeout() const PURE;

  /**
   * @return optional<std::chrono::milliseconds> the route's idle timeout. Zero indicates a
   *         disabled idle timeout, while nullopt indicates deference to the global timeout.
   */
  virtual absl::optional<std::chrono::milliseconds> idleTimeout() const PURE;

  /**
   * @return true if new style max_stream_duration config should be used over the old style.
   */
  virtual bool usingNewTimeouts() const PURE;

  /**
   * @return optional<std::chrono::milliseconds> the route's maximum stream duration.
   */
  virtual absl::optional<std::chrono::milliseconds> maxStreamDuration() const PURE;

  /**
   * @return optional<std::chrono::milliseconds> the max grpc-timeout this route will allow.
   */
  virtual absl::optional<std::chrono::milliseconds> grpcTimeoutHeaderMax() const PURE;

  /**
   * @return optional<std::chrono::milliseconds> the delta between grpc-timeout and enforced grpc
   *         timeout.
   */
  virtual absl::optional<std::chrono::milliseconds> grpcTimeoutHeaderOffset() const PURE;

  /**
   * @return absl::optional<std::chrono::milliseconds> the maximum allowed timeout value derived
   * from 'grpc-timeout' header of a gRPC request. Non-present value disables use of 'grpc-timeout'
   * header, while 0 represents infinity.
   */
  virtual absl::optional<std::chrono::milliseconds> maxGrpcTimeout() const PURE;

  /**
   * @return absl::optional<std::chrono::milliseconds> the timeout offset to apply to the timeout
   * provided by the 'grpc-timeout' header of a gRPC request. This value will be positive and should
   * be subtracted from the value provided by the header.
   */
  virtual absl::optional<std::chrono::milliseconds> grpcTimeoutOffset() const PURE;

  /**
   * Determine whether a specific request path belongs to a virtual cluster for use in stats, etc.
   * @param headers supplies the request headers.
   * @return the virtual cluster or nullptr if there is no match.
   */
  virtual const VirtualCluster* virtualCluster(const Http::HeaderMap& headers) const PURE;

  /**
   * @return const VirtualHost& the virtual host that owns the route.
   */
  virtual const VirtualHost& virtualHost() const PURE;

  /**
   * @return bool true if the :authority header should be overwritten with the upstream hostname.
   */
  virtual bool autoHostRewrite() const PURE;

  /**
   * @return bool true if the x-forwarded-host header should be updated.
   */
  virtual bool appendXfh() const PURE;

  /**
   * @return MetadataMatchCriteria* the metadata that a subset load balancer should match when
   * selecting an upstream host
   */
  virtual const MetadataMatchCriteria* metadataMatchCriteria() const PURE;

  /**
   * @return const std::multimap<std::string, std::string> the opaque configuration associated
   *         with the route
   */
  virtual const std::multimap<std::string, std::string>& opaqueConfig() const PURE;

  /**
   * @return bool true if the virtual host rate limits should be included.
   */
  virtual bool includeVirtualHostRateLimits() const PURE;

  /**
   * @return TlsContextMatchCriteria* the tls context match criterion for this route. If there is no
   * tls context match criteria, nullptr is returned.
   */
  virtual const TlsContextMatchCriteria* tlsContextMatchCriteria() const PURE;

  /**
   * @return const PathMatchCriterion& the match criterion for this route.
   */
  virtual const PathMatchCriterion& pathMatchCriterion() const PURE;

  /**
   * True if the virtual host this RouteEntry belongs to is configured to include the attempt
   * count header.
   * @return bool whether x-envoy-attempt-count should be included on the upstream request.
   */
  virtual bool includeAttemptCountInRequest() const PURE;

  /**
   * True if the virtual host this RouteEntry belongs to is configured to include the attempt
   * count header.
   * @return bool whether x-envoy-attempt-count should be included on the downstream response.
   */
  virtual bool includeAttemptCountInResponse() const PURE;

  using UpgradeMap = std::map<std::string, bool>;
  /**
   * @return a map of route-specific upgrades to their enabled/disabled status.
   */
  virtual const UpgradeMap& upgradeMap() const PURE;

  using ConnectConfig = envoy::config::route::v3::RouteAction::UpgradeConfig::ConnectConfig;
  using ConnectConfigOptRef = OptRef<ConnectConfig>;
  /**
   * If present, informs how to handle proxying CONNECT requests on this route.
   */
  virtual const ConnectConfigOptRef connectConfig() const PURE;

  /**
   * @return RouteStatsContextOptRef the config needed to generate route level stats.
   */
  virtual const RouteStatsContextOptRef routeStatsContext() const PURE;

  /**
   * @return EarlyDataPolicy& the configured early data option.
   */
  virtual const EarlyDataPolicy& earlyDataPolicy() const PURE;
};

/**
 * An interface representing the Decorator.
 */
class Decorator {
public:
  virtual ~Decorator() = default;

  /**
   * This method decorates the supplied span.
   * @param Tracing::Span& the span.
   */
  virtual void apply(Tracing::Span& span) const PURE;

  /**
   * This method returns the operation name.
   * @return the operation name
   */
  virtual const std::string& getOperation() const PURE;

  /**
   * This method returns whether the decorator information
   * should be propagated to other services.
   * @return whether to propagate
   */
  virtual bool propagate() const PURE;
};

using DecoratorConstPtr = std::unique_ptr<const Decorator>;

/**
 * An interface representing the Tracing for the route configuration.
 */
class RouteTracing {
public:
  virtual ~RouteTracing() = default;

  /**
   * This method returns the client sampling percentage.
   * @return the client sampling percentage
   */
  virtual const envoy::type::v3::FractionalPercent& getClientSampling() const PURE;

  /**
   * This method returns the random sampling percentage.
   * @return the random sampling percentage
   */
  virtual const envoy::type::v3::FractionalPercent& getRandomSampling() const PURE;

  /**
   * This method returns the overall sampling percentage.
   * @return the overall sampling percentage
   */
  virtual const envoy::type::v3::FractionalPercent& getOverallSampling() const PURE;

  /**
   * This method returns the route level tracing custom tags.
   * @return the tracing custom tags.
   */
  virtual const Tracing::CustomTagMap& getCustomTags() const PURE;
};

using RouteTracingConstPtr = std::unique_ptr<const RouteTracing>;

/**
 * An interface that holds a DirectResponseEntry or RouteEntry for a request.
 */
class Route {
public:
  virtual ~Route() = default;

  /**
   * @return the direct response entry or nullptr if there is no direct response for the request.
   */
  virtual const DirectResponseEntry* directResponseEntry() const PURE;

  /**
   * @return the route entry or nullptr if there is no matching route for the request.
   */
  virtual const RouteEntry* routeEntry() const PURE;

  /**
   * @return the decorator or nullptr if not defined for the request.
   */
  virtual const Decorator* decorator() const PURE;

  /**
   * @return the tracing config or nullptr if not defined for the request.
   */
  virtual const RouteTracing* tracingConfig() const PURE;

  /**
   * Check if the filter is disabled for this route.
   * @param config_name supplies the name of the filter config in the HTTP filter chain. This name
   * may be different from the filter extension qualified name.
   * @return true if the filter is disabled for this route, false if the filter is enabled.
   *         nullopt if no decision can be made explicitly for the filter.
   */
  virtual absl::optional<bool> filterDisabled(absl::string_view config_name) const PURE;

  /**
   * This is a helper to get the route's per-filter config if it exists, up along the config
   * hierarchy(Route --> VirtualHost --> RouteConfiguration). Or nullptr if none of them exist.
   */
  virtual const RouteSpecificFilterConfig*
  mostSpecificPerFilterConfig(const std::string& name) const PURE;

  /**
   * Find all the available per route filter configs, invoking the callback with each config (if
   * it is present). Iteration of the configs is in order of specificity. That means that the
   * callback will be called first for a config on a Virtual host, then a route, and finally a route
   * entry (weighted cluster). If a config is not present, the callback will not be invoked.
   */
  virtual void traversePerFilterConfig(
      const std::string& filter_name,
      std::function<void(const Router::RouteSpecificFilterConfig&)> cb) const PURE;

  /**
   * @return const envoy::config::core::v3::Metadata& return the metadata provided in the config for
   * this route.
   */
  virtual const envoy::config::core::v3::Metadata& metadata() const PURE;

  /**
   * @return const Envoy::Config::TypedMetadata& return the typed metadata provided in the config
   * for this route.
   */
  virtual const Envoy::Config::TypedMetadata& typedMetadata() const PURE;

  /**
   * @return std::string& the name of the route.
   */
  virtual const std::string& routeName() const PURE;
};

using RouteConstSharedPtr = std::shared_ptr<const Route>;

class RouteEntryAndRoute : public RouteEntry, public Route {};

/**
 * RouteCallback, returns one of these enums to the route matcher to indicate
 * if the matched route has been accepted or it wants the route matching to
 * continue.
 */
enum class RouteMatchStatus {
  // Continue matching route
  Continue,
  // Accept matched route
  Accept
};

/**
 * RouteCallback is passed this enum to indicate if more routes are available for evaluation.
 */
enum class RouteEvalStatus {
  // Has more routes that can be evaluated for match.
  HasMoreRoutes,
  // All routes have been evaluated for match.
  NoMoreRoutes
};

/**
 * RouteCallback can be used to override routing decision made by the Route::Config::route,
 * this callback is passed the RouteConstSharedPtr, when a matching route is found, and
 * RouteEvalStatus indicating whether there are more routes available for evaluation.
 *
 * RouteCallback will be called back only when at least one matching route is found, if no matching
 * routes are found RouteCallback will not be invoked. RouteCallback can return one of the
 * RouteMatchStatus enum to indicate if the match has been accepted or should the route match
 * evaluation continue.
 *
 * Returning RouteMatchStatus::Continue, when no more routes available for evaluation will result in
 * no further callbacks and no route is deemed to be accepted and nullptr is returned to the caller
 * of Route::Config::route.
 */
using RouteCallback = std::function<RouteMatchStatus(RouteConstSharedPtr, RouteEvalStatus)>;

/**
 * Shared part of the route configuration. This class contains interfaces that needn't depend on
 * router matcher. Then every virtualhost could keep a reference to the CommonConfig. When the
 * entire route config is destroyed, the part of CommonConfig will still live until all
 * virtualhosts are destroyed.
 */
class CommonConfig {
public:
  virtual ~CommonConfig() = default;

  /**
   * Return a list of headers that will be cleaned from any requests that are not from an internal
   * (RFC1918) source.
   */
  virtual const std::list<Http::LowerCaseString>& internalOnlyHeaders() const PURE;

  /**
   * @return const std::string the RouteConfiguration name.
   */
  virtual const std::string& name() const PURE;

  /**
   * @return whether router configuration uses VHDS.
   */
  virtual bool usesVhds() const PURE;

  /**
   * @return bool whether most specific header mutations should take precedence. The default
   * evaluation order is route level, then virtual host level and finally global connection
   * manager level.
   */
  virtual bool mostSpecificHeaderMutationsWins() const PURE;

  /**
   * @return uint32_t The maximum bytes of the response direct response body size. The default value
   * is 4096.
   * TODO(dio): To allow overrides at different levels (e.g. per-route, virtual host, etc).
   */
  virtual uint32_t maxDirectResponseBodySizeBytes() const PURE;

  /**
   * @return const envoy::config::core::v3::Metadata& return the metadata provided in the config for
   * this route configuration.
   */
  virtual const envoy::config::core::v3::Metadata& metadata() const PURE;

  /**
   * @return const Envoy::Config::TypedMetadata& return the typed metadata provided in the config
   * for this route configuration.
   */
  virtual const Envoy::Config::TypedMetadata& typedMetadata() const PURE;
};

/**
 * The router configuration.
 */
class Config : public Rds::Config, public CommonConfig {
public:
  /**
   * Based on the incoming HTTP request headers, determine the target route (containing either a
   * route entry or a direct response entry) for the request.
   * @param headers supplies the request headers.
   * @param random_value supplies the random seed to use if a runtime choice is required. This
   *        allows stable choices between calls if desired.
   * @return the route or nullptr if there is no matching route for the request.
   */
  virtual RouteConstSharedPtr route(const Http::RequestHeaderMap& headers,
                                    const StreamInfo::StreamInfo& stream_info,
                                    uint64_t random_value) const PURE;

  /**
   * Based on the incoming HTTP request headers, determine the target route (containing either a
   * route entry or a direct response entry) for the request.
   *
   * Invokes callback with matched route, callback can choose to accept the route by returning
   * RouteStatus::Stop or continue route match from last matched route by returning
   * RouteMatchStatus::Continue, when more routes are available.
   *
   * @param cb supplies callback to be invoked upon route match.
   * @param headers supplies the request headers.
   * @param random_value supplies the random seed to use if a runtime choice is required. This
   *        allows stable choices between calls if desired.
   * @return the route accepted by the callback or nullptr if no match found or none of route is
   * accepted by the callback.
   */
  virtual RouteConstSharedPtr route(const RouteCallback& cb, const Http::RequestHeaderMap& headers,
                                    const StreamInfo::StreamInfo& stream_info,
                                    uint64_t random_value) const PURE;
};

using ConfigConstSharedPtr = std::shared_ptr<const Config>;

class GenericConnectionPoolCallbacks;
class GenericUpstream;

/**
 * An API for wrapping either an HTTP, TCP, or UDP connection pool.
 *
 * The GenericConnPool exists to create a GenericUpstream handle via a call to
 * newStream resulting in an eventual call to onPoolReady
 */
class GenericConnPool {
public:
  virtual ~GenericConnPool() = default;

  /**
   * Called to create a new HTTP stream, TCP connection for CONNECT streams, or UDP socket for
   * CONNECT-UDP streams.
   *
   * The implementation of the GenericConnPool will either call
   * GenericConnectionPoolCallbacks::onPoolReady
   * when a stream is available or GenericConnectionPoolCallbacks::onPoolFailure
   * if stream creation fails.
   *
   * The caller is responsible for calling cancelAnyPendingStream() if stream
   * creation is no longer desired. newStream may only be called once per
   * GenericConnPool.
   *
   * @param callbacks callbacks to communicate stream failure or creation on.
   */
  virtual void newStream(GenericConnectionPoolCallbacks* callbacks) PURE;
  /**
   * Called to cancel any pending newStream request,
   */
  virtual bool cancelAnyPendingStream() PURE;
  /**
   * @return optionally returns the host for the connection pool.
   */
  virtual Upstream::HostDescriptionConstSharedPtr host() const PURE;

  /**
   * @return returns if the connection pool was iniitalized successfully.
   */
  virtual bool valid() const PURE;
};

/**
 * An API for the interactions the upstream stream needs to have with the downstream stream
 * and/or router components
 */
class UpstreamToDownstream : public Http::ResponseDecoder, public Http::StreamCallbacks {
public:
  /**
   * @return return the route for the downstream stream.
   */
  virtual const Route& route() const PURE;
  /**
   * @return return the connection for the downstream stream if it exists.
   */
  virtual OptRef<const Network::Connection> connection() const PURE;
  /**
   * @return returns the options to be consulted with for upstream stream creation.
   */
  virtual const Http::ConnectionPool::Instance::StreamOptions& upstreamStreamOptions() const PURE;
};

/**
 * An API for wrapping callbacks from either an HTTP, TCP, or UDP connection pool.
 *
 * Just like the connection pool callbacks, the GenericConnectionPoolCallbacks
 * will either call onPoolReady when a GenericUpstream is ready, or
 * onPoolFailure if a connection/stream can not be established.
 */
class GenericConnectionPoolCallbacks {
public:
  virtual ~GenericConnectionPoolCallbacks() = default;

  /**
   * Called to indicate a failure for GenericConnPool::newStream to establish a stream.
   *
   * @param reason supplies the failure reason.
   * @param transport_failure_reason supplies the details of the transport failure reason.
   * @param host supplies the description of the host that caused the failure. This may be nullptr
   *             if no host was involved in the failure (for example overflow).
   */
  virtual void onPoolFailure(ConnectionPool::PoolFailureReason reason,
                             absl::string_view transport_failure_reason,
                             Upstream::HostDescriptionConstSharedPtr host) PURE;
  /**
   * Called when GenericConnPool::newStream has established a new stream.
   *
   * @param upstream supplies the generic upstream for the stream.
   * @param host supplies the description of the host that will carry the request. For logical
   *             connection pools the description may be different each time this is called.
   * @param connection_info_provider, supplies the address provider of the upstream connection.
   * @param info supplies the stream info object associated with the upstream connection.
   * @param protocol supplies the protocol associated with the upstream connection.
   */
  virtual void onPoolReady(std::unique_ptr<GenericUpstream>&& upstream,
                           Upstream::HostDescriptionConstSharedPtr host,
                           const Network::ConnectionInfoProvider& connection_info_provider,
                           StreamInfo::StreamInfo& info,
                           absl::optional<Http::Protocol> protocol) PURE;

  // @return the UpstreamToDownstream interface for this stream.
  //
  // This is the interface for all interactions the upstream stream needs to have with the
  // downstream stream. It is in the GenericConnectionPoolCallbacks as the GenericConnectionPool
  // creates the GenericUpstream, and the GenericUpstream will need this interface.
  virtual UpstreamToDownstream& upstreamToDownstream() PURE;
};

/**
 * An API for sending information to either a TCP, UDP, or HTTP upstream.
 *
 * It is similar logically to RequestEncoder, only without the getStream interface.
 */
class GenericUpstream {
public:
  virtual ~GenericUpstream() = default;
  /**
   * Encode a data frame.
   * @param data supplies the data to encode. The data may be moved by the encoder.
   * @param end_stream supplies whether this is the last data frame.
   */
  virtual void encodeData(Buffer::Instance& data, bool end_stream) PURE;
  /**
   * Encode metadata.
   * @param metadata_map_vector is the vector of metadata maps to encode.
   */
  virtual void encodeMetadata(const Http::MetadataMapVector& metadata_map_vector) PURE;
  /**
   * Encode headers, optionally indicating end of stream.
   * @param headers supplies the header map to encode.
   * @param end_stream supplies whether this is a header only request.
   * @return status indicating success. Encoding will fail if headers do not have required HTTP
   * headers.
   */
  virtual Http::Status encodeHeaders(const Http::RequestHeaderMap& headers, bool end_stream) PURE;
  /**
   * Encode trailers. This implicitly ends the stream.
   * @param trailers supplies the trailers to encode.
   */
  virtual void encodeTrailers(const Http::RequestTrailerMap& trailers) PURE;
  /**
   * Enable/disable further data from this stream.
   */
  virtual void readDisable(bool disable) PURE;
  /**
   * Reset the stream. No events will fire beyond this point.
   */
  virtual void resetStream() PURE;

  /**
   * Sets the upstream to use the following account.
   * @param the account to assign the generic upstream.
   */
  virtual void setAccount(Buffer::BufferMemoryAccountSharedPtr account) PURE;

  /**
   * Get the bytes meter for this stream.
   */
  virtual const StreamInfo::BytesMeterSharedPtr& bytesMeter() PURE;
};

using GenericConnPoolPtr = std::unique_ptr<GenericConnPool>;

/*
 * A factory for creating generic connection pools.
 */
class GenericConnPoolFactory : public Envoy::Config::TypedFactory {
public:
  /*
   * Protocol used by the upstream sockets.
   */
  enum class UpstreamProtocol { HTTP, TCP, UDP };

  ~GenericConnPoolFactory() override = default;

  /*
   * @param options for creating the transport socket
   * @return may be null
   */
  virtual GenericConnPoolPtr
  createGenericConnPool(Upstream::ThreadLocalCluster& thread_local_cluster,
                        GenericConnPoolFactory::UpstreamProtocol upstream_protocol,
                        Upstream::ResourcePriority priority,
                        absl::optional<Http::Protocol> downstream_protocol,
                        Upstream::LoadBalancerContext* ctx) const PURE;
};

using GenericConnPoolFactoryPtr = std::unique_ptr<GenericConnPoolFactory>;

} // namespace Router
} // namespace Envoy
#pragma once

#include "envoy/http/filter.h"
#include "envoy/http/header_map.h"
#include "envoy/stats/scope.h"
#include "envoy/stats/stats_macros.h"
#include "envoy/stream_info/stream_info.h"
#include "envoy/upstream/cluster_manager.h"
#include "envoy/upstream/host_description.h"

namespace Envoy {
namespace Router {

class UpstreamRequest;

// This groups various per-stream timeouts conveniently together.
struct TimeoutData {
  std::chrono::milliseconds global_timeout_{0};
  std::chrono::milliseconds per_try_timeout_{0};
  std::chrono::milliseconds per_try_idle_timeout_{0};
};

// The interface the UpstreamRequest has to interact with the router filter.
class RouterFilterInterface {
public:
  virtual ~RouterFilterInterface() = default;

  /**
   * This will be called when upstream 1xx headers are ready to be processed by downstream code.
   * @param headers contains the 1xx headers
   * @param upstream_request inicates which UpstreamRequest the 1xx headers are from.
   *
   */
  virtual void onUpstream1xxHeaders(Http::ResponseHeaderMapPtr&& headers,
                                    UpstreamRequest& upstream_request) PURE;
  /**
   * This will be called when upstream non-1xx headers are ready to be processed by downstream code.
   * @param headers contains the headers
   * @param upstream_request inicates which UpstreamRequest the headers are from.
   * @param end_stream indicates if the response is complete.
   *
   */
  virtual void onUpstreamHeaders(uint64_t response_code, Http::ResponseHeaderMapPtr&& headers,
                                 UpstreamRequest& upstream_request, bool end_stream) PURE;
  /**
   * This will be called when upstream data is ready to be processed by downstream code.
   * @param data contains the data to process
   * @param upstream_request inicates which UpstreamRequest the data is from.
   * @param end_stream indicates if the response is complete.
   *
   */
  virtual void onUpstreamData(Buffer::Instance& data, UpstreamRequest& upstream_request,
                              bool end_stream) PURE;
  /**
   * This will be called when upstream trailers are ready to be processed by downstream code.
   * @param trailers contains the trailers to process
   * @param upstream_request inicates which UpstreamRequest the trailers are from.
   *
   */
  virtual void onUpstreamTrailers(Http::ResponseTrailerMapPtr&& trailers,
                                  UpstreamRequest& upstream_request) PURE;
  /**
   * This will be called when upstream metadata is ready to be processed by downstream code.
   * @param metadata contains the metadata to process
   * @param upstream_request inicates which UpstreamRequest the metadata is from.
   *
   */
  virtual void onUpstreamMetadata(Http::MetadataMapPtr&& metadata_map) PURE;

  /**
   * This will be called when an upstream reset is ready to be processed by downstream code.
   * @param reset_reason indicates the reason for the reset.
   * @param transport_failure optionally indicates any transport failure.
   * @param upstream_request inicates which UpstreamRequest the reset is from.
   *
   */
  virtual void onUpstreamReset(Http::StreamResetReason reset_reason,
                               absl::string_view transport_failure,
                               UpstreamRequest& upstream_request) PURE;

  /**
   * This will be called when an upstream host is selected. This is called both
   * if the host can accomodate the stream and if the host is selected but unusable.
   * @param host the host selected for the request
   * @param pool_success indicates if the host can be used for the request.
   */
  virtual void onUpstreamHostSelected(Upstream::HostDescriptionConstSharedPtr host,
                                      bool pool_success) PURE;
  /*
   * This will be called if a per-try timeout fails.
   * @param upstream_request inicates which UpstreamRequest which timed out
   */
  virtual void onPerTryTimeout(UpstreamRequest& upstream_request) PURE;

  /*
   * This will be called if a per-try idle timeout fails.
   * @param upstream_request inicates which UpstreamRequest which timed out
   */
  virtual void onPerTryIdleTimeout(UpstreamRequest& upstream_request) PURE;

  /*
   * This will be called if the max stream duration was reached.
   * @param upstream_request inicates which UpstreamRequest which timed out
   */
  virtual void onStreamMaxDurationReached(UpstreamRequest& upstream_request) PURE;

  /*
   * @returns the Router filter's StreamDecoderFilterCallbacks.
   */
  virtual Http::StreamDecoderFilterCallbacks* callbacks() PURE;
  /*
   * @returns the cluster for this stream.
   */
  virtual Upstream::ClusterInfoConstSharedPtr cluster() PURE;

  /*
   * @returns the FilterConfig for this stream
   */
  virtual FilterConfig& config() PURE;

  /*
   * @returns the various timeouts for this stream.
   */
  virtual TimeoutData timeout() PURE;

  /*
   * @returns the dynamic max stream duraration for this stream, if set.
   */
  virtual absl::optional<std::chrono::milliseconds> dynamicMaxStreamDuration() const PURE;

  /*
   * @returns the request headers for the stream.
   */
  virtual Http::RequestHeaderMap* downstreamHeaders() PURE;

  /*
   * @returns the request trailers for the stream.
   */
  virtual Http::RequestTrailerMap* downstreamTrailers() PURE;

  /*
   * @returns true if the downstream response has started.
   */
  virtual bool downstreamResponseStarted() const PURE;

  /*
   * @returns true if end_stream has been sent from the upstream side to the downstream side.
   */
  virtual bool downstreamEndStream() const PURE;

  /*
   * @returns the number of attempts (e.g. retries) performed for this stream.
   */
  virtual uint32_t attemptCount() const PURE;
};

} // namespace Router
} // namespace Envoy
#pragma once

#include <chrono>
#include <memory>
#include <string>

#include "envoy/http/async_client.h"
#include "envoy/http/message.h"

namespace Envoy {
namespace Router {

/**
 * Interface used to shadow complete requests to an alternate upstream cluster in a "fire and
 * forget" fashion. Right now this interface takes a fully buffered request and cannot be used for
 * streaming. This is sufficient for current use cases.
 */
class ShadowWriter {
public:
  virtual ~ShadowWriter() = default;

  /**
   * Shadow a request.
   * @param cluster supplies the cluster name to shadow to.
   * @param message supplies the complete request to shadow.
   * @param options supplies the request options for the underlying asynchronous request.
   */
  virtual void shadow(const std::string& cluster, Http::RequestMessagePtr&& request,
                      const Http::AsyncClient::RequestOptions& options) PURE;

  /**
   * Initialize shadowing a request. Differs from the above in that additional
   * data can be passed to the returned handle after the headers have been sent.
   * @param cluster supplies the cluster name to shadow to.
   * @param headers supplies the headers for initializing the shadow.
   * @param options supplies the request options for the underlying asynchronous request.
   * @return OngoingRequest* pointer owned by the AsyncClient which can have additional data and
   *                         trailers sent to it. Can be null if the stream is immediately
   *                         cancelled.
   */
  virtual Http::AsyncClient::OngoingRequest*
  streamingShadow(const std::string& cluster, Http::RequestHeaderMapPtr&& headers,
                  const Http::AsyncClient::RequestOptions& options) PURE;
};

using ShadowWriterPtr = std::unique_ptr<ShadowWriter>;

} // namespace Router
} // namespace Envoy
#pragma once

#include "source/common/network/socket_interface.h"

namespace Envoy {
namespace Extensions {
namespace Network {
namespace Vcl {

class VclSocketInterfaceExtension : public Envoy::Network::SocketInterfaceExtension {
public:
  VclSocketInterfaceExtension(Envoy::Network::SocketInterface& sock_interface)
      : Envoy::Network::SocketInterfaceExtension(sock_interface) {}
};

class VclSocketInterface : public Envoy::Network::SocketInterfaceBase {
public:
  // Network::SocketInterface
  Envoy::Network::IoHandlePtr socket(Envoy::Network::Socket::Type socket_type,
                                     Envoy::Network::Address::Type addr_type,
                                     Envoy::Network::Address::IpVersion version, bool socket_v6only,
                                     const Envoy::Network::SocketCreationOptions&) const override;
  Envoy::Network::IoHandlePtr socket(Envoy::Network::Socket::Type socket_type,
                                     const Envoy::Network::Address::InstanceConstSharedPtr addr,
                                     const Envoy::Network::SocketCreationOptions&) const override;
  bool ipFamilySupported(int domain) override;

  // Server::Configuration::BootstrapExtensionFactory
  Server::BootstrapExtensionPtr
  createBootstrapExtension(const Protobuf::Message& config,
                           Server::Configuration::ServerFactoryContext& context) override;
  ProtobufTypes::MessagePtr createEmptyConfigProto() override;
  std::string name() const override { return "envoy.extensions.vcl.vcl_socket_interface"; };
};

DECLARE_FACTORY(VclSocketInterface);

} // namespace Vcl
} // namespace Network
} // namespace Extensions
} // namespace Envoy
#include "contrib/vcl/source/vcl_interface.h"

#include "source/common/network/address_impl.h"

#include "contrib/vcl/source/vcl_io_handle.h"
#include "vppcom.h"

namespace Envoy {
namespace Extensions {
namespace Network {
namespace Vcl {

namespace {

/**
 * Max number of epoll events to drain from VCL per `vppcom_epoll_wait` call
 */
const int MaxNumEpollEvents = 128;

/**
 * Envoy worker epoll session handles by VCL worker index, i.e., `vppcom_worker_index()`. Each
 * worker uses its respective handle to retrieve session events from VCL via `vppcom_epoll_wait()`.
 */
std::vector<uint32_t>& epollHandles() { MUTABLE_CONSTRUCT_ON_FIRST_USE(std::vector<uint32_t>); }

/**
 * Mutex only used during VCL worker registration
 */
ABSL_CONST_INIT absl::Mutex wrk_lock(absl::kConstInit);

/**
 * Map of VCL workers to message queue eventfd file events
 */
using MqFileEventsMap = absl::flat_hash_map<int, Envoy::Event::FileEventPtr>;
MqFileEventsMap& mqFileEventsMap() { MUTABLE_CONSTRUCT_ON_FIRST_USE(MqFileEventsMap); }

void onMqSocketEvents(uint32_t flags) {
  ASSERT((flags & (Event::FileReadyType::Read | Event::FileReadyType::Write)));
  int wrk_index = vppcom_worker_index();
  VCL_LOG("events on worker {}", wrk_index);
  struct epoll_event events[MaxNumEpollEvents];
  int max_events = MaxNumEpollEvents;
  uint32_t epoll_fd = vclEpollHandle(wrk_index);

  while (max_events > 0) {
    int n_events = vppcom_epoll_wait(epoll_fd, events, max_events, 0);
    if (n_events <= 0) {
      break;
    }
    max_events -= n_events;
    VCL_LOG("had {} events", n_events);

    for (int i = 0; i < n_events; i++) {
      auto vcl_handle = reinterpret_cast<VclIoHandle*>(events[i].data.u64);
      if (vcl_handle->isWrkListener()) {
        vcl_handle = vcl_handle->getParentListener();
      }

      // session closed due to some recently processed event
      if (!vcl_handle->isOpen()) {
        continue;
      }

      uint32_t evts = 0;
      if (events[i].events & EPOLLIN) {
        evts |= Event::FileReadyType::Read;
      }
      if (events[i].events & EPOLLOUT) {
        evts |= Event::FileReadyType::Write;
      }
      if (events[i].events & (EPOLLERR | EPOLLHUP)) {
        evts |= Event::FileReadyType::Closed;
      }

      VCL_LOG("got event on vcl handle fd {} sh {:x} events {}", vcl_handle->fdDoNotUse(),
              vcl_handle->sh(), evts);
      vcl_handle->cb(evts);
    }
  }

  // There might be more unhandled events, so program drain
  if (max_events == 0) {
    vclInterfaceDrainEvents();
  }
}

} // namespace

uint32_t vclEpollHandle(uint32_t wrk_index) {
  std::vector<uint32_t>& epoll_handles = epollHandles();
  RELEASE_ASSERT(wrk_index < epoll_handles.size(), "epoll handles worker index");
  return epoll_handles[wrk_index];
}

void vclInterfaceWorkerRegister() {
  {
    absl::MutexLock lk(&wrk_lock);
    RELEASE_ASSERT(vppcom_worker_register() == VPPCOM_OK, "failed to register VCL worker");
  }
  const int wrk_index = vppcom_worker_index();
  int epoll_handle = vppcom_epoll_create();
  std::vector<uint32_t>& epoll_handles = epollHandles();
  RELEASE_ASSERT(static_cast<size_t>(wrk_index) < epoll_handles.size(),
                 "epoll handles worker index");
  epoll_handles[wrk_index] = epoll_handle;
  VCL_LOG("registered worker {} and epoll handle {:x} mq fd {}", wrk_index, epoll_handle,
          vppcom_mq_epoll_fd());
}

void vclInterfaceRegisterEpollEvent(Envoy::Event::Dispatcher& dispatcher) {
  MqFileEventsMap& mq_fevts_map = mqFileEventsMap();
  const int wrk_index = vppcom_worker_index();
  RELEASE_ASSERT(wrk_index != -1, "");
  if (mq_fevts_map.find(wrk_index) != mq_fevts_map.end()) {
    return;
  }
  mq_fevts_map[wrk_index] = dispatcher.createFileEvent(
      vppcom_mq_epoll_fd(), [](uint32_t events) -> void { onMqSocketEvents(events); },
      Event::FileTriggerType::Edge, Event::FileReadyType::Read | Event::FileReadyType::Write);
}

void vclInterfaceInit(Event::Dispatcher& dispatcher, uint32_t concurrency) {
  MqFileEventsMap& mq_fevts_map = mqFileEventsMap();
  vppcom_app_create("envoy");
  const int wrk_index = vppcom_worker_index();
  std::vector<uint32_t>& epoll_handles = epollHandles();
  // Assume we may have additional threads that request network access
  epoll_handles.resize(std::max(concurrency, static_cast<uint32_t>(1)) * 2);
  epoll_handles[wrk_index] = vppcom_epoll_create();
  mq_fevts_map[wrk_index] = dispatcher.createFileEvent(
      vppcom_mq_epoll_fd(), [](uint32_t events) -> void { onMqSocketEvents(events); },
      Event::FileTriggerType::Edge, Event::FileReadyType::Read | Event::FileReadyType::Write);
}

void vclInterfaceDrainEvents() {
  MqFileEventsMap& mq_fevts_map = mqFileEventsMap();
  const int wrk_index = vppcom_worker_index();
  mq_fevts_map[wrk_index]->activate(Event::FileReadyType::Read | Event::FileReadyType::Write);
}

} // namespace Vcl
} // namespace Network
} // namespace Extensions
} // namespace Envoy
#pragma once

#include <cstdint>

#include "envoy/event/file_event.h"

#include "source/common/event/dispatcher_impl.h"
#include "source/common/event/event_impl_base.h"

#include "contrib/vcl/source/vcl_io_handle.h"

namespace Envoy {
namespace Extensions {
namespace Network {
namespace Vcl {

class VclEvent : public Envoy::Event::FileEvent {
public:
  VclEvent(Event::Dispatcher& dispatcher, VclIoHandle& io_handle, Event::FileReadyCb cb);
  ~VclEvent() override;

  // Event::FileEvent
  void activate(uint32_t events) override;
  void setEnabled(uint32_t events) override;
  void unregisterEventIfEmulatedEdge(uint32_t event) override;
  void registerEventIfEmulatedEdge(uint32_t event) override;

private:
  void mergeInjectedEventsAndRunCb();

  Event::FileReadyCb cb_;
  VclIoHandle& io_handle_;

  // Injected FileReadyType events that were scheduled by recent calls to activate() and are pending
  // delivery.
  uint32_t injected_activation_events_{};
  // Used to schedule delayed event activation. Armed iff pending_activation_events_ != 0.
  Event::SchedulableCallbackPtr activation_cb_;
};

} // namespace Vcl
} // namespace Network
} // namespace Extensions
} // namespace Envoy
#include "contrib/vcl/source/vcl_io_handle.h"

#include "source/common/buffer/buffer_impl.h"
#include "source/common/network/address_impl.h"

#include "contrib/vcl/source/vcl_event.h"
#include "contrib/vcl/source/vcl_interface.h"

namespace Envoy {
namespace Extensions {
namespace Network {
namespace Vcl {

namespace {

int vclWrkIndexOrRegister() {
  int wrk_index = vppcom_worker_index();
  if (wrk_index == -1) {
    vclInterfaceWorkerRegister();
    wrk_index = vppcom_worker_index();
  }
  return wrk_index;
}

bool peekVclSession(vcl_session_handle_t sh, vppcom_endpt_t* ep, uint32_t* proto) {
  int current_wrk = vppcom_worker_index();
  int sh_wrk = vppcom_session_worker(sh);
  uint32_t eplen = sizeof(*ep);

  // should NOT be used while system is loaded
  vppcom_worker_index_set(sh_wrk);

  if (vppcom_session_attr(sh, VPPCOM_ATTR_GET_LCL_ADDR, ep, &eplen) != VPPCOM_OK) {
    return true;
  }

  uint32_t buflen = sizeof(uint32_t);
  if (vppcom_session_attr(sh, VPPCOM_ATTR_GET_PROTOCOL, proto, &buflen) != VPPCOM_OK) {
    return true;
  }

  vppcom_worker_index_set(current_wrk);

  return false;
}

void vclEndptCopy(sockaddr* addr, socklen_t* addrlen, const vppcom_endpt_t& ep) {
  if (ep.is_ip4) {
    sockaddr_in* addr4 = reinterpret_cast<sockaddr_in*>(addr);
    addr4->sin_family = AF_INET;
    *addrlen = std::min(static_cast<unsigned int>(sizeof(struct sockaddr_in)), *addrlen);
    memcpy(&addr4->sin_addr, ep.ip, *addrlen); // NOLINT(safe-memcpy)
    addr4->sin_port = ep.port;
  } else {
    sockaddr_in6* addr6 = reinterpret_cast<sockaddr_in6*>(addr);
    addr6->sin6_family = AF_INET6;
    *addrlen = std::min(static_cast<unsigned int>(sizeof(struct sockaddr_in6)), *addrlen);
    memcpy(&addr6->sin6_addr, ep.ip, *addrlen); // NOLINT(safe-memcpy)
    addr6->sin6_port = ep.port;
  }
}

Envoy::Network::Address::InstanceConstSharedPtr vclEndptToAddress(const vppcom_endpt_t& ep,
                                                                  uint32_t sh) {
  sockaddr_storage addr;
  int len;

  if (ep.is_ip4) {
    addr.ss_family = AF_INET;
    len = sizeof(struct sockaddr_in);
    auto in4 = reinterpret_cast<struct sockaddr_in*>(&addr);
    memcpy(&in4->sin_addr, ep.ip, len); // NOLINT(safe-memcpy)
    in4->sin_port = ep.port;
  } else {
    addr.ss_family = AF_INET6;
    len = sizeof(struct sockaddr_in6);
    auto in6 = reinterpret_cast<struct sockaddr_in6*>(&addr);
    memcpy(&in6->sin6_addr, ep.ip, len); // NOLINT(safe-memcpy)
    in6->sin6_port = ep.port;
  }

  try {
    // Set v6only to false so that mapped-v6 address can be normalize to v4
    // address. Though dual stack may be disabled, it's still okay to assume the
    // address is from a dual stack socket. This is because mapped-v6 address
    // must come from a dual stack socket. An actual v6 address can come from
    // both dual stack socket and v6 only socket. If |peer_addr| is an actual v6
    // address and the socket is actually v6 only, the returned address will be
    // regarded as a v6 address from dual stack socket. However, this address is not going to be
    // used to create socket. Wrong knowledge of dual stack support won't hurt.
    return *Envoy::Network::Address::addressFromSockAddr(addr, len, /*v6only=*/false);
  } catch (const EnvoyException& e) {
    PANIC(fmt::format("Invalid remote address for fd: {}, error: {}", sh, e.what()));
  }
}

void vclEndptFromAddress(vppcom_endpt_t& endpt,
                         Envoy::Network::Address::InstanceConstSharedPtr address) {
  if (address->ip()->version() == Envoy::Network::Address::IpVersion::v4) {
    const sockaddr_in* in = reinterpret_cast<const sockaddr_in*>(address->sockAddr());
    endpt.is_ip4 = 1;
    endpt.ip = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&in->sin_addr));
    endpt.port = static_cast<uint16_t>(in->sin_port);
  } else {
    const sockaddr_in6* in6 = reinterpret_cast<const sockaddr_in6*>(address->sockAddr());
    endpt.is_ip4 = 0;
    endpt.ip = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&in6->sin6_addr));
    endpt.port = static_cast<uint16_t>(in6->sin6_port);
  }
}

// Converts a VCL return types to IoCallUint64Result.
Api::IoCallUint64Result vclCallResultToIoCallResult(const int32_t result) {
  if (result >= 0) {
    // Return nullptr as IoError upon success.
    return {static_cast<unsigned long>(result), Api::IoError::none()};
  }
  RELEASE_ASSERT(result != VPPCOM_EINVAL, "Invalid argument passed in.");
  return {/*rc=*/0, (result == VPPCOM_EAGAIN
                         // EAGAIN is frequent enough that its memory allocation should be avoided.
                         ? Envoy::Network::IoSocketError::getIoSocketEagainError()
                         : Envoy::Network::IoSocketError::create(-result))};
}

} // namespace

VclIoHandle::~VclIoHandle() {
  if (VCL_SH_VALID(sh_)) {
    VclIoHandle::close();
  }
}

Api::IoCallUint64Result VclIoHandle::close() {
  int wrk_index = vclWrkIndexOrRegister();
  int rc = 0;

  VCL_LOG("closing sh {:x}", sh_);

  if (!VCL_SH_VALID(sh_)) {
    ENVOY_LOG_MISC(info, "[{}] sh {:x} already closed is_listener {} isWrkListener{}", wrk_index,
                   sh_, is_listener_, isWrkListener());
    return {static_cast<unsigned long>(rc), Api::IoError::none()};
  }

  if (is_listener_) {
    ENVOY_LOG_MISC(info, "[{}] destroying listener sh {}", wrk_index, sh_);
    if (wrk_index) {
      if (wrk_listener_ != nullptr) {
        uint32_t sh = wrk_listener_->sh();
        RELEASE_ASSERT(wrk_index == vppcom_session_worker(sh), "listener close on wrong thread");
      }
      clearChildWrkListener();
      // sh_ not invalidated yet, waiting for destructor on main to call `vppcom_session_close`
    } else {
      clearChildWrkListener();
      rc = vppcom_session_close(sh_);
      VCL_SET_SH_INVALID(sh_);
    }
  } else {
    rc = vppcom_session_close(sh_);
    VCL_SET_SH_INVALID(sh_);
  }

  return {static_cast<unsigned long>(rc), Api::IoError::none()};
}

bool VclIoHandle::isOpen() const { return VCL_SH_VALID(sh_); }

Api::IoCallUint64Result VclIoHandle::readv(uint64_t max_length, Buffer::RawSlice* slices,
                                           uint64_t num_slice) {
  if (!VCL_SH_VALID(sh_)) {
    return vclCallResultToIoCallResult(VPPCOM_EBADFD);
  }

  VCL_LOG("reading on sh {:x}", sh_);

  uint64_t num_bytes_read = 0;
  int32_t result = 0, rv = 0;
  size_t slice_length;

  for (uint64_t i = 0; i < num_slice; i++) {
    slice_length = std::min(slices[i].len_, static_cast<size_t>(max_length - num_bytes_read));
    rv = vppcom_session_read(sh_, slices[i].mem_, slice_length);
    if (rv < 0) {
      break;
    }
    num_bytes_read += rv;
    if (static_cast<size_t>(rv) < slice_length || num_bytes_read == max_length) {
      break;
    }
  }
  result = (num_bytes_read == 0) ? rv : num_bytes_read;
  VCL_LOG("done reading on sh {:x} bytes {} result {}", sh_, num_bytes_read, result);
  return vclCallResultToIoCallResult(result);
}

#if VCL_RX_ZC
Api::IoCallUint64Result VclIoHandle::read(Buffer::Instance& buffer, absl::optional<uint64_t>) {
  vppcom_data_segment_t ds[16];
  int32_t rv;

  rv = vppcom_session_read_segments(sh_, ds, 16, ~0);
  if (rv < 0) {
    return vclCallResultToIoCallResult(rv);
  }

  uint32_t ds_index = 0, sh = sh_, len;
  int32_t n_bytes = 0;
  while (n_bytes < rv) {
    len = ds[ds_index].len;
    auto fragment = new Envoy::Buffer::BufferFragmentImpl(
        ds[ds_index].data, len,
        [&, sh](const void*, size_t data_len,
                const Envoy::Buffer::BufferFragmentImpl* this_fragment) {
          vppcom_session_free_segments(sh, data_len);
          delete this_fragment;
        });

    buffer.addBufferFragment(*fragment);
    n_bytes += len;
    ds_index += 1;
  }

  return vclCallResultToIoCallResult(rv);
}
#else
Api::IoCallUint64Result VclIoHandle::read(Buffer::Instance& buffer,
                                          absl::optional<uint64_t> max_length_opt) {
  uint64_t max_length = max_length_opt.value_or(UINT64_MAX);
  if (max_length == 0) {
    return Api::ioCallUint64ResultNoError();
  }

  Buffer::Reservation reservation = buffer.reserveForRead();
  Api::IoCallUint64Result result = readv(std::min(reservation.length(), max_length),
                                         reservation.slices(), reservation.numSlices());
  uint64_t bytes_to_commit = result.ok() ? result.return_value_ : 0;
  ASSERT(bytes_to_commit <= max_length);
  reservation.commit(bytes_to_commit);
  return result;
}
#endif

Api::IoCallUint64Result VclIoHandle::writev(const Buffer::RawSlice* slices, uint64_t num_slice) {
  if (!VCL_SH_VALID(sh_)) {
    return vclCallResultToIoCallResult(VPPCOM_EBADFD);
  }

  VCL_LOG("writing on sh {:x}", sh_);

  uint64_t num_bytes_written = 0;
  int32_t result = 0, rv = 0;

  for (uint64_t i = 0; i < num_slice; i++) {
    rv = vppcom_session_write(sh_, slices[i].mem_, slices[i].len_);
    if (rv < 0) {
      break;
    }
    num_bytes_written += rv;
  }
  result = (num_bytes_written == 0) ? rv : num_bytes_written;

  return vclCallResultToIoCallResult(result);
}

Api::IoCallUint64Result VclIoHandle::write(Buffer::Instance& buffer) {
  constexpr uint64_t MaxSlices = 16;
  Buffer::RawSliceVector slices = buffer.getRawSlices(MaxSlices);
  Api::IoCallUint64Result result = writev(slices.begin(), slices.size());
  if (result.ok() && result.return_value_ > 0) {
    buffer.drain(static_cast<uint64_t>(result.return_value_));
  }
  return result;
}

Api::IoCallUint64Result VclIoHandle::recv(void* buffer, size_t length, int flags) {
  VCL_LOG("recv on sh {:x}", sh_);
  int rv = vppcom_session_recvfrom(sh_, buffer, length, flags, nullptr);
  return vclCallResultToIoCallResult(rv);
}

Api::IoCallUint64Result VclIoHandle::sendmsg(const Buffer::RawSlice* slices, uint64_t num_slice,
                                             int, const Envoy::Network::Address::Ip*,
                                             const Envoy::Network::Address::Instance&) {
  if (!VCL_SH_VALID(sh_)) {
    return vclCallResultToIoCallResult(VPPCOM_EBADFD);
  }
  VCL_LOG("sendmsg called on {:x}", sh_);

  absl::FixedArray<iovec> iov(num_slice);
  uint64_t num_slices_to_write = 0;
  uint64_t num_bytes_written = 0;

  for (uint64_t i = 0; i < num_slice; i++) {
    if (slices[i].mem_ != nullptr && slices[i].len_ != 0) {
      iov[num_slices_to_write].iov_base = slices[i].mem_;
      iov[num_slices_to_write].iov_len = slices[i].len_;
      num_slices_to_write++;
    }
  }
  if (num_slices_to_write == 0) {
    return Api::ioCallUint64ResultNoError();
  }

  // VCL has no sendmsg semantics- Treat as a session write followed by a flush
  int result = 0;
  for (uint64_t i = 0; i < num_slices_to_write; i++) {
    int n;
    if (i < (num_slices_to_write - 1)) {
      n = vppcom_session_write(sh_, iov[i].iov_base, iov[i].iov_len);
      if (n < 0) {
        result = (num_bytes_written == 0) ? n : num_bytes_written;
        break;
      }
    } else {
      // Flush after the last segment is written
      n = vppcom_session_write_msg(sh_, iov[i].iov_base, iov[i].iov_len);
      if (n < 0) {
        result = (num_bytes_written == 0) ? n : num_bytes_written;
        break;
      }
    }
    num_bytes_written += n;
  }

  return vclCallResultToIoCallResult(result);
}

Api::IoCallUint64Result VclIoHandle::recvmsg(Buffer::RawSlice* slices, const uint64_t num_slice,
                                             uint32_t self_port, RecvMsgOutput& output) {
  if (!VCL_SH_VALID(sh_)) {
    return vclCallResultToIoCallResult(VPPCOM_EBADFD);
  }

  absl::FixedArray<iovec> iov(num_slice);
  uint64_t num_slices_for_read = 0;
  uint64_t num_bytes_recvd = 0;
  for (uint64_t i = 0; i < num_slice; i++) {
    if (slices[i].mem_ != nullptr && slices[i].len_ != 0) {
      iov[num_slices_for_read].iov_base = slices[i].mem_;
      iov[num_slices_for_read].iov_len = slices[i].len_;
      ++num_slices_for_read;
    }
  }

  // VCL has no recvmsg semantics- treat as a read into each slice, which is not
  // as cumbersome as it sounds, since VCL will simply copy from shared mem buffers
  // if the data is available.
  uint8_t ipaddr[sizeof(absl::uint128)];
  vppcom_endpt_t endpt;
  endpt.ip = ipaddr;
  endpt.port = static_cast<uint16_t>(self_port);
  int result = 0;

  for (uint64_t i = 0; i < num_slices_for_read; i++) {
    int n = vppcom_session_recvfrom(sh_, iov[i].iov_base, iov[i].iov_len, 0, &endpt);
    if (n < 0) {
      result = (num_bytes_recvd == 0) ? n : num_bytes_recvd;
      break;
    }
    if (i == 0) {
      output.msg_[0].peer_address_ = vclEndptToAddress(endpt, sh_);
    }
    num_bytes_recvd += n;
  }

  if (result < 0) {
    return vclCallResultToIoCallResult(result);
  }

  output.dropped_packets_ = nullptr;

  return vclCallResultToIoCallResult(result);
}

Api::IoCallUint64Result VclIoHandle::recvmmsg(RawSliceArrays&, uint32_t, RecvMsgOutput&) {
  PANIC("not implemented");
}

bool VclIoHandle::supportsMmsg() const { return false; }

Api::SysCallIntResult VclIoHandle::bind(Envoy::Network::Address::InstanceConstSharedPtr address) {
  if (!VCL_SH_VALID(sh_)) {
    return {-1, VPPCOM_EBADFD};
  }

  int wrk_index = vclWrkIndexOrRegister();
  RELEASE_ASSERT(wrk_index != -1, "should be initialized");

  vppcom_endpt_t endpt;
  vclEndptFromAddress(endpt, address);
  int32_t rv = vppcom_session_bind(sh_, &endpt);
  return {rv < 0 ? -1 : 0, -rv};
}

Api::SysCallIntResult VclIoHandle::listen(int) {
  int wrk_index = vclWrkIndexOrRegister();
  RELEASE_ASSERT(wrk_index != -1, "should be initialized");

  VCL_LOG("trying to listen sh {}", sh_);
  RELEASE_ASSERT(is_listener_ == false, "");
  RELEASE_ASSERT(vppcom_session_worker(sh_) == wrk_index, "");

  is_listener_ = true;

  if (!wrk_index) {
    not_listened_ = true;
  }

  return {0, 0};
}

Envoy::Network::IoHandlePtr VclIoHandle::accept(sockaddr* addr, socklen_t* addrlen) {
  int wrk_index = vclWrkIndexOrRegister();
  RELEASE_ASSERT(wrk_index != -1 && is_listener_, "must have worker and must be listener");

  uint32_t sh = sh_;
  if (wrk_index) {
    sh = wrk_listener_->sh();
    VCL_LOG("trying to accept fd {} sh {:x}", fd_, sh);
  }

  vppcom_endpt_t endpt;
  sockaddr_storage ss;
  endpt.ip = reinterpret_cast<uint8_t*>(&ss);
  int new_sh = vppcom_session_accept(sh, &endpt, O_NONBLOCK);
  if (new_sh >= 0) {
    vclEndptCopy(addr, addrlen, endpt);
    return std::make_unique<VclIoHandle>(new_sh, VclInvalidFd);
  }
  return nullptr;
}

Api::SysCallIntResult
VclIoHandle::connect(Envoy::Network::Address::InstanceConstSharedPtr address) {
  if (!VCL_SH_VALID(sh_)) {
    return {-1, VPPCOM_EBADFD};
  }
  vppcom_endpt_t endpt;
  uint8_t ipaddr[sizeof(absl::uint128)];
  endpt.ip = ipaddr;
  vclEndptFromAddress(endpt, address);
  int32_t rv = vppcom_session_connect(sh_, &endpt);
  return {rv < 0 ? -1 : 0, -rv};
}

Api::SysCallIntResult VclIoHandle::setOption(int level, int optname, const void* optval,
                                             socklen_t optlen) {
  if (!VCL_SH_VALID(sh_)) {
    return {-1, VPPCOM_EBADFD};
  }
  int32_t rv = 0;

  switch (level) {
  case SOL_TCP:
    switch (optname) {
    case TCP_NODELAY:
      rv =
          vppcom_session_attr(sh_, VPPCOM_ATTR_SET_TCP_NODELAY, const_cast<void*>(optval), &optlen);
      break;
    case TCP_MAXSEG:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_SET_TCP_USER_MSS, const_cast<void*>(optval),
                               &optlen);
      break;
    case TCP_KEEPIDLE:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_SET_TCP_KEEPIDLE, const_cast<void*>(optval),
                               &optlen);
      break;
    case TCP_KEEPINTVL:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_SET_TCP_KEEPINTVL, const_cast<void*>(optval),
                               &optlen);
      break;
    case TCP_CONGESTION:
    case TCP_CORK:
      /* Ignore */
      rv = 0;
      break;
    default:
      ENVOY_LOG(error, "setOption() SOL_TCP: sh {} optname {} unsupported!", sh_, optname);
      break;
    }
    break;
  case SOL_IPV6:
    switch (optname) {
    case IPV6_V6ONLY:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_SET_V6ONLY, const_cast<void*>(optval), &optlen);
      break;
    default:
      ENVOY_LOG(error, "setOption() SOL_IPV6: sh {} optname {} unsupported!", sh_, optname);
      break;
    }
    break;
  case SOL_SOCKET:
    switch (optname) {
    case SO_KEEPALIVE:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_SET_KEEPALIVE, const_cast<void*>(optval), &optlen);
      break;
    case SO_REUSEADDR:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_SET_REUSEADDR, const_cast<void*>(optval), &optlen);
      break;
    case SO_BROADCAST:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_SET_BROADCAST, const_cast<void*>(optval), &optlen);
      break;
    default:
      ENVOY_LOG(error, "setOption() SOL_SOCKET: sh {} optname {} unsupported!", sh_, optname);
      break;
    }
    break;
  default:
    break;
  }

  return {rv < 0 ? -1 : 0, -rv};
}

Api::SysCallIntResult VclIoHandle::getOption(int level, int optname, void* optval,
                                             socklen_t* optlen) {
  VCL_LOG("trying to get option");
  if (!VCL_SH_VALID(sh_)) {
    return {-1, VPPCOM_EBADFD};
  }
  int32_t rv = 0;

  switch (level) {
  case SOL_TCP:
    switch (optname) {
    case TCP_NODELAY:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_GET_TCP_NODELAY, optval, optlen);
      break;
    case TCP_MAXSEG:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_GET_TCP_USER_MSS, optval, optlen);
      break;
    case TCP_KEEPIDLE:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_GET_TCP_KEEPIDLE, optval, optlen);
      break;
    case TCP_KEEPINTVL:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_GET_TCP_KEEPINTVL, optval, optlen);
      break;
    case TCP_INFO:
      if (optval && optlen && (*optlen == sizeof(struct tcp_info))) {
        ENVOY_LOG(error, "getOption() TCP_INFO: sh %u optname %d unsupported!", sh_, optname);
        memset(optval, 0, *optlen);
        rv = VPPCOM_OK;
      } else {
        rv = -EFAULT;
      }
      break;
    case TCP_CONGESTION:
      *optlen = strlen("cubic");
      strncpy(static_cast<char*>(optval), "cubic", *optlen + 1);
      rv = 0;
      break;
    default:
      ENVOY_LOG(error, "getOption() SOL_TCP: sh %u optname %d unsupported!", sh_, optname);
      break;
    }
    break;
  case SOL_IPV6:
    switch (optname) {
    case IPV6_V6ONLY:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_GET_V6ONLY, optval, optlen);
      break;
    default:
      ENVOY_LOG(error, "getOption() SOL_IPV6: sh %u optname %d unsupported!", sh_, optname);
      break;
    }
    break;
  case SOL_SOCKET:
    switch (optname) {
    case SO_ACCEPTCONN:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_GET_LISTEN, optval, optlen);
      break;
    case SO_KEEPALIVE:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_GET_KEEPALIVE, optval, optlen);
      break;
    case SO_PROTOCOL:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_GET_PROTOCOL, optval, optlen);
      *static_cast<int*>(optval) = *static_cast<int*>(optval) ? SOCK_DGRAM : SOCK_STREAM;
      break;
    case SO_SNDBUF:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_GET_TX_FIFO_LEN, optval, optlen);
      break;
    case SO_RCVBUF:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_GET_RX_FIFO_LEN, optval, optlen);
      break;
    case SO_REUSEADDR:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_GET_REUSEADDR, optval, optlen);
      break;
    case SO_BROADCAST:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_GET_BROADCAST, optval, optlen);
      break;
    case SO_ERROR:
      rv = vppcom_session_attr(sh_, VPPCOM_ATTR_GET_ERROR, optval, optlen);
      break;
    default:
      ENVOY_LOG(error, "getOption() SOL_SOCKET: sh %u optname %d unsupported!", sh_, optname);
      ;
      break;
    }
    break;
  default:
    break;
  }
  return {rv < 0 ? -1 : 0, -rv};
}

Api::SysCallIntResult VclIoHandle::ioctl(unsigned long, void*, unsigned long, void*, unsigned long,
                                         unsigned long*) {
  return {0, 0};
}

Api::SysCallIntResult VclIoHandle::setBlocking(bool) {
  uint32_t flags = O_NONBLOCK;
  uint32_t buflen = sizeof(flags);
  int32_t rv = vppcom_session_attr(sh_, VPPCOM_ATTR_SET_FLAGS, &flags, &buflen);
  return {rv < 0 ? -1 : 0, -rv};
}

absl::optional<int> VclIoHandle::domain() {
  VCL_LOG("grabbing domain sh {:x}", sh_);
  return {AF_INET};
};

Envoy::Network::Address::InstanceConstSharedPtr VclIoHandle::localAddress() {
  vppcom_endpt_t ep;
  uint32_t eplen = sizeof(ep);
  uint8_t addr_buf[sizeof(struct sockaddr_in6)];
  ep.ip = addr_buf;
  if (vppcom_session_attr(sh_, VPPCOM_ATTR_GET_LCL_ADDR, &ep, &eplen)) {
    return nullptr;
  }
  return vclEndptToAddress(ep, sh_);
}

Envoy::Network::Address::InstanceConstSharedPtr VclIoHandle::peerAddress() {
  VCL_LOG("grabbing peer address sh {:x}", sh_);
  vppcom_endpt_t ep;
  uint32_t eplen = sizeof(ep);
  uint8_t addr_buf[sizeof(struct sockaddr_in6)];
  ep.ip = addr_buf;
  if (vppcom_session_attr(sh_, VPPCOM_ATTR_GET_PEER_ADDR, &ep, &eplen)) {
    return nullptr;
  }
  return vclEndptToAddress(ep, sh_);
}

void VclIoHandle::updateEvents(uint32_t events) {
  int wrk_index = vclWrkIndexOrRegister();
  VclIoHandle* vcl_handle = this;

  if (wrk_index && is_listener_) {
    vcl_handle = wrk_listener_.get();
  }

  struct epoll_event ev;
  ev.events = EPOLLET;

  if (events & Event::FileReadyType::Read) {
    ev.events |= EPOLLIN;
  }
  if (events & Event::FileReadyType::Write) {
    ev.events |= EPOLLOUT;
  }
  if (events & Event::FileReadyType::Closed) {
    ev.events |= EPOLLERR | EPOLLHUP;
  }

  ev.data.u64 = reinterpret_cast<uint64_t>(vcl_handle);

  vppcom_epoll_ctl(vclEpollHandle(wrk_index), EPOLL_CTL_MOD, vcl_handle->sh(), &ev);
  vclInterfaceDrainEvents();
}

void VclIoHandle::initializeFileEvent(Event::Dispatcher& dispatcher, Event::FileReadyCb cb,
                                      Event::FileTriggerType, uint32_t events) {
  VCL_LOG("adding events for sh {:x} fd {} isListener {}", sh_, fd_, is_listener_);

  int wrk_index = vclWrkIndexOrRegister();
  vclInterfaceRegisterEpollEvent(dispatcher);

  VclIoHandle* vcl_handle = this;

  if (is_listener_) {
    if (wrk_index) {
      // If this is not the main worker, make sure a worker listener exists
      if (!wrk_listener_) {
        vppcom_endpt_t ep;
        uint8_t addr_buf[sizeof(struct sockaddr_in6)];
        ep.ip = addr_buf;
        uint32_t proto;

        RELEASE_ASSERT(peekVclSession(sh_, &ep, &proto) == false, "peek returned");

        Address::InstanceConstSharedPtr address = vclEndptToAddress(ep, -1);
        uint32_t sh = vppcom_session_create(proto, 1);
        wrk_listener_ = std::make_unique<VclIoHandle>(sh, VclInvalidFd);
        wrk_listener_->bind(address);
        uint32_t rv = vppcom_session_listen(sh, 0 /* ignored */);
        if (rv) {
          VCL_LOG("listen failed sh {:x}", sh);
          return;
        }
        wrk_listener_->setParentListener(this);
        VCL_LOG("add worker listener sh {:x} wrk_index {} new sh {:x}", sh_, wrk_index, sh);
      }
      vcl_handle = wrk_listener_.get();
    } else if (not_listened_) {
      // On main worker, no need to create worker listeners
      vppcom_session_listen(sh_, 0 /* ignored */);
      not_listened_ = false;
    }
  }

  struct epoll_event ev;
  ev.events = EPOLLET;

  if (events & Event::FileReadyType::Read) {
    ev.events |= EPOLLIN;
  }
  if (events & Event::FileReadyType::Write) {
    ev.events |= EPOLLOUT;
  }
  if (events & Event::FileReadyType::Closed) {
    ev.events |= EPOLLERR | EPOLLHUP;
  }

  cb_ = cb;
  ev.data.u64 = reinterpret_cast<uint64_t>(vcl_handle);
  vppcom_epoll_ctl(vclEpollHandle(wrk_index), EPOLL_CTL_ADD, vcl_handle->sh(), &ev);

  file_event_ = Event::FileEventPtr{new VclEvent(dispatcher, *vcl_handle, cb)};
  vclInterfaceDrainEvents();
}

void VclIoHandle::resetFileEvents() {
  if (!file_event_) {
    return;
  }
  // Remove session from epoll fd. This makes sure that when the even is recreated events already
  // consumed are regenerated.
  int wrk_index = vclWrkIndexOrRegister();
  if (VCL_SH_VALID(sh_) && wrk_index == vppcom_session_worker(sh_)) {
    vppcom_epoll_ctl(vclEpollHandle(wrk_index), EPOLL_CTL_DEL, sh_, nullptr);
  }
  file_event_.reset();
}

IoHandlePtr VclIoHandle::duplicate() {
  VCL_LOG("duplicate called");

  // Find what must be duplicated. Assume this is ONLY called for listeners
  vppcom_endpt_t ep;
  uint8_t addr_buf[sizeof(struct sockaddr_in6)];
  ep.ip = addr_buf;
  uint32_t proto;

  RELEASE_ASSERT(peekVclSession(sh_, &ep, &proto) == false, "peek returned");

  Address::InstanceConstSharedPtr address = vclEndptToAddress(ep, -1);
  uint32_t sh = vppcom_session_create(proto, 1);
  IoHandlePtr io_handle = std::make_unique<VclIoHandle>(sh, VclInvalidFd);

  io_handle->bind(address);

  return io_handle;
}

absl::optional<std::chrono::milliseconds> VclIoHandle::lastRoundTripTime() { return {}; }

absl::optional<uint64_t> VclIoHandle::congestionWindowInBytes() const { return {}; }

} // namespace Vcl
} // namespace Network
} // namespace Extensions
} // namespace Envoy
#include "contrib/vcl/source/vcl_event.h"

#include "source/common/runtime/runtime_features.h"

namespace Envoy {
namespace Extensions {
namespace Network {
namespace Vcl {

VclEvent::VclEvent(Event::Dispatcher& dispatcher, VclIoHandle& io_handle, Event::FileReadyCb cb)
    : cb_(cb), io_handle_(io_handle), activation_cb_(dispatcher.createSchedulableCallback([this]() {
        ASSERT(injected_activation_events_ != 0);
        mergeInjectedEventsAndRunCb();
      })) {}

VclEvent::~VclEvent() {
  // Worker listeners are valid only as long as the event is valid
  if (io_handle_.isWrkListener()) {
    VclIoHandle* parentListener = io_handle_.getParentListener();
    if (parentListener) {
      parentListener->clearChildWrkListener();
    }
    if (VCL_SH_VALID(io_handle_.sh())) {
      io_handle_.close();
    }
  }
}

void VclEvent::activate(uint32_t events) {
  // events is not empty.
  ASSERT(events != 0);
  // Only supported event types are set.
  ASSERT((events & (Event::FileReadyType::Read | Event::FileReadyType::Write |
                    Event::FileReadyType::Closed)) == events);

  // Schedule the activation callback so it runs as part of the next loop iteration if it is not
  // already scheduled.
  if (injected_activation_events_ == 0) {
    ASSERT(!activation_cb_->enabled());
    activation_cb_->scheduleCallbackNextIteration();
  }
  ASSERT(activation_cb_->enabled());

  // Merge new events with pending injected events.
  injected_activation_events_ |= events;
}

void VclEvent::setEnabled(uint32_t events) { io_handle_.updateEvents(events); }

void VclEvent::mergeInjectedEventsAndRunCb() {
  uint32_t events = 0;
  if (injected_activation_events_ != 0) {
    events |= injected_activation_events_;
    injected_activation_events_ = 0;
    activation_cb_->cancel();
  }
  cb_(events);
}

void VclEvent::unregisterEventIfEmulatedEdge(uint32_t) {}

void VclEvent::registerEventIfEmulatedEdge(uint32_t) {}

} // namespace Vcl
} // namespace Network
} // namespace Extensions
} // namespace Envoy
load("@base_pip3//:requirements.bzl", "requirement")
load("@rules_cc//cc:defs.bzl", "cc_library")
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_cmake",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

# VPP Comms Lib (VCL) adaptor.

envoy_contrib_package()

cc_library(
    name = "vpp_vcl",
    srcs = [
        "external/libsvm.a",
        "external/libvlibapi.a",
        "external/libvlibmemoryclient.a",
        "external/libvppcom.a",
        "external/libvppinfra.a",
        "external/vppcom.h",
    ],
    hdrs = ["external/vppcom.h"],
    defines = ["VPP_VCL"],
    includes = ["external/"],
    tags = ["skip_on_windows"],
    visibility = ["//visibility:public"],
)

envoy_cmake(
    name = "build",
    build_data = [requirement("ply")],
    cache_entries = {
        "CMAKE_BUILD_TYPE": "Release",
        "VPP_API_TEST_BUILTIN": "OFF",
        "BUILD_SHARED_LIBS": "OFF",
        "CMAKE_ENABLE_EXPORTS": "OFF",
    },
    copts = ["-Wno-unused-variable"],
    default_cache_entries = {},
    env = {
        "PLYPATHS": "$(locations %s)" % requirement("ply"),
    },
    lib_source = "@com_github_fdio_vpp_vcl//:all",
    linkopts = ["-Wno-unused-variable"],
    out_static_libs = [
        "libvppcom.a",
        "libvppinfra.a",
        "libsvm.a",
        "libvlibapi.a",
        "libvlibmemoryclient.a",
    ],
    postfix_script = """
        mkdir -p $INSTALLDIR/lib/external $INSTALLDIR/include/external \
        && find . -name "*.a" | xargs -I{} cp -a {} $INSTALLDIR/lib/ \
        && find . -name "*.h" | xargs -I{} cp -a {} $INSTALLDIR/include
    """,
    tags = [
        "cpu:16",
        "skip_on_windows",
    ],
    targets = [
        "vppcom",
    ],
    working_directory = "src",
)

genrule(
    name = "build_files",
    outs = [
        "external/libsvm.a",
        "external/libvlibapi.a",
        "external/libvlibmemoryclient.a",
        "external/libvppcom.a",
        "external/libvppinfra.a",
        "external/vppcom.h",
    ],
    cmd = """
        EXTERNAL_DIR=$$(dirname $(location external/libsvm.a)) \
        && mkdir -p $$EXTERNAL_DIR \
        && find . -name "*.a" | xargs -I{} cp -a {} $$EXTERNAL_DIR \
        && find . -name "vppcom.h" | xargs -I{} cp -a {} $$EXTERNAL_DIR
    """,
    tools = [":build"],
)

envoy_cc_library(
    name = "vcl_interface_lib",
    srcs = [
        "vcl_event.cc",
        "vcl_interface.cc",
        "vcl_io_handle.cc",
    ],
    hdrs = [
        "vcl_event.h",
        "vcl_interface.h",
        "vcl_io_handle.h",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":vpp_vcl",
        "//envoy/event:dispatcher_interface",
        "//envoy/network:socket_interface",
        "//source/common/common:minimal_logger_lib",
        "//source/common/event:dispatcher_includes",
        "//source/common/event:dispatcher_lib",
        "//source/common/event:libevent_scheduler_lib",
        "//source/common/network:address_lib",
        "//source/common/network:io_socket_error_lib",
        "//source/common/network:socket_interface_lib",
        "//source/common/network:socket_lib",
    ],
)

envoy_cc_contrib_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    visibility = ["//visibility:public"],
    deps = [
        ":vcl_interface_lib",
        "@envoy_api//contrib/envoy/extensions/vcl/v3alpha:pkg_cc_proto",
    ],
)
#pragma once

#include <list>

#include "envoy/api/io_error.h"
#include "envoy/network/io_handle.h"

#include "source/common/common/logger.h"
#include "source/common/network/io_socket_error_impl.h"

namespace Envoy {
namespace Extensions {
namespace Network {
namespace Vcl {

using namespace Envoy::Network;

#define VCL_INVALID_SH uint32_t(~0)
#define VCL_SH_VALID(_sh) (_sh != static_cast<uint32_t>(~0))
#define VCL_SET_SH_INVALID(_sh) (_sh = static_cast<uint32_t>(~0))

class VclIoHandle : public Envoy::Network::IoHandle,
                    Logger::Loggable<Logger::Id::connection>,
                    NonCopyable {
public:
  VclIoHandle(uint32_t sh, os_fd_t fd) : sh_(sh), fd_(fd) {}
  ~VclIoHandle() override;

  // Network::IoHandle
  os_fd_t fdDoNotUse() const override { return fd_; }
  Api::IoCallUint64Result close() override;
  bool isOpen() const override;
  Api::IoCallUint64Result readv(uint64_t max_length, Buffer::RawSlice* slices,
                                uint64_t num_slice) override;
  Api::IoCallUint64Result read(Buffer::Instance& buffer,
                               absl::optional<uint64_t> max_length) override;
  Api::IoCallUint64Result writev(const Buffer::RawSlice* slices, uint64_t num_slice) override;
  Api::IoCallUint64Result write(Buffer::Instance& buffer) override;
  Api::IoCallUint64Result recv(void* buffer, size_t length, int flags) override;
  Api::IoCallUint64Result sendmsg(const Buffer::RawSlice* slices, uint64_t num_slice, int flags,
                                  const Envoy::Network::Address::Ip* self_ip,
                                  const Envoy::Network::Address::Instance& peer_address) override;
  Api::IoCallUint64Result recvmsg(Buffer::RawSlice* slices, const uint64_t num_slice,
                                  uint32_t self_port, RecvMsgOutput& output) override;
  Api::IoCallUint64Result recvmmsg(RawSliceArrays& slices, uint32_t self_port,
                                   RecvMsgOutput& output) override;
  absl::optional<std::chrono::milliseconds> lastRoundTripTime() override;
  absl::optional<uint64_t> congestionWindowInBytes() const override;

  bool supportsMmsg() const override;
  bool supportsUdpGro() const override { return false; }

  Api::SysCallIntResult bind(Envoy::Network::Address::InstanceConstSharedPtr address) override;
  Api::SysCallIntResult listen(int backlog) override;
  Envoy::Network::IoHandlePtr accept(struct sockaddr* addr, socklen_t* addrlen) override;
  Api::SysCallIntResult connect(Envoy::Network::Address::InstanceConstSharedPtr address) override;
  Api::SysCallIntResult setOption(int level, int optname, const void* optval,
                                  socklen_t optlen) override;
  Api::SysCallIntResult getOption(int level, int optname, void* optval, socklen_t* optlen) override;
  Api::SysCallIntResult ioctl(unsigned long control_code, void* in_buffer,
                              unsigned long in_buffer_len, void* out_buffer,
                              unsigned long out_buffer_len, unsigned long* bytes_returned) override;
  Api::SysCallIntResult setBlocking(bool blocking) override;
  absl::optional<int> domain() override;
  Envoy::Network::Address::InstanceConstSharedPtr localAddress() override;
  Envoy::Network::Address::InstanceConstSharedPtr peerAddress() override;
  Api::SysCallIntResult shutdown(int) override { return {0, 0}; }

  void initializeFileEvent(Event::Dispatcher& dispatcher, Event::FileReadyCb cb,
                           Event::FileTriggerType trigger, uint32_t events) override;
  void activateFileEvents(uint32_t events) override { file_event_->activate(events); }
  void enableFileEvents(uint32_t events) override { file_event_->setEnabled(events); }
  void resetFileEvents() override;
  IoHandlePtr duplicate() override;

  absl::optional<std::string> interfaceName() override { return absl::nullopt; }

  void cb(uint32_t events) { cb_(events); }
  void setCb(Event::FileReadyCb cb) { cb_ = cb; }
  void updateEvents(uint32_t events);
  uint32_t sh() const { return sh_; }
  void clearChildWrkListener() { wrk_listener_ = nullptr; }
  VclIoHandle* getParentListener() { return parent_listener_; }
  bool isWrkListener() { return parent_listener_ != nullptr; }

private:
  void setParentListener(VclIoHandle* parent_listener) { parent_listener_ = parent_listener; }

  uint32_t sh_{VCL_INVALID_SH};
  os_fd_t fd_;
  Event::FileEventPtr file_event_{nullptr};
  bool is_listener_{false};
  bool not_listened_{false};
  // Listener allocated on main thread and shared with worker. VCL listen not called on it.
  VclIoHandle* parent_listener_{nullptr};
  // Listener allocated on worker and associated to main thread (parent) listener. VCL listen called
  // on it.
  std::unique_ptr<VclIoHandle> wrk_listener_{nullptr};
  Event::FileReadyCb cb_;
};

} // namespace Vcl
} // namespace Network
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/network/socket.h"

#include "source/common/network/socket_interface.h"

#include "vppcom.h"

namespace Envoy {
namespace Extensions {
namespace Network {
namespace Vcl {

#define VCL_RX_ZC (0)
#define VCL_LOG(fmt, _args...) ENVOY_LOG_MISC(debug, "[{}] " fmt, vppcom_worker_index(), ##_args)

/**
 * VclIoHandle does not rely on linux fds. Constant lower used as invalid fd.
 */
constexpr int VclInvalidFd = 1 << 23;

/**
 * Used to initialize VCL interface when VclSocketInterface extension is loaded.
 */
void vclInterfaceInit(Event::Dispatcher& dispatcher, uint32_t concurrency);

/**
 * Register Envoy worker with VCL and allocate epoll session handle to be used to retrieve per
 * worker session events.
 */
void vclInterfaceWorkerRegister();

/**
 * Create FileEvent for VCL worker message queue `eventfd` if one does not exist. Used to signal
 * main dispatch loop that VCL has session events.
 */
void vclInterfaceRegisterEpollEvent(Envoy::Event::Dispatcher& dispatcher);

/**
 * Retrieve epoll session handle for VCL worker.
 */
uint32_t vclEpollHandle(uint32_t wrk_index);

/**
 * Force drain of events on current worker
 */
void vclInterfaceDrainEvents();

} // namespace Vcl
} // namespace Network
} // namespace Extensions
} // namespace Envoy
#include "contrib/vcl/source/config.h"

#include "contrib/envoy/extensions/vcl/v3alpha/vcl_socket_interface.pb.h"
#include "contrib/vcl/source/vcl_interface.h"
#include "contrib/vcl/source/vcl_io_handle.h"

namespace Envoy {
namespace Extensions {
namespace Network {
namespace Vcl {

Server::BootstrapExtensionPtr
VclSocketInterface::createBootstrapExtension(const Protobuf::Message&,
                                             Server::Configuration::ServerFactoryContext& ctx) {

  vclInterfaceInit(ctx.mainThreadDispatcher(), ctx.options().concurrency());
  return std::make_unique<VclSocketInterfaceExtension>(*this);
}

ProtobufTypes::MessagePtr VclSocketInterface::createEmptyConfigProto() {
  return std::make_unique<envoy::extensions::vcl::v3alpha::VclSocketInterface>();
}

Envoy::Network::IoHandlePtr VclSocketInterface::socket(
    Envoy::Network::Socket::Type socket_type, Envoy::Network::Address::Type addr_type,
    Envoy::Network::Address::IpVersion, bool, const Envoy::Network::SocketCreationOptions&) const {
  if (vppcom_worker_index() == -1) {
    vclInterfaceWorkerRegister();
  }
  VCL_LOG("trying to create socket1 epoll fd {}", vppcom_mq_epoll_fd());
  if (addr_type == Envoy::Network::Address::Type::Pipe) {
    return nullptr;
  }
  uint32_t sh = vppcom_session_create(
      socket_type == Envoy::Network::Socket::Type::Stream ? VPPCOM_PROTO_TCP : VPPCOM_PROTO_UDP, 1);
  if (!VCL_SH_VALID(sh)) {
    return nullptr;
  }
  return std::make_unique<VclIoHandle>(sh, VclInvalidFd);
}

Envoy::Network::IoHandlePtr
VclSocketInterface::socket(Envoy::Network::Socket::Type socket_type,
                           const Envoy::Network::Address::InstanceConstSharedPtr addr,
                           const Envoy::Network::SocketCreationOptions& creation_options) const {
  return socket(socket_type, addr->type(), Envoy::Network::Address::IpVersion::v4, false,
                creation_options);
}

bool VclSocketInterface::ipFamilySupported(int) { return true; };

REGISTER_FACTORY(VclSocketInterface, Server::Configuration::BootstrapExtensionFactory);

} // namespace Vcl
} // namespace Network
} // namespace Extensions
} // namespace Envoy
#include <string>

#include "source/common/common/random_generator.h"
#include "source/extensions/transport_sockets/tls/private_key/private_key_manager_impl.h"

#include "test/common/stats/stat_test_utility.h"
#include "test/mocks/common.h"
#include "test/mocks/server/transport_socket_factory_context.h"
#include "test/mocks/ssl/mocks.h"
#include "test/mocks/thread_local/mocks.h"
#include "test/test_common/environment.h"
#include "test/test_common/registry.h"
#include "test/test_common/simulated_time_system.h"
#include "test/test_common/utility.h"

#include "contrib/qat/private_key_providers/source/qat_private_key_provider.h"
#include "fake_factory.h"
#include "gtest/gtest.h"

using testing::NiceMock;
using testing::ReturnRef;

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace Qat {

envoy::extensions::transport_sockets::tls::v3::PrivateKeyProvider
parsePrivateKeyProviderFromV3Yaml(const std::string& yaml_string) {
  envoy::extensions::transport_sockets::tls::v3::PrivateKeyProvider private_key_provider;
  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml_string), private_key_provider);
  return private_key_provider;
}

class FakeSingletonManager : public Singleton::Manager {
public:
  FakeSingletonManager(LibQatCryptoSharedPtr libqat) : libqat_(libqat) {}
  Singleton::InstanceSharedPtr get(const std::string&, Singleton::SingletonFactoryCb,
                                   bool) override {
    return std::make_shared<QatManager>(libqat_);
  }

private:
  LibQatCryptoSharedPtr libqat_;
};

class QatConfigTest : public Event::TestUsingSimulatedTime, public testing::Test {
public:
  QatConfigTest()
      : api_(Api::createApiForTest(store_, time_system_)),
        libqat_(std::make_shared<FakeLibQatCryptoImpl>()), fsm_(libqat_) {
    ON_CALL(factory_context_.server_context_, api()).WillByDefault(ReturnRef(*api_));
    ON_CALL(factory_context_, sslContextManager()).WillByDefault(ReturnRef(context_manager_));
    ON_CALL(context_manager_, privateKeyMethodManager())
        .WillByDefault(ReturnRef(private_key_method_manager_));
    ON_CALL(factory_context_.server_context_, singletonManager()).WillByDefault(ReturnRef(fsm_));
  }

  Ssl::PrivateKeyMethodProviderSharedPtr createWithConfig(std::string yaml) {
    FakeQatPrivateKeyMethodFactory qat_factory;
    Registry::InjectFactory<Ssl::PrivateKeyMethodProviderInstanceFactory>
        qat_private_key_method_factory(qat_factory);

    return factory_context_.sslContextManager()
        .privateKeyMethodManager()
        .createPrivateKeyMethodProvider(parsePrivateKeyProviderFromV3Yaml(yaml), factory_context_);
  }

  Event::SimulatedTimeSystem time_system_;
  NiceMock<Server::Configuration::MockTransportSocketFactoryContext> factory_context_;
  Stats::IsolatedStoreImpl store_;
  Api::ApiPtr api_;
  NiceMock<Ssl::MockContextManager> context_manager_;
  TransportSockets::Tls::PrivateKeyMethodManagerImpl private_key_method_manager_;
  std::shared_ptr<FakeLibQatCryptoImpl> libqat_;
  FakeSingletonManager fsm_;
};

TEST_F(QatConfigTest, CreateRsa1024) {
  const std::string yaml = R"EOF(
      provider_name: qat
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.qat.v3alpha.QatPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/qat/private_key_providers/test/test_data/rsa-1024.pem" }
)EOF";

  Ssl::PrivateKeyMethodProviderSharedPtr provider = createWithConfig(yaml);
  EXPECT_NE(nullptr, provider);
  EXPECT_EQ(false, provider->checkFips());
  EXPECT_EQ(provider->isAvailable(), true);
  Ssl::BoringSslPrivateKeyMethodSharedPtr method = provider->getBoringSslPrivateKeyMethod();
  EXPECT_NE(nullptr, method);
}

TEST_F(QatConfigTest, CreateRsa2048) {
  const std::string yaml = R"EOF(
      provider_name: qat
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.qat.v3alpha.QatPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/qat/private_key_providers/test/test_data/rsa-2048.pem" }
)EOF";

  Ssl::PrivateKeyMethodProviderSharedPtr provider = createWithConfig(yaml);
  EXPECT_NE(nullptr, provider);
  EXPECT_EQ(provider->isAvailable(), true);
}

TEST_F(QatConfigTest, CreateRsa3072) {
  const std::string yaml = R"EOF(
      provider_name: qat
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.qat.v3alpha.QatPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/qat/private_key_providers/test/test_data/rsa-3072.pem" }
)EOF";

  Ssl::PrivateKeyMethodProviderSharedPtr provider = createWithConfig(yaml);
  EXPECT_NE(nullptr, provider);
  EXPECT_EQ(provider->isAvailable(), true);
}

TEST_F(QatConfigTest, CreateRsa4096) {
  const std::string yaml = R"EOF(
      provider_name: qat
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.qat.v3alpha.QatPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/qat/private_key_providers/test/test_data/rsa-4096.pem" }
)EOF";

  Ssl::PrivateKeyMethodProviderSharedPtr provider = createWithConfig(yaml);
  EXPECT_NE(nullptr, provider);
  EXPECT_EQ(provider->isAvailable(), true);
}

TEST_F(QatConfigTest, CreateEcdsaP256) {
  const std::string yaml = R"EOF(
      provider_name: qat
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.qat.v3alpha.QatPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/qat/private_key_providers/test/test_data/ecdsa-p256.pem" }
)EOF";

  Ssl::PrivateKeyMethodProviderSharedPtr provider = createWithConfig(yaml);
  EXPECT_NE(nullptr, provider);
  EXPECT_EQ(provider->isAvailable(), false);
}

TEST_F(QatConfigTest, CreateMissingPrivateKeyFile) {
  const std::string yaml = R"EOF(
      provider_name: qat
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.qat.v3alpha.QatPrivateKeyMethodConfig
        poll_delay: 0.02s
        private_key: { "filename": "{{ test_rundir }}/contrib/qat/private_key_providers/test/test_data/missing.pem" }
)EOF";

  EXPECT_THROW(createWithConfig(yaml), EnvoyException);
}

TEST_F(QatConfigTest, CreateMissingKey) {
  const std::string yaml = R"EOF(
      provider_name: qat
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.qat.v3alpha.QatPrivateKeyMethodConfig
        poll_delay: 0.02s
        )EOF";

  EXPECT_THROW_WITH_MESSAGE(createWithConfig(yaml), EnvoyException,
                            "Unexpected DataSource::specifier_case(): 0");
}

TEST_F(QatConfigTest, CreateMissingPollDelay) {
  const std::string yaml = R"EOF(
      provider_name: qat
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.qat.v3alpha.QatPrivateKeyMethodConfig
        private_key: { "filename": "{{ test_rundir }}/contrib/qat/private_key_providers/test/test_data/rsa-4096.pem" }
        )EOF";

  EXPECT_THROW_WITH_REGEX(createWithConfig(yaml), EnvoyException,
                          "Proto constraint validation failed");
}

TEST_F(QatConfigTest, CreateZeroPollDelay) {
  const std::string yaml = R"EOF(
      provider_name: qat
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.private_key_providers.qat.v3alpha.QatPrivateKeyMethodConfig
        poll_delay: 0s
        private_key: { "filename": "{{ test_rundir }}/contrib/qat/private_key_providers/test/test_data/rsa-4096.pem" }
        )EOF";

  EXPECT_THROW_WITH_REGEX(createWithConfig(yaml), EnvoyException,
                          "Proto constraint validation failed");
}

} // namespace Qat
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
-----BEGIN RSA PRIVATE KEY-----
MIIG4gIBAAKCAYEA6RGuLUt6cgyuDl9+4ygvPEwpq0/U4WfdSAFyf8IeM2ArAViK
Tqg88Q49ey+chmFD6fck6rSWyGgY8b+V3ZdSvuNqSxyhDIIxg9HIYRMc+YkcrlH8
MStMnMR9m8GDqOKIMjUwRjsYoZ0nCtAIXWqn3NTzdypVIO5ymgJi8Uqwq4yTSWrq
BDoPFoLhqHIE8WTUr7tdsphpOD4QxGg1AEg5+PQu6Rr1Uf2WcP7coVLZcqgHXTCC
svkPlvcWmb+AKApP+Oq536F7QnBVJOdBTKvoOGwS13oSPfN0TYc1LSi5V40TEA8H
flRr1z+JyPljOH9dsRvjpbWTau+CJmn3qK/4dMpj788nR7Fn+HBh3NelKhnEWtRz
EBPNN8+Fg9OhaGeX+36vfln5HGU75aNK6TPVTAgE/8oGEsPUhZ5N6ZvwSLZWnqEm
pGDgTlZUDuEWLp3PRzm3ewIqSyBJVt4kVhrwzWntDi+Dzj/pHh4pNW0qHyQsQmNm
9pNJhyAcmQjIXyqnAgMBAAECggGAJR/K1a4rH9WDOAjgBkDVXU5oaMA7kXfg2GJa
oZ0DAH31+63lweesZV02T9Pio8kEb1UNjVEcn2ltZ7xzm6tJ49wHh1VVFc/7IRse
RtArklfTuLSYbiCOgH4P3+pwFUuYFB9CxD0PjFai7Gb8nhyqBlPpP/b/PlKc8Ikm
x3Z1M64dm9kq02eIFbbdSN54iRbdhexbXWJHiEzikNZkctoOWehTPJAtuVSiTPdb
n1q6Bjhbi+15NBbV898Bu5W0TSxvCMqdUKvd9z6yUNe362yz6pNGjAtQsPWxMXSy
3s14jjjLG6+Ms+MZixZUkfBR3J9LjtiaqK6kmq0FTK8txKsyajSqDamYAGqQVqk1
R5dLlp0gYm0+nRAYJzfMLDwfNiMeLR6+0Cvbeg598Ag/b1sMVwZnH4ORrsNAYId2
L0NHfzyKT8VHhwZC4PgfTEl/pHJUpHjRylUn/SRKmFRijK7LErigJlT3LrZuaEe/
rX9aR8Y5PEpuOPbJos2LrjLvlRxJAoHBAPmF31PsxqQB2IoHpqXyWr8ho48n2v9u
qFoLJgyJzkoeYIi7zTimR77eGysKfgm+iTO+NEMpNtt+X44b6qdc1pGrQKBplgZC
+R3ZFVryrXVs4u6MO/iBFf1ZczAivZu5Tie9ipXgklicrQN/W3YvesIzTjWcnPBS
bvZ2yDBKf0Or9pZ3OmPYu7MVrzBwWUOHVZ/B2io/C+fkvKtH5mnh3CoFQHnCEY8Y
RuRbnGrS42mGPGOh7wz1ekVBkzPO9ooz0wKBwQDvHngHM4yxJrerLkGtQd62i6n7
1gLa/kgu4gtD0/pjG9MbxhX3gSFFPK4Na1tDqvmp68kzev3w7oYkiugmdDyoKla6
TZE0z/5C5nZATf88l1MTUfl7USjJ5mEYaR+UzvImbMK+Le1NaN4t44A4hEzBIzW5
m2r9fN7Iqm92oKh0Wfb3RvOHMGBEK3lH3x6e977EGani2Xnm18tvW5v+MLMYktSU
GxvI9h4y1yzZiWKQn44n/akrohxrA9+/pzMQ7V0CgcByeNo19GBFCZu/5zaq1v6O
xO32VQCBQtD1TjwMcIQ1OK5szEuf+5jalaa9HjkoW0Mye8YaMaQ7GkTYOzJxyYOe
nIQvk4ECKmODL/4+FStCvct2SNuSbBYcfpb7tFRsRpz2Wlxj2f0JrgcpnZnmJG4a
/dKZgdn13ruNUn0QunycHR4pdVVSTTH/PKl8fW5WLpY3joV58CaUIjn0Ei5A0R9i
H7quoTvQ/AA571VZJJqz5KN7yeSTe2K2txjDIeW1DYUCgcAtoDm03hA1aTbYke30
OkJdwI6BwBcxZB2v3G/b1GHNcWy5uvVMEbageHCZnOeAJOqYkqYEja5Qv6KW7G5Z
kApW6CU+TTisxBc2+rSLlpZiIFm4sQaSkizfQXc7aiudgFNSI6SRF0BVafIi/Wrk
3dGrdKV2sgIbNi1oSqUUFJmwAc6O5lnnbMKhn033+cnk+U7MKj1xTJ/m/TwTFn7Q
ZMh3ouSvEfEeSl/+wXIMXBuTju5YER2rdrZHcSjLcALdcv0CgcBRIp56FGlPDc97
gwaHZn0rK9CUmCC9YXU0R0OeBE9hv3/eTUJPIxz6N1ngVxd+kgdFAop9vUw7xLiy
pJdnKFYhiNmvvR/AdUvWvDYStzJu+C2JNpkvPeG9OcI+4JjCMdsKz94/9qYRC9VP
JfrH/0aKGCHSWGo6yAvA+QN69RfpoPKoMQCtzgmbym1VEnrkDNL0bg16QB81K0IU
6RN41OycWLAyQ97cueZOtf9EiHCweK6Bc9jlFEyu/BWxNhJa1H0=
-----END RSA PRIVATE KEY-----
-----BEGIN RSA PRIVATE KEY-----
MIIJKQIBAAKCAgEAwqLI32ZGVA+JaniDRwRtgUI1CeSX0JRoU/PD8cKpEIoBvT+Q
eJkzKoZIgGGApcjnmKsItfKelq1WMowNgB/Cd+uTBhh73+15aDEuqbXQvcShf5Rz
TMVAmgSjCZdYx7XhUyAb3wKig04dia+Ox4OVnqfVcqb+Lot72VjPkfkmMNe6AySC
B7xEWhBY+JE8o6329nDM1jfq9rE/CHevUXoH/x+e4DZiiKWsZ/RKbnm0Wwm5srI9
f1OtabyG3p4MEJhQYswif9OTf8uuIJNkycRJrOnSiIviRLgXLFKQXXr70GajCofV
sbPJcs1pHsa+K0UcevutHtmr6SRxu1juwXuoDwp2gE3vy/CQ7bwsKsOdyi1JC1TC
G+2G2nnaoFyBqSa4VT/TQNaEvt/vI8MhxNeJ+9ebLTEIPQ+bJbL4C579ICf3mUYu
QcvHxyGJQ0TzoCB8pCLAETkwIb1Sm5YRJP2xD3B+sHXdr9rQB4/5SJyvunKjpG8P
pSfa98e1/o+yBlsJQyupaAYh8RC6+cuuPQLD6KQ/SjLKtDmOFvdt2dBhfGE2mFvX
gj2ipCzK0uOTPL2kqP7h0RAu2ywWj7/kBcQycz4I3deCDAActsARpOB7NfcVCjA9
aMDlSn1zKGJAplXVh6hrXSJYEFie7rUClst8T3NcMS+cTG5Q5XXkUZN1jnkCAwEA
AQKCAgBjs4VYQoi2GLtYieEdaNw7QVHv/mPyGYOTtaPi3MdDzJ31dnEoBbobB2xu
LwP6aH6SStKMeXrZTnOAMxPbVOmGCmtmzPXvkDMHt2Hi11rVSrs7oiyp38Um4Ecv
65IzwyxoK2N7ilr7DfG9jOuDshjbi7egIoDEEPlhLcguS0VP8cG8SGA/XCZbSFJ7
CdLZOYzvUnrrJPu8YLEcQkrRXsRn4Ke+zL0OqGc3XQEftEI5/DJeokU0SwXiywr/
UFB3074hzdXCSvwck5Zf44DWhjEDXUdWYOmIMBDWyHhhGlWRvHG6PDiv7Zu8rhIy
DLZvbdiX+wIEcpZIOD32LSkofZJpM+6D1Qz61U8D5aaXE0cE9AFLPJTYMajyUEaI
FfkUb+HpmeqK8Zd/FW+97YJ7qlUIz7c4bZJsd5/Byhk5+m/KxD4LV874/EYN9/qR
pCSe61Sm5BxN29DKumHBHaeuFRbVFOp0HOvUVUqN/Vi5BKcLMGG7cdV4rSBepROq
Gpt+nHnsA44BppoGEHR9plx1wc1q4OCufT/vvMXbjG1cD7mHKX0sczQD2mUmTjbs
dOaLrKiukUemK9QmweqVgBNyIlJSRRW5xNRv++x0JJn/vLWDdiyhjdTR1Fr3WPlO
jDULe+DTsR77ZMFQHekLGNfLXymTwPK9RlNumZvMg9gmVrIhrQKCAQEA+RxfSme7
NRCSVAjdf2CnIUjSo0Mk5yI06irma1TrRfOxLdx96VDjkXmULxFVtGgv2s32yYU+
0nu/aQXz5Y4qzXkGH6KiQp0TcARzdRVgTFUtdXunjFUO3025c6h+2zoVC0bX17eZ
xgDep9wLZUWixgzjA0Ufitwa5Fm2ROl8ZX3DkDtcvf0i/UjxmkFf0G0A0lFqAPi3
5sKVGZMDmyIje5cvYL6TLtGBosKcXpf+q+YWJroo2HGwLN5ffH4KzE60G+Jgh+sF
xLkJZeazGc4dmtVtY02THMzbUHjiWHi9meuC9Za5J9ZXO1AvpX5IX9NFvXW9wuVQ
0alAJXH2FefxqwKCAQEAyAS/IHzJtnZGP4r/SbKzEHe0ojas+eyWyeq7DyhQ0vxn
R6uNCQR7Kb4+3eZob4sJe4Q2Fe0cb5ZdJZYoUf5XcRNLAW/KjNOpQPH11efZele/
U/g5sZ/bRmzuZqMIZILP0NeaVh4VxIj6nrBxBaoSnXm54fNsAmx3vvnrA2sMCZDV
Kb8v06ouBo3LzoztzaJTUPfJSamP8Uv3WErqHizoyt6S2a2n8h0x+nKGPTdzNfSw
476E5GVenzfEFMC3UrkAHayUZaY5QJgmCunba4KFHKCNM91gHv/QOj+1ZiNT2B50
mPGwtS0/UugshwLh7GWFcKP2GNHhB1eNhmaNMBakawKCAQBi2r550VY6BZx72pTD
UoCgNbzY6vE/A5UKBAIyP52pwb3i3CffKalU9nE2iGOBVwL+ilNPvx+h+VeI/sK9
qsATj949OZW4Z4rqHeoPYW84e2ixwWNIzgw70yUv34KPzqnBMti+ku5j47530Ft5
Ubv5ae3AQ3Lz8Mp/KZaqHBmwUMsFdnkkL8rtxj+SHjU+ibMUwxgU0J5x5W+zmWKJ
8m8wQVucwaO4pY0TILVa2GhIoOLTdXZ2Bg+KjqhHx+DTGLxigGAcL8i3O1KebIFQ
UTnwUpe5G3Swrh6t/Xqc7zUWWp46hRhu1aECOZzeyJFB7Z40RAAM0mFTAh4hferQ
4J1HAoIBAQCfHy+Rv9SVBKjEGmcXkUNlAWZBei/IL9CR19xypYcPIl9jo/VyTA9T
WRcYXxmMS1cC3V5NuTFbEIsPwNJY0Hdt7IRKI05HFIfcs+D4CBd6fd4nBh2X0m2W
LEjIfEDL/Ukogq00f4Cftr1yizmO4QsoHlOjjozJrNLiql2tfXa5EXCTYpbA0+0D
p8CQlIsGgXG4wzduE6gAtYeTxR1VXjLgWYsIA1/NfC5raLqkbr2IGh6zP7jnHkHV
dn7WZ64v8B9IfCgeacu4OJJjMkIt2ErfSFatARtb7fUQseg01jv4fdoSZoxGxjVP
Voc97SwgbW9n+fhpLGbR+XQMjP8bV5f7AoIBAQDwZaysVWwr6ajqrTSyHAHAI8Aa
9M8P0vxTHll4+Nnhp4qySJAghQ6Kq2+1O5mV3x2DYe0Iby4HKWUsVLFVAyZKk8TG
X6byndMhPhSF+/xgbS3tXVgjo/EbOC6WYK0qXcUX8egN9hAbSkZN/WZuWPLZI/O/
Sl0fP2uzpY46PSYcVoI57b9NKv7uO6o/gC0/bjjhclBT8cWS9r5B2LWZ6fxnz2yN
vJUtPoMdzZIVTGm9NnoW7HmHTfzWLeiOaL0dZf413mcqyyHwmE55bXv+eOFmdPem
4sG3LcKC0Yyhe2tVoZ/9zvLyi2Ufi+ycnPKZZjcHtST/7byj5Fb58n/Uyar9
-----END RSA PRIVATE KEY-----
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEID7HsWA78rq1BRIKXLDzuU9j/nKezWFV2x9+2PwhhJIRoAoGCCqGSM49
AwEHoUQDQgAElkpVgAVSb3eBsea9oYfRtWUVkZpa8g3PzzW4N/pxok2Jt//cvpqQ
0krtxLd5hX018fNi/vZ3gINciS4waO4RJA==
-----END EC PRIVATE KEY-----
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

filegroup(
    name = "certs",
    srcs = glob(["*.pem"]),
)
-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQCahx0RdJwYtXtBNI98b+xN28HmcEzRMcByJZ6FHpDnTOXmUKpF
olHYlypZ5lLSHIuPJAcUk33iXpOqJQLBv8wUR0EPUXAnsZosbhJtAlxV4BIVj0QY
3RiLaZ1QGzXS4rNiLFwJDPwVnG9tKZlRpmCmYrLb5lhBEfiG8Ug7rjKVUQIDAQAB
AoGAbTbXXZHsDS6e6UvrqYg1HCYYWfS+5g9is4pRCka7JS7dQbV7UnHRpOHaBeXa
XTPdkxJkiq9fhlFPzi4QT71tz0IQ20b+MtgqkJkMDkLhUYYN17fMtNvtTQnVmxNk
a5k9HcAkp00qPF8d8i4/quRTulRHnNbip8wpeaqRWbsrGxECQQDIng+8oXf2B51i
hYRnyLQysSRoqpFE9C2XDCrA7+e4G8UvdFPS9R9XBoOgFZvf/kjMCJxc68/15XfX
yvlHc/PNAkEAxS/Tv5PMYGYOvCiYBxPPFvOIb025iCKjA04YHDbm8LBHoRLXw+R6
DWYH9iyKB5ZJfiMTjn0wp/VharTzwwtrlQJBAI4EputH+x4mAdpO3o6B3F7OXBHk
PXZszSFSsalnq8f/kLWpSfXbJNZ8fA2FfpUw8+PMbLSzEsLmMNKIk7NreDkCQQDB
EuV4zhTtxsBiyDSjqWe6h1Zt9WLWw2NuFwdQiQlzXoekVbji3FIN0Hu3NUEp0KPB
WEML39TGgGOUgf20WvhJAkBQ4jNgi2d8y/2vlh4B3wKsI1hJvZPjkqh66KH7OyF4
Wa8lQ1gBgajTYocZkmIcf2dkrNArmMl2ozWJrFY9vSDs
-----END RSA PRIVATE KEY-----
-----BEGIN RSA PRIVATE KEY-----
MIIEpgIBAAKCAQEA+9PgIj2YvDhix2wGx5PWoTF4jLpQZuqCYeBKh40yBwCj3ljl
3G5DTx4Vb+yyvWZhnOi/bWgt2iJgoCNXGhHtwqY1/IWTDoj4403RG6EaKMmZFEf+
GsqZBtiq3r4l0B+o98CVaX9YNbdFi0bVYcoKh33CeQXBZJ9F9m/8nGJcJTbYS/7P
62n0/waQxZnFolBK2Py4OFyBqJkCVnmukTRW612h6hE1xsiA62m6mta5UsqcYwf6
jFFZmg2dzioF1eKb65lU2/M6C6a3aMnZiyO8zLVnrOfQulYSzp8xldVSMchx9ouD
Qs5Mn5D+LNYJMR9oQcAfB1CacEpg9fUk/VFPEwIDAQABAoIBAQDhz1U1nuIsNKtu
gtF5eHmGxSOBnTencTVEqqhp8BQh71MBd9l11XGJqkIywJ5t8zYoSxQL+NTUuurF
7aqW9+ipF/1k2CnLaMs0l3ygN8+LL2qSoxOZ1n1thC+D2CF0BE+xCQFxPf1M/W/g
ub1xGIhkgkI13xFRNvi3SCfN2u0hd8sVRw86SFzpD7kFf7FfQfLVSmoA/7uq7pwZ
iDjC8Np72zbRhjHiNQLvWq9KH2dq+srEOoPG1eplhatcQr2XacyKZGfi1Kuqy+a5
NchhlD6lJFQ0Tou10zrEoWuhV80NMRek+TkPV1IPYG7+EzV9fmJBlXir3Y/Z2qAF
LLscYKtRAoGBAP65uNGGDUROvmxPbsSzsskYcJxU6BGzrbO6T4r6TATZmSPuM45A
MrdUgKEsD75v1x+xzDgHXFk5ODuToFOtPg8An8VxDwCP1uAnc5dKh3mTRjslW4e+
kZlMXJvztOubYXvY62Bnh6HIjIKc/GH/g0aNQQFUWNy2jTqvlMkFiJWlAoGBAP0W
cRVq05xkFE+wE7YWX5qe+PdcBRRnE/+uw7In9sS5HDlpwKB5vSv6eF2ACKO7x1m9
8H4KshEHw+BcMaOd7LdqrclFomP8Us0DXw0v7FahOyMMKHK/6sW1iopCmKP4uyfS
A7YfMECswDxinSn5cNlUjjI/AMkz1YTb4Ub1CmRXAoGBAPgZPIIW5uUZLS+hTmoX
/JMRUt1xdXeIYi8j0EW09EXlCtuMLnrm3H7jt0VD/TGnDQi5zAbmZHQi3zpn10io
/EDwgq10KQCLGObKhjNdTAaGA2moQTY9zuJZFfpvrE+uz4wpA1iqfdh91R2Cee+Z
Rut4uU/qL4MJ6xS131zMHvRhAoGBAMmQbQHUsbH1VuPcZOZ5TS0U/U3sALOuIJRa
uMsT3wnwL5VeLybfrhTvh5tX1AmrDOrhRj7r/8Nmfs8aPgKETToLAVuyVNHy7HMR
A0u6Zizcff+8uB4j0TQjELJqtayp9UySi5gpoMFxlCzDkU4TtpewKwvDd7nGyX/l
qrZbhCpDAoGBAI4GUmYN5xGGmGhKjmGY74Kbq1G9Hw5yQObmDPCZdR7AqIMCPyCe
Yjb4htsdBBVMlyased5EWm8nVUop3PuZCPATHVVxiPsVoomJ5WakF4IqMCVdb2sA
xvjzVYG74cHcZ8YCClQolIkbbWhtWOChB0EtpxI6qUGU5zeeZL+LjKuB
-----END RSA PRIVATE KEY-----
#!/bin/bash

set -e

openssl ecparam -name prime256v1 -genkey -noout -out ecdsa-p256.pem
openssl genrsa -out rsa-1024.pem 1024
openssl genrsa -out rsa-2048.pem 2048
openssl genrsa -out rsa-3072.pem 3072
openssl genrsa -out rsa-4096.pem 4096

#include <memory>
#include <set>
#include <string>
#include <vector>

#include "source/extensions/transport_sockets/tls/private_key/private_key_manager_impl.h"

#include "test/common/stats/stat_test_utility.h"
#include "test/mocks/server/transport_socket_factory_context.h"
#include "test/test_common/environment.h"
#include "test/test_common/simulated_time_system.h"
#include "test/test_common/utility.h"

#include "contrib/qat/private_key_providers/source/qat_private_key_provider.h"
#include "fake_factory.h"
#include "gtest/gtest.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace Qat {

// Testing interface
ssl_private_key_result_t privateKeySignForTest(QatPrivateKeyConnection* ops, uint8_t* out,
                                               size_t* out_len, size_t max_out,
                                               uint16_t signature_algorithm, const uint8_t* in,
                                               size_t in_len);
ssl_private_key_result_t privateKeyDecryptForTest(QatPrivateKeyConnection* ops, uint8_t* out,
                                                  size_t* out_len, size_t max_out,
                                                  const uint8_t* in, size_t in_len);
ssl_private_key_result_t privateKeyCompleteForTest(QatPrivateKeyConnection* ops,
                                                   QatContext* qat_ctx, uint8_t* out,
                                                   size_t* out_len, size_t max_out);

namespace {

class TestCallbacks : public Envoy::Ssl::PrivateKeyConnectionCallbacks {
public:
  void onPrivateKeyMethodComplete() override{

  };
};

class FakeSingletonManager : public Singleton::Manager {
public:
  FakeSingletonManager(LibQatCryptoSharedPtr libqat) : libqat_(libqat) {}
  Singleton::InstanceSharedPtr get(const std::string&, Singleton::SingletonFactoryCb,
                                   bool) override {
    return std::make_shared<QatManager>(libqat_);
  }

private:
  LibQatCryptoSharedPtr libqat_;
};

class QatProviderTest : public testing::Test {
protected:
  QatProviderTest()
      : api_(Api::createApiForTest(store_, time_system_)),
        dispatcher_(api_->allocateDispatcher("test_thread")),
        libqat_(std::make_shared<FakeLibQatCryptoImpl>()), fsm_(libqat_) {
    handle_.setLibqat(libqat_);
    ON_CALL(factory_context_.server_context_, api()).WillByDefault(testing::ReturnRef(*api_));
    ON_CALL(factory_context_.server_context_, singletonManager())
        .WillByDefault(testing::ReturnRef(fsm_));
  }

  Stats::TestUtil::TestStore store_;
  Api::ApiPtr api_;
  Event::SimulatedTimeSystem time_system_;
  Event::DispatcherPtr dispatcher_;
  QatHandle handle_;
  std::shared_ptr<FakeLibQatCryptoImpl> libqat_;
  NiceMock<Server::Configuration::MockTransportSocketFactoryContext> factory_context_;
  FakeSingletonManager fsm_;

  // Result of an operation.
  ssl_private_key_result_t res_;

  // A size for signing and decryption operation input chosen for tests.
  static constexpr size_t in_len_ = 32;
  // Test input bytes for signing and decryption chosen for tests.
  static constexpr uint8_t in_[in_len_] = {0x7f};

  // Maximum size of out_ in all test cases.
  static constexpr size_t max_out_len_ = 256;
  uint8_t out_[max_out_len_] = {0};

  // Size of output in out_ from an operation.
  size_t out_len_ = 0;
};

class QatProviderRsaTest : public QatProviderTest {
public:
  bssl::UniquePtr<EVP_PKEY> makeRsaKey() {
    std::string file = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(
        "{{ test_rundir }}/contrib/qat/private_key_providers/test/test_data/rsa-2048.pem"));
    bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(file.data(), file.size()));

    bssl::UniquePtr<EVP_PKEY> key(EVP_PKEY_new());

    RSA* rsa = PEM_read_bio_RSAPrivateKey(bio.get(), nullptr, nullptr, nullptr);
    RELEASE_ASSERT(rsa != nullptr, "PEM_read_bio_RSAPrivateKey failed.");
    RELEASE_ASSERT(1 == EVP_PKEY_assign_RSA(key.get(), rsa), "EVP_PKEY_assign_RSA failed.");
    return key;
  }

protected:
  QatProviderRsaTest() : pkey_(makeRsaKey()) {
    rsa_ = EVP_PKEY_get0_RSA(pkey_.get());
    libqat_->setRsaKey(rsa_);
  }
  bssl::UniquePtr<EVP_PKEY> pkey_{};
  RSA* rsa_{};
};

TEST_F(QatProviderRsaTest, TestRsaPkcs1Signing) {
  // PKCS #1 v1.5.
  TestCallbacks cb;
  QatPrivateKeyConnection op(cb, *dispatcher_, handle_, bssl::UpRef(pkey_));

  res_ = privateKeySignForTest(&op, nullptr, nullptr, max_out_len_, SSL_SIGN_RSA_PKCS1_SHA256, in_,
                               in_len_);
  EXPECT_EQ(res_, ssl_private_key_retry);

  // When we called the sign operation, QAT context was registered. Ask it back so we can provide it
  // to complete() function.
  QatContext* ctx = static_cast<QatContext*>(libqat_->getQatContextPointer());
  EXPECT_NE(ctx, nullptr);

  ctx->setOpStatus(CPA_STATUS_RETRY);
  res_ = privateKeyCompleteForTest(&op, ctx, nullptr, nullptr, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_retry);

  libqat_->triggerDecrypt();
  ctx->setOpStatus(CPA_STATUS_SUCCESS);

  res_ = privateKeyCompleteForTest(&op, ctx, out_, &out_len_, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_success);
  EXPECT_NE(out_len_, 0);

  // Check the signature in out_.
  RSA* rsa = EVP_PKEY_get0_RSA(pkey_.get());

  uint8_t buf[max_out_len_] = {0};
  size_t buf_len = 0;
  EXPECT_EQ(RSA_verify_raw(rsa, &buf_len, buf, max_out_len_, out_, out_len_, RSA_PKCS1_PADDING), 1);
}

TEST_F(QatProviderRsaTest, TestRsaPSSSigning) {
  // RSA-PSS
  TestCallbacks cb;
  QatPrivateKeyConnection op(cb, *dispatcher_, handle_, bssl::UpRef(pkey_));

  res_ = privateKeySignForTest(&op, nullptr, nullptr, max_out_len_, SSL_SIGN_RSA_PSS_SHA256, in_,
                               in_len_);
  EXPECT_EQ(res_, ssl_private_key_retry);

  // When we called the sign operation, QAT context was registered. Ask it back so we can provide it
  // to complete() function.
  QatContext* ctx = static_cast<QatContext*>(libqat_->getQatContextPointer());
  EXPECT_NE(ctx, nullptr);

  ctx->setOpStatus(CPA_STATUS_RETRY);
  res_ = privateKeyCompleteForTest(&op, ctx, nullptr, nullptr, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_retry);

  libqat_->triggerDecrypt();
  ctx->setOpStatus(CPA_STATUS_SUCCESS);

  res_ = privateKeyCompleteForTest(&op, ctx, out_, &out_len_, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_success);
  EXPECT_NE(out_len_, 0);

  // Check the signature in out_.
  RSA* rsa = EVP_PKEY_get0_RSA(pkey_.get());

  uint8_t buf[max_out_len_] = {0};
  unsigned int buf_len = 0;
  const EVP_MD* md = SSL_get_signature_algorithm_digest(SSL_SIGN_RSA_PSS_SHA256);
  EXPECT_NE(md, nullptr);
  bssl::ScopedEVP_MD_CTX md_ctx;
  // Calculate the message digest (so that we can be sure that it has been signed).
  EXPECT_EQ(EVP_DigestInit_ex(md_ctx.get(), md, nullptr), 1);
  EXPECT_EQ(EVP_DigestUpdate(md_ctx.get(), in_, in_len_), 1);
  EXPECT_EQ(EVP_DigestFinal_ex(md_ctx.get(), buf, &buf_len), 1);

  EXPECT_EQ(RSA_verify_pss_mgf1(rsa, buf, buf_len, md, nullptr, -1, out_, out_len_), 1);
}

TEST_F(QatProviderRsaTest, TestRsaDecryption) {
  TestCallbacks cb;
  QatPrivateKeyConnection op(cb, *dispatcher_, handle_, bssl::UpRef(pkey_));
  RSA* rsa = EVP_PKEY_get0_RSA(pkey_.get());
  uint8_t encrypt_buf[256] = {0x0};                                              // RSA_size()
  uint8_t in_buf[128] = {'l', 'o', 'r', 'e', 'm', ' ', 'i', 'p', 's', 'u', 'm'}; // RSA_size() / 2

  int ret = RSA_public_encrypt(128, in_buf, encrypt_buf, rsa, RSA_PKCS1_PADDING);
  EXPECT_EQ(ret, RSA_size(rsa));

  res_ = privateKeyDecryptForTest(&op, nullptr, nullptr, max_out_len_, encrypt_buf, RSA_size(rsa));
  EXPECT_EQ(res_, ssl_private_key_retry);

  QatContext* ctx = static_cast<QatContext*>(libqat_->getQatContextPointer());
  EXPECT_NE(ctx, nullptr);

  ctx->setOpStatus(CPA_STATUS_RETRY);
  res_ = privateKeyCompleteForTest(&op, ctx, nullptr, nullptr, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_retry);

  libqat_->triggerDecrypt();
  ctx->setOpStatus(CPA_STATUS_SUCCESS);

  res_ = privateKeyCompleteForTest(&op, ctx, out_, &out_len_, max_out_len_);
  EXPECT_EQ(res_, ssl_private_key_success);
  EXPECT_EQ(out_len_, 256);

  // The padding is for the first 128 bytes and the data starts after that.
  for (size_t i = 0; i < 128; i++) {
    EXPECT_EQ(in_buf[i], out_[i + 128]);
  }
}

TEST_F(QatProviderRsaTest, TestFailedSigning) {
  TestCallbacks cb;
  QatPrivateKeyConnection op(cb, *dispatcher_, handle_, bssl::UpRef(pkey_));
  libqat_->cpaCyRsaDecrypt_return_value_ = CPA_STATUS_FAIL; // "fail" the decryption

  res_ = privateKeySignForTest(&op, nullptr, nullptr, max_out_len_, SSL_SIGN_RSA_PSS_SHA256, in_,
                               in_len_);
  EXPECT_EQ(res_, ssl_private_key_failure);
}

TEST_F(QatProviderRsaTest, TestQatDeviceInit) {
  std::string* key_file = new std::string(TestEnvironment::substitute(
      "{{ test_rundir }}/contrib/qat/private_key_providers/test/test_data/rsa-2048.pem"));
  envoy::config::core::v3::DataSource* private_key = new envoy::config::core::v3::DataSource();
  private_key->set_allocated_filename(key_file);

  envoy::extensions::private_key_providers::qat::v3alpha::QatPrivateKeyMethodConfig conf;
  conf.set_allocated_private_key(private_key);

  // no device found
  libqat_->icpSalUserStart_return_value_ = CPA_STATUS_FAIL;
  Ssl::PrivateKeyMethodProviderSharedPtr provider =
      std::make_shared<QatPrivateKeyMethodProvider>(conf, factory_context_, libqat_);
  EXPECT_EQ(provider->isAvailable(), false);
  delete private_key;
}

} // namespace
} // namespace Qat
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_test",
    "envoy_cc_test_library",
    "envoy_contrib_package",
)
load(
    "//contrib:all_contrib_extensions.bzl",
    "envoy_contrib_linux_x86_64_constraints",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_test_library(
    name = "test_fake_factory",
    srcs = [
        "fake_factory.cc",
    ],
    hdrs = [
        "fake_factory.h",
    ],
    external_deps = ["ssl"],
    # This makes the test targets dependent on this target only run on the desired platform.
    # The actual feature is dependent on hardware but this mock library can run on other platforms.
    target_compatible_with = envoy_contrib_linux_x86_64_constraints(),
    deps = [
        "//contrib/qat/private_key_providers/source:qat_private_key_provider_lib",
        "//envoy/api:api_interface",
        "//envoy/event:dispatcher_interface",
        "//envoy/server:transport_socket_config_interface",
        "//envoy/ssl/private_key:private_key_config_interface",
        "//envoy/ssl/private_key:private_key_interface",
        "//source/common/config:datasource_lib",
        "//source/common/config:utility_lib",
        "//source/common/protobuf:utility_lib",
        "@envoy_api//contrib/envoy/extensions/private_key_providers/qat/v3alpha:pkg_cc_proto",
        "@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto",
    ],
)

envoy_cc_test(
    name = "config_test",
    srcs = [
        "config_test.cc",
    ],
    data = [
        "//contrib/qat/private_key_providers/test/test_data:certs",
    ],
    deps = [
        ":test_fake_factory",
        "//source/common/common:random_generator_lib",
        "//source/extensions/transport_sockets/tls/private_key:private_key_manager_lib",
        "//test/mocks/runtime:runtime_mocks",
        "//test/mocks/server:server_mocks",
        "//test/mocks/ssl:ssl_mocks",
        "//test/test_common:environment_lib",
        "//test/test_common:registry_lib",
        "//test/test_common:simulated_time_system_lib",
        "//test/test_common:utility_lib",
    ],
)

envoy_cc_test(
    name = "ops_test",
    srcs = [
        "ops_test.cc",
    ],
    data = [
        "//contrib/qat/private_key_providers/test/test_data:certs",
    ],
    deps = [
        ":test_fake_factory",
        "//source/extensions/transport_sockets/tls/private_key:private_key_manager_lib",
        "//test/mocks/server:server_mocks",
        "//test/test_common:environment_lib",
        "//test/test_common:simulated_time_system_lib",
        "//test/test_common:utility_lib",
    ],
)
#include "fake_factory.h"

#include <memory>

#include "envoy/registry/registry.h"
#include "envoy/server/transport_socket_config.h"

#include "source/common/config/datasource.h"
#include "source/common/config/utility.h"
#include "source/common/protobuf/message_validator_impl.h"
#include "source/common/protobuf/utility.h"

#include "contrib/envoy/extensions/private_key_providers/qat/v3alpha/qat.pb.h"
#include "contrib/envoy/extensions/private_key_providers/qat/v3alpha/qat.pb.validate.h"
#include "contrib/qat/private_key_providers/source/qat_private_key_provider.h"
#include "openssl/rsa.h"
#include "openssl/ssl.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace Qat {

CpaStatus FakeLibQatCryptoImpl::FakeLibQatCryptoImpl::icpSalUserStart(std::string name) {
  UNREFERENCED_PARAMETER(name);
  return icpSalUserStart_return_value_;
}

CpaStatus FakeLibQatCryptoImpl::cpaCyGetNumInstances(Cpa16U* p_num_instances) {
  *p_num_instances = 1;
  return cpaCyGetNumInstances_return_value_;
}

CpaStatus FakeLibQatCryptoImpl::cpaCyGetInstances(Cpa16U num_instances,
                                                  CpaInstanceHandle* cy_instances) {
  UNREFERENCED_PARAMETER(num_instances);
  UNREFERENCED_PARAMETER(cy_instances);
  if (num_instances == 1) {
    cy_instances[0] = CPA_INSTANCE_HANDLE_SINGLE;
  }
  return cpaCyGetInstances_return_value_;
}

CpaStatus FakeLibQatCryptoImpl::cpaCySetAddressTranslation(const CpaInstanceHandle instance_handle,
                                                           CpaVirtualToPhysical virtual2_physical) {
  UNREFERENCED_PARAMETER(instance_handle);
  UNREFERENCED_PARAMETER(virtual2_physical);
  return cpaCySetAddressTranslation_return_value_;
}

CpaStatus FakeLibQatCryptoImpl::cpaCyInstanceGetInfo2(const CpaInstanceHandle instance_handle,
                                                      CpaInstanceInfo2* p_instance_info2) {
  UNREFERENCED_PARAMETER(instance_handle);
  UNREFERENCED_PARAMETER(p_instance_info2);
  return cpaCyInstanceGetInfo2_return_value_;
}

CpaStatus FakeLibQatCryptoImpl::cpaCyStartInstance(CpaInstanceHandle instance_handle) {
  UNREFERENCED_PARAMETER(instance_handle);
  return cpaCyStartInstance_return_value_;
}

void* FakeLibQatCryptoImpl::qaeMemAllocNUMA(size_t size, int node, size_t phys_alignment_byte) {
  UNREFERENCED_PARAMETER(node);
  UNREFERENCED_PARAMETER(phys_alignment_byte);
  return malloc(size);
}

void FakeLibQatCryptoImpl::qaeMemFreeNUMA(void** ptr) {
  if (ptr) {
    free(*ptr);
  }
};

bool FakeLibQatCryptoImpl::setRsaKey(RSA* rsa) {
  ASSERT(rsa != nullptr);

  RSA_get0_key(rsa, &n_, &e_, &d_);

  if (n_ == nullptr || e_ == nullptr || d_ == nullptr) {
    return false;
  }

  return true;
};

CpaStatus FakeLibQatCryptoImpl::cpaCyRsaDecrypt(const CpaInstanceHandle instance_handle,
                                                const CpaCyGenFlatBufCbFunc p_rsa_decrypt_cb,
                                                void* p_callback_tag,
                                                const CpaCyRsaDecryptOpData* p_decrypt_op_data,
                                                CpaFlatBuffer* p_output_data) {
  UNREFERENCED_PARAMETER(instance_handle);

  output_data_ = p_output_data;
  callback_tag_ = p_callback_tag;

  decrypt_cb_ = p_rsa_decrypt_cb;

  CpaCyRsaPrivateKey* key = p_decrypt_op_data->pRecipientPrivateKey;

  // Re-create the RSA object from the key data.
  BIGNUM* p = BN_bin2bn(key->privateKeyRep2.prime1P.pData,
                        key->privateKeyRep2.prime1P.dataLenInBytes, nullptr);
  BIGNUM* q = BN_bin2bn(key->privateKeyRep2.prime2Q.pData,
                        key->privateKeyRep2.prime2Q.dataLenInBytes, nullptr);
  BIGNUM* dmp1 = BN_bin2bn(key->privateKeyRep2.exponent1Dp.pData,
                           key->privateKeyRep2.exponent1Dp.dataLenInBytes, nullptr);
  BIGNUM* dmq1 = BN_bin2bn(key->privateKeyRep2.exponent2Dq.pData,
                           key->privateKeyRep2.exponent2Dq.dataLenInBytes, nullptr);
  BIGNUM* iqmp = BN_bin2bn(key->privateKeyRep2.coefficientQInv.pData,
                           key->privateKeyRep2.coefficientQInv.dataLenInBytes, nullptr);

  RSA* rsa = RSA_new();

  RSA_set0_factors(rsa, p, q);
  RSA_set0_crt_params(rsa, dmp1, dmq1, iqmp);

  if (n_ == nullptr || e_ == nullptr || d_ == nullptr) {
    ASSERT(false);
  }

  // BoringSSL needs these factors. They are set out-of-band.
  RSA_set0_key(rsa, BN_dup(n_), BN_dup(e_), BN_dup(d_));

  // Run the decrypt operation.
  output_data_->pData = static_cast<Cpa8U*>(qaeMemAllocNUMA(RSA_size(rsa), 0, 0));
  int ret = RSA_private_decrypt(RSA_size(rsa), p_decrypt_op_data->inputData.pData,
                                output_data_->pData, rsa, RSA_NO_PADDING);
  if (ret < 0) {
    return CPA_STATUS_FAIL;
  }

  output_data_->dataLenInBytes = ret;

  RSA_free(rsa);

  return cpaCyRsaDecrypt_return_value_;
};

CpaStatus FakeLibQatCryptoImpl::icpSalUserStop(void) { return CPA_STATUS_SUCCESS; };

CpaStatus FakeLibQatCryptoImpl::icpSalCyPollInstance(CpaInstanceHandle instance_handle,
                                                     Cpa32U response_quota) {
  UNREFERENCED_PARAMETER(instance_handle);
  UNREFERENCED_PARAMETER(response_quota);
  return CPA_STATUS_SUCCESS;
};

CpaStatus FakeLibQatCryptoImpl::cpaCyStopInstance(CpaInstanceHandle instance_handle) {
  UNREFERENCED_PARAMETER(instance_handle);
  return CPA_STATUS_SUCCESS;
}

Ssl::PrivateKeyMethodProviderSharedPtr
FakeQatPrivateKeyMethodFactory::createPrivateKeyMethodProviderInstance(
    const envoy::extensions::transport_sockets::tls::v3::PrivateKeyProvider& proto_config,
    Server::Configuration::TransportSocketFactoryContext& private_key_provider_context) {
  ProtobufTypes::MessagePtr message = std::make_unique<
      envoy::extensions::private_key_providers::qat::v3alpha::QatPrivateKeyMethodConfig>();

  Config::Utility::translateOpaqueConfig(proto_config.typed_config(),
                                         ProtobufMessage::getNullValidationVisitor(), *message);
  const envoy::extensions::private_key_providers::qat::v3alpha::QatPrivateKeyMethodConfig conf =
      MessageUtil::downcastAndValidate<
          const envoy::extensions::private_key_providers::qat::v3alpha::QatPrivateKeyMethodConfig&>(
          *message, private_key_provider_context.messageValidationVisitor());

  std::shared_ptr<FakeLibQatCryptoImpl> libqat = std::make_shared<FakeLibQatCryptoImpl>();
  return std::make_shared<QatPrivateKeyMethodProvider>(conf, private_key_provider_context, libqat);
}

} // namespace Qat
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#pragma once

#include <openssl/ssl.h>
#include <qat/cpa.h>

#include "envoy/extensions/transport_sockets/tls/v3/cert.pb.h"
#include "envoy/ssl/private_key/private_key.h"
#include "envoy/ssl/private_key/private_key_config.h"

#include "contrib/qat/private_key_providers/source/libqat.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace Qat {

class FakeLibQatCryptoImpl : public virtual LibQatCrypto {
public:
  FakeLibQatCryptoImpl() = default;
  CpaStatus icpSalUserStart(std::string) override;
  CpaStatus cpaCyGetNumInstances(Cpa16U* p_num_instances) override;
  CpaStatus cpaCyGetInstances(Cpa16U num_instances, CpaInstanceHandle* cy_instances) override;
  CpaStatus cpaCySetAddressTranslation(const CpaInstanceHandle instance_handle,
                                       CpaVirtualToPhysical virtual2_physical) override;
  CpaStatus cpaCyInstanceGetInfo2(const CpaInstanceHandle instance_handle,
                                  CpaInstanceInfo2* p_instance_info2) override;
  CpaStatus cpaCyStartInstance(CpaInstanceHandle instance_handle) override;
  void* qaeMemAllocNUMA(size_t size, int node, size_t phys_alignment_byte) override;
  void qaeMemFreeNUMA(void** ptr) override;
  CpaStatus cpaCyRsaDecrypt(const CpaInstanceHandle instance_handle,
                            const CpaCyGenFlatBufCbFunc p_rsa_decrypt_cb, void* p_callback_tag,
                            const CpaCyRsaDecryptOpData* p_decrypt_op_data,
                            CpaFlatBuffer* p_output_data) override;
  CpaStatus icpSalUserStop(void) override;
  CpaStatus icpSalCyPollInstance(CpaInstanceHandle instance_handle, Cpa32U response_quota) override;
  CpaStatus cpaCyStopInstance(CpaInstanceHandle instance_handle) override;

  void injectErrors(bool enabled) { inject_errors_ = enabled; }
  void triggerDecrypt() { decrypt_cb_(callback_tag_, CPA_STATUS_SUCCESS, nullptr, output_data_); }
  void* getQatContextPointer() { return callback_tag_; }

  // Set required RSA params out-of-band.
  bool setRsaKey(RSA* rsa);

  CpaStatus icpSalUserStart_return_value_{CPA_STATUS_SUCCESS};
  CpaStatus cpaCyGetNumInstances_return_value_{CPA_STATUS_SUCCESS};
  CpaStatus cpaCyGetInstances_return_value_{CPA_STATUS_SUCCESS};
  CpaStatus cpaCySetAddressTranslation_return_value_{CPA_STATUS_SUCCESS};
  CpaStatus cpaCyInstanceGetInfo2_return_value_{CPA_STATUS_SUCCESS};
  CpaStatus cpaCyStartInstance_return_value_{CPA_STATUS_SUCCESS};
  CpaStatus cpaCyRsaDecrypt_return_value_{CPA_STATUS_SUCCESS};

  void resetReturnValues() {
    icpSalUserStart_return_value_ = CPA_STATUS_SUCCESS;
    cpaCyGetNumInstances_return_value_ = CPA_STATUS_SUCCESS;
    cpaCyGetInstances_return_value_ = CPA_STATUS_SUCCESS;
    cpaCySetAddressTranslation_return_value_ = CPA_STATUS_SUCCESS;
    cpaCyInstanceGetInfo2_return_value_ = CPA_STATUS_SUCCESS;
    cpaCyStartInstance_return_value_ = CPA_STATUS_SUCCESS;
    cpaCyRsaDecrypt_return_value_ = CPA_STATUS_SUCCESS;
  }

private:
  bool inject_errors_{};
  void* callback_tag_{};
  CpaCyGenFlatBufCbFunc decrypt_cb_{};
  CpaFlatBuffer* output_data_{};

  const BIGNUM* n_{};
  const BIGNUM* e_{};
  const BIGNUM* d_{};
};

class FakeQatPrivateKeyMethodFactory : public Ssl::PrivateKeyMethodProviderInstanceFactory {
public:
  FakeQatPrivateKeyMethodFactory() = default;

  // Ssl::PrivateKeyMethodProviderInstanceFactory
  Ssl::PrivateKeyMethodProviderSharedPtr createPrivateKeyMethodProviderInstance(
      const envoy::extensions::transport_sockets::tls::v3::PrivateKeyProvider& message,
      Server::Configuration::TransportSocketFactoryContext& private_key_provider_context) override;
  std::string name() const override { return "qat"; };
};

} // namespace Qat
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/extensions/transport_sockets/tls/v3/cert.pb.h"
#include "envoy/ssl/private_key/private_key.h"
#include "envoy/ssl/private_key/private_key_config.h"

#ifndef QAT_DISABLED
#include "contrib/qat/private_key_providers/source/qat_private_key_provider.h"
#endif

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace Qat {

class QatPrivateKeyMethodFactory : public Ssl::PrivateKeyMethodProviderInstanceFactory {
  // Ssl::PrivateKeyMethodProviderInstanceFactory
  Ssl::PrivateKeyMethodProviderSharedPtr createPrivateKeyMethodProviderInstance(
      const envoy::extensions::transport_sockets::tls::v3::PrivateKeyProvider& message,
      Server::Configuration::TransportSocketFactoryContext& private_key_provider_context) override;

public:
  std::string name() const override { return "qat"; };
};

} // namespace Qat
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "contrib/qat/private_key_providers/source/libqat.h"
#include "qat/cpa_cy_im.h"
#include "qat/icp_sal_poll.h"
#include "qat/icp_sal_user.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace Qat {

class LibQatCryptoImpl : public virtual LibQatCrypto {
public:
  CpaStatus icpSalUserStart(const std::string name) override {
    return ::icp_sal_userStart(name.c_str());
  }

  CpaStatus cpaCyGetNumInstances(Cpa16U* p_num_instances) override {
    return ::cpaCyGetNumInstances(p_num_instances);
  }

  CpaStatus cpaCyGetInstances(Cpa16U num_instances, CpaInstanceHandle* cy_instances) override {
    return ::cpaCyGetInstances(num_instances, cy_instances);
  }

  CpaStatus cpaCySetAddressTranslation(const CpaInstanceHandle instance_handle,
                                       CpaVirtualToPhysical virtual2_physical) override {
    return ::cpaCySetAddressTranslation(instance_handle, virtual2_physical);
  }

  CpaStatus cpaCyInstanceGetInfo2(const CpaInstanceHandle instance_handle,
                                  CpaInstanceInfo2* p_instance_info2) override {
    return ::cpaCyInstanceGetInfo2(instance_handle, p_instance_info2);
  }

  CpaStatus cpaCyStartInstance(CpaInstanceHandle instance_handle) override {
    return ::cpaCyStartInstance(instance_handle);
  }

  void* qaeMemAllocNUMA(size_t size, int node, size_t phys_alignment_byte) override {
    return ::qaeMemAllocNUMA(size, node, phys_alignment_byte);
  }

  void qaeMemFreeNUMA(void** ptr) override { return ::qaeMemFreeNUMA(ptr); };

  CpaStatus cpaCyRsaDecrypt(const CpaInstanceHandle instance_handle,
                            const CpaCyGenFlatBufCbFunc p_rsa_decrypt_cb, void* p_callback_tag,
                            const CpaCyRsaDecryptOpData* p_decrypt_op_data,
                            CpaFlatBuffer* p_output_data) override {
    return ::cpaCyRsaDecrypt(instance_handle, p_rsa_decrypt_cb, p_callback_tag, p_decrypt_op_data,
                             p_output_data);
  };

  CpaStatus icpSalUserStop(void) override { return ::icp_sal_userStop(); };

  CpaStatus icpSalCyPollInstance(CpaInstanceHandle instance_handle,
                                 Cpa32U response_quota) override {
    return ::icp_sal_CyPollInstance(instance_handle, response_quota);
  }

  CpaStatus cpaCyStopInstance(CpaInstanceHandle instance_handle) override {
    return ::cpaCyStopInstance(instance_handle);
  };
};

} // namespace Qat
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/api/api.h"
#include "envoy/event/dispatcher.h"
#include "envoy/ssl/private_key/private_key.h"
#include "envoy/ssl/private_key/private_key_config.h"

#include "source/common/common/logger.h"

#include "contrib/envoy/extensions/private_key_providers/qat/v3alpha/qat.pb.h"
#include "contrib/qat/private_key_providers/source/libqat.h"
#include "contrib/qat/private_key_providers/source/qat.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace Qat {

class QatPrivateKeyConnection {
public:
  QatPrivateKeyConnection(Ssl::PrivateKeyConnectionCallbacks& cb, Event::Dispatcher& dispatcher,
                          QatHandle& handle, bssl::UniquePtr<EVP_PKEY> pkey);

  void registerCallback(QatContext* ctx);
  void unregisterCallback();
  QatHandle& getHandle() { return handle_; };
  EVP_PKEY* getPrivateKey() { return pkey_.get(); };

private:
  Ssl::PrivateKeyConnectionCallbacks& cb_;
  Event::Dispatcher& dispatcher_;
  Event::FileEventPtr ssl_async_event_{};
  QatHandle& handle_;
  bssl::UniquePtr<EVP_PKEY> pkey_;
};

class QatPrivateKeyMethodProvider : public virtual Ssl::PrivateKeyMethodProvider,
                                    public Logger::Loggable<Logger::Id::connection> {
public:
  QatPrivateKeyMethodProvider(
      const envoy::extensions::private_key_providers::qat::v3alpha::QatPrivateKeyMethodConfig&
          config,
      Server::Configuration::TransportSocketFactoryContext& private_key_provider_context,
      LibQatCryptoSharedPtr libqat);
  // Ssl::PrivateKeyMethodProvider
  void registerPrivateKeyMethod(SSL* ssl, Ssl::PrivateKeyConnectionCallbacks& cb,
                                Event::Dispatcher& dispatcher) override;
  void unregisterPrivateKeyMethod(SSL* ssl) override;
  bool checkFips() override;
  bool isAvailable() override;
  Ssl::BoringSslPrivateKeyMethodSharedPtr getBoringSslPrivateKeyMethod() override;

private:
  Ssl::BoringSslPrivateKeyMethodSharedPtr method_{};
  std::shared_ptr<QatManager> manager_;
  std::shared_ptr<QatSection> section_;
  Api::Api& api_;
  bssl::UniquePtr<EVP_PKEY> pkey_;
  LibQatCryptoSharedPtr libqat_{};
  bool initialized_{};
};

} // namespace Qat
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_library(
    name = "libqat_wrapper_lib",
    hdrs = [
        "libqat.h",
        "libqat_impl.h",
    ],
    external_deps = ["ssl"],
    repository = "@envoy",
    deps = ["//contrib/qat:qatlib"],
)

envoy_cc_library(
    name = "qat_private_key_provider_lib",
    srcs = [
        "qat.cc",
        "qat_private_key_provider.cc",
    ],
    hdrs = [
        "libqat.h",
        "libqat_impl.h",
        "qat.h",
        "qat_private_key_provider.h",
    ],
    external_deps = [
        "ssl",
    ],
    deps = [
        ":libqat_wrapper_lib",
        "//envoy/api:api_interface",
        "//envoy/event:dispatcher_interface",
        "//envoy/registry",
        "//envoy/server:transport_socket_config_interface",
        "//envoy/singleton:manager_interface",
        "//envoy/ssl/private_key:private_key_config_interface",
        "//envoy/ssl/private_key:private_key_interface",
        "//source/common/common:thread_lib",
        "//source/common/config:datasource_lib",
        "@envoy_api//contrib/envoy/extensions/private_key_providers/qat/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_contrib_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    defines = select({
        "//bazel:linux_x86_64": [],
        "//conditions:default": [
            "QAT_DISABLED=1",
        ],
    }),
    deps = [
        "//envoy/protobuf:message_validator_interface",
        "//envoy/registry",
        "//envoy/ssl/private_key:private_key_config_interface",
        "//envoy/ssl/private_key:private_key_interface",
        "//source/common/config:utility_lib",
        "//source/common/protobuf:utility_lib",
        "@envoy_api//contrib/envoy/extensions/private_key_providers/qat/v3alpha:pkg_cc_proto",
        "@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto",
    ] + select({
        "//bazel:linux_x86_64": [
            ":qat_private_key_provider_lib",
        ],
        "//conditions:default": [],
    }),
)
#pragma once

#include "envoy/common/pure.h"

#include "openssl/ssl.h"
#include "qat/cpa.h"
#include "qat/cpa_cy_rsa.h"
#include "qat/qae_mem.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace Qat {

class LibQatCrypto {
public:
  virtual ~LibQatCrypto() = default;

  virtual CpaStatus icpSalUserStart(const std::string name) PURE;
  virtual CpaStatus cpaCyGetNumInstances(Cpa16U* p_num_instances) PURE;
  virtual CpaStatus cpaCyGetInstances(Cpa16U num_instances, CpaInstanceHandle* cy_instances) PURE;
  virtual CpaStatus cpaCySetAddressTranslation(const CpaInstanceHandle instance_handle,
                                               CpaVirtualToPhysical virtual2_physical) PURE;
  virtual CpaStatus cpaCyInstanceGetInfo2(const CpaInstanceHandle instance_handle,
                                          CpaInstanceInfo2* p_instance_info2) PURE;
  virtual CpaStatus cpaCyStartInstance(CpaInstanceHandle instance_handle) PURE;
  virtual void* qaeMemAllocNUMA(size_t size, int node, size_t phys_alignment_byte) PURE;
  virtual void qaeMemFreeNUMA(void** ptr) PURE;
  virtual CpaStatus cpaCyRsaDecrypt(const CpaInstanceHandle instance_handle,
                                    const CpaCyGenFlatBufCbFunc p_rsa_decrypt_cb,
                                    void* p_callback_tag,
                                    const CpaCyRsaDecryptOpData* p_decrypt_op_data,
                                    CpaFlatBuffer* p_output_data) PURE;
  virtual CpaStatus icpSalUserStop(void) PURE;
  virtual CpaStatus icpSalCyPollInstance(CpaInstanceHandle instance_handle,
                                         Cpa32U response_quota) PURE;
  virtual CpaStatus cpaCyStopInstance(CpaInstanceHandle instance_handle) PURE;
};

using LibQatCryptoSharedPtr = std::shared_ptr<LibQatCrypto>;

} // namespace Qat
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#include "contrib/qat/private_key_providers/source/qat_private_key_provider.h"

#include <memory>

#include "envoy/registry/registry.h"
#include "envoy/server/transport_socket_config.h"

#include "source/common/config/datasource.h"

#include "contrib/qat/private_key_providers/source/qat.h"
#include "openssl/ssl.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace Qat {

SINGLETON_MANAGER_REGISTRATION(qat_manager);

void QatPrivateKeyConnection::registerCallback(QatContext* ctx) {

  // Get the receiving end of the notification pipe. The other end is written to by the polling
  // thread.
  int fd = ctx->getFd();

  ssl_async_event_ = dispatcher_.createFileEvent(
      fd,
      [this, ctx, fd](uint32_t) -> void {
        CpaStatus status = CPA_STATUS_FAIL;
        {
          Thread::LockGuard data_lock(ctx->data_lock_);
          int bytes = read(fd, &status, sizeof(status));
          if (bytes != sizeof(status)) {
            status = CPA_STATUS_FAIL;
          }
          if (status == CPA_STATUS_RETRY) {
            // At this point we are no longer allowed to have the status as "retry", because the
            // upper levels consider the operation complete.
            status = CPA_STATUS_FAIL;
          }
          ctx->setOpStatus(status);
        }
        this->cb_.onPrivateKeyMethodComplete();
      },
      Event::FileTriggerType::Edge, Event::FileReadyType::Read);
}

void QatPrivateKeyConnection::unregisterCallback() { ssl_async_event_ = nullptr; }

namespace {

ssl_private_key_result_t privateKeySignInternal(SSL* ssl, QatPrivateKeyConnection* ops, uint8_t*,
                                                size_t*, size_t, uint16_t signature_algorithm,
                                                const uint8_t* in, size_t in_len) {
  RSA* rsa;
  const EVP_MD* md;
  bssl::ScopedEVP_MD_CTX ctx;
  unsigned char hash[EVP_MAX_MD_SIZE];
  unsigned int hash_len;
  uint8_t* msg;
  size_t msg_len;
  int prefix_allocated = 0;
  QatContext* qat_ctx = nullptr;
  int padding = RSA_NO_PADDING;

  if (ops == nullptr) {
    return ssl_private_key_failure;
  }

  QatHandle& qat_handle = ops->getHandle();

  EVP_PKEY* rsa_pkey = ops->getPrivateKey();

  // Check if the SSL instance has correct data attached to it.
  if (rsa_pkey == nullptr) {
    goto error;
  }

  if (EVP_PKEY_id(rsa_pkey) != SSL_get_signature_algorithm_key_type(signature_algorithm)) {
    goto error;
  }

  rsa = EVP_PKEY_get0_RSA(rsa_pkey);
  if (rsa == nullptr) {
    goto error;
  }

  md = SSL_get_signature_algorithm_digest(signature_algorithm);
  if (md == nullptr) {
    goto error;
  }

  // Create QAT context which will be used for this particular signing/decryption.
  qat_ctx = new QatContext(qat_handle);
  if (qat_ctx == nullptr || !qat_ctx->init()) {
    goto error;
  }

  // The fd will become readable when the QAT operation has been completed.
  ops->registerCallback(qat_ctx);

  if (ssl) {
    // Associate the SSL instance with the QAT Context. The SSL instance might be nullptr if this is
    // called from a test context.
    if (!SSL_set_ex_data(ssl, QatManager::contextIndex(), qat_ctx)) {
      goto error;
    }
  }

  // Calculate the digest for signing.
  if (!EVP_DigestInit_ex(ctx.get(), md, nullptr) || !EVP_DigestUpdate(ctx.get(), in, in_len) ||
      !EVP_DigestFinal_ex(ctx.get(), hash, &hash_len)) {
    goto error;
  }

  // Add RSA padding to the the hash. Supported types are PSS and PKCS1.
  if (SSL_is_signature_algorithm_rsa_pss(signature_algorithm)) {
    msg_len = RSA_size(rsa);
    msg = static_cast<uint8_t*>(OPENSSL_malloc(msg_len));
    if (!msg) {
      goto error;
    }
    prefix_allocated = 1;
    if (!RSA_padding_add_PKCS1_PSS_mgf1(rsa, msg, hash, md, nullptr, -1)) {
      goto error;
    }
    padding = RSA_NO_PADDING;
  } else {
    if (!RSA_add_pkcs1_prefix(&msg, &msg_len, &prefix_allocated, EVP_MD_type(md), hash, hash_len)) {
      goto error;
    }
    padding = RSA_PKCS1_PADDING;
  }

  // Start QAT decryption (signing) operation.
  if (!qat_ctx->decrypt(msg_len, msg, rsa, padding)) {
    goto error;
  }

  if (prefix_allocated) {
    OPENSSL_free(msg);
  }

  return ssl_private_key_retry;

error:
  if (prefix_allocated) {
    OPENSSL_free(msg);
  }
  delete qat_ctx;
  return ssl_private_key_failure;
}

ssl_private_key_result_t privateKeySign(SSL* ssl, uint8_t* out, size_t* out_len, size_t max_out,
                                        uint16_t signature_algorithm, const uint8_t* in,
                                        size_t in_len) {
  return ssl == nullptr
             ? ssl_private_key_failure
             : privateKeySignInternal(ssl,
                                      static_cast<QatPrivateKeyConnection*>(
                                          SSL_get_ex_data(ssl, QatManager::connectionIndex())),
                                      out, out_len, max_out, signature_algorithm, in, in_len);
}

ssl_private_key_result_t privateKeyDecryptInternal(SSL* ssl, QatPrivateKeyConnection* ops, uint8_t*,
                                                   size_t*, size_t, const uint8_t* in,
                                                   size_t in_len) {
  RSA* rsa;
  QatContext* qat_ctx = nullptr;

  if (ops == nullptr) {
    return ssl_private_key_failure;
  }

  QatHandle& qat_handle = ops->getHandle();
  EVP_PKEY* rsa_pkey = ops->getPrivateKey();

  // Check if the SSL instance has correct data attached to it.
  if (!rsa_pkey) {
    goto error;
  }

  rsa = EVP_PKEY_get0_RSA(rsa_pkey);
  if (rsa == nullptr) {
    goto error;
  }

  // Create QAT context which will be used for this particular signing/decryption.
  qat_ctx = new QatContext(qat_handle);
  if (qat_ctx == nullptr || !qat_ctx->init()) {
    goto error;
  }

  // The fd will become readable when the QAT operation has been completed.
  ops->registerCallback(qat_ctx);

  // Associate the SSL instance with the QAT Context.
  if (ssl) {
    if (!SSL_set_ex_data(ssl, QatManager::contextIndex(), qat_ctx)) {
      goto error;
    }
  }

  // Start QAT decryption (signing) operation.
  if (!qat_ctx->decrypt(in_len, in, rsa, RSA_NO_PADDING)) {
    goto error;
  }

  return ssl_private_key_retry;

error:
  delete qat_ctx;
  return ssl_private_key_failure;
}

ssl_private_key_result_t privateKeyDecrypt(SSL* ssl, uint8_t* out, size_t* out_len, size_t max_out,
                                           const uint8_t* in, size_t in_len) {
  return ssl == nullptr
             ? ssl_private_key_failure
             : privateKeyDecryptInternal(ssl,
                                         static_cast<QatPrivateKeyConnection*>(
                                             SSL_get_ex_data(ssl, QatManager::connectionIndex())),
                                         out, out_len, max_out, in, in_len);
}

ssl_private_key_result_t privateKeyCompleteInternal(SSL* ssl, QatPrivateKeyConnection* ops,
                                                    QatContext* qat_ctx, uint8_t* out,
                                                    size_t* out_len, size_t max_out) {

  if (qat_ctx == nullptr) {
    return ssl_private_key_failure;
  }

  // Check if the QAT operation is ready yet. This can happen if someone calls
  // the top-level SSL function too early. The op status is only set from this thread.
  if (qat_ctx->getOpStatus() == CPA_STATUS_RETRY) {
    return ssl_private_key_retry;
  }

  // If this point is reached, the QAT processing must be complete. We are allowed to delete the
  // qat_ctx now without fear of the polling thread trying to use it.

  if (ops == nullptr) {
    return ssl_private_key_failure;
  }

  // Unregister the callback to prevent it from being called again when the pipe is closed.
  ops->unregisterCallback();

  // See if the operation failed.
  if (qat_ctx->getOpStatus() != CPA_STATUS_SUCCESS) {
    delete qat_ctx;
    return ssl_private_key_failure;
  }

  *out_len = qat_ctx->getDecryptedDataLength();

  if (*out_len > max_out) {
    delete qat_ctx;
    return ssl_private_key_failure;
  }

  memcpy(out, qat_ctx->getDecryptedData(), *out_len); // NOLINT(safe-memcpy)

  if (ssl) {
    SSL_set_ex_data(ssl, QatManager::contextIndex(), nullptr);
  }

  delete qat_ctx;
  return ssl_private_key_success;
}

ssl_private_key_result_t privateKeyComplete(SSL* ssl, uint8_t* out, size_t* out_len,
                                            size_t max_out) {

  if (ssl == nullptr) {
    return ssl_private_key_failure;
  }
  QatContext* qat_ctx = static_cast<QatContext*>(SSL_get_ex_data(ssl, QatManager::contextIndex()));
  QatPrivateKeyConnection* ops =
      static_cast<QatPrivateKeyConnection*>(SSL_get_ex_data(ssl, QatManager::connectionIndex()));

  return privateKeyCompleteInternal(ssl, ops, qat_ctx, out, out_len, max_out);
}

} // namespace

// External linking, meant for testing without SSL context.
ssl_private_key_result_t privateKeySignForTest(QatPrivateKeyConnection* ops, uint8_t* out,
                                               size_t* out_len, size_t max_out,
                                               uint16_t signature_algorithm, const uint8_t* in,
                                               size_t in_len) {
  return privateKeySignInternal(nullptr, ops, out, out_len, max_out, signature_algorithm, in,
                                in_len);
}
ssl_private_key_result_t privateKeyDecryptForTest(QatPrivateKeyConnection* ops, uint8_t* out,
                                                  size_t* out_len, size_t max_out,
                                                  const uint8_t* in, size_t in_len) {
  return privateKeyDecryptInternal(nullptr, ops, out, out_len, max_out, in, in_len);
}
ssl_private_key_result_t privateKeyCompleteForTest(QatPrivateKeyConnection* ops,
                                                   QatContext* qat_ctx, uint8_t* out,
                                                   size_t* out_len, size_t max_out) {
  return privateKeyCompleteInternal(nullptr, ops, qat_ctx, out, out_len, max_out);
}

Ssl::BoringSslPrivateKeyMethodSharedPtr
QatPrivateKeyMethodProvider::getBoringSslPrivateKeyMethod() {
  return method_;
}

bool QatPrivateKeyMethodProvider::checkFips() { return false; }
bool QatPrivateKeyMethodProvider::isAvailable() { return initialized_; }

QatPrivateKeyConnection::QatPrivateKeyConnection(Ssl::PrivateKeyConnectionCallbacks& cb,
                                                 Event::Dispatcher& dispatcher, QatHandle& handle,
                                                 bssl::UniquePtr<EVP_PKEY> pkey)
    : cb_(cb), dispatcher_(dispatcher), handle_(handle), pkey_(std::move(pkey)) {}

void QatPrivateKeyMethodProvider::registerPrivateKeyMethod(SSL* ssl,
                                                           Ssl::PrivateKeyConnectionCallbacks& cb,
                                                           Event::Dispatcher& dispatcher) {

  if (section_ == nullptr || !section_->isInitialized()) {
    throw EnvoyException("QAT isn't properly initialized.");
  }

  if (SSL_get_ex_data(ssl, QatManager::connectionIndex()) != nullptr) {
    throw EnvoyException(
        "Registering the QAT provider twice for same context is not yet supported.");
  }

  QatHandle& handle = section_->getNextHandle();

  QatPrivateKeyConnection* ops =
      new QatPrivateKeyConnection(cb, dispatcher, handle, bssl::UpRef(pkey_));
  SSL_set_ex_data(ssl, QatManager::connectionIndex(), ops);
}

void QatPrivateKeyMethodProvider::unregisterPrivateKeyMethod(SSL* ssl) {
  QatPrivateKeyConnection* ops =
      static_cast<QatPrivateKeyConnection*>(SSL_get_ex_data(ssl, QatManager::connectionIndex()));
  SSL_set_ex_data(ssl, QatManager::connectionIndex(), nullptr);
  delete ops;
}

QatPrivateKeyMethodProvider::QatPrivateKeyMethodProvider(
    const envoy::extensions::private_key_providers::qat::v3alpha::QatPrivateKeyMethodConfig& conf,
    Server::Configuration::TransportSocketFactoryContext& factory_context,
    LibQatCryptoSharedPtr libqat)
    : api_(factory_context.serverFactoryContext().api()), libqat_(libqat) {

  manager_ = factory_context.serverFactoryContext().singletonManager().getTyped<QatManager>(
      SINGLETON_MANAGER_REGISTERED_NAME(qat_manager),
      [libqat] { return std::make_shared<QatManager>(libqat); });

  ASSERT(manager_);

  if (!manager_->checkQatDevice()) {
    return;
  }

  std::chrono::milliseconds poll_delay =
      std::chrono::milliseconds(PROTOBUF_GET_MS_OR_DEFAULT(conf, poll_delay, 5));

  std::string private_key = Config::DataSource::read(conf.private_key(), false, api_);

  bssl::UniquePtr<BIO> bio(
      BIO_new_mem_buf(const_cast<char*>(private_key.data()), private_key.size()));

  bssl::UniquePtr<EVP_PKEY> pkey(PEM_read_bio_PrivateKey(bio.get(), nullptr, nullptr, nullptr));
  if (pkey == nullptr) {
    throw EnvoyException("Failed to read private key.");
  }

  if (EVP_PKEY_id(pkey.get()) != EVP_PKEY_RSA) {
    // TODO(ipuustin): add support also to ECDSA keys.
    ENVOY_LOG(warn, "Only RSA keys are supported.");
    return;
  }
  pkey_ = std::move(pkey);

  section_ = std::make_shared<QatSection>(libqat);
  if (!section_->startSection(api_, poll_delay)) {
    ENVOY_LOG(warn, "Failed to start QAT.");
    return;
  }

  method_ = std::make_shared<SSL_PRIVATE_KEY_METHOD>();
  method_->sign = privateKeySign;
  method_->decrypt = privateKeyDecrypt;
  method_->complete = privateKeyComplete;

  initialized_ = true;
  ENVOY_LOG(info, "initialized QAT private key provider");
}

} // namespace Qat
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#pragma once

#include <map>

#include "envoy/api/api.h"
#include "envoy/singleton/manager.h"

#include "source/common/common/lock_guard.h"
#include "source/common/common/logger.h"
#include "source/common/common/thread.h"

#include "contrib/qat/private_key_providers/source/libqat.h"
#include "openssl/err.h"
#include "openssl/rand.h"
#include "openssl/x509v3.h"

// qatlib
#include "qat/cpa.h"
#include "qat/cpa_cy_im.h"
#include "qat/cpa_cy_rsa.h"
#include "qat/icp_sal_poll.h"
#include "qat/icp_sal_user.h"
#include "qat/qae_mem.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace Qat {

const int QAT_BUFFER_SIZE = 1024;

/**
 * Represents a QAT hardware instance.
 */
class QatHandle : public Logger::Loggable<Logger::Id::connection> {
public:
  QatHandle() = default;
  ~QatHandle();
  // TODO(ipuustin): getters and setters
  void setLibqat(LibQatCryptoSharedPtr libqat);
  LibQatCryptoSharedPtr getLibqat();
  bool initQatInstance(CpaInstanceHandle handle, LibQatCryptoSharedPtr libqat);
  CpaInstanceHandle getHandle();
  void addUser();
  void removeUser();
  bool hasUsers();
  int getNodeAffinity();
  int isDone();

  Thread::ThreadPtr polling_thread_{};
  Thread::MutexBasicLockable poll_lock_{};
  Thread::CondVar qat_thread_cond_{};

private:
  CpaInstanceHandle handle_;
  CpaInstanceInfo2 info_;
  LibQatCryptoSharedPtr libqat_{};
  int users_{};
  bool done_{};
};

/**
 * QatSection represents a section definition in QAT configuration. Its main purpose is to initalize
 * HW and load balance operations to the QAT handles.
 */
class QatSection : public Logger::Loggable<Logger::Id::connection> {
public:
  QatSection(LibQatCryptoSharedPtr libqat);
  bool startSection(Api::Api& api, std::chrono::milliseconds poll_delay);
  QatHandle& getNextHandle();
  bool isInitialized();

private:
  Thread::MutexBasicLockable handle_lock_{};
  Cpa16U num_instances_{};
  std::vector<QatHandle> qat_handles_;
  int next_handle_{};
  LibQatCryptoSharedPtr libqat_{};
};

/**
 * QatManager is a singleton to oversee QAT hardware.
 */
class QatManager : public std::enable_shared_from_this<QatManager>,
                   public Singleton::Instance,
                   public Logger::Loggable<Logger::Id::connection> {
public:
  static void qatPoll(QatHandle& handle, std::chrono::milliseconds poll_delay);

  QatManager(LibQatCryptoSharedPtr libqat);
  ~QatManager() override;

  static int connectionIndex();
  static int contextIndex();

  bool checkQatDevice();

private:
  LibQatCryptoSharedPtr libqat_{};
  bool qat_is_supported_{true};
};

/**
 * Represents a single QAT operation context.
 */
class QatContext {
public:
  QatContext(QatHandle& handle);
  ~QatContext();
  bool init();
  QatHandle& getHandle();
  int getDecryptedDataLength();
  unsigned char* getDecryptedData();
  bool copyDecryptedData(unsigned char* bytes, int len);
  void setOpStatus(CpaStatus status);
  CpaStatus getOpStatus();
  int getFd();
  int getWriteFd();
  bool decrypt(int len, const unsigned char* from, RSA* rsa, int padding);
  void freeDecryptOpBuf(CpaCyRsaDecryptOpData* dec_op_data, CpaFlatBuffer* out_buf);
  void freeNuma(void* ptr);

  Thread::MutexBasicLockable data_lock_{};

  LibQatCryptoSharedPtr getLibqat();

private:
  // TODO(ipuustin): QatHandle might be a more logical place for these.
  bool convertBnToFlatbuffer(CpaFlatBuffer* fb, const BIGNUM* bn);
  bool buildDecryptOpBuf(int flen, const unsigned char* from, RSA* rsa, int padding,
                         CpaCyRsaDecryptOpData** dec_op_data, CpaFlatBuffer** output_buffer);

  QatHandle& handle_;
  CpaStatus last_status_{CPA_STATUS_RETRY};
  unsigned char decrypted_data_[QAT_BUFFER_SIZE];
  int decrypted_data_length_{0};
  // Pipe for passing the message that the operation is completed.
  int read_fd_{-1};
  int write_fd_{-1};
};

} // namespace Qat
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#include "contrib/qat/private_key_providers/source/config.h"

#include <memory>

#include "envoy/registry/registry.h"
#include "envoy/server/transport_socket_config.h"

#include "source/common/config/utility.h"
#include "source/common/protobuf/message_validator_impl.h"
#include "source/common/protobuf/utility.h"

#include "contrib/envoy/extensions/private_key_providers/qat/v3alpha/qat.pb.h"
#include "contrib/envoy/extensions/private_key_providers/qat/v3alpha/qat.pb.validate.h"
#include "openssl/ssl.h"

#ifndef QAT_DISABLED
#include "contrib/qat/private_key_providers/source/libqat_impl.h"
#endif

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace Qat {

Ssl::PrivateKeyMethodProviderSharedPtr
QatPrivateKeyMethodFactory::createPrivateKeyMethodProviderInstance(
    const envoy::extensions::transport_sockets::tls::v3::PrivateKeyProvider& proto_config,
    Server::Configuration::TransportSocketFactoryContext& private_key_provider_context) {
  ProtobufTypes::MessagePtr message = std::make_unique<
      envoy::extensions::private_key_providers::qat::v3alpha::QatPrivateKeyMethodConfig>();

  Config::Utility::translateOpaqueConfig(proto_config.typed_config(),
                                         ProtobufMessage::getNullValidationVisitor(), *message);
  const envoy::extensions::private_key_providers::qat::v3alpha::QatPrivateKeyMethodConfig conf =
      MessageUtil::downcastAndValidate<
          const envoy::extensions::private_key_providers::qat::v3alpha::QatPrivateKeyMethodConfig&>(
          *message, private_key_provider_context.messageValidationVisitor());

#ifdef QAT_DISABLED
  throw EnvoyException("X86_64 architecture is required for QAT.");
#else
  LibQatCryptoSharedPtr libqat = std::make_shared<LibQatCryptoImpl>();
  return std::make_shared<QatPrivateKeyMethodProvider>(conf, private_key_provider_context, libqat);
#endif
}

REGISTER_FACTORY(QatPrivateKeyMethodFactory, Ssl::PrivateKeyMethodProviderInstanceFactory);

} // namespace Qat
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
#include "contrib/qat/private_key_providers/source/qat.h"

#include "libqat.h"
#include "openssl/rsa.h"
#include "openssl/ssl.h"

namespace Envoy {
namespace Extensions {
namespace PrivateKeyMethodProvider {
namespace Qat {

QatManager::QatManager(LibQatCryptoSharedPtr libqat) {
  // Since we want to use VFs, it means that the section name doesn't
  // really matter but it needs to be a non-empty string. Use "SSL"
  // because that's what the qatlib tests use.

  libqat_ = libqat;
  CpaStatus status = libqat_->icpSalUserStart("SSL");
  if (status != CPA_STATUS_SUCCESS) {
    ENVOY_LOG(warn, "Failed to start QAT device.");
    qat_is_supported_ = false;
  }
}

QatManager::~QatManager() {
  // The idea is that icp_sal_userStop() is called after the instances have been stopped and the
  // polling threads exited. Since QatManager is a singleton this is done only once.

  libqat_->icpSalUserStop();
}

void QatManager::qatPoll(QatHandle& handle, std::chrono::milliseconds poll_delay) {
  ENVOY_LOG(debug, "created QAT polling thread");
  while (1) {
    {
      Thread::LockGuard poll_lock(handle.poll_lock_);

      if (handle.isDone()) {
        return;
      }

      // Wait for an event which tells that a QAT request has been made.
      if (!handle.hasUsers()) {
        handle.qat_thread_cond_.wait(handle.poll_lock_);
      }
    }

    handle.getLibqat()->icpSalCyPollInstance(handle.getHandle(), 0);

    // Sleep for a while.
    std::this_thread::sleep_for(poll_delay); // NO_CHECK_FORMAT(real_time)
  }
  ENVOY_LOG(debug, "joined QAT polling thread");
}

namespace {
int createIndex() {
  int index = SSL_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);
  RELEASE_ASSERT(index >= 0, "Failed to get SSL user data index.");
  return index;
}
} // namespace

int QatManager::connectionIndex() { CONSTRUCT_ON_FIRST_USE(int, createIndex()); }

int QatManager::contextIndex() { CONSTRUCT_ON_FIRST_USE(int, createIndex()); }

bool QatManager::checkQatDevice() { return qat_is_supported_; }

QatHandle::~QatHandle() {
  if (polling_thread_ == nullptr) {
    return;
  }
  {
    Thread::LockGuard poll_lock(poll_lock_);
    done_ = true;
    qat_thread_cond_.notifyOne();
  }
  polling_thread_->join();

  libqat_->cpaCyStopInstance(handle_);
};

bool QatHandle::initQatInstance(CpaInstanceHandle handle, LibQatCryptoSharedPtr libqat) {
  libqat_ = libqat;
  handle_ = handle;

  CpaStatus status = libqat_->cpaCySetAddressTranslation(handle_, qaeVirtToPhysNUMA);
  if (status != CPA_STATUS_SUCCESS) {
    return false;
  }

  status = libqat_->cpaCyInstanceGetInfo2(handle_, &info_);
  if (status != CPA_STATUS_SUCCESS) {
    return false;
  }

  status = libqat_->cpaCyStartInstance(handle_);
  if (status != CPA_STATUS_SUCCESS) {
    return false;
  }

  return true;
}

void QatHandle::setLibqat(LibQatCryptoSharedPtr libqat) { libqat_ = libqat; }

LibQatCryptoSharedPtr QatHandle::getLibqat() { return libqat_; }

CpaInstanceHandle QatHandle::getHandle() { return handle_; }

void QatHandle::addUser() { users_++; };

void QatHandle::removeUser() {
  ASSERT(users_ > 0);
  users_--;
};

bool QatHandle::hasUsers() { return users_ > 0; };

int QatHandle::getNodeAffinity() { return info_.nodeAffinity; }

int QatHandle::isDone() { return done_; }

QatSection::QatSection(LibQatCryptoSharedPtr libqat) : libqat_(libqat){};

bool QatSection::startSection(Api::Api& api, std::chrono::milliseconds poll_delay) {

  // This function is called from a single-thread environment (server startup) to
  // initialize QAT for this particular section (or process name).

  CpaStatus status = libqat_->cpaCyGetNumInstances(&num_instances_);
  if ((status != CPA_STATUS_SUCCESS) || (num_instances_ <= 0)) {
    return false;
  }

  ENVOY_LOG(debug, "found {} QAT instances", num_instances_);

  CpaInstanceHandle* handles = new CpaInstanceHandle[num_instances_];

  status = libqat_->cpaCyGetInstances(num_instances_, handles);
  if (status != CPA_STATUS_SUCCESS) {
    delete[] handles;
    return false;
  }

  qat_handles_ = std::vector<QatHandle>(num_instances_);

  for (int i = 0; i < num_instances_; i++) {
    if (!qat_handles_[i].initQatInstance(handles[i], libqat_)) {
      delete[] handles;
      return false;
    }

    // Every handle has a polling thread associated with it. This is needed
    // until qatlib implements event-based notifications when the QAT operation
    // is ready.
    qat_handles_[i].polling_thread_ =
        api.threadFactory().createThread([this, poll_delay, i]() -> void {
          QatManager::qatPoll(this->qat_handles_[i], poll_delay);
        });
  }

  delete[] handles;

  return true;
}

bool QatSection::isInitialized() { return num_instances_ > 0; }

QatHandle& QatSection::getNextHandle() {
  Thread::LockGuard handle_lock(handle_lock_);
  if (next_handle_ == num_instances_) {
    next_handle_ = 0;
  }
  return qat_handles_[next_handle_++];
}

// The decrypt operation buffer creation functions are partially adapted from
// OpenSSL QAT engine. Changes include using the QAT library functions for
// allocating memory.

bool QatContext::convertBnToFlatbuffer(CpaFlatBuffer* fb, const BIGNUM* bn) {
  fb->dataLenInBytes = static_cast<Cpa32U>(BN_num_bytes(bn));
  if (fb->dataLenInBytes == 0) {
    fb->pData = nullptr;
    return false;
  }

  // Allocate continuous memory from the right NUMA node in 64 byte alignment.
  fb->pData = static_cast<Cpa8U*>(
      getLibqat()->qaeMemAllocNUMA(fb->dataLenInBytes, handle_.getNodeAffinity(), 64));
  if (fb->pData == nullptr) {
    fb->dataLenInBytes = 0;
    return false;
  }

  if (BN_bn2bin(bn, fb->pData) == 0) {
    fb->dataLenInBytes = 0;
    return false;
  }

  return true;
}

void QatContext::freeNuma(void* ptr) {
  if (ptr) {
    getLibqat()->qaeMemFreeNUMA(&ptr);
  }
}

void QatContext::freeDecryptOpBuf(CpaCyRsaDecryptOpData* dec_op_data, CpaFlatBuffer* out_buf) {
  CpaCyRsaPrivateKeyRep2* key = nullptr;

  if (dec_op_data) {
    if (dec_op_data->inputData.pData) {
      freeNuma(dec_op_data->inputData.pData);
    }

    if (dec_op_data->pRecipientPrivateKey) {
      key = &dec_op_data->pRecipientPrivateKey->privateKeyRep2;
      freeNuma(static_cast<void*>(key->prime1P.pData));
      freeNuma(static_cast<void*>(key->prime2Q.pData));
      freeNuma(static_cast<void*>(key->exponent1Dp.pData));
      freeNuma(static_cast<void*>(key->exponent2Dq.pData));
      freeNuma(static_cast<void*>(key->coefficientQInv.pData));
      OPENSSL_free(dec_op_data->pRecipientPrivateKey);
    }
    OPENSSL_free(dec_op_data);
  }

  if (out_buf) {
    if (out_buf->pData) {
      freeNuma(out_buf->pData);
    }
    OPENSSL_free(out_buf);
  }
}

bool QatContext::buildDecryptOpBuf(int from_len, const unsigned char* from, RSA* rsa, int padding,
                                   CpaCyRsaDecryptOpData** dec_op_data,
                                   CpaFlatBuffer** output_buffer) {
  const BIGNUM* p = nullptr;
  const BIGNUM* q = nullptr;
  RSA_get0_factors(rsa, &p, &q);

  const BIGNUM* dmp1 = nullptr;
  const BIGNUM* dmq1 = nullptr;
  const BIGNUM* iqmp = nullptr;
  RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);

  if (p == nullptr || q == nullptr || dmp1 == nullptr || dmq1 == nullptr || iqmp == nullptr) {
    return false;
  }

  *dec_op_data = static_cast<CpaCyRsaDecryptOpData*>(OPENSSL_malloc(sizeof(CpaCyRsaDecryptOpData)));
  if (*dec_op_data == nullptr) {
    return false;
  }
  memset(*dec_op_data, 0, sizeof(**dec_op_data));

  CpaCyRsaPrivateKey* cpa_prv_key =
      static_cast<CpaCyRsaPrivateKey*>(OPENSSL_malloc(sizeof(CpaCyRsaPrivateKey)));
  if (cpa_prv_key == nullptr) {
    freeDecryptOpBuf(*dec_op_data, *output_buffer);
    return false;
  }
  memset(cpa_prv_key, 0, sizeof(*cpa_prv_key));

  (*dec_op_data)->pRecipientPrivateKey = cpa_prv_key;

  cpa_prv_key->version = CPA_CY_RSA_VERSION_TWO_PRIME;
  cpa_prv_key->privateKeyRepType = CPA_CY_RSA_PRIVATE_KEY_REP_TYPE_2;
  if (!convertBnToFlatbuffer(&cpa_prv_key->privateKeyRep2.prime1P, p) ||
      !convertBnToFlatbuffer(&cpa_prv_key->privateKeyRep2.prime2Q, q) ||
      !convertBnToFlatbuffer(&cpa_prv_key->privateKeyRep2.exponent1Dp, dmp1) ||
      !convertBnToFlatbuffer(&cpa_prv_key->privateKeyRep2.exponent2Dq, dmq1) ||
      !convertBnToFlatbuffer(&cpa_prv_key->privateKeyRep2.coefficientQInv, iqmp)) {
    freeDecryptOpBuf(*dec_op_data, *output_buffer);
    return false;
  }

  int rsa_len = RSA_size(rsa);

  (*dec_op_data)->inputData.pData = static_cast<Cpa8U*>(getLibqat()->qaeMemAllocNUMA(
      padding != RSA_NO_PADDING ? rsa_len : from_len, handle_.getNodeAffinity(), 64));

  if ((*dec_op_data)->inputData.pData == nullptr) {
    freeDecryptOpBuf(*dec_op_data, *output_buffer);
    return false;
  }

  (*dec_op_data)->inputData.dataLenInBytes = padding != RSA_NO_PADDING ? rsa_len : from_len;

  // Add RSA PKCS 1.5 padding if needed. The RSA PSS padding is already added.
  if (padding == RSA_PKCS1_PADDING) {
    if (rsa_len < from_len + 3 + 8) {
      freeDecryptOpBuf(*dec_op_data, *output_buffer);
      return false;
    }
    // PKCS1 1.5 padding from RFC 8017 9.2.
    int ff_padding_amount = rsa_len - from_len - 3;
    if (ff_padding_amount < 8) {
      freeDecryptOpBuf(*dec_op_data, *output_buffer);
      return false;
    }
    int idx = 0;
    (*dec_op_data)->inputData.pData[idx++] = 0;
    (*dec_op_data)->inputData.pData[idx++] = 1;
    memset((*dec_op_data)->inputData.pData + idx, 0xff, ff_padding_amount);
    idx += ff_padding_amount;
    (*dec_op_data)->inputData.pData[idx++] = 0;
    memcpy((*dec_op_data)->inputData.pData + idx, from, from_len); // NOLINT(safe-memcpy)
  } else if (padding == RSA_NO_PADDING) {
    // If there is no padding to be added, the input data needs to be the right size.
    if (from_len != rsa_len) {
      freeDecryptOpBuf(*dec_op_data, *output_buffer);
      return false;
    }
    memcpy((*dec_op_data)->inputData.pData, from, from_len); // NOLINT(safe-memcpy)
  } else {
    // Non-supported padding.
    freeDecryptOpBuf(*dec_op_data, *output_buffer);
    return false;
  }

  *output_buffer = static_cast<CpaFlatBuffer*>(OPENSSL_malloc(sizeof(CpaFlatBuffer)));
  if (*output_buffer == nullptr) {
    freeDecryptOpBuf(*dec_op_data, *output_buffer);
    return false;
  }
  memset(*output_buffer, 0, sizeof(CpaFlatBuffer));

  (*output_buffer)->pData =
      static_cast<Cpa8U*>(qaeMemAllocNUMA(rsa_len, handle_.getNodeAffinity(), 64));
  if ((*output_buffer)->pData == nullptr) {
    freeDecryptOpBuf(*dec_op_data, *output_buffer);
    return false;
  }
  (*output_buffer)->dataLenInBytes = rsa_len;

  return true;
}

namespace {
static void decryptCb(void* callback_tag, CpaStatus status, void* data, CpaFlatBuffer* out_buf) {
  // This function is called from the polling thread context as a result of polling indicating that
  // the QAT result is ready.
  QatContext* ctx = static_cast<QatContext*>(callback_tag);
  CpaCyRsaDecryptOpData* op_data = static_cast<CpaCyRsaDecryptOpData*>(data);

  ASSERT(ctx != nullptr);

  QatHandle& handle = ctx->getHandle();
  {
    Thread::LockGuard poll_lock(handle.poll_lock_);
    handle.removeUser();
  }
  {
    Thread::LockGuard data_lock(ctx->data_lock_);
    if (!ctx->copyDecryptedData(out_buf->pData, out_buf->dataLenInBytes)) {
      status = CPA_STATUS_FAIL;
    }

    ctx->freeDecryptOpBuf(op_data, out_buf);

    // Take the fd from the ctx and send the status to it. This indicates that the
    // decryption has completed and the upper layer can redo the SSL request.

    // TODO(ipuustin): OS system calls.
    int ret = write(ctx->getWriteFd(), &status, sizeof(status));
    UNREFERENCED_PARAMETER(ret);
  }
}
} // namespace

QatContext::QatContext(QatHandle& handle) : handle_(handle) {}

QatContext::~QatContext() {
  if (read_fd_ >= 0) {
    close(read_fd_);
  }
  if (write_fd_ >= 0) {
    close(write_fd_);
  }
}

bool QatContext::init() {
  // The pipe is the communications channel from the polling thread to the worker thread.

  // TODO(ipuustin): OS system calls.
  int pipe_fds[2] = {0, 0};
  int ret = pipe(pipe_fds);

  if (ret == -1) {
    return false;
  }

  read_fd_ = pipe_fds[0];
  write_fd_ = pipe_fds[1];

  return true;
}

bool QatContext::decrypt(int len, const unsigned char* from, RSA* rsa, int padding) {
  CpaCyRsaDecryptOpData* op_data = nullptr;
  CpaFlatBuffer* out_buf = nullptr;

  // TODO(ipuustin): should this rather be a class function?
  int ret = buildDecryptOpBuf(len, from, rsa, padding, &op_data, &out_buf);
  if (!ret) {
    return false;
  }

  CpaStatus status;
  do {
    status = getLibqat()->cpaCyRsaDecrypt(handle_.getHandle(), decryptCb, this, op_data, out_buf);
  } while (status == CPA_STATUS_RETRY);

  if (status != CPA_STATUS_SUCCESS) {
    return false;
  }

  {
    Thread::LockGuard poll_lock(handle_.poll_lock_);
    handle_.addUser();
    // Start polling for the result.
    handle_.qat_thread_cond_.notifyOne();
  }

  return true;
}

QatHandle& QatContext::getHandle() { return handle_; };

LibQatCryptoSharedPtr QatContext::getLibqat() { return handle_.getLibqat(); };

int QatContext::getDecryptedDataLength() { return decrypted_data_length_; }

unsigned char* QatContext::getDecryptedData() { return decrypted_data_; }

void QatContext::setOpStatus(CpaStatus status) { last_status_ = status; };

CpaStatus QatContext::getOpStatus() { return last_status_; }

bool QatContext::copyDecryptedData(unsigned char* bytes, int len) {
  ASSERT(bytes != nullptr);
  if (len > QAT_BUFFER_SIZE) {
    return false;
  }
  memcpy(decrypted_data_, bytes, len); // NOLINT(safe-memcpy)
  decrypted_data_length_ = len;
  return true;
};

int QatContext::getFd() { return read_fd_; }

int QatContext::getWriteFd() { return write_fd_; };

} // namespace Qat
} // namespace PrivateKeyMethodProvider
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_test",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_test(
    name = "qatzip_compressor_impl_test",
    srcs = select({
        "//bazel:linux_x86_64": ["qatzip_compressor_impl_test.cc"],
        "//conditions:default": [],
    }),
    deps = [
        "//contrib/qat/compression/qatzip/compressor/source:config",
        "//source/extensions/compression/gzip/decompressor:zlib_decompressor_impl_lib",
        "//test/mocks/server:factory_context_mocks",
        "//test/test_common:utility_lib",
    ],
)
#include "source/common/buffer/buffer_impl.h"
#include "source/common/stats/isolated_store_impl.h"
#include "source/extensions/compression/gzip/decompressor/zlib_decompressor_impl.h"

#include "test/mocks/server/factory_context.h"
#include "test/test_common/utility.h"

#include "contrib/qat/compression/qatzip/compressor/source/config.h"
#include "gtest/gtest.h"

namespace Envoy {
namespace Extensions {
namespace Compression {
namespace Qatzip {
namespace Compressor {

class QatzipCompressorImplTest : public ::testing::Test {
protected:
  void drainBuffer(Buffer::OwnedImpl& buffer) { buffer.drain(buffer.length()); }

  void verifyWithDecompressor(Envoy::Compression::Compressor::CompressorPtr compressor,
                              int chunk_size) {
    Buffer::OwnedImpl buffer;
    Buffer::OwnedImpl accumulation_buffer;
    std::string original_text{};
    for (uint64_t i = 0; i < 10; i++) {
      TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size_ * i, i);
      original_text.append(buffer.toString());
      ASSERT_EQ(default_input_size_ * i, buffer.length());
      compressor->compress(buffer, Envoy::Compression::Compressor::State::Flush);
      accumulation_buffer.add(buffer);
      drainBuffer(buffer);
      ASSERT_EQ(0, buffer.length());
    }

    compressor->compress(buffer, Envoy::Compression::Compressor::State::Finish);
    accumulation_buffer.add(buffer);
    drainBuffer(buffer);

    Stats::IsolatedStoreImpl stats_store;
    Compression::Gzip::Decompressor::ZlibDecompressorImpl decompressor(*stats_store.rootScope(),
                                                                       "test.", chunk_size, 100);
    // Window bits = 31 (15 for maximum window bits + 16 for gzip).
    decompressor.init(31);

    decompressor.decompress(accumulation_buffer, buffer);
    std::string decompressed_text{buffer.toString()};

    ASSERT_EQ(original_text.length(), decompressed_text.length());
    EXPECT_EQ(original_text, decompressed_text);
  }

  Envoy::Compression::Compressor::CompressorFactoryPtr
  createQatzipCompressorFactoryFromConfig(const std::string& json) {
    envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip qatzip_config;
    TestUtility::loadFromJson(json, qatzip_config);

    return qatzip_compressor_library_factory_.createCompressorFactoryFromProto(qatzip_config,
                                                                               context_);
  }
  // A value which has an impact on the size of random input created for the tests that use
  // verifyWithDecompressor.
  static constexpr uint32_t default_input_size_{796};

  QatzipCompressorLibraryFactory qatzip_compressor_library_factory_;
  NiceMock<Server::Configuration::MockFactoryContext> context_;
};

class QatzipConfigTest
    : public QatzipCompressorImplTest,
      public ::testing::WithParamInterface<std::tuple<int, std::string, int, int, int>> {};

// These tests should pass even if required hardware or setup steps required for qatzip are missing.
// Qatzip uses a sofware fallback in this case.
INSTANTIATE_TEST_SUITE_P(QatzipConfigTestInstantiation, QatzipConfigTest,
                         // First tuple has all default values.
                         ::testing::Values(std::make_tuple(1, "DEFAULT", 1024, 131072, 4096),
                                           std::make_tuple(2, "DEFAULT", 128, 131072, 4096),
                                           std::make_tuple(3, "DEFAULT", 524288, 131072, 4096),
                                           std::make_tuple(4, "SZ_4K", 1024, 1024, 4096),
                                           std::make_tuple(5, "SZ_8K", 1024, 2092032, 4096),
                                           std::make_tuple(6, "SZ_32K", 1024, 131072, 65536),
                                           std::make_tuple(7, "SZ_64K", 1024, 131072, 4096),
                                           std::make_tuple(8, "SZ_128K", 1024, 131072, 4096),
                                           std::make_tuple(9, "SZ_512K", 1024, 131072, 4096)));

TEST_P(QatzipConfigTest, LoadConfigAndVerifyWithDecompressor) {
  std::tuple<int, std::string, int, int, int> config_value_tuple = GetParam();
  int chunk_size = std::get<4>(config_value_tuple);
  std::string json{fmt::format(R"EOF({{
  "compression_level": {},
  "hardware_buffer_size": "{}",
  "input_size_threshold": {},
  "stream_buffer_size": {},
  "chunk_size": {}
}})EOF",
                               std::get<0>(config_value_tuple), std::get<1>(config_value_tuple),
                               std::get<2>(config_value_tuple), std::get<3>(config_value_tuple),
                               chunk_size)};

  Envoy::Compression::Compressor::CompressorFactoryPtr qatzip_compressor_factory =
      createQatzipCompressorFactoryFromConfig(json);

  EXPECT_EQ("gzip", qatzip_compressor_factory->contentEncoding());
  EXPECT_EQ("qatzip.", qatzip_compressor_factory->statsPrefix());

  verifyWithDecompressor(qatzip_compressor_factory->createCompressor(), chunk_size);
}

class InvalidQatzipConfigTest
    : public QatzipCompressorImplTest,
      public ::testing::WithParamInterface<std::tuple<int, std::string, int, int, int>> {};

// Tests with invalid qatzip configs.
INSTANTIATE_TEST_SUITE_P(
    InvalidQatzipConfigTestInstantiation, InvalidQatzipConfigTest,
    // This tuple has all default values: std::make_tuple(1, "DEFAULT", 1024, 131072, 4096).
    ::testing::Values(std::make_tuple(0, "DEFAULT", 1024, 131072, 4096),
                      std::make_tuple(10, "DEFAULT", 1024, 131072, 4096),
                      std::make_tuple(1, "DEFAULT", 127, 131072, 4096),
                      std::make_tuple(1, "DEFAULT", 524289, 131072, 4096),
                      std::make_tuple(1, "DEFAULT", 1024, 1023, 4096),
                      std::make_tuple(1, "DEFAULT", 1024, 2092033, 4096),
                      std::make_tuple(1, "DEFAULT", 1024, 131072, 4095),
                      std::make_tuple(1, "DEFAULT", 1024, 131072, 65537)));

TEST_P(InvalidQatzipConfigTest, LoadConfigWithInvalidValues) {
  std::tuple<int, std::string, int, int, int> config_value_tuple = GetParam();
  int chunk_size = std::get<4>(config_value_tuple);
  std::string json{fmt::format(R"EOF({{
  "compression_level": {},
  "hardware_buffer_size": "{}",
  "input_size_threshold": {},
  "stream_buffer_size": {},
  "chunk_size": {}
}})EOF",
                               std::get<0>(config_value_tuple), std::get<1>(config_value_tuple),
                               std::get<2>(config_value_tuple), std::get<3>(config_value_tuple),
                               chunk_size)};

  EXPECT_THROW_WITH_REGEX(createQatzipCompressorFactoryFromConfig(json), EnvoyException,
                          "Proto constraint validation failed");
}

} // namespace Compressor
} // namespace Qatzip
} // namespace Compression
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/compression/compressor/config.h"
#include "envoy/compression/compressor/factory.h"
#include "envoy/thread_local/thread_local.h"

#include "source/common/http/headers.h"

#include "contrib/envoy/extensions/compression/qatzip/compressor/v3alpha/qatzip.pb.h"
#include "contrib/envoy/extensions/compression/qatzip/compressor/v3alpha/qatzip.pb.validate.h"

#ifndef QAT_DISABLED
#include "contrib/qat/compression/qatzip/compressor/source/qatzip_compressor_impl.h"
#endif

namespace Envoy {
namespace Extensions {
namespace Compression {
namespace Qatzip {
namespace Compressor {

namespace {

#ifndef QAT_DISABLED
const std::string& qatzipStatsPrefix() { CONSTRUCT_ON_FIRST_USE(std::string, "qatzip."); }
#endif

const std::string& qatzipExtensionName() {
  CONSTRUCT_ON_FIRST_USE(std::string, "envoy.compression.qatzip.compressor");
}

} // namespace

#ifndef QAT_DISABLED
class QatzipCompressorFactory : public Envoy::Compression::Compressor::CompressorFactory {
public:
  QatzipCompressorFactory(
      const envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip& qatzip,
      Server::Configuration::FactoryContext& context);

  // Envoy::Compression::Compressor::CompressorFactory
  Envoy::Compression::Compressor::CompressorPtr createCompressor() override;
  const std::string& statsPrefix() const override { return qatzipStatsPrefix(); }
  const std::string& contentEncoding() const override {
    return Http::CustomHeaders::get().ContentEncodingValues.Gzip;
  }

private:
  struct QatzipThreadLocal : public ThreadLocal::ThreadLocalObject {
    QatzipThreadLocal(QzSessionParams_T params);
    ~QatzipThreadLocal() override;
    QzSession_T* getSession();

    QzSessionParams_T params_;
    QzSession_T session_;
    bool initialized_;
  };

  const uint32_t chunk_size_;
  ThreadLocal::SlotPtr tls_slot_;
};
#endif

class QatzipCompressorLibraryFactory
    : public Envoy::Compression::Compressor::NamedCompressorLibraryConfigFactory {
public:
  QatzipCompressorLibraryFactory() : name_{qatzipExtensionName()} {}

  Envoy::Compression::Compressor::CompressorFactoryPtr
  createCompressorFactoryFromProto(const Protobuf::Message& proto_config,
                                   Server::Configuration::FactoryContext& context) override;

  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip>();
  }

  std::string name() const override { return name_; }

private:
#ifndef QAT_DISABLED
  Envoy::Compression::Compressor::CompressorFactoryPtr createCompressorFactoryFromProtoTyped(
      const envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip& config,
      Server::Configuration::FactoryContext& context);
#endif

  const std::string name_;
};

DECLARE_FACTORY(QatzipCompressorLibraryFactory);

} // namespace Compressor
} // namespace Qatzip
} // namespace Compression
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/compression/compressor/compressor.h"

#define HAVE_QAT_HEADERS
#include "qatzip.h"

namespace Envoy {
namespace Extensions {
namespace Compression {
namespace Qatzip {
namespace Compressor {

/**
 * Implementation of compressor's interface.
 */
class QatzipCompressorImpl : public Envoy::Compression::Compressor::Compressor {
public:
  QatzipCompressorImpl(QzSession_T* session);

  /**
   * Constructor that allows setting the size of compressor's output buffer. It
   * should be called whenever a buffer size different than the 4096 bytes, normally set by the
   * default constructor, is desired.
   * @param chunk_size amount of memory reserved for the compressor output.
   */
  QatzipCompressorImpl(QzSession_T* session, size_t chunk_size);
  ~QatzipCompressorImpl() override;

  // Compressor
  void compress(Buffer::Instance& buffer, Envoy::Compression::Compressor::State state) override;

private:
  void process(Buffer::Instance& output_buffer, unsigned int last);

  const size_t chunk_size_;
  size_t avail_in_;
  size_t avail_out_;

  std::unique_ptr<unsigned char[]> chunk_char_ptr_;
  QzSession_T* const session_;
  QzStream_T stream_;

  uint32_t input_len_;
};

} // namespace Compressor
} // namespace Qatzip
} // namespace Compression
} // namespace Extensions
} // namespace Envoy
#include "contrib/qat/compression/qatzip/compressor/source/qatzip_compressor_impl.h"

#include <memory>

#include "source/common/common/assert.h"

namespace Envoy {
namespace Extensions {
namespace Compression {
namespace Qatzip {
namespace Compressor {

QatzipCompressorImpl::QatzipCompressorImpl(QzSession_T* session)
    : QatzipCompressorImpl(session, 4096) {}

// TODO(rojkov): add lower limit to chunk_size in proto definition.
QatzipCompressorImpl::QatzipCompressorImpl(QzSession_T* session, size_t chunk_size)
    : chunk_size_{chunk_size}, avail_in_{0}, avail_out_{chunk_size - 10},
      chunk_char_ptr_(new unsigned char[chunk_size]), session_{session}, stream_{}, input_len_(0) {
  RELEASE_ASSERT(session_ != nullptr,
                 "QATzip compressor must be created with non-null QATzip session");
  static unsigned char gzheader[10] = {0x1f, 0x8b, 8, 0, 0, 0, 0, 0, 0, 3};
  stream_.out = static_cast<unsigned char*>(mempcpy(chunk_char_ptr_.get(), gzheader, 10));
}

QatzipCompressorImpl::~QatzipCompressorImpl() { qzEndStream(session_, &stream_); }

void QatzipCompressorImpl::compress(Buffer::Instance& buffer,
                                    Envoy::Compression::Compressor::State state) {

  for (const Buffer::RawSlice& input_slice : buffer.getRawSlices()) {
    avail_in_ = input_slice.len_;
    stream_.in = static_cast<unsigned char*>(input_slice.mem_);

    while (avail_in_ > 0) {
      process(buffer, 0);
    }

    buffer.drain(input_slice.len_);
  }

  if (state == Envoy::Compression::Compressor::State::Finish) {
    do {
      process(buffer, 1);
    } while (stream_.pending_out > 0);

    const size_t n_output = chunk_size_ - avail_out_;
    if (n_output > 0) {
      buffer.add(static_cast<void*>(chunk_char_ptr_.get()), n_output);
    }
    buffer.writeLEInt<uint32_t>(stream_.crc_32);
    buffer.writeLEInt<uint32_t>(input_len_);
  }
}

void QatzipCompressorImpl::process(Buffer::Instance& output_buffer, unsigned int last) {
  stream_.in_sz = avail_in_;
  stream_.out_sz = avail_out_;
  auto status = qzCompressStream(session_, &stream_, last);
  // NOTE: stream_.in_sz and stream_.out_sz have changed their semantics after the call
  //       to qzCompressStream(). Despite their name the new values are consumed input
  //       and produced output (not available buffer sizes).
  avail_out_ -= stream_.out_sz;
  avail_in_ -= stream_.in_sz;
  input_len_ += stream_.in_sz;
  stream_.in = stream_.in + stream_.in_sz;
  stream_.out = stream_.out + stream_.out_sz;
  RELEASE_ASSERT(status == QZ_OK, "");
  if (avail_out_ == 0) {
    // The chunk is full, so copy it to the output buffer and reset context.
    output_buffer.add(static_cast<void*>(chunk_char_ptr_.get()), chunk_size_);
    chunk_char_ptr_ = std::make_unique<unsigned char[]>(chunk_size_);
    avail_out_ = chunk_size_;
    stream_.out = chunk_char_ptr_.get();
  }
}

} // namespace Compressor
} // namespace Qatzip
} // namespace Compression
} // namespace Extensions
} // namespace Envoy
load("@rules_foreign_cc//foreign_cc:configure.bzl", "configure_make")
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_contrib_package",
)
load(
    "//contrib:all_contrib_extensions.bzl",
    "envoy_contrib_linux_x86_64_constraints",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

configure_make(
    name = "qatzip",
    autogen = True,
    configure_in_place = True,
    configure_options = [
        "--enable-static",
        "--disable-shared",
    ],
    env = select({
        "//bazel:clang_build": {
            "CFLAGS": "-Wno-error=newline-eof -Wno-error=strict-prototypes -Wno-error=unused-but-set-variable",
        },
        "//conditions:default": {},
    }),
    lib_source = "@com_github_intel_qatzip//:all",
    out_static_libs = [
        "libqatzip.a",
    ],
    tags = ["skip_on_windows"],
    target_compatible_with = envoy_contrib_linux_x86_64_constraints(),
    visibility = ["//visibility:public"],
    deps = [
        "//bazel/foreign_cc:lz4",
        "//bazel/foreign_cc:zlib",
        "//contrib/qat:qatlib",
        # Use boringssl alias to select fips vs non-fips version.
        "//bazel:boringssl",
    ],
    alwayslink = False,
)

envoy_cc_library(
    name = "compressor_lib",
    srcs = ["qatzip_compressor_impl.cc"],
    hdrs = ["qatzip_compressor_impl.h"],
    deps = [
        ":qatzip",
        "//envoy/compression/compressor:compressor_interface",
    ],
)

envoy_cc_contrib_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    defines = select({
        "//bazel:linux_x86_64": [
        ],
        "//conditions:default": [
            "QAT_DISABLED=1",
        ],
    }),
    deps = [
        "//envoy/compression/compressor:compressor_config_interface",
        "//envoy/compression/compressor:compressor_factory_interface",
        "//source/common/http:headers_lib",
        "@envoy_api//contrib/envoy/extensions/compression/qatzip/compressor/v3alpha:pkg_cc_proto",
    ] + select({
        "//bazel:linux_x86_64": [
            ":compressor_lib",
        ],
        "//conditions:default": [
        ],
    }),
)
#include "contrib/qat/compression/qatzip/compressor/source/config.h"

namespace Envoy {
namespace Extensions {
namespace Compression {
namespace Qatzip {
namespace Compressor {

#ifndef QAT_DISABLED
namespace {

// Default qatzip chunk size.
const uint32_t DefaultChunkSize = 4096;

// Default qatzip stream buffer size.
const unsigned int DefaultStreamBufferSize = 128 * 1024;

unsigned int hardwareBufferSizeEnum(
    envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip_HardwareBufferSize
        hardware_buffer_size) {
  switch (hardware_buffer_size) {
  case envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip_HardwareBufferSize::
      Qatzip_HardwareBufferSize_SZ_4K:
    return 4 * 1024;
  case envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip_HardwareBufferSize::
      Qatzip_HardwareBufferSize_SZ_8K:
    return 8 * 1024;
  case envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip_HardwareBufferSize::
      Qatzip_HardwareBufferSize_SZ_32K:
    return 32 * 1024;
  case envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip_HardwareBufferSize::
      Qatzip_HardwareBufferSize_SZ_64K:
    return 64 * 1024;
  case envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip_HardwareBufferSize::
      Qatzip_HardwareBufferSize_SZ_128K:
    return 128 * 1024;
  case envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip_HardwareBufferSize::
      Qatzip_HardwareBufferSize_SZ_512K:
    return 512 * 1024;
  default:
    return 64 * 1024;
  }
}

unsigned int compressionLevelUint(Protobuf::uint32 compression_level) {
  return compression_level > 0 ? compression_level : QZ_COMP_LEVEL_DEFAULT;
}

unsigned int inputSizeThresholdUint(Protobuf::uint32 input_size_threshold) {
  return input_size_threshold > 0 ? input_size_threshold : QZ_COMP_THRESHOLD_DEFAULT;
}

unsigned int streamBufferSizeUint(Protobuf::uint32 stream_buffer_size) {
  return stream_buffer_size > 0 ? stream_buffer_size : DefaultStreamBufferSize;
}

} // namespace

QatzipCompressorFactory::QatzipCompressorFactory(
    const envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip& qatzip,
    Server::Configuration::FactoryContext& context)
    : chunk_size_(PROTOBUF_GET_WRAPPED_OR_DEFAULT(qatzip, chunk_size, DefaultChunkSize)),
      tls_slot_(context.serverFactoryContext().threadLocal().allocateSlot()) {
  QzSessionParams_T params;

  int status = qzGetDefaults(&params);
  RELEASE_ASSERT(status == QZ_OK, "failed to initialize hardware");
  params.comp_lvl = compressionLevelUint(qatzip.compression_level().value());
  params.hw_buff_sz = hardwareBufferSizeEnum(qatzip.hardware_buffer_size());
  params.strm_buff_sz = streamBufferSizeUint(qatzip.stream_buffer_size().value());
  params.input_sz_thrshold = inputSizeThresholdUint(qatzip.input_size_threshold().value());
  params.data_fmt = QZ_DEFLATE_RAW;

  tls_slot_->set([params](Event::Dispatcher&) -> ThreadLocal::ThreadLocalObjectSharedPtr {
    return std::make_shared<QatzipThreadLocal>(params);
  });
}

Envoy::Compression::Compressor::CompressorPtr QatzipCompressorFactory::createCompressor() {
  return std::make_unique<QatzipCompressorImpl>(
      tls_slot_->getTyped<QatzipThreadLocal>().getSession());
}

QatzipCompressorFactory::QatzipThreadLocal::QatzipThreadLocal(QzSessionParams_T params)
    : params_(params), session_{}, initialized_(false) {}

QatzipCompressorFactory::QatzipThreadLocal::~QatzipThreadLocal() {
  if (initialized_) {
    qzTeardownSession(&session_);
  }
}

QzSession_T* QatzipCompressorFactory::QatzipThreadLocal::getSession() {
  // The session must be initialized only once in every worker thread.
  if (!initialized_) {

    int status = qzInit(&session_, params_.sw_backup);
    RELEASE_ASSERT(status == QZ_OK || status == QZ_DUPLICATE, "failed to initialize hardware");
    status = qzSetupSession(&session_, &params_);
    RELEASE_ASSERT(status == QZ_OK || status == QZ_DUPLICATE, "failed to setup session");
    initialized_ = true;
  }

  return &session_;
}

Envoy::Compression::Compressor::CompressorFactoryPtr
QatzipCompressorLibraryFactory::createCompressorFactoryFromProtoTyped(
    const envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip& proto_config,
    Server::Configuration::FactoryContext& context) {
  return std::make_unique<QatzipCompressorFactory>(proto_config, context);
}
#endif

Envoy::Compression::Compressor::CompressorFactoryPtr
QatzipCompressorLibraryFactory::createCompressorFactoryFromProto(
    const Protobuf::Message& proto_config, Server::Configuration::FactoryContext& context) {

  const envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip config =
      MessageUtil::downcastAndValidate<
          const envoy::extensions::compression::qatzip::compressor::v3alpha::Qatzip&>(
          proto_config, context.messageValidationVisitor());
#ifdef QAT_DISABLED
  throw EnvoyException("X86_64 architecture is required for QAT.");
#else
  return createCompressorFactoryFromProtoTyped(config, context);
#endif
}

/**
 * Static registration for the qatzip compressor library. @see NamedCompressorLibraryConfigFactory.
 */
REGISTER_FACTORY(QatzipCompressorLibraryFactory,
                 Envoy::Compression::Compressor::NamedCompressorLibraryConfigFactory);

} // namespace Compressor
} // namespace Qatzip
} // namespace Compression
} // namespace Extensions
} // namespace Envoy
load("@rules_foreign_cc//foreign_cc:configure.bzl", "configure_make")
load("//bazel:envoy_build_system.bzl", "envoy_contrib_package")
load(
    "//contrib:all_contrib_extensions.bzl",
    "envoy_contrib_linux_x86_64_constraints",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

# Have qatlib outside of any extensions because it may be used by both
# QAT compression library extension and QAT private key provider
# extension.

configure_make(
    name = "qatlib",
    autogen = True,
    configure_in_place = True,
    configure_options = [
        "--disable-fast-crc-in-assembler",
        "--disable-systemd",
        "--disable-shared",
        "--with-pic",
        "--enable-static",
        "--enable-samples=no",
    ],
    lib_source = "@com_github_intel_qatlib//:all",
    out_static_libs = [
        "libqat.a",
        "libusdm.a",
    ],
    target_compatible_with = envoy_contrib_linux_x86_64_constraints(),
    visibility = ["//visibility:public"],
    # Use boringssl alias to select fips vs non-fips version.
    deps = ["//bazel:boringssl"],
    alwayslink = True,
)
#include <cstdlib>

#include "envoy/config/bootstrap/v3/bootstrap.pb.h"

#include "source/common/protobuf/protobuf.h"

#include "test/integration/autonomous_upstream.h"
#include "test/integration/http_integration.h"
#include "test/integration/integration.h"
#include "test/integration/utility.h"
#include "test/test_common/environment.h"

#define ENV_VAR_VALUE "somerandomevalue"

using Envoy::Protobuf::util::MessageDifferencer;

namespace Envoy {

class SquashFilterIntegrationTest : public testing::TestWithParam<Network::Address::IpVersion>,
                                    public HttpIntegrationTest {
public:
  SquashFilterIntegrationTest() : HttpIntegrationTest(Http::CodecType::HTTP1, GetParam()) {}

  ~SquashFilterIntegrationTest() override {
    if (fake_squash_connection_) {
      AssertionResult result = fake_squash_connection_->close();
      RELEASE_ASSERT(result, result.message());
      result = fake_squash_connection_->waitForDisconnect();
      RELEASE_ASSERT(result, result.message());
    }
  }

  FakeStreamPtr sendSquash(const std::string& status, const std::string& body) {

    if (!fake_squash_connection_) {
      AssertionResult result =
          fake_upstreams_[1]->waitForHttpConnection(*dispatcher_, fake_squash_connection_);
      RELEASE_ASSERT(result, result.message());
    }

    FakeStreamPtr request_stream;
    AssertionResult result =
        fake_squash_connection_->waitForNewStream(*dispatcher_, request_stream);
    RELEASE_ASSERT(result, result.message());
    result = request_stream->waitForEndStream(*dispatcher_);
    RELEASE_ASSERT(result, result.message());
    if (body.empty()) {
      request_stream->encodeHeaders(Http::TestResponseHeaderMapImpl{{":status", status}}, true);
    } else {
      request_stream->encodeHeaders(Http::TestResponseHeaderMapImpl{{":status", status}}, false);
      Buffer::OwnedImpl responseBuffer(body);
      request_stream->encodeData(responseBuffer, true);
    }

    return request_stream;
  }

  FakeStreamPtr sendSquashCreate(const std::string& body = SQUASH_CREATE_DEFAULT) {
    return sendSquash("201", body);
  }

  FakeStreamPtr sendSquashOk(const std::string& body) { return sendSquash("200", body); }

  IntegrationStreamDecoderPtr sendDebugRequest(IntegrationCodecClientPtr& codec_client) {
    Http::TestRequestHeaderMapImpl headers{{":method", "GET"},
                                           {":authority", "www.solo.io"},
                                           {"x-squash-debug", "true"},
                                           {":path", "/getsomething"}};
    return codec_client->makeHeaderOnlyRequest(headers);
  }

  void createUpstreams() override {
    HttpIntegrationTest::createUpstreams();
    addFakeUpstream(Http::CodecType::HTTP2);
  }

  /**
   * Initializer for an individual integration test.
   */
  void initialize() override {
    TestEnvironment::setEnvVar("SQUASH_ENV_TEST", ENV_VAR_VALUE, 1);

    autonomous_upstream_ = true;

    config_helper_.prependFilter(ConfigHelper::defaultSquashFilter());

    config_helper_.addConfigModifier([](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
      auto* squash_cluster = bootstrap.mutable_static_resources()->add_clusters();
      squash_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);
      squash_cluster->set_name("squash");
      ConfigHelper::setHttp2(*squash_cluster);
    });

    HttpIntegrationTest::initialize();
    codec_client_ = makeHttpConnection(makeClientConnection((lookupPort("http"))));
  }

  /**
   * Initialize before every test.
   */
  void SetUp() override { initialize(); }

  FakeHttpConnectionPtr fake_squash_connection_;
  static const std::string SQUASH_CREATE_DEFAULT;
  static std::string squashGetAttachmentBodyWithState(const std::string& state) {
    return "{\"metadata\":{\"name\":\"oF8iVdiJs5\"},\"spec\":{"
           "\"attachment\":{\"a\":\"b\"},\"image\":\"debug\",\"node\":"
           "\"debug-node\"},\"status\":{\"state\":\"" +
           state + "\"}}";
  }
};

const std::string SquashFilterIntegrationTest::SQUASH_CREATE_DEFAULT =
    "{\"metadata\":{\"name\":\"oF8iVdiJs5\"},"
    "\"spec\":{\"attachment\":{\"a\":\"b\"},"
    "\"image\":\"debug\",\"node\":\"debug-node\"},"
    "\"status\":{\"state\":\"none\"}}";

INSTANTIATE_TEST_SUITE_P(IpVersions, SquashFilterIntegrationTest,
                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
                         TestUtility::ipTestParamsToString);

TEST_P(SquashFilterIntegrationTest, TestHappyPath) {
  auto response = sendDebugRequest(codec_client_);

  // Respond to create request
  FakeStreamPtr create_stream = sendSquashCreate();

  // Respond to read attachment request
  FakeStreamPtr get_stream = sendSquashOk(squashGetAttachmentBodyWithState("attached"));

  ASSERT_TRUE(response->waitForEndStream());

  EXPECT_EQ("POST", create_stream->headers().getMethodValue());
  EXPECT_EQ("/api/v2/debugattachment/", create_stream->headers().getPathValue());
  // Make sure the env var was replaced
  ProtobufWkt::Struct actualbody;
  TestUtility::loadFromJson(create_stream->body().toString(), actualbody);

  ProtobufWkt::Struct expectedbody;
  TestUtility::loadFromJson("{\"spec\": { \"attachment\" : { \"env\": \"" ENV_VAR_VALUE
                            "\" } , \"match_request\":true} }",
                            expectedbody);

  EXPECT_TRUE(MessageDifferencer::Equals(expectedbody, actualbody));
  // The second request should be for the created object
  EXPECT_EQ("GET", get_stream->headers().getMethodValue());
  EXPECT_EQ("/api/v2/debugattachment/oF8iVdiJs5", get_stream->headers().getPathValue());
  EXPECT_TRUE(response->complete());
  EXPECT_EQ("200", response->headers().getStatusValue());
}

TEST_P(SquashFilterIntegrationTest, ErrorAttaching) {
  auto response = sendDebugRequest(codec_client_);

  // Respond to create request
  FakeStreamPtr create_stream = sendSquashCreate();
  // Respond to read attachment request with error!
  FakeStreamPtr get_stream = sendSquashOk(squashGetAttachmentBodyWithState("error"));

  ASSERT_TRUE(response->waitForEndStream());

  EXPECT_TRUE(response->complete());
  EXPECT_EQ("200", response->headers().getStatusValue());
}

TEST_P(SquashFilterIntegrationTest, TimeoutAttaching) {
  auto response = sendDebugRequest(codec_client_);

  // Respond to create request
  FakeStreamPtr create_stream = sendSquashCreate();
  // Respond to read attachment. since attachment_timeout is smaller than attachment_poll_period
  // config, just one response is enough, as the filter will timeout (and continue the iteration)
  // before issuing another get attachment request.
  FakeStreamPtr get_stream = sendSquashOk(squashGetAttachmentBodyWithState("attaching"));

  ASSERT_TRUE(response->waitForEndStream());

  EXPECT_TRUE(response->complete());
  EXPECT_EQ("200", response->headers().getStatusValue());
}

TEST_P(SquashFilterIntegrationTest, ErrorNoSquashServer) {
  auto response = sendDebugRequest(codec_client_);

  // Don't respond to anything. squash filter should timeout within
  // squash_request_timeout and continue the request.
  ASSERT_TRUE(response->waitForEndStream());

  EXPECT_TRUE(response->complete());
  EXPECT_EQ("200", response->headers().getStatusValue());
}

TEST_P(SquashFilterIntegrationTest, BadCreateResponse) {
  auto response = sendDebugRequest(codec_client_);

  // Respond to create request
  FakeStreamPtr create_stream = sendSquashCreate("not json...");

  ASSERT_TRUE(response->waitForEndStream());

  EXPECT_TRUE(response->complete());
  EXPECT_EQ("200", response->headers().getStatusValue());
}

TEST_P(SquashFilterIntegrationTest, BadGetResponse) {
  auto response = sendDebugRequest(codec_client_);

  // Respond to create request
  FakeStreamPtr create_stream = sendSquashCreate();
  // Respond to read attachment request with error!
  FakeStreamPtr get_stream = sendSquashOk("not json...");

  ASSERT_TRUE(response->waitForEndStream());

  EXPECT_TRUE(response->complete());
  EXPECT_EQ("200", response->headers().getStatusValue());
}

} // namespace Envoy
#include "test/mocks/server/factory_context.h"
#include "test/test_common/utility.h"

#include "contrib/envoy/extensions/filters/http/squash/v3/squash.pb.h"
#include "contrib/envoy/extensions/filters/http/squash/v3/squash.pb.validate.h"
#include "contrib/squash/filters/http/source/config.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using testing::_;

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace Squash {
namespace {

TEST(SquashFilterConfigFactoryTest, SquashFilterCorrectYaml) {
  const std::string yaml_string = R"EOF(
  cluster: fake_cluster
  attachment_template:
    a: b
  request_timeout: 1.001s
  attachment_poll_period: 2.002s
  attachment_timeout: 3.003s
  )EOF";

  envoy::extensions::filters::http::squash::v3::Squash proto_config;
  TestUtility::loadFromYaml(yaml_string, proto_config);
  NiceMock<Server::Configuration::MockFactoryContext> context;
  context.server_factory_context_.cluster_manager_.initializeClusters({"fake_cluster"}, {});
  SquashFilterConfigFactory factory;
  Http::FilterFactoryCb cb =
      factory.createFilterFactoryFromProto(proto_config, "stats", context).value();
  Http::MockFilterChainFactoryCallbacks filter_callback;
  EXPECT_CALL(filter_callback, addStreamDecoderFilter(_));
  cb(filter_callback);
}

} // namespace
} // namespace Squash
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include <chrono>
#include <memory>
#include <string>

#include "source/common/http/message_impl.h"
#include "source/common/protobuf/protobuf.h"

#include "test/mocks/server/factory_context.h"
#include "test/mocks/upstream/cluster_manager.h"
#include "test/test_common/environment.h"
#include "test/test_common/utility.h"

#include "contrib/envoy/extensions/filters/http/squash/v3/squash.pb.h"
#include "contrib/squash/filters/http/source/squash_filter.h"
#include "fmt/format.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using testing::_;
using testing::Invoke;
using testing::NiceMock;
using testing::Return;

using Envoy::Protobuf::util::MessageDifferencer;

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace Squash {
namespace {

SquashFilterConfig constructSquashFilterConfigFromYaml(
    const std::string& yaml, NiceMock<Envoy::Server::Configuration::MockFactoryContext>& context) {
  envoy::extensions::filters::http::squash::v3::Squash proto_config;
  TestUtility::loadFromYaml(yaml, proto_config);
  return {proto_config, context.server_factory_context_.cluster_manager_};
}

void expectJsonEq(const std::string& expected, const std::string& actual) {
  ProtobufWkt::Struct actualjson;
  TestUtility::loadFromJson(actual, actualjson);

  ProtobufWkt::Struct expectedjson;
  TestUtility::loadFromJson(expected, expectedjson);

  EXPECT_TRUE(MessageDifferencer::Equals(expectedjson, actualjson));
}

} // namespace

TEST(SquashFilterConfigTest, V2ApiConversion) {
  const std::string yaml = R"EOF(
  cluster: fake_cluster
  attachment_template:
    a: b
  request_timeout: 1.001s
  attachment_poll_period: 2.002s
  attachment_timeout: 3.003s
  )EOF";

  NiceMock<Envoy::Server::Configuration::MockFactoryContext> factory_context;
  factory_context.server_factory_context_.cluster_manager_.initializeClusters({"fake_cluster"}, {});

  const auto config = constructSquashFilterConfigFromYaml(yaml, factory_context);
  EXPECT_EQ("fake_cluster", config.clusterName());
  expectJsonEq("{\"a\":\"b\"}", config.attachmentJson());
  EXPECT_EQ(std::chrono::milliseconds(1001), config.requestTimeout());
  EXPECT_EQ(std::chrono::milliseconds(2002), config.attachmentPollPeriod());
  EXPECT_EQ(std::chrono::milliseconds(3003), config.attachmentTimeout());
}

TEST(SquashFilterConfigTest, NoCluster) {
  const std::string yaml = R"EOF(
  cluster: fake_cluster
  attachment_template: {}
  )EOF";

  NiceMock<Envoy::Server::Configuration::MockFactoryContext> factory_context;
  EXPECT_THROW_WITH_MESSAGE(constructSquashFilterConfigFromYaml(yaml, factory_context),
                            Envoy::EnvoyException,
                            "squash filter: unknown cluster 'fake_cluster' in squash config");
}

TEST(SquashFilterConfigTest, ParsesEnvironment) {
  const std::string yaml = R"EOF(
  cluster: squash
  attachment_template:
    a: "{{ MISSING_ENV }}"

  )EOF";
  const std::string expected_json = "{\"a\":\"\"}";

  NiceMock<Envoy::Server::Configuration::MockFactoryContext> factory_context;
  factory_context.server_factory_context_.cluster_manager_.initializeClusters({"squash"}, {});

  const auto config = constructSquashFilterConfigFromYaml(yaml, factory_context);
  expectJsonEq(expected_json, config.attachmentJson());
}

TEST(SquashFilterConfigTest, ParsesAndEscapesEnvironment) {
  TestEnvironment::setEnvVar("ESCAPE_ENV", "\"", 1);

  const std::string yaml = R"EOF(
  cluster: squash
  attachment_template:
    a: "{{ ESCAPE_ENV }}"
  )EOF";

  const std::string expected_json = "{\"a\":\"\\\"\"}";

  NiceMock<Envoy::Server::Configuration::MockFactoryContext> factory_context;
  factory_context.server_factory_context_.cluster_manager_.initializeClusters({"squash"}, {});
  const auto config = constructSquashFilterConfigFromYaml(yaml, factory_context);
  expectJsonEq(expected_json, config.attachmentJson());
}

TEST(SquashFilterConfigTest, TwoEnvironmentVariables) {
  TestEnvironment::setEnvVar("ENV1", "1", 1);
  TestEnvironment::setEnvVar("ENV2", "2", 1);

  const std::string yaml = R"EOF(
  cluster: squash
  attachment_template:
    a: "{{ ENV1 }}-{{ ENV2 }}"
  )EOF";

  const std::string expected_json = "{\"a\":\"1-2\"}";

  NiceMock<Envoy::Server::Configuration::MockFactoryContext> factory_context;
  factory_context.server_factory_context_.cluster_manager_.initializeClusters({"squash"}, {});
  auto config = constructSquashFilterConfigFromYaml(yaml, factory_context);
  expectJsonEq(expected_json, config.attachmentJson());
}

TEST(SquashFilterConfigTest, ParsesEnvironmentInComplexTemplate) {
  TestEnvironment::setEnvVar("CONF_ENV", "some-config-value", 1);

  const std::string yaml = R"EOF(
  cluster: squash
  attachment_template:
    a:
    - e: "{{ CONF_ENV }}"
    - c: d
  )EOF";

  const std::string expected_json = R"EOF({"a":[{"e": "some-config-value"},{"c":"d"}]})EOF";

  NiceMock<Envoy::Server::Configuration::MockFactoryContext> factory_context;
  factory_context.server_factory_context_.cluster_manager_.initializeClusters({"squash"}, {});
  const auto config = constructSquashFilterConfigFromYaml(yaml, factory_context);
  expectJsonEq(expected_json, config.attachmentJson());
}

class SquashFilterTest : public testing::Test {
public:
  SquashFilterTest()
      : request_(&factory_context_.server_factory_context_.cluster_manager_.thread_local_cluster_
                      .async_client_) {}

protected:
  void SetUp() override {}

  void initFilter() {
    envoy::extensions::filters::http::squash::v3::Squash p;
    p.set_cluster("squash");
    factory_context_.server_factory_context_.cluster_manager_.initializeClusters({"squash"}, {});
    factory_context_.server_factory_context_.cluster_manager_.initializeThreadLocalClusters(
        {"squash"});
    config_ = std::make_shared<SquashFilterConfig>(
        p, factory_context_.server_factory_context_.cluster_manager_);

    filter_ = std::make_shared<SquashFilter>(
        config_, factory_context_.server_factory_context_.cluster_manager_);
    filter_->setDecoderFilterCallbacks(filter_callbacks_);
  }

  // start a downstream request marked with the squash header.
  // note that a side effect of this is that
  // a call to the squash server will be made.
  // use popPendingCallback() to reply to that call.
  void startDownstreamRequest() {
    initFilter();

    attachmentTimeout_timer_ =
        new NiceMock<Envoy::Event::MockTimer>(&filter_callbacks_.dispatcher_);

    EXPECT_CALL(factory_context_.server_factory_context_.cluster_manager_.thread_local_cluster_,
                httpAsyncClient())
        .WillRepeatedly(ReturnRef(factory_context_.server_factory_context_.cluster_manager_
                                      .thread_local_cluster_.async_client_));

    expectAsyncClientSend();

    EXPECT_CALL(*attachmentTimeout_timer_, enableTimer(config_->attachmentTimeout(), _));

    Envoy::Http::TestRequestHeaderMapImpl headers{{":method", "GET"},
                                                  {":authority", "www.solo.io"},
                                                  {"x-squash-debug", "true"},
                                                  {":path", "/getsomething"}};
    EXPECT_EQ(Envoy::Http::FilterHeadersStatus::StopIteration,
              filter_->decodeHeaders(headers, false));
  }

  void doDownstreamRequest() {
    startDownstreamRequest();

    Http::MetadataMap metadata_map{{"metadata", "metadata"}};
    EXPECT_EQ(Http::FilterMetadataStatus::Continue, filter_->decodeMetadata(metadata_map));
    Http::TestRequestTrailerMapImpl trailers;
    // Complete a full request cycle
    Envoy::Buffer::OwnedImpl buffer("nothing here");
    EXPECT_EQ(Envoy::Http::FilterDataStatus::StopIterationAndBuffer,
              filter_->decodeData(buffer, false));
    EXPECT_EQ(Envoy::Http::FilterTrailersStatus::StopIteration, filter_->decodeTrailers(trailers));
  }

  void expectAsyncClientSend() {
    EXPECT_CALL(factory_context_.server_factory_context_.cluster_manager_.thread_local_cluster_
                    .async_client_,
                send_(_, _, _))
        .WillOnce(Invoke(
            [&](Envoy::Http::RequestMessagePtr&, Envoy::Http::AsyncClient::Callbacks& cb,
                const Http::AsyncClient::RequestOptions&) -> Envoy::Http::AsyncClient::Request* {
              callbacks_.push_back(&cb);
              return &request_;
            }));
  }

  void completeRequest(const std::string& status, const std::string& body) {
    Http::ResponseMessagePtr msg(new Http::ResponseMessageImpl(
        Http::ResponseHeaderMapPtr{new Http::TestResponseHeaderMapImpl{{":status", status}}}));
    msg->body().add(body);
    popPendingCallback()->onSuccess(request_, std::move(msg));
  }

  void completeCreateRequest() {
    // return the create request
    completeRequest("201", R"EOF({"metadata":{"name":"a"}})EOF");
  }

  void completeGetStatusRequest(const std::string& status) {
    completeRequest("200", fmt::format(R"EOF({{"status":{{"state":"{}"}}}})EOF", status));
  }

  Envoy::Http::AsyncClient::Callbacks* popPendingCallback() {
    if (callbacks_.empty()) {
      // Can't use ASSERT_* as this is not a test function
      throw std::underflow_error("empty deque");
    }

    auto callbacks = callbacks_.front();
    callbacks_.pop_front();
    return callbacks;
  }

  NiceMock<Envoy::Http::MockStreamDecoderFilterCallbacks> filter_callbacks_;
  NiceMock<Envoy::Server::Configuration::MockFactoryContext> factory_context_;
  NiceMock<Envoy::Event::MockTimer>* attachmentTimeout_timer_{};
  Envoy::Http::MockAsyncClientRequest request_;
  SquashFilterConfigSharedPtr config_;
  std::shared_ptr<SquashFilter> filter_;
  std::deque<Envoy::Http::AsyncClient::Callbacks*> callbacks_;
};

TEST_F(SquashFilterTest, DecodeHeaderContinuesOnClientFail) {
  initFilter();

  EXPECT_CALL(factory_context_.server_factory_context_.cluster_manager_.thread_local_cluster_,
              httpAsyncClient())
      .WillOnce(ReturnRef(factory_context_.server_factory_context_.cluster_manager_
                              .thread_local_cluster_.async_client_));

  EXPECT_CALL(
      factory_context_.server_factory_context_.cluster_manager_.thread_local_cluster_.async_client_,
      send_(_, _, _))
      .WillOnce(Invoke(
          [&](Envoy::Http::RequestMessagePtr&, Envoy::Http::AsyncClient::Callbacks& callbacks,
              const Http::AsyncClient::RequestOptions&) -> Envoy::Http::AsyncClient::Request* {
            callbacks.onFailure(request_, Envoy::Http::AsyncClient::FailureReason::Reset);
            // Intentionally return nullptr (instead of request handle) to trigger a particular
            // code path.
            return nullptr;
          }));

  Http::TestRequestHeaderMapImpl headers{{":method", "GET"},
                                         {":authority", "www.solo.io"},
                                         {"x-squash-debug", "true"},
                                         {":path", "/getsomething"}};

  Envoy::Buffer::OwnedImpl data("nothing here");
  EXPECT_EQ(Envoy::Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(headers, false));
  EXPECT_EQ(Envoy::Http::FilterDataStatus::Continue, filter_->decodeData(data, false));
  Http::TestRequestTrailerMapImpl trailers;
  EXPECT_EQ(Envoy::Http::FilterTrailersStatus::Continue, filter_->decodeTrailers(trailers));
}

TEST_F(SquashFilterTest, DecodeContinuesOnCreateAttachmentFail) {
  startDownstreamRequest();

  EXPECT_CALL(filter_callbacks_, continueDecoding());
  EXPECT_CALL(*attachmentTimeout_timer_, disableTimer());
  popPendingCallback()->onFailure(request_, Envoy::Http::AsyncClient::FailureReason::Reset);

  Envoy::Buffer::OwnedImpl data("nothing here");
  EXPECT_EQ(Envoy::Http::FilterDataStatus::Continue, filter_->decodeData(data, false));
  Http::TestRequestTrailerMapImpl trailers;
  EXPECT_EQ(Envoy::Http::FilterTrailersStatus::Continue, filter_->decodeTrailers(trailers));
}

TEST_F(SquashFilterTest, DoesNothingWithNoHeader) {
  initFilter();
  EXPECT_CALL(factory_context_.server_factory_context_.cluster_manager_.thread_local_cluster_,
              httpAsyncClient())
      .Times(0);

  Http::TestRequestHeaderMapImpl headers{{":method", "GET"},
                                         {":authority", "www.solo.io"},
                                         {"x-not-squash-debug", "true"},
                                         {":path", "/getsomething"}};

  Envoy::Buffer::OwnedImpl data("nothing here");
  EXPECT_EQ(Envoy::Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(headers, false));
  EXPECT_EQ(Envoy::Http::FilterDataStatus::Continue, filter_->decodeData(data, false));
  Http::TestRequestTrailerMapImpl trailers;
  EXPECT_EQ(Envoy::Http::FilterTrailersStatus::Continue, filter_->decodeTrailers(trailers));
}

TEST_F(SquashFilterTest, Timeout) {
  startDownstreamRequest();

  // invoke timeout
  Envoy::Buffer::OwnedImpl buffer("nothing here");

  EXPECT_EQ(Envoy::Http::FilterDataStatus::StopIterationAndBuffer,
            filter_->decodeData(buffer, false));

  EXPECT_CALL(request_, cancel());
  EXPECT_CALL(filter_callbacks_, continueDecoding());

  EXPECT_CALL(filter_callbacks_.dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(filter_callbacks_.dispatcher_, popTrackedObject(_));
  attachmentTimeout_timer_->invokeCallback();

  EXPECT_EQ(Envoy::Http::FilterDataStatus::Continue, filter_->decodeData(buffer, false));
}

TEST_F(SquashFilterTest, HappyPathWithTrailers) {
  doDownstreamRequest();
  // Expect the get attachment request
  expectAsyncClientSend();
  completeCreateRequest();

  EXPECT_CALL(filter_callbacks_, continueDecoding());
  completeGetStatusRequest("attached");
}

TEST_F(SquashFilterTest, CheckRetryPollingAttachment) {
  doDownstreamRequest();
  // Expect the get attachment request
  expectAsyncClientSend();
  completeCreateRequest();

  auto retry_timer = new NiceMock<Envoy::Event::MockTimer>(&filter_callbacks_.dispatcher_);

  EXPECT_CALL(*retry_timer, enableTimer(config_->attachmentPollPeriod(), _));
  completeGetStatusRequest("attaching");

  // Expect the second get attachment request
  expectAsyncClientSend();
  EXPECT_CALL(filter_callbacks_.dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(filter_callbacks_.dispatcher_, popTrackedObject(_));

  retry_timer->invokeCallback();
  EXPECT_CALL(filter_callbacks_, continueDecoding());
  completeGetStatusRequest("attached");
}

TEST_F(SquashFilterTest, PollingAttachmentNoCluster) {
  doDownstreamRequest();
  // Expect the get attachment request
  expectAsyncClientSend();
  completeCreateRequest();

  auto retry_timer = new NiceMock<Envoy::Event::MockTimer>(&filter_callbacks_.dispatcher_);

  EXPECT_CALL(*retry_timer, enableTimer(config_->attachmentPollPeriod(), _));
  completeGetStatusRequest("attaching");

  // Expect the second get attachment request
  ON_CALL(factory_context_.server_factory_context_.cluster_manager_,
          getThreadLocalCluster("squash"))
      .WillByDefault(Return(nullptr));
  EXPECT_CALL(filter_callbacks_.dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(filter_callbacks_.dispatcher_, popTrackedObject(_));
  EXPECT_CALL(*retry_timer, enableTimer(config_->attachmentPollPeriod(), _));
  retry_timer->invokeCallback();
}

TEST_F(SquashFilterTest, CheckRetryPollingAttachmentOnFailure) {
  doDownstreamRequest();
  // Expect the first get attachment request
  expectAsyncClientSend();
  completeCreateRequest();

  auto retry_timer = new NiceMock<Envoy::Event::MockTimer>(&filter_callbacks_.dispatcher_);
  EXPECT_CALL(*retry_timer, enableTimer(config_->attachmentPollPeriod(), _));
  popPendingCallback()->onFailure(request_, Envoy::Http::AsyncClient::FailureReason::Reset);

  // Expect the second get attachment request
  expectAsyncClientSend();

  EXPECT_CALL(filter_callbacks_.dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(filter_callbacks_.dispatcher_, popTrackedObject(_));
  retry_timer->invokeCallback();

  EXPECT_CALL(filter_callbacks_, continueDecoding());
  completeGetStatusRequest("attached");
}

TEST_F(SquashFilterTest, DestroyedInTheMiddle) {
  doDownstreamRequest();
  // Expect the get attachment request
  expectAsyncClientSend();
  completeCreateRequest();

  auto retry_timer = new NiceMock<Envoy::Event::MockTimer>(&filter_callbacks_.dispatcher_);
  EXPECT_CALL(*retry_timer, enableTimer(config_->attachmentPollPeriod(), _));
  completeGetStatusRequest("attaching");

  EXPECT_CALL(*attachmentTimeout_timer_, disableTimer());
  EXPECT_CALL(*retry_timer, disableTimer());

  filter_->onDestroy();
}

TEST_F(SquashFilterTest, InvalidJsonForCreateAttachment) {
  doDownstreamRequest();
  EXPECT_CALL(filter_callbacks_, continueDecoding());
  completeRequest("201", "This is not a JSON object");
}

TEST_F(SquashFilterTest, InvalidJsonForGetAttachment) {
  doDownstreamRequest();
  // Expect the get attachment request
  expectAsyncClientSend();
  completeCreateRequest();

  auto retry_timer = new NiceMock<Envoy::Event::MockTimer>(&filter_callbacks_.dispatcher_);
  EXPECT_CALL(*retry_timer, enableTimer(config_->attachmentPollPeriod(), _));
  completeRequest("200", "This is not a JSON object");
}

TEST_F(SquashFilterTest, InvalidResponseWithNoBody) {
  doDownstreamRequest();
  // Expect the get attachment request
  expectAsyncClientSend();
  completeCreateRequest();

  auto retry_timer = new NiceMock<Envoy::Event::MockTimer>(&filter_callbacks_.dispatcher_);
  EXPECT_CALL(*retry_timer, enableTimer(config_->attachmentPollPeriod(), _));
  Http::ResponseMessagePtr msg(new Http::ResponseMessageImpl(Http::ResponseHeaderMapPtr{
      new Http::TestResponseHeaderMapImpl{{":status", "200"}, {"content-length", "0"}}}));
  popPendingCallback()->onSuccess(request_, std::move(msg));
}

TEST_F(SquashFilterTest, DestroyedInFlight) {
  doDownstreamRequest();

  EXPECT_CALL(request_, cancel());
  EXPECT_CALL(*attachmentTimeout_timer_, disableTimer());

  filter_->onDestroy();
}

TEST_F(SquashFilterTest, TimerExpiresInline) {
  initFilter();

  attachmentTimeout_timer_ = new NiceMock<Envoy::Event::MockTimer>(&filter_callbacks_.dispatcher_);
  EXPECT_CALL(*attachmentTimeout_timer_, enableTimer(config_->attachmentTimeout(), _))
      .WillOnce(Invoke([&](const std::chrono::milliseconds&, const ScopeTrackedObject* scope) {
        attachmentTimeout_timer_->scope_ = scope;
        attachmentTimeout_timer_->enabled_ = true;
        // timer expires inline
        EXPECT_CALL(filter_callbacks_.dispatcher_, pushTrackedObject(_));
        EXPECT_CALL(filter_callbacks_.dispatcher_, popTrackedObject(_));
        attachmentTimeout_timer_->invokeCallback();
      }));

  EXPECT_CALL(
      factory_context_.server_factory_context_.cluster_manager_.thread_local_cluster_.async_client_,
      send_(_, _, _))
      .WillOnce(Invoke([&](Envoy::Http::RequestMessagePtr&, Envoy::Http::AsyncClient::Callbacks&,
                           const Http::AsyncClient::RequestOptions&)
                           -> Envoy::Http::AsyncClient::Request* { return &request_; }));

  EXPECT_CALL(request_, cancel());
  Http::TestRequestHeaderMapImpl headers{{":method", "GET"},
                                         {":authority", "www.solo.io"},
                                         {"x-squash-debug", "true"},
                                         {":path", "/getsomething"}};
  EXPECT_EQ(Envoy::Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(headers, false));
}

} // namespace Squash
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_test",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_test(
    name = "squash_filter_test",
    srcs = ["squash_filter_test.cc"],
    deps = [
        "//contrib/squash/filters/http/source:squash_filter_lib",
        "//envoy/event:dispatcher_interface",
        "//source/common/http:header_map_lib",
        "//source/common/stats:stats_lib",
        "//test/mocks/http:http_mocks",
        "//test/mocks/server:factory_context_mocks",
        "//test/mocks/upstream:cluster_manager_mocks",
        "//test/test_common:environment_lib",
        "@envoy_api//contrib/envoy/extensions/filters/http/squash/v3:pkg_cc_proto",
    ],
)

envoy_cc_test(
    name = "squash_filter_integration_test",
    srcs = ["squash_filter_integration_test.cc"],
    deps = [
        "//contrib/squash/filters/http/source:config",
        "//test/integration:http_integration_lib",
        "@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto",
    ],
)

envoy_cc_test(
    name = "config_test",
    srcs = ["config_test.cc"],
    deps = [
        "//contrib/squash/filters/http/source:config",
        "//test/mocks/server:factory_context_mocks",
        "//test/test_common:utility_lib",
        "@envoy_api//contrib/envoy/extensions/filters/http/squash/v3:pkg_cc_proto",
    ],
)
#pragma once

#include "source/extensions/filters/http/common/factory_base.h"

#include "contrib/envoy/extensions/filters/http/squash/v3/squash.pb.h"
#include "contrib/envoy/extensions/filters/http/squash/v3/squash.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace Squash {

/**
 * Config registration for the squash filter. @see NamedHttpFilterConfigFactory.
 */
class SquashFilterConfigFactory
    : public Common::FactoryBase<envoy::extensions::filters::http::squash::v3::Squash> {
public:
  SquashFilterConfigFactory() : FactoryBase("envoy.filters.http.squash") {}

private:
  Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoy::extensions::filters::http::squash::v3::Squash& proto_config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

} // namespace Squash
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

# L7 HTTP filter that implements the Squash microservice debugger
# Public docs: https://envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/squash_filter

envoy_contrib_package()

envoy_cc_library(
    name = "squash_filter_lib",
    srcs = ["squash_filter.cc"],
    hdrs = ["squash_filter.h"],
    deps = [
        "//envoy/event:timer_interface",
        "//envoy/http:codes_interface",
        "//envoy/http:filter_interface",
        "//envoy/http:header_map_interface",
        "//envoy/upstream:cluster_manager_interface",
        "//source/common/common:empty_string",
        "//source/common/common:enum_to_int",
        "//source/common/http:headers_lib",
        "//source/common/http:message_lib",
        "//source/common/http:utility_lib",
        "//source/common/json:json_loader_lib",
        "//source/common/protobuf:utility_lib",
        "@envoy_api//contrib/envoy/extensions/filters/http/squash/v3:pkg_cc_proto",
    ],
)

envoy_cc_contrib_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    deps = [
        ":squash_filter_lib",
        "//envoy/registry",
        "//source/common/protobuf:utility_lib",
        "//source/extensions/filters/http/common:factory_base_lib",
        "@envoy_api//contrib/envoy/extensions/filters/http/squash/v3:pkg_cc_proto",
    ],
)
#include "contrib/squash/filters/http/source/squash_filter.h"

#include <memory>

#include "envoy/http/codes.h"

#include "source/common/common/empty_string.h"
#include "source/common/common/enum_to_int.h"
#include "source/common/common/logger.h"
#include "source/common/http/headers.h"
#include "source/common/http/message_impl.h"
#include "source/common/http/utility.h"
#include "source/common/json/json_loader.h"
#include "source/common/protobuf/protobuf.h"
#include "source/common/protobuf/utility.h"

#include "absl/container/fixed_array.h"
#include "contrib/envoy/extensions/filters/http/squash/v3/squash.pb.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace Squash {

using std::placeholders::_1;

const std::regex SquashFilterConfig::ENV_REGEX("\\{\\{ (\\w+) \\}\\}");

const std::string SquashFilter::POST_ATTACHMENT_PATH = "/api/v2/debugattachment/";
const std::string SquashFilter::SERVER_AUTHORITY = "squash-server";
const std::string SquashFilter::ATTACHED_STATE = "attached";
const std::string SquashFilter::ERROR_STATE = "error";

SquashFilterConfig::SquashFilterConfig(
    const envoy::extensions::filters::http::squash::v3::Squash& proto_config,
    Upstream::ClusterManager& cluster_manager)
    : cluster_name_(proto_config.cluster()),
      attachment_json_(getAttachment(proto_config.attachment_template())),
      attachment_timeout_(PROTOBUF_GET_MS_OR_DEFAULT(proto_config, attachment_timeout, 60000)),
      attachment_poll_period_(
          PROTOBUF_GET_MS_OR_DEFAULT(proto_config, attachment_poll_period, 1000)),
      request_timeout_(PROTOBUF_GET_MS_OR_DEFAULT(proto_config, request_timeout, 1000)) {

  if (!cluster_manager.clusters().hasCluster(cluster_name_)) {
    throw EnvoyException(
        fmt::format("squash filter: unknown cluster '{}' in squash config", cluster_name_));
  }
}

std::string SquashFilterConfig::getAttachment(const ProtobufWkt::Struct& attachment_template) {
  ProtobufWkt::Struct attachment_json(attachment_template);
  updateTemplateInStruct(attachment_json);
  return MessageUtil::getJsonStringFromMessageOrError(attachment_json);
}

void SquashFilterConfig::updateTemplateInStruct(ProtobufWkt::Struct& attachment_template) {
  for (auto& value_it : *attachment_template.mutable_fields()) {
    auto& curvalue = value_it.second;
    updateTemplateInValue(curvalue);
  }
}

void SquashFilterConfig::updateTemplateInValue(ProtobufWkt::Value& curvalue) {
  switch (curvalue.kind_case()) {
  case ProtobufWkt::Value::kStructValue: {
    updateTemplateInStruct(*curvalue.mutable_struct_value());
    break;
  }
  case ProtobufWkt::Value::kListValue: {
    ProtobufWkt::ListValue& values = *curvalue.mutable_list_value();
    for (int i = 0; i < values.values_size(); i++) {
      updateTemplateInValue(*values.mutable_values(i));
    }
    break;
  }
  case ProtobufWkt::Value::kStringValue: {
    curvalue.set_string_value(replaceEnv(curvalue.string_value()));
    break;
  }
  case ProtobufWkt::Value::KIND_NOT_SET:
  case ProtobufWkt::Value::kNullValue:
  case ProtobufWkt::Value::kBoolValue:
  case ProtobufWkt::Value::kNumberValue: {
    // Nothing here... we only need to transform strings
  }
  }
}

/*
 This function interpolates environment variables in a string template.
 To interpolate an environment variable named ENV, add '{{ ENV }}' (without the
  quotes, with the spaces) to the template string.

  See api/envoy/extensions/squash/filters/http/v3/squash.proto for the motivation on why this is
 needed.
*/
std::string SquashFilterConfig::replaceEnv(const std::string& attachment_template) {
  std::string s;

  auto end_last_match = attachment_template.begin();

  auto replaceEnvVarInTemplateCallback =
      [&s, &attachment_template,
       &end_last_match](const std::match_results<std::string::const_iterator>& match) {
        auto start_match = attachment_template.begin() + match.position(0);

        s.append(end_last_match, start_match);

        std::string envar_name = match[1].str();
        const char* envar_value = std::getenv(envar_name.c_str());
        if (envar_value == nullptr) {
          ENVOY_LOG(warn, "Squash: no environment variable named {}.", envar_name);
        } else {
          s.append(envar_value);
        }
        end_last_match = start_match + match.length(0);
      };

  std::sregex_iterator begin(attachment_template.begin(), attachment_template.end(), ENV_REGEX),
      end;
  std::for_each(begin, end, replaceEnvVarInTemplateCallback);
  s.append(end_last_match, attachment_template.end());

  return s;
}

SquashFilter::SquashFilter(SquashFilterConfigSharedPtr config, Upstream::ClusterManager& cm)
    : config_(config), attachment_poll_period_timer_(nullptr), attachment_timeout_timer_(nullptr),
      create_attachment_callback_(std::bind(&SquashFilter::onCreateAttachmentSuccess, this, _1),
                                  std::bind(&SquashFilter::onCreateAttachmentFailure, this, _1)),
      check_attachment_callback_(std::bind(&SquashFilter::onGetAttachmentSuccess, this, _1),
                                 std::bind(&SquashFilter::onGetAttachmentFailure, this, _1)),
      cm_(cm) {}

SquashFilter::~SquashFilter() = default;

void SquashFilter::onDestroy() { cleanup(); }

Http::FilterHeadersStatus SquashFilter::decodeHeaders(Http::RequestHeaderMap& headers, bool) {
  // Check for squash header
  if (headers.get(Http::Headers::get().XSquashDebug).empty()) {
    return Http::FilterHeadersStatus::Continue;
  }

  ENVOY_LOG(debug, "Squash: Holding request and requesting debug attachment");

  Http::RequestMessagePtr request(new Http::RequestMessageImpl());
  request->headers().setReferenceContentType(Http::Headers::get().ContentTypeValues.Json);
  request->headers().setReferencePath(POST_ATTACHMENT_PATH);
  request->headers().setReferenceHost(SERVER_AUTHORITY);
  request->headers().setReferenceMethod(Http::Headers::get().MethodValues.Post);
  request->body().add(config_->attachmentJson());

  is_squashing_ = true;
  const auto thread_local_cluster = cm_.getThreadLocalCluster(config_->clusterName());
  if (thread_local_cluster != nullptr) {
    in_flight_request_ = thread_local_cluster->httpAsyncClient().send(
        std::move(request), create_attachment_callback_,
        Http::AsyncClient::RequestOptions().setTimeout(config_->requestTimeout()));
  }

  if (in_flight_request_ == nullptr) {
    ENVOY_LOG(debug, "Squash: can't create request for squash server");
    is_squashing_ = false;
    return Http::FilterHeadersStatus::Continue;
  }

  attachment_timeout_timer_ =
      decoder_callbacks_->dispatcher().createTimer([this]() -> void { doneSquashing(); });
  attachment_timeout_timer_->enableTimer(config_->attachmentTimeout(),
                                         &decoder_callbacks_->scope());
  // Check if the timer expired inline.
  if (!is_squashing_) {
    return Http::FilterHeadersStatus::Continue;
  }

  return Http::FilterHeadersStatus::StopIteration;
}

Http::FilterDataStatus SquashFilter::decodeData(Buffer::Instance&, bool) {
  if (is_squashing_) {
    return Http::FilterDataStatus::StopIterationAndBuffer;
  }
  return Http::FilterDataStatus::Continue;
}

Http::FilterTrailersStatus SquashFilter::decodeTrailers(Http::RequestTrailerMap&) {
  if (is_squashing_) {
    return Http::FilterTrailersStatus::StopIteration;
  }
  return Http::FilterTrailersStatus::Continue;
}

void SquashFilter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {
  decoder_callbacks_ = &callbacks;
}

void SquashFilter::onCreateAttachmentSuccess(Http::ResponseMessagePtr&& m) {
  in_flight_request_ = nullptr;

  // Get the config object that was created
  if (Http::Utility::getResponseStatus(m->headers()) != enumToInt(Http::Code::Created)) {
    ENVOY_LOG(debug, "Squash: can't create attachment object. status {} - not squashing",
              m->headers().getStatusValue());
    doneSquashing();
  } else {
    std::string debug_attachment_id;
    try {
      Json::ObjectSharedPtr json_config = getJsonBody(std::move(m));
      debug_attachment_id =
          json_config->getObject("metadata", true)->getString("name", EMPTY_STRING);
    } catch (Json::Exception&) {
      debug_attachment_id = EMPTY_STRING;
    }

    if (debug_attachment_id.empty()) {
      ENVOY_LOG(debug, "Squash: failed to parse debug attachment object - check server settings.");
      doneSquashing();
    } else {
      debug_attachment_path_ = POST_ATTACHMENT_PATH + debug_attachment_id;
      pollForAttachment();
    }
  }
}

void SquashFilter::onCreateAttachmentFailure(Http::AsyncClient::FailureReason) {
  // in_flight_request_ will be null if we are called inline of async client send()
  bool request_created = in_flight_request_ != nullptr;
  in_flight_request_ = nullptr;

  // No retries here, as we couldn't create the attachment object.
  if (request_created) {
    // Cleanup not needed if onFailure called inline in async client send, as this means that
    // decodeHeaders is down the stack and will return Continue.
    doneSquashing();
  }
}

void SquashFilter::onGetAttachmentSuccess(Http::ResponseMessagePtr&& m) {
  in_flight_request_ = nullptr;

  std::string attachmentstate;
  try {
    Json::ObjectSharedPtr json_config = getJsonBody(std::move(m));
    attachmentstate = json_config->getObject("status", true)->getString("state", EMPTY_STRING);
  } catch (Json::Exception&) {
    // No state yet.. leave it empty for the retry logic.
  }

  if (attachmentstate == ATTACHED_STATE || attachmentstate == ERROR_STATE) {
    doneSquashing();
  } else {
    // Always schedule a retry. The attachment_timeout_timer_ will stop the retry loop when it
    // expires.
    scheduleRetry();
  }
}

void SquashFilter::onGetAttachmentFailure(Http::AsyncClient::FailureReason) {
  in_flight_request_ = nullptr;
  scheduleRetry();
}

void SquashFilter::scheduleRetry() {
  if (attachment_poll_period_timer_.get() == nullptr) {
    attachment_poll_period_timer_ =
        decoder_callbacks_->dispatcher().createTimer([this]() -> void { pollForAttachment(); });
  }
  attachment_poll_period_timer_->enableTimer(config_->attachmentPollPeriod(),
                                             &decoder_callbacks_->scope());
}

void SquashFilter::pollForAttachment() {
  Http::RequestMessagePtr request(new Http::RequestMessageImpl());
  request->headers().setReferenceMethod(Http::Headers::get().MethodValues.Get);
  request->headers().setReferencePath(debug_attachment_path_);
  request->headers().setReferenceHost(SERVER_AUTHORITY);

  const auto thread_local_cluster = cm_.getThreadLocalCluster(config_->clusterName());
  if (thread_local_cluster != nullptr) {
    in_flight_request_ = thread_local_cluster->httpAsyncClient().send(
        std::move(request), check_attachment_callback_,
        Http::AsyncClient::RequestOptions().setTimeout(config_->requestTimeout()));
  } else {
    scheduleRetry();
  }
  // No need to check if in_flight_request_ is null as onFailure will take care of
  // cleanup.
}

void SquashFilter::doneSquashing() {
  cleanup();
  decoder_callbacks_->continueDecoding();
}

void SquashFilter::cleanup() {
  is_squashing_ = false;

  if (attachment_poll_period_timer_) {
    attachment_poll_period_timer_->disableTimer();
    attachment_poll_period_timer_.reset();
  }

  if (attachment_timeout_timer_) {
    attachment_timeout_timer_->disableTimer();
    attachment_timeout_timer_.reset();
  }

  if (in_flight_request_ != nullptr) {
    in_flight_request_->cancel();
    in_flight_request_ = nullptr;
  }

  debug_attachment_path_ = EMPTY_STRING;
}

Json::ObjectSharedPtr SquashFilter::getJsonBody(Http::ResponseMessagePtr&& m) {
  return Json::Factory::loadFromString(m->bodyAsString());
}

} // namespace Squash
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include <regex>

#include "envoy/http/async_client.h"
#include "envoy/http/filter.h"
#include "envoy/json/json_object.h"
#include "envoy/upstream/cluster_manager.h"

#include "source/common/common/logger.h"
#include "source/common/protobuf/protobuf.h"

#include "absl/types/optional.h"
#include "contrib/envoy/extensions/filters/http/squash/v3/squash.pb.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace Squash {

class SquashFilterConfig : protected Logger::Loggable<Logger::Id::config> {
public:
  SquashFilterConfig(const envoy::extensions::filters::http::squash::v3::Squash& proto_config,
                     Upstream::ClusterManager& cluster_manager);
  const std::string& clusterName() const { return cluster_name_; }
  const std::string& attachmentJson() const { return attachment_json_; }
  const std::chrono::milliseconds& attachmentTimeout() const { return attachment_timeout_; }
  const std::chrono::milliseconds& attachmentPollPeriod() const { return attachment_poll_period_; }
  const std::chrono::milliseconds& requestTimeout() const { return request_timeout_; }

private:
  // Get the attachment body, and returns a JSON representations with environment variables
  // interpolated.
  static std::string getAttachment(const ProtobufWkt::Struct& attachment_template);
  // Recursively interpolates environment variables inline in the struct.
  static void updateTemplateInStruct(ProtobufWkt::Struct& attachment_template);
  // Recursively interpolates environment variables inline in the value.
  static void updateTemplateInValue(ProtobufWkt::Value& curvalue);
  // Interpolates environment variables in a string, and returns the new interpolated string.
  static std::string replaceEnv(const std::string& attachment_template);

  // The name of the squash server cluster.
  const std::string cluster_name_;
  // The attachment body sent to squash server on create attachment.
  const std::string attachment_json_;
  // The total amount of time for an attachment to reach a final state (attached or error).
  const std::chrono::milliseconds attachment_timeout_;
  // How frequently should we poll the attachment state with the squash server.
  const std::chrono::milliseconds attachment_poll_period_;
  // The timeout for individual requests to the squash server.
  const std::chrono::milliseconds request_timeout_;

  // Defines the pattern for interpolating environment variables in to the attachment.
  const static std::regex ENV_REGEX;
};

using SquashFilterConfigSharedPtr = std::shared_ptr<SquashFilterConfig>;

class AsyncClientCallbackShim : public Http::AsyncClient::Callbacks {
public:
  AsyncClientCallbackShim(std::function<void(Http::ResponseMessagePtr&&)>&& on_success,
                          std::function<void(Http::AsyncClient::FailureReason)>&& on_fail)
      : on_success_(on_success), on_fail_(on_fail) {}
  // Http::AsyncClient::Callbacks
  void onSuccess(const Http::AsyncClient::Request&, Http::ResponseMessagePtr&& m) override {
    on_success_(std::forward<Http::ResponseMessagePtr>(m));
  }
  void onFailure(const Http::AsyncClient::Request&, Http::AsyncClient::FailureReason f) override {
    on_fail_(f);
  }
  void onBeforeFinalizeUpstreamSpan(Tracing::Span&, const Http::ResponseHeaderMap*) override {}

private:
  const std::function<void(Http::ResponseMessagePtr&&)> on_success_;
  const std::function<void(Http::AsyncClient::FailureReason)> on_fail_;
};

class SquashFilter : public Http::StreamDecoderFilter,
                     protected Logger::Loggable<Logger::Id::filter> {
public:
  SquashFilter(SquashFilterConfigSharedPtr config, Upstream::ClusterManager& cm);
  ~SquashFilter() override;

  // Http::StreamFilterBase
  void onDestroy() override;

  // Http::StreamDecoderFilter
  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& headers, bool) override;
  Http::FilterDataStatus decodeData(Buffer::Instance&, bool) override;
  Http::FilterTrailersStatus decodeTrailers(Http::RequestTrailerMap&) override;
  void setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) override;

private:
  // AsyncClient callbacks for create attachment request
  void onCreateAttachmentSuccess(Http::ResponseMessagePtr&&);
  void onCreateAttachmentFailure(Http::AsyncClient::FailureReason);
  // AsyncClient callbacks for get attachment request
  void onGetAttachmentSuccess(Http::ResponseMessagePtr&&);
  void onGetAttachmentFailure(Http::AsyncClient::FailureReason);

  // Schedules a pollForAttachment
  void scheduleRetry();
  // Contacts Squash server to get the latest version of a debug attachment.
  void pollForAttachment();
  // Cleanup and continue the filter chain.
  void doneSquashing();
  void cleanup();
  // Creates a JSON from the message body.
  Json::ObjectSharedPtr getJsonBody(Http::ResponseMessagePtr&& m);

  const SquashFilterConfigSharedPtr config_;

  // Current state of the squash filter. If is_squashing_ is true, Hold the request while we
  // communicate with the squash server to attach a debugger. If it is false, let the request
  // pass-through.
  bool is_squashing_{false};
  // The API path of the created debug attachment (used for polling its state).
  std::string debug_attachment_path_;
  // A timer for polling the state of a debug attachment until it reaches a final state.
  Event::TimerPtr attachment_poll_period_timer_;
  // A timeout timer - after this timer expires we abort polling the debug attachment, and continue
  // filter iteration
  Event::TimerPtr attachment_timeout_timer_;
  // The current inflight request to the squash server.
  Http::AsyncClient::Request* in_flight_request_{nullptr};
  // Shims to get AsyncClient callbacks to specific methods, per API method.
  AsyncClientCallbackShim create_attachment_callback_;
  AsyncClientCallbackShim check_attachment_callback_;

  // ClusterManager to send requests to squash server
  Upstream::ClusterManager& cm_;
  // Callbacks used to continue filter iteration.
  Http::StreamDecoderFilterCallbacks* decoder_callbacks_{nullptr};

  // Create debug attachment URL path.
  const static std::string POST_ATTACHMENT_PATH;
  // Authority header for squash server.
  const static std::string SERVER_AUTHORITY;
  // The state of a debug attachment object when a debugger is successfully attached.
  const static std::string ATTACHED_STATE;
  // The state of a debug attachment object when an error has occurred.
  const static std::string ERROR_STATE;
};

} // namespace Squash
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/squash/filters/http/source/config.h"

#include "envoy/registry/registry.h"

#include "source/common/protobuf/protobuf.h"
#include "source/common/protobuf/utility.h"

#include "contrib/envoy/extensions/filters/http/squash/v3/squash.pb.h"
#include "contrib/envoy/extensions/filters/http/squash/v3/squash.pb.validate.h"
#include "contrib/squash/filters/http/source/squash_filter.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace Squash {

Http::FilterFactoryCb SquashFilterConfigFactory::createFilterFactoryFromProtoTyped(
    const envoy::extensions::filters::http::squash::v3::Squash& proto_config, const std::string&,
    Server::Configuration::FactoryContext& context) {
  auto& server_context = context.serverFactoryContext();

  SquashFilterConfigSharedPtr config = std::make_shared<SquashFilterConfig>(
      SquashFilterConfig(proto_config, server_context.clusterManager()));

  return [&server_context, config](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamDecoderFilter(
        std::make_shared<SquashFilter>(config, server_context.clusterManager()));
  };
}

/**
 * Static registration for the squash filter. @see RegisterFactory.
 */
LEGACY_REGISTER_FACTORY(SquashFilterConfigFactory,
                        Server::Configuration::NamedHttpFilterConfigFactory, "envoy.squash");

} // namespace Squash
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
envoy.filters.http.checksum:
  categories:
  - envoy.filters.http
  security_posture: requires_trusted_downstream_and_upstream
  status: alpha
envoy.filters.http.dynamo:
  categories:
  - envoy.filters.http
  security_posture: requires_trusted_downstream_and_upstream
  status: stable
envoy.filters.http.golang:
  categories:
  - envoy.filters.http
  security_posture: requires_trusted_downstream_and_upstream
  status: alpha
envoy.compression.qatzip.compressor:
  categories:
  - envoy.compression.compressor
  security_posture: robust_to_untrusted_downstream_and_upstream
  status: alpha
envoy.filters.http.squash:
  categories:
  - envoy.filters.http
  security_posture: requires_trusted_downstream_and_upstream
  status: stable
envoy.filters.http.sxg:
  categories:
  - envoy.filters.http
  security_posture: robust_to_untrusted_downstream
  status: alpha
envoy.filters.network.client_ssl_auth:
  categories:
  - envoy.filters.network
  security_posture: robust_to_untrusted_downstream
  status: stable
envoy.filters.network.kafka_broker:
  categories:
  - envoy.filters.network
  security_posture: requires_trusted_downstream_and_upstream
  status: wip
envoy.filters.network.kafka_mesh:
  categories:
  - envoy.filters.network
  security_posture: requires_trusted_downstream_and_upstream
  status: wip
envoy.filters.network.golang:
  categories:
  - envoy.filters.network
  security_posture: requires_trusted_downstream_and_upstream
  status: alpha
envoy.filters.network.rocketmq_proxy:
  categories:
  - envoy.filters.network
  security_posture: requires_trusted_downstream_and_upstream
  status: alpha
envoy.filters.network.mysql_proxy:
  categories:
  - envoy.filters.network
  security_posture: requires_trusted_downstream_and_upstream
  status: alpha
envoy.filters.network.postgres_proxy:
  categories:
  - envoy.filters.network
  security_posture: requires_trusted_downstream_and_upstream
  status: stable
envoy.filters.network.sip_proxy:
  categories:
  - envoy.filters.network
  security_posture: requires_trusted_downstream_and_upstream
  status: alpha
envoy.filters.sip.router:
  categories:
  - envoy.sip_proxy.filters
  security_posture: requires_trusted_downstream_and_upstream
  status: alpha
envoy.tls.key_providers.cryptomb:
  categories:
  - envoy.tls.key_providers
  security_posture: robust_to_untrusted_downstream
  status: alpha
envoy.tls.key_providers.qat:
  categories:
  - envoy.tls.key_providers
  security_posture: robust_to_untrusted_downstream
  status: alpha
envoy.bootstrap.vcl:
  categories:
  - envoy.bootstrap
  security_posture: requires_trusted_downstream_and_upstream
  status: alpha
envoy.matching.input_matchers.hyperscan:
  categories:
  - envoy.matching.input_matchers
  security_posture: requires_trusted_downstream_and_upstream
  status: alpha
envoy.filters.http.language:
  categories:
  - envoy.filters.http
  security_posture: requires_trusted_downstream_and_upstream
  status: alpha
envoy.network.connection_balance.dlb:
  categories:
  - envoy.network.connection_balance
  security_posture: requires_trusted_downstream_and_upstream
  status: alpha
envoy.regex_engines.hyperscan:
  categories:
  - envoy.regex_engines
  security_posture: requires_trusted_downstream_and_upstream
  status: alpha
envoy.xds_delegates.kv_store:
  categories:
  - envoy.xds_delegates
  security_posture: data_plane_agnostic
  status: wip
envoy.filters.network.generic_proxy:
  categories:
  - envoy.filters.network
  security_posture: requires_trusted_downstream_and_upstream
  status: wip
envoy.filters.generic.router:
  categories:
  - envoy.generic_proxy.filters
  security_posture: requires_trusted_downstream_and_upstream
  status: wip
  type_urls:
  - envoy.extensions.filters.network.generic_proxy.router.v3.Router
envoy.generic_proxy.codecs.dubbo:
  categories:
  - envoy.generic_proxy.codecs
  security_posture: requires_trusted_downstream_and_upstream
  status: wip
  type_urls:
  - envoy.extensions.filters.network.generic_proxy.codecs.dubbo.v3.DubboCodecConfig
envoy.generic_proxy.codecs.kafka:
  categories:
  - envoy.generic_proxy.codecs
  security_posture: requires_trusted_downstream_and_upstream
  status: wip
  type_urls:
  - envoy.extensions.filters.network.generic_proxy.codecs.kafka.v3.KafkaCodecConfig
envoy.router.cluster_specifier_plugin.golang:
  categories:
  - envoy.router.cluster_specifier_plugin
  security_posture: requires_trusted_downstream_and_upstream
  status: alpha
syntax = "proto3";

package test.envoy.config.xds;

// Configuration for InvalidProtoKeyValueStore.
message InvalidProtoKeyValueStoreConfig {
}
#include "envoy/admin/v3/config_dump.pb.h"
#include "envoy/api/os_sys_calls.h"
#include "envoy/common/key_value_store.h"
#include "envoy/config/cluster/v3/cluster.pb.h"
#include "envoy/service/discovery/v3/discovery.pb.h"
#include "envoy/service/runtime/v3/rtds.pb.h"
#include "envoy/service/secret/v3/sds.pb.h"

#include "source/extensions/config_subscription/grpc/xds_source_id.h"

#include "test/common/grpc/grpc_client_integration.h"
#include "test/integration/http_integration.h"
#include "test/test_common/registry.h"
#include "test/test_common/status_utility.h"
#include "test/test_common/utility.h"

#include "contrib/config/test/invalid_proto_kv_store_config.pb.h"
#include "gtest/gtest.h"

namespace Envoy {
namespace {

constexpr char SDS_CLUSTER_NAME[] = "sds_cluster.lyft.com";
constexpr char RTDS_CLUSTER_NAME[] = "rtds_cluster";
constexpr char CDS_CLUSTER_NAME[] = "cds_cluster";
constexpr char CLIENT_CERT_NAME[] = "client_cert";

std::string kvStoreDelegateConfig() {
  const std::string filename = TestEnvironment::temporaryPath("xds_kv_store.txt");
  Api::OsSysCallsSingleton().get().unlink(filename.c_str());

  return fmt::format(R"EOF(
    name: envoy.config.config.KeyValueStoreXdsDelegate
    typed_config:
      "@type": type.googleapis.com/envoy.extensions.config.v3alpha.KeyValueStoreXdsDelegateConfig
      key_value_store_config:
        config:
          name: envoy.key_value.file_based
          typed_config:
            "@type": type.googleapis.com/envoy.extensions.key_value.file_based.v3.FileBasedKeyValueStoreConfig
            filename: {}
    )EOF",
                     filename);
}

std::string invalidProtoKvStoreDelegateConfig() {
  return R"EOF(
    name: envoy.config.config.KeyValueStoreXdsDelegate
    typed_config:
      "@type": type.googleapis.com/envoy.extensions.config.v3alpha.KeyValueStoreXdsDelegateConfig
      key_value_store_config:
        config:
          name: envoy.common.key_value.test_store
          typed_config:
            "@type": type.googleapis.com/test.envoy.config.xds.InvalidProtoKeyValueStoreConfig
    )EOF";
}

class KeyValueStoreXdsDelegateIntegrationTest
    : public HttpIntegrationTest,
      public Grpc::UnifiedOrLegacyMuxIntegrationParamTest {
public:
  KeyValueStoreXdsDelegateIntegrationTest()
      : HttpIntegrationTest(Http::CodecType::HTTP2, ipVersion(),
                            ConfigHelper::baseConfigNoListeners()) {
    use_lds_ = false;
    skip_tag_extraction_rule_check_ = true;

    if (isUnified()) {
      config_helper_.addRuntimeOverride("envoy.reloadable_features.unified_mux", "true");
    }

    // Make the default cluster HTTP2.
    config_helper_.addConfigModifier([](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
      ConfigHelper::setHttp2(*bootstrap.mutable_static_resources()->mutable_clusters(0));
    });

    // Add xDS clusters.
    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
      // Add the SDS cluster.
      addXdsCluster(bootstrap, std::string(SDS_CLUSTER_NAME));
      // Add the RTDS cluster.
      addXdsCluster(bootstrap, std::string(RTDS_CLUSTER_NAME));
    });

    // Set up the initial static cluster with SSL using SDS.
    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
      auto* transport_socket =
          bootstrap.mutable_static_resources()->mutable_clusters(0)->mutable_transport_socket();
      envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;
      tls_context.set_sni("lyft.com");
      auto* secret_config =
          tls_context.mutable_common_tls_context()->add_tls_certificate_sds_secret_configs();
      setUpSdsConfig(secret_config, CLIENT_CERT_NAME);
      transport_socket->set_name("envoy.transport_sockets.tls");
      transport_socket->mutable_typed_config()->PackFrom(tls_context);
    });

    // Add static runtime values.
    config_helper_.addRuntimeOverride("foo", "whatevs");
    config_helper_.addRuntimeOverride("bar", "yar");

    // Set up the RTDS runtime layer.
    config_helper_.addConfigModifier([](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
      auto* layer = bootstrap.mutable_layered_runtime()->add_layers();
      layer->set_name("some_rtds_layer");
      auto* rtds_layer = layer->mutable_rtds_layer();
      rtds_layer->set_name("some_rtds_layer");
      auto* rtds_config = rtds_layer->mutable_rtds_config();
      rtds_config->set_resource_api_version(envoy::config::core::v3::ApiVersion::V3);
      auto* api_config_source = rtds_config->mutable_api_config_source();
      api_config_source->set_transport_api_version(envoy::config::core::v3::ApiVersion::V3);
      api_config_source->set_api_type(envoy::config::core::v3::ApiConfigSource::GRPC);
      api_config_source->set_set_node_on_first_message_only(true);
      api_config_source->add_grpc_services()->mutable_envoy_grpc()->set_cluster_name(
          RTDS_CLUSTER_NAME);
    });

    // Add test xDS delegate.
    config_helper_.addConfigModifier([](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
      auto* delegate_extension = bootstrap.mutable_xds_delegate_extension();
      TestUtility::loadFromYaml(kvStoreDelegateConfig(), *delegate_extension);
    });
  }

  void initialize() override {
    HttpIntegrationTest::initialize();
    registerTestServerPorts({});
  }

  void TearDown() override {
    closeConnection(sds_connection_);
    closeConnection(rtds_connection_);
    cleanupUpstreamAndDownstream();
    codec_client_.reset();
    test_server_.reset();
    fake_upstreams_.clear();
  }

  void createUpstreams() override {
    // Static cluster.
    addFakeUpstream(Http::CodecType::HTTP2);
    // SDS Cluster.
    addFakeUpstream(Http::CodecType::HTTP2);
    // RTDS Cluster.
    addFakeUpstream(Http::CodecType::HTTP2);
  }

protected:
  std::unique_ptr<FakeUpstream>& getSdsUpstream() { return fake_upstreams_[1]; }
  std::unique_ptr<FakeUpstream>& getRtdsUpstream() { return fake_upstreams_[2]; }

  void addXdsCluster(envoy::config::bootstrap::v3::Bootstrap& bootstrap,
                     const std::string& cluster_name) {
    auto* xds_cluster = bootstrap.mutable_static_resources()->add_clusters();
    xds_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);
    xds_cluster->set_name(cluster_name);
    xds_cluster->mutable_load_assignment()->set_cluster_name(cluster_name);
    ConfigHelper::setHttp2(*xds_cluster);
  }

  void initXdsStream(FakeUpstream& upstream, FakeHttpConnectionPtr& connection,
                     FakeStreamPtr& stream) {
    AssertionResult result = upstream.waitForHttpConnection(*dispatcher_, connection);
    RELEASE_ASSERT(result, result.message());
    result = connection->waitForNewStream(*dispatcher_, stream);
    RELEASE_ASSERT(result, result.message());
    stream->startGrpcStream();
  }

  void closeConnection(FakeHttpConnectionPtr& connection) {
    if (!connection) {
      return;
    }
    AssertionResult result = connection->close();
    RELEASE_ASSERT(result, result.message());
    result = connection->waitForDisconnect();
    RELEASE_ASSERT(result, result.message());
    connection.reset();
  }

  void setUpSdsConfig(envoy::extensions::transport_sockets::tls::v3::SdsSecretConfig* secret_config,
                      const std::string& secret_name) {
    secret_config->set_name(secret_name);
    auto* config_source = secret_config->mutable_sds_config();
    config_source->set_resource_api_version(envoy::config::core::v3::ApiVersion::V3);
    auto* api_config_source = config_source->mutable_api_config_source();
    api_config_source->set_api_type(envoy::config::core::v3::ApiConfigSource::GRPC);
    api_config_source->set_transport_api_version(envoy::config::core::v3::V3);
    auto* grpc_service = api_config_source->add_grpc_services();
    setGrpcService(*grpc_service, SDS_CLUSTER_NAME, getSdsUpstream()->localAddress());
  }

  envoy::extensions::transport_sockets::tls::v3::Secret getClientSecret() {
    envoy::extensions::transport_sockets::tls::v3::Secret secret;
    secret.set_name(std::string(CLIENT_CERT_NAME));
    auto* tls_certificate = secret.mutable_tls_certificate();
    tls_certificate->mutable_certificate_chain()->set_filename(
        TestEnvironment::runfilesPath("test/config/integration/certs/clientcert.pem"));
    tls_certificate->mutable_private_key()->set_filename(
        TestEnvironment::runfilesPath("test/config/integration/certs/clientkey.pem"));
    return secret;
  }

  std::string getRuntimeKey(const std::string& key) {
    auto response = IntegrationUtil::makeSingleRequest(
        lookupPort("admin"), "GET", "/runtime?format=json", "", downstreamProtocol(), version_);
    EXPECT_TRUE(response->complete());
    EXPECT_EQ("200", response->headers().getStatusValue());
    Json::ObjectSharedPtr loader = TestEnvironment::jsonLoadFromString(response->body());
    auto entries = loader->getObject("entries");
    if (entries->hasObject(key)) {
      return entries->getObject(key)->getString("final_value");
    }
    return "";
  }

  void checkSecretExists(const std::string& secret_name, const std::string& version_info) {
    auto response = IntegrationUtil::makeSingleRequest(
        lookupPort("admin"), "GET", "/config_dump?resource=dynamic_active_secrets", "",
        downstreamProtocol(), version_);
    EXPECT_TRUE(response->complete());
    EXPECT_EQ("200", response->headers().getStatusValue());
    Json::ObjectSharedPtr loader = TestEnvironment::jsonLoadFromString(response->body());
    envoy::admin::v3::ConfigDump config_dump;
    TestUtility::loadFromJson(loader->asJsonString(), config_dump);
    // Expect at least the "client_cert" dynamic secret.
    ASSERT_GE(config_dump.configs_size(), 1);
    envoy::admin::v3::SecretsConfigDump::DynamicSecret dynamic_secret;
    ASSERT_OK(MessageUtil::unpackToNoThrow(config_dump.configs(0), dynamic_secret));
    EXPECT_EQ(secret_name, dynamic_secret.name());
    EXPECT_EQ(version_info, dynamic_secret.version_info());
  }

  void shutdownAndRestartTestServer() {
    // Shutdown the Envoy server.
    absl::Notification shutdown_done;
    Server::Instance& server = test_server_->server();
    server.dispatcher().post([&server, &shutdown_done]() {
      server.shutdown();
      shutdown_done.Notify();
    });
    ASSERT_TRUE(shutdown_done.WaitForNotificationWithTimeout(absl::Seconds(5)));
    // Reset the test server.
    test_server_.reset();
    // Reset the server init function, as we don't want xDS responses sent on restart (we want to
    // use the values in the KV store instead).
    on_server_init_function_ = nullptr;

    // Set up a new Envoy, using the previous Envoy's configuration, and create the test server.
    ConfigHelper helper(version_, config_helper_.bootstrap());

    // Close the connection between Envoy and the xDS FakeUpstreams.
    closeConnection(sds_connection_);
    closeConnection(rtds_connection_);
    // Bring down the xDS FakeUpstreams.
    getSdsUpstream().reset();
    getRtdsUpstream().reset();

    // Reset the xDS upstreams to new FakeUpstreams, since we'll re-establish a connection to xDS
    // after the Envoy server gets re-created and the KV store loaded.
    fake_upstreams_.pop_back(); // Removes the RTDS upstream.
    fake_upstreams_.pop_back(); // Removes the SDS upstream.
    // Adds the new SDS upstream.
    fake_upstreams_.emplace_back(std::make_unique<FakeUpstream>(
        0, version_, configWithType(Http::CodecType::HTTP2), /*defer_initialization=*/true));
    // Adds the new RTDS upstream.
    fake_upstreams_.emplace_back(std::make_unique<FakeUpstream>(
        0, version_, configWithType(Http::CodecType::HTTP2), /*defer_initialization=*/true));

    std::vector<uint32_t> ports;
    std::vector<uint32_t> zero;
    for (auto& upstream : fake_upstreams_) {
      if (upstream->localAddress()->ip()) {
        ports.push_back(upstream->localAddress()->ip()->port());
        zero.push_back(0);
      }
    }
    helper.setPorts(zero, true); // Zero out ports set by config_helper_'s finalize();
    const std::string bootstrap_path = finalizeConfigWithPorts(helper, ports, use_lds_);

    std::vector<std::string> named_ports;
    const auto& static_resources = config_helper_.bootstrap().static_resources();
    named_ports.reserve(static_resources.listeners_size());
    for (int i = 0; i < static_resources.listeners_size(); ++i) {
      named_ports.push_back(static_resources.listeners(i).name());
    }

    // Create and start the new Envoy.
    createGeneratedApiTestServer(bootstrap_path, named_ports, {false, true, false}, false,
                                 test_server_);
    registerTestServerPorts(named_ports, test_server_);
  }

  FakeHttpConnectionPtr sds_connection_;
  FakeStreamPtr sds_stream_;
  FakeHttpConnectionPtr rtds_connection_;
  FakeStreamPtr rtds_stream_;
  uint32_t rtds_upstream_port_;
};

INSTANTIATE_TEST_SUITE_P(IpVersions, KeyValueStoreXdsDelegateIntegrationTest,
                         UNIFIED_LEGACY_GRPC_CLIENT_INTEGRATION_PARAMS);

TEST_P(KeyValueStoreXdsDelegateIntegrationTest, BasicSuccess) {
  on_server_init_function_ = [this]() {
    {
      // SDS.
      initXdsStream(*getSdsUpstream(), sds_connection_, sds_stream_);
      EXPECT_TRUE(compareSotwDiscoveryRequest(
          /*expected_type_url=*/Config::TypeUrl::get().Secret, /*expected_version=*/"",
          /*expected_resource_names=*/{std::string(CLIENT_CERT_NAME)}, /*expect_node=*/true,
          /*expected_error_code=*/Grpc::Status::WellKnownGrpcStatus::Ok,
          /*expected_error_message=*/"", sds_stream_.get()));
      auto sds_resource = getClientSecret();
      sendSotwDiscoveryResponse<envoy::extensions::transport_sockets::tls::v3::Secret>(
          Config::TypeUrl::get().Secret, {sds_resource}, "1", sds_stream_.get());
    }
    {
      // RTDS.
      initXdsStream(*getRtdsUpstream(), rtds_connection_, rtds_stream_);
      EXPECT_TRUE(compareSotwDiscoveryRequest(
          /*expected_type_url=*/Config::TypeUrl::get().Runtime,
          /*expected_version=*/"",
          /*expected_resource_names=*/{"some_rtds_layer"}, /*expect_node=*/true,
          /*expected_error_code=*/Grpc::Status::WellKnownGrpcStatus::Ok,
          /*expected_error_message=*/"", rtds_stream_.get()));
      auto rtds_resource = TestUtility::parseYaml<envoy::service::runtime::v3::Runtime>(R"EOF(
          name: some_rtds_layer
          layer:
            foo: bar
            baz: meh
      )EOF");
      sendSotwDiscoveryResponse<envoy::service::runtime::v3::Runtime>(
          Config::TypeUrl::get().Runtime, {rtds_resource}, "1", rtds_stream_.get());
    }
  };

  initialize();

  // Wait until the discovery responses have been processed.
  test_server_->waitForCounterGe(
      "cluster.cluster_0.client_ssl_socket_factory.ssl_context_update_by_sds", 1);
  test_server_->waitForCounterGe("runtime.load_success", 2);

  // Verify that the xDS resources are used by Envoy.
  checkSecretExists(std::string(CLIENT_CERT_NAME), /*version_info=*/"1");
  EXPECT_EQ("bar", getRuntimeKey("foo"));
  EXPECT_EQ("yar", getRuntimeKey("bar"));
  EXPECT_EQ("meh", getRuntimeKey("baz"));

  // Send an update to the RTDS resource, from the RTDS cluster to the Envoy test server.
  EXPECT_TRUE(compareSotwDiscoveryRequest(
      /*expected_type_url=*/Config::TypeUrl::get().Runtime, /*expected_version=*/"1",
      /*expected_resource_names=*/{"some_rtds_layer"}, /*expect_node=*/false,
      /*expected_error_code=*/Grpc::Status::WellKnownGrpcStatus::Ok,
      /*expected_error_message=*/"", rtds_stream_.get()));
  auto rtds_resource = TestUtility::parseYaml<envoy::service::runtime::v3::Runtime>(R"EOF(
    name: some_rtds_layer
    layer:
      baz: saz
  )EOF");
  sendSotwDiscoveryResponse<envoy::service::runtime::v3::Runtime>(
      Config::TypeUrl::get().Runtime, {rtds_resource}, "2", rtds_stream_.get());
  test_server_->waitForCounterGe("runtime.load_success", 3);

  EXPECT_EQ("whatevs", getRuntimeKey("foo"));
  EXPECT_EQ("yar", getRuntimeKey("bar"));
  EXPECT_EQ("saz", getRuntimeKey("baz"));

  // Kill the current test server, and restart it using the same configuration.
  shutdownAndRestartTestServer();

  // Wait until SDS and RTDS have been loaded from the KV store and updated the Envoy instance.
  test_server_->waitForCounterGe(
      "cluster.cluster_0.client_ssl_socket_factory.ssl_context_update_by_sds", 1);
  // Two runtime loads are expected, one for the admin layer and one for the RTDS layer.
  test_server_->waitForCounterGe("runtime.load_success", 2);

  // Verify that the latest resource values in the KV store are used by Envoy.
  EXPECT_EQ(2, test_server_->counter("xds.kv_store.load_success")->value());
  EXPECT_EQ(0, test_server_->counter("xds.kv_store.resources_not_found")->value());
  EXPECT_EQ(0, test_server_->counter("xds.kv_store.resource_missing")->value());
  EXPECT_EQ(0, test_server_->counter("xds.kv_store.parse_failed")->value());
  checkSecretExists(std::string(CLIENT_CERT_NAME), /*version_info=*/"1");
  EXPECT_EQ("whatevs", getRuntimeKey("foo"));
  EXPECT_EQ("yar", getRuntimeKey("bar"));
  EXPECT_EQ("saz", getRuntimeKey("baz"));

  // Start the FakeUpstream's listener and re-establish the connection with the RTDS upstream.
  getRtdsUpstream()->initializeServer();
  initXdsStream(*getRtdsUpstream(), rtds_connection_, rtds_stream_);

  // Send v2 of the RTDS layer.
  auto rtds_resource_v2 = TestUtility::parseYaml<envoy::service::runtime::v3::Runtime>(R"EOF(
          name: some_rtds_layer
          layer:
            foo: zoo
            baz: jazz
  )EOF");
  sendSotwDiscoveryResponse<envoy::service::runtime::v3::Runtime>(
      Config::TypeUrl::get().Runtime, {rtds_resource_v2}, /*version=*/"3", rtds_stream_.get());

  test_server_->waitForCounterGe("runtime.load_success", 3);

  // Verify that the values from the xDS response are used instead of from the persisted xDS once
  // connectivity is re-established.
  EXPECT_EQ("zoo", getRuntimeKey("foo"));
  EXPECT_EQ("jazz", getRuntimeKey("baz"));
}

// A KeyValueStore implementation that returns an invalid proto field value for a Cluster resource.
class InvalidProtoKeyValueStore : public KeyValueStore {
public:
  absl::optional<absl::string_view> get(absl::string_view) override { return absl::nullopt; }
  void remove(absl::string_view) override {}
  void addOrUpdate(absl::string_view, absl::string_view,
                   absl::optional<std::chrono::seconds>) override {}
  void flush() override {}

  // We only have a cds_config making wildcard requests, so we only need to implement the iterate
  // function.
  void iterate(ConstIterateCb cb) const override {
    const Config::XdsConfigSourceId source_id{CDS_CLUSTER_NAME, Config::TypeUrl::get().Cluster};
    const std::string cluster_name = "cluster_A";
    const std::string key = absl::StrCat(source_id.toKey(), "+", cluster_name);

    // 9999 is an invalid enum value for LbPolicy.
    auto cluster_resource = TestUtility::parseYaml<envoy::config::cluster::v3::Cluster>(
        fmt::format(R"EOF(
         name: {}
         connect_timeout: 5s
         type: STATIC
         load_assignment:
           cluster_name: {}
         lb_policy: {}
         typed_extension_protocol_options:
           envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
             "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
             explicit_http_config:
               http2_protocol_options: {{}}
        )EOF",
                    cluster_name, cluster_name, 9999));

    envoy::service::discovery::v3::Resource r;
    r.set_name(cluster_name);
    r.set_version("1");
    r.mutable_resource()->PackFrom(cluster_resource);

    std::string value;
    r.SerializeToString(&value);

    cb(key, value);
  }
};

// A factory for creating the InvalidProtoKeyValueStore test implementation.
class InvalidProtoKeyValueStoreFactory : public KeyValueStoreFactory {
public:
  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<test::envoy::config::xds::InvalidProtoKeyValueStoreConfig>();
  }

  std::string name() const override { return "envoy.common.key_value.test_store"; };

  KeyValueStorePtr createStore(const Protobuf::Message& /*config*/,
                               ProtobufMessage::ValidationVisitor& /*validation_visitor*/,
                               Event::Dispatcher& /*dispatcher*/,
                               Filesystem::Instance& /*file_system*/) override {
    return std::make_unique<InvalidProtoKeyValueStore>();
  }
};

class InvalidProtoKeyValueStoreXdsDelegateIntegrationTest
    : public HttpIntegrationTest,
      public Grpc::UnifiedOrLegacyMuxIntegrationParamTest {
public:
  InvalidProtoKeyValueStoreXdsDelegateIntegrationTest()
      : HttpIntegrationTest(Http::CodecType::HTTP2, ipVersion(),
                            ConfigHelper::baseConfigNoListeners()) {
    use_lds_ = false;
    skip_tag_extraction_rule_check_ = true;

    if (isUnified()) {
      config_helper_.addRuntimeOverride("envoy.reloadable_features.unified_mux", "true");
    }

    // One static CDS cluster and CDS config.
    config_helper_.addConfigModifier([](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
      auto* xds_cluster = bootstrap.mutable_static_resources()->mutable_clusters(0);
      xds_cluster->set_name(std::string(CDS_CLUSTER_NAME));
      xds_cluster->mutable_load_assignment()->set_cluster_name(xds_cluster->name());
      ConfigHelper::setHttp2(*xds_cluster);

      auto* cds = bootstrap.mutable_dynamic_resources()->mutable_cds_config();
      const std::string cds_yaml = fmt::format(R"EOF(
        resource_api_version: V3
        api_config_source:
          api_type: GRPC
          transport_api_version: V3
          grpc_services:
            envoy_grpc:
              cluster_name: {}
          set_node_on_first_message_only: true
      )EOF",
                                               CDS_CLUSTER_NAME);
      TestUtility::loadFromYaml(cds_yaml, *cds);
    });

    // Add test xDS delegate.
    config_helper_.addConfigModifier([](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
      auto* delegate_extension = bootstrap.mutable_xds_delegate_extension();
      TestUtility::loadFromYaml(invalidProtoKvStoreDelegateConfig(), *delegate_extension);
    });
  }

  void initialize() override {
    setUpstreamCount(1);
    HttpIntegrationTest::initialize();
    // Reset the upstream so the connection cannot be established.
    fake_upstreams_[0].reset();
    registerTestServerPorts({});
  }

  void TearDown() override { test_server_.reset(); }

  void createUpstreams() override {
    // CDS Cluster.
    addFakeUpstream(Http::CodecType::HTTP2);
  }
};

INSTANTIATE_TEST_SUITE_P(IpVersions, InvalidProtoKeyValueStoreXdsDelegateIntegrationTest,
                         UNIFIED_LEGACY_GRPC_CLIENT_INTEGRATION_PARAMS);

TEST_P(InvalidProtoKeyValueStoreXdsDelegateIntegrationTest, InvalidProto) {
  InvalidProtoKeyValueStoreFactory factory;
  Registry::InjectFactory<KeyValueStoreFactory> registered(factory);

  initialize();

  // Make sure that the proto parsing of a serialized resource with an invalid enum value fails.
  test_server_->waitForCounterEq("xds.kv_store.xds_load_failed", 1);
}

} // namespace
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_test",
    "envoy_contrib_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_test(
    name = "kv_store_xds_delegate_test",
    srcs = [
        "kv_store_xds_delegate_test.cc",
    ],
    deps = [
        "//contrib/config/source:kv_store_xds_delegate",
        "//source/extensions/config_subscription/grpc:xds_source_id_lib",
        "//source/extensions/key_value/file_based:config_lib",
        "//test/mocks/api:api_mocks",
        "//test/mocks/event:event_mocks",
        "//test/mocks/protobuf:protobuf_mocks",
        "//test/test_common:environment_lib",
        "//test/test_common:resources_lib",
        "//test/test_common:simulated_time_system_lib",
        "//test/test_common:utility_lib",
        "@envoy_api//envoy/config/cluster/v3:pkg_cc_proto",
        "@envoy_api//envoy/service/discovery/v3:pkg_cc_proto",
        "@envoy_api//envoy/service/runtime/v3:pkg_cc_proto",
    ],
)

envoy_cc_test(
    name = "kv_store_xds_delegate_integration_test",
    srcs = [
        "kv_store_xds_delegate_integration_test.cc",
    ],
    data = [
        "//test/config/integration/certs",
    ],
    deps = [
        ":invalid_proto_kv_store_config_proto_cc_proto",
        "//contrib/config/source:kv_store_xds_delegate",
        "//envoy/common:key_value_store_interface",
        "//source/extensions/config_subscription/grpc:xds_source_id_lib",
        "//source/extensions/key_value/file_based:config_lib",
        "//test/common/grpc:grpc_client_integration_lib",
        "//test/integration:http_integration_lib",
        "//test/test_common:registry_lib",
        "//test/test_common:status_utility_lib",
        "//test/test_common:utility_lib",
        "@envoy_api//envoy/admin/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/cluster/v3:pkg_cc_proto",
        "@envoy_api//envoy/service/discovery/v3:pkg_cc_proto",
        "@envoy_api//envoy/service/runtime/v3:pkg_cc_proto",
        "@envoy_api//envoy/service/secret/v3:pkg_cc_proto",
    ],
)

envoy_proto_library(
    name = "invalid_proto_kv_store_config_proto",
    srcs = ["invalid_proto_kv_store_config.proto"],
)
#include "envoy/api/os_sys_calls.h"
#include "envoy/config/cluster/v3/cluster.pb.h"
#include "envoy/config/cluster/v3/cluster.pb.validate.h"
#include "envoy/service/discovery/v3/discovery.pb.h"
#include "envoy/service/discovery/v3/discovery.pb.validate.h"
#include "envoy/service/runtime/v3/rtds.pb.h"
#include "envoy/service/runtime/v3/rtds.pb.validate.h"

#include "source/extensions/config_subscription/grpc/xds_source_id.h"

#include "test/common/stats/stat_test_utility.h"
#include "test/mocks/api/mocks.h"
#include "test/mocks/event/mocks.h"
#include "test/mocks/protobuf/mocks.h"
#include "test/test_common/environment.h"
#include "test/test_common/resources.h"
#include "test/test_common/simulated_time_system.h"
#include "test/test_common/utility.h"

#include "contrib/config/source/kv_store_xds_delegate.h"
#include "gtest/gtest.h"

namespace Envoy {
namespace {

using ::Envoy::Config::DecodedResourceRef;
using ::Envoy::Config::XdsConfigSourceId;
using ::Envoy::Config::XdsSourceId;

envoy::config::core::v3::TypedExtensionConfig kvStoreDelegateConfig() {
  const std::string filename = TestEnvironment::temporaryPath("xds_kv_store.txt");
  Api::OsSysCallsSingleton().get().unlink(filename.c_str());

  const std::string config_str = fmt::format(R"EOF(
    name: envoy.config.config.KeyValueStoreXdsDelegate
    typed_config:
      "@type": type.googleapis.com/envoy.extensions.config.v3alpha.KeyValueStoreXdsDelegateConfig
      key_value_store_config:
        config:
          name: envoy.key_value.file_based
          typed_config:
            "@type": type.googleapis.com/envoy.extensions.key_value.file_based.v3.FileBasedKeyValueStoreConfig
            filename: {}
    )EOF",
                                             filename);

  envoy::config::core::v3::TypedExtensionConfig config;
  TestUtility::loadFromYaml(config_str, config);
  return config;
}

class KeyValueStoreXdsDelegateTest : public testing::Test {
public:
  KeyValueStoreXdsDelegateTest() : api_(Api::createApiForTest(store_)) {
    auto config = kvStoreDelegateConfig();
    Extensions::Config::KeyValueStoreXdsDelegateFactory delegate_factory;
    xds_delegate_ = delegate_factory.createXdsResourcesDelegate(
        config.typed_config(), ProtobufMessage::getStrictValidationVisitor(), *api_, dispatcher_);
  }

protected:
  envoy::service::runtime::v3::Runtime parseYamlIntoRuntimeResource(const std::string& yaml) {
    envoy::service::runtime::v3::Runtime runtime;
    TestUtility::loadFromYaml(yaml, runtime);
    return runtime;
  }

  envoy::config::cluster::v3::Cluster parseYamlIntoClusterResource(const std::string& yaml) {
    envoy::config::cluster::v3::Cluster cluster;
    TestUtility::loadFromYaml(yaml, cluster);
    return cluster;
  }

  template <typename Resource>
  void checkSavedResources(const XdsSourceId& source_id,
                           const absl::flat_hash_set<std::string>& resource_names,
                           const std::vector<DecodedResourceRef>& expected_resources) {
    // Retrieve the xDS resources.
    const auto retrieved_resources = xds_delegate_->getResources(source_id, resource_names);
    // Check that they're the same.
    EXPECT_EQ(expected_resources.size(), retrieved_resources.size());
    for (size_t i = 0; i < expected_resources.size(); ++i) {
      Resource unpacked_resource;
      MessageUtil::unpackTo(retrieved_resources[i].resource(), unpacked_resource);
      TestUtility::protoEqual(expected_resources[i].get().resource(), unpacked_resource);
    }
  }

  Stats::TestUtil::TestStore store_;
  Api::ApiPtr api_;
  testing::NiceMock<Event::MockDispatcher> dispatcher_;
  Config::XdsResourcesDelegatePtr xds_delegate_;
  Event::SimulatedTimeSystem time_source_;
};

TEST_F(KeyValueStoreXdsDelegateTest, SaveAndRetrieve) {
  const std::string authority_1 = "rtds_cluster";
  auto runtime_resource_1 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_1
    layer:
      foo: bar
      baz: meh
  )EOF");
  auto runtime_resource_2 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_2
    layer:
      abc: xyz
  )EOF");
  const auto saved_resources =
      TestUtility::decodeResources({runtime_resource_1, runtime_resource_2});
  const XdsConfigSourceId source_id{authority_1, Config::TypeUrl::get().Runtime};
  // Save xDS resources.
  xds_delegate_->onConfigUpdated(source_id, saved_resources.refvec_);

  checkSavedResources<envoy::service::runtime::v3::Runtime>(
      source_id, /*resource_names=*/{"some_resource_1", "some_resource_2"},
      saved_resources.refvec_);
  EXPECT_EQ(1, store_.counter("xds.kv_store.load_success").value());
  EXPECT_EQ(0, store_.counter("xds.kv_store.resources_not_found").value());
  EXPECT_EQ(0, store_.counter("xds.kv_store.resource_missing").value());
  EXPECT_EQ(0, store_.counter("xds.kv_store.parse_failed").value());
}

TEST_F(KeyValueStoreXdsDelegateTest, MultipleAuthoritiesAndTypes) {
  const std::string authority_1 = "rtds_cluster";
  const std::string authority_2 = "127.0.0.1:8585";

  auto runtime_resource_1 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_1
    layer:
      foo: bar
      baz: meh
  )EOF");
  auto runtime_resource_2 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_2
    layer:
      abc: xyz
  )EOF");
  auto cluster_resource_1 = parseYamlIntoClusterResource(R"EOF(
    name: cluster_1
    type: ORIGINAL_DST
    lb_policy: CLUSTER_PROVIDED
  )EOF");

  const auto authority_1_runtime_resources = TestUtility::decodeResources({runtime_resource_1});
  const auto authority_2_runtime_resources = TestUtility::decodeResources({runtime_resource_2});
  const auto authority_2_cluster_resources = TestUtility::decodeResources({cluster_resource_1});

  const XdsConfigSourceId source_id_1{authority_1, Config::TypeUrl::get().Runtime};
  const XdsConfigSourceId source_id_2_runtime{authority_2, Config::TypeUrl::get().Runtime};
  const XdsConfigSourceId source_id_2_cluster{authority_2, Config::TypeUrl::get().Cluster};

  // Save xDS resources.
  xds_delegate_->onConfigUpdated(source_id_1, authority_1_runtime_resources.refvec_);
  xds_delegate_->onConfigUpdated(source_id_2_runtime, authority_2_runtime_resources.refvec_);
  xds_delegate_->onConfigUpdated(source_id_2_cluster, authority_2_cluster_resources.refvec_);

  checkSavedResources<envoy::service::runtime::v3::Runtime>(
      source_id_1, /*resource_names=*/{"some_resource_1"}, authority_1_runtime_resources.refvec_);
  EXPECT_EQ(1, store_.counter("xds.kv_store.load_success").value());
  checkSavedResources<envoy::service::runtime::v3::Runtime>(source_id_2_runtime,
                                                            /*resource_names=*/{"some_resource_2"},
                                                            authority_2_runtime_resources.refvec_);
  EXPECT_EQ(2, store_.counter("xds.kv_store.load_success").value());
  checkSavedResources<envoy::config::cluster::v3::Cluster>(
      source_id_2_cluster, /*resource_names=*/{"cluster_1"}, authority_2_cluster_resources.refvec_);
  EXPECT_EQ(3, store_.counter("xds.kv_store.load_success").value());
  EXPECT_EQ(0, store_.counter("xds.kv_store.resources_not_found").value());
  EXPECT_EQ(0, store_.counter("xds.kv_store.resource_missing").value());
  EXPECT_EQ(0, store_.counter("xds.kv_store.parse_failed").value());
}

TEST_F(KeyValueStoreXdsDelegateTest, UpdatedSotwResources) {
  const std::string authority_1 = "rtds_cluster";
  auto runtime_resource_1 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_1
    layer:
      foo: bar
      baz: meh
  )EOF");
  auto runtime_resource_2 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_2
    layer:
      abc: xyz
  )EOF");

  const XdsConfigSourceId source_id{authority_1, Config::TypeUrl::get().Runtime};

  // Save xDS resources.
  const auto saved_resources =
      TestUtility::decodeResources({runtime_resource_1, runtime_resource_2});
  xds_delegate_->onConfigUpdated(source_id, saved_resources.refvec_);

  // Update xDS resources.
  runtime_resource_2 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_2
    layer:
      abc: klm
  )EOF");
  auto runtime_resource_3 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_3
    layer:
      xyz: 123
  )EOF");
  const auto updated_saved_resources = TestUtility::decodeResources({runtime_resource_3});
  xds_delegate_->onConfigUpdated(source_id, updated_saved_resources.refvec_);

  // Make sure all resources are present and at their latest versions.
  const auto all_resources =
      TestUtility::decodeResources({runtime_resource_1, runtime_resource_2, runtime_resource_3});
  checkSavedResources<envoy::service::runtime::v3::Runtime>(
      source_id, /*resource_names=*/{"some_resource_1", "some_resource_2", "some_resource_3"},
      all_resources.refvec_);
  EXPECT_EQ(1, store_.counter("xds.kv_store.load_success").value());
  EXPECT_EQ(0, store_.counter("xds.kv_store.resources_not_found").value());
  EXPECT_EQ(0, store_.counter("xds.kv_store.resource_missing").value());
  EXPECT_EQ(0, store_.counter("xds.kv_store.parse_failed").value());
}

TEST_F(KeyValueStoreXdsDelegateTest, Wildcard) {
  const std::string authority_1 = "rtds_cluster";
  auto runtime_resource_1 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_1
    layer:
      foo: bar
      baz: meh
  )EOF");
  auto runtime_resource_2 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_2
    layer:
      abc: xyz
  )EOF");
  const auto saved_resources =
      TestUtility::decodeResources({runtime_resource_1, runtime_resource_2});
  const XdsConfigSourceId source_id{authority_1, Config::TypeUrl::get().Runtime};
  // Save xDS resources.
  xds_delegate_->onConfigUpdated(source_id, saved_resources.refvec_);

  // Empty resource names, or just one entry with "*" means wildcard.
  checkSavedResources<envoy::service::runtime::v3::Runtime>(source_id, /*resource_names=*/{},
                                                            saved_resources.refvec_);
  EXPECT_EQ(1, store_.counter("xds.kv_store.load_success").value());
  checkSavedResources<envoy::service::runtime::v3::Runtime>(source_id, /*resource_names=*/{"*"},
                                                            saved_resources.refvec_);
  EXPECT_EQ(2, store_.counter("xds.kv_store.load_success").value());
  EXPECT_EQ(0, store_.counter("xds.kv_store.resources_not_found").value());
  EXPECT_EQ(0, store_.counter("xds.kv_store.resource_missing").value());
  EXPECT_EQ(0, store_.counter("xds.kv_store.parse_failed").value());
}

TEST_F(KeyValueStoreXdsDelegateTest, ResourceNotFound) {
  const std::string authority_1 = "rtds_cluster";
  auto runtime_resource_1 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_1
    layer:
      foo: bar
      baz: meh
  )EOF");
  const auto saved_resources = TestUtility::decodeResources({runtime_resource_1});
  const XdsConfigSourceId source_id{authority_1, Config::TypeUrl::get().Runtime};
  // Save xDS resources.
  xds_delegate_->onConfigUpdated(source_id, saved_resources.refvec_);

  // Empty resource names, or just one entry with "*" means wildcard.
  checkSavedResources<envoy::service::runtime::v3::Runtime>(
      source_id, /*resource_names=*/{"non_existent"}, /*expected_resources=*/{});
  EXPECT_EQ(0, store_.counter("xds.kv_store.load_success").value());
  EXPECT_EQ(1, store_.counter("xds.kv_store.resources_not_found").value());
  EXPECT_EQ(1, store_.counter("xds.kv_store.resource_missing").value());
  EXPECT_EQ(0, store_.counter("xds.kv_store.parse_failed").value());
}

TEST_F(KeyValueStoreXdsDelegateTest, ResourcesWithTTL) {
  const std::string authority_1 = "rtds_cluster";
  auto runtime_resource_1 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_1
    layer:
      foo: bar
      baz: meh
  )EOF");
  auto runtime_resource_2 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_2
    layer:
      abc: xyz
  )EOF");
  auto runtime_resource_3 = parseYamlIntoRuntimeResource(R"EOF(
    name: some_resource_3
    layer:
      boo: yikes
  )EOF");

  // some_resource_1 has no TTL
  // some_resource_2 has a TTL of 30 seconds.
  // some_resource_3 has a TTL of 60 seconds.
  Protobuf::RepeatedPtrField<envoy::service::discovery::v3::Resource> resources;
  auto* resource = resources.Add();
  resource->set_name("some_resource_1");
  resource->mutable_resource()->PackFrom(runtime_resource_1);
  resource = resources.Add();
  resource->set_name("some_resource_2");
  resource->mutable_resource()->PackFrom(runtime_resource_2);
  resource->mutable_ttl()->set_seconds(30);
  resource = resources.Add();
  resource->set_name("some_resource_3");
  resource->mutable_resource()->PackFrom(runtime_resource_3);
  resource->mutable_ttl()->set_seconds(60);

  auto decoded_resources = TestUtility::decodeResources<envoy::service::runtime::v3::Runtime>(
      resources, /*version=*/"1");

  // Save xDS resources.
  const XdsConfigSourceId source_id{authority_1, Config::TypeUrl::get().Runtime};
  xds_delegate_->onConfigUpdated(source_id, decoded_resources.refvec_);

  // TTL hasn't expired, so we should have all three xDS resources.
  checkSavedResources<envoy::service::runtime::v3::Runtime>(
      source_id, /*resource_names=*/{"some_resource_1", "some_resource_2", "some_resource_3"},
      decoded_resources.refvec_);

  // Advance time past the first TTL and let the timers fire.
  time_source_.advanceTimeWait(std::chrono::seconds(45));

  // We should only have resources 1 and 3.
  decoded_resources.refvec_.erase(std::next(decoded_resources.refvec_.begin())); // delete 2nd entry
  checkSavedResources<envoy::service::runtime::v3::Runtime>(
      source_id, /*resource_names=*/{"some_resource_1", "some_resource_3"},
      decoded_resources.refvec_);

  // Advance time past the second TTL and let the timers fire.
  time_source_.advanceTimeWait(std::chrono::seconds(45));

  // We should only have resource 1.
  decoded_resources.refvec_.erase(std::next(decoded_resources.refvec_.begin())); // delete 2nd entry
  checkSavedResources<envoy::service::runtime::v3::Runtime>(
      source_id, /*resource_names=*/{"some_resource_1"}, decoded_resources.refvec_);
}

} // namespace
} // namespace Envoy
#include "contrib/config/source/kv_store_xds_delegate.h"

#include "envoy/registry/registry.h"
#include "envoy/service/discovery/v3/discovery.pb.h"

#include "source/common/common/logger.h"
#include "source/common/config/utility.h"
#include "source/common/protobuf/utility.h"

#include "absl/strings/match.h"
#include "absl/strings/str_cat.h"
#include "absl/types/optional.h"
#include "contrib/envoy/extensions/config/v3alpha/kv_store_xds_delegate_config.pb.h"
#include "contrib/envoy/extensions/config/v3alpha/kv_store_xds_delegate_config.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace Config {
namespace {

using ::Envoy::Config::XdsSourceId;
using ::envoy::extensions::config::v3alpha::KeyValueStoreXdsDelegateConfig;

// Constructs the key for the resource, to be used in the KeyValueStore.
std::string constructKey(const XdsSourceId& source_id, const std::string& resource_name) {
  static constexpr char DELIMITER[] = "+";
  return absl::StrCat(source_id.toKey(), DELIMITER, resource_name);
}

} // namespace

XdsKeyValueStoreStats KeyValueStoreXdsDelegate::generateStats(Stats::Scope& scope) {
  return {ALL_XDS_KV_STORE_STATS(POOL_COUNTER(scope))};
}

KeyValueStoreXdsDelegate::KeyValueStoreXdsDelegate(KeyValueStorePtr&& xds_config_store,
                                                   Stats::Scope& root_scope)
    : xds_config_store_(std::move(xds_config_store)),
      scope_(root_scope.createScope("xds.kv_store.")), stats_(generateStats(*scope_)) {}

std::vector<envoy::service::discovery::v3::Resource> KeyValueStoreXdsDelegate::getResources(
    const XdsSourceId& source_id, const absl::flat_hash_set<std::string>& resource_names) const {
  std::vector<envoy::service::discovery::v3::Resource> resources;
  if (resource_names.empty() ||
      (resource_names.size() == 1 && resource_names.contains(Envoy::Config::Wildcard))) {
    // Empty names or one entry with "*" means wildcard.
    resources = getAllResources(source_id);
  } else {
    for (const std::string& resource_name : resource_names) {
      const std::string resource_key = constructKey(source_id, resource_name);
      if (const auto existing_resource = xds_config_store_->get(resource_key)) {
        envoy::service::discovery::v3::Resource r;
        if (r.ParseFromString(std::string(*existing_resource))) {
          resources.push_back(std::move(r));
        } else {
          // Resource failed to parse; this shouldn't happen unless fields get removed from the
          // proto. Since the serialized resource in the KV store is no longer parseable into an
          // xDS resource, we'll remove it from the store and not use it in xDS processing.
          xds_config_store_->remove(resource_key);
          stats_.parse_failed_.inc();
        }
      } else {
        stats_.resource_missing_.inc();
      }
    }
  }

  if (resources.empty()) {
    stats_.resources_not_found_.inc();
  } else {
    stats_.load_success_.inc();
  }

  return resources;
}

std::vector<envoy::service::discovery::v3::Resource>
KeyValueStoreXdsDelegate::getAllResources(const XdsSourceId& source_id) const {
  std::vector<envoy::service::discovery::v3::Resource> resources;
  // TODO(abeyad): This is slow as we are iterating over all entries in the KV store; the
  // expectation is we won't be iterating over too many values. But still, try to find a better way.
  xds_config_store_->iterate(
      [&resources, &source_id](const std::string& key, const std::string& value) {
        if (absl::StartsWith(key, source_id.toKey())) {
          // The source id is a prefix of the key, so it should be included in the list of returned
          // resources.
          envoy::service::discovery::v3::Resource r;
          r.ParseFromString(value);
          resources.push_back(std::move(r));
        }
        return KeyValueStore::Iterate::Continue;
      });
  return resources;
}

void KeyValueStoreXdsDelegate::onConfigUpdated(
    const XdsSourceId& source_id, const std::vector<Envoy::Config::DecodedResourceRef>& resources) {
  for (const auto& resource_ref : resources) {
    const auto& decoded_resource = resource_ref.get();
    if (decoded_resource.hasResource()) {
      envoy::service::discovery::v3::Resource r;
      // TODO(abeyad): Support dynamic parameter constraints.
      r.set_name(decoded_resource.name());
      r.set_version(decoded_resource.version());
      r.mutable_resource()->PackFrom(decoded_resource.resource());
      absl::optional<std::chrono::seconds> ttl = absl::nullopt;
      if (decoded_resource.ttl().has_value()) {
        r.mutable_ttl()->CopyFrom(
            Protobuf::util::TimeUtil::MillisecondsToDuration(decoded_resource.ttl()->count()));
        ttl = std::chrono::duration_cast<std::chrono::seconds>(decoded_resource.ttl().value());
      }
      std::string serialized_resource;
      if (r.SerializeToString(&serialized_resource)) {
        xds_config_store_->addOrUpdate(constructKey(source_id, r.name()),
                                       std::move(serialized_resource), ttl);
      } else {
        stats_.serialization_failed_.inc();
        ENVOY_LOG_MISC(
            warn,
            "KeyValueStore xDS delegate didn't persist xDS update {}: resource serialiation failed",
            decoded_resource.name());
      }
    } else {
      ENVOY_LOG_MISC(warn,
                     "KeyValueStore xDS delegate didn't persist xDS update {}: missing resource",
                     decoded_resource.name());
    }
  }
}

void KeyValueStoreXdsDelegate::onResourceLoadFailed(
    const XdsSourceId& source_id, const std::string& resource_name,
    const absl::optional<EnvoyException>& exception) {
  // The resource failed to load, so remove it from the store.
  xds_config_store_->remove(constructKey(source_id, resource_name));
  stats_.xds_load_failed_.inc();
  ENVOY_LOG_MISC(warn, "Failed to load locally-persisted xDS resource(s) for {}, {}: {}",
                 source_id.toKey(), resource_name,
                 (exception.has_value() ? exception->what() : "no exception"));
}

Envoy::ProtobufTypes::MessagePtr KeyValueStoreXdsDelegateFactory::createEmptyConfigProto() {
  return std::make_unique<KeyValueStoreXdsDelegateConfig>();
}

std::string KeyValueStoreXdsDelegateFactory::name() const {
  return "envoy.xds_delegates.kv_store";
};

Envoy::Config::XdsResourcesDelegatePtr KeyValueStoreXdsDelegateFactory::createXdsResourcesDelegate(
    const ProtobufWkt::Any& config, ProtobufMessage::ValidationVisitor& validation_visitor,
    Api::Api& api, Event::Dispatcher& dispatcher) {
  const auto& validator_config =
      Envoy::MessageUtil::anyConvertAndValidate<KeyValueStoreXdsDelegateConfig>(config,
                                                                                validation_visitor);
  auto& kv_store_factory = Envoy::Config::Utility::getAndCheckFactory<Envoy::KeyValueStoreFactory>(
      validator_config.key_value_store_config().config());
  KeyValueStorePtr xds_config_store = kv_store_factory.createStore(
      validator_config.key_value_store_config(), validation_visitor, dispatcher, api.fileSystem());
  return std::make_unique<KeyValueStoreXdsDelegate>(std::move(xds_config_store), api.rootScope());
}

REGISTER_FACTORY(KeyValueStoreXdsDelegateFactory, Envoy::Config::XdsResourcesDelegateFactory);

} // namespace Config
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/common/key_value_store.h"
#include "envoy/config/xds_resources_delegate.h"
#include "envoy/stats/scope.h"
#include "envoy/stats/stats_macros.h"

#include "absl/container/flat_hash_set.h"

namespace Envoy {
namespace Extensions {
namespace Config {

// All KV store xDS delegate stats. @see stats_macros.h.
#define ALL_XDS_KV_STORE_STATS(COUNTER)                                                            \
  /* Number of times a resource failed to serialize for persistence in the KV store. */            \
  COUNTER(serialization_failed)                                                                    \
  /* Number of times a resource failed to load due to parsing/validation issues. */                \
  COUNTER(xds_load_failed)                                                                         \
  /* Number of times resources were loaded successfully from the KV store. */                      \
  COUNTER(load_success)                                                                            \
  /* Number of times no resources were found for a load attempt from the KV store. */              \
  COUNTER(resources_not_found)                                                                     \
  /* Number of times a persisted resource failed to parse into a xDS proto. */                     \
  COUNTER(parse_failed)                                                                            \
  /* Number of times a resource was requested but not found from the KV store. */                  \
  COUNTER(resource_missing)

// Struct definition for all KV store xDS delegate stats. @see stats_macros.h
struct XdsKeyValueStoreStats {
  ALL_XDS_KV_STORE_STATS(GENERATE_COUNTER_STRUCT);
};

// An implementation of the XdsResourcesDelegate interface that saves and retrieves xDS resources
// to/from the configured KeyValueStore implementation.
//
// The configured KeyValueStore should not do any storage or network I/O on the main thread in their
// addOrUpdate() and get() implementations. Doing so would cause the main thread to block, since
// the delegate is invoked on the main Envoy thread.
//
// The handling of wildcard resources is designed for use with O(100) resources or fewer, so it's
// not currently advised to use this feature for large and complicated configurations.
class KeyValueStoreXdsDelegate : public Envoy::Config::XdsResourcesDelegate {
public:
  KeyValueStoreXdsDelegate(KeyValueStorePtr&& xds_config_store, Stats::Scope& root_scope);

  std::vector<envoy::service::discovery::v3::Resource>
  getResources(const Envoy::Config::XdsSourceId& source_id,
               const absl::flat_hash_set<std::string>& resource_names) const override;

  void onConfigUpdated(const Envoy::Config::XdsSourceId& source_id,
                       const std::vector<Envoy::Config::DecodedResourceRef>& resources) override;

  void onResourceLoadFailed(const Envoy::Config::XdsSourceId& source_id,
                            const std::string& resource_name,
                            const absl::optional<EnvoyException>& exception) override;

private:
  // Gets all the resources present in the KeyValueStore for the given source_id. This is the
  // equivalent of wildcard xDS requests.
  std::vector<envoy::service::discovery::v3::Resource>
  getAllResources(const Envoy::Config::XdsSourceId& source_id) const;

  static XdsKeyValueStoreStats generateStats(Stats::Scope& scope);

  KeyValueStorePtr xds_config_store_;
  Stats::ScopeSharedPtr scope_;
  XdsKeyValueStoreStats stats_;
};

// A factory for creating instances of KeyValueStoreXdsDelegate from the typed_config field of a
// TypedExtensionConfig protocol buffer message.
class KeyValueStoreXdsDelegateFactory : public Envoy::Config::XdsResourcesDelegateFactory {
public:
  KeyValueStoreXdsDelegateFactory() = default;

  Envoy::ProtobufTypes::MessagePtr createEmptyConfigProto() override;

  std::string name() const override;

  Envoy::Config::XdsResourcesDelegatePtr
  createXdsResourcesDelegate(const ProtobufWkt::Any& config,
                             ProtobufMessage::ValidationVisitor& validation_visitor, Api::Api& api,
                             Event::Dispatcher& dispatcher) override;
};

} // namespace Config
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_contrib_extension(
    name = "kv_store_xds_delegate",
    srcs = ["kv_store_xds_delegate.cc"],
    hdrs = ["kv_store_xds_delegate.h"],
    external_deps = ["abseil_optional"],
    deps = [
        "//envoy/common:key_value_store_interface",
        "//envoy/common:time_interface",
        "//envoy/config:xds_resources_delegate_interface",
        "//envoy/stats:stats_interface",
        "//envoy/stats:stats_macros",
        "//source/common/config:utility_lib",
        "//source/common/protobuf:utility_lib",
        "@envoy_api//contrib/envoy/extensions/config/v3alpha:pkg_cc_proto",
        "@envoy_api//envoy/service/discovery/v3:pkg_cc_proto",
    ],
)
#include <string>

#include "envoy/registry/registry.h"

#include "test/mocks/server/factory_context.h"
#include "test/test_common/environment.h"
#include "test/test_common/utility.h"

#include "absl/strings/str_format.h"
#include "contrib/golang/filters/network/source/config.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using testing::_;
using testing::ReturnRef;

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace Golang {
namespace {

class MockThreadFactory : public Thread::ThreadFactory {
public:
  MOCK_METHOD(Thread::ThreadPtr, createThread, (std::function<void()>, Thread::OptionsOptConstRef));
  MOCK_METHOD(Thread::ThreadId, currentThreadId, ());
};

class GolangFilterConfigTestBase {
public:
  void testConfig(envoy::extensions::filters::network::golang::v3alpha::Config& config) {
    EXPECT_CALL(slot_allocator_, allocateSlot())
        .WillRepeatedly(Invoke(&slot_allocator_, &ThreadLocal::MockInstance::allocateSlotMock));
    ON_CALL(context_.server_factory_context_, threadLocal())
        .WillByDefault(ReturnRef(slot_allocator_));
    ON_CALL(context_.server_factory_context_.api_, threadFactory())
        .WillByDefault(ReturnRef(thread_factory_));

    Network::FilterFactoryCb cb;
    EXPECT_NO_THROW({ cb = factory_.createFilterFactoryFromProto(config, context_); });
    Network::MockConnection connection;
    EXPECT_CALL(connection, addFilter(_));
    cb(connection);
  }

  NiceMock<Server::Configuration::MockFactoryContext> context_;
  NiceMock<MockThreadFactory> thread_factory_;
  ThreadLocal::MockInstance slot_allocator_;
  GolangConfigFactory factory_;
};

class GolangFilterConfigTest : public GolangFilterConfigTestBase, public testing::Test {
public:
  ~GolangFilterConfigTest() override = default;
};

TEST(GolangConfigFactoryTest, InvalidateEmptyConfig) {
  NiceMock<Server::Configuration::MockFactoryContext> context;
  EXPECT_THROW_WITH_REGEX(
      GolangConfigFactory().createFilterFactoryFromProto(
          envoy::extensions::filters::network::golang::v3alpha::Config(), context),
      Envoy::ProtoValidationException,
      "ConfigValidationError.LibraryId: value length must be at least 1 characters");
}

TEST_F(GolangFilterConfigTest, GolangFilterWithValidConfig) {
  const auto yaml_fmt = R"EOF(
  library_id: %s
  library_path: %s
  is_terminal_filter: true
  plugin_name: xxx
  plugin_config:
    "@type": type.googleapis.com/udpa.type.v1.TypedStruct
    type_url: typexx
    value:
        key: value
        int: 10
  )EOF";

  auto yaml_string = absl::StrFormat(
      yaml_fmt, "test",
      TestEnvironment::substitute(
          "{{ test_rundir }}/contrib/golang/filters/network/test/test_data/filter.so"));
  envoy::extensions::filters::network::golang::v3alpha::Config proto_config;
  TestUtility::loadFromYaml(yaml_string, proto_config);
  auto plugin_config = proto_config.plugin_config();
  std::string str;
  EXPECT_TRUE(plugin_config.SerializeToString(&str));

  testConfig(proto_config);
}

TEST_F(GolangFilterConfigTest, GolangFilterWithNilPluginConfig) {
  const auto yaml_fmt = R"EOF(
  library_id: %s
  library_path: %s
  plugin_name: xxx
  )EOF";

  auto yaml_string = absl::StrFormat(
      yaml_fmt, "test",
      TestEnvironment::substitute(
          "{{ test_rundir }}/contrib/golang/filters/network/test/test_data/filter.so"));
  envoy::extensions::filters::network::golang::v3alpha::Config proto_config;
  TestUtility::loadFromYaml(yaml_string, proto_config);
  auto plugin_config = proto_config.plugin_config();
  std::string str;
  EXPECT_TRUE(plugin_config.SerializeToString(&str));

  testConfig(proto_config);
}

} // namespace
} // namespace Golang
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
module github.com/envoyproxy/envoy/contrib/golang/filters/network/test/test_data

go 1.18

require github.com/envoyproxy/envoy v1.24.0

require google.golang.org/protobuf v1.30.0 // indirect

replace github.com/envoyproxy/envoy => ../../../../../../
package main

import (
	"github.com/envoyproxy/envoy/contrib/golang/common/go/api"
	"github.com/envoyproxy/envoy/contrib/golang/filters/network/source/go/pkg/network"
)

func init() {
	network.RegisterNetworkFilterConfigFactory("", simpleConfigFactory)
}

var simpleConfigFactory = &SimpleConfigFactory{}

type SimpleConfigFactory struct{}

func (f *SimpleConfigFactory) CreateFactoryFromConfig(config interface{}) network.FilterFactory {
	return &SimpleFilterFactory{}
}

type SimpleFilterFactory struct{}

func (f *SimpleFilterFactory) CreateFilter(cb api.ConnectionCallback) api.DownstreamFilter {
	return &SimpleFilter{}
}

type SimpleFilter struct {
	api.EmptyDownstreamFilter
}

func main() {
}
load("@io_bazel_rules_go//go:def.bzl", "go_binary")

licenses(["notice"])  # Apache 2

go_binary(
    name = "filter.so",
    srcs = [
        "filter.go",
    ],
    out = "filter.so",
    cgo = True,
    importpath = "github.com/envoyproxy/envoy/contrib/golang/filters/network/test/test_data",
    linkmode = "c-shared",
    visibility = ["//visibility:public"],
    deps = [
        "//contrib/golang/common/go/api",
        "//contrib/golang/filters/network/source/go/pkg/network",
        "@com_github_cncf_xds_go//udpa/type/v1:type",
        "@org_golang_google_protobuf//types/known/anypb",
    ],
)
#include <string>

#include "envoy/registry/registry.h"

#include "source/common/network/filter_state_dst_address.h"

#include "test/mocks/server/factory_context.h"
#include "test/test_common/environment.h"
#include "test/test_common/utility.h"

#include "absl/strings/str_format.h"
#include "contrib/golang/common/dso/test/mocks.h"
#include "contrib/golang/filters/network/source/upstream.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using testing::_;
using testing::ReturnRef;

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace Golang {
namespace {

class MockThreadFactory : public Thread::ThreadFactory {
public:
  MOCK_METHOD(Thread::ThreadPtr, createThread, (std::function<void()>, Thread::OptionsOptConstRef));
  MOCK_METHOD(Thread::ThreadId, currentThreadId, ());
};

class UpstreamConnTest : public testing::Test {
public:
  UpstreamConnTest() { ENVOY_LOG_MISC(info, "test"); }
  ~UpstreamConnTest() override = default;

  void initialize() {
    EXPECT_CALL(slot_allocator_, allocateSlot())
        .WillRepeatedly(Invoke(&slot_allocator_, &ThreadLocal::MockInstance::allocateSlotMock));
    context_.server_factory_context_.cluster_manager_.initializeClusters({"plainText"}, {});
    context_.server_factory_context_.cluster_manager_.initializeThreadLocalClusters({"plainText"});
    ON_CALL(context_.server_factory_context_.api_, threadFactory())
        .WillByDefault(ReturnRef(thread_factory_));
    UpstreamConn::initThreadLocalStorage(context_, slot_allocator_);
    dso_ = std::make_shared<Dso::MockNetworkFilterDsoImpl>();
    upConn_ = std::make_shared<UpstreamConn>(addr_, dso_, 0, &dispatcher_);
  }

  ThreadLocal::MockInstance slot_allocator_;
  NiceMock<MockThreadFactory> thread_factory_;
  NiceMock<Server::Configuration::MockFactoryContext> context_;
  std::shared_ptr<Dso::MockNetworkFilterDsoImpl> dso_;
  NiceMock<Event::MockDispatcher> dispatcher_;
  const std::string addr_{"127.0.0.1:8080"};
  UpstreamConnPtr upConn_;

  NiceMock<Network::MockClientConnection> upstream_connection_;
};

TEST_F(UpstreamConnTest, ConnectUpstream) {
  initialize();

  const auto* dst_addr =
      upConn_->requestStreamInfo()->filterState().getDataReadOnly<Network::AddressObject>(
          "envoy.network.transport_socket.original_dst_address");
  EXPECT_EQ(dst_addr->address()->asString(), addr_);

  EXPECT_CALL(
      context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_,
      newConnection(_))
      .WillOnce(
          Invoke([&](Tcp::ConnectionPool::Callbacks& cb) -> Tcp::ConnectionPool::Cancellable* {
            context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_
                .newConnectionImpl(cb);
            context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_
                .poolReady(upstream_connection_);
            return nullptr;
          }));
  EXPECT_CALL(*dso_.get(), envoyGoFilterOnUpstreamConnectionReady(_, _));
  upConn_->connect();

  EXPECT_CALL(
      context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_,
      newConnection(_))
      .WillOnce(
          Invoke([&](Tcp::ConnectionPool::Callbacks& cb) -> Tcp::ConnectionPool::Cancellable* {
            context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_
                .newConnectionImpl(cb);
            context_.server_factory_context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_
                .poolFailure(ConnectionPool::PoolFailureReason::RemoteConnectionFailure, true);
            return nullptr;
          }));
  EXPECT_CALL(*dso_.get(),
              envoyGoFilterOnUpstreamConnectionFailure(
                  _, GoInt(ConnectionPool::PoolFailureReason::RemoteConnectionFailure), _));
  upConn_->connect();
}

TEST_F(UpstreamConnTest, InvokeDsoOnEventOrData) {
  initialize();
  EXPECT_CALL(*dso_.get(),
              envoyGoFilterOnUpstreamEvent(_, GoInt(Network::ConnectionEvent::Connected)));
  upConn_->onEvent(Network::ConnectionEvent::Connected);

  Buffer::OwnedImpl someData("123");
  EXPECT_CALL(*dso_.get(), envoyGoFilterOnUpstreamData(_, someData.length(), _, _, _));
  upConn_->onUpstreamData(someData, false);
}

TEST_F(UpstreamConnTest, WriteAndClose) {
  initialize();

  EXPECT_CALL(*dso_.get(), envoyGoFilterOnUpstreamConnectionReady(_, _));
  auto data = std::make_unique<NiceMock<Envoy::Tcp::ConnectionPool::MockConnectionData>>();
  EXPECT_CALL(*data, connection()).WillRepeatedly(ReturnRef(upstream_connection_));
  upConn_->onPoolReady(std::move(data), nullptr);

  Buffer::OwnedImpl someData("123");
  EXPECT_CALL(upstream_connection_, write(_, false));
  upConn_->write(someData, false);

  EXPECT_CALL(upstream_connection_, close(_, "go_upstream_close"));
  EXPECT_CALL(*dso_.get(), envoyGoFilterOnUpstreamEvent(_, _));
  upConn_->close(Network::ConnectionCloseType::NoFlush);
  upConn_->onEvent(Network::ConnectionEvent::RemoteClose);

  // once upstream conn got closed, should not write any more
  EXPECT_CALL(upstream_connection_, write(_, _)).Times(0);
  upConn_->write(someData, false);

  // once upstream conn got closed, should not close any more
  EXPECT_CALL(upstream_connection_, close(_)).Times(0);
  upConn_->close(Network::ConnectionCloseType::NoFlush);
}

} // namespace
} // namespace Golang
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_test",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

envoy_contrib_package()

envoy_cc_test(
    name = "config_test",
    srcs = ["config_test.cc"],
    data = [
        "//contrib/golang/filters/network/test/test_data:filter.so",
    ],
    deps = [
        "//contrib/golang/filters/network/source:config",
        "//test/mocks/server:factory_context_mocks",
        "//test/test_common:utility_lib",
    ],
)

envoy_cc_test(
    name = "filter_test",
    srcs = ["filter_test.cc"],
    deps = [
        "//contrib/golang/common/dso/test:dso_mocks",
        "//contrib/golang/filters/network/source:golang",
        "//test/mocks/api:api_mocks",
        "//test/mocks/network:network_mocks",
        "//test/mocks/server:factory_context_mocks",
        "//test/mocks/ssl:ssl_mocks",
        "//test/mocks/thread_local:thread_local_mocks",
        "//test/mocks/upstream:cluster_manager_mocks",
        "//test/test_common:logging_lib",
        "//test/test_common:test_runtime_lib",
        "//test/test_common:utility_lib",
    ],
)

envoy_cc_test(
    name = "upstream_test",
    srcs = ["upstream_test.cc"],
    deps = [
        "//contrib/golang/common/dso/test:dso_mocks",
        "//contrib/golang/filters/network/source:upstream",
        "//source/common/network:filter_state_dst_address_lib",
        "//test/mocks/api:api_mocks",
        "//test/mocks/network:network_mocks",
        "//test/mocks/server:factory_context_mocks",
        "//test/mocks/ssl:ssl_mocks",
        "//test/mocks/thread_local:thread_local_mocks",
        "//test/mocks/upstream:cluster_manager_mocks",
        "//test/test_common:logging_lib",
        "//test/test_common:test_runtime_lib",
        "//test/test_common:utility_lib",
    ],
)
#include <string>

#include "envoy/registry/registry.h"

#include "test/mocks/server/factory_context.h"
#include "test/test_common/environment.h"
#include "test/test_common/utility.h"

#include "absl/strings/str_format.h"
#include "contrib/golang/common/dso/test/mocks.h"
#include "contrib/golang/filters/network/source/golang.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using testing::_;
using testing::Return;

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace Golang {
namespace {

class FilterTest : public testing::Test {
public:
  FilterTest() { ENVOY_LOG_MISC(info, "test"); }
  ~FilterTest() override = default;

  void initialize() {
    proto_config_ = prepareProtoConfig();
    config_ = std::make_shared<FilterConfig>(proto_config_);
    dso_ = std::make_shared<Dso::MockNetworkFilterDsoImpl>();
    filter_ = std::make_shared<Filter>(context_, config_, 1, dso_);
    filter_->initializeReadFilterCallbacks(filter_callbacks_);
  }

  envoy::extensions::filters::network::golang::v3alpha::Config prepareProtoConfig() {
    const auto yaml_fmt = R"EOF(
  library_id: %s
  library_path: %s
  is_terminal_filter: true
  plugin_name: xxx
  plugin_config:
    "@type": type.googleapis.com/udpa.type.v1.TypedStruct
    type_url: typexx
    value:
        key: value
        int: 10
  )EOF";

    auto yaml_string = absl::StrFormat(
        yaml_fmt, "test",
        TestEnvironment::substitute(
            "{{ test_rundir }}/contrib/golang/filters/network/test/test_data/filter.so"));
    envoy::extensions::filters::network::golang::v3alpha::Config proto_config;
    TestUtility::loadFromYaml(yaml_string, proto_config);
    return proto_config;
  }

  FilterConfigSharedPtr config_;
  envoy::extensions::filters::network::golang::v3alpha::Config proto_config_;
  NiceMock<Server::Configuration::MockFactoryContext> context_;
  std::shared_ptr<Dso::MockNetworkFilterDsoImpl> dso_;
  NiceMock<Network::MockReadFilterCallbacks> filter_callbacks_;
  FilterSharedPtr filter_;
};

TEST_F(FilterTest, InvokeDsoOnEventOrData) {
  initialize();

  EXPECT_CALL(*dso_.get(), envoyGoFilterOnDownstreamConnection(_, _, _, _));
  filter_->onNewConnection();

  EXPECT_CALL(*dso_.get(),
              envoyGoFilterOnDownstreamEvent(_, GoInt(Network::ConnectionEvent::Connected)));
  filter_->onEvent(Network::ConnectionEvent::Connected);

  Buffer::OwnedImpl someData("123");
  EXPECT_CALL(*dso_.get(), envoyGoFilterOnDownstreamData(_, someData.length(), _, _, _))
      .WillOnce(Return(GoUint64(Network::FilterStatus::Continue)));
  EXPECT_EQ(Network::FilterStatus::Continue, filter_->onData(someData, false));

  EXPECT_CALL(*dso_.get(), envoyGoFilterOnDownstreamWrite(_, someData.length(), _, _, _))
      .WillOnce(Return(GoUint64(Network::FilterStatus::Continue)));
  EXPECT_EQ(Network::FilterStatus::Continue, filter_->onWrite(someData, false));
}

TEST_F(FilterTest, FilterState) {
  initialize();
  EXPECT_CALL(*dso_.get(), envoyGoFilterOnDownstreamConnection(_, _, _, _));
  filter_->onNewConnection();
  filter_->setFilterState("filterStateKey", "filterStateValue",
                          static_cast<int>(StreamInfo::FilterState::StateType::Mutable),
                          static_cast<int>(StreamInfo::FilterState::LifeSpan::Connection),
                          static_cast<int>(StreamInfo::StreamSharingMayImpactPooling::None));
  GoString str;
  filter_->getFilterState("filterStateKey", &str);
  EXPECT_EQ("filterStateValue", std::string(str.p, str.n));
}

TEST_F(FilterTest, WriteAndClose) {
  initialize();

  Buffer::OwnedImpl someData("123");
  EXPECT_CALL(filter_callbacks_.connection_, write(_, false));
  filter_->write(someData, false);

  EXPECT_CALL(filter_callbacks_.connection_, close(_, "go_downstream_close"));
  EXPECT_CALL(*dso_.get(), envoyGoFilterOnDownstreamEvent(_, _));
  filter_->close(Network::ConnectionCloseType::NoFlush);

  // once filter got closed, should not write any more
  EXPECT_CALL(filter_callbacks_.connection_, write(_, _)).Times(0);
  filter_->write(someData, false);

  // once filter got closed, should not close any more
  EXPECT_CALL(filter_callbacks_.connection_, close(_)).Times(0);
  filter_->close(Network::ConnectionCloseType::NoFlush);
}

} // namespace
} // namespace Golang
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

/*
// ref https://github.com/golang/go/issues/25832

#cgo CFLAGS: -I../../../../../../common/go/api -I../api
#cgo linux LDFLAGS: -Wl,-unresolved-symbols=ignore-all
#cgo darwin LDFLAGS: -Wl,-undefined,dynamic_lookup

#include <stdlib.h>
#include <string.h>

#include "api.h"

*/
import "C"
import (
	"strings"
	"sync/atomic"
	"unsafe"

	"github.com/envoyproxy/envoy/contrib/golang/common/go/api"
)

var cgoAPI api.NetworkCAPI = &cgoApiImpl{}

func SetCgoAPI(apiImpl api.NetworkCAPI) {
	if apiImpl != nil {
		cgoAPI = apiImpl
	}
}

type cgoApiImpl struct{}

func (c *cgoApiImpl) DownstreamWrite(f unsafe.Pointer, bufferPtr unsafe.Pointer, bufferLen int, endStream int) {
	C.envoyGoFilterDownstreamWrite(f, bufferPtr, C.int(bufferLen), C.int(endStream))
}

func (c *cgoApiImpl) DownstreamClose(f unsafe.Pointer, closeType int) {
	C.envoyGoFilterDownstreamClose(f, C.int(closeType))
}

func (c *cgoApiImpl) DownstreamFinalize(f unsafe.Pointer, reason int) {
	C.envoyGoFilterDownstreamFinalize(f, C.int(reason))
}

func (c *cgoApiImpl) DownstreamInfo(f unsafe.Pointer, infoType int) string {
	var info string
	C.envoyGoFilterDownstreamInfo(f, C.int(infoType), unsafe.Pointer(&info))
	return strings.Clone(info)
}

func (c *cgoApiImpl) GetFilterState(f unsafe.Pointer, key string) string {
	cb := (*connectionCallback)(f)
	var value string
	cb.mutex.Lock()
	defer cb.mutex.Unlock()
	cb.sema.Add(1)
	res := C.envoyGoFilterGetFilterState(cb.wrapper, unsafe.Pointer(&key), unsafe.Pointer(&value))
	if res == C.CAPIYield {
		atomic.AddInt32(&cb.waitingOnEnvoy, 1)
		cb.sema.Wait()
	} else {
		cb.sema.Done()
		// TODO: handle res
	}

	return strings.Clone(value)
}

func (c *cgoApiImpl) SetFilterState(f unsafe.Pointer, key string, value string, stateType api.StateType, lifeSpan api.LifeSpan, streamSharing api.StreamSharing) {
	cb := (*connectionCallback)(f)
	_ = C.envoyGoFilterSetFilterState(cb.wrapper, unsafe.Pointer(&key), unsafe.Pointer(&value), C.int(stateType), C.int(lifeSpan), C.int(streamSharing))
	// TODO: handle res
}

func (c *cgoApiImpl) UpstreamConnect(libraryID string, addr string, connID uint64) unsafe.Pointer {
	return unsafe.Pointer(C.envoyGoFilterUpstreamConnect(unsafe.Pointer(&libraryID), unsafe.Pointer(&addr), C.uint64_t(connID)))
}

func (c *cgoApiImpl) UpstreamWrite(f unsafe.Pointer, bufferPtr unsafe.Pointer, bufferLen int, endStream int) {
	C.envoyGoFilterUpstreamWrite(f, bufferPtr, C.int(bufferLen), C.int(endStream))
}

func (c *cgoApiImpl) UpstreamClose(f unsafe.Pointer, closeType int) {
	C.envoyGoFilterUpstreamClose(f, C.int(closeType))
}

func (c *cgoApiImpl) UpstreamFinalize(f unsafe.Pointer, reason int) {
	C.envoyGoFilterUpstreamFinalize(f, C.int(reason))
}

func (c *cgoApiImpl) UpstreamInfo(f unsafe.Pointer, infoType int) string {
	var info string
	C.envoyGoFilterUpstreamInfo(f, C.int(infoType), unsafe.Pointer(&info))
	return strings.Clone(info)
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

import (
	"sync"

	"google.golang.org/protobuf/types/known/anypb"

	"github.com/envoyproxy/envoy/contrib/golang/common/go/api"
)

type ConfigFactory interface {
	CreateFactoryFromConfig(config interface{}) FilterFactory
}

type FilterFactory interface {
	CreateFilter(cb api.ConnectionCallback) api.DownstreamFilter
}

type ConfigParser interface {
	// TODO: should return error when the config is invalid.
	ParseConfig(any *anypb.Any) interface{}
}

var (
	networkFilterConfigFactoryMap = &sync.Map{} // pluginName -> ConfigFactory
)

func RegisterNetworkFilterConfigFactory(name string, factory ConfigFactory) {
	if factory != nil {
		networkFilterConfigFactoryMap.Store(name, factory)
	}
}

func GetNetworkFilterConfigFactory(name string) ConfigFactory {
	if v, ok := networkFilterConfigFactoryMap.Load(name); ok {
		return v.(ConfigFactory)
	}
	return nil
}

var networkFilterConfigParser ConfigParser = &noopConfigParser{}

func RegisterNetworkFilterConfigParser(parser ConfigParser) {
	if parser != nil {
		networkFilterConfigParser = parser
	}
}

func GetNetworkFilterConfigParser() ConfigParser {
	return networkFilterConfigParser
}

type noopConfigParser struct{}

var _ ConfigParser = (*noopConfigParser)(nil)

func (n *noopConfigParser) ParseConfig(any *anypb.Any) interface{} {
	return any
}
//go:build go1.22

package network

/*
// This is a performance optimization.
// The following noescape and nocallback directives are used to
// prevent the Go compiler from allocating function parameters on the heap.

#cgo noescape envoyGoFilterDownstreamWrite
#cgo nocallback envoyGoFilterDownstreamWrite
#cgo noescape envoyGoFilterDownstreamInfo
#cgo nocallback envoyGoFilterDownstreamInfo
#cgo noescape envoyGoFilterUpstreamConnect
#cgo nocallback envoyGoFilterUpstreamConnect
#cgo noescape envoyGoFilterUpstreamWrite
#cgo nocallback envoyGoFilterUpstreamWrite
#cgo noescape envoyGoFilterUpstreamInfo
#cgo nocallback envoyGoFilterUpstreamInfo
#cgo noescape envoyGoFilterSetFilterState
#cgo nocallback envoyGoFilterSetFilterState
#cgo noescape envoyGoFilterGetFilterState
#cgo nocallback envoyGoFilterGetFilterState

*/
import "C"
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

import (
	"sync"
	"unsafe"

	"github.com/envoyproxy/envoy/contrib/golang/common/go/api"
)

type connectionCallback struct {
	wrapper        unsafe.Pointer
	writeFunc      func(envoyFilter unsafe.Pointer, buffers unsafe.Pointer, buffersNum int, endStream int)
	closeFunc      func(envoyFilter unsafe.Pointer, closeType int)
	infoFunc       func(envoyFilter unsafe.Pointer, infoType int) string
	streamInfo     api.StreamInfo
	state          *filterState
	sema           sync.WaitGroup
	waitingOnEnvoy int32
	mutex          sync.Mutex
}

var _ api.ConnectionCallback = (*connectionCallback)(nil)
var _ api.StreamInfo = (*connectionCallback)(nil)

func (n *connectionCallback) Write(buffer []byte, endStream bool) {
	var endStreamInt int
	if endStream {
		endStreamInt = 1
	}
	n.writeFunc(n.wrapper, unsafe.Pointer(&buffer[0]), len(buffer), endStreamInt)
}

func (n *connectionCallback) Close(closeType api.ConnectionCloseType) {
	n.closeFunc(n.wrapper, int(closeType))
}

func (n *connectionCallback) StreamInfo() api.StreamInfo {
	return n
}

func (n *connectionCallback) GetRouteName() string {
	panic("implement me")
}

func (n *connectionCallback) FilterChainName() string {
	panic("implement me")
}

func (n *connectionCallback) Protocol() (string, bool) {
	panic("implement me")
}

func (n *connectionCallback) ResponseCode() (uint32, bool) {
	panic("implement me")
}

func (n *connectionCallback) ResponseCodeDetails() (string, bool) {
	panic("implement me")
}

func (n *connectionCallback) AttemptCount() uint32 {
	panic("implement me")
}

func (n *connectionCallback) DynamicMetadata() api.DynamicMetadata {
	panic("implement me")
}

func (n *connectionCallback) DownstreamLocalAddress() string {
	panic("implement me")
}

func (n *connectionCallback) DownstreamRemoteAddress() string {
	panic("implement me")
}

// UpstreamLocalAddress return the upstream local address.
func (n *connectionCallback) UpstreamLocalAddress() (string, bool) {
	return n.infoFunc(n.wrapper, int(api.ConnectionInfoLocalAddr)), true
}

// UpstreamRemoteAddress return the upstream remote address.
func (n *connectionCallback) UpstreamRemoteAddress() (string, bool) {
	return n.infoFunc(n.wrapper, int(api.ConnectionInfoRemoteAddr)), true
}

func (n *connectionCallback) UpstreamClusterName() (string, bool) {
	panic("implement me")
}

func (n *connectionCallback) FilterState() api.FilterState {
	return n.state
}

func (n *connectionCallback) VirtualClusterName() (string, bool) {
	panic("implement me")
}

type filterState struct {
	wrapper unsafe.Pointer
	setFunc func(envoyFilter unsafe.Pointer, key string, value string, stateType api.StateType, lifeSpan api.LifeSpan, streamSharing api.StreamSharing)
	getFunc func(envoyFilter unsafe.Pointer, key string) string
}

var _ api.FilterState = (*filterState)(nil)

func (f *filterState) SetString(key, value string, stateType api.StateType, lifeSpan api.LifeSpan, streamSharing api.StreamSharing) {
	if f.setFunc != nil {
		f.setFunc(unsafe.Pointer(f), key, value, stateType, lifeSpan, streamSharing)
	}
}

func (f *filterState) GetString(key string) string {
	if f.getFunc != nil {
		return f.getFunc(unsafe.Pointer(f), key)
	}
	return ""
}
load("@io_bazel_rules_go//go:def.bzl", "go_library")

licenses(["notice"])  # Apache 2

go_library(
    name = "network",
    srcs = [
        "api.h",
        "capi.go",
        "factory.go",
        "filter.go",
        "shim.go",
    ],
    cgo = True,
    clinkopts = select({
        "@io_bazel_rules_go//go/platform:android": [
            "-Wl,-unresolved-symbols=ignore-all",
        ],
        "@io_bazel_rules_go//go/platform:darwin": [
            "-Wl,-undefined,dynamic_lookup",
        ],
        "@io_bazel_rules_go//go/platform:ios": [
            "-Wl,-undefined,dynamic_lookup",
        ],
        "@io_bazel_rules_go//go/platform:linux": [
            "-Wl,-unresolved-symbols=ignore-all",
        ],
        "//conditions:default": [],
    }),
    importpath = "github.com/envoyproxy/envoy/contrib/golang/filters/network/source/go/pkg/network",
    visibility = ["//visibility:public"],
    deps = [
        "//contrib/golang/common/go/api",
        "//contrib/golang/common/go/utils",
        "@org_golang_google_protobuf//proto",
        "@org_golang_google_protobuf//types/known/anypb",
    ],
)
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

/*
// ref https://github.com/golang/go/issues/25832

#cgo CFLAGS: -I../../../../../../common/go/api -I../api
#cgo linux LDFLAGS: -Wl,-unresolved-symbols=ignore-all
#cgo darwin LDFLAGS: -Wl,-undefined,dynamic_lookup

#include <stdlib.h>
#include <string.h>

#include "api.h"
*/
import "C"
import (
	"errors"
	"runtime"
	"strings"
	"sync"
	"sync/atomic"
	"unsafe"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/anypb"

	"github.com/envoyproxy/envoy/contrib/golang/common/go/api"
	"github.com/envoyproxy/envoy/contrib/golang/common/go/utils"
)

var (
	// ref: https://golang.org/cmd/cgo/
	// The size of any C type T is available as C.sizeof_T, as in C.sizeof_struct_stat.
	CULLSize uintptr = C.sizeof_ulonglong

	ErrDupRequestKey = errors.New("dup request key")

	DownstreamFilters = &DownstreamFilterMap{}
	UpstreamFilters   = &UpstreamFilterMap{}

	configIDGenerator uint64
	configCache       = &sync.Map{} // uint64 -> *anypb.Any

	upstreamConnIDGenerator uint64

	libraryID string
)

// wrap the UpstreamFilter to ensure that the runtime.finalizer can be triggered
// regardless of whether there is a circular reference in the UpstreamFilter.
type upstreamConnWrapper struct {
	api.UpstreamFilter
	finalizer *int
}

func CreateUpstreamConn(addr string, filter api.UpstreamFilter) {
	conn := &upstreamConnWrapper{
		UpstreamFilter: filter,
		finalizer:      new(int),
	}
	connID := atomic.AddUint64(&upstreamConnIDGenerator, 1)
	_ = UpstreamFilters.StoreFilterByConnID(connID, conn)

	h := cgoAPI.UpstreamConnect(libraryID, addr, connID)

	// NP: make sure filter will be deleted.
	runtime.SetFinalizer(conn.finalizer, func(_ *int) {
		cgoAPI.UpstreamFinalize(unsafe.Pointer(uintptr(h)), api.NormalFinalize)
	})
}

//export envoyGoFilterOnNetworkFilterConfig
func envoyGoFilterOnNetworkFilterConfig(libraryIDPtr uint64, libraryIDLen uint64, configPtr uint64, configLen uint64) uint64 {
	buf := utils.BytesToSlice(configPtr, configLen)
	var any anypb.Any
	proto.Unmarshal(buf, &any)

	libraryID = strings.Clone(utils.BytesToString(libraryIDPtr, libraryIDLen))
	configID := atomic.AddUint64(&configIDGenerator, 1)
	configCache.Store(configID, GetNetworkFilterConfigParser().ParseConfig(&any))

	return configID
}

//export envoyGoFilterOnDownstreamConnection
func envoyGoFilterOnDownstreamConnection(wrapper unsafe.Pointer, pluginNamePtr uint64, pluginNameLen uint64,
	configID uint64) uint64 {
	filterFactoryConfig, ok := configCache.Load(configID)
	if !ok {
		// TODO: panic
		return uint64(api.NetworkFilterStopIteration)
	}
	pluginName := strings.Clone(utils.BytesToString(pluginNamePtr, pluginNameLen))
	filterFactory := GetNetworkFilterConfigFactory(pluginName).CreateFactoryFromConfig(filterFactoryConfig)

	cb := &connectionCallback{
		wrapper:   wrapper,
		writeFunc: cgoAPI.DownstreamWrite,
		closeFunc: cgoAPI.DownstreamClose,
		infoFunc:  cgoAPI.DownstreamInfo,
		state: &filterState{
			wrapper: wrapper,
			setFunc: cgoAPI.SetFilterState,
			getFunc: cgoAPI.GetFilterState,
		},
	}
	filter := filterFactory.CreateFilter(cb)

	// NP: make sure filter will be deleted.
	runtime.SetFinalizer(filter, func(ff api.DownstreamFilter) {
		cgoAPI.DownstreamFinalize(unsafe.Pointer(uintptr(wrapper)), api.NormalFinalize)
	})

	// TODO: handle error
	_ = DownstreamFilters.StoreFilter(uint64(uintptr(wrapper)), &downstreamFilterWrapper{
		filter: filter,
		cb:     cb,
	})

	return uint64(filter.OnNewConnection())
}

//export envoyGoFilterOnDownstreamData
func envoyGoFilterOnDownstreamData(wrapper unsafe.Pointer, dataSize uint64, dataPtr uint64, sliceNum int, endOfStream int) uint64 {
	filter := DownstreamFilters.GetFilter(uint64(uintptr(wrapper)))

	var buf []byte

	for i := 0; i < sliceNum; i++ {
		slicePtr := dataPtr + uint64(i)*uint64(CULLSize+CULLSize)
		sliceData := *((*uint64)(unsafe.Pointer(uintptr(slicePtr))))
		sliceLen := *((*uint64)(unsafe.Pointer(uintptr(slicePtr) + CULLSize)))

		data := utils.BytesToSlice(sliceData, sliceLen)
		buf = append(buf, data...)
	}

	return uint64(filter.OnData(buf, endOfStream == 1))
}

//export envoyGoFilterOnDownstreamEvent
func envoyGoFilterOnDownstreamEvent(wrapper unsafe.Pointer, event int) {
	filter := DownstreamFilters.GetFilter(uint64(uintptr(wrapper)))
	e := api.ConnectionEvent(event)
	filter.OnEvent(e)
	if e == api.LocalClose || e == api.RemoteClose {
		DownstreamFilters.DeleteFilter(uint64(uintptr(wrapper)))
	}
}

//export envoyGoFilterOnDownstreamWrite
func envoyGoFilterOnDownstreamWrite(wrapper unsafe.Pointer, dataSize uint64, dataPtr uint64, sliceNum int, endOfStream int) uint64 {
	filter := DownstreamFilters.GetFilter(uint64(uintptr(wrapper)))

	var buf []byte

	for i := 0; i < sliceNum; i++ {
		slicePtr := dataPtr + uint64(i)*uint64(CULLSize+CULLSize)
		sliceData := *((*uint64)(unsafe.Pointer(uintptr(slicePtr))))
		sliceLen := *((*uint64)(unsafe.Pointer(uintptr(slicePtr) + CULLSize)))

		data := utils.BytesToSlice(sliceData, sliceLen)
		buf = append(buf, data...)
	}

	return uint64(filter.OnWrite(buf, endOfStream == 1))
}

//export envoyGoFilterOnSemaDec
func envoyGoFilterOnSemaDec(wrapper unsafe.Pointer) {
	w := DownstreamFilters.GetFilterWrapper(uint64(uintptr(wrapper)))
	if atomic.CompareAndSwapInt32(&w.cb.waitingOnEnvoy, 1, 0) {
		w.cb.sema.Done()
	}
}

//export envoyGoFilterOnUpstreamConnectionReady
func envoyGoFilterOnUpstreamConnectionReady(wrapper unsafe.Pointer, connID uint64) {
	cb := &connectionCallback{
		wrapper:   wrapper,
		writeFunc: cgoAPI.UpstreamWrite,
		closeFunc: cgoAPI.UpstreamClose,
		infoFunc:  cgoAPI.UpstreamInfo,
	}
	// switch filter from idMap to wrapperMap
	filter := UpstreamFilters.GetFilterByConnID(connID)
	UpstreamFilters.DeleteFilterByConnID(connID)
	UpstreamFilters.StoreFilterByWrapper(uint64(uintptr(wrapper)), filter)
	filter.OnPoolReady(cb)
}

//export envoyGoFilterOnUpstreamConnectionFailure
func envoyGoFilterOnUpstreamConnectionFailure(wrapper unsafe.Pointer, reason int, connID uint64) {
	filter := UpstreamFilters.GetFilterByConnID(connID)
	UpstreamFilters.DeleteFilterByConnID(connID)
	filter.OnPoolFailure(api.PoolFailureReason(reason), "")
}

//export envoyGoFilterOnUpstreamData
func envoyGoFilterOnUpstreamData(wrapper unsafe.Pointer, dataSize uint64, dataPtr uint64, sliceNum int, endOfStream int) {
	filter := UpstreamFilters.GetFilterByWrapper(uint64(uintptr(wrapper)))

	var buf []byte

	for i := 0; i < sliceNum; i++ {
		slicePtr := dataPtr + uint64(i)*uint64(CULLSize+CULLSize)
		sliceData := *((*uint64)(unsafe.Pointer(uintptr(slicePtr))))
		sliceLen := *((*uint64)(unsafe.Pointer(uintptr(slicePtr) + CULLSize)))

		data := utils.BytesToSlice(sliceData, sliceLen)
		buf = append(buf, data...)
	}

	filter.OnData(buf, endOfStream == 1)
}

//export envoyGoFilterOnUpstreamEvent
func envoyGoFilterOnUpstreamEvent(wrapper unsafe.Pointer, event int) {
	filter := UpstreamFilters.GetFilterByWrapper(uint64(uintptr(wrapper)))
	e := api.ConnectionEvent(event)
	filter.OnEvent(e)
	if e == api.LocalClose || e == api.RemoteClose {
		UpstreamFilters.DeleteFilterByWrapper(uint64(uintptr(wrapper)))
	}
}

type downstreamFilterWrapper struct {
	filter api.DownstreamFilter
	cb     *connectionCallback
}

type DownstreamFilterMap struct {
	m sync.Map // uint64 -> *downstreamFilterWrapper
}

func (f *DownstreamFilterMap) StoreFilter(key uint64, filter *downstreamFilterWrapper) error {
	if _, loaded := f.m.LoadOrStore(key, filter); loaded {
		return ErrDupRequestKey
	}
	return nil
}

func (f *DownstreamFilterMap) GetFilter(key uint64) api.DownstreamFilter {
	w := f.GetFilterWrapper(key)
	if w != nil {
		return w.filter
	}
	return nil
}

func (f *DownstreamFilterMap) GetFilterWrapper(key uint64) *downstreamFilterWrapper {
	if v, ok := f.m.Load(key); ok {
		return v.(*downstreamFilterWrapper)
	}
	return nil
}

func (f *DownstreamFilterMap) DeleteFilter(key uint64) {
	f.m.Delete(key)
}

func (f *DownstreamFilterMap) Clear() {
	f.m.Range(func(key, _ interface{}) bool {
		f.m.Delete(key)
		return true
	})
}

type UpstreamFilterMap struct {
	idMap      sync.Map // upstreamConnID(uint) -> UpstreamFilter
	wrapperMap sync.Map // wrapper(uint64) -> UpstreamFilter
}

func (f *UpstreamFilterMap) StoreFilterByConnID(key uint64, filter api.UpstreamFilter) error {
	if _, loaded := f.idMap.LoadOrStore(key, filter); loaded {
		return ErrDupRequestKey
	}
	return nil
}

func (f *UpstreamFilterMap) StoreFilterByWrapper(key uint64, filter api.UpstreamFilter) error {
	if _, loaded := f.wrapperMap.LoadOrStore(key, filter); loaded {
		return ErrDupRequestKey
	}
	return nil
}

func (f *UpstreamFilterMap) GetFilterByConnID(key uint64) api.UpstreamFilter {
	if v, ok := f.idMap.Load(key); ok {
		return v.(api.UpstreamFilter)
	}
	return nil
}

func (f *UpstreamFilterMap) GetFilterByWrapper(key uint64) api.UpstreamFilter {
	if v, ok := f.wrapperMap.Load(key); ok {
		return v.(api.UpstreamFilter)
	}
	return nil
}

func (f *UpstreamFilterMap) DeleteFilterByConnID(key uint64) {
	f.idMap.Delete(key)
}

func (f *UpstreamFilterMap) DeleteFilterByWrapper(key uint64) {
	f.wrapperMap.Delete(key)
}

func (f *UpstreamFilterMap) Clear() {
	f.idMap.Range(func(key, _ interface{}) bool {
		f.idMap.Delete(key)
		return true
	})
	f.wrapperMap.Range(func(key, _ interface{}) bool {
		f.wrapperMap.Delete(key)
		return true
	})
}
#pragma once

#include <cstdlib>

#include "envoy/registry/registry.h"
#include "envoy/server/filter_config.h"
#include "envoy/server/lifecycle_notifier.h"

#include "source/extensions/filters/network/common/factory_base.h"

#include "contrib/envoy/extensions/filters/network/golang/v3alpha/golang.pb.h"
#include "contrib/envoy/extensions/filters/network/golang/v3alpha/golang.pb.validate.h"
#include "contrib/golang/common/dso/dso.h"
#include "contrib/golang/filters/network/source/golang.h"
#include "contrib/golang/filters/network/source/upstream.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace Golang {

constexpr char CanonicalName[] = "envoy.filters.network.golang";

/**
 * Config registration for the golang filter. @see NamedNetworkFilterConfigFactory.
 */
class GolangConfigFactory
    : public Common::FactoryBase<envoy::extensions::filters::network::golang::v3alpha::Config> {
public:
  GolangConfigFactory() : FactoryBase(CanonicalName) {}

  bool isTerminalFilterByProto(const Protobuf::Message&,
                               Server::Configuration::ServerFactoryContext&) override {
    return is_terminal_filter_;
  }

private:
  Network::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoy::extensions::filters::network::golang::v3alpha::Config& proto_config,
      Server::Configuration::FactoryContext& context) override;

  bool is_terminal_filter_{true};
};

} // namespace Golang
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#pragma once

#include "envoy/buffer/buffer.h"
#include "envoy/event/dispatcher.h"
#include "envoy/network/connection.h"
#include "envoy/network/filter.h"
#include "envoy/ssl/connection.h"
#include "envoy/tcp/conn_pool.h"
#include "envoy/upstream/cluster_manager.h"

#include "source/common/buffer/buffer_impl.h"
#include "source/common/common/logger.h"
#include "source/common/network/connection_impl.h"
#include "source/common/upstream/load_balancer_impl.h"
#include "source/extensions/filters/network/common/factory_base.h"

#include "contrib/envoy/extensions/filters/network/golang/v3alpha/golang.pb.h"
#include "contrib/golang/common/dso/dso.h"
#include "contrib/golang/filters/network/source/upstream.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace Golang {

/**
 * Configuration for the Golang network filter.
 */
class FilterConfig {
public:
  FilterConfig(const envoy::extensions::filters::network::golang::v3alpha::Config& proto_config);

  const std::string& libraryID() const { return library_id_; }
  const std::string& libraryPath() const { return library_path_; }
  const std::string& pluginName() const { return plugin_name_; }
  const ProtobufWkt::Any& pluginConfig() const { return plugin_config_; }

private:
  const std::string library_id_;
  const std::string library_path_;
  const std::string plugin_name_;
  const ProtobufWkt::Any plugin_config_;
};

using FilterConfigSharedPtr = std::shared_ptr<FilterConfig>;

struct FilterWrapper;

/**
 * Implementation of a basic golang filter.
 */
class Filter : public Network::Filter,
               public Network::ConnectionCallbacks,
               public std::enable_shared_from_this<Filter>,
               Logger::Loggable<Logger::Id::golang> {
public:
  explicit Filter(Server::Configuration::FactoryContext& context, FilterConfigSharedPtr config,
                  uint64_t config_id, Dso::NetworkFilterDsoPtr dynamic_lib)
      : context_(context), config_(config),
        config_id_(config_id), plugin_name_{config->pluginName()}, dynamic_lib_(dynamic_lib) {}

  // Network::ReadFilter
  Network::FilterStatus onData(Buffer::Instance& data, bool end_stream) override;
  Network::FilterStatus onNewConnection() override;
  void initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) override;

  // Network::WriteFilter
  Network::FilterStatus onWrite(Buffer::Instance& data, bool end_stream) override;

  // Network::ConnectionCallbacks
  void onEvent(Network::ConnectionEvent event) override;
  void onAboveWriteBufferHighWatermark() override {}
  void onBelowWriteBufferLowWatermark() override {}

  void write(Buffer::Instance& buf, bool end_stream);
  void close(Network::ConnectionCloseType close_type);

  Event::Dispatcher* dispatcher() { return dispatcher_; }
  Upstream::ClusterManager& clusterManager() {
    return context_.serverFactoryContext().clusterManager();
  }

  std::string getLocalAddrStr() const { return local_addr_; }
  std::string getRemoteAddrStr() const { return addr_; };

  CAPIStatus setFilterState(absl::string_view key, absl::string_view value, int state_type,
                            int life_span, int stream_sharing);
  CAPIStatus getFilterState(absl::string_view key, GoString* value_str);

private:
  Server::Configuration::FactoryContext& context_;
  const FilterConfigSharedPtr config_;
  const uint64_t config_id_;
  std::string plugin_name_{};
  Dso::NetworkFilterDsoPtr dynamic_lib_{nullptr};
  FilterWrapper* wrapper_{nullptr};
  Event::Dispatcher* dispatcher_{nullptr};

  bool closed_{false};
  Network::ReadFilterCallbacks* read_callbacks_{};
  std::string local_addr_{};
  std::string addr_{};

  Thread::MutexBasicLockable mutex_{};
};

using FilterSharedPtr = std::shared_ptr<Filter>;
using FilterWeakPtr = std::weak_ptr<Filter>;

struct FilterWrapper {
public:
  FilterWrapper(FilterWeakPtr ptr) : filter_ptr_(ptr) {}
  ~FilterWrapper() = default;

  FilterWeakPtr filter_ptr_{};
  // anchor a string temporarily, make sure it won't be freed before copied to Go.
  std::string str_value_;
};

class GoStringFilterState : public StreamInfo::FilterState::Object {
public:
  GoStringFilterState(absl::string_view value) : value_(value) {}
  const std::string& value() const { return value_; }

private:
  const std::string value_;
};

} // namespace Golang
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/golang/filters/network/source/golang.h"
#include "contrib/golang/filters/network/source/upstream.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace Golang {

//
// These functions may be invoked in another go thread,
// which means may introduce race between go thread and envoy thread.
// So we use the envoy's dispatcher in the filter to post it, and make it only executes in the envoy
// thread.
//

// Deep copy GoString into std::string, including the string content,
// it's safe to use it after the current cgo call returns.
std::string copyGoString(void* str) {
  if (str == nullptr) {
    return "";
  }
  auto go_str = reinterpret_cast<GoString*>(str);
  return std::string{go_str->p, size_t(go_str->n)};
}

// The returned absl::string_view only refer to the GoString, won't copy the string content into
// C++, should not use it after the current cgo call returns.
absl::string_view referGoString(void* str) {
  if (str == nullptr) {
    return "";
  }
  auto go_str = reinterpret_cast<GoString*>(str);
  return {go_str->p, static_cast<size_t>(go_str->n)};
}

enum class ConnectionInfoType {
  LocalAddr,
  RemoteAddr,
};

extern "C" {

//
// Downstream
//

CAPIStatus envoyGoFilterDownstreamClose(void* f, int close_type) {
  auto* wrapper = reinterpret_cast<FilterWrapper*>(f);
  FilterWeakPtr& weak_ptr = wrapper->filter_ptr_;
  if (FilterSharedPtr f = weak_ptr.lock()) {
    f->dispatcher()->post([weak_ptr, close_type] {
      if (FilterSharedPtr filter = weak_ptr.lock()) {
        filter->close(static_cast<Network::ConnectionCloseType>(close_type));
      }
    });
    return CAPIStatus::CAPIOK;
  }
  return CAPIStatus::CAPIFilterIsGone;
}

CAPIStatus envoyGoFilterDownstreamWrite(void* f, void* buffer_ptr, int buffer_len, int end_stream) {
  auto* wrapper = reinterpret_cast<FilterWrapper*>(f);
  FilterWeakPtr& weak_ptr = wrapper->filter_ptr_;
  if (FilterSharedPtr f = weak_ptr.lock()) {
    // should do the copy right now, because the 'data' pointer still point at the go's heap
    Buffer::InstancePtr buffer =
        std::make_unique<Buffer::OwnedImpl>(reinterpret_cast<char*>(buffer_ptr), buffer_len);
    // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)
    f->dispatcher()->post([weak_ptr, end_stream, buf_raw_ptr = buffer.release()] {
      Buffer::InstancePtr buf = absl::WrapUnique(buf_raw_ptr);
      if (FilterSharedPtr filter = weak_ptr.lock()) {
        filter->write(*buf.get(), end_stream);
      }
    });
    return CAPIStatus::CAPIOK;
  }
  return CAPIStatus::CAPIFilterIsGone;
}

void envoyGoFilterDownstreamFinalize(void* f, int reason) {
  UNREFERENCED_PARAMETER(reason);
  auto* wrapper = reinterpret_cast<FilterWrapper*>(f);
  FilterWeakPtr& weak_ptr = wrapper->filter_ptr_;
  if (FilterSharedPtr filter = weak_ptr.lock()) {
    // make sure that the deconstructor is also executed by envoy work thread.
    filter->dispatcher()->post([wrapper] { delete wrapper; });
  } else {
    // the Filter is already deleted, just release the wrapper.
    delete wrapper;
  }
}

CAPIStatus envoyGoFilterDownstreamInfo(void* f, int info_type, void* ret) {
  auto* wrapper = reinterpret_cast<FilterWrapper*>(f);
  FilterWeakPtr& weak_ptr = wrapper->filter_ptr_;
  if (FilterSharedPtr filter = weak_ptr.lock()) {
    auto* goStr = reinterpret_cast<GoString*>(ret);
    switch (static_cast<ConnectionInfoType>(info_type)) {
    case ConnectionInfoType::LocalAddr:
      wrapper->str_value_ = filter->getLocalAddrStr();
      break;
    case ConnectionInfoType::RemoteAddr:
      wrapper->str_value_ = filter->getRemoteAddrStr();
      break;
    default:
      PANIC_DUE_TO_CORRUPT_ENUM;
    }
    goStr->p = wrapper->str_value_.data();
    goStr->n = wrapper->str_value_.length();
    return CAPIStatus::CAPIOK;
  }
  return CAPIStatus::CAPIFilterIsGone;
}

//
// Upstream
//

void* envoyGoFilterUpstreamConnect(void* library_id, void* addr, uint64_t conn_id) {
  std::string id = copyGoString(library_id);
  auto dynamic_lib = Dso::DsoManager<Dso::NetworkFilterDsoImpl>::getDsoByID(id);
  UpstreamConnPtr conn_ptr =
      std::make_shared<UpstreamConn>(copyGoString(addr), dynamic_lib, conn_id);
  // the upstream connect wrapper will be deleted by envoyGoFilterUpstreamFinalize
  UpstreamConnWrapper* wrapper = new UpstreamConnWrapper(conn_ptr);
  conn_ptr->setWrapper(wrapper);

  conn_ptr->dispatcher()->post([conn_ptr] { conn_ptr->connect(); });

  return static_cast<void*>(wrapper);
}

CAPIStatus envoyGoFilterUpstreamWrite(void* u, void* buffer_ptr, int buffer_len, int end_stream) {
  auto* wrapper = reinterpret_cast<UpstreamConnWrapper*>(u);
  UpstreamConnPtr& conn_ptr = wrapper->conn_ptr_;
  // should do the copy right now, because the 'data' pointer still point at the go's heap
  Buffer::InstancePtr buffer =
      std::make_unique<Buffer::OwnedImpl>(reinterpret_cast<char*>(buffer_ptr), buffer_len);
  // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)
  conn_ptr->dispatcher()->post([conn_ptr, end_stream, buf_raw_ptr = buffer.release()] {
    Buffer::InstancePtr buf = absl::WrapUnique(buf_raw_ptr);
    conn_ptr->write(*buf.get(), end_stream);
  });
  return CAPIOK;
}

CAPIStatus envoyGoFilterUpstreamClose(void* u, int close_type) {
  auto* wrapper = reinterpret_cast<UpstreamConnWrapper*>(u);
  UpstreamConnPtr& conn_ptr = wrapper->conn_ptr_;
  conn_ptr->dispatcher()->post([conn_ptr, close_type] {
    conn_ptr->close(static_cast<Network::ConnectionCloseType>(close_type));
  });
  return CAPIOK;
}

void envoyGoFilterUpstreamFinalize(void* u, int reason) {
  UNREFERENCED_PARAMETER(reason);
  auto* wrapper = reinterpret_cast<UpstreamConnWrapper*>(u);
  UpstreamConnPtr& conn_ptr = wrapper->conn_ptr_;
  // make sure that the deconstructor is also executed by envoy work thread
  conn_ptr->dispatcher()->post([wrapper] { delete wrapper; });
}

CAPIStatus envoyGoFilterUpstreamInfo(void* u, int info_type, void* ret) {
  auto* wrapper = reinterpret_cast<UpstreamConnWrapper*>(u);
  UpstreamConnPtr& conn_ptr = wrapper->conn_ptr_;
  auto* goStr = reinterpret_cast<GoString*>(ret);
  switch (static_cast<ConnectionInfoType>(info_type)) {
  case ConnectionInfoType::LocalAddr:
    wrapper->str_value_ = conn_ptr->getLocalAddrStr();
    break;
  case ConnectionInfoType::RemoteAddr:
    wrapper->str_value_ = conn_ptr->getRemoteAddrStr();
    break;
  default:
    PANIC_DUE_TO_CORRUPT_ENUM;
  }
  goStr->p = wrapper->str_value_.data();
  goStr->n = wrapper->str_value_.length();
  return CAPIStatus::CAPIOK;
}

CAPIStatus envoyGoFilterSetFilterState(void* f, void* key, void* value, int state_type,
                                       int life_span, int stream_sharing) {
  auto* wrapper = reinterpret_cast<FilterWrapper*>(f);
  FilterWeakPtr& weak_ptr = wrapper->filter_ptr_;
  if (FilterSharedPtr f = weak_ptr.lock()) {
    auto key_str = referGoString(key);
    auto value_str = referGoString(value);
    return f->setFilterState(key_str, value_str, state_type, life_span, stream_sharing);
  }
  return CAPIStatus::CAPIFilterIsGone;
}

CAPIStatus envoyGoFilterGetFilterState(void* f, void* key, void* value) {
  auto* wrapper = reinterpret_cast<FilterWrapper*>(f);
  FilterWeakPtr& weak_ptr = wrapper->filter_ptr_;
  if (FilterSharedPtr f = weak_ptr.lock()) {
    auto key_str = referGoString(key);
    auto value_str = reinterpret_cast<GoString*>(value);
    return f->getFilterState(key_str, value_str);
  }
  return CAPIStatus::CAPIFilterIsGone;
}

} // extern "C"
} // namespace Golang
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/golang/filters/network/source/upstream.h"

#include <cstdint>

#include "envoy/network/connection.h"
#include "envoy/tcp/conn_pool.h"

#include "source/common/common/assert.h"
#include "source/common/network/filter_state_dst_address.h"
#include "source/common/network/utility.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace Golang {

// init function registers each works' dispatcher for load balance when creating upstream conn
void UpstreamConn::initThreadLocalStorage(Server::Configuration::FactoryContext& context,
                                          ThreadLocal::SlotAllocator& tls) {
  // dispatchers array should be init only once.
  DispatcherStore& store = dispatcherStore();
  std::call_once(store.init_once_, [&context, &tls, &store]() {
    // should be the singleton for use by the entire server.
    ClusterManagerContainer& cluster_manager_container = clusterManagerContainer();
    cluster_manager_container.cluster_manager_ = &context.serverFactoryContext().clusterManager();

    SlotPtrContainer& slot_ptr_container = slotPtrContainer();
    slot_ptr_container.slot_ = tls.allocateSlot();

    Thread::ThreadId main_thread_id =
        context.serverFactoryContext().api().threadFactory().currentThreadId();
    slot_ptr_container.slot_->set(
        [&context, main_thread_id,
         &store](Event::Dispatcher& dispatcher) -> ThreadLocal::ThreadLocalObjectSharedPtr {
          if (context.serverFactoryContext().api().threadFactory().currentThreadId() ==
              main_thread_id) {
            return nullptr;
          }

          {
            Thread::LockGuard guard(store.lock_);
            store.dispatchers_.push_back(dispatcher);
          }

          return nullptr;
        });
  });
}

UpstreamConn::UpstreamConn(std::string addr, Dso::NetworkFilterDsoPtr dynamic_lib,
                           unsigned long long int go_conn_id, Event::Dispatcher* dispatcher)
    : dynamic_lib_(dynamic_lib), go_conn_id_(go_conn_id), dispatcher_(dispatcher), addr_(addr) {
  if (dispatcher_ == nullptr) {
    DispatcherStore& store = dispatcherStore();
    Thread::LockGuard guard(store.lock_);
    // load balance among each workers' dispatcher
    ASSERT(!store.dispatchers_.empty());
    dispatcher_ = &store.dispatchers_[store.dispatcher_idx_++ % store.dispatchers_.size()].get();
  }
  stream_info_ = std::make_unique<StreamInfo::StreamInfoImpl>(
      dispatcher_->timeSource(), nullptr, StreamInfo::FilterState::LifeSpan::FilterChain);
  stream_info_->filterState()->setData(
      "envoy.network.transport_socket.original_dst_address",
      std::make_shared<Network::AddressObject>(
          Network::Utility::parseInternetAddressAndPort(addr, false)),
      StreamInfo::FilterState::StateType::ReadOnly, StreamInfo::FilterState::LifeSpan::FilterChain,
      StreamInfo::StreamSharingMayImpactPooling::None);
}

void UpstreamConn::connect() {
  ENVOY_LOG(debug, "do connect addr: {}", addr_);

  // TODO(antJack): add support for upstream TLS cluster.
  static const std::string upstream_cluster = "plainText";
  ClusterManagerContainer& cluster_manager_container = clusterManagerContainer();
  Upstream::ThreadLocalCluster* cluster =
      cluster_manager_container.cluster_manager_->getThreadLocalCluster(upstream_cluster);
  if (!cluster) {
    ENVOY_LOG(error, "cluster not found");
    onPoolFailure(Tcp::ConnectionPool::PoolFailureReason::LocalConnectionFailure,
                  absl::string_view("cluster not found"), nullptr);
    return;
  }

  auto conn_pool = cluster->tcpConnPool(Upstream::ResourcePriority::Default, this);
  if (!conn_pool) {
    ENVOY_LOG(error, "no host available for cluster");
    // prevent golang from blocking on connection result channel
    onPoolFailure(Tcp::ConnectionPool::PoolFailureReason::LocalConnectionFailure,
                  absl::string_view("no host available"), nullptr);
    return;
  }

  Tcp::ConnectionPool::Cancellable* cancellable = conn_pool.value().newConnection(*this);
  if (cancellable) {
    handler_ = cancellable;
  }
}

void UpstreamConn::write(Buffer::Instance& buf, bool end_stream) {
  if (closed_) {
    ENVOY_LOG(warn, "connection has closed, addr: {}", addr_);
    return;
  }
  ENVOY_CONN_LOG(debug, "write to addr: {}, len: {}, end: {}", conn_->connection(), addr_,
                 buf.length(), end_stream);
  ASSERT(conn_ != nullptr);
  conn_->connection().write(buf, end_stream);
}

void UpstreamConn::close(Network::ConnectionCloseType close_type) {
  if (closed_) {
    ENVOY_LOG(warn, "connection has closed, addr: {}", addr_);
    return;
  }
  ENVOY_CONN_LOG(debug, "close addr: {}, type: {}", conn_->connection(), addr_,
                 static_cast<int>(close_type));
  ASSERT(conn_ != nullptr);
  conn_->connection().close(close_type, "go_upstream_close");
}

void UpstreamConn::onPoolReady(Tcp::ConnectionPool::ConnectionDataPtr&& conn,
                               Upstream::HostDescriptionConstSharedPtr host) {
  ENVOY_CONN_LOG(debug, "onPoolReady, addr: {}", conn->connection(), addr_);
  if (handler_) {
    handler_ = nullptr;
  }

  conn_ = std::move(conn);
  host_ = host;
  conn_->addUpstreamCallbacks(*this);
  remote_addr_ = conn_->connection().connectionInfoProvider().directRemoteAddress()->asString();

  dynamic_lib_->envoyGoFilterOnUpstreamConnectionReady(wrapper_, go_conn_id_);
}

void UpstreamConn::onPoolFailure(Tcp::ConnectionPool::PoolFailureReason reason,
                                 absl::string_view transport_failure_reason,
                                 Upstream::HostDescriptionConstSharedPtr) {
  ENVOY_LOG(error, "onPoolFailure, addr: {}, reason: {}, {}", addr_, int(reason),
            std::string(transport_failure_reason));
  if (handler_) {
    handler_ = nullptr;
  }

  dynamic_lib_->envoyGoFilterOnUpstreamConnectionFailure(wrapper_, static_cast<int>(reason),
                                                         go_conn_id_);
}

void UpstreamConn::onEvent(Network::ConnectionEvent event) {
  ENVOY_CONN_LOG(debug, "onEvent addr: {}, event: {}", conn_->connection(), addr_,
                 static_cast<int>(event));
  if (event == Network::ConnectionEvent::LocalClose ||
      event == Network::ConnectionEvent::RemoteClose) {
    closed_ = true;
    conn_ = nullptr;
  }

  dynamic_lib_->envoyGoFilterOnUpstreamEvent(wrapper_, static_cast<int>(event));
}

void UpstreamConn::onUpstreamData(Buffer::Instance& data, bool end_stream) {
  ENVOY_CONN_LOG(debug, "onData, addr: {}, len: {}, end: {}", conn_->connection(), addr_,
                 data.length(), end_stream);

  Buffer::RawSliceVector slice_vector = data.getRawSlices();
  int slice_num = slice_vector.size();
  unsigned long long* slices = new unsigned long long[2 * slice_num];
  for (int i = 0; i < slice_num; i++) {
    const Buffer::RawSlice& s = slice_vector[i];
    slices[2 * i] = reinterpret_cast<unsigned long long>(s.mem_);
    slices[2 * i + 1] = s.len_;
  }

  dynamic_lib_->envoyGoFilterOnUpstreamData(
      wrapper_, data.length(), reinterpret_cast<GoUint64>(slices), slice_num, end_stream);

  // TODO: do not drain buffer by default
  data.drain(data.length());

  delete[] slices;
}

} // namespace Golang
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/golang/filters/network/source/golang.h"

#include <cstdint>

#include "envoy/network/connection.h"

#include "source/common/common/assert.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace Golang {

FilterConfig::FilterConfig(
    const envoy::extensions::filters::network::golang::v3alpha::Config& proto_config)
    : library_id_(proto_config.library_id()), library_path_(proto_config.library_path()),
      plugin_name_(proto_config.plugin_name()), plugin_config_(proto_config.plugin_config()) {}

void Filter::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) {
  read_callbacks_ = &callbacks;
  dispatcher_ = &read_callbacks_->connection().dispatcher();
  read_callbacks_->connection().addConnectionCallbacks(*this);

  local_addr_ = callbacks.connection().connectionInfoProvider().localAddress()->asString();
  addr_ = callbacks.connection().connectionInfoProvider().directRemoteAddress()->asString();
}

void Filter::close(Network::ConnectionCloseType close_type) {
  if (closed_) {
    ENVOY_CONN_LOG(warn, "connection has closed, addr: {}", read_callbacks_->connection(), addr_);
    return;
  }
  ENVOY_CONN_LOG(debug, "close addr: {}, type: {}", read_callbacks_->connection(), addr_,
                 static_cast<int>(close_type));
  read_callbacks_->connection().close(close_type, "go_downstream_close");
}

void Filter::write(Buffer::Instance& buf, bool end_stream) {
  if (closed_) {
    ENVOY_CONN_LOG(warn, "connection has closed, addr: {}", read_callbacks_->connection(), addr_);
    return;
  }
  ENVOY_CONN_LOG(debug, "write to addr: {}, len: {}, end: {}", read_callbacks_->connection(), addr_,
                 buf.length(), end_stream);
  read_callbacks_->connection().write(buf, end_stream);
}

Network::FilterStatus Filter::onNewConnection() {
  ENVOY_CONN_LOG(debug, "onNewConnection, addr: {}, localAddr: {}", read_callbacks_->connection(),
                 addr_, local_addr_);
  wrapper_ = new FilterWrapper(weak_from_this());

  return Network::FilterStatus(dynamic_lib_->envoyGoFilterOnDownstreamConnection(
      wrapper_, reinterpret_cast<unsigned long long>(plugin_name_.data()), plugin_name_.length(),
      config_id_));
}

void Filter::onEvent(Network::ConnectionEvent event) {
  ENVOY_CONN_LOG(debug, "onEvent addr: {}, event: {}", read_callbacks_->connection(), addr_,
                 static_cast<int>(event));

  if (event == Network::ConnectionEvent::LocalClose ||
      event == Network::ConnectionEvent::RemoteClose) {
    closed_ = true;
  }

  dynamic_lib_->envoyGoFilterOnDownstreamEvent(wrapper_, static_cast<int>(event));
}

Network::FilterStatus Filter::onData(Buffer::Instance& data, bool end_stream) {
  ENVOY_CONN_LOG(debug, "onData, addr: {}, len: {}, end: {}", read_callbacks_->connection(), addr_,
                 data.length(), end_stream);

  Buffer::RawSliceVector slice_vector = data.getRawSlices();
  int slice_num = slice_vector.size();
  unsigned long long* slices = new unsigned long long[2 * slice_num];
  for (int i = 0; i < slice_num; i++) {
    const Buffer::RawSlice& s = slice_vector[i];
    slices[2 * i] = reinterpret_cast<unsigned long long>(s.mem_);
    slices[2 * i + 1] = s.len_;
  }

  auto ret = dynamic_lib_->envoyGoFilterOnDownstreamData(
      wrapper_, data.length(), reinterpret_cast<GoUint64>(slices), slice_num, end_stream);

  // TODO: do not drain buffer by default
  data.drain(data.length());

  delete[] slices;

  return Network::FilterStatus(ret);
}

Network::FilterStatus Filter::onWrite(Buffer::Instance& data, bool end_stream) {
  ENVOY_CONN_LOG(debug, "onWrite, addr: {}, len: {}, end: {}", read_callbacks_->connection(), addr_,
                 data.length(), end_stream);

  Buffer::RawSliceVector slice_vector = data.getRawSlices();
  int slice_num = slice_vector.size();
  unsigned long long* slices = new unsigned long long[2 * slice_num];
  for (int i = 0; i < slice_num; i++) {
    const Buffer::RawSlice& s = slice_vector[i];
    slices[2 * i] = reinterpret_cast<unsigned long long>(s.mem_);
    slices[2 * i + 1] = s.len_;
  }

  auto ret = dynamic_lib_->envoyGoFilterOnDownstreamWrite(
      wrapper_, data.length(), reinterpret_cast<GoUint64>(slices), slice_num, end_stream);

  delete[] slices;

  return Network::FilterStatus(ret);
}

CAPIStatus Filter::setFilterState(absl::string_view key, absl::string_view value, int state_type,
                                  int life_span, int stream_sharing) {
  // lock until this function return since it may running in a Go thread.
  Thread::LockGuard lock(mutex_);
  if (closed_) {
    ENVOY_CONN_LOG(warn, "connection has closed, addr: {}", read_callbacks_->connection(), addr_);
    return CAPIStatus::CAPIFilterIsDestroy;
  }

  if (dispatcher_->isThreadSafe()) {
    read_callbacks_->connection().streamInfo().filterState()->setData(
        key, std::make_shared<GoStringFilterState>(value),
        static_cast<StreamInfo::FilterState::StateType>(state_type),
        static_cast<StreamInfo::FilterState::LifeSpan>(life_span),
        static_cast<StreamInfo::StreamSharingMayImpactPooling>(stream_sharing));
  } else {
    auto key_str = std::string(key);
    auto filter_state = std::make_shared<GoStringFilterState>(value);
    auto weak_ptr = weak_from_this();
    dispatcher_->post(
        [this, weak_ptr, key_str, filter_state, state_type, life_span, stream_sharing] {
          if (!weak_ptr.expired() && !closed_) {
            Thread::LockGuard lock(mutex_);
            read_callbacks_->connection().streamInfo().filterState()->setData(
                key_str, filter_state, static_cast<StreamInfo::FilterState::StateType>(state_type),
                static_cast<StreamInfo::FilterState::LifeSpan>(life_span),
                static_cast<StreamInfo::StreamSharingMayImpactPooling>(stream_sharing));
          } else {
            ENVOY_CONN_LOG(info, "golang filter has gone or destroyed in setStringFilterState",
                           read_callbacks_->connection());
          }
        });
  }
  return CAPIStatus::CAPIOK;
}

CAPIStatus Filter::getFilterState(absl::string_view key, GoString* value_str) {
  // lock until this function return since it may running in a Go thread.
  Thread::LockGuard lock(mutex_);
  if (closed_) {
    ENVOY_CONN_LOG(warn, "connection has closed, addr: {}", read_callbacks_->connection(), addr_);
    return CAPIStatus::CAPIFilterIsDestroy;
  }

  if (dispatcher_->isThreadSafe()) {
    auto go_filter_state = read_callbacks_->connection()
                               .streamInfo()
                               .filterState()
                               ->getDataReadOnly<GoStringFilterState>(key);
    if (go_filter_state) {
      wrapper_->str_value_ = go_filter_state->value();
      value_str->p = wrapper_->str_value_.data();
      value_str->n = wrapper_->str_value_.length();
    }
  } else {
    auto key_str = std::string(key);
    auto weak_ptr = weak_from_this();
    dispatcher_->post([this, weak_ptr, key_str, value_str] {
      if (!weak_ptr.expired() && !closed_) {
        auto go_filter_state = read_callbacks_->connection()
                                   .streamInfo()
                                   .filterState()
                                   ->getDataReadOnly<GoStringFilterState>(key_str);
        if (go_filter_state) {
          wrapper_->str_value_ = go_filter_state->value();
          value_str->p = wrapper_->str_value_.data();
          value_str->n = wrapper_->str_value_.length();
        }
        dynamic_lib_->envoyGoFilterOnSemaDec(wrapper_);
      } else {
        ENVOY_CONN_LOG(info, "golang filter has gone or destroyed in setStringFilterState",
                       read_callbacks_->connection());
      }
    });
    return CAPIStatus::CAPIYield;
  }
  return CAPIStatus::CAPIOK;
}

} // namespace Golang
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_cc_contrib_extension",
    "envoy_cc_library",
    "envoy_contrib_package",
)

licenses(["notice"])  # Apache 2

# Golang L4 network filter.

envoy_contrib_package()

envoy_cc_library(
    name = "golang",
    srcs = ["golang.cc"],
    hdrs = ["golang.h"],
    deps = [
        ":cgo",
        ":upstream",
        "//contrib/golang/common/dso:dso_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/golang/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_library(
    name = "upstream",
    srcs = ["upstream.cc"],
    hdrs = [
        "upstream.h",
    ],
    deps = [
        "//contrib/golang/common/dso:dso_lib",
        "//envoy/buffer:buffer_interface",
        "//envoy/event:dispatcher_interface",
        "//envoy/network:connection_interface",
        "//envoy/network:filter_interface",
        "//envoy/tcp:conn_pool_interface",
        "//envoy/upstream:cluster_manager_interface",
        "//envoy/upstream:load_balancer_interface",
        "//envoy/upstream:thread_local_cluster_interface",
        "//source/common/buffer:buffer_lib",
        "//source/common/common:assert_lib",
        "//source/common/common:minimal_logger_lib",
        "//source/common/common:thread_lib",
        "//source/common/memory:utils_lib",
        "//source/common/network:connection_lib",
        "//source/common/network:filter_state_dst_address_lib",
        "//source/common/network:utility_lib",
        "//source/common/stream_info:stream_info_lib",
        "//source/common/tcp:conn_pool_lib",
        "//source/common/upstream:load_balancer_lib",
        "//source/extensions/filters/network/common:factory_base_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/golang/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_contrib_extension(
    name = "config",
    srcs = ["config.cc"],
    hdrs = [
        "config.h",
    ],
    deps = [
        ":golang",
        ":upstream",
        "//envoy/registry",
        "//envoy/server:filter_config_interface",
        "//envoy/server:lifecycle_notifier_interface",
        "//source/extensions/filters/network:well_known_names",
        "//source/extensions/filters/network/common:factory_base_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/golang/v3alpha:pkg_cc_proto",
    ],
)

envoy_cc_contrib_extension(
    name = "cgo",
    srcs = ["cgo.cc"],
    hdrs = [
        "golang.h",
        "upstream.h",
    ],
    deps = [
        "//contrib/golang/common/dso:dso_lib",
        "//contrib/golang/common/log:log_lib",
        "//envoy/buffer:buffer_interface",
        "//envoy/event:dispatcher_interface",
        "//envoy/network:connection_interface",
        "//envoy/network:filter_interface",
        "//envoy/registry",
        "//envoy/server:filter_config_interface",
        "//envoy/upstream:cluster_manager_interface",
        "//envoy/upstream:load_balancer_interface",
        "//envoy/upstream:thread_local_cluster_interface",
        "//source/common/buffer:buffer_lib",
        "//source/common/common:assert_lib",
        "//source/common/common:minimal_logger_lib",
        "//source/common/memory:utils_lib",
        "//source/common/network:connection_lib",
        "//source/common/upstream:load_balancer_lib",
        "//source/extensions/filters/network:well_known_names",
        "//source/extensions/filters/network/common:factory_base_lib",
        "@envoy_api//contrib/envoy/extensions/filters/network/golang/v3alpha:pkg_cc_proto",
    ],
)
#pragma once

#include <functional>
#include <vector>

#include "envoy/buffer/buffer.h"
#include "envoy/event/dispatcher.h"
#include "envoy/network/connection.h"
#include "envoy/network/filter.h"
#include "envoy/tcp/conn_pool.h"
#include "envoy/upstream/cluster_manager.h"

#include "source/common/buffer/buffer_impl.h"
#include "source/common/common/logger.h"
#include "source/common/common/thread.h"
#include "source/common/memory/utils.h"
#include "source/common/network/connection_impl.h"
#include "source/common/stream_info/stream_info_impl.h"
#include "source/common/upstream/load_balancer_impl.h"
#include "source/extensions/filters/network/common/factory_base.h"

#include "contrib/envoy/extensions/filters/network/golang/v3alpha/golang.pb.h"
#include "contrib/golang/common/dso/dso.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace Golang {

struct UpstreamConnWrapper;

class UpstreamConn : public Tcp::ConnectionPool::Callbacks,
                     public Upstream::LoadBalancerContextBase,
                     public Tcp::ConnectionPool::UpstreamCallbacks,
                     public std::enable_shared_from_this<UpstreamConn>,
                     Logger::Loggable<Logger::Id::golang> {
public:
  UpstreamConn(std::string addr, Dso::NetworkFilterDsoPtr dynamic_lib,
               unsigned long long int go_conn_id, Event::Dispatcher* dispatcher = nullptr);
  ~UpstreamConn() override {
    if (handler_) {
      handler_->cancel(Tcp::ConnectionPool::CancelPolicy::Default);
    }
  }

  static void initThreadLocalStorage(Server::Configuration::FactoryContext& context,
                                     ThreadLocal::SlotAllocator& tls);

  // Tcp::ConnectionPool::Callbacks
  void onPoolFailure(Tcp::ConnectionPool::PoolFailureReason reason,
                     absl::string_view transport_failure_reason,
                     Upstream::HostDescriptionConstSharedPtr host) override;

  void onPoolReady(Tcp::ConnectionPool::ConnectionDataPtr&& conn,
                   Upstream::HostDescriptionConstSharedPtr host) override;

  // Tcp::ConnectionPool::UpstreamCallbacks
  void onUpstreamData(Buffer::Instance& data, bool end_stream) override;
  void onAboveWriteBufferHighWatermark() override {}
  void onBelowWriteBufferLowWatermark() override {}
  void onEvent(Network::ConnectionEvent event) override;

  // Upstream::LoadBalancerContextBase
  const StreamInfo::StreamInfo* requestStreamInfo() const override { return stream_info_.get(); }

  void connect();
  void write(Buffer::Instance& buf, bool end_stream);
  void close(Network::ConnectionCloseType close_type);

  Event::Dispatcher* dispatcher() { return dispatcher_; }
  void setWrapper(UpstreamConnWrapper* wrapper) { wrapper_ = wrapper; };

  std::string getLocalAddrStr() const { return addr_; }
  std::string getRemoteAddrStr() const { return remote_addr_; };

private:
  struct DispatcherStore {
    std::vector<std::reference_wrapper<Event::Dispatcher>> dispatchers_ ABSL_GUARDED_BY(lock_){};
    int dispatcher_idx_ ABSL_GUARDED_BY(lock_){0};
    Thread::MutexBasicLockable lock_{};
    std::once_flag init_once_{};
  };
  static DispatcherStore& dispatcherStore() { MUTABLE_CONSTRUCT_ON_FIRST_USE(DispatcherStore); }

  struct SlotPtrContainer {
    ThreadLocal::SlotPtr slot_{nullptr};
  };
  static SlotPtrContainer& slotPtrContainer() { MUTABLE_CONSTRUCT_ON_FIRST_USE(SlotPtrContainer); }

  struct ClusterManagerContainer {
    Upstream::ClusterManager* cluster_manager_{nullptr};
  };
  static ClusterManagerContainer& clusterManagerContainer() {
    MUTABLE_CONSTRUCT_ON_FIRST_USE(ClusterManagerContainer);
  }

  Dso::NetworkFilterDsoPtr dynamic_lib_{nullptr};
  unsigned long long int go_conn_id_{0};
  UpstreamConnWrapper* wrapper_{nullptr};
  Event::Dispatcher* dispatcher_{nullptr};
  std::unique_ptr<StreamInfo::StreamInfo> stream_info_{nullptr};
  Tcp::ConnectionPool::ConnectionDataPtr conn_{nullptr};
  Upstream::HostDescriptionConstSharedPtr host_{nullptr};
  Tcp::ConnectionPool::Cancellable* handler_{nullptr};
  bool closed_{false};
  std::string addr_{};
  std::string remote_addr_{};
};

using UpstreamConnPtr = std::shared_ptr<UpstreamConn>;

struct UpstreamConnWrapper {
public:
  UpstreamConnWrapper(UpstreamConnPtr ptr) : conn_ptr_(ptr) {}
  ~UpstreamConnWrapper() = default;

  // Must be strong shared_ptr, otherwise the UpstreamConn will be released immediately since we do
  // not have any other place to keep strong reference of the UpstreamConn.
  UpstreamConnPtr conn_ptr_{};
  // anchor a string temporarily, make sure it won't be freed before copied to Go.
  std::string str_value_;
};

} // namespace Golang
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
#include "contrib/golang/filters/network/source/config.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace Golang {

/**
 * Static registration for the golang filter. @see RegisterFactory.
 */
REGISTER_FACTORY(GolangConfigFactory,
                 Envoy::Server::Configuration::NamedNetworkFilterConfigFactory);

Network::FilterFactoryCb GolangConfigFactory::createFilterFactoryFromProtoTyped(
    const envoy::extensions::filters::network::golang::v3alpha::Config& proto_config,
    Server::Configuration::FactoryContext& context) {
  is_terminal_filter_ = proto_config.is_terminal_filter();

  UpstreamConn::initThreadLocalStorage(context, context.serverFactoryContext().threadLocal());

  FilterConfigSharedPtr config = std::make_shared<FilterConfig>(proto_config);
  std::string config_str;
  auto res = config->pluginConfig().SerializeToString(&config_str);
  ASSERT(res, "SerializeToString should always successful");
  std::string library_id = config->libraryID();

  // TODO(antJack): should check the return value and fast fail if we cannot load the dso.
  Dso::DsoManager<Dso::NetworkFilterDsoImpl>::load(library_id, config->libraryPath());

  uint64_t config_id = 0;
  auto dlib = Dso::DsoManager<Dso::NetworkFilterDsoImpl>::getDsoByID(library_id);
  if (dlib) {
    config_id = dlib->envoyGoFilterOnNetworkFilterConfig(
        reinterpret_cast<unsigned long long>(library_id.data()), library_id.length(),
        reinterpret_cast<unsigned long long>(config_str.data()), config_str.length());
    ASSERT(config_id, "config id should not be zero");
  }

  return [config, config_id, &context, dlib](Network::FilterManager& filter_manager) -> void {
    filter_manager.addFilter(std::make_shared<Filter>(context, config, config_id, dlib));
  };
}

} // namespace Golang
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";
package envoy.extensions.filters.http.golang;

import "test/fuzz/common.proto";
import "validate/validate.proto";

// We only fuzz a single request per iteration.
message GolangFilterTestCase {
  // HTTP request data.
  test.fuzz.HttpData request_data = 1 [(validate.rules).message = {required: true}];
}
#include "envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h"

#include "test/config/v2_link_hacks.h"
#include "test/extensions/filters/http/common/empty_http_filter_config.h"
#include "test/integration/http_integration.h"
#include "test/test_common/registry.h"
#include "test/test_common/utility.h"

#include "contrib/golang/filters/http/source/golang_filter.h"
#include "gtest/gtest.h"

namespace Envoy {

// helper function
absl::string_view getHeader(const Http::HeaderMap& headers, absl::string_view key) {
  auto values = headers.get(Http::LowerCaseString(key));
  if (values.empty()) {
    return "";
  }
  return values[0]->value().getStringView();
}

class RetrieveDynamicMetadataFilter : public Http::StreamEncoderFilter {
public:
  // Http::StreamEncoderFilter
  Http::Filter1xxHeadersStatus encode1xxHeaders(Http::ResponseHeaderMap&) override {
    return Http::Filter1xxHeadersStatus::Continue;
  }

  Http::FilterHeadersStatus encodeHeaders(Http::ResponseHeaderMap&, bool) override {
    const auto& metadata = decoder_callbacks_->streamInfo().dynamicMetadata().filter_metadata();
    const auto& filter_it = metadata.find("filter.go");
    ASSERT(filter_it != metadata.end());
    const auto& fields = filter_it->second.fields();
    std::string val = fields.at("foo").string_value();
    EXPECT_EQ(val, "bar");
    EXPECT_TRUE(
        decoder_callbacks_->streamInfo().filterState()->hasDataWithName("go_state_test_key"));
    return Http::FilterHeadersStatus::Continue;
  }

  Http::FilterDataStatus encodeData(Buffer::Instance&, bool) override {
    return Http::FilterDataStatus::Continue;
  }

  Http::FilterTrailersStatus encodeTrailers(Http::ResponseTrailerMap&) override {
    return Http::FilterTrailersStatus::Continue;
  }

  Http::FilterMetadataStatus encodeMetadata(Http::MetadataMap&) override {
    return Http::FilterMetadataStatus::Continue;
  }

  void setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) override {
    decoder_callbacks_ = &callbacks;
  }

  void onDestroy() override{};
  Http::StreamEncoderFilterCallbacks* decoder_callbacks_;
};

class RetrieveDynamicMetadataFilterConfig
    : public Extensions::HttpFilters::Common::EmptyHttpFilterConfig {
public:
  RetrieveDynamicMetadataFilterConfig()
      : Extensions::HttpFilters::Common::EmptyHttpFilterConfig("validate-dynamic-metadata") {}

  absl::StatusOr<Http::FilterFactoryCb>
  createFilter(const std::string&, Server::Configuration::FactoryContext&) override {
    return [](Http::FilterChainFactoryCallbacks& callbacks) -> void {
      callbacks.addStreamEncoderFilter(std::make_shared<::Envoy::RetrieveDynamicMetadataFilter>());
    };
  }
};

class GolangIntegrationTest : public testing::TestWithParam<Network::Address::IpVersion>,
                              public HttpIntegrationTest {
public:
  GolangIntegrationTest()
      : HttpIntegrationTest(Http::CodecClient::Type::HTTP1, GetParam()), registration_(factory_) {}

  RetrieveDynamicMetadataFilterConfig factory_;
  Registry::InjectFactory<Server::Configuration::NamedHttpFilterConfigFactory> registration_;

  void createUpstreams() override {
    HttpIntegrationTest::createUpstreams();
    addFakeUpstream(Http::CodecType::HTTP1);
    addFakeUpstream(Http::CodecType::HTTP1);
  }

  std::string genSoPath(std::string name) {
    return TestEnvironment::substitute(
        "{{ test_rundir }}/contrib/golang/filters/http/test/test_data/" + name + "/filter.so");
  }

  void initializeConfig(const std::string& lib_id, const std::string& lib_path,
                        const std::string& plugin_name) {
    const auto yaml_fmt = R"EOF(
name: golang
typed_config:
  "@type": type.googleapis.com/envoy.extensions.filters.http.golang.v3alpha.Config
  library_id: %s
  library_path: %s
  plugin_name: %s
  plugin_config:
    "@type": type.googleapis.com/xds.type.v3.TypedStruct
    value:
     echo_body: "echo from go"
     match_path: "/echo"
)EOF";

    auto yaml_string = absl::StrFormat(yaml_fmt, lib_id, lib_path, plugin_name);
    config_helper_.prependFilter(yaml_string);
    config_helper_.skipPortUsageValidation();
  }

  void initializeBasicFilter(const std::string& so_id, const std::string& domain = "*",
                             bool with_injected_metadata_validator = false) {
    const auto yaml_fmt = R"EOF(
name: golang
typed_config:
  "@type": type.googleapis.com/envoy.extensions.filters.http.golang.v3alpha.Config
  library_id: %s
  library_path: %s
  plugin_name: %s
  plugin_config:
    "@type": type.googleapis.com/xds.type.v3.TypedStruct
    value:
      remove: x-test-header-0
      set: foo
)EOF";

    auto yaml_string = absl::StrFormat(yaml_fmt, so_id, genSoPath(so_id), so_id);
    config_helper_.prependFilter(yaml_string);
    if (with_injected_metadata_validator) {
      config_helper_.prependFilter("{ name: validate-dynamic-metadata }");
    }

    config_helper_.skipPortUsageValidation();

    config_helper_.addConfigModifier(
        [domain](
            envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
                hcm) {
          hcm.mutable_route_config()
              ->mutable_virtual_hosts(0)
              ->mutable_routes(0)
              ->mutable_match()
              ->set_prefix("/test");

          // setting route name for testing
          hcm.mutable_route_config()->mutable_virtual_hosts(0)->mutable_routes(0)->set_name(
              "test-route-name");
          hcm.mutable_route_config()->mutable_virtual_hosts(0)->set_domains(0, domain);

          auto* virtual_cluster =
              hcm.mutable_route_config()->mutable_virtual_hosts(0)->add_virtual_clusters();
          virtual_cluster->set_name("test_vcluster");
          auto* headers = virtual_cluster->add_headers();
          // use test_vcluster if presents
          headers->set_name("existed-header");
          headers->set_present_match(true);

          hcm.mutable_route_config()
              ->mutable_virtual_hosts(0)
              ->mutable_routes(0)
              ->mutable_route()
              ->set_cluster("cluster_0");
        });
    config_helper_.addConfigModifier(setEnableDownstreamTrailersHttp1());
    config_helper_.addConfigModifier(setEnableUpstreamTrailersHttp1());
    initialize();
  }

  void initializeRouteConfig(const std::string& so_id) {
    config_helper_.addConfigModifier(
        [so_id](
            envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
                hcm) {
          // for testing http filter level config, a new virtualhost without per route config
          auto vh = hcm.mutable_route_config()->add_virtual_hosts();
          vh->add_domains("filter-level.com");
          vh->set_name("filter-level.com");
          auto* rt = vh->add_routes();
          rt->mutable_match()->set_prefix("/test");
          rt->mutable_route()->set_cluster("cluster_0");

          // virtualhost level per route config
          const std::string key = "golang";
          const auto yaml_fmt =
              R"EOF(
              "@type": type.googleapis.com/envoy.extensions.filters.http.golang.v3alpha.ConfigsPerRoute
              plugins_config:
                %s:
                  config:
                    "@type": type.googleapis.com/xds.type.v3.TypedStruct
                    type_url: map
                    value:
                      remove: x-test-header-1
                      set: bar
              )EOF";
          auto yaml = absl::StrFormat(yaml_fmt, so_id);
          ProtobufWkt::Any value;
          TestUtility::loadFromYaml(yaml, value);
          hcm.mutable_route_config()
              ->mutable_virtual_hosts(0)
              ->mutable_typed_per_filter_config()
              ->insert(Protobuf::MapPair<std::string, ProtobufWkt::Any>(key, value));

          // route level per route config
          const auto yaml_fmt2 =
              R"EOF(
              "@type": type.googleapis.com/envoy.extensions.filters.http.golang.v3alpha.ConfigsPerRoute
              plugins_config:
                %s:
                  config:
                    "@type": type.googleapis.com/xds.type.v3.TypedStruct
                    type_url: map
                    value:
                      remove: x-test-header-0
                      set: baz
              )EOF";
          auto yaml2 = absl::StrFormat(yaml_fmt2, so_id);
          ProtobufWkt::Any value2;
          TestUtility::loadFromYaml(yaml2, value2);

          auto* new_route2 = hcm.mutable_route_config()->mutable_virtual_hosts(0)->add_routes();
          new_route2->mutable_match()->set_prefix("/route-config-test");
          new_route2->mutable_typed_per_filter_config()->insert(
              Protobuf::MapPair<std::string, ProtobufWkt::Any>(key, value2));
          new_route2->mutable_route()->set_cluster("cluster_0");
        });

    initializeBasicFilter(so_id, "test.com");
  }

  void initializePropertyConfig(const std::string& lib_id, const std::string& lib_path,
                                const std::string& plugin_name) {
    const auto yaml_fmt = R"EOF(
name: golang
typed_config:
  "@type": type.googleapis.com/envoy.extensions.filters.http.golang.v3alpha.Config
  library_id: %s
  library_path: %s
  plugin_name: %s
  plugin_config:
    "@type": type.googleapis.com/xds.type.v3.TypedStruct
)EOF";

    auto yaml_string = absl::StrFormat(yaml_fmt, lib_id, lib_path, plugin_name);
    config_helper_.prependFilter(yaml_string);
    config_helper_.skipPortUsageValidation();

    config_helper_.addConfigModifier(
        [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
               hcm) {
          hcm.mutable_route_config()
              ->mutable_virtual_hosts(0)
              ->mutable_routes(0)
              ->mutable_match()
              ->set_prefix("/property");

          // setting route name for testing
          hcm.mutable_route_config()->mutable_virtual_hosts(0)->mutable_routes(0)->set_name(
              "test-route-name");
          hcm.mutable_route_config()
              ->mutable_virtual_hosts(0)
              ->mutable_routes(0)
              ->mutable_route()
              ->set_cluster("cluster_0");
        });

    config_helper_.addConfigModifier(setEnableDownstreamTrailersHttp1());
    config_helper_.addConfigModifier(setEnableUpstreamTrailersHttp1());
  }

  void testBasic(std::string path) {
    initializeBasicFilter(BASIC, "test.com");

    codec_client_ = makeHttpConnection(makeClientConnection(lookupPort("http")));
    Http::TestRequestHeaderMapImpl request_headers{
        {":method", "POST"},        {":path", path},
        {":scheme", "http"},        {":authority", "test.com"},
        {"x-test-header-0", "foo"}, {"x-test-header-1", "bar"},
        {"existed-header", "foo"},
    };

    auto encoder_decoder = codec_client_->startRequest(request_headers);
    Http::RequestEncoder& request_encoder = encoder_decoder.first;
    auto response = std::move(encoder_decoder.second);
    codec_client_->sendData(request_encoder, "helloworld", false);
    codec_client_->sendData(request_encoder, "", false);

    Http::TestRequestTrailerMapImpl request_trailers{
        {"x-test-trailer-0", "foo"}, {"existed-trailer", "foo"}, {"x-test-trailer-1", "foo"}};
    codec_client_->sendTrailers(request_encoder, request_trailers);

    waitForNextUpstreamRequest();

    EXPECT_EQ("go_state_test_value",
              getHeader(upstream_request_->headers(), "go-state-test-header-key"));

    // original header: x-test-header-0
    EXPECT_EQ("foo", getHeader(upstream_request_->headers(), "x-test-header-0"));

    // check header value which set in golang: test-x-set-header-0
    EXPECT_EQ("foo", getHeader(upstream_request_->headers(), "test-x-set-header-0"));

    // check header exists which removed in golang side: x-test-header-1
    EXPECT_TRUE(upstream_request_->headers().get(Http::LowerCaseString("x-test-header-1")).empty());

    // check header value which set in golang: req-downstream-local-address
    EXPECT_TRUE(
        absl::StrContains(getHeader(upstream_request_->headers(), "req-downstream-local-address"),
                          GetParam() == Network::Address::IpVersion::v4 ? "127.0.0.1:" : "[::1]:"));

    // check header value which set in golang: req-downstream-remote-address
    EXPECT_TRUE(
        absl::StrContains(getHeader(upstream_request_->headers(), "req-downstream-remote-address"),
                          GetParam() == Network::Address::IpVersion::v4 ? "127.0.0.1:" : "[::1]:"));

    // check header value which is appended in golang: existed-header
    auto entries = upstream_request_->headers().get(Http::LowerCaseString("existed-header"));
    EXPECT_EQ(2, entries.size());
    EXPECT_EQ("foo", entries[0]->value().getStringView());
    EXPECT_EQ("bar", entries[1]->value().getStringView());

    // check header value which added in golang: newly-added-header
    entries = upstream_request_->headers().get(Http::LowerCaseString("newly-added-header"));
    EXPECT_EQ(2, entries.size());
    EXPECT_EQ("foo", entries[0]->value().getStringView());
    EXPECT_EQ("bar", entries[1]->value().getStringView());

    // "prepend_" + upper("helloworld") + "_append"
    std::string expected = "prepend_HELLOWORLD_append";
    // only match the prefix since data buffer may be combined into a single.
    EXPECT_EQ(expected, upstream_request_->body().toString());

    // check trailer value which is appended in golang: existed-trailer
    entries = upstream_request_->trailers()->get(Http::LowerCaseString("existed-trailer"));
    EXPECT_EQ(2, entries.size());
    EXPECT_EQ("foo", entries[0]->value().getStringView());
    EXPECT_EQ("bar", entries[1]->value().getStringView());

    // check trailer value which set in golang: x-test-trailer-0
    entries = upstream_request_->trailers()->get(Http::LowerCaseString("x-test-trailer-0"));
    EXPECT_EQ("bar", entries[0]->value().getStringView());

    EXPECT_TRUE(
        upstream_request_->trailers()->get(Http::LowerCaseString("x-test-trailer-1")).empty());

    // check trailer value which add in golang: x-test-trailer-2
    entries = upstream_request_->trailers()->get(Http::LowerCaseString("x-test-trailer-2"));

    EXPECT_EQ("bar", entries[0]->value().getStringView());

    Http::TestResponseHeaderMapImpl response_headers{
        {":status", "200"},
        {"x-test-header-0", "foo"},
        {"x-test-header-1", "bar"},
        {"existed-header", "foo"},
    };
    upstream_request_->encodeHeaders(response_headers, false);
    Buffer::OwnedImpl response_data1("good");
    upstream_request_->encodeData(response_data1, false);
    Buffer::OwnedImpl response_data2("bye");
    upstream_request_->encodeData(response_data2, true);

    ASSERT_TRUE(response->waitForEndStream());

    // original resp header: x-test-header-0
    EXPECT_EQ("foo", getHeader(response->headers(), "x-test-header-0"));

    // check resp header value which set in golang: test-x-set-header-0
    EXPECT_EQ("foo", getHeader(response->headers(), "test-x-set-header-0"));

    // check resp header exists which removed in golang side: x-test-header-1
    EXPECT_TRUE(response->headers().get(Http::LowerCaseString("x-test-header-1")).empty());

    // check header value which is appended in golang: existed-header
    entries = response->headers().get(Http::LowerCaseString("existed-header"));
    EXPECT_EQ(2, entries.size());
    EXPECT_EQ("foo", entries[0]->value().getStringView());
    EXPECT_EQ("bar", entries[1]->value().getStringView());

    // check header value which added in golang: newly-added-header
    entries = response->headers().get(Http::LowerCaseString("newly-added-header"));
    EXPECT_EQ(2, entries.size());
    EXPECT_EQ("foo", entries[0]->value().getStringView());
    EXPECT_EQ("bar", entries[1]->value().getStringView());

    // length("helloworld") = 10
    EXPECT_EQ("10", getHeader(response->headers(), "test-req-body-length"));

    // check route name in encode phase
    EXPECT_EQ("test-route-name", getHeader(response->headers(), "rsp-route-name"));

    // check protocol in encode phase
    EXPECT_EQ("HTTP/1.1", getHeader(response->headers(), "rsp-protocol"));

    // check filter chain name in encode phase, exists.
    EXPECT_FALSE(response->headers().get(Http::LowerCaseString("rsp-filter-chain-name")).empty());

    // check response code in encode phase, not exists.
    EXPECT_FALSE(response->headers().get(Http::LowerCaseString("rsp-response-code")).empty());

    // check response code details in encode phase
    EXPECT_EQ("via_upstream", getHeader(response->headers(), "rsp-response-code-details"));

    // check upstream host in encode phase
    EXPECT_TRUE(
        absl::StrContains(getHeader(response->headers(), "rsp-upstream-host"),
                          GetParam() == Network::Address::IpVersion::v4 ? "127.0.0.1:" : "[::1]:"));

    // check upstream cluster in encode phase
    EXPECT_EQ("cluster_0", getHeader(response->headers(), "rsp-upstream-cluster"));

    // check response attempt count in encode phase
    EXPECT_EQ("1", getHeader(response->headers(), "rsp-attempt-count"));

    // check virtual cluster name
    EXPECT_EQ("test_vcluster", getHeader(response->headers(), "rsp-virtual-cluster-name"));

    // verify response status
    EXPECT_EQ("200", getHeader(response->headers(), "rsp-status"));

    // verify protocol
    EX