reshSecondsBase)
      XCTAssertEqual(5678, config.dnsFailureRefreshSecondsMax)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addDNSFailureRefreshSeconds(base: 1234, max: 5678)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingH2ConnectionKeepaliveIdleIntervalMSAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual(234, config.h2ConnectionKeepaliveIdleIntervalMilliseconds)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addH2ConnectionKeepaliveIdleIntervalMilliseconds(234)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingH2ConnectionKeepaliveTimeoutSecondsAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual(234, config.h2ConnectionKeepaliveTimeoutSeconds)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addH2ConnectionKeepaliveTimeoutSeconds(234)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testSettingMaxConnectionsPerHostAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual(23, config.maxConnectionsPerHost)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .setMaxConnectionsPerHost(23)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingPlatformFiltersToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual(1, config.httpPlatformFilterFactories.count)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addPlatformFilter(TestFilter.init)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingStreamIdleTimeoutSecondsAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual(42, config.streamIdleTimeoutSeconds)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addStreamIdleTimeoutSeconds(42)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingPerTryIdleTimeoutSecondsAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual(21, config.perTryIdleTimeoutSeconds)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addPerTryIdleTimeoutSeconds(21)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingAppVersionAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual("v1.2.3", config.appVersion)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addAppVersion("v1.2.3")
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingAppIdAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual("com.envoymobile.ios", config.appId)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addAppId("com.envoymobile.ios")
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingNativeFiltersToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual(1, config.nativeFilterChain.count)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addNativeFilter(
        name: "envoy.filters.http.buffer",
        typedConfig: """
          {
            "@type": "type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer",
            "max_request_bytes": 5242880
          }
          """
      )
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingStringAccessorToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual("hello", config.stringAccessors["name"]?.getEnvoyString())
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addStringAccessor(name: "name", accessor: { "hello" })
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

#if ENVOY_MOBILE_XDS
  func testAddingRtdsConfigurationWhenRunningEnvoy() {
    let xdsBuilder = XdsBuilder(xdsServerAddress: "FAKE_SWIFT_ADDRESS", xdsServerPort: 0)
      .addRuntimeDiscoveryService(resourceName: "some_rtds_resource", timeoutInSeconds: 14325)
    let bootstrapDebugDescription = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .setXds(xdsBuilder)
      .bootstrapDebugDescription()
    XCTAssertTrue(bootstrapDebugDescription.contains("some_rtds_resource"))
    XCTAssertTrue(bootstrapDebugDescription.contains("initial_fetch_timeout { seconds: 14325 }"))
    XCTAssertTrue(bootstrapDebugDescription.contains("FAKE_SWIFT_ADDRESS"))
  }

  func testAddingCdsConfigurationWhenRunningEnvoy() {
    let xdsBuilder = XdsBuilder(xdsServerAddress: "FAKE_SWIFT_ADDRESS", xdsServerPort: 0)
      .addClusterDiscoveryService(cdsResourcesLocator: "FAKE_CDS_LOCATOR", timeoutInSeconds: 2543)
    let bootstrapDebugDescription = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .setXds(xdsBuilder)
      .bootstrapDebugDescription()
    XCTAssertTrue(bootstrapDebugDescription.contains("FAKE_CDS_LOCATOR"))
    XCTAssertTrue(bootstrapDebugDescription.contains("initial_fetch_timeout { seconds: 2543 }"))
    XCTAssertTrue(bootstrapDebugDescription.contains("FAKE_SWIFT_ADDRESS"))
  }

  func testAddingDefaultCdsConfigurationWhenRunningEnvoy() {
    let xdsBuilder = XdsBuilder(xdsServerAddress: "FAKE_SWIFT_ADDRESS", xdsServerPort: 0)
      .addClusterDiscoveryService()
    let bootstrapDebugDescription = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .setXds(xdsBuilder)
      .bootstrapDebugDescription()
    XCTAssertTrue(bootstrapDebugDescription.contains("cds_config {"))
    XCTAssertTrue(bootstrapDebugDescription.contains("initial_fetch_timeout { seconds: 5 }"))
  }

  func testAddingXdsSecurityConfigurationWhenRunningEnvoy() {
    let xdsBuilder = XdsBuilder(xdsServerAddress: "FAKE_SWIFT_ADDRESS", xdsServerPort: 0)
      .addInitialStreamHeader(header: "x-goog-api-key", value: "A1B2C3")
      .addInitialStreamHeader(header: "x-android-package", value: "com.google.myapp")
      .setSslRootCerts(rootCerts: "fake_ssl_root_certs")
      .addRuntimeDiscoveryService(resourceName: "some_rtds_resource", timeoutInSeconds: 14325)
    let bootstrapDebugDescription = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .setXds(xdsBuilder)
      .bootstrapDebugDescription()
    XCTAssertTrue(bootstrapDebugDescription.contains("x-goog-api-key"))
    XCTAssertTrue(bootstrapDebugDescription.contains("A1B2C3"))
    XCTAssertTrue(bootstrapDebugDescription.contains("x-android-package"))
    XCTAssertTrue(bootstrapDebugDescription.contains("com.google.myapp"))
    XCTAssertTrue(bootstrapDebugDescription.contains("fake_ssl_root_certs"))
  }
#endif

  func testXDSDefaultValues() {
    // rtds, ads, node_id, node_locality
    let bootstrapDebugDescription = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .bootstrapDebugDescription()
    XCTAssertFalse(bootstrapDebugDescription.contains("rtds_layer {"))
    XCTAssertFalse(bootstrapDebugDescription.contains("cds_config {"))
    XCTAssertFalse(bootstrapDebugDescription.contains("ads_config {"))
    XCTAssertTrue(bootstrapDebugDescription.contains(#"id: "envoy-mobile""#))
    XCTAssertFalse(bootstrapDebugDescription.contains("locality {"))
  }

  func testCustomNodeID() {
    let bootstrapDebugDescription = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .setNodeID("SWIFT_TEST_NODE_ID")
      .bootstrapDebugDescription()
    XCTAssertTrue(bootstrapDebugDescription.contains(#"id: "SWIFT_TEST_NODE_ID""#))
  }

  func testCustomNodeLocality() {
    let bootstrapDebugDescription = EngineBuilder()
      .setNodeLocality(region: "SWIFT_REGION", zone: "SWIFT_ZONE", subZone: "SWIFT_SUB")
      .bootstrapDebugDescription()
    XCTAssertTrue(bootstrapDebugDescription.contains(#"region: "SWIFT_REGION""#))
    XCTAssertTrue(bootstrapDebugDescription.contains(#"zone: "SWIFT_ZONE""#))
    XCTAssertTrue(bootstrapDebugDescription.contains(#"sub_zone: "SWIFT_SUB""#))
  }

  func testAddingKeyValueStoreToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual("bar", config.keyValueStores["name"]?.readValue(forKey: "foo"))
      expectation.fulfill()
    }

    let testStore: KeyValueStore = {
      class TestStore: KeyValueStore {
        private var dict: [String: String] = [:]

        func readValue(forKey key: String) -> String? {
          return dict[key]
        }

        func saveValue(_ value: String, toKey key: String) {
          dict[key] = value
        }

        func removeKey(_ key: String) {
          dict[key] = nil
        }
      }

      return TestStore()
    }()

    testStore.saveValue("bar", toKey: "foo")

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addKeyValueStore(name: "name", keyValueStore: testStore)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:apple.bzl", "envoy_mobile_swift_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_swift_test(
    name = "test",
    size = "large",
    srcs = [
        "EngineBuilderTests.swift",
        "GRPCRequestHeadersBuilderTests.swift",
        "GRPCStreamTests.swift",
        "HeadersBuilderTests.swift",
        "HeadersContainerTests.swift",
        "PulseClientImplTests.swift",
        "RequestHeadersBuilderTests.swift",
        "ResponseHeadersTests.swift",
        "RetryPolicyMapperTests.swift",
        "RetryPolicyTests.swift",
    ],
    flaky = True,  # TODO(jpsim): Fix timeouts when running these tests on CI
    tags = ["no-remote-exec"],  # TODO(jpsim): Re-enable remote exec
    visibility = ["//visibility:public"],
    deps = [
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)
import Envoy
import XCTest

final class RetryPolicyTests: XCTestCase {
  func testRetryPoliciesAreEqualWhenPropertiesAreEqual() {
    let policy1 = RetryPolicy(maxRetryCount: 123,
                              retryOn: [.connectFailure],
                              perRetryTimeoutMS: 8000)
    let policy2 = RetryPolicy(maxRetryCount: 123,
                              retryOn: [.connectFailure],
                              perRetryTimeoutMS: 8000)
    XCTAssertEqual(policy1, policy2)
  }

  func testPointersAreNotEqualWhenInstancesAreDifferent() {
    let policy1 = RetryPolicy(maxRetryCount: 123,
                              retryOn: [.connectFailure],
                              perRetryTimeoutMS: 8000)
    let policy2 = RetryPolicy(maxRetryCount: 123,
                              retryOn: [.connectFailure],
                              perRetryTimeoutMS: 8000)
    XCTAssert(policy1 !== policy2)
  }
}
import Envoy
import UIKit

private let kCellID = "cell-id"
private let kRequestAuthority = "api.lyft.com"
private let kRequestPath = "/ping"
private let kRequestScheme = "https"
private let kFilteredHeaders =
  ["server", "filter-demo", "async-filter-demo", "x-envoy-upstream-service-time"]

final class ViewController: UITableViewController {
  private var results = [Result<Response, RequestError>]()
  private var timer: Foundation.Timer?
  private var streamClient: StreamClient?
  private var pulseClient: PulseClient?

  override func viewDidLoad() {
    super.viewDidLoad()

    let engine = EngineBuilder()
      .addLogLevel(.debug)
      .addPlatformFilter(DemoFilter.init)
      .addPlatformFilter(BufferDemoFilter.init)
      .addPlatformFilter(AsyncDemoFilter.init)
      .enableDNSCache(true)
      // required by DNS cache
      .addKeyValueStore(name: "reserved.platform_store", keyValueStore: UserDefaults.standard)
      .enableInterfaceBinding(true)
      .enablePlatformCertificateValidation(true)
      .addNativeFilter(
        name: "envoy.filters.http.buffer",
        typedConfig: """
          {
            "@type": "type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer",
            "max_request_bytes": 5242880
          }
          """
      )
      .setOnEngineRunning { NSLog("Envoy async internal setup completed") }
      .addStringAccessor(name: "demo-accessor", accessor: { return "PlatformString" })
      .addKeyValueStore(name: "demo-kv-store", keyValueStore: UserDefaults.standard)
      .setEventTracker { NSLog("Envoy event emitted: \($0)") }
      .forceIPv6(true)
      .enableSwiftBootstrap(true)
      .build()
    self.streamClient = engine.streamClient()
    self.pulseClient = engine.pulseClient()

    NSLog("started Envoy, beginning requests...")
    self.startRequests()
  }

  deinit {
    self.timer?.invalidate()
  }

  // MARK: - Requests

  private func startRequests() {
    self.timer = .scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
      self?.performRequest()
      self?.recordStats()
    }
  }

  private func performRequest() {
    guard let streamClient = self.streamClient else {
      NSLog("failed to start request - Envoy is not running")
      return
    }

    NSLog("starting request to '\(kRequestPath)'")

    let headers = RequestHeadersBuilder(method: .get, scheme: kRequestScheme,
                                        authority: kRequestAuthority, path: kRequestPath)
      .build()

    streamClient
      .newStreamPrototype()
      .setOnResponseHeaders { [weak self] headers, _, _ in
        let statusCode = headers.httpStatus.map(String.init) ?? "nil"
        let message = "received headers with status \(statusCode)"

        let headerMessage = headers.caseSensitiveHeaders()
          .filter { kFilteredHeaders.contains($0.key) }
          .map { "\($0.key): \($0.value.joined(separator: ", "))" }
          .joined(separator: "\n")

        NSLog(message)
        if let filterDemoValue = headers.value(forName: "filter-demo")?.first {
          NSLog("filter-demo: \(filterDemoValue)")
        }
        if let asyncFilterDemoValue = headers.value(forName: "async-filter-demo")?.first {
          NSLog("async-filter-demo: \(asyncFilterDemoValue)")
        }

        let response = Response(message: message,
                                headerMessage: headerMessage)
        self?.add(result: .success(response))
      }
      .setOnError { [weak self] error, _ in
        let message: String
        if let attemptCount = error.attemptCount {
          message = "failed within Envoy library after \(attemptCount) attempts: \(error.message)"
        } else {
          message = "failed within Envoy library: \(error.message)"
        }

        NSLog(message)
        self?.add(result: .failure(RequestError(message: message)))
      }
      .start()
      .sendHeaders(headers, endStream: true)
  }

  private func add(result: Result<Response, RequestError>) {
    self.results.insert(result, at: 0)
    self.tableView.reloadData()
  }

  private func recordStats() {
    guard let pulseClient = self.pulseClient else {
      NSLog("failed to send stats - Envoy is not running")
      return
    }

    let counter = pulseClient.counter(elements: ["foo", "bar", "counter"])
    counter.increment()
    counter.increment(count: 5)
  }
  // MARK: - UITableView

  override func numberOfSections(in tableView: UITableView) -> Int {
    return 1
  }

  override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
    return self.results.count
  }

  override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath)
    -> UITableViewCell
  {
    let cell = tableView.dequeueReusableCell(withIdentifier: kCellID) ??
      UITableViewCell(style: .subtitle, reuseIdentifier: kCellID)

    let result = self.results[indexPath.row]
    switch result {
    case .success(let response):
      cell.textLabel?.text = response.message
      cell.detailTextLabel?.text = response.headerMessage

      cell.textLabel?.textColor = .black
      cell.detailTextLabel?.lineBreakMode = .byWordWrapping
      cell.detailTextLabel?.numberOfLines = 0
      cell.detailTextLabel?.textColor = .black
      cell.contentView.backgroundColor = .white
    case .failure(let error):
      cell.textLabel?.text = error.message
      cell.detailTextLabel?.text = nil

      cell.textLabel?.textColor = .white
      cell.detailTextLabel?.textColor = .white
      cell.contentView.backgroundColor = .red
    }

    return cell
  }
}
import Envoy
import Foundation

/// Example of a more complex HTTP filter that pauses processing on the response filter chain,
/// buffers until the response is complete, then resumes filter iteration while setting a new
/// header.
final class BufferDemoFilter: ResponseFilter {
  private var headers: ResponseHeaders!
  private var body: Data?

  func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool, streamIntel: StreamIntel)
    -> FilterHeadersStatus<ResponseHeaders>
  {
    self.headers = headers
    return .stopIteration
  }

  func onResponseData(_ data: Data, endStream: Bool, streamIntel: StreamIntel)
    -> FilterDataStatus<ResponseHeaders>
  {
    // Since we request buffering, each invocation will include all data buffered so far.
    self.body = data

    // If this is the end of the stream, resume processing of the (now fully-buffered) response.
    if endStream {
      let builder = self.headers.toResponseHeadersBuilder()
        .add(name: "buffer-filter-demo", value: "1")
      return .resumeIteration(headers: builder.build(), data: data)
    }
    return .stopIterationAndBuffer
  }

  func onResponseTrailers(
    _ trailers: ResponseTrailers,
    streamIntel: StreamIntel
  ) -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
    // Trailers imply end of stream; resume processing of the (now fully-buffered) response.
    let builder = self.headers.toResponseHeadersBuilder()
      .add(name: "buffer-filter-demo", value: "1")
    return .resumeIteration(headers: builder.build(), data: self.body, trailers: trailers)
  }

  func onError(_ error: EnvoyError, streamIntel: FinalStreamIntel) {}

  func onCancel(streamIntel: FinalStreamIntel) {}

  func onComplete(streamIntel: FinalStreamIntel) {}
}
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="13122.16" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="13104.12"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <viewLayoutGuide key="safeArea" id="6Tk-OE-BBY"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
</document>
For instructions on how to use this demo, please head over to our [docs](https://envoymobile.io/docs/envoy-mobile/latest/start/examples/hello_world.html).
import UIKit

@UIApplicationMain
final class AppDelegate: UIResponder, UIApplicationDelegate {
  var window: UIWindow?

  func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool
  {
    let window = UIWindow(frame: UIScreen.main.bounds)
    window.rootViewController = ViewController()
    window.makeKeyAndVisible()
    self.window = window

    NSLog("Finished launching!")
    return true
  }
}
load("@build_bazel_rules_apple//apple:ios.bzl", "ios_application")
load("@build_bazel_rules_swift//swift:swift.bzl", "swift_library")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("//bazel:config.bzl", "MINIMUM_IOS_VERSION")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

swift_library(
    name = "appmain",
    srcs = glob(["*.swift"]),
    deps = ["//library/swift:ios_lib"],
)

ios_application(
    name = "app",
    bundle_id = "io.envoyproxy.envoymobile.helloworld",
    families = ["iphone"],
    infoplists = ["Info.plist"],
    minimum_os_version = MINIMUM_IOS_VERSION,
    provisioning_profile = select({
        "@envoy//bazel:ios_arm64": "//examples:ios_provisioning_profile",
        "//conditions:default": None,
    }),
    visibility = ["//visibility:public"],
    deps = ["appmain"],
)
import Envoy
import Foundation

/// Example of a simple HTTP filter that adds a response header.
struct DemoFilter: ResponseFilter {
  func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool, streamIntel: StreamIntel)
    -> FilterHeadersStatus<ResponseHeaders>
  {
    let builder = headers.toResponseHeadersBuilder()
    builder.add(name: "filter-demo", value: "1")
    return .continue(headers: builder.build())
  }

  func setResponseFilterCallbacks(_ callbacks: ResponseFilterCallbacks, streamIntel: StreamIntel) {}

  func onResponseData(_ body: Data, endStream: Bool, streamIntel: StreamIntel)
    -> FilterDataStatus<ResponseHeaders>
  {
    return .continue(data: body)
  }

  func onResponseTrailers(_ trailers: ResponseTrailers, streamIntel: StreamIntel)
    -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers>
  {
    return .continue(trailers: trailers)
  }

  func onError(_ error: EnvoyError, streamIntel: FinalStreamIntel) {}

  func onCancel(streamIntel: FinalStreamIntel) {}

  func onComplete(streamIntel: FinalStreamIntel) {}
}
import Envoy
import Foundation

/// Example of a more complex HTTP filter that pauses processing on the response filter chain,
/// buffers until the response is complete, then asynchronously triggers filter chain resumption
/// while setting a new header. Also demonstrates safety of re-entrancy of async callbacks.
final class AsyncDemoFilter: AsyncResponseFilter {
  private var callbacks: ResponseFilterCallbacks!

  func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool, streamIntel: StreamIntel)
    -> FilterHeadersStatus<ResponseHeaders>
  {
    if endStream {
      DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { [weak self] in
        self?.callbacks.resumeResponse()
      }
    }
    return .stopIteration
  }

  func onResponseData(_ body: Data, endStream: Bool, streamIntel: StreamIntel)
    -> FilterDataStatus<ResponseHeaders>
  {
    if endStream {
      DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { [weak self] in
        self?.callbacks.resumeResponse()
      }
    }
    return .stopIterationAndBuffer
  }

  func onResponseTrailers(
    _ trailers: ResponseTrailers,
    streamIntel: StreamIntel
  ) -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { [weak self] in
      self?.callbacks.resumeResponse()
    }
    return .stopIteration
  }

  func setResponseFilterCallbacks(_ callbacks: ResponseFilterCallbacks) {
    self.callbacks = callbacks
  }

  func onResumeResponse(
    headers: ResponseHeaders?,
    data: Data?,
    trailers: ResponseTrailers?,
    endStream: Bool,
    streamIntel: StreamIntel
  ) -> FilterResumeStatus<ResponseHeaders, ResponseTrailers> {
    guard let headers = headers else {
      // Iteration was stopped on headers, so headers must be present.
      fatalError("Filter behavior violation!")
    }
    let builder = headers.toResponseHeadersBuilder()
      .add(name: "async-filter-demo", value: "1")
    return .resumeIteration(headers: builder.build(), data: data, trailers: trailers)
  }

  func onError(_ error: EnvoyError, streamIntel: FinalStreamIntel) {}

  func onCancel(streamIntel: FinalStreamIntel) {}

  func onComplete(streamIntel: FinalStreamIntel) {}
}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>0.1</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>0.1</string>
	<key>ITSAppUsesNonExemptEncryption</key>
	<false/>
	<key>NSAppTransportSecurity</key>
	<dict>
		<key>NSExceptionDomains</key>
		<dict>
			<key>localhost</key>
			<dict>
				<key>NSExceptionAllowsInsecureHTTPLoads</key>
				<true/>
			</dict>
		</dict>
	</dict>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>armv7</string>
	</array>
	<key>UIStatusBarStyle</key>
	<string>UIStatusBarStyleLightContent</string>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
</dict>
</plist>
/// Represents a response from the server.
struct Response {
  let message: String
  let headerMessage: String
}

/// Error that was encountered when executing a request.
struct RequestError: Error {
  let message: String
}
import Envoy
import UIKit

private let kCellID = "cell-id"
private let kRequestAuthority = "api.lyft.com"
private let kRequestPath = "/ping"
private let kRequestScheme = "http"
private let kFilteredHeaders =
  ["server", "filter-demo", "x-envoy-upstream-service-time"]

final class ViewController: UITableViewController {
  private var results = [Result<Response, RequestError>]()
  private var timer: Foundation.Timer?
  private var streamClient: StreamClient?
  private var pulseClient: PulseClient?

  override func viewDidLoad() {
    super.viewDidLoad()

    let engine = EngineBuilder()
      .addLogLevel(.debug)
      .addPlatformFilter(DemoFilter.init)
      .addNativeFilter(
        name: "envoy.filters.http.buffer",
        typedConfig: """
            {\
            "@type":"type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer",\
            "max_request_bytes":5242880\
            }
            """
      )
      .setOnEngineRunning { NSLog("Envoy async internal setup completed") }
      .addStringAccessor(name: "demo-accessor", accessor: { return "PlatformString" })
      .setEventTracker { NSLog("Envoy event emitted: \($0)") }
      .build()
    self.streamClient = engine.streamClient()
    self.pulseClient = engine.pulseClient()

    NSLog("started Envoy, beginning requests...")
    self.startRequests()
  }

  deinit {
    self.timer?.invalidate()
  }

  // MARK: - Requests

  private func startRequests() {
    self.timer = .scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
      self?.performRequest()
      self?.recordStats()
    }
  }

  private func performRequest() {
    guard let streamClient = self.streamClient else {
      NSLog("failed to start request - Envoy is not running")
      return
    }

    NSLog("starting request to '\(kRequestPath)'")

    let headers = RequestHeadersBuilder(method: .get, scheme: kRequestScheme,
                                        authority: kRequestAuthority, path: kRequestPath)
      .build()

    streamClient
      .newStreamPrototype()
      .setOnResponseHeaders { [weak self] headers, _, _ in
        let statusCode = headers.httpStatus.map(String.init) ?? "nil"
        let message = "received headers with status \(statusCode)"

        let headerMessage = headers.caseSensitiveHeaders()
          .filter { kFilteredHeaders.contains($0.key) }
          .map { "\($0.key): \($0.value.joined(separator: ", "))" }
          .joined(separator: "\n")

        NSLog(message)
        if let filterDemoValue = headers.value(forName: "filter-demo")?.first {
          NSLog("filter-demo: \(filterDemoValue)")
        }

        let response = Response(message: message,
                                headerMessage: headerMessage)
        self?.add(result: .success(response))
      }
      .setOnError { [weak self] error, _ in
        let message: String
        if let attemptCount = error.attemptCount {
          message = "failed within Envoy library after \(attemptCount) attempts: \(error.message)"
        } else {
          message = "failed within Envoy library: \(error.message)"
        }

        NSLog(message)
        self?.add(result: .failure(RequestError(message: message)))
      }
      .start()
      .sendHeaders(headers, endStream: true)
  }

  private func add(result: Result<Response, RequestError>) {
    self.results.insert(result, at: 0)
    self.tableView.reloadData()
  }

  private func recordStats() {
    guard let pulseClient = self.pulseClient else {
      NSLog("failed to send stats - Envoy is not running")
      return
    }

    let counter = pulseClient.counter(elements: ["foo", "bar", "counter"])
    counter.increment()
    counter.increment(count: 5)
  }
  // MARK: - UITableView

  override func numberOfSections(in tableView: UITableView) -> Int {
    return 1
  }

  override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
    return self.results.count
  }

  override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath)
    -> UITableViewCell
  {
    let cell = tableView.dequeueReusableCell(withIdentifier: kCellID) ??
      UITableViewCell(style: .subtitle, reuseIdentifier: kCellID)

    let result = self.results[indexPath.row]
    switch result {
    case .success(let response):
      cell.textLabel?.text = response.message
      cell.detailTextLabel?.text = response.headerMessage

      cell.textLabel?.textColor = .black
      cell.detailTextLabel?.lineBreakMode = .byWordWrapping
      cell.detailTextLabel?.numberOfLines = 0
      cell.detailTextLabel?.textColor = .black
      cell.contentView.backgroundColor = .white
    case .failure(let error):
      cell.textLabel?.text = error.message
      cell.detailTextLabel?.text = nil

      cell.textLabel?.textColor = .white
      cell.detailTextLabel?.textColor = .white
      cell.contentView.backgroundColor = .red
    }

    return cell
  }
}
import Envoy
import Foundation

/// Example of a more complex HTTP filter that pauses processing on the response filter chain,
/// buffers until the response is complete, then resumes filter iteration while setting a new
/// header.
final class BufferDemoFilter: ResponseFilter {
  private var headers: ResponseHeaders!
  private var body: Data?

  func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool, streamIntel: StreamIntel)
    -> FilterHeadersStatus<ResponseHeaders>
  {
    self.headers = headers
    return .stopIteration
  }

  func onResponseData(_ data: Data, endStream: Bool, streamIntel: StreamIntel)
    -> FilterDataStatus<ResponseHeaders>
  {
    // Since we request buffering, each invocation will include all data buffered so far.
    self.body = data

    // If this is the end of the stream, resume processing of the (now fully-buffered) response.
    if endStream {
      let builder = self.headers.toResponseHeadersBuilder()
        .add(name: "buffer-filter-demo", value: "1")
      return .resumeIteration(headers: builder.build(), data: data)
    }
    return .stopIterationAndBuffer
  }

  func onResponseTrailers(
    _ trailers: ResponseTrailers,
    streamIntel: StreamIntel
  ) -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
    // Trailers imply end of stream; resume processing of the (now fully-buffered) response.
    let builder = self.headers.toResponseHeadersBuilder()
      .add(name: "buffer-filter-demo", value: "1")
    return .resumeIteration(headers: builder.build(), data: self.body, trailers: trailers)
  }

  func onError(_ error: EnvoyError, streamIntel: FinalStreamIntel) {}

  func onCancel(streamIntel: FinalStreamIntel) {}

  func onComplete(streamIntel: FinalStreamIntel) {}
}
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="13122.16" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="13104.12"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <viewLayoutGuide key="safeArea" id="6Tk-OE-BBY"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
</document>
For instructions on how to use this demo, please head over to our [docs](https://envoymobile.io/docs/envoy-mobile/latest/start/examples/hello_world.html).
import UIKit

@UIApplicationMain
final class AppDelegate: UIResponder, UIApplicationDelegate {
  var window: UIWindow?

  func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool
  {
    let window = UIWindow(frame: UIScreen.main.bounds)
    window.rootViewController = ViewController()
    window.makeKeyAndVisible()
    self.window = window

    NSLog("Finished launching!")
    return true
  }
}
load("@build_bazel_rules_apple//apple:ios.bzl", "ios_application")
load("@build_bazel_rules_swift//swift:swift.bzl", "swift_library")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("//bazel:config.bzl", "MINIMUM_IOS_VERSION")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

swift_library(
    name = "appmain",
    srcs = glob(["*.swift"]),
    deps = ["//library/swift:ios_lib"],
)

ios_application(
    name = "app",
    bundle_id = "io.envoyproxy.envoymobile.helloworld",
    families = ["iphone"],
    infoplists = ["Info.plist"],
    minimum_os_version = MINIMUM_IOS_VERSION,
    provisioning_profile = select({
        "@envoy//bazel:ios_arm64": "//examples:ios_provisioning_profile",
        "//conditions:default": None,
    }),
    visibility = ["//visibility:public"],
    deps = ["appmain"],
)
import Envoy
import Foundation

/// Example of a simple HTTP filter that adds a response header.
struct DemoFilter: ResponseFilter {
  func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool, streamIntel: StreamIntel)
    -> FilterHeadersStatus<ResponseHeaders>
  {
    let builder = headers.toResponseHeadersBuilder()
    builder.add(name: "filter-demo", value: "1")
    return .continue(headers: builder.build())
  }

  func setResponseFilterCallbacks(_ callbacks: ResponseFilterCallbacks, streamIntel: StreamIntel) {}

  func onResponseData(_ body: Data, endStream: Bool, streamIntel: StreamIntel)
    -> FilterDataStatus<ResponseHeaders>
  {
    return .continue(data: body)
  }

  func onResponseTrailers(_ trailers: ResponseTrailers, streamIntel: StreamIntel)
    -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers>
  {
    return .continue(trailers: trailers)
  }

  func onError(_ error: EnvoyError, streamIntel: FinalStreamIntel) {}

  func onCancel(streamIntel: FinalStreamIntel) {}

  func onComplete(streamIntel: FinalStreamIntel) {}
}
import Envoy
import Foundation

/// Example of a more complex HTTP filter that pauses processing on the response filter chain,
/// buffers until the response is complete, then asynchronously triggers filter chain resumption
/// while setting a new header. Also demonstrates safety of re-entrancy of async callbacks.
final class AsyncDemoFilter: AsyncResponseFilter {
  private var callbacks: ResponseFilterCallbacks!

  func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool, streamIntel: StreamIntel)
    -> FilterHeadersStatus<ResponseHeaders>
  {
    if endStream {
      DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { [weak self] in
        self?.callbacks.resumeResponse()
      }
    }
    return .stopIteration
  }

  func onResponseData(_ body: Data, endStream: Bool, streamIntel: StreamIntel)
    -> FilterDataStatus<ResponseHeaders>
  {
    if endStream {
      DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { [weak self] in
        self?.callbacks.resumeResponse()
      }
    }
    return .stopIterationAndBuffer
  }

  func onResponseTrailers(
    _ trailers: ResponseTrailers,
    streamIntel: StreamIntel
  ) -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { [weak self] in
      self?.callbacks.resumeResponse()
    }
    return .stopIteration
  }

  func setResponseFilterCallbacks(_ callbacks: ResponseFilterCallbacks) {
    self.callbacks = callbacks
  }

  func onResumeResponse(
    headers: ResponseHeaders?,
    data: Data?,
    trailers: ResponseTrailers?,
    endStream: Bool,
    streamIntel: StreamIntel
  ) -> FilterResumeStatus<ResponseHeaders, ResponseTrailers> {
    guard let headers = headers else {
      // Iteration was stopped on headers, so headers must be present.
      fatalError("Filter behavior violation!")
    }
    let builder = headers.toResponseHeadersBuilder()
      .add(name: "async-filter-demo", value: "1")
    return .resumeIteration(headers: builder.build(), data: data, trailers: trailers)
  }

  func onError(_ error: EnvoyError, streamIntel: FinalStreamIntel) {}

  func onCancel(streamIntel: FinalStreamIntel) {}

  func onComplete(streamIntel: FinalStreamIntel) {}
}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>0.1</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>0.1</string>
	<key>ITSAppUsesNonExemptEncryption</key>
	<false/>
	<key>NSAppTransportSecurity</key>
	<dict>
		<key>NSExceptionDomains</key>
		<dict>
			<key>localhost</key>
			<dict>
				<key>NSExceptionAllowsInsecureHTTPLoads</key>
				<true/>
			</dict>
		</dict>
	</dict>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>armv7</string>
	</array>
	<key>UIStatusBarStyle</key>
	<string>UIStatusBarStyleLightContent</string>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
</dict>
</plist>
/// Represents a response from the server.
struct Response {
  let message: String
  let headerMessage: String
}

/// Error that was encountered when executing a request.
struct RequestError: Error {
  let message: String
}
@testable import Envoy
import XCTest

final class TagsBuilderTests: XCTestCase {
  func testAddsTagToTags() {
    let tags = TagsBuilder().add(name: "testKey", value: "testValue").build()
    XCTAssertEqual(tags.allTags(), ["testKey": "testValue"])
  }

  func testSetsTagToTags() {
    let tags = TagsBuilder()
              .add(name: "testKey", value: "testValue1")
              .set(name: "testKey", value: "testValue2")
              .build()
    XCTAssertEqual(tags.allTags(), ["testKey": "testValue2"])
  }

  func testRemovesTagFromTags() {
    let tags = TagsBuilder()
              .add(name: "testKey1", value: "testValue1")
              .add(name: "testKey2", value: "testValue2")
              .remove(name: "testKey1")
              .build()
    XCTAssertEqual(tags.allTags(), ["testKey2": "testValue2"])
  }

  func testPutAllTagToTags() {
    let tagsMap = ["testKey1": "testValue1", "testKey2": "testValue2"]
    let tags = TagsBuilder()
              .putAll(tags: tagsMap)
              .build()
    XCTAssertEqual(tags.allTags(), ["testKey1": "testValue1", "testKey2": "testValue2"])
  }
}
@testable import Envoy
@testable import EnvoyEngine
import Foundation
import XCTest

final class CounterTests: XCTestCase {
  override func tearDown() {
    super.tearDown()
    MockEnvoyEngine.onRecordCounter = nil
  }

  func testConvenientMethodDelegatesToTheMainMethod() {
    class MockCounterImpl: Counter {
      var count: Int?
      var tags: Tags
      func increment(count: Int) {
        self.count = count
      }
      func increment(tags: Tags, count: Int) {
        self.tags = tags
        self.count = count
      }
      init(){
        self.count = -1
        self.tags = TagsBuilder().build()
      }
    }

    let counter = MockCounterImpl()
    counter.increment()
    XCTAssertEqual(1, counter.count)

    let tags = TagsBuilder().add(name: "testKey", value: "testValue").build()
    counter.increment(tags: tags, count: 1)
    XCTAssertEqual(1, counter.count)
    XCTAssertEqual(tags, counter.tags)
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:apple.bzl", "envoy_mobile_swift_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_swift_test(
    name = "test",
    srcs = [
        "CounterImplTests.swift",
        "ElementTests.swift",
        "TagsBuilderTests.swift",
    ],
    flaky = True,  # TODO(jpsim): Fix timeouts when running these tests on CI
    tags = ["no-remote-exec"],  # TODO(jpsim): Re-enable remote exec
    visibility = ["//visibility:public"],
    deps = [
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)
import Envoy
import XCTest

final class ElementTests: XCTestCase {
    func testElementNotEqualToObjectOfUnrelatedType() {
        let element = Element("foo")
        XCTAssertFalse(element.isEqual("bar"))
    }

    func testElementsAreEqualIfStringValuesAreEqual() {
      XCTAssertTrue(Element("foo").isEqual(Element("foo")))
      XCTAssertEqual(Element("foo"), Element("foo"))

      XCTAssertFalse(Element("foo").isEqual(Element("bar")))
      XCTAssertNotEqual(Element("foo"), Element("bar"))
    }
}
#include <string>
#include <vector>

#include "envoy/extensions/clusters/dynamic_forward_proxy/v3/cluster.pb.h"

#include "test/test_common/utility.h"

#include "absl/strings/str_cat.h"
#include "absl/strings/str_replace.h"
#include "absl/synchronization/notification.h"
#include "gtest/gtest.h"
#include "library/cc/engine_builder.h"
#include "library/cc/log_level.h"
#include "library/common/api/external.h"
#include "library/common/data/utility.h"

#if defined(__APPLE__)
#include "source/extensions/network/dns_resolver/apple/apple_dns_impl.h"
#endif

namespace Envoy {
namespace {

using namespace Platform;

using envoy::config::bootstrap::v3::Bootstrap;
using DfpClusterConfig = ::envoy::extensions::clusters::dynamic_forward_proxy::v3::ClusterConfig;
using testing::HasSubstr;
using testing::IsEmpty;
using testing::Not;
using testing::SizeIs;

DfpClusterConfig getDfpClusterConfig(const Bootstrap& bootstrap) {
  DfpClusterConfig cluster_config;
  const auto& clusters = bootstrap.static_resources().clusters();
  for (const auto& cluster : clusters) {
    if (cluster.name() == "base") {
      MessageUtil::unpackTo(cluster.cluster_type().typed_config(), cluster_config);
    }
  }
  return cluster_config;
}

TEST(TestConfig, ConfigIsApplied) {
  EngineBuilder engine_builder;
  engine_builder
#ifdef ENVOY_ENABLE_QUIC
      .setHttp3ConnectionOptions("5RTO")
      .setHttp3ClientConnectionOptions("MPQC")
      .addQuicHint("www.abc.com", 443)
      .addQuicHint("www.def.com", 443)
      .addQuicCanonicalSuffix(".opq.com")
      .addQuicCanonicalSuffix(".xyz.com")
#endif
      .addConnectTimeoutSeconds(123)
      .addDnsRefreshSeconds(456)
      .addDnsMinRefreshSeconds(567)
      .addDnsFailureRefreshSeconds(789, 987)
      .addDnsQueryTimeoutSeconds(321)
      .addH2ConnectionKeepaliveIdleIntervalMilliseconds(222)
      .addH2ConnectionKeepaliveTimeoutSeconds(333)
      .setAppVersion("1.2.3")
      .setAppId("1234-1234-1234")
      .setRuntimeGuard("test_feature_false", true)
      .enableDnsCache(true, /* save_interval_seconds */ 101)
      .addDnsPreresolveHostnames({"lyft.com", "google.com"})
      .setForceAlwaysUsev6(true)
      .setDeviceOs("probably-ubuntu-on-CI");

  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  const std::string config_str = bootstrap->ShortDebugString();

  std::vector<std::string> must_contain = {
      "connect_timeout { seconds: 123 }",
      "dns_refresh_rate { seconds: 456 }",
      "dns_min_refresh_rate { seconds: 567 }",
      "dns_query_timeout { seconds: 321 }",
      "dns_failure_refresh_rate { base_interval { seconds: 789 } max_interval { seconds: 987 } }",
      "connection_idle_interval { nanos: 222000000 }",
      "connection_keepalive { timeout { seconds: 333 }",
#ifdef ENVOY_ENABLE_QUIC
      "connection_options: \"5RTO\"",
      "client_connection_options: \"MPQC\"",
      "hostname: \"www.abc.com\"",
      "hostname: \"www.def.com\"",
      "canonical_suffixes: \".opq.com\"",
      "canonical_suffixes: \".xyz.com\"",
#endif
      "key: \"dns_persistent_cache\" save_interval { seconds: 101 }",
      "key: \"always_use_v6\" value { bool_value: true }",
      "key: \"test_feature_false\" value { bool_value: true }",
      "key: \"device_os\" value { string_value: \"probably-ubuntu-on-CI\" } }",
      "key: \"app_version\" value { string_value: \"1.2.3\" } }",
      "key: \"app_id\" value { string_value: \"1234-1234-1234\" } }",
      "validation_context { trusted_ca {",
  };

  for (const auto& string : must_contain) {
    EXPECT_THAT(config_str, HasSubstr(string)) << "'" << string << "' not found in " << config_str;
  }
}

TEST(TestConfig, MultiFlag) {
  EngineBuilder engine_builder;
  engine_builder.setRuntimeGuard("test_feature_false", true)
      .setRuntimeGuard("test_feature_true", false);

  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  const std::string bootstrap_str = bootstrap->ShortDebugString();
  EXPECT_THAT(bootstrap_str, HasSubstr("\"test_feature_false\" value { bool_value: true }"));
  EXPECT_THAT(bootstrap_str, HasSubstr("\"test_feature_true\" value { bool_value: false }"));
}

TEST(TestConfig, ConfigIsValid) {
  EngineBuilder engine_builder;
  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();

  // Test per-platform DNS fixes.
#if defined(__APPLE__)
  EXPECT_THAT(bootstrap->DebugString(), Not(HasSubstr("envoy.network.dns_resolver.getaddrinfo")));
  EXPECT_THAT(bootstrap->DebugString(), HasSubstr("envoy.network.dns_resolver.apple"));
#else
  EXPECT_THAT(bootstrap->DebugString(), HasSubstr("envoy.network.dns_resolver.getaddrinfo"));
  EXPECT_THAT(bootstrap->DebugString(), Not(HasSubstr("envoy.network.dns_resolver.apple")));
#endif
}

TEST(TestConfig, SetGzipDecompression) {
  EngineBuilder engine_builder;

  engine_builder.enableGzipDecompression(false);
  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->DebugString(), Not(HasSubstr("envoy.filters.http.decompressor")));

  engine_builder.enableGzipDecompression(true);
  bootstrap.reset();
  bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->DebugString(), HasSubstr("envoy.filters.http.decompressor"));
}

TEST(TestConfig, SetBrotliDecompression) {
  EngineBuilder engine_builder;

  engine_builder.enableBrotliDecompression(false);
  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->DebugString(), Not(HasSubstr("brotli.decompressor.v3.Brotli")));

  engine_builder.enableBrotliDecompression(true);
  bootstrap.reset();
  bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->DebugString(), HasSubstr("brotli.decompressor.v3.Brotli"));
}

TEST(TestConfig, SetSocketTag) {
  EngineBuilder engine_builder;

  engine_builder.enableSocketTagging(false);
  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->DebugString(), Not(HasSubstr("http.socket_tag.SocketTag")));

  engine_builder.enableSocketTagging(true);
  bootstrap.reset();
  bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->DebugString(), HasSubstr("http.socket_tag.SocketTag"));
}

#ifdef ENVOY_ENABLE_QUIC
TEST(TestConfig, SetAltSvcCache) {
  EngineBuilder engine_builder;
  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->DebugString(), HasSubstr("alternate_protocols_cache"));
}
#endif

TEST(TestConfig, StreamIdleTimeout) {
  EngineBuilder engine_builder;

  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(), HasSubstr("stream_idle_timeout { seconds: 15 }"));

  engine_builder.setStreamIdleTimeoutSeconds(42);
  bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(), HasSubstr("stream_idle_timeout { seconds: 42 }"));
}

TEST(TestConfig, PerTryIdleTimeout) {
  EngineBuilder engine_builder;

  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(), HasSubstr("per_try_idle_timeout { seconds: 15 }"));

  engine_builder.setPerTryIdleTimeoutSeconds(42);
  bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(), HasSubstr("per_try_idle_timeout { seconds: 42 }"));
}

TEST(TestConfig, EnableInterfaceBinding) {
  EngineBuilder engine_builder;

  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(), Not(HasSubstr("enable_interface_binding")));

  engine_builder.enableInterfaceBinding(true);
  bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(), HasSubstr("enable_interface_binding: true"));
}

TEST(TestConfig, EnableDrainPostDnsRefresh) {
  EngineBuilder engine_builder;

  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(), Not(HasSubstr("enable_drain_post_dns_refresh")));

  engine_builder.enableDrainPostDnsRefresh(true);
  bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(), HasSubstr("enable_drain_post_dns_refresh: true"));
}

TEST(TestConfig, EnforceTrustChainVerification) {
  EngineBuilder engine_builder;

  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(), Not(HasSubstr("trust_chain_verification")));

  engine_builder.enforceTrustChainVerification(false);
  bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(),
              HasSubstr("trust_chain_verification: ACCEPT_UNTRUSTED"));
}

TEST(TestConfig, AddMaxConnectionsPerHost) {
  EngineBuilder engine_builder;

  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(), HasSubstr("max_connections { value: 7 }"));

  engine_builder.addMaxConnectionsPerHost(16);
  bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(), HasSubstr("max_connections { value: 16 }"));
}

TEST(TestConfig, AddDnsPreresolveHostnames) {
  EngineBuilder engine_builder;
  engine_builder.addDnsPreresolveHostnames({"google.com", "lyft.com"});
  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();

  Protobuf::RepeatedPtrField<envoy::config::core::v3::SocketAddress>
      expected_dns_preresolve_hostnames;
  auto& host_addr1 = *expected_dns_preresolve_hostnames.Add();
  host_addr1.set_address("google.com");
  host_addr1.set_port_value(443);
  auto& host_addr2 = *expected_dns_preresolve_hostnames.Add();
  host_addr2.set_address("lyft.com");
  host_addr2.set_port_value(443);
  EXPECT_TRUE(TestUtility::repeatedPtrFieldEqual(
      getDfpClusterConfig(*bootstrap).dns_cache_config().preresolve_hostnames(),
      expected_dns_preresolve_hostnames));

  // Resetting the DNS preresolve hostnames with just "google.com" now.
  engine_builder.addDnsPreresolveHostnames({"google.com"});
  bootstrap = engine_builder.generateBootstrap();
  expected_dns_preresolve_hostnames.Clear();
  auto& host_addr3 = *expected_dns_preresolve_hostnames.Add();
  host_addr3.set_address("google.com");
  host_addr3.set_port_value(443);
  EXPECT_TRUE(TestUtility::repeatedPtrFieldEqual(
      getDfpClusterConfig(*bootstrap).dns_cache_config().preresolve_hostnames(),
      expected_dns_preresolve_hostnames));
}

TEST(TestConfig, DisableHttp3) {
  EngineBuilder engine_builder;

  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
#ifdef ENVOY_ENABLE_QUIC
  EXPECT_THAT(bootstrap->ShortDebugString(),
              HasSubstr("envoy.extensions.filters.http.alternate_protocols_cache.v3.FilterConfig"));
#endif
#ifndef ENVOY_ENABLE_QUIC
  EXPECT_THAT(
      bootstrap->ShortDebugString(),
      Not(HasSubstr("envoy.extensions.filters.http.alternate_protocols_cache.v3.FilterConfig")));
#endif

#ifdef ENVOY_ENABLE_QUIC
  engine_builder.enableHttp3(false);
  bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(
      bootstrap->ShortDebugString(),
      Not(HasSubstr("envoy.extensions.filters.http.alternate_protocols_cache.v3.FilterConfig")));
#endif
}

#ifdef ENVOY_MOBILE_XDS
TEST(TestConfig, XdsConfig) {
  EngineBuilder engine_builder;
  const std::string host = "fake-td.googleapis.com";
  const uint32_t port = 12345;
  const std::string authority = absl::StrCat(host, ":", port);

  XdsBuilder xds_builder(/*xds_server_address=*/host,
                         /*xds_server_port=*/port);
  engine_builder.setXds(std::move(xds_builder));
  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();

  auto& ads_config = bootstrap->dynamic_resources().ads_config();
  EXPECT_EQ(ads_config.api_type(), envoy::config::core::v3::ApiConfigSource::GRPC);
  EXPECT_EQ(ads_config.grpc_services(0).envoy_grpc().cluster_name(), "base");
  EXPECT_EQ(ads_config.grpc_services(0).envoy_grpc().authority(), authority);

  Protobuf::RepeatedPtrField<envoy::config::core::v3::SocketAddress>
      expected_dns_preresolve_hostnames;
  auto& host_addr1 = *expected_dns_preresolve_hostnames.Add();
  host_addr1.set_address(host);
  host_addr1.set_port_value(port);
  EXPECT_TRUE(TestUtility::repeatedPtrFieldEqual(
      getDfpClusterConfig(*bootstrap).dns_cache_config().preresolve_hostnames(),
      expected_dns_preresolve_hostnames));

  // With initial gRPC metadata.
  xds_builder = XdsBuilder(/*xds_server_address=*/host, /*xds_server_port=*/port);
  xds_builder.addInitialStreamHeader(/*header=*/"x-goog-api-key", /*value=*/"A1B2C3")
      .addInitialStreamHeader(/*header=*/"x-android-package",
                              /*value=*/"com.google.envoymobile.io.myapp");
  engine_builder.setXds(std::move(xds_builder));
  bootstrap = engine_builder.generateBootstrap();
  auto& ads_config_with_metadata = bootstrap->dynamic_resources().ads_config();
  EXPECT_EQ(ads_config_with_metadata.api_type(), envoy::config::core::v3::ApiConfigSource::GRPC);
  EXPECT_EQ(ads_config_with_metadata.grpc_services(0).envoy_grpc().cluster_name(), "base");
  EXPECT_EQ(ads_config_with_metadata.grpc_services(0).envoy_grpc().authority(), authority);
  EXPECT_EQ(ads_config_with_metadata.grpc_services(0).initial_metadata(0).key(), "x-goog-api-key");
  EXPECT_EQ(ads_config_with_metadata.grpc_services(0).initial_metadata(0).value(), "A1B2C3");
  EXPECT_EQ(ads_config_with_metadata.grpc_services(0).initial_metadata(1).key(),
            "x-android-package");
  EXPECT_EQ(ads_config_with_metadata.grpc_services(0).initial_metadata(1).value(),
            "com.google.envoymobile.io.myapp");
}

TEST(TestConfig, CopyConstructor) {
  EngineBuilder engine_builder;
  engine_builder.setRuntimeGuard("test_feature_false", true).enableGzipDecompression(false);

  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  std::string bootstrap_str = bootstrap->ShortDebugString();
  EXPECT_THAT(bootstrap_str, HasSubstr("\"test_feature_false\" value { bool_value: true }"));
  EXPECT_THAT(bootstrap_str, Not(HasSubstr("envoy.filters.http.decompressor")));

  EngineBuilder engine_builder_copy(engine_builder);
  engine_builder_copy.enableGzipDecompression(true);
  XdsBuilder xdsBuilder("FAKE_XDS_SERVER", 0);
  xdsBuilder.addClusterDiscoveryService();
  engine_builder_copy.setXds(xdsBuilder);
  bootstrap_str = engine_builder_copy.generateBootstrap()->ShortDebugString();
  EXPECT_THAT(bootstrap_str, HasSubstr("\"test_feature_false\" value { bool_value: true }"));
  EXPECT_THAT(bootstrap_str, HasSubstr("envoy.filters.http.decompressor"));
  EXPECT_THAT(bootstrap_str, HasSubstr("FAKE_XDS_SERVER"));

  EngineBuilder engine_builder_copy2(engine_builder_copy);
  bootstrap_str = engine_builder_copy2.generateBootstrap()->ShortDebugString();
  EXPECT_THAT(bootstrap_str, HasSubstr("\"test_feature_false\" value { bool_value: true }"));
  EXPECT_THAT(bootstrap_str, HasSubstr("envoy.filters.http.decompressor"));
  EXPECT_THAT(bootstrap_str, HasSubstr("FAKE_XDS_SERVER"));
}
#endif

TEST(TestConfig, EnablePlatformCertificatesValidation) {
  EngineBuilder engine_builder;
  engine_builder.enablePlatformCertificatesValidation(false);
  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(),
              Not(HasSubstr("envoy_mobile.cert_validator.platform_bridge_cert_validator")));
  EXPECT_THAT(bootstrap->ShortDebugString(), HasSubstr("trusted_ca"));

  engine_builder.enablePlatformCertificatesValidation(true);
  bootstrap = engine_builder.generateBootstrap();
  EXPECT_THAT(bootstrap->ShortDebugString(),
              HasSubstr("envoy_mobile.cert_validator.platform_bridge_cert_validator"));
  EXPECT_THAT(bootstrap->ShortDebugString(), Not(HasSubstr("trusted_ca")));
}

// Implementation of StringAccessor which tracks the number of times it was used.
class TestStringAccessor : public StringAccessor {
public:
  explicit TestStringAccessor(std::string data) : data_(data) {}
  ~TestStringAccessor() override = default;

  // StringAccessor
  const std::string& get() const override {
    ++count_;
    return data_;
  }

  int count() { return count_; }

private:
  std::string data_;
  mutable int count_ = 0;
};

TEST(TestConfig, AddNativeFilters) {
  EngineBuilder engine_builder;

  std::string filter_name1 = "envoy.filters.http.buffer1";
  std::string filter_name2 = "envoy.filters.http.buffer2";
  std::string filter_config =
      "{\"@type\":\"type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer\","
      "\"max_request_bytes\":5242880}";
  engine_builder.addNativeFilter(filter_name1, filter_config);
  engine_builder.addNativeFilter(filter_name2, filter_config);

  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  const std::string hcm_config =
      bootstrap->static_resources().listeners(0).api_listener().DebugString();
  EXPECT_THAT(hcm_config, HasSubstr(filter_name1));
  EXPECT_THAT(hcm_config, HasSubstr(filter_name2));
  EXPECT_THAT(hcm_config,
              HasSubstr("type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer"));
  EXPECT_THAT(hcm_config, HasSubstr(std::to_string(5242880)));
}

TEST(TestConfig, AddPlatformFilter) {
  EngineBuilder engine_builder;

  std::string filter_name = "test_platform_filter";

  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  std::string bootstrap_str = bootstrap->ShortDebugString();
  EXPECT_THAT(bootstrap_str, Not(HasSubstr("http.platform_bridge.PlatformBridge")));
  EXPECT_THAT(bootstrap_str, Not(HasSubstr("platform_filter_name: \"" + filter_name + "\"")));

  engine_builder.addPlatformFilter(filter_name);
  bootstrap = engine_builder.generateBootstrap();
  bootstrap_str = bootstrap->ShortDebugString();
  EXPECT_THAT(bootstrap_str, HasSubstr("http.platform_bridge.PlatformBridge"));
  EXPECT_THAT(bootstrap_str, HasSubstr("platform_filter_name: \"" + filter_name + "\""));
}

// TODO(RyanTheOptimist): This test seems to be flaky. #2641
TEST(TestConfig, DISABLED_StringAccessors) {
  std::string name("accessor_name");
  EngineBuilder engine_builder;
  std::string data_string = "envoy string";
  auto accessor = std::make_shared<TestStringAccessor>(data_string);
  engine_builder.addStringAccessor(name, accessor);
  Platform::EngineSharedPtr engine = engine_builder.build();
  auto c_accessor = static_cast<envoy_string_accessor*>(Envoy::Api::External::retrieveApi(name));
  ASSERT_TRUE(c_accessor != nullptr);
  EXPECT_EQ(0, accessor->count());
  envoy_data data = c_accessor->get_string(c_accessor->context);
  EXPECT_EQ(1, accessor->count());
  EXPECT_EQ(data_string, Data::Utility::copyToString(data));
  release_envoy_data(data);
}

TEST(TestConfig, SetNodeId) {
  EngineBuilder engine_builder;
  const std::string default_node_id = "envoy-mobile";
  EXPECT_EQ(engine_builder.generateBootstrap()->node().id(), default_node_id);

  const std::string test_node_id = "my_test_node";
  engine_builder.setNodeId(test_node_id);
  EXPECT_EQ(engine_builder.generateBootstrap()->node().id(), test_node_id);
}

TEST(TestConfig, SetNodeLocality) {
  EngineBuilder engine_builder;
  const std::string region = "us-west-1";
  const std::string zone = "some_zone";
  const std::string sub_zone = "some_sub_zone";
  engine_builder.setNodeLocality(region, zone, sub_zone);
  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_EQ(bootstrap->node().locality().region(), region);
  EXPECT_EQ(bootstrap->node().locality().zone(), zone);
  EXPECT_EQ(bootstrap->node().locality().sub_zone(), sub_zone);
}

TEST(TestConfig, SetNodeMetadata) {
  ProtobufWkt::Struct node_metadata;
  (*node_metadata.mutable_fields())["string_field"].set_string_value("some_string");
  (*node_metadata.mutable_fields())["bool_field"].set_bool_value(true);
  (*node_metadata.mutable_fields())["number_field"].set_number_value(3.14);
  EngineBuilder engine_builder;
  engine_builder.setNodeMetadata(node_metadata);
  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_EQ(bootstrap->node().metadata().fields().at("string_field").string_value(), "some_string");
  EXPECT_EQ(bootstrap->node().metadata().fields().at("bool_field").bool_value(), true);
  EXPECT_EQ(bootstrap->node().metadata().fields().at("number_field").number_value(), 3.14);
}

#ifdef ENVOY_MOBILE_XDS
TEST(TestConfig, AddCdsLayer) {
  XdsBuilder xds_builder(/*xds_server_address=*/"fake-xds-server", /*xds_server_port=*/12345);
  xds_builder.addClusterDiscoveryService();
  EngineBuilder engine_builder;
  engine_builder.setXds(std::move(xds_builder));

  std::unique_ptr<Bootstrap> bootstrap = engine_builder.generateBootstrap();
  EXPECT_EQ(bootstrap->dynamic_resources().cds_resources_locator(), "");
  EXPECT_EQ(bootstrap->dynamic_resources().cds_config().initial_fetch_timeout().seconds(),
            /*default_timeout=*/5);

  xds_builder = XdsBuilder(/*xds_server_address=*/"fake-xds-server", /*xds_server_port=*/12345);
  const std::string cds_resources_locator =
      "xdstp://traffic-director-global.xds.googleapis.com/envoy.config.cluster.v3.Cluster";
  const int timeout_seconds = 300;
  xds_builder.addClusterDiscoveryService(cds_resources_locator, timeout_seconds);
  engine_builder.setXds(std::move(xds_builder));
  bootstrap = engine_builder.generateBootstrap();
  EXPECT_EQ(bootstrap->dynamic_resources().cds_resources_locator(), cds_resources_locator);
  EXPECT_EQ(bootstrap->dynamic_resources().cds_config().initial_fetch_timeout().seconds(),
            timeout_seconds);
  EXPECT_EQ(bootstrap->dynamic_resources().cds_config().api_config_source().api_type(),
            envoy::config::core::v3::ApiConfigSource::AGGREGATED_GRPC);
  EXPECT_EQ(bootstrap->dynamic_resources().cds_config().api_config_source().transport_api_version(),
            envoy::config::core::v3::ApiVersion::V3);
}
#endif

} // namespace
} // namespace Envoy
#include <string>
#include <vector>

#include "examples/cc/fetch_client/fetch_client.h"
#include "gtest/gtest.h"

namespace Envoy {
namespace Platform {
namespace {

// This test verifies that the fetch client is able to successfully
// build and start the Envoy engine. It will panic if it is unable
// to do so.
TEST(FetchClientTest, Foo) {
  Envoy::Fetch client;
  client.fetch({"https://www.google.com/"});
}

} // namespace
} // namespace Platform
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_test", "envoy_mobile_package")
load("@envoy//bazel:envoy_select.bzl", "envoy_select_enable_yaml")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_test(
    name = "envoy_config_test",
    srcs = envoy_select_enable_yaml(
        ["envoy_config_test.cc"],
        "@envoy",
    ),
    repository = "@envoy",
    deps = [
        "//library/cc:engine_builder_lib",
        "//library/cc:envoy_engine_cc_lib_no_stamp",
        "@envoy_api//envoy/extensions/clusters/dynamic_forward_proxy/v3:pkg_cc_proto",
        "@envoy_build_config//:extension_registry",
        "@envoy_build_config//:test_extensions",
    ],
)

envoy_cc_test(
    name = "request_headers_builder_test",
    srcs = ["request_headers_builder_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/cc:envoy_engine_cc_lib_no_stamp",
        "@envoy_build_config//:extension_registry",
    ],
)

envoy_cc_test(
    name = "fetch_client_test",
    srcs = ["fetch_client_test.cc"],
    repository = "@envoy",
    deps = [
        "//examples/cc/fetch_client:fetch_client_lib",
        "@envoy_build_config//:extension_registry",
        "@envoy_build_config//:test_extensions",
    ],
)
#include <string>
#include <vector>

#include "gtest/gtest.h"
#include "library/cc/request_headers_builder.h"

namespace Envoy {
namespace Platform {
namespace {

TEST(RequestHeadersBuilderTest, ConstructsFromPieces) {
  RequestHeadersBuilder builder(RequestMethod::POST, "https", "www.example.com", "/");
  RequestHeaders headers = builder.build();
  EXPECT_EQ(RequestMethod::POST, headers.requestMethod());
  EXPECT_EQ("https", headers.scheme());
  EXPECT_EQ("www.example.com", headers.authority());
  EXPECT_EQ("/", headers.path());
}

TEST(RequestHeadersBuilderTest, ConstructsFromUrl) {
  RequestHeadersBuilder builder(RequestMethod::POST, "https://www.example.com/");
  RequestHeaders headers = builder.build();
  EXPECT_EQ(RequestMethod::POST, headers.requestMethod());
  EXPECT_EQ("https", headers.scheme());
  EXPECT_EQ("www.example.com", headers.authority());
  EXPECT_EQ("/", headers.path());
}

TEST(RequestHeadersBuilderTest, ConstructsFromInvalidUrl) {
  RequestHeadersBuilder builder(RequestMethod::POST, "root@example.com");
  RequestHeaders headers = builder.build();
  EXPECT_EQ(RequestMethod::POST, headers.requestMethod());
  EXPECT_EQ("", headers.scheme());
  EXPECT_EQ("", headers.authority());
  EXPECT_EQ("", headers.path());
}

TEST(RequestHeadersBuilderTest, AddHeader) {
  RequestHeadersBuilder builder(RequestMethod::POST, "root@example.com");
  builder.add("foo", "bar");
  RequestHeaders headers = builder.build();
  EXPECT_EQ(RequestMethod::POST, headers.requestMethod());
  ASSERT_TRUE(headers.contains("foo"));
  EXPECT_EQ("bar", headers["foo"][0]);
}

TEST(RequestHeadersBuilderTest, AddAndRemoveHeader) {
  RequestHeadersBuilder builder(RequestMethod::POST, "root@example.com");
  builder.add("foo", "bar");
  builder.remove("foo");
  RequestHeaders headers = builder.build();
  EXPECT_EQ(RequestMethod::POST, headers.requestMethod());
  ASSERT_FALSE(headers.contains("foo"));
}

} // namespace
} // namespace Platform
} // namespace Envoy
#include "test/test_common/utility.h"

#include "absl/synchronization/notification.h"
#include "gtest/gtest.h"
#include "library/cc/engine_builder.h"
#include "library/cc/envoy_error.h"
#include "library/cc/log_level.h"
#include "library/cc/request_headers_builder.h"
#include "library/cc/request_method.h"

namespace Envoy {
namespace {

struct Status {
  int status_code;
  bool end_stream;
};

void sendRequest(Platform::EngineSharedPtr engine, Status& status,
                 absl::Notification& stream_complete) {
  auto stream_prototype = engine->streamClient()->newStreamPrototype();
  auto stream = (*stream_prototype)
                    .setOnHeaders([&](Platform::ResponseHeadersSharedPtr headers, bool end_stream,
                                      envoy_stream_intel) {
                      status.status_code = headers->httpStatus();
                      status.end_stream = end_stream;
                    })
                    .setOnData([&](envoy_data, bool end_stream) { status.end_stream = end_stream; })
                    .setOnComplete([&](envoy_stream_intel, envoy_final_stream_intel) {
                      stream_complete.Notify();
                    })
                    .setOnError([&](Platform::EnvoyErrorSharedPtr, envoy_stream_intel,
                                    envoy_final_stream_intel) { stream_complete.Notify(); })
                    .setOnCancel([&](envoy_stream_intel, envoy_final_stream_intel) {
                      stream_complete.Notify();
                    })
                    .start();

  auto request_headers =
      Platform::RequestHeadersBuilder(Platform::RequestMethod::GET, "https", "example.com", "/")
          .build();
  stream->sendHeaders(std::make_shared<Platform::RequestHeaders>(request_headers), true);
}

void sendRequestEndToEnd() {
  Platform::EngineBuilder engine_builder;
  engine_builder.addNativeFilter(
      "test_remote_response",
      "{'@type': "
      "type.googleapis.com/"
      "envoymobile.extensions.filters.http.test_remote_response.TestRemoteResponse}");
  absl::Notification engine_running;
  Platform::EngineSharedPtr engine = engine_builder.addLogLevel(Platform::LogLevel::debug)
                                         .setOnEngineRunning([&]() { engine_running.Notify(); })
                                         .build();
  engine_running.WaitForNotification();

  Status status;
  absl::Notification stream_complete;
  sendRequest(engine, status, stream_complete);
  stream_complete.WaitForNotification();

  EXPECT_EQ(status.status_code, 200);
  EXPECT_EQ(status.end_stream, true);

  engine->terminate();
}

// this test attempts to elicit race conditions deriving from
// the semantics of ownership on StreamCallbacks
TEST(TestLifetimes, CallbacksStayAlive) {
  for (size_t i = 0; i < 10; i++) {
    sendRequestEndToEnd();
  }
}

} // namespace
} // namespace Envoy
#include "test/test_common/utility.h"

#include "absl/synchronization/notification.h"
#include "gtest/gtest.h"
#include "library/cc/engine_builder.h"
#include "library/cc/envoy_error.h"
#include "library/cc/request_headers_builder.h"
#include "library/cc/request_method.h"

namespace Envoy {
namespace {

struct Status {
  int status_code;
  bool end_stream;
};

TEST(SendHeadersTest, CanSendHeaders) {
  Platform::EngineBuilder engine_builder;
  engine_builder.addNativeFilter(
      "test_remote_response",
      "{'@type': "
      "type.googleapis.com/"
      "envoymobile.extensions.filters.http.test_remote_response.TestRemoteResponse}");
  absl::Notification engine_running;
  Platform::EngineSharedPtr engine = engine_builder.addLogLevel(Platform::LogLevel::debug)
                                         .setOnEngineRunning([&]() { engine_running.Notify(); })
                                         .build();
  engine_running.WaitForNotification();

  Status status;
  absl::Notification stream_complete;
  auto stream_prototype = engine->streamClient()->newStreamPrototype();
  Platform::StreamSharedPtr stream =
      (*stream_prototype)
          .setOnHeaders(
              [&](Platform::ResponseHeadersSharedPtr headers, bool end_stream, envoy_stream_intel) {
                status.status_code = headers->httpStatus();
                status.end_stream = end_stream;
              })
          .setOnData([&](envoy_data data, bool end_stream) {
            status.end_stream = end_stream;
            data.release(data.context);
          })
          .setOnComplete(
              [&](envoy_stream_intel, envoy_final_stream_intel) { stream_complete.Notify(); })
          .setOnError([&](Platform::EnvoyErrorSharedPtr, envoy_stream_intel,
                          envoy_final_stream_intel) { stream_complete.Notify(); })
          .setOnCancel(
              [&](envoy_stream_intel, envoy_final_stream_intel) { stream_complete.Notify(); })
          .start();

  Platform::RequestHeadersBuilder request_headers_builder(Platform::RequestMethod::GET, "https",
                                                          "example.com", "/");
  auto request_headers = request_headers_builder.build();
  auto request_headers_ptr =
      Platform::RequestHeadersSharedPtr(new Platform::RequestHeaders(request_headers));
  stream->sendHeaders(request_headers_ptr, true);
  stream_complete.WaitForNotification();

  EXPECT_EQ(status.status_code, 200);
  EXPECT_EQ(status.end_stream, true);

  engine->terminate();
}

} // namespace
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_test", "envoy_mobile_package")
load("@envoy//bazel:envoy_select.bzl", "envoy_select_enable_yaml")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_test(
    name = "send_headers_test",
    srcs = envoy_select_enable_yaml(
        ["send_headers_test.cc"],
        "@envoy",
    ),
    repository = "@envoy",
    deps = [
        "//library/cc:engine_builder_lib",
        "@envoy_build_config//:test_extensions",
    ],
)

envoy_cc_test(
    name = "lifetimes_test",
    srcs = envoy_select_enable_yaml(
        ["lifetimes_test.cc"],
        "@envoy",
    ),
    repository = "@envoy",
    deps = [
        "//library/cc:engine_builder_lib",
        "@envoy_build_config//:test_extensions",
    ],
)
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_binary", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_binary(
    name = "test_binary_size",
    srcs = ["test_binary_size.cc"],
    repository = "@envoy",
    stamped = True,
    deps = ["//library/common:engine_lib"],
)
#include "library/common/engine.h"

// NOLINT(namespace-envoy)

// This binary is used to perform stripped down binary size investigations of the Envoy codebase.
// Please refer to the development docs for more information:
// https://envoymobile.io/docs/envoy-mobile/latest/development/performance/binary_size.html
int main() { return reinterpret_cast<Envoy::Engine*>(0)->run(nullptr, nullptr); }
#import <XCTest/XCTest.h>

#import "library/objective-c/EnvoyKeyValueStoreBridgeImpl.h"
#import "library/objective-c/EnvoyBridgeUtility.h"

@interface TestKeyValueStore : NSObject <EnvoyKeyValueStore>

@property (nonatomic, copy) NSString * (^readValueBlock)(NSString *key);
@property (nonatomic, copy) void (^saveValueBlock)(NSString *key, NSString *value);
@property (nonatomic, copy) void (^removeValueBlock)(NSString *key);

@end

@implementation TestKeyValueStore

- (NSString *_Nullable)readValueForKey:(NSString *)key {
  return self.readValueBlock(key);
}

- (void)saveValue:(NSString *)value toKey:(NSString *)key {
  self.saveValueBlock(key, value);
}

- (void)removeKey:(NSString *)key {
  self.removeValueBlock(key);
}

@end

@interface EnvoyEngineImplTest : XCTestCase
@end

@implementation EnvoyEngineImplTest

- (void)testReadValue {
  NSString *expectedKey = @"key";
  NSString *expectedValue = @"value";

  TestKeyValueStore *store = [TestKeyValueStore new];
  __block NSString *actualKey = @"";
  store.readValueBlock = ^NSString *(NSString *key) {
    actualKey = key;
    return expectedValue;
  };

  NSData *keyData = [expectedKey dataUsingEncoding:NSUTF8StringEncoding];
  envoy_data data = ios_kv_store_read(toNativeData(keyData), CFBridgingRetain(store));
  NSData *valueData = to_ios_data(data);
  NSString *actualValue = [[NSString alloc] initWithBytes:valueData.bytes
                                                   length:valueData.length
                                                 encoding:NSUTF8StringEncoding];

  XCTAssertEqualObjects(expectedKey, actualKey);
  XCTAssertEqualObjects(expectedValue, actualValue);
}

- (void)testSaveValue {
  NSString *expectedKey = @"key";
  NSString *expectedValue = @"value";

  TestKeyValueStore *store = [TestKeyValueStore new];
  __block NSString *actualKey = @"";
  __block NSString *actualValue = @"";
  store.saveValueBlock = ^void(NSString *key, NSString *value) {
    actualKey = key;
    actualValue = value;
  };

  NSData *keyData = [expectedKey dataUsingEncoding:NSUTF8StringEncoding];
  NSData *valueData = [expectedValue dataUsingEncoding:NSUTF8StringEncoding];
  ios_kv_store_save(toNativeData(keyData), toNativeData(valueData), CFBridgingRetain(store));

  XCTAssertEqualObjects(expectedKey, actualKey);
  XCTAssertEqualObjects(expectedValue, actualValue);
}

- (void)testRemoveValue {
  NSString *expectedKey = @"key";

  TestKeyValueStore *store = [TestKeyValueStore new];
  __block NSString *actualKey = @"";
  store.removeValueBlock = ^void(NSString *key) {
    actualKey = key;
  };

  NSData *keyData = [expectedKey dataUsingEncoding:NSUTF8StringEncoding];
  ios_kv_store_remove(toNativeData(keyData), CFBridgingRetain(store));

  XCTAssertEqualObjects(expectedKey, actualKey);
}

@end
#import <XCTest/XCTest.h>

typedef NSDictionary<NSString *, NSArray<NSString *> *> EnvoyHeaders;
typedef NSDictionary<NSString *, NSString *> EnvoyTags;
typedef NSDictionary<NSString *, NSString *> EnvoyEvent;

#import "library/objective-c/EnvoyBridgeUtility.h"

@interface EnvoyBridgeUtilityTest : XCTestCase
@end

@implementation EnvoyBridgeUtilityTest

- (void)testToNativeData {
  NSString *testString = @"abc";
  NSData *testData = [testString dataUsingEncoding:NSUTF8StringEncoding];
  envoy_data nativeData = toNativeData(testData);
  XCTAssertEqual(memcmp(nativeData.bytes, testData.bytes, 3), 0);
}

- (void)testToManagedNativeStringUsingUTF8Chars {
  NSString *testString = @"台灣大哥大";
  envoy_data stringData = toManagedNativeString(testString);
  NSString *roundtripString = to_ios_string(stringData);
  XCTAssertEqual([testString compare:roundtripString options:0], NSOrderedSame);
}

@end
#pragma once

#import <Foundation/Foundation.h>

// Interface for starting and managing a test server. Calls into to test_server.cc
@interface EnvoyTestServer : NSObject

// Get the port of the upstream server.
+ (NSInteger)getEnvoyPort;
// Starts a server with HTTP1 and no TLS.
+ (void)startHttp1PlaintextServer;
// Shut down and clean up server.
+ (void)shutdownTestServer;
// Add response data to the upstream.
+ (void)setHeadersAndData:(NSString *)header_key
             header_value:(NSString *)header_value
            response_body:(NSString *)response_body;

@end
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:apple.bzl", "envoy_mobile_objc_test", "envoy_objc_library")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_objc_test(
    name = "envoy_bridge_utility_test",
    srcs = [
        "EnvoyBridgeUtilityTest.m",
    ],
    flaky = True,  # TODO(jpsim): Fix timeouts when running these tests on CI
    tags = ["no-remote-exec"],  # TODO(jpsim): Re-enable remote exec
    visibility = ["//visibility:public"],
    deps = [
        "//library/objective-c:envoy_objc_bridge_lib",
    ],
)

envoy_mobile_objc_test(
    name = "envoy_key_value_store_bridge_impl_test",
    srcs = [
        "EnvoyKeyValueStoreBridgeImplTest.m",
    ],
    flaky = True,  # TODO(jpsim): Fix timeouts when running these tests on CI
    tags = ["no-remote-exec"],  # TODO(jpsim): Re-enable remote exec
    visibility = ["//visibility:public"],
    deps = [
        "//library/objective-c:envoy_key_value_store_bridge_impl_lib",
        "//library/objective-c:envoy_objc_bridge_lib",
    ],
)

envoy_objc_library(
    name = "envoy_test_server",
    testonly = True,
    srcs = [
        "EnvoyTestServer.mm",
    ],
    hdrs = ["EnvoyTestServer.h"],
    module_name = "EnvoyTestServer",
    visibility = ["//visibility:public"],
    deps = [
        "//test/common/integration:test_server_interface_lib",
    ],
)
#import "test/objective-c/EnvoyTestServer.h"
#import "test/common/integration/test_server_interface.h"

@implementation EnvoyTestServer

+ (NSInteger)getEnvoyPort {
  return get_server_port();
}

+ (void)startHttp1PlaintextServer {
  start_server(Envoy::TestServerType::HTTP1_WITHOUT_TLS);
}

+ (void)shutdownTestServer {
  shutdown_server();
}

+ (void)setHeadersAndData:(NSString *)header_key
             header_value:(NSString *)header_value
            response_body:(NSString *)response_body {
  set_headers_and_data([header_key UTF8String], [header_value UTF8String],
                       [response_body UTF8String]);
}

@end
// This test is not meant to be run on the command line, because it depends on a GCP
// authentication token provided as a GitHub encrypted secret through a GitHub actions workflow.

#include <string>
#include <tuple>
#include <vector>

#include "envoy/config/bootstrap/v3/bootstrap.pb.h"
#include "envoy/config/cluster/v3/cluster.pb.h"
#include "envoy/config/core/v3/base.pb.h"
#include "envoy/config/core/v3/config_source.pb.h"

#include "source/common/protobuf/utility.h"
#include "source/extensions/clusters/strict_dns/strict_dns_cluster.h"
#include "source/extensions/health_checkers/http/health_checker_impl.h"
#include "source/extensions/load_balancing_policies/round_robin/config.h"

#include "test/common/grpc/grpc_client_integration.h"
#include "test/common/integration/base_client_integration_test.h"
#include "test/test_common/environment.h"

#include "absl/strings/substitute.h"
#include "absl/synchronization/notification.h"
#include "extension_registry.h"
#include "gtest/gtest.h"
#include "library/common/data/utility.h"
#include "library/common/types/c_types.h"
#include "tools/cpp/runfiles/runfiles.h"

namespace Envoy {
namespace {

using ::Envoy::Grpc::SotwOrDelta;
using ::Envoy::Network::Address::IpVersion;

// The One-Platform API endpoint for Traffic Director.
constexpr char TD_API_ENDPOINT[] = "trafficdirectorconsumermesh.googleapis.com";
// The project number of the project, found on the main page of the project in
// Google Cloud Console.
constexpr char PROJECT_ID[] = "33303528656";

// Tests that Envoy Mobile can connect to Traffic Director (an xDS management server offered by GCP)
// via a test GCP project, and can pull down xDS config for the given project.
class GcpTrafficDirectorIntegrationTest
    : public BaseClientIntegrationTest,
      public testing::TestWithParam<std::tuple<IpVersion, SotwOrDelta>> {
public:
  GcpTrafficDirectorIntegrationTest() : BaseClientIntegrationTest(ip_version()) {
    // TODO(https://github.com/envoyproxy/envoy/issues/27848): remove these force registrations
    // once the EngineBuilder APIs support conditional force registration.

    // Register the extensions required for Envoy Mobile.
    ExtensionRegistry::registerFactories();

    // Force register the cluster factories used by the test.
    Upstream::forceRegisterStrictDnsClusterFactory();
    Upstream::forceRegisterHttpHealthCheckerFactory();
    Extensions::LoadBalancingPolices::RoundRobin::forceRegisterFactory();

    std::string root_certs(TestEnvironment::readFileToStringForTest(
        TestEnvironment::runfilesPath("test/config/integration/certs/google_root_certs.pem")));

    // API key for the `bct-prod-td-consumer-mesh` GCP test project.
    const char* api_key = std::getenv("GCP_TEST_PROJECT_PROD_API_KEY");
    RELEASE_ASSERT(api_key != nullptr,
                   "GCP_TEST_PROJECT_PROD_API_KEY environment variable not set.");

    Platform::XdsBuilder xds_builder(/*xds_server_address=*/std::string(TD_API_ENDPOINT),
                                     /*xds_server_port=*/443);
    xds_builder.addInitialStreamHeader("x-goog-api-key", std::string(api_key))
        .setSslRootCerts(std::move(root_certs))
        .addClusterDiscoveryService();
    builder_.addLogLevel(Platform::LogLevel::trace)
        .setNodeId(absl::Substitute("projects/$0/networks/default/nodes/111222333444", PROJECT_ID))
        .setXds(std::move(xds_builder));

    // Other test knobs.
    skip_tag_extraction_rule_check_ = true;
    // Envoy Mobile does not use LDS.
    use_lds_ = false;
    // We don't need a fake xDS upstream since we are using Traffic Director.
    create_xds_upstream_ = false;
    sotw_or_delta_ = api_type();

    if (api_type() == SotwOrDelta::UnifiedSotw || api_type() == SotwOrDelta::UnifiedDelta) {
      config_helper_.addRuntimeOverride("envoy.reloadable_features.unified_mux", "true");
    }
  }

  void TearDown() override { BaseClientIntegrationTest::TearDown(); }

  IpVersion ip_version() const { return std::get<0>(GetParam()); }
  SotwOrDelta api_type() const { return std::get<1>(GetParam()); }
};

INSTANTIATE_TEST_SUITE_P(
    GrpcOptions, GcpTrafficDirectorIntegrationTest,
    testing::Combine(testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
                     testing::Values(SotwOrDelta::Sotw, SotwOrDelta::UnifiedSotw)));

TEST_P(GcpTrafficDirectorIntegrationTest, AdsDynamicClusters) {
  // Starts up Envoy and loads the bootstrap config, which will trigger fetching
  // of the dynamic cluster resources from Traffic Director.
  initialize();

  // Wait for the xDS cluster resources to be retrieved and loaded.
  //
  // There are 5 total active clusters after the Envoy engine has finished initialization.
  //
  // 1. There is one strict dns cluster retrieved from Traffic Director:
  //      backend-svc-do-not-delete
  // 2. There are two static clusters added by the EngineBuilder by default:
  //      base
  //      base_clear
  ASSERT_TRUE(waitForGaugeGe("cluster_manager.active_clusters", 3));

  // TODO(abeyad): Once we have a Envoy Mobile stats API, we can use it to check the
  // actual cluster names.
}

} // namespace
} // namespace Envoy

int main(int argc, char** argv) {
  Envoy::TestEnvironment::initializeOptions(argc, argv);
  std::string error;
  std::unique_ptr<bazel::tools::cpp::runfiles::Runfiles> runfiles(
      bazel::tools::cpp::runfiles::Runfiles::Create(argv[0], &error));
  RELEASE_ASSERT(runfiles != nullptr, error);
  Envoy::TestEnvironment::setRunfiles(runfiles.get());

  Envoy::Thread::MutexBasicLockable lock;
  Envoy::Logger::Context logging_context(spdlog::level::level_enum::trace,
                                         Envoy::Logger::Logger::DEFAULT_LOG_FORMAT, lock, false);
  Envoy::Event::Libevent::Global::initialize();

  testing::InitGoogleTest();
  return RUN_ALL_TESTS();
}
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_test_binary",
    "envoy_mobile_package",
    "envoy_select_envoy_mobile_xds",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

# This is a envoy_cc_test_binary instead of an envoy_cc_test because we don't want it to be run
# when `bazel test //test/...` is called.
envoy_cc_test_binary(
    name = "gcp_traffic_director_integration_test",
    srcs = envoy_select_envoy_mobile_xds(
        ["gcp_traffic_director_integration_test.cc"],
        "@envoy",
    ),
    data = [
        "@envoy//test/config/integration/certs",
    ],
    external_deps = [
        "abseil_strings",
    ],
    repository = "@envoy",
    deps = [
        "//library/common:envoy_lib_no_stamp",
        "//library/common/data:utility_lib",
        "//library/common/types:c_types_lib",
        "//test/common/integration:base_client_integration_test_lib",
        "@envoy//source/common/config:api_version_lib",
        "@envoy//source/common/protobuf:utility_lib_header",
        "@envoy//source/extensions/clusters/strict_dns:strict_dns_cluster_lib",
        "@envoy//source/extensions/health_checkers/http:health_checker_lib",
        "@envoy//source/extensions/load_balancing_policies/round_robin:config",
        "@envoy//test/common/grpc:grpc_client_integration_lib",
        "@envoy//test/integration:http_integration_lib",
        "@envoy//test/test_common:environment_lib",
        "@envoy//test/test_common:network_utility_lib",
        "@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/cluster/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
        "@envoy_build_config//:extension_registry",
        "@envoy_build_config//:test_extensions",
    ],
)
#!/bin/bash

set -euo pipefail

readonly bazelisk_version="1.15.0"

if [[ $OSTYPE == darwin* ]]; then
  readonly bazel_os="darwin"
else
  readonly bazel_os="linux"
fi

raw_arch="$(uname -m)"
readonly raw_arch

if [[ -n "${BAZELW_ARCH+x}" ]]; then
  readonly bazel_arch="${BAZELW_ARCH}"
elif [[ "$raw_arch" == "aarch64" || "$raw_arch" == "arm64" ]]; then
  readonly bazel_arch="arm64"
else
  readonly bazel_arch="amd64"
fi

bazel_platform="$bazel_os-$bazel_arch"
case "$bazel_platform" in
  darwin-arm64)
    readonly bazel_version_sha="dfc36f30c1d5f86d72c9870cdeb995ac894787887089fd9b61e64f27c8bc184c"
    ;;
  darwin-amd64)
    readonly bazel_version_sha="cf876f4303223e6b1867db6c30c55b5bc0208d7c8003042a9872b8ec112fd3c0"
    ;;
  linux-arm64)
    readonly bazel_version_sha="3862ab0857b776411906d0a65215509ca72f6d4923f01807e11299a8d419db80"
    ;;
  linux-amd64)
    readonly bazel_version_sha="19fd84262d5ef0cb958bcf01ad79b528566d8fef07ca56906c5c516630a0220b"
    ;;

  *)
    echo "Unsupported platform $OSTYPE $raw_arch" >&2
    exit 1
esac

readonly bazel_version_url="https://github.com/bazelbuild/bazelisk/releases/download/v$bazelisk_version/bazelisk-$bazel_platform"
script_root="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly bazelisk="$script_root/tmp/bazel/versions/bazelisk-$bazelisk_version-$bazel_platform"

if [[ ! -x "$bazelisk" ]]; then
  echo "Installing bazelisk..." >&2
  mkdir -p "$(dirname "$bazelisk")"

  download_bazelisk() {
    curl --fail -L --retry 5 --retry-connrefused --silent --progress-bar \
      --output "$bazelisk" "$bazel_version_url"
  }

  download_bazelisk || download_bazelisk
  if echo "$bazel_version_sha  $bazelisk" | shasum --check --status; then
    chmod +x "$bazelisk"
  else
    echo "Bazelisk sha mismatch" >&2
    rm -f "$bazelisk"
    exit 1
  fi
fi

exec "$bazelisk" "$@"
only_rules:
- array_init
- attributes
- block_based_kvo
- class_delegate_protocol
- closing_brace
- closure_end_indentation
- closure_parameter_position
- closure_spacing
- collection_alignment
- colon
- comma
- conditional_returns_on_newline
- contains_over_first_not_nil
- control_statement
- custom_rules
- cyclomatic_complexity
- deployment_target
- discarded_notification_center_observer
- discouraged_direct_init
- discouraged_object_literal
- duplicate_enum_cases
- duplicate_imports
- dynamic_inline
- empty_enum_arguments
- empty_parameters
- empty_parentheses_with_trailing_closure
- empty_string
- explicit_init
- fallthrough
- fatal_error_message
- file_header
- file_length
- first_where
- for_where
- force_unwrapping
- generic_type_name
- identical_operands
- implicit_getter
- inert_defer
- is_disjoint
- leading_whitespace
- legacy_cggeometry_functions
- legacy_constant
- legacy_constructor
- legacy_multiple
- legacy_nsgeometry_functions
- legacy_random
- line_length
- literal_expression_end_indentation
- lower_acl_than_parent
- mark
- modifier_order
- no_fallthrough_only
- nsobject_prefer_isequal
- operator_usage_whitespace
- operator_whitespace
- overridden_super_call
- prefixed_toplevel_constant
- private_outlet
- private_over_fileprivate
- private_unit_test
- prohibited_super_call
- protocol_property_accessors_order
- reduce_boolean
- redundant_discardable_let
- redundant_nil_coalescing
- redundant_objc_attribute
- redundant_optional_initialization
- redundant_set_access_control
- redundant_void_return
- return_arrow_whitespace
- shorthand_operator
- single_test_class
- sorted_imports
- statement_position
- superfluous_disable_command
- switch_case_alignment
- switch_case_on_newline
- syntactic_sugar
- toggle_bool
- trailing_comma
- trailing_newline
- trailing_semicolon
- trailing_whitespace
- type_body_length
- unavailable_function
- unneeded_break_in_switch
- unneeded_parentheses_in_closure_argument
- unused_capture_list
- unused_closure_parameter
- unused_control_flow_label
- unused_enumerated
- unused_optional_binding
- valid_ibinspectable
- vertical_parameter_alignment
- vertical_parameter_alignment_on_call
- vertical_whitespace
- void_return
- weak_delegate
- xctfail_message
- yoda_condition
trailing_whitespace:
  ignores_comments: false
  ignores_empty_lines: false
trailing_comma:
  mandatory_comma: true
line_length:
- 100
type_body_length:
  warning: 300
  error: 400
file_length:
  warning: 400
  ignore_comment_only_lines: true
private_over_fileprivate:
  validate_extensions: true
cyclomatic_complexity:
  ignores_case_statements: true
prefixed_toplevel_constant:
  only_private: true
attributes:
  always_on_line_above:
  - "@discardableResult"
  - "@IBDesignable"
  - "@nonobjc"
  - "@NSManaged"
  - "@objc"
modifier_order:
  preferred_modifier_order:
  - acl
  - setterACL
  - final
  - override
  - required
  - typeMethods
  - mutators
  - owned
  - lazy
  - dynamic
  - convenience
deployment_target:
  iOS_deployment_target: 13.0

custom_rules:
  newline_after_brace:
    name: "Opening braces shouldn't have empty lines under them"
    regex: '\{\n\n'
  newline_before_brace:
    name: "Closing braces shouldn't have empty lines before them"
    regex: '\n\n\}'
  space_before_comma:
    name: "Commas should never have a space before them"
    regex: '\s+,'
  spaces_over_tabs:
    name: "Use (2) spaces instead of tabs"
    regex: '\t'
exclude: '(^third_party/rbe_configs/cc/module.modulemap$)|(/certificates.inc$)|(test/.*/testing/data/)'
repos:
- repo: https://github.com/pre-commit/pre-commit-hooks
  rev: v2.1.0
  hooks:
    - id: trailing-whitespace
    - id: end-of-file-fixer
    - id: check-docstring-first
    - id: check-executables-have-shebangs
    - id: check-merge-conflict
    - id: check-yaml
      exclude: '(.clang-format|test_envoy_config_template.yaml)'
    - id: detect-private-key
      exclude: 'experimental/swift/QUICStreamTest.swift'
    - id: mixed-line-ending
- repo: https://github.com/codespell-project/codespell
  rev: v2.1.0
  hooks:
    - id: codespell
      args: ['-L=inout,keyserver,optin,uint']
#!/usr/bin/env python

import argparse
import base64
import hashlib
import json
import os
import shutil
import sys
import time

try:
    from urllib.request import urlopen, Request, HTTPError
except ImportError:  # python 2
    from urllib2 import urlopen, Request, HTTPError

_USER_CREDS = os.environ.get("READWRITE_USER", "")
_KEY_CREDS = os.environ.get("READWRITE_API_KEY", "")
BASE64_ENCODED_CREDENTIALS = base64.b64encode("{}:{}".format(_USER_CREDS,
                                                             _KEY_CREDS).encode()).decode()

_ARTIFACT_HOST_URL = "https://oss.sonatype.org/service/local/staging"
_GROUP_ID = "io.envoyproxy.envoymobile"
_LOCAL_INSTALL_PATH = os.path.expanduser(
    "~/.m2/repository/{directory}/envoy".format(directory=_GROUP_ID.replace(".", "/")))


def _resolve_name(file):
    file_name, file_extension = os.path.splitext(file)

    extension = file_extension[1:]
    if extension == "asc" or extension == "sha256":
        if file_name.endswith("pom.xml"):
            return ".pom", extension
        elif file_name.endswith("javadoc.jar"):
            return "-javadoc.jar", extension
        elif file_name.endswith("sources.jar"):
            return "-sources.jar", extension
        elif file_name.endswith(".aar"):
            return ".aar", extension
        elif file_name.endswith(".jar"):
            return ".jar", extension
    else:
        if file_name.endswith("pom"):
            return "", "pom"
        elif file_name.endswith("javadoc"):
            return "-javadoc", extension
        elif file_name.endswith("sources"):
            return "-sources", extension
        else:
            return "", extension


def _install_locally(artifact_id, version, files):
    path = "{}/{}".format(_LOCAL_INSTALL_PATH, version)

    if os.path.exists(path):
        shutil.rmtree(path)

    os.makedirs(path)

    for file in files:
        suffix, file_extension = _resolve_name(file)
        basename = "{name}-{version}{suffix}.{extension}".format(
            name=artifact_id, version=version, suffix=suffix, extension=file_extension)

        shutil.copyfile(file, os.path.join(path, basename))
        print("{file_name}\n{sha}\n".format(file_name=file, sha=_sha256(file)))


def _urlopen_retried(request, max_retries=500, attempt=1, delay_sec=1):
    """
    Retries a request via recursion. Retries happen after the provided delay. We do not exponentially back off.
    :param request: the request to be made
    :param max_retries: Number of retries to use, default is 500. The reason we are using such a high retry is because
    sonatype fails quite frequently
    :param attempt: The current attempt number for the request
    :param delay_sec: The delay before making a retried request
    :return: the response if successful, raises error otherwise
    """
    try:
        return urlopen(request)
    except HTTPError as e:
        if max_retries > attempt and e.code >= 500:
            print(
                "[{retry_attempt}/{max_retries} Retry attempt] Retrying request after {delay}s."
                " Received error code {code}".format(
                    retry_attempt=attempt, max_retries=max_retries, delay=delay_sec, code=e.code))
            time.sleep(delay_sec)
            return _urlopen_retried(request, max_retries, attempt + 1)
        elif max_retries <= attempt:
            print(
                "Retry limit reached. Will not continue to retry. Received error code {}".format(
                    e.code))
            raise e
        else:
            raise e


def _create_staging_repository(profile_id):
    try:
        url = os.path.join(_ARTIFACT_HOST_URL, "profiles/{}/start".format(profile_id))
        data = {'data': {'description': ''}}
        request = Request(url)
        request.add_header("Authorization", "Basic {}".format(BASE64_ENCODED_CREDENTIALS))
        request.add_header("Content-Type", "application/json")
        request.get_method = lambda: "POST"
        request.data = json.dumps(data).encode("utf8")

        response = json.load(_urlopen_retried(request))
        staging_id = response["data"]["stagedRepositoryId"]
        print("staging id {} was created".format(staging_id))
        return staging_id
    except Exception as e:
        raise e


def _upload_files(staging_id, artifact_id, version, files, ascs, sha256):
    uploaded_file_count = 0

    # aggregate all the files for uploading
    all_files = files + ascs + sha256
    for file in all_files:
        # This will output "envoy", ".aar" for "envoy.aar
        print("Uploading file {}".format(file))
        suffix, file_extension = _resolve_name(file)
        basename = "{name}-{version}{suffix}.{extension}".format(
            name=artifact_id, version=version, suffix=suffix, extension=file_extension)

        artifact_url = os.path.join(
            _ARTIFACT_HOST_URL, "deployByRepositoryId/{}".format(staging_id),
            _GROUP_ID.replace('.', "/"), artifact_id, version, basename)

        try:
            with open(file, "rb") as f:
                request = Request(artifact_url, f.read())

            request.add_header("Authorization", "Basic {}".format(BASE64_ENCODED_CREDENTIALS))
            request.add_header(
                "Content-Type", "application/x-{extension}".format(extension=file_extension))
            request.get_method = lambda: "PUT"
            _urlopen_retried(request)
            uploaded_file_count = uploaded_file_count + 1
        except HTTPError as e:
            if e.code == 403:
                # Don't need to pipe to error since we are ignoring duplicated uploads
                print("Ignoring duplicate upload for {}".format(artifact_url))
            else:
                raise e
        except Exception as e:
            raise e

    return uploaded_file_count


def _close_staging_repository(profile_id, staging_id):
    url = os.path.join(_ARTIFACT_HOST_URL, "profiles/{}/finish".format(profile_id))
    data = {'data': {'stagedRepositoryId': staging_id, 'description': ''}}

    try:
        request = Request(url)

        request.add_header("Authorization", "Basic {}".format(BASE64_ENCODED_CREDENTIALS))
        request.add_header("Content-Type", "application/json")
        request.data = json.dumps(data).encode("utf8")
        request.get_method = lambda: "POST"
        _urlopen_retried(request)
    except Exception as e:
        raise e


def _drop_staging_repository(staging_id, message):
    url = os.path.join(_ARTIFACT_HOST_URL, "bulk/drop")
    data = {'data': {'stagedRepositoryIds': [staging_id], 'description': message}}

    try:
        request = Request(url)

        request.add_header("Authorization", "Basic {}".format(BASE64_ENCODED_CREDENTIALS))
        request.add_header("Content-Type", "application/json")
        request.data = json.dumps(data).encode("utf8")
        request.get_method = lambda: "POST"
        _urlopen_retried(request)
    except Exception as e:
        raise e


def _release_staging_repository(staging_id):
    url = os.path.join(_ARTIFACT_HOST_URL, "bulk/promote")
    data = {'data': {'stagedRepositoryIds': [staging_id], 'description': ''}}

    try:
        request = Request(url)

        request.add_header("Authorization", "Basic {}".format(BASE64_ENCODED_CREDENTIALS))
        request.add_header("Content-Type", "application/json")
        request.data = json.dumps(data).encode("utf8")
        request.get_method = lambda: "POST"
        _urlopen_retried(request)
    except Exception as e:
        raise e


def _create_sha256_files(files):
    sha256_files = []
    for file in files:
        sha256_file_name = "{}.sha256".format(file)
        sha256 = _sha256(file)
        sha256_file = open(sha256_file_name, 'w+')
        sha256_file.write(sha256)
        sha256_file.close()
        sha256_files.append(sha256_file_name)
    return sha256_files


def _sha256(file_name):
    sha256 = hashlib.sha256()
    with open(file_name, 'rb') as file:
        for line in file.readlines():
            sha256.update(line)
    return sha256.hexdigest()


def _build_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--profile_id",
        required=False,
        help="""
                        The staging profile id of the sonatype repository target.
                        This is the id in the sonatype web ui. The REST api is:
                        curl -u {usr}:{psswrd} -H "Accept: application/json"
                        https://oss.sonatype.org//nexus/service/local/staging/profile_repositories
                        """)
    parser.add_argument(
        "--artifact_id",
        required=True,
        help="""
                        The artifact ID to be published.
                        """)
    parser.add_argument(
        "--version",
        default="LOCAL-SNAPSHOT",
        help="""
                        The version of the artifact to be published. `LOCAL-SNAPSHOT` is defaulted
                        if the version is not set. This version should be consistent with the pom.xml
                        provided.
                        """)
    parser.add_argument(
        "--local",
        nargs='?',
        const=True,
        default=False,
        help="""
                        For installing artifacts into local maven. For now, we only support
                        installing to the path `~/.m2/repository/io/envoyproxy/envoymobile/`
                        """)
    parser.add_argument(
        "--files",
        nargs="+",
        required=True,
        help="""
                        Files to upload

                        The checklist for Envoy Mobile files are:
                            envoy.aar
                            envoy-pom.xml
                            envoy-sources.jar
                            envoy-javadoc.jar
                        """)
    parser.add_argument(
        "--signed_files",
        nargs="+",
        required=False,
        help="""
                        Files to upload.
                        Sonatype requires uploaded artifacts to be gpg signed

                        GPG signed:
                            envoy.aar.asc
                            envoy-pom.xml.asc
                            envoy-sources.jar.asc
                            envoy-javadoc.jar.asc
                        """)
    return parser


if __name__ == "__main__":
    args = _build_parser().parse_args()

    version = args.version
    if args.local:
        _install_locally(args.artifact_id, version, args.files)
    else:
        staging_id = ""

        try:
            staging_id = _create_staging_repository(args.profile_id)
        except:
            sys.exit("Unable to create staging id")

        # Upload files using the staging_id, close the staging repository, and release
        # If an error occurs, we will attempt to drop the repository. The script will
        # need to be re-run to initiate another upload attempt
        try:
            print("Uploading files...")
            sha256_files = _create_sha256_files(args.files)
            uploaded_file_count = _upload_files(
                staging_id, args.artifact_id, version, args.files, args.signed_files, sha256_files)
            if uploaded_file_count > 0:
                print("Uploading files complete!")
                print("Closing staging repository...")
                _close_staging_repository(args.profile_id, staging_id)
                print("Closing staging complete!")
                print("Releasing artifact {}...".format(version))
                _release_staging_repository(staging_id)
                print("Release complete!")
            else:
                print("No files were uploaded. Dropping staging repository...")
                _drop_staging_repository(staging_id, "droppng release due to no uploaded files")
                print("Dropping staging id {} complete!".format(staging_id))
        except Exception as e:
            print(e)

            print(
                "Unable to complete file upload. Will attempt to drop staging id: [{}]".format(
                    staging_id))
            try:
                _drop_staging_repository(staging_id, "droppng release due to error")
                sys.exit("Dropping staging id: [{}] successful.".format(staging_id))
            except Exception as e:
                print(e)
                sys.exit("Dropping staging id: [{}] failed.".format(staging_id))
#!/bin/bash

set -e

check_emulator_status() {
    while true; do
        if grep -q "Running on a system with less than 6 logical cores. Setting number of virtual cores to 1" nohup.out; then
            echo "=================================================================================="
            echo "ERROR: Starting an emulator on this machine is likely to fail, please run /retest"
            echo "=================================================================================="
            exit 1
        elif grep -q "Boot completed" nohup.out; then
            break
        fi
        sleep 1
    done
}

echo "y" | "${ANDROID_HOME}/cmdline-tools/latest/bin/sdkmanager" --install 'system-images;android-30;google_apis;x86_64' --channel=3
echo "no" | "${ANDROID_HOME}/cmdline-tools/latest/bin/avdmanager" create avd -n test_android_emulator -k 'system-images;android-30;google_apis;x86_64' --device pixel_4 --force
"${ANDROID_HOME}"/emulator/emulator -accel-check
# This is only available on macOS.
if [[ -n $(which system_profiler) ]]; then
    system_profiler SPHardwareDataType
fi

# shellcheck disable=SC2094
nohup "${ANDROID_HOME}/emulator/emulator" -no-window -accel on -gpu swiftshader_indirect -no-snapshot -noaudio -no-boot-anim -avd test_android_emulator > nohup.out 2>&1 | tail -f nohup.out & {
    if [[ "$(uname -s)" == "Darwin" ]]; then
        check_emulator_status
    fi
    # shellcheck disable=SC2016
    "${ANDROID_HOME}/platform-tools/adb" wait-for-device shell 'while [[ -z $(getprop sys.boot_completed | tr -d '\''\r'\'') ]]; do sleep 1; done; input keyevent 82'
}
licenses(["notice"])  # Apache 2

platform(
    name = "macos",
    constraint_values = [
        "@platforms//cpu:x86_64",
        "@platforms//os:macos",
    ],
    exec_properties = {
        "Pool": "macos",
    },
)
#!/bin/bash -e

set -o pipefail

# Checks the absolute size and the relative size increase of a file.

# As of Jan 11, 2024, the latest runs show that the test binary size is
# 4273716 bytes:
# https://github.com/envoyproxy/envoy/actions/runs/7497709450/job/20411963750
MAX_SIZE=4500000 # 4.5MB
MAX_PERC=1.5

if [ "$(uname)" == "Darwin" ]
then
    SIZE1=$(stat -f "%z" "$1")
    SIZE2=$(stat -f "%z" "$2")
else
    SIZE1=$(stat -c "%s" "$1")
    SIZE2=$(stat -c "%s" "$2")
fi
PERC=$(bc <<< "scale=2; ($SIZE2 - $SIZE1)/$SIZE1 * 100")

echo "The new binary is $PERC % different in size compared to main."
echo "The new binary is $SIZE2 bytes."

if [ "$SIZE2" -gt $MAX_SIZE ]
then
    echo "The current size ($SIZE2) is larger than the maximum size ($MAX_SIZE)."
    exit 1
fi

if [ "$(bc <<< "scale=2; $PERC >= $MAX_PERC")" -eq 1 ]
then
    echo "The percentage increase ($PERC) is larger then the maximum percentage increase ($MAX_PERC)."
    exit 1
fi
#!/bin/bash

set -e

# Copied from Envoy upstream's setup scripts with homebrew update disabled.
# Installs the dependencies required for a macOS build via homebrew.
# Tools are not upgraded to new versions.
# See:
# https://github.com/actions/virtual-environments/blob/main/images/macos/macos-12-Readme.md for
# a list of pre-installed tools in the macOS image.

export HOMEBREW_NO_AUTO_UPDATE=1
RETRY_ATTEMPTS=10
RETRY_INTERVAL=3


function retry () {
    local returns=1 i=1
    while ((i<=RETRY_ATTEMPTS)); do
        if "$@"; then
            returns=0
            break
        else
            sleep "$RETRY_INTERVAL";
            ((i++))
        fi
    done
    return "$returns"
}

function is_installed {
    brew ls --versions "$1" >/dev/null
}

function install {
    echo "Installing $1"
    if ! retry brew install --quiet "$1"; then
        echo "Failed to install $1"
        exit 1
    fi
}

if ! retry brew update; then
  # Do not exit early if update fails.
  echo "Failed to update homebrew"
fi

DEPS="automake cmake coreutils libtool ninja"
for DEP in ${DEPS}
do
    is_installed "${DEP}" || install "${DEP}"
done

# https://github.com/actions/runner-images/blob/main/images/macos/macos-12-Readme.md#xcode
sudo xcode-select --switch /Applications/Xcode_14.1.app

retry ./bazelw version

if [[ "${1:-}" == "--android" ]]; then
  # Download and set up ndk 21 after GitHub update
  # https://github.com/actions/virtual-environments/issues/5595
  ANDROID_HOME=$ANDROID_SDK_ROOT
  SDKMANAGER="${ANDROID_SDK_ROOT}/cmdline-tools/latest/bin/sdkmanager"
  "${SDKMANAGER}" --install "platform-tools" "platforms;android-30"
  "${SDKMANAGER}" --uninstall "ndk-bundle"
  "${SDKMANAGER}" --install "ndk;21.4.7075529"
  "${SDKMANAGER}" --install "build-tools;30.0.2"
  ANDROID_NDK_HOME="${ANDROID_HOME}/ndk/21.4.7075529"
  export ANDROID_NDK_HOME
fi
#!/bin/bash

set -euo pipefail

simulator_name="iPhone 14 Pro Max"
simulator_uuid="$(xcrun simctl list | sed -nr "s/.*$simulator_name \(([A-Z0-9\-]{36})\).*/\1/p" | head -n1)"

echo "Booting simulator named '$simulator_name' with uuid '$simulator_uuid'"

open -a "$(xcode-select -p)/Applications/Simulator.app" --args -CurrentDeviceUDID "$simulator_uuid"

attempt=0
max=5
delay=5
while true; do
  # shellcheck disable=SC2015
  (xcrun simctl list | grep "($simulator_uuid) (Booted)") && break || {
    if [[ $attempt -lt $max ]]; then
      ((attempt++))
      echo "Simulator not yet booted. Attempt $attempt/$max. Waiting $delay seconds."
      sleep $delay;
    else
      echo "The simulator did not boot after $attempt attempts."
      exit 1
    fi
  }
done

echo "Simulator booted successfully"
licenses(["notice"])  # Apache 2

xcode_version(
    name = "xcode_14_1_0",
    default_ios_sdk_version = "16.1",
    default_macos_sdk_version = "13.0",
    default_tvos_sdk_version = "16.1",
    default_watchos_sdk_version = "9.1",
    version = "14.1",
)

available_xcodes(
    name = "local_xcodes",
    default = ":xcode_14_1_0",
    versions = [
        ":xcode_14_1_0",
    ],
)

available_xcodes(
    name = "remote_xcodes",
    default = ":xcode_14_1_0",
    versions = [
        ":xcode_14_1_0",
    ],
)

xcode_config(
    name = "xcode_config",
    local_versions = ":local_xcodes",
    remote_versions = ":remote_xcodes",
)
#!/bin/bash

set -e

# Set up necessary Android SDK and NDK.
ANDROID_HOME=$ANDROID_SDK_ROOT
SDKMANAGER="${ANDROID_SDK_ROOT}/cmdline-tools/latest/bin/sdkmanager"
"${SDKMANAGER}" --install "platform-tools" "platforms;android-30"
"${SDKMANAGER}" --uninstall "ndk-bundle"
"${SDKMANAGER}" --install "ndk;21.4.7075529"
"${SDKMANAGER}" --install "build-tools;30.0.2"
echo "ANDROID_NDK_HOME=${ANDROID_HOME}/ndk/21.4.7075529" >> "$GITHUB_ENV"
workspace(name = "envoy_mobile")

# The pgv imports require gazelle to be available early on.
load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")

http_archive(
    name = "bazel_gazelle",
    sha256 = "29218f8e0cebe583643cbf93cae6f971be8a2484cdcfa1e45057658df8d54002",
    urls = [
        "https://mirror.bazel.build/github.com/bazelbuild/bazel-gazelle/releases/download/v0.32.0/bazel-gazelle-v0.32.0.tar.gz",
        "https://github.com/bazelbuild/bazel-gazelle/releases/download/v0.32.0/bazel-gazelle-v0.32.0.tar.gz",
    ],
)

# TODO(yannic): Remove once https://github.com/bazelbuild/rules_foreign_cc/pull/938
# is merged and released.
http_archive(
    name = "rules_foreign_cc",
    sha256 = "bbc605fd36048923939845d6843464197df6e6ffd188db704423952825e4760a",
    strip_prefix = "rules_foreign_cc-a473d42bada74afac4e32b767964c1785232e07b",
    urls = [
        "https://storage.googleapis.com/engflow-tools-public/rules_foreign_cc-a473d42bada74afac4e32b767964c1785232e07b.tar.gz",
        "https://github.com/EngFlow/rules_foreign_cc/archive/a473d42bada74afac4e32b767964c1785232e07b.tar.gz",
    ],
)

load("@envoy_mobile//bazel:envoy_mobile_repositories.bzl", "envoy_mobile_repositories")

envoy_mobile_repositories()

local_repository(
    name = "envoy",
    path = "..",
)

local_repository(
    name = "envoy_build_config",
    path = "envoy_build_config",
)

load("@envoy//bazel:api_binding.bzl", "envoy_api_binding")

envoy_api_binding()

load("@envoy//bazel:api_repositories.bzl", "envoy_api_dependencies")

envoy_api_dependencies()

load("@envoy//bazel:repositories.bzl", "envoy_dependencies")

envoy_dependencies()

load("@envoy//bazel:repositories_extra.bzl", "envoy_dependencies_extra")

envoy_dependencies_extra(ignore_root_user_error=True)

load("@envoy//bazel:python_dependencies.bzl", "envoy_python_dependencies")

envoy_python_dependencies()

load("@envoy//bazel:dependency_imports.bzl", "envoy_dependency_imports")

envoy_dependency_imports()

load("@envoy_mobile//bazel:envoy_mobile_dependencies.bzl", "envoy_mobile_dependencies")

envoy_mobile_dependencies()

load("@envoy_mobile//bazel:envoy_mobile_toolchains.bzl", "envoy_mobile_toolchains")

envoy_mobile_toolchains()

load("@pybind11_bazel//:python_configure.bzl", "python_configure")

python_configure(
    name = "local_config_python",
    python_version = "3",
)

load("//bazel:python.bzl", "declare_python_abi")

declare_python_abi(
    name = "python_abi",
    python_version = "3",
)

load("//bazel:android_configure.bzl", "android_configure")

android_configure(
    name = "local_config_android",
    build_tools_version = "30.0.2",
    ndk_api_level = 21,
    sdk_api_level = 30,
)

load("@local_config_android//:android_configure.bzl", "android_workspace")

android_workspace()

load("@com_github_buildbuddy_io_rules_xcodeproj//xcodeproj:repositories.bzl", "xcodeproj_rules_dependencies")

xcodeproj_rules_dependencies()

load(
    "@build_bazel_rules_apple//apple:apple.bzl",
    "provisioning_profile_repository",
)

provisioning_profile_repository(
    name = "local_provisioning_profiles",
)
package org.chromium.net;

import java.util.List;
import java.util.Map;

/**
 * Basic information about a response. Included in {@link UrlRequest.Callback} callbacks. Each
 * {@link UrlRequest.Callback#onRedirectReceived onRedirectReceived()} callback gets a different
 * copy of {@code UrlResponseInfo} describing a particular redirect response.
 */
public abstract class UrlResponseInfo {
  /** Unmodifiable container of response headers or trailers. {@hide}. */
  public abstract static class HeaderBlock {
    /**
     * Returns an unmodifiable list of the response header field and value pairs. The headers are in
     * the same order they are received over the wire.
     *
     * @return an unmodifiable list of response header field and value pairs
     */
    public abstract List<Map.Entry<String, String>> getAsList();

    /**
     * Returns an unmodifiable map from response-header field names to lists of values. Each list of
     * values for a single header field is in the same order they were received over the wire.
     *
     * @return an unmodifiable map from response-header field names to lists of values
     */
    public abstract Map<String, List<String>> getAsMap();
  }

  /**
   * Returns the URL the response is for. This is the URL after following redirects, so it may not
   * be the originally requested URL.
   *
   * @return the URL the response is for.
   */
  public abstract String getUrl();

  /**
   * Returns the URL chain. The first entry is the originally requested URL; the following entries
   * are redirects followed.
   *
   * @return the URL chain.
   */
  public abstract List<String> getUrlChain();

  /**
   * Returns the HTTP status code. When a resource is retrieved from the cache, whether it was
   * revalidated or not, the original status code is returned.
   *
   * @return the HTTP status code.
   */
  public abstract int getHttpStatusCode();

  /**
   * Returns the HTTP status text of the status line. For example, if the request received a
   * "HTTP/1.1 200 OK" response, this method returns "OK".
   *
   * @return the HTTP status text of the status line.
   */
  public abstract String getHttpStatusText();

  /**
   * Returns an unmodifiable list of response header field and value pairs. The headers are in the
   * same order they are received over the wire.
   *
   * @return an unmodifiable list of response header field and value pairs.
   */
  public abstract List<Map.Entry<String, String>> getAllHeadersAsList();

  /**
   * Returns an unmodifiable map of the response-header fields and values. Each list of values for a
   * single header field is in the same order they were received over the wire.
   *
   * @return an unmodifiable map of the response-header fields and values.
   */
  public abstract Map<String, List<String>> getAllHeaders();

  /**
   * Returns {@code true} if the response came from the cache, including requests that were
   * revalidated over the network before being retrieved from the cache.
   *
   * @return {@code true} if the response came from the cache, {@code false} otherwise.
   */
  public abstract boolean wasCached();

  /**
   * Returns the protocol (for example 'quic/1+spdy/3') negotiated with the server. Returns an empty
   * string if no protocol was negotiated, the protocol is not known, or when using plain HTTP or
   * HTTPS.
   *
   * @return the protocol negotiated with the server.
   */
  // TODO(mef): Figure out what this returns in the cached case, both with
  // and without a revalidation request.
  public abstract String getNegotiatedProtocol();

  /**
   * Returns the proxy server that was used for the request.
   *
   * @return the proxy server that was used for the request.
   */
  public abstract String getProxyServer();

  /**
   * Returns a minimum count of bytes received from the network to process this request. This count
   * may ignore certain overheads (for example IP and TCP/UDP framing, SSL handshake and framing,
   * proxy handling). This count is taken prior to decompression (for example GZIP) and includes
   * headers and data from all redirects.
   *
   * <p>This value may change (even for one {@link UrlResponseInfo} instance) as the request
   * progresses until completion, when {@link UrlRequest.Callback#onSucceeded onSucceeded()}, {@link
   * UrlRequest.Callback#onFailed onFailed()}, or {@link UrlRequest.Callback#onCanceled
   * onCanceled()} is called.
   *
   * @return a minimum count of bytes received from the network to process this request.
   */
  public abstract long getReceivedByteCount();
}
package org.chromium.net.impl;

import androidx.annotation.IntDef;
import androidx.annotation.Nullable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.Collection;
import java.util.Collections;
import org.chromium.net.CronetException;
import org.chromium.net.RequestFinishedInfo;
import org.chromium.net.UrlResponseInfo;

/**
 * Implements information about a finished request. Passed to {@link RequestFinishedInfo.Listener}.
 */
public class CronvoyRequestFinishedInfoImpl extends RequestFinishedInfo {
  private final String mUrl;
  private final Collection<Object> mAnnotations;
  private final RequestFinishedInfo.Metrics mMetrics;

  @FinishedReason private final int mFinishedReason;

  @Nullable private final UrlResponseInfo mResponseInfo;
  @Nullable private final CronetException mException;

  @IntDef({SUCCEEDED, FAILED, CANCELED})
  @Retention(RetentionPolicy.SOURCE)
  public @interface FinishedReason {}

  public CronvoyRequestFinishedInfoImpl(String url, Collection<Object> annotations,
                                        RequestFinishedInfo.Metrics metrics,
                                        @FinishedReason int finishedReason,
                                        @Nullable UrlResponseInfo responseInfo,
                                        @Nullable CronetException exception) {
    mUrl = url;
    mAnnotations = annotations;
    mMetrics = metrics;
    mFinishedReason = finishedReason;
    mResponseInfo = responseInfo;
    mException = exception;
  }

  @Override
  public String getUrl() {
    return mUrl;
  }

  @Override
  public Collection<Object> getAnnotations() {
    if (mAnnotations == null) {
      return Collections.emptyList();
    }
    return mAnnotations;
  }

  @Override
  public Metrics getMetrics() {
    return mMetrics;
  }

  @Override
  @FinishedReason
  public int getFinishedReason() {
    return mFinishedReason;
  }

  @Override
  @Nullable
  public UrlResponseInfo getResponseInfo() {
    return mResponseInfo;
  }

  @Override
  @Nullable
  public CronetException getException() {
    return mException;
  }
}
package org.chromium.net.impl;

import androidx.annotation.IntDef;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/** Annotations for "int" based Enums. */
public final class Annotations {
  /** Enum defined here: chromium/src/net/base/request_priority.h */
  @IntDef({RequestPriority.THROTTLED, RequestPriority.IDLE, RequestPriority.LOWEST,
           RequestPriority.LOW, RequestPriority.MEDIUM, RequestPriority.HIGHEST})
  @Retention(RetentionPolicy.SOURCE)
  public @interface RequestPriority {
    int THROTTLED = 0;
    int IDLE = 1; // Default "as resources available" level.
    int LOWEST = 2;
    int LOW = 3;
    int MEDIUM = 4;
    int HIGHEST = 5;
  }

  /** Enum defined here: chromium/src/components/cronet/url_request_context_config.h, line 37 */
  @IntDef({HttpCacheType.DISABLED, HttpCacheType.DISK, HttpCacheType.MEMORY})
  @Retention(RetentionPolicy.SOURCE)
  public @interface HttpCacheType {
    int DISABLED = 0;
    int DISK = 1;
    int MEMORY = 2;
  }

  private Annotations() {}
}
package org.chromium.net.impl;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * Map between HTTP status codes and corresponding textual reasons.
 *
 * <p>Respects https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
 */
public final class HttpReason {

  private static final Map<Integer, String> CODE_TO_REASON = buildReasonMap();

  public static String getReason(int statusCode) {
    return CODE_TO_REASON.getOrDefault(statusCode, "Unknown");
  }

  private static Map<Integer, String> buildReasonMap() {
    Map<Integer, String> map = new HashMap<>();
    map.put(100, "Continue");
    map.put(101, "Switching Protocols");
    map.put(102, "Processing");
    map.put(103, "Early Hints");
    map.put(200, "OK");
    map.put(201, "Created");
    map.put(202, "Accepted");
    map.put(203, "Non-Authoritative Information");
    map.put(204, "No Content");
    map.put(205, "Reset Content");
    map.put(206, "Partial Content");
    map.put(207, "Multi-Status");
    map.put(208, "Already Reported");
    map.put(226, "IM Used");
    map.put(300, "Multiple Choices");
    map.put(301, "Moved Permanently");
    map.put(302, "Found");
    map.put(303, "See Other");
    map.put(304, "Not Modified");
    map.put(305, "Use Proxy");
    map.put(307, "Temporary Redirect");
    map.put(308, "Permanent Redirect");
    map.put(400, "Bad Request");
    map.put(401, "Unauthorized");
    map.put(402, "Payment Required");
    map.put(403, "Forbidden");
    map.put(404, "Not Found");
    map.put(405, "Method Not Allowed");
    map.put(406, "Not Acceptable");
    map.put(407, "Proxy Authentication Required");
    map.put(408, "Request Timeout");
    map.put(409, "Conflict");
    map.put(410, "Gone");
    map.put(411, "Length Required");
    map.put(412, "Precondition Failed");
    map.put(413, "Payload Too Large");
    map.put(414, "URI Too Long");
    map.put(415, "Unsupported Media Type");
    map.put(416, "Range Not Satisfiable");
    map.put(417, "Expectation Failed");
    map.put(421, "Misdirected Request");
    map.put(422, "Unprocessable Entity");
    map.put(423, "Locked");
    map.put(424, "Failed Dependency");
    map.put(425, "Too Early");
    map.put(426, "Upgrade Required");
    map.put(428, "Precondition Required");
    map.put(429, "Too Many Requests");
    map.put(431, "Request Header Fields Too Large");
    map.put(451, "Unavailable For Legal Reasons");
    map.put(500, "Internal Server Error");
    map.put(501, "Not Implemented");
    map.put(502, "Bad Gateway");
    map.put(503, "Service Unavailable");
    map.put(504, "Gateway Timeout");
    map.put(505, "HTTP Version Not Supported");
    map.put(506, "Variant Also Negotiates");
    map.put(507, "Insufficient Storage");
    map.put(508, "Loop Detected");
    map.put(510, "Not Extended");
    map.put(511, "Network Authentication Required");
    return Collections.unmodifiableMap(map);
  }

  HttpReason() {}
}
package org.chromium.net.impl;

import static android.os.Process.THREAD_PRIORITY_LOWEST;

import android.content.Context;
import android.util.Base64;
import androidx.annotation.IntDef;
import java.io.File;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.net.IDN;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import org.chromium.net.CronetEngine;
import org.chromium.net.ICronetEngineBuilder;
import org.chromium.net.impl.Annotations.HttpCacheType;

/** Implementation of {@link ICronetEngineBuilder} that builds Envoy-Mobile based Cronet engine. */
public abstract class CronvoyEngineBuilderImpl extends ICronetEngineBuilder {

  /** A public key pin. */
  final static class Pkp {
    // Host to pin for.
    final String mHost;
    // Array of SHA-256 hashes of keys.
    final byte[][] mHashes;
    // Should pin apply to subdomains?
    final boolean mIncludeSubdomains;
    // When the pin expires.
    final Date mExpirationDate;

    Pkp(String host, byte[][] hashes, boolean includeSubdomains, Date expirationDate) {
      mHost = host;
      mHashes = hashes;
      mIncludeSubdomains = includeSubdomains;
      mExpirationDate = expirationDate;
    }
  }

  private static final Pattern INVALID_PKP_HOST_NAME = Pattern.compile("^[0-9\\.]*$");

  private static final int INVALID_THREAD_PRIORITY = THREAD_PRIORITY_LOWEST + 1;

  // Private fields are simply storage of configuration for the resulting CronetEngine.
  // See setters below for verbose descriptions.
  private final Context mApplicationContext;
  private final Map<String, Integer> mQuicHints = new HashMap<>();
  private final List<String> mQuicCanonicalSuffixes = new LinkedList<>();
  private final List<Pkp> mPkps = new LinkedList<>();
  private boolean mPublicKeyPinningBypassForLocalTrustAnchorsEnabled;
  private String mUserAgent;
  private String mStoragePath;
  private boolean mQuicEnabled;
  private String mQuicConnectionOptions = "";
  private String mQuicClientConnectionOptions = "";
  private boolean mHttp2Enabled;
  private boolean mBrotiEnabled;
  private boolean mDisableCache;
  private int mHttpCacheMode;
  private long mHttpCacheMaxSize;
  private String mExperimentalOptions;
  private boolean mNetworkQualityEstimatorEnabled;
  private int mThreadPriority = INVALID_THREAD_PRIORITY;

  /**
   * Default config enables SPDY and QUIC, disables SDCH and HTTP cache.
   *
   * @param context Android {@link Context} for engine to use.
   */
  CronvoyEngineBuilderImpl(Context context) {
    mApplicationContext = context.getApplicationContext();
    enableQuic(true);
    enableHttp2(true);
    enableBrotli(false);
    enableHttpCache(CronetEngine.Builder.HTTP_CACHE_DISABLED, 0);
    enableNetworkQualityEstimator(false);
    enablePublicKeyPinningBypassForLocalTrustAnchors(true);
  }

  @Override
  public String getDefaultUserAgent() {
    return CronvoyUserAgent.from(mApplicationContext);
  }

  @Override
  public CronvoyEngineBuilderImpl setUserAgent(String userAgent) {
    mUserAgent = userAgent;
    return this;
  }

  String getUserAgent() { return mUserAgent; }

  @Override
  public CronvoyEngineBuilderImpl setStoragePath(String value) {
    if (!new File(value).isDirectory()) {
      throw new IllegalArgumentException("Storage path must be set to existing directory");
    }
    mStoragePath = value;
    return this;
  }

  String storagePath() { return mStoragePath; }

  @Override
  public CronvoyEngineBuilderImpl setLibraryLoader(CronetEngine.Builder.LibraryLoader loader) {
    // |CronvoyEngineBuilderImpl| is an abstract class that is used by concrete builder
    // implementations, including the Java Cronet engine builder; therefore, the implementation
    // of this method should be "no-op". Subclasses that care about the library loader
    // should override this method.
    return this;
  }

  /**
   * Default implementation of the method that returns {@code null}.
   */
  CronvoyVersionSafeCallbacks.LibraryLoader libraryLoader() { return null; }

  @Override
  public CronvoyEngineBuilderImpl enableQuic(boolean value) {
    mQuicEnabled = value;
    return this;
  }

  boolean quicEnabled() { return mQuicEnabled; }

  public CronvoyEngineBuilderImpl setQuicConnectionOptions(String options) {
    mQuicConnectionOptions = options;
    return this;
  }

  String quicConnectionOptions() { return mQuicConnectionOptions; }

  public CronvoyEngineBuilderImpl setQuicClientConnectionOptions(String options) {
    mQuicClientConnectionOptions = options;
    return this;
  }

  String quicClientConnectionOptions() { return mQuicClientConnectionOptions; }

  /**
   * Constructs default QUIC User Agent Id string including application name and Cronet version.
   * Returns empty string if QUIC is not enabled.
   *
   * @return QUIC User Agent ID string.
   */
  String getDefaultQuicUserAgentId() {
    return mQuicEnabled ? CronvoyUserAgent.getQuicUserAgentIdFrom(mApplicationContext) : "";
  }

  @Override
  public CronvoyEngineBuilderImpl enableHttp2(boolean value) {
    mHttp2Enabled = value;
    return this;
  }

  boolean http2Enabled() { return mHttp2Enabled; }

  @Override
  public CronvoyEngineBuilderImpl enableSdch(boolean value) {
    return this;
  }

  @Override
  public CronvoyEngineBuilderImpl enableBrotli(boolean value) {
    mBrotiEnabled = value;
    return this;
  }

  boolean brotliEnabled() { return mBrotiEnabled; }

  @IntDef({CronetEngine.Builder.HTTP_CACHE_DISABLED, CronetEngine.Builder.HTTP_CACHE_IN_MEMORY,
           CronetEngine.Builder.HTTP_CACHE_DISK_NO_HTTP, CronetEngine.Builder.HTTP_CACHE_DISK})
  @Retention(RetentionPolicy.SOURCE)
  public @interface HttpCacheSetting {}

  @Override
  public CronvoyEngineBuilderImpl enableHttpCache(@HttpCacheSetting int cacheMode, long maxSize) {
    if (cacheMode == CronetEngine.Builder.HTTP_CACHE_DISK ||
        cacheMode == CronetEngine.Builder.HTTP_CACHE_DISK_NO_HTTP) {
      if (storagePath() == null) {
        throw new IllegalArgumentException("Storage path must be set");
      }
    } else {
      if (storagePath() != null) {
        throw new IllegalArgumentException("Storage path must not be set");
      }
    }
    mDisableCache = (cacheMode == CronetEngine.Builder.HTTP_CACHE_DISABLED ||
                     cacheMode == CronetEngine.Builder.HTTP_CACHE_DISK_NO_HTTP);
    mHttpCacheMaxSize = maxSize;

    switch (cacheMode) {
    case CronetEngine.Builder.HTTP_CACHE_DISABLED:
      mHttpCacheMode = HttpCacheType.DISABLED;
      break;
    case CronetEngine.Builder.HTTP_CACHE_DISK_NO_HTTP:
    case CronetEngine.Builder.HTTP_CACHE_DISK:
      mHttpCacheMode = HttpCacheType.DISK;
      break;
    case CronetEngine.Builder.HTTP_CACHE_IN_MEMORY:
      mHttpCacheMode = HttpCacheType.MEMORY;
      break;
    default:
      throw new IllegalArgumentException("Unknown cache mode");
    }
    return this;
  }

  boolean cacheDisabled() { return mDisableCache; }

  long httpCacheMaxSize() { return mHttpCacheMaxSize; }

  int httpCacheMode() { return mHttpCacheMode; }

  @Override
  public CronvoyEngineBuilderImpl addQuicHint(String host, int port, int alternatePort) {
    if (host.contains("/")) {
      throw new IllegalArgumentException("Illegal QUIC Hint Host: " + host);
    }
    mQuicHints.put(host, port);
    return this;
  }

  Map<String, Integer> quicHints() { return mQuicHints; }

  public CronvoyEngineBuilderImpl addQuicCanonicalSuffix(String suffix) {
    mQuicCanonicalSuffixes.add(suffix);
    return this;
  }

  List<String> quicCanonicalSuffixes() { return mQuicCanonicalSuffixes; }

  @Override
  public CronvoyEngineBuilderImpl addPublicKeyPins(String hostName, Set<byte[]> pinsSha256,
                                                   boolean includeSubdomains, Date expirationDate) {
    if (hostName == null) {
      throw new NullPointerException("The hostname cannot be null");
    }
    if (pinsSha256 == null) {
      throw new NullPointerException("The set of SHA256 pins cannot be null");
    }
    if (expirationDate == null) {
      throw new NullPointerException("The pin expiration date cannot be null");
    }
    String idnHostName = validateHostNameForPinningAndConvert(hostName);
    // Convert the pin to BASE64 encoding to remove duplicates.
    Map<String, byte[]> hashes = new HashMap<>();
    for (byte[] pinSha256 : pinsSha256) {
      if (pinSha256 == null || pinSha256.length != 32) {
        throw new IllegalArgumentException("Public key pin is invalid");
      }
      hashes.put(Base64.encodeToString(pinSha256, 0), pinSha256);
    }
    // Add new element to PKP list.
    mPkps.add(new Pkp(idnHostName, hashes.values().toArray(new byte[hashes.size()][]),
                      includeSubdomains, expirationDate));
    return this;
  }

  /**
   * Returns list of public key pins.
   *
   * @return list of public key pins.
   */
  List<Pkp> publicKeyPins() { return mPkps; }

  @Override
  public CronvoyEngineBuilderImpl enablePublicKeyPinningBypassForLocalTrustAnchors(boolean value) {
    mPublicKeyPinningBypassForLocalTrustAnchorsEnabled = value;
    return this;
  }

  boolean publicKeyPinningBypassForLocalTrustAnchorsEnabled() {
    return mPublicKeyPinningBypassForLocalTrustAnchorsEnabled;
  }

  /**
   * Checks whether a given string represents a valid host name for PKP and converts it to ASCII
   * Compatible Encoding representation according to RFC 1122, RFC 1123 and RFC 3490. This method is
   * more restrictive than required by RFC 7469. Thus, a host that contains digits and the dot
   * character only is considered invalid.
   *
   * <p>Note: Currently Cronet doesn't have native implementation of host name validation that can
   * be used. There is code that parses a provided URL but doesn't ensure its correctness. The
   * implementation relies on {@code getaddrinfo} function.
   *
   * @param hostName host name to check and convert.
   * @return true if the string is a valid host name.
   * @throws IllegalArgumentException if the the given string does not represent a valid hostname.
   */
  private static String validateHostNameForPinningAndConvert(String hostName)
      throws IllegalArgumentException {
    if (INVALID_PKP_HOST_NAME.matcher(hostName).matches()) {
      throw new IllegalArgumentException(
          "Hostname " + hostName + " is illegal."
          + " A hostname should not consist of digits and/or dots only.");
    }
    // Workaround for crash, see crbug.com/634914
    if (hostName.length() > 255) {
      throw new IllegalArgumentException(
          "Hostname " + hostName + " is too long."
          + " The name of the host does not comply with RFC 1122 and RFC 1123.");
    }
    try {
      return IDN.toASCII(hostName, IDN.USE_STD3_ASCII_RULES);
    } catch (IllegalArgumentException ex) {
      throw new IllegalArgumentException(
          "Hostname " + hostName + " is illegal."
          + " The name of the host does not comply with RFC 1122 and RFC 1123.");
    }
  }

  @Override
  public CronvoyEngineBuilderImpl setExperimentalOptions(String options) {
    mExperimentalOptions = options;
    return this;
  }

  public String experimentalOptions() { return mExperimentalOptions; }

  /**
   * @return true if the network quality estimator has been enabled for
   * this builder.
   */
  boolean networkQualityEstimatorEnabled() { return mNetworkQualityEstimatorEnabled; }

  @Override
  public CronvoyEngineBuilderImpl enableNetworkQualityEstimator(boolean value) {
    mNetworkQualityEstimatorEnabled = value;
    return this;
  }

  @Override
  public CronvoyEngineBuilderImpl setThreadPriority(int priority) {
    if (priority > THREAD_PRIORITY_LOWEST || priority < -20) {
      throw new IllegalArgumentException("Thread priority invalid");
    }
    mThreadPriority = priority;
    return this;
  }

  /**
   * @return thread priority provided by user, or {@code defaultThreadPriority} if none provided.
   */
  int threadPriority(int defaultThreadPriority) {
    return mThreadPriority == INVALID_THREAD_PRIORITY ? defaultThreadPriority : mThreadPriority;
  }

  /**
   * Returns {@link Context} for builder.
   *
   * @return {@link Context} for builder.
   */
  Context getContext() { return mApplicationContext; }
}
package org.chromium.net.impl;

import android.content.Context;
import org.chromium.net.CronetEngine.Builder.LibraryLoader;
import org.chromium.net.ICronetEngineBuilder;

/**
 * An extension of {@link NativeCronvoyEngineBuilderImpl} that implements
 * {@link ICronetEngineBuilder#setLibraryLoader}.
 */
public class NativeCronvoyEngineBuilderWithLibraryLoaderImpl
    extends NativeCronvoyEngineBuilderImpl {
  private CronvoyVersionSafeCallbacks.LibraryLoader mLibraryLoader;

  /**
   * Constructs a builder for Native Cronet Engine.
   * Default config enables SPDY, disables QUIC and HTTP cache.
   *
   * @param context Android {@link Context} for engine to use.
   */
  public NativeCronvoyEngineBuilderWithLibraryLoaderImpl(Context context) { super(context); }

  @Override
  public CronvoyEngineBuilderImpl setLibraryLoader(LibraryLoader loader) {
    mLibraryLoader = new CronvoyVersionSafeCallbacks.LibraryLoader(loader);
    return this;
  }

  @Override
  CronvoyVersionSafeCallbacks.LibraryLoader libraryLoader() {
    return mLibraryLoader;
  }
}
package org.chromium.net.impl;

import org.chromium.net.impl.Errors.NetError;

/**
 * Used in {@link CronetBidirectionalStream}. Implements {@link CronvoyNetworkExceptionImpl}.
 */
public final class CronvoyBidirectionalStreamNetworkException extends CronvoyNetworkExceptionImpl {
  public CronvoyBidirectionalStreamNetworkException(String message, int errorCode,
                                                    int cronetInternalErrorCode) {
    super(message, errorCode, cronetInternalErrorCode);
  }

  @Override
  public boolean immediatelyRetryable() {
    if (mCronetInternalErrorCode == NetError.ERR_HTTP2_PING_FAILED.getErrorCode() ||
        mCronetInternalErrorCode == NetError.ERR_QUIC_HANDSHAKE_FAILED.getErrorCode()) {
      assert mErrorCode == ERROR_OTHER;
      return true;
    }
    return super.immediatelyRetryable();
  }
}
package org.chromium.net.impl;

import org.chromium.net.QuicException;

/**
 * Implements {@link QuicException}.
 */
public class CronvoyQuicExceptionImpl extends QuicException {
  private final int mQuicDetailedErrorCode;
  private final CronvoyNetworkExceptionImpl mNetworkException;

  /**
   * Constructs an exception with a specific error.
   *
   * @param message explanation of failure.
   * @param netErrorCode Error code from
   * <a href=https://chromium.googlesource.com/chromium/src/+/master/net/base/net_error_list.h>
   * this list</a>.
   * @param quicDetailedErrorCode Detailed <a href="https://www.chromium.org/quic">QUIC</a> error
   * code from <a
   * href="https://cs.chromium.org/search/?q=symbol:%5CbQuicErrorCode%5Cb">
   * QuicErrorCode</a>.
   */
  public CronvoyQuicExceptionImpl(String message, int errorCode, int netErrorCode,
                                  int quicDetailedErrorCode) {
    super(message, null);
    mNetworkException = new CronvoyNetworkExceptionImpl(message, errorCode, netErrorCode);
    mQuicDetailedErrorCode = quicDetailedErrorCode;
  }

  @Override
  public String getMessage() {
    StringBuilder b = new StringBuilder(mNetworkException.getMessage());
    b.append(", QuicDetailedErrorCode=").append(mQuicDetailedErrorCode);
    return b.toString();
  }

  @Override
  public int getErrorCode() {
    return mNetworkException.getErrorCode();
  }

  @Override
  public int getCronetInternalErrorCode() {
    return mNetworkException.getCronetInternalErrorCode();
  }

  @Override
  public boolean immediatelyRetryable() {
    return mNetworkException.immediatelyRetryable();
  }

  @Override
  public int getQuicDetailedErrorCode() {
    return mQuicDetailedErrorCode;
  }
}
package org.chromium.net.impl;

import static io.envoyproxy.envoymobile.engine.EnvoyConfiguration.TrustChainVerification.VERIFY_TRUST_CHAIN;

import android.content.Context;
import androidx.annotation.VisibleForTesting;
import com.google.protobuf.Struct;
import io.envoyproxy.envoymobile.engine.AndroidEngineImpl;
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary;
import io.envoyproxy.envoymobile.engine.AndroidNetworkMonitor;
import io.envoyproxy.envoymobile.engine.EnvoyConfiguration;
import io.envoyproxy.envoymobile.engine.EnvoyConfiguration.TrustChainVerification;
import io.envoyproxy.envoymobile.engine.EnvoyEngine;
import io.envoyproxy.envoymobile.engine.EnvoyNativeFilterConfig;
import io.envoyproxy.envoymobile.engine.types.EnvoyEventTracker;
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilterFactory;
import io.envoyproxy.envoymobile.engine.types.EnvoyLogger;
import io.envoyproxy.envoymobile.engine.types.EnvoyOnEngineRunning;
import io.envoyproxy.envoymobile.engine.types.EnvoyStringAccessor;
import io.envoyproxy.envoymobile.engine.types.EnvoyKeyValueStore;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import org.chromium.net.ExperimentalCronetEngine;
import org.chromium.net.ICronetEngineBuilder;

/**
 * Implementation of {@link ICronetEngineBuilder} that builds native Cronvoy engine.
 */
public class NativeCronvoyEngineBuilderImpl extends CronvoyEngineBuilderImpl {

  // TODO(refactor) move unshared variables into their specific methods.
  private final List<EnvoyNativeFilterConfig> nativeFilterChain = new ArrayList<>();
  private final EnvoyEventTracker mEnvoyEventTracker = null;
  private int mConnectTimeoutSeconds = 30;
  private int mDnsRefreshSeconds = 60;
  private int mDnsFailureRefreshSecondsBase = 2;
  private int mDnsFailureRefreshSecondsMax = 10;
  private int mDnsQueryTimeoutSeconds = 25;
  private int mDnsMinRefreshSeconds = 60;
  private List<String> mDnsPreresolveHostnames = Collections.emptyList();
  private boolean mEnableDNSCache = false;
  private int mDnsCacheSaveIntervalSeconds = 1;
  private List<String> mDnsFallbackNameservers = Collections.emptyList();
  private boolean mEnableDnsFilterUnroutableFamilies = true;
  private boolean mDnsUseSystemResolver = true;
  private boolean mEnableDrainPostDnsRefresh = false;
  private boolean mEnableGzipDecompression = true;
  private boolean mEnableSocketTag = true;
  private boolean mEnableInterfaceBinding = false;
  private boolean mEnableProxying = false;
  private int mH2ConnectionKeepaliveIdleIntervalMilliseconds = 1;
  private int mH2ConnectionKeepaliveTimeoutSeconds = 10;
  private int mMaxConnectionsPerHost = 7;
  private int mStreamIdleTimeoutSeconds = 15;
  private int mPerTryIdleTimeoutSeconds = 15;
  private String mAppVersion = "unspecified";
  private String mAppId = "unspecified";
  private TrustChainVerification mTrustChainVerification = VERIFY_TRUST_CHAIN;
  private boolean mEnablePlatformCertificatesValidation = true;
  private String mNodeId = "";
  private String mNodeRegion = "";
  private String mNodeZone = "";
  private String mNodeSubZone = "";

  /**
   * Builder for Native Cronet Engine. Default config enables SPDY, disables QUIC and HTTP cache.
   *
   * @param context Android {@link Context} for engine to use.
   */
  public NativeCronvoyEngineBuilderImpl(Context context) { super(context); }

  /**
   * Indicates to skip the TLS certificate verification.
   *
   * @return the builder to facilitate chaining.
   */
  @VisibleForTesting
  public CronvoyEngineBuilderImpl setMockCertVerifierForTesting() {
    mTrustChainVerification = TrustChainVerification.ACCEPT_UNTRUSTED;
    return this;
  }

  /**
   * Adds url interceptors to the cronetEngine
   *
   * @return the builder to facilitate chaining.
   */
  @VisibleForTesting
  public CronvoyEngineBuilderImpl addUrlInterceptorsForTesting() {
    nativeFilterChain.add(new EnvoyNativeFilterConfig(
        "envoy.filters.http.test_read",
        "{\"@type\": type.googleapis.com/envoymobile.test.integration.filters.http.test_read.TestRead}"));
    return this;
  }

  @Override
  public ExperimentalCronetEngine build() {
    if (getUserAgent() == null) {
      setUserAgent(getDefaultUserAgent());
    }
    return new CronvoyUrlRequestContext(this);
  }

  EnvoyEngine createEngine(EnvoyOnEngineRunning onEngineRunning, EnvoyLogger envoyLogger,
                           String logLevel) {
    AndroidEngineImpl engine = new AndroidEngineImpl(getContext(), onEngineRunning, envoyLogger,
                                                     mEnvoyEventTracker, mEnableProxying);
    AndroidJniLibrary.load(getContext());
    AndroidNetworkMonitor.load(getContext(), engine);
    engine.runWithConfig(createEnvoyConfiguration(), logLevel);
    return engine;
  }

  private EnvoyConfiguration createEnvoyConfiguration() {
    List<EnvoyHTTPFilterFactory> platformFilterChain = Collections.emptyList();
    Map<String, EnvoyStringAccessor> stringAccessors = Collections.emptyMap();
    Map<String, EnvoyKeyValueStore> keyValueStores = Collections.emptyMap();
    Map<String, Boolean> runtimeGuards = Collections.emptyMap();

    return new EnvoyConfiguration(
        mConnectTimeoutSeconds, mDnsRefreshSeconds, mDnsFailureRefreshSecondsBase,
        mDnsFailureRefreshSecondsMax, mDnsQueryTimeoutSeconds, mDnsMinRefreshSeconds,
        mDnsPreresolveHostnames, mEnableDNSCache, mDnsCacheSaveIntervalSeconds,
        mEnableDrainPostDnsRefresh, quicEnabled(), quicConnectionOptions(),
        quicClientConnectionOptions(), quicHints(), quicCanonicalSuffixes(),
        mEnableGzipDecompression, brotliEnabled(), mEnableSocketTag, mEnableInterfaceBinding,
        mH2ConnectionKeepaliveIdleIntervalMilliseconds, mH2ConnectionKeepaliveTimeoutSeconds,
        mMaxConnectionsPerHost, mStreamIdleTimeoutSeconds, mPerTryIdleTimeoutSeconds, mAppVersion,
        mAppId, mTrustChainVerification, nativeFilterChain, platformFilterChain, stringAccessors,
        keyValueStores, runtimeGuards, mEnablePlatformCertificatesValidation,
        /*rtdsResourceName=*/"", /*rtdsTimeoutSeconds=*/0, /*xdsAddress=*/"",
        /*xdsPort=*/0, /*xdsGrpcInitialMetadata=*/Collections.emptyMap(),
        /*xdsSslRootCerts=*/"", mNodeId, mNodeRegion, mNodeZone, mNodeSubZone,
        Struct.getDefaultInstance(), /*cdsResourcesLocator=*/"", /*cdsTimeoutSeconds=*/0,
        /*enableCds=*/false);
  }
}
package org.chromium.net.impl;

import androidx.annotation.Nullable;
import java.util.Date;
import org.chromium.net.RequestFinishedInfo;

/**
 * Implementation of {@link RequestFinishedInfo.Metrics}.
 */
public final class CronvoyMetrics extends RequestFinishedInfo.Metrics {
  private final long mRequestStartMs;
  private final long mDnsStartMs;
  private final long mDnsEndMs;
  private final long mConnectStartMs;
  private final long mConnectEndMs;
  private final long mSslStartMs;
  private final long mSslEndMs;
  private final long mSendingStartMs;
  private final long mSendingEndMs;
  private final long mPushStartMs;
  private final long mPushEndMs;
  private final long mResponseStartMs;
  private final long mRequestEndMs;
  private final boolean mSocketReused;

  @Nullable private final Long mTtfbMs;
  @Nullable private final Long mTotalTimeMs;
  @Nullable private final Long mSentByteCount;
  @Nullable private final Long mReceivedByteCount;

  @Nullable
  private static Date toDate(long timestamp) {
    if (timestamp != -1) {
      return new Date(timestamp);
    }
    return null;
  }

  private static boolean checkOrder(long start, long end) {
    // If end doesn't exist, start can be anything, including also not existing
    // If end exists, start must also exist and be before end
    return (end >= start && start != -1) || end == -1;
  }

  /** New-style constructor */
  public CronvoyMetrics(long requestStartMs, long dnsStartMs, long dnsEndMs, long connectStartMs,
                        long connectEndMs, long sslStartMs, long sslEndMs, long sendingStartMs,
                        long sendingEndMs, long pushStartMs, long pushEndMs, long responseStartMs,
                        long requestEndMs, boolean socketReused, long sentByteCount,
                        long receivedByteCount) {
    // Check that no end times are before corresponding start times,
    // or exist when start time doesn't.
    assert checkOrder(dnsStartMs, dnsEndMs);
    assert checkOrder(connectStartMs, connectEndMs);
    assert checkOrder(sslStartMs, sslEndMs);
    assert checkOrder(sendingStartMs, sendingEndMs);
    assert checkOrder(pushStartMs, pushEndMs);
    // requestEnd always exists, so just check that it's after start
    assert requestEndMs >= responseStartMs;
    // Spot-check some of the other orderings
    assert dnsStartMs >= requestStartMs || dnsStartMs == -1;
    assert sendingStartMs >= requestStartMs || sendingStartMs == -1;
    assert sslStartMs >= connectStartMs || sslStartMs == -1;
    assert responseStartMs >= sendingStartMs || responseStartMs == -1;
    mRequestStartMs = requestStartMs;
    mDnsStartMs = dnsStartMs;
    mDnsEndMs = dnsEndMs;
    mConnectStartMs = connectStartMs;
    mConnectEndMs = connectEndMs;
    mSslStartMs = sslStartMs;
    mSslEndMs = sslEndMs;
    mSendingStartMs = sendingStartMs;
    mSendingEndMs = sendingEndMs;
    mPushStartMs = pushStartMs;
    mPushEndMs = pushEndMs;
    mResponseStartMs = responseStartMs;
    mRequestEndMs = requestEndMs;
    mSocketReused = socketReused;
    mSentByteCount = sentByteCount;
    mReceivedByteCount = receivedByteCount;

    if (requestStartMs != -1 && responseStartMs != -1) {
      mTtfbMs = responseStartMs - requestStartMs;
    } else {
      mTtfbMs = null;
    }
    if (requestStartMs != -1 && requestEndMs != -1) {
      mTotalTimeMs = requestEndMs - requestStartMs;
    } else {
      mTotalTimeMs = null;
    }
  }

  @Nullable
  @Override
  public Date getRequestStart() {
    return toDate(mRequestStartMs);
  }

  @Nullable
  @Override
  public Date getDnsStart() {
    return toDate(mDnsStartMs);
  }

  @Nullable
  @Override
  public Date getDnsEnd() {
    return toDate(mDnsEndMs);
  }

  @Nullable
  @Override
  public Date getConnectStart() {
    return toDate(mConnectStartMs);
  }

  @Nullable
  @Override
  public Date getConnectEnd() {
    return toDate(mConnectEndMs);
  }

  @Nullable
  @Override
  public Date getSslStart() {
    return toDate(mSslStartMs);
  }

  @Nullable
  @Override
  public Date getSslEnd() {
    return toDate(mSslEndMs);
  }

  @Nullable
  @Override
  public Date getSendingStart() {
    return toDate(mSendingStartMs);
  }

  @Nullable
  @Override
  public Date getSendingEnd() {
    return toDate(mSendingEndMs);
  }

  @Nullable
  @Override
  public Date getPushStart() {
    return toDate(mPushStartMs);
  }

  @Nullable
  @Override
  public Date getPushEnd() {
    return toDate(mPushEndMs);
  }

  @Nullable
  @Override
  public Date getResponseStart() {
    return toDate(mResponseStartMs);
  }

  @Nullable
  @Override
  public Date getRequestEnd() {
    return toDate(mRequestEndMs);
  }

  @Override
  public boolean getSocketReused() {
    return mSocketReused;
  }

  @Nullable
  @Override
  public Long getTtfbMs() {
    return mTtfbMs;
  }

  @Nullable
  @Override
  public Long getTotalTimeMs() {
    return mTotalTimeMs;
  }

  @Nullable
  @Override
  public Long getSentByteCount() {
    return mSentByteCount;
  }

  @Nullable
  @Override
  public Long getReceivedByteCount() {
    return mReceivedByteCount;
  }
}
package org.chromium.net.impl;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.concurrent.Executor;
import org.chromium.net.BidirectionalStream;
import org.chromium.net.CronetEngine;
import org.chromium.net.CronetException;
import org.chromium.net.NetworkQualityRttListener;
import org.chromium.net.NetworkQualityThroughputListener;
import org.chromium.net.RequestFinishedInfo;
import org.chromium.net.UploadDataProvider;
import org.chromium.net.UploadDataSink;
import org.chromium.net.UrlRequest;
import org.chromium.net.UrlResponseInfo;

/**
 * This class contains wrapper classes for all Cronet API callback/listener classes. These classes
 * only permit callbacks that the version of the client API is known to support. For example, if
 * version 2 of the API adds a callback onFoo() but the client API this class is implementing is
 * version 1, these wrapper classes should not call {@code mWrappedCallback.onFoo()} and should
 * instead silently drop the callback.
 *
 * When adding any callback wrapping here, be sure you add the proper version check. Only callbacks
 * supported in all versions of the API should forgo a version check.
 */
public class CronvoyVersionSafeCallbacks {
  /**
   * Wrap a {@link UrlRequest.Callback} in a version safe manner.
   */
  public static final class UrlRequestCallback extends UrlRequest.Callback {
    private final UrlRequest.Callback mWrappedCallback;

    public UrlRequestCallback(UrlRequest.Callback callback) { mWrappedCallback = callback; }

    @Override
    public void onRedirectReceived(UrlRequest request, UrlResponseInfo info, String newLocationUrl)
        throws Exception {
      mWrappedCallback.onRedirectReceived(request, info, newLocationUrl);
    }

    @Override
    public void onResponseStarted(UrlRequest request, UrlResponseInfo info) throws Exception {
      mWrappedCallback.onResponseStarted(request, info);
    }

    @Override
    public void onReadCompleted(UrlRequest request, UrlResponseInfo info, ByteBuffer byteBuffer)
        throws Exception {
      mWrappedCallback.onReadCompleted(request, info, byteBuffer);
    }

    @Override
    public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
      mWrappedCallback.onSucceeded(request, info);
    }

    @Override
    public void onFailed(UrlRequest request, UrlResponseInfo info, CronetException error) {
      mWrappedCallback.onFailed(request, info, error);
    }

    @Override
    public void onCanceled(UrlRequest request, UrlResponseInfo info) {
      mWrappedCallback.onCanceled(request, info);
    }
  }

  /**
   * Wrap a {@link UrlRequest.StatusListener} in a version safe manner.
   */
  public static final class UrlRequestStatusListener extends UrlRequest.StatusListener {
    private final UrlRequest.StatusListener mWrappedListener;

    public UrlRequestStatusListener(UrlRequest.StatusListener listener) {
      mWrappedListener = listener;
    }

    @Override
    public void onStatus(int status) {
      mWrappedListener.onStatus(status);
    }
  }

  /**
   * Wrap a {@link BidirectionalStream.Callback} in a version safe manner.
   */
  public static final class BidirectionalStreamCallback extends BidirectionalStream.Callback {
    private final BidirectionalStream.Callback mWrappedCallback;

    public BidirectionalStreamCallback(BidirectionalStream.Callback callback) {
      mWrappedCallback = callback;
    }

    @Override
    public void onStreamReady(BidirectionalStream stream) {
      mWrappedCallback.onStreamReady(stream);
    }

    @Override
    public void onResponseHeadersReceived(BidirectionalStream stream, UrlResponseInfo info) {
      mWrappedCallback.onResponseHeadersReceived(stream, info);
    }

    @Override
    public void onReadCompleted(BidirectionalStream stream, UrlResponseInfo info, ByteBuffer buffer,
                                boolean endOfStream) {
      mWrappedCallback.onReadCompleted(stream, info, buffer, endOfStream);
    }

    @Override
    public void onWriteCompleted(BidirectionalStream stream, UrlResponseInfo info,
                                 ByteBuffer buffer, boolean endOfStream) {
      mWrappedCallback.onWriteCompleted(stream, info, buffer, endOfStream);
    }

    @Override
    public void onResponseTrailersReceived(BidirectionalStream stream, UrlResponseInfo info,
                                           UrlResponseInfo.HeaderBlock trailers) {
      mWrappedCallback.onResponseTrailersReceived(stream, info, trailers);
    }

    @Override
    public void onSucceeded(BidirectionalStream stream, UrlResponseInfo info) {
      mWrappedCallback.onSucceeded(stream, info);
    }

    @Override
    public void onFailed(BidirectionalStream stream, UrlResponseInfo info, CronetException error) {
      mWrappedCallback.onFailed(stream, info, error);
    }

    @Override
    public void onCanceled(BidirectionalStream stream, UrlResponseInfo info) {
      mWrappedCallback.onCanceled(stream, info);
    }
  }

  /**
   * Wrap a {@link UploadDataProvider} in a version safe manner.
   */
  public static final class UploadDataProviderWrapper extends UploadDataProvider {
    private final UploadDataProvider mWrappedProvider;

    public UploadDataProviderWrapper(UploadDataProvider provider) { mWrappedProvider = provider; }

    @Override
    public long getLength() throws IOException {
      return mWrappedProvider.getLength();
    }

    @Override
    public void read(UploadDataSink uploadDataSink, ByteBuffer byteBuffer) throws IOException {
      mWrappedProvider.read(uploadDataSink, byteBuffer);
    }

    @Override
    public void rewind(UploadDataSink uploadDataSink) throws IOException {
      mWrappedProvider.rewind(uploadDataSink);
    }

    @Override
    public void close() throws IOException {
      mWrappedProvider.close();
    }
  }

  /**
   * Wrap a {@link RequestFinishedInfo.Listener} in a version safe manner.
   */
  public static final class RequestFinishedInfoListener extends RequestFinishedInfo.Listener {
    private final RequestFinishedInfo.Listener mWrappedListener;

    public RequestFinishedInfoListener(RequestFinishedInfo.Listener listener) {
      super(listener.getExecutor());
      mWrappedListener = listener;
    }

    @Override
    public void onRequestFinished(RequestFinishedInfo requestInfo) {
      mWrappedListener.onRequestFinished(requestInfo);
    }

    @Override
    public Executor getExecutor() {
      return mWrappedListener.getExecutor();
    }
  }

  /**
   * Wrap a {@link NetworkQualityRttListener} in a version safe manner.
   * NOTE(pauljensen): Delegates equals() and hashCode() to wrapped listener to
   * facilitate looking up by wrapped listener in an ArrayList.indexOf().
   */
  public static final class NetworkQualityRttListenerWrapper extends NetworkQualityRttListener {
    private final NetworkQualityRttListener mWrappedListener;

    public NetworkQualityRttListenerWrapper(NetworkQualityRttListener listener) {
      super(listener.getExecutor());
      mWrappedListener = listener;
    }

    @Override
    public void onRttObservation(int rttMs, long whenMs, int source) {
      mWrappedListener.onRttObservation(rttMs, whenMs, source);
    }

    @Override
    public Executor getExecutor() {
      return mWrappedListener.getExecutor();
    }

    @Override
    public int hashCode() {
      return mWrappedListener.hashCode();
    }

    @Override
    public boolean equals(Object o) {
      if (o == null || !(o instanceof NetworkQualityRttListenerWrapper)) {
        return false;
      }
      return mWrappedListener.equals(((NetworkQualityRttListenerWrapper)o).mWrappedListener);
    }
  }

  /**
   * Wrap a {@link NetworkQualityThroughputListener} in a version safe manner.
   * NOTE(pauljensen): Delegates equals() and hashCode() to wrapped listener to
   * facilitate looking up by wrapped listener in an ArrayList.indexOf().
   */
  public static final class NetworkQualityThroughputListenerWrapper
      extends NetworkQualityThroughputListener {
    private final NetworkQualityThroughputListener mWrappedListener;

    public NetworkQualityThroughputListenerWrapper(NetworkQualityThroughputListener listener) {
      super(listener.getExecutor());
      mWrappedListener = listener;
    }

    @Override
    public void onThroughputObservation(int throughputKbps, long whenMs, int source) {
      mWrappedListener.onThroughputObservation(throughputKbps, whenMs, source);
    }

    @Override
    public Executor getExecutor() {
      return mWrappedListener.getExecutor();
    }

    @Override
    public int hashCode() {
      return mWrappedListener.hashCode();
    }

    @Override
    public boolean equals(Object o) {
      if (o == null || !(o instanceof NetworkQualityThroughputListenerWrapper)) {
        return false;
      }
      return mWrappedListener.equals(((NetworkQualityThroughputListenerWrapper)o).mWrappedListener);
    }
  }

  /**
   * Wrap a {@link CronetEngine.Builder.LibraryLoader} in a version safe manner.
   */
  public static final class LibraryLoader extends CronetEngine.Builder.LibraryLoader {
    private final CronetEngine.Builder.LibraryLoader mWrappedLoader;

    public LibraryLoader(CronetEngine.Builder.LibraryLoader libraryLoader) {
      mWrappedLoader = libraryLoader;
    }

    @Override
    public void loadLibrary(String libName) {
      mWrappedLoader.loadLibrary(libName);
    }
  }
}
package org.chromium.net.impl;

import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
import static android.os.Process.THREAD_PRIORITY_MORE_FAVORABLE;

import android.os.ConditionVariable;
import androidx.annotation.GuardedBy;
import androidx.annotation.VisibleForTesting;
import io.envoyproxy.envoymobile.engine.EnvoyEngine;
import java.io.IOException;
import java.net.Proxy;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLStreamHandlerFactory;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import org.chromium.net.BidirectionalStream;
import org.chromium.net.ExperimentalBidirectionalStream;
import org.chromium.net.NetworkQualityRttListener;
import org.chromium.net.NetworkQualityThroughputListener;
import org.chromium.net.RequestFinishedInfo;
import org.chromium.net.UrlRequest;
import org.chromium.net.impl.CronvoyVersionSafeCallbacks.RequestFinishedInfoListener;
import org.chromium.net.urlconnection.CronvoyHttpURLConnection;
import org.chromium.net.urlconnection.CronvoyURLStreamHandlerFactory;

/**
 * Cronvoy engine shim.
 *
 * <p>Does not support Cronet-compatible netlogs, transferred data measurement, bidistream, cache,
 * or priority.
 */
public final class CronvoyUrlRequestContext extends CronvoyEngineBase {

  static final String LOG_TAG = CronvoyUrlRequestContext.class.getSimpleName();

  /**
   * Synchronize access to mUrlRequestContextAdapter and shutdown routine.
   */
  private final Object mLock = new Object();
  private final ConditionVariable mInitCompleted = new ConditionVariable(false);
  private final AtomicInteger mActiveRequestCount = new AtomicInteger(0);
  private EnvoyEngine.LogLevel mLogLevel = EnvoyEngine.LogLevel.OFF;

  @GuardedBy("mLock") private EnvoyEngine mEngine;
  /**
   * This field is accessed without synchronization, but only for the purposes of reference
   * equality comparison with other threads. If such a comparison is performed on the network
   * thread, then there is a happens-before edge between the write of this field and the
   * subsequent read; if it's performed on another thread, then observing a value of null won't
   * change the result of the comparison.
   */
  private Thread mNetworkThread;

  private final String mUserAgent;
  private final AtomicReference<Runnable> mInitializationCompleter = new AtomicReference<>();
  private final CronvoyLogger mCronvoyLogger = new CronvoyLogger();

  /**
   * Locks operations on the list of RequestFinishedInfo.Listeners, because operations can happen
   * on any thread. This should be used for fine-grained locking only. In particular, don't call
   * any UrlRequest methods that acquire mUrlRequestAdapterLock while holding this lock.
   */
  private final Object mFinishedListenerLock = new Object();
  @GuardedBy("mFinishedListenerLock")
  private final Map<RequestFinishedInfo.Listener,
                    CronvoyVersionSafeCallbacks.RequestFinishedInfoListener> mFinishedListenerMap =
      new HashMap<>();

  public CronvoyUrlRequestContext(NativeCronvoyEngineBuilderImpl builder) {
    // On android, all background threads (and all threads that are part
    // of background processes) are put in a cgroup that is allowed to
    // consume up to 5% of CPU - these worker threads spend the vast
    // majority of their time waiting on I/O, so making them contend with
    // background applications for a slice of CPU doesn't make much sense.
    // We want to hurry up and get idle.
    final int threadPriority =
        builder.threadPriority(THREAD_PRIORITY_BACKGROUND + THREAD_PRIORITY_MORE_FAVORABLE);
    mUserAgent = builder.getUserAgent();
    synchronized (mLock) {

      mEngine = builder.createEngine(() -> {
        mNetworkThread = Thread.currentThread();
        android.os.Process.setThreadPriority(threadPriority);
        mInitCompleted.open();
        Runnable taskToExecuteWhenInitializationIsCompleted =
            mInitializationCompleter.getAndSet(() -> {});
        if (taskToExecuteWhenInitializationIsCompleted != null) {
          taskToExecuteWhenInitializationIsCompleted.run();
        }
        return null;
      }, mCronvoyLogger, mLogLevel.toString().toLowerCase());
    }
    mInitCompleted.block();
  }

  public EnvoyEngine getEnvoyEngine() {
    synchronized (mLock) {
      if (mEngine == null) {
        throw new IllegalStateException("Engine is shut down.");
      }
      return mEngine;
    }
  }

  void setTaskToExecuteWhenInitializationIsCompleted(Runnable runnable) {
    if (!mInitializationCompleter.compareAndSet(null, runnable)) {
      // The fact that the initializationCompleter was not null implies that the initialization
      // callback has already been executed. In this case, execute the task now - nothing else will
      // ever execute it otherwise.
      runnable.run();
    }
  }

  @Override
  public CronvoyUrlRequestBase
  createRequest(String url, UrlRequest.Callback callback, Executor executor, int priority,
                Collection<Object> requestAnnotations, boolean disableCache,
                boolean disableConnectionMigration, boolean allowDirectExecutor,
                boolean trafficStatsTagSet, int trafficStatsTag, boolean trafficStatsUidSet,
                int trafficStatsUid, RequestFinishedInfo.Listener requestFinishedListener,
                int idempotency) {
    synchronized (mLock) {
      checkHaveAdapter();
      return new CronvoyUrlRequest(this, url, callback, executor, mUserAgent, allowDirectExecutor,
                                   requestAnnotations, trafficStatsTagSet, trafficStatsTag,
                                   trafficStatsUidSet, trafficStatsUid, requestFinishedListener);
    }
  }

  @Override
  protected ExperimentalBidirectionalStream
  createBidirectionalStream(String url, BidirectionalStream.Callback callback, Executor executor,
                            String httpMethod, List<Map.Entry<String, String>> requestHeaders,
                            @StreamPriority int priority,
                            boolean delayRequestHeadersUntilFirstFlush,
                            Collection<Object> requestAnnotations, boolean trafficStatsTagSet,
                            int trafficStatsTag, boolean trafficStatsUidSet, int trafficStatsUid) {
    synchronized (mLock) {
      checkHaveAdapter();
      return new CronvoyBidirectionalStream(
          this, url, priority, callback, executor, mUserAgent, httpMethod, requestHeaders,
          delayRequestHeadersUntilFirstFlush, requestAnnotations, trafficStatsTagSet,
          trafficStatsTag, trafficStatsUidSet, trafficStatsUid);
    }
  }

  @Override
  public ExperimentalBidirectionalStream.Builder
  newBidirectionalStreamBuilder(String url, BidirectionalStream.Callback callback,
                                Executor executor) {
    return new CronvoyBidirectionalStreamBuilderImpl(url, callback, executor, this);
  }

  @Override
  public String getVersionString() {
    return "Cronet/" + CronvoyImplVersion.getCronetVersionWithLastChange();
  }

  @Override
  public void shutdown() {
    synchronized (mLock) {
      if (mEngine == null) {
        return; // Already shut down.
      }
      checkHaveAdapter();
      if (mActiveRequestCount.get() != 0) {
        throw new IllegalStateException("Cannot shutdown with active requests.");
      }
      // Destroying adapter stops the network thread, so it cannot be
      // called on network thread.
      if (Thread.currentThread() == mNetworkThread) {
        throw new IllegalThreadStateException("Cannot shutdown from network thread.");
      }
    }
    // Wait for init to complete on init and network thread (without lock,
    // so other thread could access it).
    mInitCompleted.block();

    // If not logging, this is a no-op.
    stopNetLog();

    synchronized (mLock) {
      // It is possible that adapter is already destroyed on another thread.
      if (!haveRequestContextAdapter()) {
        return;
      }
      mEngine.terminate();
      mEngine = null;
    }
  }

  @Override
  public void startNetLogToFile(String fileName, boolean logAll) throws IllegalStateException {
    synchronized (mLock) {
      if (mEngine == null) {
        throw new IllegalStateException("Engine is shut down.");
      }
      mCronvoyLogger.setNetLogToFile(fileName);
      // Turn up logging
      if (logAll) {
        mLogLevel = EnvoyEngine.LogLevel.TRACE;
      } else {
        mLogLevel = EnvoyEngine.LogLevel.DEBUG;
      }
      mEngine.setLogLevel(mLogLevel);
    }
  }

  @Override
  public void startNetLogToDisk(String dirPath, boolean logAll, int maxSize)
      throws IllegalStateException {
    synchronized (mLock) {
      if (mEngine == null) {
        throw new IllegalStateException("Engine is shut down.");
      }
      mCronvoyLogger.setNetLogToDisk(dirPath, maxSize);
      // Turn up logging
      if (logAll) {
        mLogLevel = EnvoyEngine.LogLevel.TRACE;
      } else {
        mLogLevel = EnvoyEngine.LogLevel.DEBUG;
      }
      mEngine.setLogLevel(mLogLevel);
    }
  }

  @Override
  public void stopNetLog() {
    synchronized (mLock) {
      mLogLevel = EnvoyEngine.LogLevel.OFF;
      if (mEngine != null) {
        mEngine.setLogLevel(EnvoyEngine.LogLevel.OFF);
      }
    }
    mCronvoyLogger.stopLogging();
  }

  @Override
  public byte[] getGlobalMetricsDeltas() {
    return new byte[0];
  }

  @Override
  public int getEffectiveConnectionType() {
    return EFFECTIVE_CONNECTION_TYPE_UNKNOWN;
  }

  @Override
  public int getHttpRttMs() {
    return CONNECTION_METRIC_UNKNOWN;
  }

  @Override
  public int getTransportRttMs() {
    return CONNECTION_METRIC_UNKNOWN;
  }

  @Override
  public int getDownstreamThroughputKbps() {
    return CONNECTION_METRIC_UNKNOWN;
  }

  @Override
  public void configureNetworkQualityEstimatorForTesting(boolean useLocalHostRequests,
                                                         boolean useSmallerResponses,
                                                         boolean disableOfflineCheck) {}

  @Override
  public void addRttListener(NetworkQualityRttListener listener) {}

  @Override
  public void removeRttListener(NetworkQualityRttListener listener) {}

  @Override
  public void addThroughputListener(NetworkQualityThroughputListener listener) {}

  @Override
  public void removeThroughputListener(NetworkQualityThroughputListener listener) {}

  @Override
  public void addRequestFinishedListener(RequestFinishedInfo.Listener listener) {
    synchronized (mFinishedListenerLock) {
      mFinishedListenerMap.put(
          listener, new CronvoyVersionSafeCallbacks.RequestFinishedInfoListener(listener));
    }
  }

  @Override
  public void removeRequestFinishedListener(RequestFinishedInfo.Listener listener) {
    synchronized (mFinishedListenerLock) { mFinishedListenerMap.remove(listener); }
  }

  boolean hasRequestFinishedListener() {
    synchronized (mFinishedListenerLock) { return !mFinishedListenerMap.isEmpty(); }
  }

  @Override
  public URLConnection openConnection(URL url) throws IOException {
    return openConnection(url, Proxy.NO_PROXY);
  }

  @Override
  public URLConnection openConnection(URL url, Proxy proxy) {
    if (proxy.type() != Proxy.Type.DIRECT) {
      throw new UnsupportedOperationException();
    }
    String protocol = url.getProtocol();
    if ("http".equals(protocol) || "https".equals(protocol)) {
      return new CronvoyHttpURLConnection(url, this);
    }
    throw new UnsupportedOperationException("Unexpected protocol:" + protocol);
  }

  @Override
  public URLStreamHandlerFactory createURLStreamHandlerFactory() {
    return new CronvoyURLStreamHandlerFactory(this);
  }

  /**
   * Mark request as started to prevent shutdown when there are active
   * requests.
   */
  void onRequestStarted() { mActiveRequestCount.incrementAndGet(); }

  /**
   * Mark request as finished to allow shutdown when there are no active
   * requests.
   */
  void onRequestDestroyed() { mActiveRequestCount.decrementAndGet(); }

  boolean isNetworkThread(Thread thread) { return thread == mNetworkThread; }

  @VisibleForTesting
  public boolean hasShutdown() {
    synchronized (mLock) { return !haveRequestContextAdapter(); }
  }

  @GuardedBy("mLock")
  private void checkHaveAdapter() throws IllegalStateException {
    if (!haveRequestContextAdapter()) {
      throw new IllegalStateException("Engine is shut down.");
    }
  }

  @GuardedBy("mLock")
  private boolean haveRequestContextAdapter() {
    return mEngine != null;
  }

  void reportRequestFinished(final RequestFinishedInfo requestInfo) {
    List<RequestFinishedInfoListener> currentListeners;
    synchronized (mFinishedListenerLock) {
      if (mFinishedListenerMap.isEmpty()) {
        return;
      }
      currentListeners = new ArrayList<>(mFinishedListenerMap.values());
    }
    for (final CronvoyVersionSafeCallbacks.RequestFinishedInfoListener listener :
         currentListeners) {
      Runnable task = new Runnable() {
        @Override
        public void run() {
          listener.onRequestFinished(requestInfo);
        }
      };
      postObservationTaskToExecutor(listener.getExecutor(), task);
    }
  }

  private static void postObservationTaskToExecutor(Executor executor, Runnable task) {
    try {
      executor.execute(task);
    } catch (RejectedExecutionException failException) {
      // TODO(https://github.com/envoyproxy/envoy-mobile/issues/2262): go with Cronet ways for logs.
      android.util.Log.e(CronvoyUrlRequestContext.LOG_TAG, "Exception posting task to executor",
                         failException);
    }
  }
}
package org.chromium.net.impl;

import java.nio.ByteBuffer;

/**
 * Utility class to check preconditions.
 */
public final class CronvoyPreconditions {

  public static void checkDirect(ByteBuffer buffer) {
    if (!buffer.isDirect()) {
      throw new IllegalArgumentException("byteBuffer must be a direct ByteBuffer.");
    }
  }

  public static void checkHasRemaining(ByteBuffer buffer) {
    if (!buffer.hasRemaining()) {
      throw new IllegalArgumentException("ByteBuffer is already full.");
    }
  }

  private CronvoyPreconditions() {}
}
package org.chromium.net.impl;

import android.util.Log;
import android.util.Pair;
import java.util.ArrayList;
import java.util.Collection;
import java.util.concurrent.Executor;
import org.chromium.net.CronetEngine;
import org.chromium.net.ExperimentalUrlRequest;
import org.chromium.net.RequestFinishedInfo;
import org.chromium.net.UploadDataProvider;
import org.chromium.net.UrlRequest;

/**
 * Implements {@link org.chromium.net.ExperimentalUrlRequest.Builder}.
 */
public class CronvoyUrlRequestBuilderImpl extends ExperimentalUrlRequest.Builder {
  private static final String ACCEPT_ENCODING = "Accept-Encoding";
  private static final String TAG = CronvoyUrlRequestBuilderImpl.class.getSimpleName();

  // All fields are temporary storage of ExperimentalUrlRequest configuration to be
  // copied to built ExperimentalUrlRequest.

  // CronetEngineBase to execute request.
  private final CronvoyEngineBase mCronetEngine;
  // URL to request.
  private final String mUrl;
  // Callback to receive progress callbacks.
  private final UrlRequest.Callback mCallback;
  // Executor to invoke callback on.
  private final Executor mExecutor;
  // HTTP method (e.g. GET, POST etc).
  private String mMethod;

  // List of request headers, stored as header field name and value pairs.
  private final ArrayList<Pair<String, String>> mRequestHeaders = new ArrayList<>();
  // Disable the cache for just this request.
  private boolean mDisableCache;
  // Disable connection migration for just this request.
  private boolean mDisableConnectionMigration;
  // Priority of request. Default is medium.
  @CronvoyEngineBase.RequestPriority private int mPriority = REQUEST_PRIORITY_MEDIUM;
  // Request reporting annotations. Avoid extra object creation if no annotations added.
  private Collection<Object> mRequestAnnotations;
  // If request is an upload, this provides the request body data.
  private UploadDataProvider mUploadDataProvider;
  // Executor to call upload data provider back on.
  private Executor mUploadDataProviderExecutor;
  private boolean mAllowDirectExecutor;
  private boolean mTrafficStatsTagSet;
  private int mTrafficStatsTag;
  private boolean mTrafficStatsUidSet;
  private int mTrafficStatsUid;
  private RequestFinishedInfo.Listener mRequestFinishedListener;
  // Idempotency of the request.
  @CronvoyEngineBase.Idempotency private int mIdempotency = DEFAULT_IDEMPOTENCY;

  /**
   * Creates a builder for {@link UrlRequest} objects. All callbacks for
   * generated {@link UrlRequest} objects will be invoked on
   * {@code executor}'s thread. {@code executor} must not run tasks on the
   * current thread to prevent blocking networking operations and causing
   * exceptions during shutdown.
   *
   * @param url URL for the generated requests.
   * @param callback callback object that gets invoked on different events.
   * @param executor {@link Executor} on which all callbacks will be invoked.
   * @param cronetEngine {@link CronetEngine} used to execute this request.
   */
  CronvoyUrlRequestBuilderImpl(String url, UrlRequest.Callback callback, Executor executor,
                               CronvoyEngineBase cronetEngine) {
    super();
    if (url == null) {
      throw new NullPointerException("URL is required.");
    }
    if (callback == null) {
      throw new NullPointerException("Callback is required.");
    }
    if (executor == null) {
      throw new NullPointerException("Executor is required.");
    }
    if (cronetEngine == null) {
      throw new NullPointerException("CronetEngine is required.");
    }
    mUrl = url;
    mCallback = callback;
    mExecutor = executor;
    mCronetEngine = cronetEngine;
  }

  @Override
  public ExperimentalUrlRequest.Builder setHttpMethod(String method) {
    if (method == null) {
      throw new NullPointerException("Method is required.");
    }
    mMethod = method;
    return this;
  }

  @Override
  public CronvoyUrlRequestBuilderImpl addHeader(String header, String value) {
    if (header == null) {
      throw new NullPointerException("Invalid header name.");
    }
    if (value == null) {
      throw new NullPointerException("Invalid header value.");
    }
    if (ACCEPT_ENCODING.equalsIgnoreCase(header)) {
      Log.w(TAG,
            "It's not necessary to set Accept-Encoding on requests - cronet will do"
                + " this automatically for you, and setting it yourself has no "
                + "effect. See https://crbug.com/581399 for details.",
            new Exception());
      return this;
    }
    mRequestHeaders.add(Pair.create(header, value));
    return this;
  }

  @Override
  public CronvoyUrlRequestBuilderImpl disableCache() {
    mDisableCache = true;
    return this;
  }

  @Override
  public CronvoyUrlRequestBuilderImpl disableConnectionMigration() {
    mDisableConnectionMigration = true;
    return this;
  }

  @Override
  public CronvoyUrlRequestBuilderImpl setPriority(@CronvoyEngineBase.RequestPriority int priority) {
    mPriority = priority;
    return this;
  }

  @Override
  public CronvoyUrlRequestBuilderImpl
  setIdempotency(@CronvoyEngineBase.Idempotency int idempotency) {
    mIdempotency = idempotency;
    return this;
  }

  @Override
  public CronvoyUrlRequestBuilderImpl setUploadDataProvider(UploadDataProvider uploadDataProvider,
                                                            Executor executor) {
    if (uploadDataProvider == null) {
      throw new NullPointerException("Invalid UploadDataProvider.");
    }
    if (executor == null) {
      throw new NullPointerException("Invalid UploadDataProvider Executor.");
    }
    if (mMethod == null) {
      mMethod = "POST";
    }
    mUploadDataProvider = uploadDataProvider;
    mUploadDataProviderExecutor = executor;
    return this;
  }

  @Override
  public CronvoyUrlRequestBuilderImpl allowDirectExecutor() {
    mAllowDirectExecutor = true;
    return this;
  }

  @Override
  public CronvoyUrlRequestBuilderImpl addRequestAnnotation(Object annotation) {
    if (annotation == null) {
      throw new NullPointerException("Invalid metrics annotation.");
    }
    if (mRequestAnnotations == null) {
      mRequestAnnotations = new ArrayList<>();
    }
    mRequestAnnotations.add(annotation);
    return this;
  }

  @Override
  public CronvoyUrlRequestBuilderImpl setTrafficStatsTag(int tag) {
    mTrafficStatsTagSet = true;
    mTrafficStatsTag = tag;
    return this;
  }

  @Override
  public CronvoyUrlRequestBuilderImpl setTrafficStatsUid(int uid) {
    mTrafficStatsUidSet = true;
    mTrafficStatsUid = uid;
    return this;
  }

  @Override
  public CronvoyUrlRequestBuilderImpl
  setRequestFinishedListener(RequestFinishedInfo.Listener listener) {
    mRequestFinishedListener = listener;
    return this;
  }

  @Override
  public CronvoyUrlRequestBase build() {
    final CronvoyUrlRequestBase request = mCronetEngine.createRequest(
        mUrl, mCallback, mExecutor, mPriority, mRequestAnnotations, mDisableCache,
        mDisableConnectionMigration, mAllowDirectExecutor, mTrafficStatsTagSet, mTrafficStatsTag,
        mTrafficStatsUidSet, mTrafficStatsUid, mRequestFinishedListener, mIdempotency);
    if (mMethod != null) {
      request.setHttpMethod(mMethod);
    }
    for (Pair<String, String> header : mRequestHeaders) {
      request.addHeader(header.first, header.second);
    }
    if (mUploadDataProvider != null) {
      request.setUploadDataProvider(mUploadDataProvider, mUploadDataProviderExecutor);
    }
    return request;
  }
}
package org.chromium.net.impl;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * "Compare And Swap" logic based class providing a mean to ensure that the last awaited
 * "stateEvent" will be identified as so. Typically a "stateEvent" is a single bit flip.
 *
 * <p>This class is Thread Safe.
 */
final class AtomicCombinatoryState {

  private final int mFinalState;
  private final AtomicInteger mState = new AtomicInteger(0);

  /**
   * finalState must be a power of two minus one: 1, 3, 7, 15, ...
   */
  AtomicCombinatoryState(int finalState) {
    assert finalState > 0 && ((finalState + 1) & finalState) == 0;
    this.mFinalState = finalState;
  }

  /**
   * Returns true if the state reaches, for the first time, the final state. The provided stateEvent
   * is atmomically ORed with the current state - the outcome is saved as the new state.
   */
  boolean hasReachedFinalState(int stateEvent) {
    assert stateEvent <= mFinalState;
    while (true) {
      int originalState = mState.get();
      int updatedState = originalState | stateEvent;
      if (mState.compareAndSet(originalState, updatedState)) {
        return originalState != mFinalState && updatedState == mFinalState;
      }
    }
  }
}
package org.chromium.net.impl;

import static org.chromium.net.impl.Errors.isQuicException;
import static org.chromium.net.impl.Errors.mapEnvoyMobileErrorToNetError;
import static org.chromium.net.impl.Errors.mapNetErrorToCronetApiErrorCode;

import android.os.ConditionVariable;
import android.util.Log;
import androidx.annotation.IntDef;
import io.envoyproxy.envoymobile.engine.EnvoyHTTPStream;
import io.envoyproxy.envoymobile.engine.types.EnvoyFinalStreamIntel;
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;
import io.envoyproxy.envoymobile.engine.types.EnvoyStreamIntel;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.AbstractMap;
import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import org.chromium.net.CallbackException;
import org.chromium.net.CronetException;
import org.chromium.net.InlineExecutionProhibitedException;
import org.chromium.net.RequestFinishedInfo;
import org.chromium.net.RequestFinishedInfo.Metrics;
import org.chromium.net.UploadDataProvider;
import org.chromium.net.impl.Errors.NetError;

/** UrlRequest, backed by Envoy-Mobile. */
public final class CronvoyUrlRequest extends CronvoyUrlRequestBase {

  /**
   * State interface for keeping track of the internal state of a {@link UrlRequestBase}.
   * <pre>
   *               /- AWAITING_FOLLOW_REDIRECT <-\     /- READING <--\
   *               |                             |     |             |
   *               V                             /     V             /
   * NOT_STARTED -> STARTED --------------------------> AWAITING_READ --------> COMPLETE
   * </pre>
   */
  @IntDef({State.NOT_STARTED, State.STARTED, State.AWAITING_FOLLOW_REDIRECT, State.AWAITING_READ,
           State.READING, State.ERROR, State.COMPLETE, State.CANCELLED, State.PENDING_CANCEL,
           State.ERROR_PENDING_CANCEL})
  @Retention(RetentionPolicy.SOURCE)
  @interface State {
    int NOT_STARTED = 0;
    int STARTED = 1;
    int AWAITING_FOLLOW_REDIRECT = 2;
    int AWAITING_READ = 3;
    int READING = 4;
    int ERROR = 5;
    int COMPLETE = 6;
    int CANCELLED = 7;
    int PENDING_CANCEL = 8;
    int ERROR_PENDING_CANCEL = 9;
  }

  @IntDef({CancelState.READY, CancelState.BUSY, CancelState.CANCELLED})
  @Retention(RetentionPolicy.SOURCE)
  private @interface CancelState {
    int READY = 0;
    int BUSY = 1;
    int CANCELLED = 2;
  }

  @IntDef(flag = true, // This is a bitmap.
          value = {SucceededState.UNDETERMINED, SucceededState.FINAL_READ_DONE,
                   SucceededState.ON_COMPLETE_RECEIVED, SucceededState.SUCCESS_READY})
  @Retention(RetentionPolicy.SOURCE)
  private @interface SucceededState {
    int UNDETERMINED = 0b00;
    int FINAL_READ_DONE = 0b01;
    int ON_COMPLETE_RECEIVED = 0b10;
    int SUCCESS_READY = FINAL_READ_DONE | ON_COMPLETE_RECEIVED;
  }

  @IntDef(flag = true, // This is a bitmap.
          value = {ReportState.INITIAL_STATE, ReportState.USER_FINAL_CALLBACK_DONE,
                   ReportState.NETWORK_FINAL_CALLBACK_RECEIVED, ReportState.REPORT_READY})
  @Retention(RetentionPolicy.SOURCE)
  private @interface ReportState {
    int INITIAL_STATE = 0b00;
    int USER_FINAL_CALLBACK_DONE = 0b01;
    int NETWORK_FINAL_CALLBACK_RECEIVED = 0b10;
    int REPORT_READY = USER_FINAL_CALLBACK_DONE | NETWORK_FINAL_CALLBACK_RECEIVED;
  }

  private static final String X_ENVOY = "x-envoy";
  private static final String X_ENVOY_UPSTREAM_ALPN = "x-envoy-upstream-alpn";
  private static final String TAG = CronvoyUrlRequest.class.getSimpleName();
  private static final String USER_AGENT = "User-Agent";
  private static final String CONTENT_TYPE = "Content-Type";
  private static final Executor DIRECT_EXECUTOR = new DirectExecutor();

  private final String mUserAgent;
  private final HeadersList mRequestHeaders = new HeadersList();
  private final Collection<Object> mRequestAnnotations;
  private final CronvoyUrlRequestContext mRequestContext;
  private final AtomicBoolean mWaitingOnRedirect = new AtomicBoolean(false);
  private final AtomicBoolean mWaitingOnRead = new AtomicBoolean(false);
  private volatile ByteBuffer mUserCurrentReadBuffer = null;

  /**
   * This is the source of thread safety in this class - no other synchronization is performed. By
   * compare-and-swapping from one state to another, we guarantee that operations aren't running
   * concurrently. Only the winner of a compare-and-swapping proceeds.
   *
   * <p>A caller can lose a compare-and-swapping for three reasons - user error (two calls to read()
   * without waiting for the read to succeed), runtime error (network code or user code throws an
   * exception), or cancellation.
   */
  private final AtomicInteger mState = new AtomicInteger(State.NOT_STARTED);
  /**
   * Ensures that the "mCallback.onSucceeded" callback will be invoked after observing the required
   * events, and that it will be done only once.
   *
   * <p>At the end of a successful request, "mCallback.onSucceeded" is invoked. Before doing so,
   * two events must have occurred first: the "completion of the final read" and the "onComplete
   * Network callback". The Thread involved with the last of these two events is in charge of the
   * registering the task to execute "mCallback.onSucceeded" - this is intrinsically racy.
   */
  private final AtomicCombinatoryState mSucceededState =
      new AtomicCombinatoryState(SucceededState.SUCCESS_READY);
  /**
   * Ensures that the CronvoyMetrics will be posted after observing the required events, and that it
   * will be done only once.
   *
   * <p>At the end of a request, mRequestFinishedListener is used to post the CronvoyMetrics. Before
   * doing so, two events must have occurred first: the "final user callback" and the "final Network
   * callback". The Thread involved with the last of these two events is in charge of the posting -
   * this is intrinsically racy.
   */
  private final AtomicCombinatoryState mReportState =
      new AtomicCombinatoryState(ReportState.REPORT_READY);

  private final boolean mAllowDirectExecutor;

  /* These don't change with redirects */
  private String mInitialMethod;
  private final Executor mUserExecutor;
  private final CronvoyVersionSafeCallbacks.UrlRequestCallback mCallback;
  private final String mInitialUrl;
  private final CronvoyVersionSafeCallbacks.RequestFinishedInfoListener mRequestFinishedListener;
  private final ConditionVariable mStartBlock = new ConditionVariable();

  private CronvoyUploadDataStream mUploadDataStream;

  private volatile CronetException mException;

  /**
   * Holds a subset of StatusValues - {@link State#STARTED} can represent {@link
   * Status#SENDING_REQUEST} or {@link Status#WAITING_FOR_RESPONSE}. While the distinction isn't
   * needed to implement the logic in this class, it is needed to implement {@link
   * #getStatus(StatusListener)}.
   *
   * <p>Concurrency notes - this value is not atomically updated with state, so there is some risk
   * that we'd get an inconsistent snapshot of both - however, it also happens that this value is
   * only used with the STARTED state, so it's inconsequential.
   */
  @StatusValues private volatile int mAdditionalStatusDetails = Status.INVALID;

  /* These change with redirects. */
  private final AtomicReference<EnvoyHTTPStream> mStream = new AtomicReference<>();
  private final List<String> mUrlChain = new ArrayList<>();
  private volatile EnvoyFinalStreamIntel mEnvoyFinalStreamIntel;
  private long mBytesReceivedFromRedirects = 0;
  private long mBytesReceivedFromLastRedirect = 0;
  private CronvoyHttpCallbacks mCronvoyCallbacks;
  private String mCurrentUrl;
  private volatile CronvoyUrlResponseInfoImpl mUrlResponseInfo;
  private String mPendingRedirectUrl;

  /**
   * @param executor The executor for orchestrating tasks between envoy-mobile callbacks
   */
  CronvoyUrlRequest(CronvoyUrlRequestContext cronvoyEngine, String url, Callback callback,
                    Executor executor, String userAgent, boolean allowDirectExecutor,
                    Collection<Object> connectionAnnotations, boolean trafficStatsTagSet,
                    int trafficStatsTag, boolean trafficStatsUidSet, int trafficStatsUid,
                    RequestFinishedInfo.Listener requestFinishedListener) {
    if (url == null) {
      throw new NullPointerException("URL is required");
    }
    if (callback == null) {
      throw new NullPointerException("Listener is required");
    }
    if (executor == null) {
      throw new NullPointerException("Executor is required");
    }
    mCallback = new CronvoyVersionSafeCallbacks.UrlRequestCallback(callback);
    mRequestFinishedListener =
        requestFinishedListener != null
            ? new CronvoyVersionSafeCallbacks.RequestFinishedInfoListener(requestFinishedListener)
            : null;
    mRequestContext = cronvoyEngine;
    mAllowDirectExecutor = allowDirectExecutor;
    mUserExecutor = executor;
    mInitialUrl = url;
    mCurrentUrl = url;
    mUserAgent = userAgent;
    mRequestAnnotations = connectionAnnotations;
  }

  @Override
  public void setHttpMethod(String method) {
    checkNotStarted();
    if (method == null) {
      throw new NullPointerException("Method is required.");
    }
    if ("OPTIONS".equalsIgnoreCase(method) || "GET".equalsIgnoreCase(method) ||
        "HEAD".equalsIgnoreCase(method) || "POST".equalsIgnoreCase(method) ||
        "PUT".equalsIgnoreCase(method) || "DELETE".equalsIgnoreCase(method) ||
        "TRACE".equalsIgnoreCase(method) || "PATCH".equalsIgnoreCase(method)) {
      mInitialMethod = method;
    } else {
      throw new IllegalArgumentException("Invalid http method " + method);
    }
  }

  @Override
  public void addHeader(String header, String value) {
    checkNotStarted();
    if (header == null) {
      throw new NullPointerException("Invalid header name.");
    }
    if (value == null) {
      throw new NullPointerException("Invalid header value.");
    }
    if (!isValidHeaderName(header) || value.contains("\r\n")) {
      throw new IllegalArgumentException("Invalid header " + header + "=" + value);
    }
    mRequestHeaders.add(new AbstractMap.SimpleImmutableEntry<>(header, value));
  }

  private boolean isValidHeaderName(String header) {
    for (int i = 0; i < header.length(); i++) {
      char c = header.charAt(i);
      switch (c) {
      case '(':
      case ')':
      case '<':
      case '>':
      case '@':
      case ',':
      case ';':
      case ':':
      case '\\':
      case '\'':
      case '/':
      case '[':
      case ']':
      case '?':
      case '=':
      case '{':
      case '}':
        return false;
      default: {
        if (Character.isISOControl(c) || Character.isWhitespace(c)) {
          return false;
        }
      }
      }
    }
    return true;
  }

  @Override
  public void setUploadDataProvider(UploadDataProvider uploadDataProvider, Executor executor) {
    if (uploadDataProvider == null) {
      throw new NullPointerException("Invalid UploadDataProvider.");
    }
    if (mInitialMethod == null) {
      mInitialMethod = "POST";
    }
    mUploadDataStream = new CronvoyUploadDataStream(uploadDataProvider, executor, this);
  }

  @Override
  public void start() {
    if (mState.compareAndSet(State.NOT_STARTED, State.STARTED)) {
      mRequestContext.setTaskToExecuteWhenInitializationIsCompleted(mStartBlock::open);
      mStartBlock.block();
      fireOpenConnection();
    } else {
      throw new IllegalStateException("Request is already started.");
    }
  }

  @Override
  public void read(final ByteBuffer buffer) {
    CronvoyPreconditions.checkDirect(buffer);
    CronvoyPreconditions.checkHasRemaining(buffer);
    if (!mWaitingOnRead.compareAndSet(true, false)) {
      throw new IllegalStateException("Unexpected read attempt.");
    }
    if (mState.compareAndSet(State.AWAITING_READ, streamEnded() ? State.COMPLETE : State.READING)) {
      if (streamEnded()) {
        if (mSucceededState.hasReachedFinalState(SucceededState.FINAL_READ_DONE)) {
          onSucceeded();
        }
        return;
      }
      mUserCurrentReadBuffer = buffer;
      mCronvoyCallbacks.readData(buffer.remaining());
    }
    // When mWaitingOnRead is true (did not throw), it means that we were duly waiting
    // for the User to invoke this method. If the mState.compareAndSet() failed, it means
    // that this was cancelled, or somehow onError() was called. For both cases, either a "cancel"
    // was induced to get a callback, or the user already had the onFailed() or onCancelled()
    // invoked. The original Cronet logic in this case is to do nothing.
  }

  @Override
  public void followRedirect() {
    if (!mWaitingOnRedirect.compareAndSet(true, false)) {
      throw new IllegalStateException("No redirect to follow.");
    }
    mCurrentUrl = mPendingRedirectUrl;
    mPendingRedirectUrl = null;
    if (mUploadDataStream != null) {
      mUploadDataStream.rewind();
    } else {
      if (mState.compareAndSet(State.AWAITING_FOLLOW_REDIRECT, State.STARTED)) {
        fireOpenConnection();
      }
      // When mWaitingOnRedirect is true (did not throw), it means that we were duly waiting
      // for the User to invoke this method. If the mState.compareAndSet() failed, it means
      // that this was cancelled, or somehow onError() was called. For both cases, the user already
      // had the onFailed() or onCancelled() invoked. mState can not be PENDING_CANCEL or
      // ERROR_PENDING_CANCEL, because at this point there is no Engine running.
    }
  }

  void followRedirectAfterSuccessfulRewind() {
    if (mState.compareAndSet(State.AWAITING_FOLLOW_REDIRECT, State.STARTED)) {
      fireOpenConnection();
    }
  }

  @Override
  public boolean isDone() {
    @State int state = mState.get();
    return state == State.COMPLETE || state == State.ERROR || state == State.CANCELLED;
  }

  @Override
  public void getStatus(StatusListener listener) {
    @StatusValues int extraStatus = mAdditionalStatusDetails;
    @State int state = mState.get();

    @StatusValues final int status;
    switch (state) {
    case State.ERROR:
    case State.COMPLETE:
    case State.CANCELLED:
    case State.PENDING_CANCEL:
    case State.ERROR_PENDING_CANCEL:
    case State.NOT_STARTED:
      status = Status.INVALID;
      break;
    case State.STARTED:
      status = extraStatus;
      break;
    case State.AWAITING_FOLLOW_REDIRECT:
    case State.AWAITING_READ:
      status = Status.IDLE;
      break;
    case State.READING:
      status = Status.READING_RESPONSE;
      break;
    default:
      throw new IllegalStateException("Switch is exhaustive: " + state);
    }

    sendStatus(new CronvoyVersionSafeCallbacks.UrlRequestStatusListener(listener), status);
  }

  @State
  private static int determineNextCancelState(boolean streamEnded, @State int originalState) {
    switch (originalState) {
    case State.STARTED:
    case State.AWAITING_READ:
    case State.READING:
      return streamEnded ? State.CANCELLED : State.PENDING_CANCEL;
    case State.AWAITING_FOLLOW_REDIRECT:
      return State.CANCELLED;
    case State.PENDING_CANCEL:
    case State.ERROR_PENDING_CANCEL:
    case State.NOT_STARTED: // Invoking cancel when NOT_STARTED has no effect.
    case State.ERROR:
    case State.COMPLETE:
    case State.CANCELLED:
      return originalState;
    default:
      throw new IllegalStateException("Switch is exhaustive: " + originalState);
    }
  }

  @Override
  public void cancel() {
    @State int originalState;
    @State int updatedState;
    do {
      originalState = mState.get();
      updatedState = determineNextCancelState(streamEnded(), originalState);
    } while (!mState.compareAndSet(originalState, updatedState));
    if (isTerminalState(originalState) || originalState == State.NOT_STARTED) {
      return;
    }
    fireCloseUploadDataProvider();
    if (updatedState == State.PENDING_CANCEL) {
      CronvoyHttpCallbacks cronvoyCallbacks = this.mCronvoyCallbacks;
      if (cronvoyCallbacks != null) {
        cronvoyCallbacks.cancel();
      }
      return;
    }

    // There is no Engine running - no callback will invoke onFailed() - hence done here.
    onCanceled();
  }

  @State
  private static int determineNextErrorState(boolean streamEnded, @State int originalState) {
    switch (originalState) {
    case State.STARTED:
    case State.AWAITING_READ:
    case State.READING:
      return streamEnded ? State.ERROR : State.ERROR_PENDING_CANCEL;
    case State.AWAITING_FOLLOW_REDIRECT:
      return State.ERROR;
    case State.PENDING_CANCEL:
    case State.ERROR_PENDING_CANCEL:
    case State.NOT_STARTED: // This is invalid and will be caught later.
    case State.ERROR:
    case State.COMPLETE:
    case State.CANCELLED:
    default:
      return originalState;
    }
  }

  // No-op if already in a terminal state.
  private void enterErrorState(CronetException error) {
    @State int originalState;
    @State int updatedState;
    do {
      originalState = mState.get();
      updatedState = determineNextErrorState(streamEnded(), originalState);
    } while (!mState.compareAndSet(originalState, updatedState));
    if (originalState == State.NOT_STARTED) {
      throw new IllegalStateException("Can't enter error state before start");
    }
    if (isTerminalState(originalState)) {
      return;
    }
    mException = error;
    fireCloseUploadDataProvider();
    if (updatedState == State.ERROR_PENDING_CANCEL) {
      CronvoyHttpCallbacks cronvoyCallbacks = this.mCronvoyCallbacks;
      if (cronvoyCallbacks != null) {
        cronvoyCallbacks.cancel();
      }
      return;
    }

    // There is no Engine running - no callback will invoke onFailed() - hence done here.
    onFailed();
  }

  private static boolean isTerminalState(@State int state) {
    switch (state) {
    case State.ERROR:
    case State.COMPLETE:
    case State.CANCELLED:
    case State.PENDING_CANCEL:
    case State.ERROR_PENDING_CANCEL:
      return true;
    default:
      return false;
    }
  }

  private void enterCronetErrorState(final Throwable error) {
    enterErrorState(new CronvoyExceptionImpl("System error", error));
  }

  /**
   * Atomically swaps from the expected state to a new state. If the swap fails, and it's not due to
   * an earlier error or cancellation, throws an exception.
   *
   * @param afterTransition Callback to run after transition completes successfully.
   */
  private void transitionStates(@State int expected, @State int newState,
                                Runnable afterTransition) {
    if (!mState.compareAndSet(expected, newState)) {
      @State int state = mState.get();
      if (!isTerminalState(state)) {
        throw new IllegalStateException("Invalid state transition - expected " + expected +
                                        " but was " + state);
      }
    } else {
      afterTransition.run();
    }
  }

  private void fireCloseUploadDataProvider() {
    if (mUploadDataStream != null) {
      mUploadDataStream.close(); // Idempotent
    }
  }

  // This method is only called when in STARTED state. This means a "cancel" request won't be
  // executed immediately - that quite important here, otherwise this would lead to unfortunate
  // race conditions. A "cancel" request will then be honnored on the first callback.
  private void fireOpenConnection() {
    if (mInitialMethod == null) {
      mInitialMethod = "GET";
    }
    mUrlResponseInfo = null;
    mEnvoyFinalStreamIntel = null;
    mBytesReceivedFromRedirects += mBytesReceivedFromLastRedirect;
    mAdditionalStatusDetails = Status.CONNECTING;
    mUrlChain.add(mCurrentUrl);
    Map<String, List<String>> envoyRequestHeaders = buildEnvoyRequestHeaders(
        mInitialMethod, mRequestHeaders, mUploadDataStream, mUserAgent, mCurrentUrl);
    mCronvoyCallbacks = new CronvoyHttpCallbacks();
    mStream.set(mRequestContext.getEnvoyEngine().startStream(mCronvoyCallbacks,
                                                             /* explicitFlowControl= */ true));
    mStream.get().sendHeaders(envoyRequestHeaders, mUploadDataStream == null);
    if (mUploadDataStream != null && mUrlChain.size() == 1) {
      mUploadDataStream.initializeWithRequest();
    }
  }

  private static Map<String, List<String>>
  buildEnvoyRequestHeaders(String initialMethod, HeadersList headersList,
                           CronvoyUploadDataStream mUploadDataStream, String userAgent,
                           String currentUrl) {
    Map<String, List<String>> headers = new LinkedHashMap<>();
    final URL url;
    try {
      url = new URL(currentUrl);
    } catch (MalformedURLException e) {
      throw new IllegalArgumentException("Invalid URL", e);
    }
    headers.computeIfAbsent(":authority", unused -> new ArrayList<>()).add(url.getAuthority());
    headers.computeIfAbsent(":method", unused -> new ArrayList<>()).add(initialMethod);
    headers.computeIfAbsent(":path", unused -> new ArrayList<>()).add(url.getFile());
    headers.computeIfAbsent(":scheme", unused -> new ArrayList<>()).add(url.getProtocol());
    boolean hasUserAgent = false;
    boolean hasContentType = false;
    for (Map.Entry<String, String> header : headersList) {
      if (header.getKey().isEmpty()) {
        throw new IllegalArgumentException("Invalid header =");
      }
      hasUserAgent = hasUserAgent ||
                     (header.getKey().equalsIgnoreCase(USER_AGENT) && !header.getValue().isEmpty());
      hasContentType = hasContentType || (header.getKey().equalsIgnoreCase(CONTENT_TYPE) &&
                                          !header.getValue().isEmpty());
      headers.computeIfAbsent(header.getKey(), unused -> new ArrayList<>()).add(header.getValue());
    }
    if (!hasUserAgent) {
      headers.computeIfAbsent(USER_AGENT, unused -> new ArrayList<>()).add(userAgent);
    }
    if (!hasContentType && mUploadDataStream != null) {
      throw new IllegalArgumentException("Requests with upload data must have a Content-Type.");
    }

    return headers;
  }

  /**
   * If callback method throws an exception, request gets canceled
   * and exception is reported via onFailed listener callback.
   * Only called on the Executor.
   */
  private void onCallbackException(Throwable t) {
    CallbackException requestError =
        new CronvoyCallbackExceptionImpl("Exception received from UrlRequest.Callback", t);
    Log.e(CronvoyUrlRequestContext.LOG_TAG, "Exception in CalledByNative method", t);
    enterErrorState(requestError);
  }

  /**
   * Called when UploadDataProvider encounters an error.
   */
  void onUploadException(Exception t) {
    CallbackException uploadError =
        new CronvoyCallbackExceptionImpl("Exception received from UploadDataProvider", t);
    Log.e(CronvoyUrlRequestContext.LOG_TAG, "Exception in upload method", t);
    enterErrorState(uploadError);
  }

  /** This wrapper ensures that callbacks are always called on the correct executor */
  void sendStatus(final CronvoyVersionSafeCallbacks.UrlRequestStatusListener listener,
                  final int status) {
    mUserExecutor.execute(() -> listener.onStatus(status));
  }

  void execute(Runnable runnable) {
    try {
      mUserExecutor.execute(runnable);
    } catch (RejectedExecutionException e) {
      enterErrorState(new CronvoyExceptionImpl("Exception posting task to executor", e));
    }
  }

  void onCanceled() {
    Runnable task = new Runnable() {
      @Override
      public void run() {
        try {
          mCallback.onCanceled(CronvoyUrlRequest.this, mUrlResponseInfo);
          maybeReportMetrics(ReportState.USER_FINAL_CALLBACK_DONE);
        } catch (Exception exception) {
          Log.e(CronvoyUrlRequestContext.LOG_TAG, "Exception in onCanceled method", exception);
        }
      }
    };
    execute(task);
  }

  void onSucceeded() {
    Runnable task = new Runnable() {
      @Override
      public void run() {
        try {
          mCallback.onSucceeded(CronvoyUrlRequest.this, mUrlResponseInfo);
          maybeReportMetrics(ReportState.USER_FINAL_CALLBACK_DONE);
        } catch (Exception exception) {
          Log.e(CronvoyUrlRequestContext.LOG_TAG, "Exception in onSucceeded method", exception);
        }
      }
    };
    execute(task);
  }

  void onFailed() {
    Runnable task = new Runnable() {
      @Override
      public void run() {
        try {
          mCallback.onFailed(CronvoyUrlRequest.this, mUrlResponseInfo, mException);
          maybeReportMetrics(ReportState.USER_FINAL_CALLBACK_DONE);
        } catch (Exception exception) {
          Log.e(CronvoyUrlRequestContext.LOG_TAG, "Exception in onFailed method", exception);
        }
      }
    };
    execute(task);
  }

  void send(ByteBuffer buffer, boolean finalChunk) {
    CronvoyHttpCallbacks cronvoyCallbacks = this.mCronvoyCallbacks;
    if (cronvoyCallbacks != null) {
      cronvoyCallbacks.send(buffer, finalChunk);
    }
  }

  boolean isAllowDirectExecutor() { return mAllowDirectExecutor; }

  /** Enforces prohibition of direct execution. */
  void checkCallingThread() {
    if (!mAllowDirectExecutor && mRequestContext.isNetworkThread(Thread.currentThread())) {
      throw new InlineExecutionProhibitedException();
    }
  }

  private void checkNotStarted() {
    @State int state = mState.get();
    if (state != State.NOT_STARTED) {
      throw new IllegalStateException("Request is already started. State is: " + state);
    }
  }

  private boolean streamEnded() {
    CronvoyHttpCallbacks cronvoyCallbacks = this.mCronvoyCallbacks;
    return cronvoyCallbacks != null && cronvoyCallbacks.mEndStream;
  }

  private void recordEnvoyFinalStreamIntel(EnvoyFinalStreamIntel envoyFinalStreamIntel) {
    mEnvoyFinalStreamIntel = envoyFinalStreamIntel;
    if (mUrlResponseInfo != null) { // Null if cancelled before receiving a Response.
      mUrlResponseInfo.setReceivedByteCount(envoyFinalStreamIntel.getReceivedByteCount() +
                                            mBytesReceivedFromRedirects);
    }
    maybeReportMetrics(ReportState.NETWORK_FINAL_CALLBACK_RECEIVED);
  }

  private void recordEnvoyStreamIntel(EnvoyStreamIntel envoyStreamIntel) {
    mUrlResponseInfo.setReceivedByteCount(envoyStreamIntel.getConsumedBytesFromResponse() +
                                          mBytesReceivedFromRedirects);
  }

  private void maybeReportMetrics(@ReportState int reportStateEvent) {
    if (!mReportState.hasReachedFinalState(reportStateEvent)) {
      return;
    }
    Metrics metrics = getMetrics(mEnvoyFinalStreamIntel, mBytesReceivedFromRedirects);
    final RequestFinishedInfo requestInfo =
        new CronvoyRequestFinishedInfoImpl(mInitialUrl, mRequestAnnotations, metrics,
                                           getFinishedReason(), mUrlResponseInfo, mException);
    mRequestContext.reportRequestFinished(requestInfo);
    if (mRequestFinishedListener != null) {
      try {
        mRequestFinishedListener.getExecutor().execute(new Runnable() {
          @Override
          public void run() {
            mRequestFinishedListener.onRequestFinished(requestInfo);
          }
        });
      } catch (RejectedExecutionException failException) {
        Log.e(CronvoyUrlRequestContext.LOG_TAG, "Exception posting task to executor",
              failException);
      }
    }
  }

  private static Metrics getMetrics(EnvoyFinalStreamIntel intel, long bytesReceivedFromRedirects) {
    return new CronvoyMetrics(
        intel.getStreamStartMs(), intel.getDnsStartMs(), intel.getDnsEndMs(),
        intel.getConnectStartMs(), intel.getConnectEndMs(), intel.getSslStartMs(),
        intel.getSslEndMs(), intel.getSendingStartMs(), intel.getSendingEndMs(),
        /* pushStartMs= */ -1, /* pushEndMs= */ -1, intel.getResponseStartMs(),
        intel.getStreamEndMs(), intel.getSocketReused(), intel.getSentByteCount(),
        intel.getReceivedByteCount() + bytesReceivedFromRedirects);
  }

  @CronvoyRequestFinishedInfoImpl.FinishedReason
  private int getFinishedReason() {
    switch (mState.get()) {
    case State.COMPLETE:
      return CronvoyRequestFinishedInfoImpl.SUCCEEDED;
    case State.CANCELLED:
      return CronvoyRequestFinishedInfoImpl.CANCELED;
    default:
      return CronvoyRequestFinishedInfoImpl.FAILED;
    }
  }

  private static int determineNextState(boolean endStream, @State int original,
                                        @State int desired) {
    switch (original) {
    case State.PENDING_CANCEL:
      return endStream ? State.CANCELLED : State.PENDING_CANCEL;
    case State.ERROR_PENDING_CANCEL:
      return endStream ? State.ERROR : State.ERROR_PENDING_CANCEL;
    default:
      return desired;
    }
  }

  private static class HeadersList extends ArrayList<Map.Entry<String, String>> {}

  private static class DirectExecutor implements Executor {
    @Override
    public void execute(Runnable runnable) {
      runnable.run();
    }
  }

  private class CronvoyHttpCallbacks implements EnvoyHTTPCallbacks {

    private final AtomicInteger mCancelState = new AtomicInteger(CancelState.READY);
    private volatile boolean mEndStream = false; // Accessed by different Threads

    @Override
    public Executor getExecutor() {
      return DIRECT_EXECUTOR;
    }

    @Override
    public void onHeaders(Map<String, List<String>> headers, boolean endStream,
                          EnvoyStreamIntel streamIntel) {
      mUrlResponseInfo = new CronvoyUrlResponseInfoImpl();
      recordEnvoyStreamIntel(streamIntel);
      mEndStream = endStream;
      List<String> statuses = headers.get(":status");
      final int responseCode =
          statuses != null && !statuses.isEmpty() ? Integer.valueOf(statuses.get(0)) : -1;
      final String locationField;
      if (responseCode >= 300 && responseCode < 400) {
        setUrlResponseInfo(headers, responseCode);
        List<String> locationFields = mUrlResponseInfo.getAllHeaders().get("location");
        locationField = locationFields == null ? null : locationFields.get(0);
      } else {
        locationField = null;
      }
      @State
      int desiredNextState =
          locationField == null ? State.AWAITING_READ : State.AWAITING_FOLLOW_REDIRECT;
      @State int originalState;
      @State int updatedState;
      do {
        originalState = mState.get();
        updatedState = determineNextState(endStream, originalState, desiredNextState);
      } while (!mState.compareAndSet(originalState, updatedState));
      if (completeAbandonIfAny(originalState, updatedState)) {
        return;
      }
      if (reportInternalStateTransitionErrorIfAny(originalState, State.STARTED)) {
        return;
      }

      if (locationField != null) {
        mBytesReceivedFromLastRedirect = streamIntel.getConsumedBytesFromResponse();
        cancel(); // Abort the the original request - we are being redirected.
      }

      Runnable task = new Runnable() {
        @Override
        public void run() {
          checkCallingThread();
          try {
            if (locationField != null) {
              // This CronvoyHttpCallbacks instance is already in an abandoned state at this point:
              // mState == State.AWAITING_FOLLOW_REDIRECT. But mState will change soon, so this line
              // puts the final nail in the coffin. isAbandoned() can only keep returning true.
              mCronvoyCallbacks = null;
              mStream.set(null);
              mPendingRedirectUrl = URI.create(mCurrentUrl).resolve(locationField).toString();
              mWaitingOnRedirect.set(true);
              mCallback.onRedirectReceived(CronvoyUrlRequest.this, mUrlResponseInfo,
                                           mPendingRedirectUrl);
            } else {
              if (responseCode < 300 || responseCode >= 400) {
                setUrlResponseInfo(headers, responseCode);
              }
              fireCloseUploadDataProvider(); // Idempotent
              mWaitingOnRead.set(true);
              mCallback.onResponseStarted(CronvoyUrlRequest.this, mUrlResponseInfo);
            }
          } catch (Throwable t) {
            onCallbackException(t);
          }
        }
      };
      execute(task);
    }

    @Override
    public void onData(ByteBuffer data, boolean endStream, EnvoyStreamIntel streamIntel) {
      if (isAbandoned()) {
        return;
      }
      recordEnvoyStreamIntel(streamIntel);
      mEndStream = endStream;
      @State int originalState;
      @State int updatedState;

      // When endStream with no data is read, there will be no more calls to read().
      boolean isFinalRead = endStream && !data.hasRemaining();
      do {
        originalState = mState.get();
        updatedState = determineNextState(endStream, originalState,
                                          isFinalRead ? State.COMPLETE : State.AWAITING_READ);
      } while (!mState.compareAndSet(originalState, updatedState));
      if (isFinalRead) {
        // onComplete still needs to be called - this always returns false.
        mSucceededState.hasReachedFinalState(SucceededState.FINAL_READ_DONE);
      }
      if (completeAbandonIfAny(originalState, updatedState)) {
        return;
      }
      if (reportInternalStateTransitionErrorIfAny(originalState, State.READING)) {
        return;
      }

      Runnable task = new Runnable() {
        @Override
        public void run() {
          checkCallingThread();
          try {
            ByteBuffer userBuffer = mUserCurrentReadBuffer;
            mUserCurrentReadBuffer = null; // Avoid the reference to a potentially large buffer.
            int dataRead = data.remaining();
            userBuffer.put(data); // NPE ==> BUG, BufferOverflowException ==> User not behaving.
            if (dataRead > 0 || !endStream) {
              mWaitingOnRead.set(true);
              mCallback.onReadCompleted(CronvoyUrlRequest.this, mUrlResponseInfo, userBuffer);
            }
          } catch (Throwable t) {
            onCallbackException(t);
          }
        }
      };
      execute(task);
    }

    @Override
    public void onTrailers(Map<String, List<String>> trailers, EnvoyStreamIntel streamIntel) {
      if (isAbandoned()) {
        return;
      }
      mEndStream = true;
      @State int originalState;
      @State int updatedState;
      do {
        originalState = mState.get();
        updatedState = determineNextState(mEndStream, originalState, originalState);
      } while (!mState.compareAndSet(originalState, updatedState));
      if (completeAbandonIfAny(originalState, updatedState)) {
        return;
      }
      if (mState.compareAndSet(State.READING, State.COMPLETE)) {
        // onComplete still needs to be called - this always returns false.
        mSucceededState.hasReachedFinalState(SucceededState.FINAL_READ_DONE);
      }
    }

    @Override
    public void onError(int errorCode, String message, int attemptCount,
                        EnvoyStreamIntel streamIntel, EnvoyFinalStreamIntel finalStreamIntel) {
      if (isAbandoned()) {
        return;
      }
      recordEnvoyFinalStreamIntel(finalStreamIntel);
      mEndStream = true;
      @State int originalState;
      @State int updatedState;
      do {
        originalState = mState.get();
        updatedState = determineNextState(mEndStream, originalState, originalState);
      } while (!mState.compareAndSet(originalState, updatedState));
      if (completeAbandonIfAny(originalState, updatedState)) {
        return;
      }

      NetError netError = mapEnvoyMobileErrorToNetError(finalStreamIntel);
      int javaError = mapNetErrorToCronetApiErrorCode(netError);

      if (isQuicException(javaError)) {
        enterErrorState(new CronvoyQuicExceptionImpl("Exception in CronvoyUrlRequest: " + netError,
                                                     javaError, netError.getErrorCode(),
                                                     Errors.QUIC_INTERNAL_ERROR));
        return;
      }

      enterErrorState(new CronvoyNetworkExceptionImpl("Exception in CronvoyUrlRequest: " + netError,
                                                      javaError, netError.getErrorCode()));
    }

    @Override
    public void onCancel(EnvoyStreamIntel streamIntel, EnvoyFinalStreamIntel finalStreamIntel) {
      if (isAbandoned()) {
        return;
      }
      recordEnvoyFinalStreamIntel(finalStreamIntel);
      mEndStream = true;
      @State int originalState;
      @State int updatedState;
      do {
        originalState = mState.get();
        updatedState = determineNextState(mEndStream, originalState, originalState);
      } while (!mState.compareAndSet(originalState, updatedState));
      if (completeAbandonIfAny(originalState, updatedState)) {
        return;
      }

      CronetException exception = new CronvoyExceptionImpl("Cancelled", /* cause= */ null);
      enterErrorState(exception);
    }

    @Override
    public void onSendWindowAvailable(EnvoyStreamIntel streamIntel) {
      if (isAbandoned()) {
        return;
      }
      @State int originalState;
      @State int updatedState;
      do {
        originalState = mState.get();
        updatedState = determineNextState(mEndStream, originalState, originalState);
      } while (!mState.compareAndSet(originalState, updatedState));
      if (completeAbandonIfAny(originalState, updatedState)) {
        return;
      }
      if (reportInternalStateTransitionErrorIfAny(originalState, State.STARTED)) {
        return;
      }

      mUploadDataStream.readDataReady(); // Have the next request body chunk to be sent.
    }

    @Override
    public void onComplete(EnvoyStreamIntel streamIntel, EnvoyFinalStreamIntel finalStreamIntel) {
      if (isAbandoned()) {
        return;
      }
      recordEnvoyFinalStreamIntel(finalStreamIntel);
      if (mSucceededState.hasReachedFinalState(SucceededState.ON_COMPLETE_RECEIVED)) {
        onSucceeded();
      }
    }

    /**
     * Sends one chunk of the request body if the state permits. This method is not re-entrant, but
     * by contract this method can only be invoked once for the first chunk, and then once per
     * onSendWindowAvailable callback.
     */
    void send(ByteBuffer buffer, boolean finalChunk) {
      EnvoyHTTPStream stream = mStream.get();
      if (isAbandoned() || mEndStream ||
          !mCancelState.compareAndSet(CancelState.READY, CancelState.BUSY)) {
        return; // Cancelled - to late to send something.
      }
      // The Envoy Mobile library only cares about the capacity - must use the correct ByteBuffer
      buffer.flip();
      if (buffer.remaining() == buffer.capacity()) {
        stream.sendData(buffer, finalChunk);
      } else {
        ByteBuffer resizedBuffer = ByteBuffer.allocateDirect(buffer.remaining());
        resizedBuffer.put(buffer);
        stream.sendData(resizedBuffer, finalChunk);
      }
      if (!mCancelState.compareAndSet(CancelState.BUSY, CancelState.READY)) {
        stream.cancel();
      }
    }

    void readData(int size) {
      EnvoyHTTPStream stream = mStream.get();
      if (!mCancelState.compareAndSet(CancelState.READY, CancelState.BUSY)) {
        return; // Cancelled - to late to send something.
      }
      stream.readData(size);
      if (!mCancelState.compareAndSet(CancelState.BUSY, CancelState.READY)) {
        stream.cancel();
      }
    }

    /**
     * Cancels the Stream if the state permits - can be called by any Thread. Returns true is the
     * cancel was effectively sent.
     */
    void cancel() {
      EnvoyHTTPStream stream = mStream.get();
      if (this != mCronvoyCallbacks || mEndStream) {
        return;
      }
      @CancelState int oldState = mCancelState.getAndSet(CancelState.CANCELLED);
      if (oldState == CancelState.READY) {
        stream.cancel();
      }
    }

    private void setUrlResponseInfo(Map<String, List<String>> responseHeaders, int responseCode) {
      mAdditionalStatusDetails = Status.WAITING_FOR_RESPONSE;
      List<Map.Entry<String, String>> headerList = new ArrayList<>();
      String selectedTransport = "unknown";
      Set<Map.Entry<String, List<String>>> headers = responseHeaders.entrySet();

      for (Map.Entry<String, List<String>> headerEntry : headers) {
        String headerKey = headerEntry.getKey();
        if (headerEntry.getValue().get(0) == null) {
          continue;
        }
        if (X_ENVOY_UPSTREAM_ALPN.equals(headerKey)) {
          selectedTransport = headerEntry.getValue().get(0);
        }
        if (!headerKey.startsWith(X_ENVOY) && !headerKey.equals("date") &&
            !headerKey.equals(":status")) {
          for (String value : headerEntry.getValue()) {
            headerList.add(new SimpleEntry<>(headerKey, value));
          }
        }
      }
      // Important to copy the list here, because although we never concurrently modify
      // the list ourselves, user code might iterate over it while we're redirecting, and
      // that would throw ConcurrentModificationException.
      // TODO(https://github.com/envoyproxy/envoy-mobile/issues/1622) support proxy
      // TODO(https://github.com/envoyproxy/envoy-mobile/issues/1578) http caching
      mUrlResponseInfo.setResponseValues(
          new ArrayList<>(mUrlChain), responseCode, HttpReason.getReason(responseCode),
          Collections.unmodifiableList(headerList), false, selectedTransport, ":0");
    }

    private boolean completeAbandonIfAny(@State int originalState, @State int updatedState) {
      if (originalState == State.COMPLETE || originalState == State.CANCELLED ||
          originalState == State.ERROR) {
        return true;
      }
      if (originalState != State.PENDING_CANCEL && originalState != State.ERROR_PENDING_CANCEL) {
        return false;
      }
      fireCloseUploadDataProvider(); // Idempotent
      if (originalState == State.ERROR_PENDING_CANCEL && updatedState == State.ERROR) {
        onFailed();
        return true;
      }
      if (originalState == State.PENDING_CANCEL && updatedState == State.CANCELLED) {
        onCanceled();
        return true;
      }
      // Reaching here means that mEndStream == false.
      cancel();
      return true;
    }

    private boolean isAbandoned() {
      return this != mCronvoyCallbacks || mState.get() == State.AWAITING_FOLLOW_REDIRECT;
    }

    private boolean reportInternalStateTransitionErrorIfAny(@State int originalState,
                                                            @State int expectedOriginalState) {
      if (expectedOriginalState == originalState) {
        return false;
      }
      enterCronetErrorState(new IllegalStateException("Invalid state transition - expected " +
                                                      expectedOriginalState + " but was " +
                                                      originalState));
      return true;
    }
  }
}
package org.chromium.net.impl;

import org.chromium.net.CallbackException;

/** An implementation of {@link CallbackException}. */
public final class CronvoyCallbackExceptionImpl extends CallbackException {
  CronvoyCallbackExceptionImpl(String message, Throwable cause) { super(message, cause); }
}
package org.chromium.net.impl;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.os.Build;
import java.util.Locale;

/**
 * Constructs a User-Agent string.
 */
public final class CronvoyUserAgent {
  private static final Object sLock = new Object();

  private static final int VERSION_CODE_UNINITIALIZED = 0;
  private static int sVersionCode = VERSION_CODE_UNINITIALIZED;

  /**
   * Constructs a User-Agent string including application name and version,
   * system build version, model and Id, and Cronet version.
   * @param context the context to fetch the application name and version
   *         from.
   * @return User-Agent string.
   */
  public static String from(Context context) {
    StringBuilder builder = new StringBuilder();

    // Our package name and version.
    builder.append(context.getPackageName());
    builder.append('/');
    builder.append(versionFromContext(context));

    // The platform version.
    builder.append(" (Linux; U; Android ");
    builder.append(Build.VERSION.RELEASE);
    builder.append("; ");
    builder.append(Locale.getDefault().toString());

    String model = Build.MODEL;
    if (model.length() > 0) {
      builder.append("; ");
      builder.append(model);
    }

    String id = Build.ID;
    if (id.length() > 0) {
      builder.append("; Build/");
      builder.append(id);
    }

    builder.append(";");
    appendCronetVersion(builder);

    builder.append(')');

    return builder.toString();
  }

  /**
   * Constructs default QUIC User Agent Id string including application name
   * and Cronet version.
   * @param context the context to fetch the application name from.
   * @return User-Agent string.
   */
  static String getQuicUserAgentIdFrom(Context context) {
    StringBuilder builder = new StringBuilder();

    // Application name and cronet version.
    builder.append(context.getPackageName());
    appendCronetVersion(builder);

    return builder.toString();
  }

  private static int versionFromContext(Context context) {
    synchronized (sLock) {
      if (sVersionCode == VERSION_CODE_UNINITIALIZED) {
        PackageManager packageManager = context.getPackageManager();
        String packageName = context.getPackageName();
        try {
          PackageInfo packageInfo = packageManager.getPackageInfo(packageName, 0);
          sVersionCode = packageInfo.versionCode;
        } catch (NameNotFoundException e) {
          throw new IllegalStateException("Cannot determine package version");
        }
      }
      return sVersionCode;
    }
  }

  private static void appendCronetVersion(StringBuilder builder) {
    builder.append(" Cronet/");
    builder.append(CronvoyImplVersion.getCronetVersion());
  }

  private CronvoyUserAgent() {}
}
package org.chromium.net.impl;

import org.chromium.net.NetworkException;

/**
 * Implements {@link NetworkException}.
 */
public class CronvoyNetworkExceptionImpl extends NetworkException {
  // Error code, one of ERROR_*
  protected final int mErrorCode;
  // Cronet internal error code.
  protected final int mCronetInternalErrorCode;

  /**
   * Constructs an exception with a specific error.
   *
   * @param message explanation of failure.
   * @param errorCode error code, one of {@link #ERROR_HOSTNAME_NOT_RESOLVED ERROR_*}.
   * @param cronetInternalErrorCode Cronet internal error code, one of
   * <a href=https://chromium.googlesource.com/chromium/src/+/master/net/base/net_error_list.h>
   * these</a>.
   */
  public CronvoyNetworkExceptionImpl(String message, int errorCode, int cronetInternalErrorCode) {
    super(message, null);
    assert errorCode > 0 && errorCode < 12;
    assert cronetInternalErrorCode < 0;
    mErrorCode = errorCode;
    mCronetInternalErrorCode = cronetInternalErrorCode;
  }

  @Override
  public int getErrorCode() {
    return mErrorCode;
  }

  @Override
  public int getCronetInternalErrorCode() {
    return mCronetInternalErrorCode;
  }

  @Override
  public boolean immediatelyRetryable() {
    switch (mErrorCode) {
    case ERROR_HOSTNAME_NOT_RESOLVED:
    case ERROR_INTERNET_DISCONNECTED:
    case ERROR_CONNECTION_REFUSED:
    case ERROR_ADDRESS_UNREACHABLE:
    case ERROR_OTHER:
    default:
      return false;
    case ERROR_NETWORK_CHANGED:
    case ERROR_TIMED_OUT:
    case ERROR_CONNECTION_CLOSED:
    case ERROR_CONNECTION_TIMED_OUT:
    case ERROR_CONNECTION_RESET:
      return true;
    }
  }

  @Override
  public String getMessage() {
    StringBuilder b = new StringBuilder(super.getMessage());
    b.append(", ErrorCode=").append(mErrorCode);
    if (mCronetInternalErrorCode != 0) {
      b.append(", InternalErrorCode=").append(mCronetInternalErrorCode);
    }
    b.append(", Retryable=").append(immediatelyRetryable());
    return b.toString();
  }
}
package org.chromium.net.impl;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import io.envoyproxy.envoymobile.engine.EnvoyHTTPStream;

/**
 * CancelProofEnvoyStream is a consistency layer above the {@link EnvoyHTTPStream} preventing
 * unwarranted Stream operations after a "cancel" operation. There are no "synchronized" - this is
 * Compare And Swap based logic. This class is Thread Safe.
 *
 * <p>This contraption ensures that once a "cancel" operation is invoked, there will be no further
 * operations allowed with the EnvoyHTTPStream - subsequent operations will be ignored silently.
 * However, in the event that that one or more EnvoyHTTPStream operations are currently being
 * executed, the "cancel" operation gets postponed: the last concurrent operation will invoke
 * "cancel" at the end.
 *
 * <p>Instances of this class start with a state of "Busy Starting". This ensure that if a cancel
 * is invoked while the stream is being created, that cancel will be executed only once the stream
 * is completely initialized. Doing otherwise leads to unpredictable outcomes.
 */
final class CancelProofEnvoyStream {

  private static final int CANCEL_BIT = 0x8000;
  /**
   * Mainly maintains a counter of how many Stream operations are currently in-flight. However when
   * bit 15 (0x8000) is set, it indicates that the cancel operation has been requested. If the
   * counter is greater than 0, then that "cancel" operation is postponed until the last in-flight
   * operation finishes, i.e. then the counter is back to 0. Then that last operation also invokes
   * "cancel". On the other hand, if the counter is already 0 when invoking "cancel", then it means
   * that there are no in-flight operations: the "cancel" operation is immediately executed. Once
   * the state is "canceled", any new stream operation is silently ignored.
   */
  private final AtomicInteger mConcurrentInvocationCount = new AtomicInteger();
  private volatile EnvoyHTTPStream mStream; // Cancel can come from any Thread.

  /**
   * The "mConcurrentInvocationCount" does not start with "zero" - this is on purpose. At this
   * stage, the Stream is considered to be in its initialization/starting phase. That phase ends
   * when mStream is set: {@link #setStream}. This way, if "cancel" gets called before the
   * {@link #setStream} method, then the intent is recorded, and the effect will be delivered
   * when {@link #setStream} will be invoked.
   */
  CancelProofEnvoyStream() { mConcurrentInvocationCount.set(1); }

  /** Sets the stream. Can only be invoked once. */
  void setStream(EnvoyHTTPStream stream) {
    // "if (returnTrueIfCanceledOrIncreaseConcurrentlyRunningStreamOperations()) { ..."
    // is not called here - see the Constructor's comment.
    assert mStream == null;
    mStream = stream;
    if (decreaseConcurrentlyRunningStreamOperationsAndReturnTrueIfAwaitingCancel()) {
      mStream.cancel(); // Cancel was called meanwhile, so now this is honored.
    }
  }

  /** Initiates the sending of the request headers if the state permits. */
  void sendHeaders(Map<String, List<String>> envoyRequestHeaders, boolean endStream) {
    if (returnTrueIfCanceledOrIncreaseConcurrentlyRunningStreamOperations()) {
      return; // Already Cancelled - to late to send something.
    }
    mStream.sendHeaders(envoyRequestHeaders, endStream);
    if (decreaseConcurrentlyRunningStreamOperationsAndReturnTrueIfAwaitingCancel()) {
      mStream.cancel(); // Cancel was called previously, so now this is honored.
    }
  }

  /** Initiates the sending of one chunk of the request body if the state permits. */
  void sendData(ByteBuffer buffer, boolean finalChunk) {
    if (returnTrueIfCanceledOrIncreaseConcurrentlyRunningStreamOperations()) {
      return; // Already Cancelled - to late to send something.
    }
    // The Envoy Mobile library only cares about the capacity - must use the correct ByteBuffer
    if (buffer.position() == 0) {
      mStream.sendData(buffer, buffer.remaining(), finalChunk);
    } else {
      // TODO(https://github.com/envoyproxy/envoy-mobile/issues/2247): avoid ByteBuffer copies
      ByteBuffer resizedBuffer = ByteBuffer.allocateDirect(buffer.remaining());
      buffer.mark();
      resizedBuffer.put(buffer);
      buffer.reset();
      mStream.sendData(resizedBuffer, finalChunk);
    }
    if (decreaseConcurrentlyRunningStreamOperationsAndReturnTrueIfAwaitingCancel()) {
      mStream.cancel(); // Cancel was called previously, so now this is honored.
    }
  }

  /** Initiates the reading of one chunk of the the request body if the state permits. */
  void readData(int size) {
    if (returnTrueIfCanceledOrIncreaseConcurrentlyRunningStreamOperations()) {
      return; // Already Cancelled - to late to read something.
    }
    mStream.readData(size);
    if (decreaseConcurrentlyRunningStreamOperationsAndReturnTrueIfAwaitingCancel()) {
      mStream.cancel(); // Cancel was called previously, so now this is honored.
    }
  }

  /**
   * Cancels the Stream if the state permits. Will be delayed when an operation is concurrently
   * running. Idempotent and Thread Safe.
   */
  void cancel() {
    // With "Compare And Swap", the contract is the mutation succeeds only if the original value
    // matches the expected one - this is atomic at the assembly language level: most CPUs have
    // dedicated mnemonics for this operation - extremely efficient. And this might look like an
    // infinite loop. There is always one Thread that will succeed - the others may/will loop, and
    // so forth. "Compare And Swap" maybe bad under heavy contention - in that case it is probably
    // better to go with "synchronized" blocks. In our case, there is none or very little
    // contention. What matters is correctness and efficiency.
    while (true) {
      int count = mConcurrentInvocationCount.get();
      if ((count & CANCEL_BIT) != 0) {
        return; // Cancel already invoked.
      }
      if (mConcurrentInvocationCount.compareAndSet(count, count | CANCEL_BIT)) {
        if (count == 0) {
          mStream.cancel(); // Was not busy with other EM operations - cancel right now.
        }
        return;
      }
    }
  }

  private boolean returnTrueIfCanceledOrIncreaseConcurrentlyRunningStreamOperations() {
    while (true) {
      int count = mConcurrentInvocationCount.get();
      if ((count & CANCEL_BIT) != 0) {
        return true; // Already canceled
      }
      if (mConcurrentInvocationCount.compareAndSet(count, count + 1)) {
        return false;
      }
    }
  }

  private boolean decreaseConcurrentlyRunningStreamOperationsAndReturnTrueIfAwaitingCancel() {
    // Only true if the count is back to zero and the cancel bit is set.
    return mConcurrentInvocationCount.decrementAndGet() == CANCEL_BIT;
  }
}
package org.chromium.net.impl;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executor;
import org.chromium.net.BidirectionalStream;
import org.chromium.net.CronetEngine;
import org.chromium.net.ExperimentalBidirectionalStream;

/** Implementation of {@link ExperimentalBidirectionalStream.Builder}. */
final class CronvoyBidirectionalStreamBuilderImpl extends ExperimentalBidirectionalStream.Builder {
  // All fields are temporary storage of ExperimentalBidirectionalStream configuration to be
  // copied to CronetBidirectionalStream.

  // CronetEngine to create the stream.
  private final CronvoyEngineBase mCronetEngine;
  // URL to request.
  private final String mUrl;
  // Callback to receive progress callbacks.
  private final BidirectionalStream.Callback mCallback;
  // Executor on which callbacks will be invoked.
  private final Executor mExecutor;
  // List of request headers, stored as header field name and value pairs.
  private final List<Map.Entry<String, String>> mRequestHeaders = new ArrayList<>();

  // HTTP method for the request. Default to POST.
  private String mHttpMethod = "POST";
  // Priority of the stream. Default is medium.
  @CronvoyEngineBase.StreamPriority private int mPriority = STREAM_PRIORITY_MEDIUM;

  private boolean mDelayRequestHeadersUntilFirstFlush;

  // Request reporting annotations.
  private Collection<Object> mRequestAnnotations;

  private boolean mTrafficStatsTagSet;
  private int mTrafficStatsTag;
  private boolean mTrafficStatsUidSet;
  private int mTrafficStatsUid;

  /**
   * Creates a builder for {@link BidirectionalStream} objects. All callbacks for generated {@code
   * BidirectionalStream} objects will be invoked on {@code executor}. {@code executor} must not run
   * tasks on the current thread, otherwise the networking operations may block and exceptions may
   * be thrown at shutdown time.
   *
   * @param url the URL for the generated stream
   * @param callback the {@link BidirectionalStream.Callback} object that gets invoked upon
   *     different events occurring
   * @param executor the {@link Executor} on which {@code callback} methods will be invoked
   * @param cronetEngine the {@link CronetEngine} used to create the stream
   */
  CronvoyBidirectionalStreamBuilderImpl(String url, BidirectionalStream.Callback callback,
                                        Executor executor, CronvoyEngineBase cronetEngine) {
    super();
    if (url == null) {
      throw new NullPointerException("URL is required.");
    }
    if (callback == null) {
      throw new NullPointerException("Callback is required.");
    }
    if (executor == null) {
      throw new NullPointerException("Executor is required.");
    }
    if (cronetEngine == null) {
      throw new NullPointerException("CronetEngine is required.");
    }
    mUrl = url;
    mCallback = callback;
    mExecutor = executor;
    mCronetEngine = cronetEngine;
  }

  @Override
  public CronvoyBidirectionalStreamBuilderImpl setHttpMethod(String method) {
    if (method == null) {
      throw new NullPointerException("Method is required.");
    }
    mHttpMethod = method;
    return this;
  }

  @Override
  public CronvoyBidirectionalStreamBuilderImpl addHeader(String header, String value) {
    if (header == null) {
      throw new NullPointerException("Invalid header name.");
    }
    if (value == null) {
      throw new NullPointerException("Invalid header value.");
    }
    mRequestHeaders.add(new AbstractMap.SimpleImmutableEntry<>(header, value));
    return this;
  }

  @Override
  public CronvoyBidirectionalStreamBuilderImpl
  setPriority(@CronvoyEngineBase.StreamPriority int priority) {
    mPriority = priority;
    return this;
  }

  @Override
  public CronvoyBidirectionalStreamBuilderImpl
  delayRequestHeadersUntilFirstFlush(boolean delayRequestHeadersUntilFirstFlush) {
    mDelayRequestHeadersUntilFirstFlush = delayRequestHeadersUntilFirstFlush;
    return this;
  }

  @Override
  public ExperimentalBidirectionalStream.Builder addRequestAnnotation(Object annotation) {
    if (annotation == null) {
      throw new NullPointerException("Invalid metrics annotation.");
    }
    if (mRequestAnnotations == null) {
      mRequestAnnotations = new ArrayList<Object>();
    }
    mRequestAnnotations.add(annotation);
    return this;
  }

  @Override
  public ExperimentalBidirectionalStream.Builder setTrafficStatsTag(int tag) {
    mTrafficStatsTagSet = true;
    mTrafficStatsTag = tag;
    return this;
  }

  @Override
  public ExperimentalBidirectionalStream.Builder setTrafficStatsUid(int uid) {
    mTrafficStatsUidSet = true;
    mTrafficStatsUid = uid;
    return this;
  }

  @Override
  public ExperimentalBidirectionalStream build() {
    return mCronetEngine.createBidirectionalStream(
        mUrl, mCallback, mExecutor, mHttpMethod, mRequestHeaders, mPriority,
        mDelayRequestHeadersUntilFirstFlush, mRequestAnnotations, mTrafficStatsTagSet,
        mTrafficStatsTag, mTrafficStatsUidSet, mTrafficStatsUid);
  }
}
package org.chromium.net.impl;

import static org.chromium.net.impl.Errors.isQuicException;
import static org.chromium.net.impl.Errors.mapEnvoyMobileErrorToNetError;
import static org.chromium.net.impl.Errors.mapNetErrorToCronetApiErrorCode;

import android.util.Log;

import androidx.annotation.Nullable;
import androidx.annotation.VisibleForTesting;

import org.chromium.net.BidirectionalStream;
import org.chromium.net.CallbackException;
import org.chromium.net.CronetException;
import org.chromium.net.ExperimentalBidirectionalStream;
import org.chromium.net.NetworkException;
import org.chromium.net.RequestFinishedInfo;
import org.chromium.net.UrlResponseInfo;
import org.chromium.net.impl.Annotations.RequestPriority;
import org.chromium.net.impl.CronvoyBidirectionalState.Event;
import org.chromium.net.impl.CronvoyBidirectionalState.NextAction;
import org.chromium.net.impl.Errors.NetError;
import org.chromium.net.impl.CronvoyUrlResponseInfoImpl.HeaderBlockImpl;

import java.net.MalformedURLException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

import io.envoyproxy.envoymobile.engine.types.EnvoyFinalStreamIntel;
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;
import io.envoyproxy.envoymobile.engine.types.EnvoyStreamIntel;

/**
 * {@link BidirectionalStream} implementation using Envoy-Mobile stack.
 *
 * <p><b>C++ API differences between EM and Cronet</b>:
 * <br>The Cronet C++ API was carved to make the Java implementation of BidirectionalStream
 * straightforward. EM C++ API is more bare bone. The missing/different logic is therefore being
 * handled by this class. Here are the main differences:
 * <ul>
 * <li>onStreamReady is called by the C++ on the Network Thread. EM does not have that.
 * <li>For the request body, Cronet C++ does a callback once a ByteBuffer has been taking in charge.
 * EM rather does a callback once it is ready to take in charge the next ByteBuffer.
 * <li>The Cronet C++ "write" method accepts a list of ByteBuffers. EM C++ "write" method accepts
 * a single ByteBuffer. This feature is important for QUIC - see Issue #2264
 * <li>Cronet C++ systematically does a final "onReadCompleted" callback with an empty ByteBuffer.
 * This is the way to tell the user that there is nothing more coming in. EM C++ does not do that:
 * the last ByteBuffer might not be empty.
 * <li>Cronet C++ does a single "onReadCompleted" callback with an empty ByteBuffer when there is no
 * Response Body. EM C++ does nothing like that.
 * <li>Cronet has a specific C++ API to destroy the stream (not just "cancel"). This allows Cronet
 * to report an Error and quit immediately by invoking "destroy". EM only has Cancel. An EM stream
 * is deemed destroyed only once one of the 3 terminating EM callbacks has been invoked.
 * <li>When invoking "cancel" with Cronet, it is guaranteed that the Cronet C++ with invoke the
 * "onCancel" callback. EM does not do the same: if the "endOfStream" for both "read" and "write"
 * have been recorded by the EM C++, then invoking "cancel" just before receiving an EM terminal
 * callback will not have "onCancel" to be invoked. For example, if a "cancel" is requested when
 * executing "onData" callback method with "endOfStream == true", then this situation occurs:
 * "onComplete" will be called, not "onCancel".
 * </ul>
 *
 * <p><b>Implementation strategy</b>:
 * <br>Implementation wise, the most noticeable difference between the Cronet implementation and
 * this one is the avoidance of any java "synchronized". This implementation is based on "Compare
 * And Swap" logic to guarantee correctness. The State of the Stream is kept in a single atomic
 * Integer owned by {@link CronvoyBidirectionalState}. That state is a set of bits. Technically it
 * could have been the conjunction of Enums held inside a single Integer. Using bits turned out
 * to avoid more complex "if" logic. Still, the most important point here is the fact that the whole
 * state is a single Atomic Integer: it eases the avoidance of race conditions, especially when
 * "cancel" is involved.
 * <ul>
 * <li>When starting, the EM Engine itself might still not have finished its own initialisation.
 * This implementation won't block. Instead, the Stream creation will be piggybacked on the Engine
 * initialisation completion callback. The {@link #start} method is therefore non-blocking like all
 * all other Stream methods.
 * <li>The User "onStreamReady" callback is invoked by this class after creating the Stream, or
 * after sending the Request Headers when requested to do so immediately. EM does not have that C++
 * callback.
 * <li>Since EM does not indicate when the last "sendData" was taken in charge by EM, then invoking
 * "sendData" with "endOfStream == true" also takes care of scheduling the last User
 * "onWriteCompleted" callback. This might look like incorrect, but in reality this does not affect
 * at all the overall behaviour.
 * <li>When invoking "sendData", if the position of the ByteBuffer is not zero, then the ByteBuffer
 * is copied so the data starts at position zero. See Issue #2247.
 * <li>EM does not expose a callback method where the last received ByteBuffer is empty. This Java
 * implementation fakes that behaviour. When the logic figures out that EM has received its last
 * ByteBuffer (usually not empty), then the State logic is set to wait for an ultimate "read" from
 * the User. This can occur after the Stream has competed. Upon receiving the last User "read", a
 * User "onReadCompleted" callback is immediately scheduled with an empty ByteBuffer.
 * <li>The "cancel" request is asynchronous. It can happen in the 6 steps of the life cycle of a
 * Stream: before starting, while starting, after starting, after receiving final "endOfStream",
 * after receiving a terminating EM callback, and after finishing the request. For the first and
 * last state, it is easy: nothing to do. When starting, any "cancel" must be postponed until
 * started. A "cancel" after receiving final "endOfStream" may or may not be processed by the EM
 * "onCancel" callback. In this case any terminal EM callback will complete the "cancel". If a
 * "cancel" occurs after receiving a terminal EM callback then the User "onCanceled" callback is
 * invoked immediately. And to avoid invoking further Stream methods once "cancel" has been invoked,
 * a dedicated class handles this business: {@link CancelProofEnvoyStream}.
 * </ul>
 */
public final class CronvoyBidirectionalStream
    extends ExperimentalBidirectionalStream implements EnvoyHTTPCallbacks {

  private static final String X_ENVOY = "x-envoy";
  private static final String X_ENVOY_SELECTED_TRANSPORT = "x-envoy-upstream-alpn";
  private static final String USER_AGENT = "User-Agent";
  private static final Executor DIRECT_EXECUTOR = new DirectExecutor();

  private final CronvoyUrlRequestContext mRequestContext;
  private final Executor mExecutor;
  private final CronvoyVersionSafeCallbacks.BidirectionalStreamCallback mCallback;
  private final String mInitialUrl;
  // TODO(https://github.com/envoyproxy/envoy-mobile/issues/1641): Priority? What should we do.
  private final int mInitialPriority;
  private final String mMethod;
  private final boolean mReadOnly; // if mInitialMethod is GET or HEAD, then this is true.
  private final List<Map.Entry<String, String>> mRequestHeaders;
  private final boolean mDelayRequestHeadersUntilFirstFlush;
  private final Collection<Object> mRequestAnnotations;
  // TODO(https://github.com/envoyproxy/envoy-mobile/issues/1521): implement traffic tagging.
  private final boolean mTrafficStatsTagSet;
  private final int mTrafficStatsTag;
  private final boolean mTrafficStatsUidSet;
  private final int mTrafficStatsUid;
  private final String mUserAgent;
  private final CancelProofEnvoyStream mStream = new CancelProofEnvoyStream();
  private final CronvoyBidirectionalState mState = new CronvoyBidirectionalState();
  private final AtomicInteger mUserflushConcurrentInvocationCount = new AtomicInteger();
  private final AtomicInteger mFlushConcurrentInvocationCount = new AtomicInteger();
  private final AtomicReference<CronetException> mException = new AtomicReference<>();

  // Set by start() upon success.
  private Map<String, List<String>> mEnvoyRequestHeaders;

  // Pending write data.
  private final ConcurrentLinkedDeque<WriteBuffer> mPendingData;

  // Flush data queue that should be pushed to the native stack when the previous
  // writevData completes.
  private final ConcurrentLinkedDeque<WriteBuffer> mFlushData;

  /* Final metrics recorded the the Envoy Mobile Engine. May be null */
  private EnvoyFinalStreamIntel mEnvoyFinalStreamIntel;

  private volatile WriteBuffer mLastWriteBufferSent;
  private final AtomicReference<ReadBuffer> mLatestBufferRead = new AtomicReference<>();

  // Only modified on the network thread.
  private volatile CronvoyUrlResponseInfoImpl mResponseInfo;

  private Runnable mOnDestroyedCallbackForTesting;

  private final class OnReadCompletedRunnable implements Runnable {
    // Buffer passed back from current invocation of onReadCompleted.
    private ByteBuffer mByteBuffer;
    // End of stream flag from current invocation of onReadCompleted.
    private final boolean mEndOfStream;

    OnReadCompletedRunnable(ByteBuffer mByteBuffer, boolean mEndOfStream) {
      this.mByteBuffer = mByteBuffer;
      this.mEndOfStream = mEndOfStream;
    }

    @Override
    public void run() {
      try {
        // Null out mByteBuffer, to pass buffer ownership to callback or release if done.
        ByteBuffer buffer = mByteBuffer;
        mByteBuffer = null;
        switch (
            mState.nextAction(mEndOfStream ? Event.LAST_READ_COMPLETED : Event.READ_COMPLETED)) {
        case NextAction.NOTIFY_USER_READ_COMPLETED:
          mCallback.onReadCompleted(CronvoyBidirectionalStream.this, mResponseInfo, buffer,
                                    mEndOfStream);
          break;
        case NextAction.TAKE_NO_MORE_ACTIONS:
          // An EM onError callback occurred, or there was a USER_CANCEL event since this task was
          // scheduled.
          return;
        default:
          assert false;
        }
        if (mEndOfStream) {
          switch (mState.nextAction(Event.READY_TO_FINISH)) {
          case NextAction.NOTIFY_USER_SUCCEEDED:
            onSucceededOnExecutor();
            break;
          case NextAction.CARRY_ON:
            break; // Not yet ready to conclude the Stream.
          case NextAction.TAKE_NO_MORE_ACTIONS:
            // Very unlikely: just before this switch statement and after the previous one, an EM
            // onError callback occurred, or there was a USER_CANCEL event.
            return;
          default:
            assert false;
          }
        }
      } catch (Exception e) {
        onCallbackException(e);
      }
    }
  }

  private final class OnWriteCompletedRunnable implements Runnable {
    // Buffer passed back from current invocation of onWriteCompleted.
    private ByteBuffer mByteBuffer;
    // End of stream flag from current call to write.
    private final boolean mEndOfStream;

    OnWriteCompletedRunnable(ByteBuffer buffer, boolean endOfStream) {
      mByteBuffer = buffer;
      mEndOfStream = endOfStream;
    }

    @Override
    public void run() {
      try {
        // Null out mByteBuffer, to pass buffer ownership to callback or release if done.
        ByteBuffer buffer = mByteBuffer;
        mByteBuffer = null;

        switch (
            mState.nextAction(mEndOfStream ? Event.LAST_WRITE_COMPLETED : Event.WRITE_COMPLETED)) {
        case NextAction.NOTIFY_USER_WRITE_COMPLETED:
          mCallback.onWriteCompleted(CronvoyBidirectionalStream.this, mResponseInfo, buffer,
                                     mEndOfStream);
          break;
        case NextAction.TAKE_NO_MORE_ACTIONS:
          // An EM onError callback occurred, or there was a USER_CANCEL event since this task was
          // scheduled.
          return;
        default:
          assert false;
        }
        if (mEndOfStream) {
          switch (mState.nextAction(Event.READY_TO_FINISH)) {
          case NextAction.NOTIFY_USER_SUCCEEDED:
            onSucceededOnExecutor();
            break;
          case NextAction.CARRY_ON:
            break; // Not yet ready to conclude the Stream.
          case NextAction.TAKE_NO_MORE_ACTIONS:
            // Very unlikely: just before this switch statement and after the previous one, an EM
            // onError callback occurred, or there was a USER_CANCEL event.
            return;
          }
        }
      } catch (Exception e) {
        onCallbackException(e);
      }
    }
  }

  CronvoyBidirectionalStream(CronvoyUrlRequestContext requestContext, String url,
                             @CronvoyEngineBase.StreamPriority int priority, Callback callback,
                             Executor executor, String userAgent, String httpMethod,
                             List<Map.Entry<String, String>> requestHeaders,
                             boolean delayRequestHeadersUntilNextFlush,
                             Collection<Object> requestAnnotations, boolean trafficStatsTagSet,
                             int trafficStatsTag, boolean trafficStatsUidSet, int trafficStatsUid) {
    mRequestContext = requestContext;
    mInitialUrl = url;
    mInitialPriority = convertStreamPriority(priority);
    mCallback = new CronvoyVersionSafeCallbacks.BidirectionalStreamCallback(callback);
    mExecutor = executor;
    mUserAgent = userAgent;
    mMethod = httpMethod;
    mRequestHeaders = requestHeaders;
    mDelayRequestHeadersUntilFirstFlush = delayRequestHeadersUntilNextFlush;
    mPendingData = new ConcurrentLinkedDeque<>();
    mFlushData = new ConcurrentLinkedDeque<>();
    mRequestAnnotations = requestAnnotations;
    mTrafficStatsTagSet = trafficStatsTagSet;
    mTrafficStatsTag = trafficStatsTag;
    mTrafficStatsUidSet = trafficStatsUidSet;
    mTrafficStatsUid = trafficStatsUid;
    mReadOnly = !doesMethodAllowWriteData(mMethod);
  }

  @Override
  public void start() {
    validateHttpMethod(mMethod);
    for (Map.Entry<String, String> requestHeader : mRequestHeaders) {
      validateHeader(requestHeader.getKey(), requestHeader.getValue());
    }
    mEnvoyRequestHeaders =
        buildEnvoyRequestHeaders(mMethod, mRequestHeaders, mUserAgent, mInitialUrl);
    // Cronet C++ layer exposes reported errors here with an onError callback. EM does not.
    @Nullable CronetException startUpException = engineSimulatedError(mEnvoyRequestHeaders);
    @Event
    int startingEvent =
        startUpException != null ? Event.ERROR
        : mDelayRequestHeadersUntilFirstFlush
            ? (mReadOnly ? Event.USER_START_READ_ONLY : Event.USER_START)
            : (mReadOnly ? Event.USER_START_WITH_HEADERS_READ_ONLY : Event.USER_START_WITH_HEADERS);
    mRequestContext.onRequestStarted();

    switch (mState.nextAction(startingEvent)) {
    case NextAction.NOTIFY_USER_FAILED:
      mException.set(startUpException);
      failWithException();
      break;
    case NextAction.NOTIFY_USER_STREAM_READY:
      Runnable startTask = new Runnable() {
        @Override
        public void run() {
          try {
            mStream.setStream(mRequestContext.getEnvoyEngine().startStream(
                CronvoyBidirectionalStream.this, /* explicitFlowCrontrol= */ true));
            if (!mDelayRequestHeadersUntilFirstFlush) {
              mStream.sendHeaders(mEnvoyRequestHeaders, mReadOnly);
            }
            onStreamReady();
          } catch (RuntimeException e) {
            // Will be reported when "onCancel" gets invoked.
            reportException(new CronvoyExceptionImpl("Startup failure", e));
          }
        }
      };
      // Starting a new stream can only occur once the engine initialization has completed. The
      // first time a Stream is created this will take more or less 100ms. Keep in mind that Cronet
      // API methods can't be blocking.
      mRequestContext.setTaskToExecuteWhenInitializationIsCompleted(new Runnable() {
        @Override
        public void run() {
          // For the first stream, this task is executed by the Network Thread once the engine
          // initialization is completed. For the subsequent streams, there is no waiting: this line
          // of code is executed by the Thread that invoked this start() method.
          postTaskToExecutor(startTask);
        }
      });
      break;
    default:
      assert false;
    }
  }

  /**
   * Returns, potentially, an exception to be reported through the User's {@link Callback#onFailed},
   * even though no stream has been created yet. This awkward error reporting solely exists to mimic
   * Cronet.
   */
  @Nullable
  private static CronetException engineSimulatedError(Map<String, List<String>> requestHeaders) {
    if (requestHeaders.get(":scheme").get(0).equals("http")) {
      return new CronvoyBidirectionalStreamNetworkException("Exception in BidirectionalStream: "
                                                                + "net::ERR_DISALLOWED_URL_SCHEME",
                                                            11, -301);
    }
    return null;
  }

  @Override
  public void read(ByteBuffer buffer) {
    CronvoyPreconditions.checkHasRemaining(buffer);
    CronvoyPreconditions.checkDirect(buffer);
    mLatestBufferRead.compareAndSet(null, new ReadBuffer(buffer));
    attemptToRead(Event.USER_READ); // Read might not occur right now. If so, it is postponed.
  }

  private void attemptToRead(@Event int readEvent) {
    switch (mState.nextAction(readEvent)) {
    case NextAction.READ: // EM receiving Stream is opened: it accepts "readData" invocations.
      mStream.readData(mLatestBufferRead.get().mByteBuffer.remaining());
      break;
    case NextAction.INVOKE_ON_READ_COMPLETED: // EM receiving Stream is closed.
      // The final read buffer has already been received, or there was no response body.
      ReadBuffer readBuffer = mLatestBufferRead.getAndSet(null);
      onReadCompleted(readBuffer, 0); // Fake the reception of an empty ByteBuffer.
      break;
    case NextAction.POSTPONE_READ: // Response Headers have not yet been received.
    case NextAction.CARRY_ON:      // There was no postponed "read".
      break;
    case NextAction.TAKE_NO_MORE_ACTIONS:
      return;
    default:
      assert false;
    }
  }

  @Override
  public void write(ByteBuffer buffer, boolean endOfStream) {
    CronvoyPreconditions.checkDirect(buffer);
    if (!buffer.hasRemaining() && !endOfStream) {
      throw new IllegalArgumentException("Empty buffer before end of stream.");
    }
    switch (mState.nextAction(endOfStream ? Event.USER_LAST_WRITE : Event.USER_WRITE)) {
    case NextAction.WRITE:
      mPendingData.add(new WriteBuffer(buffer, endOfStream));
      break;
    case NextAction.TAKE_NO_MORE_ACTIONS:
      return;
    default:
      assert false;
    }
  }

  @Override
  public void flush() {
    switch (mState.nextAction(Event.USER_FLUSH)) {
    case NextAction.FLUSH_HEADERS:
      mStream.sendHeaders(mEnvoyRequestHeaders, /* endStream= */ mReadOnly);
      break;
    case NextAction.CARRY_ON:
      break;
    case NextAction.TAKE_NO_MORE_ACTIONS:
      return;
    default:
      assert false;
    }
    if (mUserflushConcurrentInvocationCount.getAndIncrement() > 0) {
      // Another Thread is already copying pending buffers - can't be done concurrently.
      // However, the thread which started with a zero count will loop until this count goes back
      // to zero. For all intent and purposes, this has a similar outcome as using synchronized {}
      return;
    }
    do {
      WriteBuffer pendingBuffer;
      // A write operation can occur while this "flush" method is being executed. This might look
      // like a breach of contract with the Cronet implementation given that this is not possible
      // with Cronet - equivalent code is under a synchronized block. However, for all intents and
      // purposes, this does not affect the general contract: the race condition remains
      // conceptually identical. With Cronet, a distinct Thread invoking a "write" can be lucky or
      // unlucky, depending if that "write" occurred just before the "flush" or not. With Cronvoy,
      // the same "luck" factor is present: it depends if the "write" sent by the other Thread
      // happens before the end of this loop, or not. In short, there is not any strong ordering
      // guarantees between the flush and write when executed by different Threads.
      while ((pendingBuffer = mPendingData.poll()) != null) {
        mFlushData.add(pendingBuffer);
      }
      sendFlushedDataIfAny();
    } while (mUserflushConcurrentInvocationCount.decrementAndGet() > 0);
  }

  private void sendFlushedDataIfAny() {
    if (mFlushConcurrentInvocationCount.getAndIncrement() > 0) {
      // Another Thread is already flushing - can't be done concurrently. However, the thread which
      // started with a zero count will loop until this count goes back to zero. For all intent and
      // purposes, this has a similar outcome as using synchronized {}
      return;
    }
    do {
      if (!mFlushData.isEmpty()) {
        WriteBuffer writeBuffer = mFlushData.getFirst();
        switch (mState.nextAction(writeBuffer.mEndStream ? Event.READY_TO_FLUSH_LAST
                                                         : Event.READY_TO_FLUSH)) {
        case NextAction.SEND_DATA:
          mLastWriteBufferSent = mFlushData.pollFirst();
          mStream.sendData(writeBuffer.mByteBuffer, writeBuffer.mEndStream);
          if (writeBuffer.mEndStream) {
            // There is no EM final callback - last write is therefore acknowledged immediately.
            onWriteCompleted(writeBuffer);
          }
          break;
        case NextAction.CARRY_ON:
          break; // Was not waiting for a "flush" at the moment.
        case NextAction.TAKE_NO_MORE_ACTIONS:
          return;
        default:
          assert false;
        }
      }
    } while (mFlushConcurrentInvocationCount.decrementAndGet() > 0);
  }

  /**
   * Returns a read-only copy of {@code mPendingData} for testing.
   */
  @VisibleForTesting
  public List<ByteBuffer> getPendingDataForTesting() {
    List<ByteBuffer> pendingData = new LinkedList<>();
    for (WriteBuffer writeBuffer : mPendingData) {
      pendingData.add(writeBuffer.mByteBuffer.asReadOnlyBuffer());
    }
    return pendingData;
  }

  /**
   * Returns a read-only copy of {@code mFlushData} for testing.
   *
   * <p>Warning: this does not behave like Cronet. Cronet flushes all buffers in one shot. EM does
   * it one by one.
   */
  @VisibleForTesting
  public List<ByteBuffer> getFlushDataForTesting() {
    List<ByteBuffer> flushData = new LinkedList<>();
    for (WriteBuffer writeBuffer : mFlushData) {
      flushData.add(writeBuffer.mByteBuffer.asReadOnlyBuffer());
    }
    return flushData;
  }

  @Override
  public void cancel() {
    switch (mState.nextAction(Event.USER_CANCEL)) {
    case NextAction.CANCEL:
      mStream.cancel();
      break;
    case NextAction.NOTIFY_USER_CANCELED:
      onCanceledReceived();
      break;
    case NextAction.CARRY_ON:
    case NextAction.TAKE_NO_MORE_ACTIONS:
      // Has already been cancelled, an error condition already registered, or just too late.
      break;
    default:
      assert false;
    }
  }

  @Override
  public boolean isDone() {
    return mState.isDone();
  }

  private void onSucceeded() {
    postTaskToExecutor(new Runnable() {
      @Override
      public void run() {
        onSucceededOnExecutor();
      }
    });
  }

  /**
   * Runs User's {@link Callback#onSucceeded} if both Read and Write sides are closed, and the EM
   * callback {@link #onComplete} was called too.
   */
  private void onSucceededOnExecutor() {
    cleanup();
    try {
      mCallback.onSucceeded(CronvoyBidirectionalStream.this, mResponseInfo);
    } catch (Exception e) {
      Log.e(CronvoyUrlRequestContext.LOG_TAG, "Exception in onSucceeded method", e);
    }
  }

  private void onStreamReady() {
    postTaskToExecutor(new Runnable() {
      @Override
      public void run() {
        try {
          if (mState.isTerminating()) {
            return;
          }
          mCallback.onStreamReady(CronvoyBidirectionalStream.this);
          // Under duress, or due to user long logic, the response headers might have been received
          // already. In that case mCallback.onResponseHeadersReceived was purposely not called, and
          // therefore this is done here. This guarantees correct ordering: mCallback.onStreamReady
          // must finish before invoking mCallback.onResponseHeadersReceived.
          switch (mState.nextAction(Event.STREAM_READY_CALLBACK_DONE)) {
          case NextAction.NOTIFY_USER_HEADERS_RECEIVED:
            mCallback.onResponseHeadersReceived(CronvoyBidirectionalStream.this, mResponseInfo);
            break;
          case NextAction.CARRY_ON:
            break; // Response headers have not been received yet - most common outcome.
          case NextAction.TAKE_NO_MORE_ACTIONS:
            return;
          default:
            assert false;
          }
        } catch (Exception e) {
          onCallbackException(e);
        }
      }
    });
  }

  /**
   * Called when the response headers are received.
   *
   * <p>Note: If the User's {@link Callback#onStreamReady} method has not yet finished, then this
   * method won't be invoked - User's {@link Callback#onResponseHeadersReceived} method will instead
   * be invoked just after {@link Callback#onStreamReady} completion. See method above.
   */
  private void onResponseHeadersReceived() {
    postTaskToExecutor(new Runnable() {
      @Override
      public void run() {
        try {
          if (mState.isTerminating()) {
            return;
          }
          mCallback.onResponseHeadersReceived(CronvoyBidirectionalStream.this, mResponseInfo);
        } catch (Exception e) {
          onCallbackException(e);
        }
      }
    });
  }

  private void onReadCompleted(ReadBuffer readBuffer, int bytesRead) {
    ByteBuffer byteBuffer = readBuffer.mByteBuffer;
    int initialPosition = readBuffer.mInitialPosition;
    int initialLimit = readBuffer.mInitialLimit;
    if (byteBuffer.position() != initialPosition || byteBuffer.limit() != initialLimit) {
      reportException(new CronvoyExceptionImpl("ByteBuffer modified externally during read", null));
      return;
    }
    if (bytesRead < 0 || initialPosition + bytesRead > initialLimit) {
      reportException(new CronvoyExceptionImpl("Invalid number of bytes read", null));
      return;
    }
    byteBuffer.position(initialPosition + bytesRead);
    postTaskToExecutor(new OnReadCompletedRunnable(byteBuffer, bytesRead == 0));
  }

  private void onWriteCompleted(WriteBuffer writeBuffer) {
    ByteBuffer buffer = writeBuffer.mByteBuffer;
    if (buffer.position() != writeBuffer.mInitialPosition ||
        buffer.limit() != writeBuffer.mInitialLimit) {
      reportException(
          new CronvoyExceptionImpl("ByteBuffer modified externally during write", null));
      return;
    }
    // Current implementation always writes the complete buffer.
    buffer.position(buffer.limit());
    postTaskToExecutor(new OnWriteCompletedRunnable(buffer, writeBuffer.mEndStream));
  }

  private void onResponseTrailersReceived(List<Map.Entry<String, String>> trailers) {
    final UrlResponseInfo.HeaderBlock trailersBlock = new HeaderBlockImpl(trailers);
    postTaskToExecutor(new Runnable() {
      @Override
      public void run() {
        try {
          if (mState.isTerminating()) {
            return;
          }
          mCallback.onResponseTrailersReceived(CronvoyBidirectionalStream.this, mResponseInfo,
                                               trailersBlock);
        } catch (Exception e) {
          onCallbackException(e);
        }
      }
    });
  }

  private void onErrorReceived(int errorCode, EnvoyFinalStreamIntel finalStreamIntel) {
    if (mResponseInfo != null) {
      mResponseInfo.setReceivedByteCount(finalStreamIntel.getReceivedByteCount());
    }

    NetError netError = mapEnvoyMobileErrorToNetError(finalStreamIntel);
    int javaError = mapNetErrorToCronetApiErrorCode(netError);

    if (isQuicException(javaError)) {
      mException.set(new CronvoyQuicExceptionImpl("Exception in BidirectionalStream: " + netError,
                                                  javaError, netError.getErrorCode(),
                                                  Errors.QUIC_INTERNAL_ERROR));
    } else {
      mException.set(new CronvoyBidirectionalStreamNetworkException(
          "Exception in BidirectionalStream: " + netError, javaError, netError.getErrorCode()));
    }

    failWithException();
  }

  /**
   * Called when request is canceled, no callbacks will be called afterwards.
   */
  private void onCanceledReceived() {
    cleanup();
    postTaskToExecutor(new Runnable() {
      @Override
      public void run() {
        try {
          mCallback.onCanceled(CronvoyBidirectionalStream.this, mResponseInfo);
        } catch (Exception e) {
          Log.e(CronvoyUrlRequestContext.LOG_TAG, "Exception in onCanceled method", e);
        }
      }
    });
  }

  /**
   * Report metrics to listeners.
   */
  private void onMetricsCollected(long requestStartMs, long dnsStartMs, long dnsEndMs,
                                  long connectStartMs, long connectEndMs, long sslStartMs,
                                  long sslEndMs, long sendingStartMs, long sendingEndMs,
                                  long pushStartMs, long pushEndMs, long responseStartMs,
                                  long requestEndMs, boolean socketReused, long sentByteCount,
                                  long receivedByteCount) {
    // Metrics information. Obtained when request succeeds, fails or is canceled.
    RequestFinishedInfo.Metrics mMetrics = new CronvoyMetrics(
        requestStartMs, dnsStartMs, dnsEndMs, connectStartMs, connectEndMs, sslStartMs, sslEndMs,
        sendingStartMs, sendingEndMs, pushStartMs, pushEndMs, responseStartMs, requestEndMs,
        socketReused, sentByteCount, receivedByteCount);
    final RequestFinishedInfo requestFinishedInfo = new CronvoyRequestFinishedInfoImpl(
        mInitialUrl, mRequestAnnotations, mMetrics, mState.getFinishedReason(), mResponseInfo,
        mException.get());
    mRequestContext.reportRequestFinished(requestFinishedInfo);
  }

  @VisibleForTesting
  public void setOnDestroyedCallbackForTesting(Runnable onDestroyedCallbackForTesting) {
    mOnDestroyedCallbackForTesting = onDestroyedCallbackForTesting;
  }

  private static boolean doesMethodAllowWriteData(String methodName) {
    return !methodName.equals("GET") && !methodName.equals("HEAD");
  }

  private static int convertStreamPriority(@CronvoyEngineBase.StreamPriority int priority) {
    switch (priority) {
    case Builder.STREAM_PRIORITY_IDLE:
      return RequestPriority.IDLE;
    case Builder.STREAM_PRIORITY_LOWEST:
      return RequestPriority.LOWEST;
    case Builder.STREAM_PRIORITY_LOW:
      return RequestPriority.LOW;
    case Builder.STREAM_PRIORITY_MEDIUM:
      return RequestPriority.MEDIUM;
    case Builder.STREAM_PRIORITY_HIGHEST:
      return RequestPriority.HIGHEST;
    default:
      throw new IllegalArgumentException("Invalid stream priority.");
    }
  }

  /**
   * Posts task to application Executor. Used for callbacks
   * and other tasks that should not be executed on network thread.
   */
  private void postTaskToExecutor(Runnable task) {
    try {
      mExecutor.execute(task);
    } catch (RejectedExecutionException failException) {
      Log.e(CronvoyUrlRequestContext.LOG_TAG, "Exception posting task to executor", failException);
      // If already in a failed state this invocation is a no-op.
      reportException(
          new CronvoyExceptionImpl("Exception posting task to executor", failException));
    }
  }

  private CronvoyUrlResponseInfoImpl
  prepareResponseInfoOnNetworkThread(int httpStatusCode, String negotiatedProtocol,
                                     Map<String, List<String>> responseHeaders,
                                     long receivedByteCount) {
    List<Map.Entry<String, String>> headers = new ArrayList<>();
    for (Map.Entry<String, List<String>> headerEntry : responseHeaders.entrySet()) {
      String headerKey = headerEntry.getKey();
      if (headerEntry.getValue().get(0) == null) {
        continue;
      }
      if (!headerKey.startsWith(X_ENVOY) && !headerKey.equals("date")) {
        for (String value : headerEntry.getValue()) {
          headers.add(new AbstractMap.SimpleEntry<>(headerKey, value));
        }
      }
    }
    // proxy and caching are not supported.
    CronvoyUrlResponseInfoImpl responseInfo =
        new CronvoyUrlResponseInfoImpl(Arrays.asList(mInitialUrl), httpStatusCode, "", headers,
                                       false, negotiatedProtocol, null, receivedByteCount);
    return responseInfo;
  }

  private void cleanup() {
    if (mEnvoyFinalStreamIntel != null) {
      recordFinalIntel(mEnvoyFinalStreamIntel);
    }
    mRequestContext.onRequestDestroyed();
    if (mOnDestroyedCallbackForTesting != null) {
      mOnDestroyedCallbackForTesting.run();
    }
  }

  /**
   * Fails the stream with an exception.
   */
  private void failWithException() {
    assert mException.get() != null;
    cleanup();
    mExecutor.execute(new Runnable() {
      @Override
      public void run() {
        try {
          mCallback.onFailed(CronvoyBidirectionalStream.this, mResponseInfo, mException.get());
        } catch (Exception failException) {
          Log.e(CronvoyUrlRequestContext.LOG_TAG, "Exception notifying of failed request",
                failException);
        }
      }
    });
  }

  /**
   * If callback method throws an exception, stream gets canceled and exception is reported via
   * User's {@link Callback#onFailed}.
   */
  private void onCallbackException(Exception e) {
    CallbackException streamError =
        new CronvoyCallbackExceptionImpl("CalledByNative method has thrown an exception", e);
    Log.e(CronvoyUrlRequestContext.LOG_TAG, "Exception in CalledByNative method", e);
    reportException(streamError);
  }

  /**
   * Reports an exception. Can be called on any thread. Only the first call is recorded. The
   * User's {@link Callback#onFailed} will be scheduled not before any of the final EM callback has
   * been invoked ({@link #onCancel}, {@link #onComplete}, or {@link #onError}).
   */
  private void reportException(CronetException exception) {
    mException.compareAndSet(null, exception);
    switch (mState.nextAction(Event.ERROR)) {
    case NextAction.CANCEL:
      mStream.cancel();
      break;
    case NextAction.NOTIFY_USER_FAILED:
      failWithException();
      break;
    case NextAction.TAKE_NO_MORE_ACTIONS:
      Log.e(CronvoyUrlRequestContext.LOG_TAG,
            "An exception has already been previously recorded. This one is ignored.", exception);
      return;
    default:
      assert false;
    }
  }

  private void recordFinalIntel(EnvoyFinalStreamIntel intel) {
    if (mRequestContext.hasRequestFinishedListener()) {
      onMetricsCollected(intel.getStreamStartMs(), intel.getDnsStartMs(), intel.getDnsEndMs(),
                         intel.getConnectStartMs(), intel.getConnectEndMs(), intel.getSslStartMs(),
                         intel.getSslEndMs(), intel.getSendingStartMs(), intel.getSendingEndMs(),
                         /* pushStartMs= */ -1, /* pushEndMs= */ -1, intel.getResponseStartMs(),
                         intel.getStreamEndMs(), intel.getSocketReused(), intel.getSentByteCount(),
                         intel.getReceivedByteCount());
    }
  }

  private static void validateHttpMethod(String method) {
    if (method == null) {
      throw new NullPointerException("Method is required.");
    }
    if ("OPTIONS".equalsIgnoreCase(method) || "GET".equalsIgnoreCase(method) ||
        "HEAD".equalsIgnoreCase(method) || "POST".equalsIgnoreCase(method) ||
        "PUT".equalsIgnoreCase(method) || "DELETE".equalsIgnoreCase(method) ||
        "TRACE".equalsIgnoreCase(method) || "PATCH".equalsIgnoreCase(method)) {
      return;
    }
    throw new IllegalArgumentException("Invalid http method " + method);
  }

  private static void validateHeader(String header, String value) {
    if (header == null) {
      throw new NullPointerException("Invalid header name.");
    }
    if (value == null) {
      throw new NullPointerException("Invalid header value.");
    }
    if (!isValidHeaderName(header) || value.contains("\r\n")) {
      throw new IllegalArgumentException("Invalid header " + header + "=" + value);
    }
  }

  private static boolean isValidHeaderName(String header) {
    for (int i = 0; i < header.length(); i++) {
      char c = header.charAt(i);
      switch (c) {
      case '(':
      case ')':
      case '<':
      case '>':
      case '@':
      case ',':
      case ';':
      case ':':
      case '\\':
      case '\'':
      case '/':
      case '[':
      case ']':
      case '?':
      case '=':
      case '{':
      case '}':
        return false;
      default: {
        if (Character.isISOControl(c) || Character.isWhitespace(c)) {
          return false;
        }
      }
      }
    }
    return true;
  }

  private static Map<String, List<String>>
  buildEnvoyRequestHeaders(String initialMethod, List<Map.Entry<String, String>> headerList,
                           String userAgent, String currentUrl) {
    Map<String, List<String>> headers = new LinkedHashMap<>();
    final URL url;
    try {
      url = new URL(currentUrl);
    } catch (MalformedURLException e) {
      throw new IllegalArgumentException("Invalid URL", e);
    }
    // TODO: with an empty string it does not always work. Why?
    String path = url.getFile().isEmpty() ? "/" : url.getFile();
    headers.computeIfAbsent(":authority", unused -> new ArrayList<>()).add(url.getAuthority());
    headers.computeIfAbsent(":method", unused -> new ArrayList<>()).add(initialMethod);
    headers.computeIfAbsent(":path", unused -> new ArrayList<>()).add(path);
    headers.computeIfAbsent(":scheme", unused -> new ArrayList<>()).add(url.getProtocol());
    boolean hasUserAgent = false;
    for (Map.Entry<String, String> header : headerList) {
      if (header.getKey().isEmpty()) {
        throw new IllegalArgumentException("Invalid header =");
      }
      hasUserAgent = hasUserAgent ||
                     (header.getKey().equalsIgnoreCase(USER_AGENT) && !header.getValue().isEmpty());
      headers.computeIfAbsent(header.getKey(), unused -> new ArrayList<>()).add(header.getValue());
    }
    if (!hasUserAgent) {
      headers.computeIfAbsent(USER_AGENT, unused -> new ArrayList<>()).add(userAgent);
    }
    return headers;
  }

  @Override
  public Executor getExecutor() {
    return DIRECT_EXECUTOR;
  }

  @Override
  public void onSendWindowAvailable(EnvoyStreamIntel streamIntel) {
    switch (mState.nextAction(Event.ON_SEND_WINDOW_AVAILABLE)) {
    case NextAction.CHAIN_NEXT_WRITE:
      onWriteCompleted(mLastWriteBufferSent);
      sendFlushedDataIfAny(); // Flush if there is anything in the flush queue mFlushData.
      break;
    case NextAction.TAKE_NO_MORE_ACTIONS:
      return;
    default:
      assert false;
    }
  }

  @Override
  public void onHeaders(Map<String, List<String>> headers, boolean endStream,
                        EnvoyStreamIntel streamIntel) {
    List<String> statuses = headers.get(":status");
    int httpStatusCode =
        statuses != null && !statuses.isEmpty() ? Integer.parseInt(statuses.get(0)) : -1;
    List<String> transportValues = headers.get(X_ENVOY_SELECTED_TRANSPORT);
    String negotiatedProtocol =
        transportValues != null && !transportValues.isEmpty() ? transportValues.get(0) : "unknown";
    try {
      mResponseInfo = prepareResponseInfoOnNetworkThread(
          httpStatusCode, negotiatedProtocol, headers, streamIntel.getConsumedBytesFromResponse());
    } catch (Exception e) {
      reportException(new CronvoyExceptionImpl("Cannot prepare ResponseInfo", null));
      return;
    }

    switch (mState.nextAction(endStream ? Event.ON_HEADERS_END_STREAM : Event.ON_HEADERS)) {
    case NextAction.NOTIFY_USER_HEADERS_RECEIVED:
      onResponseHeadersReceived();
      break;
    case NextAction.CARRY_ON:
      break; // User has not finished executing the "streamReady" callback - must wait.
    case NextAction.TAKE_NO_MORE_ACTIONS:
      return;
    default:
      assert false;
    }

    attemptToRead(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
  }

  @Override
  public void onData(ByteBuffer data, boolean endStream, EnvoyStreamIntel streamIntel) {
    mResponseInfo.setReceivedByteCount(streamIntel.getConsumedBytesFromResponse());
    switch (mState.nextAction(endStream ? Event.ON_DATA_END_STREAM : Event.ON_DATA)) {
    case NextAction.INVOKE_ON_READ_COMPLETED:
      ReadBuffer readBuffer = mLatestBufferRead.getAndSet(null);
      ByteBuffer userBuffer = readBuffer.mByteBuffer;
      // TODO: this copies buffer on the Network Thread - consider doing on the user Thread.
      //       Or even better, revamp EM API to avoid as much as possible copying ByteBuffers.
      userBuffer.mark();
      userBuffer.put(data); // NPE ==> BUG, BufferOverflowException ==> User not behaving.
      userBuffer.reset();
      onReadCompleted(readBuffer, data.capacity());
      break;
    case NextAction.TAKE_NO_MORE_ACTIONS:
      return;
    default:
      assert false;
    }
  }

  @Override
  public void onTrailers(Map<String, List<String>> trailers, EnvoyStreamIntel streamIntel) {
    List<Map.Entry<String, String>> headers = new ArrayList<>();
    switch (mState.nextAction(Event.ON_TRAILERS)) {
    case NextAction.NOTIFY_USER_TRAILERS_RECEIVED:
      for (Map.Entry<String, List<String>> headerEntry : trailers.entrySet()) {
        String headerKey = headerEntry.getKey();
        if (headerEntry.getValue().get(0) == null) {
          continue;
        }
        // TODO: make sure which headers should be posted.
        if (!headerKey.startsWith(X_ENVOY) && !headerKey.equals("date") &&
            !headerKey.startsWith(":")) {
          for (String value : headerEntry.getValue()) {
            headers.add(new AbstractMap.SimpleEntry<>(headerKey, value));
          }
        }
      }
      onResponseTrailersReceived(headers);
      break;
    case NextAction.TAKE_NO_MORE_ACTIONS:
      return;
    default:
      assert false;
    }
  }

  @Override
  public void onError(int errorCode, String message, int attemptCount, EnvoyStreamIntel streamIntel,
                      EnvoyFinalStreamIntel finalStreamIntel) {
    mEnvoyFinalStreamIntel = finalStreamIntel;
    switch (mState.nextAction(Event.ON_ERROR)) {
    case NextAction.NOTIFY_USER_NETWORK_ERROR:
      onErrorReceived(errorCode, finalStreamIntel);
      break;
    case NextAction.NOTIFY_USER_FAILED:
      // There was already an error in-progress - the network error came too late and is ignored.
      failWithException();
      break;
    default:
      assert false;
    }
  }

  @Override
  public void onCancel(EnvoyStreamIntel streamIntel, EnvoyFinalStreamIntel finalStreamIntel) {
    mEnvoyFinalStreamIntel = finalStreamIntel;
    switch (mState.nextAction(Event.ON_CANCEL)) {
    case NextAction.NOTIFY_USER_CANCELED:
      onCanceledReceived(); // The cancel was user initiated.
      break;
    case NextAction.NOTIFY_USER_FAILED:
      failWithException(); // The cancel was not user initiated, but a mean to report the error.
      break;
    default:
      assert false;
    }
  }

  @Override
  public void onComplete(EnvoyStreamIntel streamIntel, EnvoyFinalStreamIntel finalStreamIntel) {
    mEnvoyFinalStreamIntel = finalStreamIntel;
    switch (mState.nextAction(Event.ON_COMPLETE)) {
    case NextAction.NOTIFY_USER_FAILED:
      failWithException();
      break;
    case NextAction.NOTIFY_USER_CANCELED:
      onCanceledReceived();
      break;
    case NextAction.NOTIFY_USER_SUCCEEDED:
      onSucceeded();
      break;
    case NextAction.CARRY_ON:
      break;
    default:
      assert false;
    }
  }

  private static class WriteBuffer {
    final ByteBuffer mByteBuffer;
    final boolean mEndStream;
    final int mInitialPosition;
    final int mInitialLimit;

    WriteBuffer(ByteBuffer mByteBuffer, boolean mEndStream) {
      this.mByteBuffer = mByteBuffer;
      this.mEndStream = mEndStream;
      this.mInitialPosition = mByteBuffer.position();
      this.mInitialLimit = mByteBuffer.limit();
    }
  }

  private static class ReadBuffer {
    final ByteBuffer mByteBuffer;
    final int mInitialPosition;
    final int mInitialLimit;

    ReadBuffer(ByteBuffer mByteBuffer) {
      this.mByteBuffer = mByteBuffer;
      this.mInitialPosition = mByteBuffer.position();
      this.mInitialLimit = mByteBuffer.limit();
    }
  }

  private static class DirectExecutor implements Executor {
    @Override
    public void execute(Runnable runnable) {
      runnable.run();
    }
  }
}
package org.chromium.net.impl;

// Version based on chrome/VERSION.
public final class CronvoyImplVersion {
  // TODO(carloseltuerto) make this class a template and use "@MAJOR@.@MINOR@.@BUILD@.@PATCH@"
  private static final String CRONET_VERSION = "99.0.4512.7";
  // TODO(carloseltuerto) make this class a template and use @API_LEVEL@;
  private static final int API_LEVEL = 14;
  // TODO(carloseltuerto) make this class a template and use "@LAST_CHANGE@";
  private static final String LAST_CHANGE = "20220222";

  /**
   * Private constructor. All members of this class should be static.
   */
  private CronvoyImplVersion() {}

  public static String getCronetVersionWithLastChange() {
    return CRONET_VERSION + "@" + LAST_CHANGE.substring(0, 8);
  }

  public static int getApiLevel() { return API_LEVEL; }

  public static String getCronetVersion() { return CRONET_VERSION; }

  public static String getLastChange() { return LAST_CHANGE; }
}
package org.chromium.net.impl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.atomic.AtomicLong;
import org.chromium.net.UrlResponseInfo;

/**
 * Implements the container for basic information about a response. Included in
 * {@link org.chromium.net.UrlRequest.Callback} callbacks. Each
 * {@link org.chromium.net.UrlRequest.Callback#onRedirectReceived onRedirectReceived()}
 * callback gets a different copy of {@code UrlResponseInfo} describing a particular
 * redirect response.
 */
public final class CronvoyUrlResponseInfoImpl extends UrlResponseInfo {
  private List<String> mResponseInfoUrlChain;
  private int mHttpStatusCode;
  private String mHttpStatusText;
  private boolean mWasCached;
  private String mNegotiatedProtocol;
  private String mProxyServer;
  private final AtomicLong mReceivedByteCount = new AtomicLong();
  private HeaderBlockImpl mHeaders;

  /**
   * Unmodifiable container of response headers or trailers.
   */
  public static final class HeaderBlockImpl extends HeaderBlock {
    private final List<Map.Entry<String, String>> mAllHeadersList;
    private Map<String, List<String>> mHeadersMap;

    HeaderBlockImpl(List<Map.Entry<String, String>> allHeadersList) {
      mAllHeadersList = allHeadersList;
    }

    @Override
    public List<Map.Entry<String, String>> getAsList() {
      return mAllHeadersList;
    }

    @Override
    public Map<String, List<String>> getAsMap() {
      // This is potentially racy...but races will only result in wasted resource.
      if (mHeadersMap != null) {
        return mHeadersMap;
      }
      Map<String, List<String>> map = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
      for (Map.Entry<String, String> entry : mAllHeadersList) {
        List<String> values = new ArrayList<String>();
        if (map.containsKey(entry.getKey())) {
          values.addAll(map.get(entry.getKey()));
        }
        values.add(entry.getValue());
        map.put(entry.getKey(), Collections.unmodifiableList(values));
      }
      mHeadersMap = Collections.unmodifiableMap(map);
      return mHeadersMap;
    }
  }

  /**
   * Creates an implementation of {@link UrlResponseInfo}.
   *
   * @param urlChain the URL chain. The first entry is the originally requested URL;
   *         the following entries are redirects followed.
   * @param httpStatusCode the HTTP status code.
   * @param httpStatusText the HTTP status text of the status line.
   * @param allHeadersList list of response header field and value pairs.
   * @param wasCached {@code true} if the response came from the cache, {@code false}
   *         otherwise.
   * @param negotiatedProtocol the protocol negotiated with the server.
   * @param proxyServer the proxy server that was used for the request.
   * @param receivedByteCount minimum count of bytes received from the network to process this
   *         request.
   */
  public CronvoyUrlResponseInfoImpl(List<String> urlChain, int httpStatusCode,
                                    String httpStatusText,
                                    List<Map.Entry<String, String>> allHeadersList,
                                    boolean wasCached, String negotiatedProtocol,
                                    String proxyServer, long receivedByteCount) {
    mResponseInfoUrlChain = Collections.unmodifiableList(urlChain);
    mHttpStatusCode = httpStatusCode;
    mHttpStatusText = httpStatusText;
    mHeaders = new HeaderBlockImpl(Collections.unmodifiableList(allHeadersList));
    mWasCached = wasCached;
    mNegotiatedProtocol = negotiatedProtocol;
    mProxyServer = proxyServer;
    mReceivedByteCount.set(receivedByteCount);
  }

  /**
   * Creates an empty implementation of {@link UrlResponseInfo}.
   */
  public CronvoyUrlResponseInfoImpl() {}

  /**
   * Sets response values.
   *
   * @param urlChain the URL chain. The first entry is the originally requested URL;
   *         the following entries are redirects followed.
   * @param httpStatusCode the HTTP status code.
   * @param httpStatusText the HTTP status text of the status line.
   * @param allHeadersList list of response header field and value pairs.
   * @param wasCached {@code true} if the response came from the cache, {@code false}
   *         otherwise.
   * @param negotiatedProtocol the protocol negotiated with the server.
   * @param proxyServer the proxy server that was used for the request.
   */
  public void setResponseValues(List<String> urlChain, int httpStatusCode, String httpStatusText,
                                List<Map.Entry<String, String>> allHeadersList, boolean wasCached,
                                String negotiatedProtocol, String proxyServer) {
    mResponseInfoUrlChain = Collections.unmodifiableList(urlChain);
    mHttpStatusCode = httpStatusCode;
    mHttpStatusText = httpStatusText;
    mHeaders = new HeaderBlockImpl(Collections.unmodifiableList(allHeadersList));
    mWasCached = wasCached;
    mNegotiatedProtocol = negotiatedProtocol;
    mProxyServer = proxyServer;
  }

  @Override
  public String getUrl() {
    return mResponseInfoUrlChain.get(mResponseInfoUrlChain.size() - 1);
  }

  @Override
  public List<String> getUrlChain() {
    return mResponseInfoUrlChain;
  }

  @Override
  public int getHttpStatusCode() {
    return mHttpStatusCode;
  }

  @Override
  public String getHttpStatusText() {
    return mHttpStatusText;
  }

  @Override
  public List<Map.Entry<String, String>> getAllHeadersAsList() {
    return mHeaders.getAsList();
  }

  @Override
  public Map<String, List<String>> getAllHeaders() {
    return mHeaders.getAsMap();
  }

  @Override
  public boolean wasCached() {
    return mWasCached;
  }

  @Override
  public String getNegotiatedProtocol() {
    return mNegotiatedProtocol;
  }

  @Override
  public String getProxyServer() {
    return mProxyServer;
  }

  @Override
  public long getReceivedByteCount() {
    return mReceivedByteCount.get();
  }

  @Override
  public String toString() {
    return String.format(Locale.ROOT,
                         "UrlResponseInfo@[%s][%s]: urlChain = %s, "
                             + "httpStatus = %d %s, headers = %s, wasCached = %b, "
                             + "negotiatedProtocol = %s, proxyServer= %s, receivedByteCount = %d",
                         // Prevent asserting on the contents of this string
                         Integer.toHexString(System.identityHashCode(this)), getUrl(),
                         getUrlChain().toString(), getHttpStatusCode(), getHttpStatusText(),
                         getAllHeadersAsList().toString(), wasCached(), getNegotiatedProtocol(),
                         getProxyServer(), getReceivedByteCount());
  }

  /**
   * Sets mReceivedByteCount. Must not be called after request completion or cancellation.
   */
  public void setReceivedByteCount(long currentReceivedByteCount) {
    mReceivedByteCount.set(currentReceivedByteCount);
  }
}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="org.cronvoy">
    <uses-sdk
            android:minSdkVersion="21"
            android:targetSdkVersion="27" />

</manifest>
package org.chromium.net.impl;

import android.util.Log;
import androidx.annotation.LongDef;
import io.envoyproxy.envoymobile.engine.AndroidNetworkMonitor;
import io.envoyproxy.envoymobile.engine.UpstreamHttpProtocol;
import io.envoyproxy.envoymobile.engine.types.EnvoyFinalStreamIntel;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.chromium.net.NetworkException;

/**
 * Handles mapping of the error codes that exist in the Cronvoy space. That is,
 * from Envoymobile error to Chromium neterror and finally to the public Network Exception.
 */
public class Errors {
  // This represents a nativeQuicError since we don't expose individual quic errors yet.
  public static final int QUIC_INTERNAL_ERROR = 1;
  private static final Map<Long, NetError> ENVOYMOBILE_ERROR_TO_NET_ERROR = buildErrorMap();

  /**Subset of errors defined in
   * https://github.com/envoyproxy/envoy/blob/main/envoy/stream_info/stream_info.h */
  @LongDef(flag = true,
           value = {EnvoyMobileError.DNS_RESOLUTION_FAILED, EnvoyMobileError.DURATION_TIMEOUT,
                    EnvoyMobileError.STREAM_IDLE_TIMEOUT,
                    EnvoyMobileError.UPSTREAM_CONNECTION_FAILURE,
                    EnvoyMobileError.UPSTREAM_CONNECTION_TERMINATION,
                    EnvoyMobileError.UPSTREAM_REMOTE_RESET})
  @Retention(RetentionPolicy.SOURCE)
  public @interface EnvoyMobileError {
    long DNS_RESOLUTION_FAILED = 0x4000000;
    long DURATION_TIMEOUT = 0x400000;
    long STREAM_IDLE_TIMEOUT = 0x10000;
    long UPSTREAM_CONNECTION_FAILURE = 0x20;
    long UPSTREAM_CONNECTION_TERMINATION = 0x40;
    long UPSTREAM_REMOTE_RESET = 0x10;
  }

  /** Subset of errors defined in chromium/src/net/base/net_error_list.h */
  public enum NetError {
    ERR_NETWORK_CHANGED(-21),
    ERR_HTTP2_PING_FAILED(-352),
    ERR_QUIC_PROTOCOL_ERROR(-356),
    ERR_QUIC_HANDSHAKE_FAILED(-358),
    ERR_NAME_NOT_RESOLVED(-105),
    ERR_INTERNET_DISCONNECTED(-106),
    ERR_TIMED_OUT(-7),
    ERR_CONNECTION_CLOSED(-100),
    ERR_CONNECTION_TIMED_OUT(-118),
    ERR_CONNECTION_REFUSED(-102),
    ERR_CONNECTION_RESET(-101),
    ERR_ADDRESS_UNREACHABLE(-109),
    ERR_OTHER(-1000);

    private final int errorCode;

    NetError(int errorCode) { this.errorCode = errorCode; }

    public int getErrorCode() { return errorCode; }

    @Override
    public String toString() {
      return "net::" + name();
    }
  }

  /**
   * Maps Envoymobile's errorcode to chromium's net errorcode
   * @param responseFlag envoymobile's finalStreamIntel responseFlag
   * @return the NetError that the EnvoyMobileError maps to
   */
  public static NetError mapEnvoyMobileErrorToNetError(EnvoyFinalStreamIntel finalStreamIntel) {
    // if connection fails to be established, check if user is offline
    long responseFlag = finalStreamIntel.getResponseFlags();
    if ((responseFlag == EnvoyMobileError.DNS_RESOLUTION_FAILED ||
         responseFlag == EnvoyMobileError.UPSTREAM_CONNECTION_FAILURE) &&
        !AndroidNetworkMonitor.getInstance().isOnline()) {
      return NetError.ERR_INTERNET_DISCONNECTED;
    }

    // Check if negotiated_protocol is quic
    if (finalStreamIntel.getUpstreamProtocol() == UpstreamHttpProtocol.HTTP3) {
      return NetError.ERR_QUIC_PROTOCOL_ERROR;
    }

    return ENVOYMOBILE_ERROR_TO_NET_ERROR.getOrDefault(responseFlag, NetError.ERR_OTHER);
  }

  /**
   * Maps chromium's net errorcode to Cronet API errorcode
   * @return the corresponding NetworkException errorcode
   */
  public static int mapNetErrorToCronetApiErrorCode(NetError netError) {
    switch (netError) {
    case ERR_NAME_NOT_RESOLVED:
      return NetworkException.ERROR_HOSTNAME_NOT_RESOLVED;
    case ERR_TIMED_OUT:
      return NetworkException.ERROR_TIMED_OUT;
    case ERR_CONNECTION_CLOSED:
      return NetworkException.ERROR_CONNECTION_CLOSED;
    case ERR_CONNECTION_RESET:
      return NetworkException.ERROR_CONNECTION_RESET;
    case ERR_CONNECTION_REFUSED:
      return NetworkException.ERROR_CONNECTION_REFUSED;
    case ERR_OTHER:
      return NetworkException.ERROR_OTHER;
    case ERR_INTERNET_DISCONNECTED:
      return NetworkException.ERROR_INTERNET_DISCONNECTED;
    case ERR_NETWORK_CHANGED:
      return NetworkException.ERROR_NETWORK_CHANGED;
    case ERR_QUIC_PROTOCOL_ERROR:
      return NetworkException.ERROR_QUIC_PROTOCOL_FAILED;
    }
    Log.e(CronvoyUrlRequestContext.LOG_TAG, "Unknown error code: " + netError);
    return NetworkException.ERROR_OTHER;
  }

  /**
   * Returns {@code true} if the error may contain QUIC specific errorcode
   */
  public static boolean isQuicException(int javaError) {
    return javaError == NetworkException.ERROR_QUIC_PROTOCOL_FAILED ||
        javaError == NetworkException.ERROR_NETWORK_CHANGED;
  }

  private static Map<Long, NetError> buildErrorMap() {
    Map<Long, NetError> errorMap = new HashMap<>();
    errorMap.put(EnvoyMobileError.DNS_RESOLUTION_FAILED, NetError.ERR_NAME_NOT_RESOLVED);
    errorMap.put(EnvoyMobileError.DURATION_TIMEOUT, NetError.ERR_TIMED_OUT);
    errorMap.put(EnvoyMobileError.STREAM_IDLE_TIMEOUT, NetError.ERR_TIMED_OUT);
    errorMap.put(EnvoyMobileError.UPSTREAM_CONNECTION_TERMINATION, NetError.ERR_CONNECTION_CLOSED);
    errorMap.put(EnvoyMobileError.UPSTREAM_REMOTE_RESET, NetError.ERR_CONNECTION_RESET);
    errorMap.put(EnvoyMobileError.UPSTREAM_CONNECTION_FAILURE, NetError.ERR_CONNECTION_REFUSED);
    return Collections.unmodifiableMap(errorMap);
  }

  private Errors() {}
}
package org.chromium.net.impl;

import androidx.annotation.IntDef;
import androidx.annotation.Nullable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.net.URL;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executor;
import org.chromium.net.BidirectionalStream;
import org.chromium.net.ExperimentalBidirectionalStream;
import org.chromium.net.ExperimentalCronetEngine;
import org.chromium.net.ExperimentalUrlRequest;
import org.chromium.net.RequestFinishedInfo;
import org.chromium.net.UrlRequest;

/**
 * Base class of {@link CronvoyUrlRequestContext}
 */
abstract class CronvoyEngineBase extends ExperimentalCronetEngine {

  /**
   * Creates a {@link UrlRequest} object. All callbacks will be called on {@code executor}'s thread.
   * {@code executor} must not run tasks on the current thread to prevent blocking networking
   * operations and causing exceptions during shutdown.
   *
   * @param url {@link URL} for the request.
   * @param callback callback object that gets invoked on different events.
   * @param executor {@link Executor} on which all callbacks will be invoked.
   * @param priority priority of the request which should be one of the {@link
   *     UrlRequest.Builder#REQUEST_PRIORITY_IDLE REQUEST_PRIORITY_*} values.
   * @param requestAnnotations Objects to pass on to {@link
   *     org.chromium.net.RequestFinishedInfo.Listener}.
   * @param disableCache disables cache for the request. If context is not set up to use cache this
   *     param has no effect.
   * @param disableConnectionMigration disables connection migration for this request if it is
   *     enabled for the session.
   * @param allowDirectExecutor whether executors used by this request are permitted to execute
   *     submitted tasks inline.
   * @param trafficStatsTagSet {@code true} if {@code trafficStatsTag} represents a TrafficStats tag
   *     to apply to sockets used to perform this request.
   * @param trafficStatsTag TrafficStats tag to apply to sockets used to perform this request.
   * @param trafficStatsUidSet {@code true} if {@code trafficStatsUid} represents a UID to attribute
   *     traffic used to perform this request.
   * @param trafficStatsUid UID to attribute traffic used to perform this request.
   * @param requestFinishedListener callback to get invoked with metrics when request is finished.
   *     Set to {@code null} if not used.
   * @param idempotency idempotency of the request which should be one of the {@link
   *     ExperimentalUrlRequest.Builder#DEFAULT_IDEMPOTENCY IDEMPOTENT NOT_IDEMPOTENT} values.
   * @return new request.
   */
  abstract CronvoyUrlRequestBase createRequest(
      String url, UrlRequest.Callback callback, Executor executor, @RequestPriority int priority,
      Collection<Object> requestAnnotations, boolean disableCache,
      boolean disableConnectionMigration, boolean allowDirectExecutor, boolean trafficStatsTagSet,
      int trafficStatsTag, boolean trafficStatsUidSet, int trafficStatsUid,
      @Nullable RequestFinishedInfo.Listener requestFinishedListener, @Idempotency int idempotency);

  /**
   * Creates a {@link BidirectionalStream} object. {@code callback} methods will be invoked on
   * {@code executor}. {@code executor} must not run tasks on the current thread to prevent blocking
   * networking operations and causing exceptions during shutdown.
   *
   * @param url the URL for the stream
   * @param callback the object whose methods get invoked upon different events
   * @param executor the {@link Executor} on which all callbacks will be called
   * @param httpMethod the HTTP method to use for the stream
   * @param requestHeaders the list of request headers
   * @param priority priority of the stream which should be one of the {@link
   *     BidirectionalStream.Builder#STREAM_PRIORITY_IDLE STREAM_PRIORITY_*} values.
   * @param delayRequestHeadersUntilFirstFlush whether to delay sending request headers until
   *     flush() is called, and try to combine them with the next data frame.
   * @param requestAnnotations Objects to pass on to {@link
   *     org.chromium.net.RequestFinishedInfo.Listener}.
   * @param trafficStatsTagSet {@code true} if {@code trafficStatsTag} represents a TrafficStats tag
   *     to apply to sockets used to perform this request.
   * @param trafficStatsTag TrafficStats tag to apply to sockets used to perform this request.
   * @param trafficStatsUidSet {@code true} if {@code trafficStatsUid} represents a UID to attribute
   *     traffic used to perform this request.
   * @param trafficStatsUid UID to attribute traffic used to perform this request.
   * @return a new stream.
   */
  abstract ExperimentalBidirectionalStream createBidirectionalStream(
      String url, BidirectionalStream.Callback callback, Executor executor, String httpMethod,
      List<Map.Entry<String, String>> requestHeaders, @StreamPriority int priority,
      boolean delayRequestHeadersUntilFirstFlush, Collection<Object> requestAnnotations,
      boolean trafficStatsTagSet, int trafficStatsTag, boolean trafficStatsUidSet,
      int trafficStatsUid);

  @Override
  public ExperimentalUrlRequest.Builder
  newUrlRequestBuilder(String url, UrlRequest.Callback callback, Executor executor) {
    return new CronvoyUrlRequestBuilderImpl(url, callback, executor, this);
  }

  @IntDef({UrlRequest.Builder.REQUEST_PRIORITY_IDLE, UrlRequest.Builder.REQUEST_PRIORITY_LOWEST,
           UrlRequest.Builder.REQUEST_PRIORITY_LOW, UrlRequest.Builder.REQUEST_PRIORITY_MEDIUM,
           UrlRequest.Builder.REQUEST_PRIORITY_HIGHEST})
  @Retention(RetentionPolicy.SOURCE)
  public @interface RequestPriority {}

  @IntDef({
      BidirectionalStream.Builder.STREAM_PRIORITY_IDLE,
      BidirectionalStream.Builder.STREAM_PRIORITY_LOWEST,
      BidirectionalStream.Builder.STREAM_PRIORITY_LOW,
      BidirectionalStream.Builder.STREAM_PRIORITY_MEDIUM,
      BidirectionalStream.Builder.STREAM_PRIORITY_HIGHEST,
  })
  @Retention(RetentionPolicy.SOURCE)
  public @interface StreamPriority {}

  @IntDef({ExperimentalUrlRequest.Builder.DEFAULT_IDEMPOTENCY,
           ExperimentalUrlRequest.Builder.IDEMPOTENT,
           ExperimentalUrlRequest.Builder.NOT_IDEMPOTENT})
  @Retention(RetentionPolicy.SOURCE)
  public @interface Idempotency {}
}
package org.chromium.net.impl;

import android.content.Context;
import java.util.Arrays;
import org.chromium.net.CronetEngine;
import org.chromium.net.CronvoyProvider;
import org.chromium.net.ExperimentalCronetEngine;
import org.chromium.net.ICronetEngineBuilder;

/**
 * Implementation of {@link CronvoyProvider} that creates {@link CronetEngine.Builder}
 * for building the native implementation of {@link CronetEngine}.
 */
public class NativeCronvoyProvider extends CronvoyProvider {
  /**
   * Constructor.
   *
   * @param context Android context to use.
   */
  // TODO(carloseltuerto) find something similar to @UsedByReflection("CronetProvider.java")
  public NativeCronvoyProvider(Context context) { super(context); }

  @Override
  public CronetEngine.Builder createBuilder() {
    ICronetEngineBuilder impl = new NativeCronvoyEngineBuilderWithLibraryLoaderImpl(mContext);
    return new ExperimentalCronetEngine.Builder(impl);
  }

  @Override
  public String getName() {
    return CronvoyProvider.PROVIDER_NAME_APP_PACKAGED;
  }

  @Override
  public String getVersion() {
    return CronvoyImplVersion.getCronetVersion();
  }

  @Override
  public boolean isEnabled() {
    return true;
  }

  @Override
  public int hashCode() {
    return Arrays.hashCode(new Object[] {NativeCronvoyProvider.class, mContext});
  }

  @Override
  public boolean equals(Object other) {
    return other == this || (other instanceof NativeCronvoyProvider &&
                             this.mContext.equals(((NativeCronvoyProvider)other).mContext));
  }
}
load("@build_bazel_rules_android//android:rules.bzl", "android_library")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@rules_jvm_external//:defs.bzl", "artifact")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

# Android libraries for cronvoy

# An http client backed by Envoy-Mobile.
android_library(
    name = "cronvoy",
    srcs = [
        "Annotations.java",
        "AtomicCombinatoryState.java",
        "CancelProofEnvoyStream.java",
        "CronvoyBidirectionalState.java",
        "CronvoyBidirectionalStream.java",
        "CronvoyBidirectionalStreamBuilderImpl.java",
        "CronvoyBidirectionalStreamNetworkException.java",
        "CronvoyCallbackExceptionImpl.java",
        "CronvoyEngineBase.java",
        "CronvoyEngineBuilderImpl.java",
        "CronvoyExceptionImpl.java",
        "CronvoyImplVersion.java",
        "CronvoyLogger.java",
        "CronvoyMetrics.java",
        "CronvoyNetworkExceptionImpl.java",
        "CronvoyPreconditions.java",
        "CronvoyQuicExceptionImpl.java",
        "CronvoyRequestFinishedInfoImpl.java",
        "CronvoyUploadDataStream.java",
        "CronvoyUrlRequest.java",
        "CronvoyUrlRequestBase.java",
        "CronvoyUrlRequestBuilderImpl.java",
        "CronvoyUrlRequestContext.java",
        "CronvoyUrlResponseInfoImpl.java",
        "CronvoyUserAgent.java",
        "CronvoyVersionSafeCallbacks.java",
        "Errors.java",
        "Executors.java",
        "HttpReason.java",
        "NativeCronvoyEngineBuilderImpl.java",
        "NativeCronvoyEngineBuilderWithLibraryLoaderImpl.java",
        "NativeCronvoyProvider.java",
    ],
    manifest = "CronvoyManifest.xml",
    visibility = ["//visibility:public"],
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine/types:envoy_c_types_lib",
        "//library/java/io/envoyproxy/envoymobile/utilities",
        "//library/java/org/chromium/net",
        "//library/java/org/chromium/net/urlconnection",
        "@maven//:com_google_protobuf_protobuf_javalite",
        artifact("androidx.annotation:annotation"),
    ],
)
package org.chromium.net.impl;

import org.chromium.net.CronetException;

/** Implements {@link CronetException}. */
final class CronvoyExceptionImpl extends CronetException {

  CronvoyExceptionImpl(String message, Throwable cause) { super(message, cause); }
}
package org.chromium.net.impl;

import androidx.annotation.IntDef;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.concurrent.Executor;
import org.chromium.net.ExperimentalUrlRequest;
import org.chromium.net.UploadDataProvider;
import org.chromium.net.UrlRequest;

/**
 * Base class for classes that implement {@link UrlRequest} including experimental
 * features. {@link CronvoyUrlRequest} and {@link JavaUrlRequest} extends this class.
 */
abstract class CronvoyUrlRequestBase extends ExperimentalUrlRequest {
  /**
   * Sets the HTTP method verb to use for this request. Must be done before
   * request has started.
   *
   * <p>The default when this method is not called is "GET" if the request has
   * no body or "POST" if it does.
   *
   * @param method "GET", "HEAD", "DELETE", "POST" or "PUT".
   */
  protected abstract void setHttpMethod(String method);

  /**
   * Adds a request header. Must be done before request has started.
   *
   * @param header header name.
   * @param value header value.
   */
  protected abstract void addHeader(String header, String value);

  /**
   * Sets upload data provider. Must be done before request has started. May only be
   * invoked once per request. Switches method to "POST" if not explicitly
   * set. Starting the request will throw an exception if a Content-Type
   * header is not set.
   *
   * @param uploadDataProvider responsible for providing the upload data.
   * @param executor All {@code uploadDataProvider} methods will be invoked
   *     using this {@code Executor}. May optionally be the same
   *     {@code Executor} the request itself is using.
   */
  protected abstract void setUploadDataProvider(UploadDataProvider uploadDataProvider,
                                                Executor executor);

  /**
   * Possible URL Request statuses.
   */
  @IntDef({Status.INVALID, Status.IDLE, Status.WAITING_FOR_STALLED_SOCKET_POOL,
           Status.WAITING_FOR_AVAILABLE_SOCKET, Status.WAITING_FOR_DELEGATE,
           Status.WAITING_FOR_CACHE, Status.DOWNLOADING_PAC_FILE, Status.RESOLVING_PROXY_FOR_URL,
           Status.RESOLVING_HOST_IN_PAC_FILE, Status.ESTABLISHING_PROXY_TUNNEL,
           Status.RESOLVING_HOST, Status.CONNECTING, Status.SSL_HANDSHAKE, Status.SENDING_REQUEST,
           Status.WAITING_FOR_RESPONSE, Status.READING_RESPONSE})
  @Retention(RetentionPolicy.SOURCE)
  @interface StatusValues {}
}
package org.chromium.net.impl;

import android.util.Log;
import androidx.annotation.GuardedBy;
import androidx.annotation.IntDef;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.nio.ByteBuffer;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;
import org.chromium.net.UploadDataProvider;
import org.chromium.net.UploadDataSink;
import org.chromium.net.impl.Executors.DirectPreventingExecutor;

/**
 * CronvoyUploadDataStream handles communication between an upload body
 * encapsulated in the embedder's {@link UploadDataSink}.
 */
public final class CronvoyUploadDataStream extends UploadDataSink {

  private static final String TAG = CronvoyUploadDataStream.class.getSimpleName();
  private static final ByteBuffer EMPTY_BYTE_BUFFER = ByteBuffer.allocateDirect(0);
  private final int BYTE_BUFFER_SIZE = 65535; // H2 initial_stream_window_size

  // These are never changed, once a request starts.
  private final Executor mExecutor;
  private final CronvoyVersionSafeCallbacks.UploadDataProviderWrapper mDataProvider;
  private final CronvoyUrlRequest mRequest;
  private long mLength;
  private long mRemainingLength;

  // Reusable read task, to reduce redundant memory allocation.
  private final Runnable mReadTask = new Runnable() {
    @Override
    public void run() {
      read();
    }
  };

  // It is only valid from the call to mDataProvider.read until onError or onReadSucceeded.
  private ByteBuffer mByteBuffer;
  private int mByteBufferLimit;

  // Lock that protects all subsequent variables. The adapter has to be
  // protected to ensure safe shutdown, mReading and mRewinding are protected
  // to robustly detect getting read/rewind results more often than expected.
  private final Object mLock = new Object();

  // Whether the CronetUploadDataStream is active or not
  @GuardedBy("mLock") private boolean mUploadDataStreamActive;

  @IntDef({UserCallback.READ, UserCallback.REWIND, UserCallback.GET_LENGTH,
           UserCallback.NOT_IN_CALLBACK})
  @Retention(RetentionPolicy.SOURCE)
  private @interface UserCallback {
    int READ = 0;
    int REWIND = 1;
    int GET_LENGTH = 2;
    int NOT_IN_CALLBACK = 3;
  }

  @GuardedBy("mLock") private @UserCallback int mInWhichUserCallback = UserCallback.NOT_IN_CALLBACK;
  @GuardedBy("mLock") private boolean mClosedPostponed;

  /**
   * Constructs a CronetUploadDataStream.
   * @param dataProvider the UploadDataProvider to read data from.
   * @param executor the Executor to execute UploadDataProvider tasks.
   */
  public CronvoyUploadDataStream(UploadDataProvider dataProvider, Executor executor,
                                 CronvoyUrlRequest request) {
    mExecutor = executor;
    mDataProvider = new CronvoyVersionSafeCallbacks.UploadDataProviderWrapper(dataProvider);
    mRequest = request;
  }

  /**
   * Called by native code to make the UploadDataProvider read data into
   * {@code byteBuffer}.
   * @param originalThread
   */
  void readDataReady() {
    if (mRemainingLength != 0) {
      postTaskToExecutor(mReadTask);
    } else {
      Runnable task = new Runnable() {
        @Override
        public void run() {
          mRequest.checkCallingThread();
          mRequest.send(EMPTY_BYTE_BUFFER, true);
          close();
        }
      };
      postTaskToExecutor(task);
    }
  }

  /**
   * Called to make the UploadDataProvider rewind upload data.
   */
  void rewind() {
    Runnable task = new Runnable() {
      @Override
      public void run() {
        synchronized (mLock) {
          checkState(UserCallback.NOT_IN_CALLBACK);
          mInWhichUserCallback = UserCallback.REWIND;
        }
        try {
          mDataProvider.rewind(CronvoyUploadDataStream.this);
        } catch (Exception exception) {
          onError(exception);
        }
      }
    };
    postTaskToExecutor(task);
  }

  @GuardedBy("mLock")
  private void checkState(@UserCallback int mode) {
    if (mInWhichUserCallback != mode) {
      throw new IllegalStateException("Expected " + mode + ", but was " + mInWhichUserCallback);
    }
  }

  private void read() {
    mRequest.checkCallingThread();
    synchronized (mLock) {
      if (!mUploadDataStreamActive) {
        return;
      }
      checkState(UserCallback.NOT_IN_CALLBACK);
      mInWhichUserCallback = UserCallback.READ;
    }
    try {
      // The mRemainingLength+1 is a hack to have the original tests passing - not really needed.
      mByteBufferLimit = mRemainingLength < 0 || mRemainingLength > BYTE_BUFFER_SIZE
                             ? BYTE_BUFFER_SIZE
                             : (int)mRemainingLength + 1;
      mByteBuffer = mRemainingLength < 0 || mRemainingLength > BYTE_BUFFER_SIZE
                        ? ByteBuffer.allocateDirect(BYTE_BUFFER_SIZE)
                        : ByteBuffer.allocate(mByteBufferLimit);
      mDataProvider.read(CronvoyUploadDataStream.this, mByteBuffer);
    } catch (Exception exception) {
      onError(exception);
    }
  }

  /**
   * Helper method called when an exception occurred. This method resets
   * states and propagates the error to the request.
   */
  private void onError(Exception exception) {
    final boolean sendClose;
    synchronized (mLock) {
      if (mInWhichUserCallback == UserCallback.NOT_IN_CALLBACK) {
        throw new IllegalStateException("There is no read or rewind or length check in progress.");
      }
      mInWhichUserCallback = UserCallback.NOT_IN_CALLBACK;
    }
    closeIfPostponed();

    // Just fail the request - simpler to fail directly, and
    // UploadDataStream only supports failing during initialization, not
    // while reading. The request is smart enough to handle the case where
    // it was already canceled by the embedder.
    mRequest.onUploadException(exception);
  }

  @Override
  public void onReadSucceeded(boolean lastChunk) {
    synchronized (mLock) {
      checkState(UserCallback.READ);
      if (mByteBufferLimit != mByteBuffer.limit()) {
        throw new IllegalStateException("ByteBuffer limit changed");
      }
      if (lastChunk && mLength >= 0) {
        throw new IllegalArgumentException("Non-chunked upload can't have last chunk");
      }
      int bytesRead = mByteBuffer.position();
      mRemainingLength -= bytesRead;
      if (mRemainingLength < 0 && mLength >= 0) {
        throw new IllegalArgumentException(
            String.format("Read upload data length %d exceeds expected length %d",
                          mLength - mRemainingLength, mLength));
      }
      mInWhichUserCallback = UserCallback.NOT_IN_CALLBACK;

      closeIfPostponed();
      if (!mUploadDataStreamActive) {
        return;
      }
    }
    mRequest.send(mByteBuffer, lastChunk || mRemainingLength == 0);
    mByteBuffer = null;
  }

  @Override
  public void onReadError(Exception exception) {
    synchronized (mLock) { checkState(UserCallback.READ); }
    onError(exception);
  }

  @Override
  public void onRewindSucceeded() {
    synchronized (mLock) {
      checkState(UserCallback.REWIND);
      mInWhichUserCallback = UserCallback.NOT_IN_CALLBACK;
      // Request may been canceled already.
      if (!mUploadDataStreamActive) {
        return;
      }
    }
    mRemainingLength = mLength;
    mRequest.followRedirectAfterSuccessfulRewind();
    readDataReady();
  }

  @Override
  public void onRewindError(Exception exception) {
    synchronized (mLock) { checkState(UserCallback.REWIND); }
    onError(exception);
  }

  /**
   * Posts task to application Executor.
   */
  private void postTaskToExecutor(Runnable task) {
    try {
      mExecutor.execute(task);
    } catch (RejectedExecutionException e) {
      // Just fail the request. The request is smart enough to handle the
      // case where it was already canceled by the embedder.
      mRequest.onUploadException(e);
    }
  }

  /**
   * Closes safely when there is no pending read.
   */
  void close() {
    synchronized (mLock) {
      if (mInWhichUserCallback == UserCallback.READ) {
        // Wait for the read to complete before destroy the adapter.
        mClosedPostponed = true;
        return;
      }
      if (!mUploadDataStreamActive) {
        return;
      }
      mUploadDataStreamActive = false;
    }
    Runnable task = new Runnable() {
      @Override
      public void run() {
        mRequest.checkCallingThread();
        try {
          mDataProvider.close();
        } catch (Exception e) {
          Log.e(TAG, "Exception thrown when closing", e);
        }
      }
    };
    postTaskToExecutor(task);
  }

  /**
   * Closes when a pending read which has since completed. Caller needs to be on executor thread.
   */
  private void closeIfPostponed() {
    synchronized (mLock) {
      if (mInWhichUserCallback == UserCallback.READ) {
        throw new IllegalStateException("Method should not be called when read has not completed.");
      }
      if (mClosedPostponed) {
        close();
      }
    }
  }

  /**
   * Initializes upload length by getting it from data provider, then follows with sending the
   * first chunk of the request body. These two initial tasks are not launched by the network
   * Thread.
   */
  void initializeWithRequest() {
    // Thread taskLauncherThread = Thread.currentThread();
    Runnable task = new Runnable() {
      @Override
      public void run() {
        synchronized (mLock) {
          mInWhichUserCallback = UserCallback.GET_LENGTH;
          mUploadDataStreamActive = true;
        }
        try {
          mLength = mDataProvider.getLength();
          mRemainingLength = mLength;
        } catch (Exception t) {
          onError(t);
          return;
        } finally {
          synchronized (mLock) { mInWhichUserCallback = UserCallback.NOT_IN_CALLBACK; }
        }
        readDataReady();
      }
    };
    // This task can not be launched by the Network Thread, so plan B is used here to ensure
    // that this is not a direct executor when disallowed.
    Executor executor =
        mRequest.isAllowDirectExecutor() ? mExecutor : new DirectPreventingExecutor(mExecutor);
    try {
      executor.execute(task);
    } catch (RejectedExecutionException e) {
      mRequest.onUploadException(e);
    }
  }
}
package org.chromium.net.impl;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import io.envoyproxy.envoymobile.engine.types.EnvoyLogger;

/*
 * CronvoyLogger
 *
 * This class bridges Envoy and Cronet logging by providing an EnvoyLogger with Envoy's log API
 * which also has Cronet-style setNetLogToFile and setNetLogToDisk functions.
 *
 * The Envoy engine is supplied the logger on start-up but will only log at the configured log
 * level (Cronvoy defaults logging off). When logging is desired, the CronvoyUrlRequestContext
 * sets the Envoy log level to TRACE or DEBUG (based on if logAll is set), and passes the desired
 * log info to the CronvoyLogger. The CronvoyLogger will then in append pass Envoy log messages to
 * the desired file until CronvoyUrlRequestContext.stopNetLog disables Envoy logging.
 *
 */
final class CronvoyLogger implements EnvoyLogger {
  private int mFilesize = 0;
  private String mFileName = null;
  private FileWriter mWriter = null;
  static final String LOG_TAG = CronvoyUrlRequestContext.class.getSimpleName();

  public CronvoyLogger() {}

  public void stopLogging() {
    mFileName = null;
    try {
      if (mWriter != null) {
        mWriter.close();
      }
    } catch (IOException e) {
      android.util.Log.e(LOG_TAG, "Failed to stop logging", e);
    }
    mWriter = null;
  }

  @Override
  public void log(String str) {
    if (mWriter != null) {
      try {
        Path path = Paths.get(mFileName);
        // For now, just delete the file if it gets overlarge.
        // If we need to we can copy the first half.
        if (mFilesize > 0 && Files.size(path) > mFilesize) {
          File file = new File(mFileName);
          file.delete();
          file.createNewFile();
          mWriter = new FileWriter(file, true);
        }
        mWriter.write(str);
        mWriter.flush();
      } catch (IOException e) {
        android.util.Log.e(LOG_TAG, "Failed to log message", e);
      }
    }
  }

  public void setNetLogToFile(String fileName) {
    try {
      mFilesize = 0;
      mFileName = fileName;
      File file = new File(mFileName);
      file.createNewFile();
      mWriter = new FileWriter(file, true);
    } catch (IOException e) {
      android.util.Log.e(LOG_TAG, "Failed to start logging", e);
    }
  }

  public void setNetLogToDisk(String dirPath, int maxSize) {
    try {
      mFilesize = maxSize;
      // This is the default Cronet logfile name.
      mFileName = dirPath + "/netlog.json";
      File directory = new File(dirPath);
      directory.mkdirs();
      File file = new File(mFileName);
      file.createNewFile();
      mWriter = new FileWriter(file, true);
    } catch (IOException e) {
      android.util.Log.e(LOG_TAG, "Failed to start logging", e);
    }
  }
}
package org.chromium.net.impl;

import java.util.concurrent.Executor;
import org.chromium.net.InlineExecutionProhibitedException;

/** Utilities related to {@link Executor}s. */
final class Executors {

  /**
   * Interface used to run commands that could throw an exception. Specifically useful for calling
   * {@link org.chromium.net.UrlRequest.Callback}s on a user-supplied executor.
   */
  interface CheckedRunnable {
    void run() throws Exception;
  }

  /** Executor that detects and throws if its delegate runs a submitted runnable inline. */
  static final class DirectPreventingExecutor implements Executor {
    private final Executor delegate;

    /**
     * Constructs an {@link DirectPreventingExecutor} that executes {@link Runnable}s on the
     * provided {@link Executor}.
     *
     * @param delegate the {@link Executor} used to run {@link Runnable}s
     */
    DirectPreventingExecutor(Executor delegate) { this.delegate = delegate; }

    /**
     * Executes a {@link Runnable} on this {@link Executor} and throws an exception if it is being
     * run on the same thread as the calling thread.
     *
     * @param command the {@link Runnable} to attempt to run
     */
    @Override
    public void execute(Runnable command) {
      Thread currentThread = Thread.currentThread();
      InlineCheckingRunnable runnable = new InlineCheckingRunnable(command, currentThread);
      delegate.execute(runnable);
      // This next read doesn't require synchronization; only the current thread could have
      // written to runnable.mExecutedInline.
      if (runnable.executedInline != null) {
        throw runnable.executedInline;
      } else {
        // It's possible that this method is being called on an executor, and the runnable
        // that was just queued will run on this thread after the current runnable returns.
        // By nulling out the mCallingThread field, the InlineCheckingRunnable's current
        // thread comparison will not fire.
        //
        // Java reference assignment is always atomic (no tearing, even on 64-bit VMs, see
        // JLS 17.7), but other threads aren't guaranteed to ever see updates without
        // something like locking, volatile, or AtomicReferences. We're ok in
        // this instance, since this write only needs to be seen in the case that
        // InlineCheckingRunnable.run() runs on the same thread as this execute() method.
        runnable.callingThread = null;
      }
    }

    private static class InlineCheckingRunnable implements Runnable {
      private final Runnable command;
      private Thread callingThread;
      private InlineExecutionProhibitedException executedInline;

      private InlineCheckingRunnable(Runnable command, Thread callingThread) {
        this.command = command;
        this.callingThread = callingThread;
      }

      @Override
      public void run() {
        if (Thread.currentThread() == callingThread) {
          // Can't throw directly from here, since the delegate executor could catch this
          // exception.
          executedInline = new InlineExecutionProhibitedException();
          return;
        }
        command.run();
      }
    }
  }

  private Executors() {}
}
package org.chromium.net.impl;

import androidx.annotation.IntDef;

import org.chromium.net.RequestFinishedInfo;
import org.chromium.net.impl.CronvoyRequestFinishedInfoImpl.FinishedReason;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Holder the the current state associated to a bidirectional stream. The main goal is to provide
 * a mean to determine what should be the next action for a given event by considering the
 * current state. This class uses Compare And Swap logic. The next state is saved with
 * {@code AtomicInteger.compareAndSet()}.
 *
 * <p>All methods in this class are Thread Safe.
 *
 * <p><b>WRITE state diagram</b>
 * <li>There are 11 states represented by 5 State bits.
 * <li>The USER_WRITE event can occur on any state - it does not change the state. However, if
 * attempted after a USER_LAST_WRITE event, the this will throw an Exception. It is absent from
 * the diagram.
 * <li>The WRITE_COMPLETED event does not change the state and is therefore absent from the diagram.
 * <li>The USER_FLUSH event won't change the state if the request headers have been sent.
 * <li>The READY_TO_FLUSH event will not change the state if the current state is "Busy" or
 * "BusyAndEnding" (in general, if the state bit WAITING_FOR_FLUSH is false.)
 *
 * <p><pre>
 * Write State                State bits use to represent the write state
 * -----------                -------------------------------------------
 * Starting:                  []
 * Ending:                    [END_STREAM_WRITTEN]
 * ReadyWaitHeaders:          [WAITING_FOR_FLUSH]
 * Ready:                     [WAITING_FOR_FLUSH, HEADERS_SENT]
 * ReadyWaitHeadersAndEnding: [WAITING_FOR_FLUSH, END_STREAM_WRITTEN]
 * WaitHeaders:               [WAITING_FOR_FLUSH, END_STREAM_WRITTEN, DONE]
 * ReadyAndEnding:            [WAITING_FOR_FLUSH, END_STREAM_WRITTEN,
 *                             HEADERS_SENT]
 * Busy:                      [WRITING, HEADERS_SENT]
 * BusyAndEnding:             [WRITING, HEADERS_SENT, END_STREAM_WRITTEN]
 * WaitingDone:               [END_STREAM_WRITTEN, HEADERS_SENT]
 * WriteDone:                 [WRITE_DONE, END_STREAM_WRITTEN, HEADERS_SENT]
 *
 *
 * |-------------|     USER_START_    |-----------| <-- LAST_WRITE_COMPLETED --
 * |  Starting   | -- WITH_HEADERS -> | WriteDone | <---------------          |
 * |-------------|     _READ_ONLY     |-----------| <---------     |          |
 *  |     |  |  |                                            |     |          |
 *  |     |  |  -- USER_START_READ_ONLY --                   |     |          |
 *  |     |  |                           V                   |     |          |
 *  |     |  |                |-------------| -- USER_FLUSH --     |          |
 *  |     |  |                | WaitHeaders |                      |          |
 *  |     |  |                |-------------| <--------            |          |
 *  |     |  |                                        |            |          |
 *  |     |  -- USER_LAST_WRITE ---                   |            |          |
 *  |     |                       V                   |            |          |
 *  |     |                  |--------| -- USER_START_READ_ONLY    |          |
 *  |     |                  | Ending | -- USER_START_WITH_HEADERS_READ_ONLY  |
 *  |  USER_START            |--------| -- USER_START_WITH_HEADERS            |
 *  |     |                       |                        |                  |
 *  |     V                       -- USER_START --         V                  |
 *  |  |------------------|                      |  |----------------|        |
 *  |  | ReadyWaitHeaders | -- USER_LAST_WRITE   |  | ReadyAndEnding | --     |
 *  |  |------------------| --        |          |  |----------------|  |     |
 *  |                        |        |          |                      |     |
 * USER_START_WITH_HEADERS   |        V          V                      |     |
 *    |                      |  |---------------------------|           |     |
 *    |  ------------------->|  | ReadyWaitHeadersAndEnding | --------->|     |
 *    V  |                   |  |---------------------------|   |       |     |
 * |-------| <--USER_FLUSH ---                                  |       |     |
 * | Ready | ------------------------ USER_LAST_WRITE ----      |  USER_FLUSH |
 * |-------| <--------                                   |      |       |     |
 *    |              |                                   V      |       |     |
 *    |              |         READY_TO_FLUSH ---- |----------------|   |     |
 * READY_TO_FLUSH    |             |               | ReadyAndEnding | <--     |
 *    |              |             V           --> |----------------|         |
 *    V              |     |---------------|   |              |               |
 * |------|          |     | BusyAndEnding |   |      READY_TO_FLUSH_LAST     |
 * | Busy |          |     |---------------|   |              V               |
 * |______|          |             |           |       |-------------|        |
 *    |              |      ON_SEND_WINDOW_AVAILABLE   | WaitingDone | --------
 * ON_SEND_WINDOW_AVAILABLE                            |-------------|
 * </pre>
 *
 * <p><b>READ state diagram</b>
 * <li>There are 16 states represented by 7 State bits.
 * <li>Some "read" related events don't change the state, like "ON_DATA". Those are omitted.
 * <li>There is something very peculiar about the "last read". When EM indicates that there is no
 * more data to receive, then the END_STREAM_READ state bit is set to one, as expected. However, if
 * the last ByteBuffer received is not empty, or if the response is "body less", then the final
 * "read" loop must be faked: the final read must return zero bytes by contract.
 *
 * <p><pre>
 * Read State                      State bits use to represent the read state
 * ----------                      ------------------------------------------
 * Starting:                       []
 * ReadyWaitingHeadersAndStreamOk: [WAITING_FOR_READ]
 * ReadyWaitingHeaders:            [WAITING_FOR_READ, STREAM_READY_EXECUTED]
 * Postponed:                      [READ_POSTPONED]
 * ReadyWaitingStreamOk:           [WAITING_FOR_READ, HEADERS_RECEIVED]
 * ReadyWaitingStreamOkLast:       [WAITING_FOR_READ, HEADERS_RECEIVED,
 *                                  END_STREAM_READ]
 * PostponedWaitingHeaders:        [READ_POSTPONED, STREAM_READY_EXECUTED]
 * PostponedWaitingStreamOk:       [READ_POSTPONED, HEADERS_RECEIVED]
 * PostponedWaitingStreamOkLast:   [READ_POSTPONED, HEADERS_RECEIVED,
 *                                  END_STREAM_READ]
 * PostponeReady:                  [READ_POSTPONED, STREAM_READY_EXECUTED,
 *                                  HEADERS_RECEIVED]
 * PostponeReadyLast:              [READ_POSTPONED, STREAM_READY_EXECUTED,
 *                                  HEADERS_RECEIVED, END_STREAM_READ]
 * Ready:                          [WAITING_FOR_READ, HEADERS_RECEIVED,
 *                                  STREAM_READY_EXECUTED]
 * ReadyLast:                      [WAITING_FOR_READ, HEADERS_RECEIVED,
 *                                  STREAM_READY_EXECUTED, END_STREAM_READ]
 * Reading:                        [READING, HEADERS_RECEIVED,
 *                                  STREAM_READY_EXECUTED]
 * ReadingLast:                    [READING, HEADERS_RECEIVED,
 *                                  STREAM_READY_EXECUTED, END_STREAM_READ]
 * ReadDone:                       [STREAM_READY_EXECUTED, END_STREAM_READ,
 *                                  READ_DONE]
 *
 *
 *    |-------------| -- USER_START* --> |--------------------------------|
 *    |  Starting   |                    | ReadyWaitingHeadersAndStreamOk |
 *    |-------------|    --------------- |--------------------------------|
 *                       |                  |                    |
 *    STREAM_READY_CALLBACK_DONE           READ              ON_HEADERS*
 *                       |                  |                    |
 *                       V                  V                    V
 *    |---------------------|      |-----------|   |--------------------------|
 *    | ReadyWaitingHeaders |      | Postponed |   | ReadyWaitingStreamOk or  |
 *    |---------------------|      |-----------|   | ReadyWaitingStreamOkLast |
 *     |    |                       |         |    |--------------------------|
 *     |    |                       |         |               |              |
 *     |   READ  STREAM_READY_CALLBACK_DONE  ON_HEADERS*     READ            |
 *     |    |                       |         |               |              |
 *     |    V                       V         V               V              |
 *     |   |-------------------------|   |------------------------------|    |
 *     |   | PostponedWaitingHeaders |   | PostponedWaitingStreamOk or  |    |
 *     |   |-------------------------|   | PostponedWaitingStreamOkLast |    |
 *     |                |                |------------------------------|    |
 *     |                |                       |                            |
 *  ON_HEADERS*     ON_HEADERS*       STREAM_READY_CALLBACK_DONE             |
 *     |                |                       |                            |
 *     V                V                       |                            |
 * |-----------|   |-------------------|        |                            |
 * | Ready or  |   | PostponeReady or  | <-------              |----------|  |
 * | ReadyLast |   | PostponeReadyLast |                       | ReadDone |  |
 * |-----------|   |-------------------|                       |----------|  |
 *  ^   ^   |                    |                                      ^    |
 *  |   |   |     READY_TO_START_POSTPONED_READ_IF_ANY                  |    |
 *  |   |   |                    |                                      |    |
 *  |   |   |                    V                                      |    |
 *  |   |   |                |-------------| -- LAST_READ_COMPLETED -----    |
 *  |   |   ----- READ ----> | Reading or  | -- ON_DATA_END_STREAM ---       |
 *  |   |                    | ReadingLast |  Reading -> ReadingLast |       |
 *  |   -- READ_COMPLETED -- |-------------| <------------------------       |
 *  |                                                                        |
 *  -------------------------------------------- STREAM_READY_CALLBACK_DONE --
 * </pre>
 */
final class CronvoyBidirectionalState {

  /**
   * Enum of the events altering the global state. There are 3 types of events: User induced
   * (prefixed with USER_), EM Callbacks (prefixed with ON_), and internal events (the remaining
   * ones).
   */
  @IntDef({
      Event.USER_START,
      Event.USER_START_WITH_HEADERS,
      Event.USER_START_READ_ONLY,
      Event.USER_START_WITH_HEADERS_READ_ONLY,
      Event.USER_WRITE,
      Event.USER_LAST_WRITE,
      Event.USER_FLUSH,
      Event.USER_READ,
      Event.USER_CANCEL,
      Event.ON_SEND_WINDOW_AVAILABLE,
      Event.ON_HEADERS,
      Event.ON_HEADERS_END_STREAM,
      Event.ON_DATA,
      Event.ON_DATA_END_STREAM,
      Event.ON_TRAILERS,
      Event.ON_COMPLETE,
      Event.ON_CANCEL,
      Event.ON_ERROR,
      Event.ERROR,
      Event.STREAM_READY_CALLBACK_DONE,
      Event.READY_TO_FLUSH,
      Event.READY_TO_FLUSH_LAST,
      Event.WRITE_COMPLETED,
      Event.READY_TO_START_POSTPONED_READ_IF_ANY,
      Event.READ_COMPLETED,
      Event.LAST_WRITE_COMPLETED,
      Event.LAST_READ_COMPLETED,
      Event.READY_TO_FINISH,
  })
  @Retention(RetentionPolicy.SOURCE)
  @interface Event {
    int USER_START = 0; // Ready. Don't send request headers yet. There will be a request body.
    int USER_START_WITH_HEADERS = 1; // Ready to send request headers. There will be a request body.
    int USER_START_READ_ONLY = 2;    // Ready. Don't send request headers yet. No request body.
    int USER_START_WITH_HEADERS_READ_ONLY = 3; // Ready to send request headers. No request body.
    int USER_WRITE = 4;      // User adding a ByteBuffer in the pending queue - not the last one.
    int USER_LAST_WRITE = 5; // User adding a ByteBuffer in the pending queue - that's the last one.
    int USER_FLUSH = 6;      // User requesting to push the pending buffers/headers on the wire.
    int USER_READ = 7;       // User requesting to read the next chunk from the wire.
    int USER_CANCEL = 8;     // User requesting to cancel the stream.
    int ON_SEND_WINDOW_AVAILABLE = 9; // EM invoked the "onSendWindowAvailable" callback.
    int ON_HEADERS = 10;            // EM invoked the "onHeaders" callback - response body to come.
    int ON_HEADERS_END_STREAM = 11; // EM invoked the "onHeaders" callback - no response body.
    int ON_DATA = 12;            // EM invoked the "onData" callback - not last "onData" callback.
    int ON_DATA_END_STREAM = 13; // EM invoked the "onData" callback - final "onData" callback.
    int ON_TRAILERS = 14;        // EM invoked the "onTrailers" callback.
    int ON_COMPLETE = 15;        // EM invoked the "onComplete" callback.
    int ON_CANCEL = 16;          // EM invoked the "onCancel" callback.
    int ON_ERROR = 17;           // EM invoked the "onError" callback.
    int ERROR = 18;              // A fatal error occurred. Can be an internal, or user related.
    int STREAM_READY_CALLBACK_DONE = 19; // Callback.streamReady() was executed.
    int READY_TO_FLUSH = 20; // Internal Event indicating readiness to write the next ByteBuffer.
    int READY_TO_FLUSH_LAST = 21; // Internal Event indicating readiness to write last ByteBuffer.
    int WRITE_COMPLETED = 22; // Internal event indicating to tell the user about a completed write.
    int READY_TO_START_POSTPONED_READ_IF_ANY = 23; // Internal event. The Enum name says it all...
    int READ_COMPLETED = 24; // Internal event indicating to tell the user about a completed read.
    int LAST_WRITE_COMPLETED = 25; // Internal event indicating to tell the user about final write.
    int LAST_READ_COMPLETED = 26;  // Internal event indicating to tell the user about final read.
    int READY_TO_FINISH = 27;      // Internal event indicating to tell the user about success.
  }

  /**
   * Enum of the Next Actions to be taken.
   *
   * <p>There are two types of "NextAction": the ones requesting to notify the user, and the
   * internal ones. For the User notifications, "Schedule" means that the Network Thread is posting
   * a task that will perform the notification, and "Execute" means that the logic is already
   * running under a Thread specified by the User - the notification is executed directly.
   */
  @IntDef({NextAction.NOTIFY_USER_STREAM_READY, NextAction.NOTIFY_USER_HEADERS_RECEIVED,
           NextAction.NOTIFY_USER_WRITE_COMPLETED, NextAction.NOTIFY_USER_READ_COMPLETED,
           NextAction.NOTIFY_USER_TRAILERS_RECEIVED, NextAction.NOTIFY_USER_SUCCEEDED,
           NextAction.NOTIFY_USER_NETWORK_ERROR, NextAction.NOTIFY_USER_FAILED,
           NextAction.NOTIFY_USER_CANCELED, NextAction.WRITE, NextAction.CHAIN_NEXT_WRITE,
           NextAction.FLUSH_HEADERS, NextAction.SEND_DATA, NextAction.READ,
           NextAction.POSTPONE_READ, NextAction.INVOKE_ON_READ_COMPLETED, NextAction.CANCEL,
           NextAction.CARRY_ON, NextAction.TAKE_NO_MORE_ACTIONS})
  @Retention(RetentionPolicy.SOURCE)
  @interface NextAction {
    int NOTIFY_USER_STREAM_READY = 0;      // Schedule Callback.streamReady()
    int NOTIFY_USER_HEADERS_RECEIVED = 1;  // Schedule/Execute Callback.onResponseHeadersReceived()
    int NOTIFY_USER_WRITE_COMPLETED = 2;   // Execute Callback.onWriteCompleted()
    int NOTIFY_USER_READ_COMPLETED = 3;    // Execute Callback.onReadeCompleted()
    int NOTIFY_USER_TRAILERS_RECEIVED = 4; // Schedule Callback.onResponseTrailersReceived()
    int NOTIFY_USER_SUCCEEDED = 5;         // Schedule/Execute Callback.onSucceeded()
    int NOTIFY_USER_NETWORK_ERROR = 6;     // Schedule Callback.onFailed()
    int NOTIFY_USER_FAILED = 7;            // Schedule Callback.onFailed()
    int NOTIFY_USER_CANCELED = 8;          // Schedule Callback.onCanceled()
    int WRITE = 9;                         // Add one more ByteBuffer to the pending queue.
    int CHAIN_NEXT_WRITE = 10;             // Initiate write completion and start next write.
    int FLUSH_HEADERS = 11;                // Start sending request headers.
    int SEND_DATA = 12;                    // Send one ByteBuffer on the wire, if any.
    int READ = 13;                         // Start reading the next chunk of the response body.
    int POSTPONE_READ = 14;                // Don't read for the moment - that action is postpone.
    int INVOKE_ON_READ_COMPLETED = 15;     // Initiate the completion of a read operation.
    int CANCEL = 16;               // Tell EM to cancel. Can be an user induced, or due to error.
    int CARRY_ON = 17;             // Do nothing special at the moment - keep calm and carry on.
    int TAKE_NO_MORE_ACTIONS = 18; // The stream is already in final state - don't do anything else.
  }

  /**
   * Bitmap used to express the global state of the BIDI Stream. Each bit represent one element of
   * the global state.
   *
   * <p>For debugging, the bits were groups by HEX digits. This "println" is very helpful - to be
   * put just before "return nextAction;"
   *
   * <pre>{@code
     System.err.println(String.format(
       "OOOO nextAction - event:%d nextAction:%d originalState:0x%08X nextState:0x%08X Thread: %s",
       event, nextAction, originalState, nextState, Thread.currentThread().getName()));
   * }</pre>
   */
  @IntDef(flag = true, // This is not used as an Enum nor as the argument of a switch statement.
          value = {State.NOT_STARTED,
                   State.STARTED,
                   State.ON_COMPLETE_RECEIVED,
                   State.USER_CANCELLED,
                   State.WAITING_FOR_FLUSH,
                   State.HEADERS_SENT,
                   State.WRITING,
                   State.END_STREAM_WRITTEN,
                   State.WRITE_DONE,
                   State.WAITING_FOR_READ,
                   State.STREAM_READY_EXECUTED,
                   State.READ_POSTPONED,
                   State.HEADERS_RECEIVED,
                   State.READING,
                   State.END_STREAM_READ,
                   State.READ_DONE,
                   State.CANCELLING,
                   State.FAILED,
                   State.DONE,
                   State.TERMINATING_STATES})
  @Retention(RetentionPolicy.SOURCE)
  private @interface State {
    // Internal state bits: Right most digit of the HEX representation: 0x0000007
    int NOT_STARTED = 0;               // Initial state.
    int STARTED = 1;                   // Started.
    int ON_COMPLETE_RECEIVED = 1 << 1; // EM's "onComplete" callback has been invoked.
    int USER_CANCELLED = 1 << 2;       // The cancel operation was initiated by the User.

    // WRITE state bits: Second and third right most digits of the HEX representation: 0x0001F0
    int WAITING_FOR_FLUSH = 1 << 4;  // User is expected to invoke "flush" at one point.
    int HEADERS_SENT = 1 << 5;       // EM's "sendHeaders" method has been invoked.
    int WRITING = 1 << 6;            // One RequestBody's Buffer is being sent on the wire.
    int END_STREAM_WRITTEN = 1 << 7; // User can't invoke "write" anymore. Maybe never could.
    int WRITE_DONE = 1 << 8;         // User won't receive more write callbacks. Maybe never had.

    // READ state bits: Fourth and fifth right most digits of the HEX representation: 0x07F000
    int WAITING_FOR_READ = 1 << 12;      // User is expected to invoke "read" at one point.
    int STREAM_READY_EXECUTED = 1 << 13; // Callback.streamReady() was executed
    int READ_POSTPONED = 1 << 14;        // User read was requested before receiving the headers.
    int HEADERS_RECEIVED = 1 << 15;      // EM's "onHeaders" callback has been invoked.
    int READING = 1 << 16;               // One ResponseBody's Buffer is being read from the wire.
    int END_STREAM_READ = 1 << 17;       // EM will not invoke the "onData" callback anymore.
    int READ_DONE = 1 << 18;             // User won't receive more read callbacks.

    // Terminating state bits: Sixth right most digit of the HEX representation: 0x700000
    int CANCELLING = 1 << 20; // EM's "cancel" method has been invoked.
    int FAILED = 1 << 21;     // An fatal failure has been encountered.
    int DONE = 1 << 22;       // Terminal state. Can be successful or otherwise.

    int TERMINATING_STATES = CANCELLING | FAILED | DONE; // Hold your breath and count to ten.
  }

  private final AtomicInteger mState = new AtomicInteger(State.NOT_STARTED);

  /**
   * Returns true if the final state has been reached. At this point the EM Stream has been
   * destroyed.
   */
  boolean isDone() { return (mState.get() & State.DONE) != 0; }

  /**
   * Returns true if a terminating state has been reached. Terminating does not necessarily means
   * that the DONE state has been reached. When the DONE bit is not set, it means that we are not
   * ready yet to inform the user about the failure, as the EM as not yet destroyed the Stream. In
   * other words, EM has not yet invoked a terminal callback (onError, onCancel, onComplete).
   */
  boolean isTerminating() { return (mState.get() & State.TERMINATING_STATES) != 0; }

  /**
   * Returns the reason why the request finished. Can only be invoked if {@link #isDone} returns
   * true.
   *
   * @return one of {@link RequestFinishedInfo#SUCCEEDED}, {@link RequestFinishedInfo#FAILED}, or
   *     {@link RequestFinishedInfo#CANCELED}
   */
  @FinishedReason
  int getFinishedReason() {
    assert isDone();
    @State int finalState = mState.get();
    if ((finalState & State.FAILED) != 0) {
      return RequestFinishedInfo.FAILED;
    }
    if ((finalState & State.USER_CANCELLED) != 0) {
      return RequestFinishedInfo.CANCELED;
    }
    return RequestFinishedInfo.SUCCEEDED;
  }

  /**
   * Establishes what is the next action by taking in account the current global state, and the
   * provided {@link Event}. This method has one important side effect: the resulting global state
   * is saved through an Atomic operation. For few cases, this method will throw when the state is
   * not compatible with the event.
   */
  @NextAction
  int nextAction(@Event final int event) {
    // With "Compare And Swap", the contract is the mutation succeeds only if the original value
    // matches the expected one - this is atomic at the assembly language level: most CPUs have
    // dedicated mnemonics for this operation - extremely efficient. And this might look like an
    // infinite loop. It is infinite only if many Threads are eternally attempting to concurrently
    // change the value. In fact, "Compare And Swap" is pretty bad under heavy contention - in
    // that case it is probably better to go with "synchronized" blocks. In our case, there is
    // none or very little contention. What matters is correctness and efficiency.
    while (true) {
      @State final int originalState = mState.get();

      if (isAlreadyFinalState(event, originalState)) {
        return NextAction.TAKE_NO_MORE_ACTIONS; // No need to loop - this is irreversible.
      }

      @NextAction final int nextAction;
      @State int nextState = originalState;
      switch (event) {
      case Event.USER_START:
      case Event.USER_START_WITH_HEADERS:
      case Event.USER_START_READ_ONLY:
      case Event.USER_START_WITH_HEADERS_READ_ONLY:
        nextState |= State.WAITING_FOR_READ | State.STARTED;
        if (event == Event.USER_START_READ_ONLY ||
            event == Event.USER_START_WITH_HEADERS_READ_ONLY) {
          nextState |= State.END_STREAM_WRITTEN | State.WRITE_DONE;
        }
        if (event != Event.USER_START_WITH_HEADERS_READ_ONLY) {
          nextState |= State.WAITING_FOR_FLUSH;
        }
        if (event == Event.USER_START_WITH_HEADERS ||
            event == Event.USER_START_WITH_HEADERS_READ_ONLY) {
          nextState |= State.HEADERS_SENT;
        }
        nextAction = NextAction.NOTIFY_USER_STREAM_READY;
        break;

      case Event.USER_LAST_WRITE:
        nextState |= State.END_STREAM_WRITTEN;
        // FOLLOW THROUGH
      case Event.USER_WRITE:
        // Note: it is fine to write even before "start" - Cronet behaves the same.
        nextAction = NextAction.WRITE;
        break;

      case Event.USER_FLUSH:
        if ((originalState & State.WAITING_FOR_FLUSH) != 0 &&
            (originalState & State.HEADERS_SENT) == 0) {
          if ((originalState & State.WRITE_DONE) != 0) {
            nextState &= ~State.WAITING_FOR_FLUSH;
          }
          nextState |= State.HEADERS_SENT;
          nextAction = NextAction.FLUSH_HEADERS;
        } else {
          nextAction = NextAction.CARRY_ON;
        }
        break;

      case Event.USER_READ:
        nextState &= ~State.WAITING_FOR_READ;
        if ((originalState & State.HEADERS_RECEIVED) == 0) {
          nextState |= State.READ_POSTPONED;
          nextAction = NextAction.POSTPONE_READ;
          // Event.READY_TO_START_POSTPONED_READ_IF_ANY will later on honor this user "read".
        } else {
          nextState |= State.READING;
          nextAction = (originalState & State.END_STREAM_READ) == 0
                           ? NextAction.READ
                           : NextAction.INVOKE_ON_READ_COMPLETED;
        }
        break;

      case Event.USER_CANCEL:
        if ((originalState & State.STARTED) == 0) {
          nextAction = NextAction.CARRY_ON; // Cancel came too soon - no effect.
        } else if ((originalState & State.ON_COMPLETE_RECEIVED) != 0) {
          nextState |= State.USER_CANCELLED | State.DONE;
          nextAction = NextAction.NOTIFY_USER_CANCELED;
        } else {
          // Due to race condition, the final EM callback can either be onCancel or onComplete.
          nextState |= State.USER_CANCELLED | State.CANCELLING;
          nextAction = NextAction.CANCEL;
        }
        break;

      case Event.ERROR:
        if ((originalState & State.ON_COMPLETE_RECEIVED) != 0 ||
            (originalState & State.STARTED) == 0) {
          nextState |= State.FAILED | State.DONE;
          nextAction = NextAction.NOTIFY_USER_FAILED;
        } else {
          // FYI: due to race condition, the final EM callback can either be onCancel or onComplete.
          nextState |= State.FAILED | State.CANCELLING;
          nextAction = NextAction.CANCEL;
        }
        break;

      case Event.STREAM_READY_CALLBACK_DONE:
        nextState |= State.STREAM_READY_EXECUTED;
        nextAction = (originalState & State.HEADERS_RECEIVED) != 0
                         ? NextAction.NOTIFY_USER_HEADERS_RECEIVED
                         : NextAction.CARRY_ON;
        break;

      case Event.ON_SEND_WINDOW_AVAILABLE:
        assert (originalState & State.WRITING) != 0;
        assert (originalState & State.WAITING_FOR_FLUSH) == 0;
        nextState |= State.WAITING_FOR_FLUSH;
        nextState &= ~State.WRITING;
        // CHAIN_NEXT_WRITE means initiate the "onCompleteReceived" user callback and send the next
        // ByteBuffer held in the mFlushData queue, if not empty.
        nextAction = NextAction.CHAIN_NEXT_WRITE;
        break;

      case Event.ON_HEADERS_END_STREAM:
        assert (originalState & State.END_STREAM_READ) == 0;
        nextState |= State.END_STREAM_READ;
        // FOLLOW THROUGH
      case Event.ON_HEADERS:
        assert (originalState & State.HEADERS_RECEIVED) == 0;
        nextState |= State.HEADERS_RECEIVED;
        nextAction = (originalState & State.STREAM_READY_EXECUTED) != 0
                         ? NextAction.NOTIFY_USER_HEADERS_RECEIVED
                         : NextAction.CARRY_ON;
        break;

      case Event.ON_DATA_END_STREAM:
        assert (originalState & State.END_STREAM_READ) == 0;
        nextState |= State.END_STREAM_READ;
        // FOLLOW THROUGH
      case Event.ON_DATA:
        assert (originalState & State.WAITING_FOR_READ) == 0;
        nextAction = NextAction.INVOKE_ON_READ_COMPLETED;
        break;

      case Event.ON_TRAILERS:
        nextAction = NextAction.NOTIFY_USER_TRAILERS_RECEIVED;
        break;

      case Event.ON_COMPLETE:
        assert (originalState & State.ON_COMPLETE_RECEIVED) == 0;
        nextState |= State.ON_COMPLETE_RECEIVED;
        if ((originalState & State.CANCELLING) != 0) {
          nextState |= State.DONE;
          nextAction = (originalState & State.FAILED) != 0 ? NextAction.NOTIFY_USER_FAILED
                                                           : NextAction.NOTIFY_USER_CANCELED;
        } else if (((originalState & State.WRITE_DONE) != 0 &&
                    (originalState & State.READ_DONE) != 0)) {
          nextState |= State.DONE;
          nextAction = NextAction.NOTIFY_USER_SUCCEEDED;
        } else {
          nextAction = NextAction.CARRY_ON;
        }
        break;

      case Event.ON_CANCEL:
        nextState |= State.DONE;
        nextAction = ((originalState & State.FAILED) != 0) ? NextAction.NOTIFY_USER_FAILED
                                                           : NextAction.NOTIFY_USER_CANCELED;
        break;

      case Event.ON_ERROR:
        nextState |= State.DONE | State.FAILED;
        nextAction = ((originalState & State.FAILED) != 0) ? NextAction.NOTIFY_USER_FAILED
                                                           : NextAction.NOTIFY_USER_NETWORK_ERROR;
        break;

      case Event.LAST_WRITE_COMPLETED:
        assert (originalState & State.WRITE_DONE) == 0;
        nextState |= State.WRITE_DONE;
        // FOLLOW THROUGH
      case Event.WRITE_COMPLETED:
        nextAction = NextAction.NOTIFY_USER_WRITE_COMPLETED;
        break;

      case Event.READY_TO_FLUSH:
        if ((originalState & State.WAITING_FOR_FLUSH) == 0) {
          nextAction = NextAction.CARRY_ON;
        } else {
          nextState &= ~State.WAITING_FOR_FLUSH;
          nextState |= State.WRITING;
          nextAction = NextAction.SEND_DATA;
        }
        break;

      case Event.READY_TO_FLUSH_LAST:
        if ((originalState & State.WAITING_FOR_FLUSH) == 0) {
          nextAction = NextAction.CARRY_ON;
        } else {
          nextState &= ~State.WAITING_FOR_FLUSH;
          nextAction = NextAction.SEND_DATA;
        }
        break;

      case Event.READY_TO_START_POSTPONED_READ_IF_ANY:
        assert (originalState & State.HEADERS_RECEIVED) != 0;
        if ((originalState & State.READ_POSTPONED) != 0) {
          nextState &= ~State.READ_POSTPONED;
          nextState |= State.READING;
          nextAction = (originalState & State.END_STREAM_READ) == 0
                           ? NextAction.READ
                           : NextAction.INVOKE_ON_READ_COMPLETED;
        } else {
          nextAction = NextAction.CARRY_ON;
        }
        break;

      case Event.READ_COMPLETED:
        assert (originalState & State.READING) != 0;
        nextState &= ~State.READING;
        nextState |= State.WAITING_FOR_READ;
        nextAction = NextAction.NOTIFY_USER_READ_COMPLETED;
        break;

      case Event.LAST_READ_COMPLETED:
        assert (originalState & State.READ_DONE) == 0;
        nextState &= ~State.READING;
        nextState |= State.READ_DONE;
        nextAction = NextAction.NOTIFY_USER_READ_COMPLETED;
        break;

      case Event.READY_TO_FINISH:
        if ((originalState & State.ON_COMPLETE_RECEIVED) != 0 &&
            (originalState & State.READ_DONE) != 0 && (originalState & State.WRITE_DONE) != 0) {
          nextState |= State.DONE;
          nextAction = NextAction.NOTIFY_USER_SUCCEEDED;
        } else {
          nextAction = NextAction.CARRY_ON;
        }
        break;

      default:
        throw new AssertionError("switch is exhaustive");
      }

      if (mState.compareAndSet(originalState, nextState)) {
        return nextAction;
      }
    }
  }

  /**
   * Returns true is we are already in a final state. However, if the provided "event" represents a
   * Terminal Network Event, then this method returns "false" even if the provided "state"
   * represents a terminating state: a Terminal Network Event needs to be processed to put the
   * Stream to rest.
   *
   * <p>For few cases, this method will throw when the state is not compatible with the event. This
   * mimics Cronet's behaviour: identical Exception types and error messages.
   */
  private static boolean isAlreadyFinalState(@Event int event, @State int state) {
    switch (event) {
    case Event.USER_START:
    case Event.USER_START_WITH_HEADERS:
    case Event.USER_START_READ_ONLY:
    case Event.USER_START_WITH_HEADERS_READ_ONLY:
      if ((state & (State.STARTED | State.TERMINATING_STATES)) != 0) {
        throw new IllegalStateException("Stream is already started.");
      }
      break;

    case Event.USER_LAST_WRITE:
    case Event.USER_WRITE:
      if ((state & State.END_STREAM_WRITTEN) != 0) {
        throw new IllegalArgumentException("Write after writing end of stream.");
      }
      break;

    case Event.USER_READ:
      if ((state & State.WAITING_FOR_READ) == 0) {
        throw new IllegalStateException("Unexpected read attempt.");
      }
      break;

    default:
      // For all other events, a potentially incompatible state does not trigger an Exception.
    }

    // Those 3 events are the final events from the EnvoyMobile C++ layer.
    if (event == Event.ON_CANCEL || event == Event.ON_ERROR || event == Event.ON_COMPLETE) {
      // If this assert triggers it means that the C++ EnvoyMobile contract has been breached.
      assert (state & State.DONE) == 0; // Or there is a blatant bug.
      // The above 3 Network Events are the only ones that need to be processed when the Stream is
      // in a terminating state. This is why here this returns "false" systematically.
      return false;
    }
    return (state & State.TERMINATING_STATES) != 0;
  }
}
package org.chromium.net;

import java.nio.ByteBuffer;
import java.util.concurrent.Executor;

/**
 * Controls an HTTP request (GET, PUT, POST etc). Created by {@link UrlRequest.Builder}, which can
 * be obtained by calling {@link CronetEngine#newUrlRequestBuilder}. Note: All methods must be
 * called on the {@link Executor} passed to {@link CronetEngine#newUrlRequestBuilder}.
 */
public abstract class UrlRequest {
  /**
   * Builder for {@link UrlRequest}s. Allows configuring requests before constructing them with
   * {@link Builder#build}. The builder can be created by calling {@link
   * CronetEngine#newUrlRequestBuilder}.
   */
  public abstract static class Builder {
    /**
     * Sets the HTTP method verb to use for this request.
     *
     * <p>The default when this method is not called is "GET" if the request has no body or "POST"
     * if it does.
     *
     * @param method "GET", "HEAD", "DELETE", "POST" or "PUT".
     * @return the builder to facilitate chaining.
     */
    public abstract Builder setHttpMethod(String method);

    /**
     * Adds a request header.
     *
     * @param header header name.
     * @param value header value.
     * @return the builder to facilitate chaining.
     */
    public abstract Builder addHeader(String header, String value);

    /**
     * Disables cache for the request. If context is not set up to use cache, this call has no
     * effect.
     *
     * @return the builder to facilitate chaining.
     */
    public abstract Builder disableCache();

    /** Lowest request priority. Passed to {@link #setPriority}. */
    public static final int REQUEST_PRIORITY_IDLE = 0;
    /** Very low request priority. Passed to {@link #setPriority}. */
    public static final int REQUEST_PRIORITY_LOWEST = 1;
    /** Low request priority. Passed to {@link #setPriority}. */
    public static final int REQUEST_PRIORITY_LOW = 2;
    /**
     * Medium request priority. Passed to {@link #setPriority}. This is the default priority given
     * to the request.
     */
    public static final int REQUEST_PRIORITY_MEDIUM = 3;
    /** Highest request priority. Passed to {@link #setPriority}. */
    public static final int REQUEST_PRIORITY_HIGHEST = 4;

    /**
     * Sets priority of the request which should be one of the {@link #REQUEST_PRIORITY_IDLE
     * REQUEST_PRIORITY_*} values. The request is given {@link #REQUEST_PRIORITY_MEDIUM} priority if
     * this method is not called.
     *
     * @param priority priority of the request which should be one of the {@link
     *     #REQUEST_PRIORITY_IDLE REQUEST_PRIORITY_*} values.
     * @return the builder to facilitate chaining.
     */
    public abstract Builder setPriority(int priority);

    /**
     * Sets upload data provider. Switches method to "POST" if not explicitly set. Starting the
     * request will throw an exception if a Content-Type header is not set.
     *
     * @param uploadDataProvider responsible for providing the upload data.
     * @param executor All {@code uploadDataProvider} methods will be invoked using this {@code
     *     Executor}. May optionally be the same {@code Executor} the request itself is using.
     * @return the builder to facilitate chaining.
     */
    public abstract Builder setUploadDataProvider(UploadDataProvider uploadDataProvider,
                                                  Executor executor);

    /**
     * Marks that the executors this request will use to notify callbacks (for {@code
     * UploadDataProvider}s and {@code UrlRequest.Callback}s) is intentionally performing inline
     * execution, like Guava's directExecutor or {@link
     * java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy}.
     *
     * <p><b>Warning:</b> This option makes it easy to accidentally block the network thread. It
     * should not be used if your callbacks perform disk I/O, acquire locks, or call into other code
     * you don't carefully control and audit.
     */
    public abstract Builder allowDirectExecutor();

    /**
     * Creates a {@link UrlRequest} using configuration within this {@link Builder}. The returned
     * {@code UrlRequest} can then be started by calling {@link UrlRequest#start}.
     *
     * @return constructed {@link UrlRequest} using configuration within this {@link Builder}.
     */
    public abstract UrlRequest build();
  }

  /**
   * Users of Cronet extend this class to receive callbacks indicating the progress of a {@link
   * UrlRequest} being processed. An instance of this class is passed in to {@link
   * UrlRequest.Builder}'s constructor when constructing the {@code UrlRequest}.
   *
   * <p>Note: All methods will be invoked on the thread of the {@link java.util.concurrent.Executor}
   * used during construction of the {@code UrlRequest}.
   */
  public abstract static class Callback {
    /**
     * Invoked whenever a redirect is encountered. This will only be invoked between the call to
     * {@link UrlRequest#start} and {@link Callback#onResponseStarted onResponseStarted()}. The body
     * of the redirect response, if it has one, will be ignored.
     *
     * <p>The redirect will not be followed until the URLRequest's {@link UrlRequest#followRedirect}
     * method is called, either synchronously or asynchronously.
     *
     * @param request Request being redirected.
     * @param info Response information.
     * @param newLocationUrl Location where request is redirected.
     * @throws Exception if an error occurs while processing a redirect. {@link #onFailed} will be
     *     called with the thrown exception set as the cause of the {@link CallbackException}.
     */
    public abstract void onRedirectReceived(UrlRequest request, UrlResponseInfo info,
                                            String newLocationUrl) throws Exception;

    /**
     * Invoked when the final set of headers, after all redirects, is received. Will only be invoked
     * once for each request.
     *
     * <p>With the exception of {@link Callback#onCanceled onCanceled()}, no other {@link Callback}
     * method will be invoked for the request, including {@link Callback#onSucceeded onSucceeded()}
     * and {@link Callback#onFailed onFailed()}, until {@link UrlRequest#read UrlRequest.read()} is
     * called to attempt to start reading the response body.
     *
     * @param request Request that started to get response.
     * @param info Response information.
     * @throws Exception if an error occurs while processing response start. {@link #onFailed} will
     *     be called with the thrown exception set as the cause of the {@link CallbackException}.
     */
    public abstract void onResponseStarted(UrlRequest request, UrlResponseInfo info)
        throws Exception;

    /**
     * Invoked whenever part of the response body has been read. Only part of the buffer may be
     * populated, even if the entire response body has not yet been consumed.
     *
     * <p>With the exception of {@link Callback#onCanceled onCanceled()}, no other {@link Callback}
     * method will be invoked for the request, including {@link Callback#onSucceeded onSucceeded()}
     * and {@link Callback#onFailed onFailed()}, until {@link UrlRequest#read UrlRequest.read()} is
     * called to attempt to continue reading the response body.
     *
     * @param request Request that received data.
     * @param info Response information.
     * @param byteBuffer The buffer that was passed in to {@link UrlRequest#read UrlRequest.read()},
     *     now containing the received data. The buffer's position is updated to the end of the
     *     received data. The buffer's limit is not changed.
     * @throws Exception if an error occurs while processing a read completion. {@link #onFailed}
     *     will be called with the thrown exception set as the cause of the {@link
     *     CallbackException}.
     */
    public abstract void onReadCompleted(UrlRequest request, UrlResponseInfo info,
                                         ByteBuffer byteBuffer) throws Exception;

    /**
     * Invoked when request is completed successfully. Once invoked, no other {@link Callback}
     * methods will be invoked.
     *
     * @param request Request that succeeded.
     * @param info Response information.
     */
    public abstract void onSucceeded(UrlRequest request, UrlResponseInfo info);

    /**
     * Invoked if request failed for any reason after {@link UrlRequest#start}. Once invoked, no
     * other {@link Callback} methods will be invoked. {@code error} provides information about the
     * failure.
     *
     * @param request Request that failed.
     * @param info Response information. May be {@code null} if no response was received.
     * @param error information about error.
     */
    public abstract void onFailed(UrlRequest request, UrlResponseInfo info, CronetException error);

    /**
     * Invoked if request was canceled via {@link UrlRequest#cancel}. Once invoked, no other {@link
     * Callback} methods will be invoked. Default implementation takes no action.
     *
     * @param request Request that was canceled.
     * @param info Response information. May be {@code null} if no response was received.
     */
    public void onCanceled(UrlRequest request, UrlResponseInfo info) {}
  }

  /** Request status values returned by {@link #getStatus}. */
  public static class Status {

    /** This state indicates that the request is completed, canceled, or is not started. */
    public static final int INVALID = -1;
    /**
     * This state corresponds to a resource load that has either not yet begun or is idle waiting
     * for the consumer to do something to move things along (e.g. when the consumer of a {@link
     * UrlRequest} has not called {@link UrlRequest#read read()} yet).
     */
    public static final int IDLE = 0;
    /**
     * When a socket pool group is below the maximum number of sockets allowed per group, but a new
     * socket cannot be created due to the per-pool socket limit, this state is returned by all
     * requests for the group waiting on an idle connection, except those that may be serviced by a
     * pending new connection.
     */
    public static final int WAITING_FOR_STALLED_SOCKET_POOL = 1;
    /**
     * When a socket pool group has reached the maximum number of sockets allowed per group, this
     * state is returned for all requests that don't have a socket, except those that correspond to
     * a pending new connection.
     */
    public static final int WAITING_FOR_AVAILABLE_SOCKET = 2;
    /**
     * This state indicates that the URLRequest delegate has chosen to block this request before it
     * was sent over the network.
     */
    public static final int WAITING_FOR_DELEGATE = 3;
    /**
     * This state corresponds to a resource load that is blocked waiting for access to a resource in
     * the cache. If multiple requests are made for the same resource, the first request will be
     * responsible for writing (or updating) the cache entry and the second request will be deferred
     * until the first completes. This may be done to optimize for cache reuse.
     */
    public static final int WAITING_FOR_CACHE = 4;
    /**
     * This state corresponds to a resource being blocked waiting for the PAC script to be
     * downloaded.
     */
    public static final int DOWNLOADING_PAC_FILE = 5;
    /**
     * This state corresponds to a resource load that is blocked waiting for a proxy autoconfig
     * script to return a proxy server to use.
     */
    public static final int RESOLVING_PROXY_FOR_URL = 6;
    /**
     * This state corresponds to a resource load that is blocked waiting for a proxy autoconfig
     * script to return a proxy server to use, but that proxy script is busy resolving the IP
     * address of a host.
     */
    public static final int RESOLVING_HOST_IN_PAC_FILE = 7;
    /**
     * This state indicates that we're in the process of establishing a tunnel through the proxy
     * server.
     */
    public static final int ESTABLISHING_PROXY_TUNNEL = 8;
    /**
     * This state corresponds to a resource load that is blocked waiting for a host name to be
     * resolved. This could either indicate resolution of the origin server corresponding to the
     * resource or to the host name of a proxy server used to fetch the resource.
     */
    public static final int RESOLVING_HOST = 9;
    /**
     * This state corresponds to a resource load that is blocked waiting for a TCP connection (or
     * other network connection) to be established. HTTP requests that reuse a keep-alive connection
     * skip this state.
     */
    public static final int CONNECTING = 10;
    /**
     * This state corresponds to a resource load that is blocked waiting for the SSL handshake to
     * complete.
     */
    public static final int SSL_HANDSHAKE = 11;
    /**
     * This state corresponds to a resource load that is blocked waiting to completely upload a
     * request to a server. In the case of a HTTP POST request, this state includes the period of
     * time during which the message body is being uploaded.
     */
    public static final int SENDING_REQUEST = 12;
    /**
     * This state corresponds to a resource load that is blocked waiting for the response to a
     * network request. In the case of a HTTP transaction, this corresponds to the period after the
     * request is sent and before all of the response headers have been received.
     */
    public static final int WAITING_FOR_RESPONSE = 13;
    /**
     * This state corresponds to a resource load that is blocked waiting for a read to complete. In
     * the case of a HTTP transaction, this corresponds to the period after the response headers
     * have been received and before all of the response body has been downloaded. (NOTE: This state
     * only applies for an {@link UrlRequest} while there is an outstanding {@link UrlRequest#read
     * read()} operation.)
     */
    public static final int READING_RESPONSE = 14;

    private Status() {}
  }

  /** Listener class used with {@link #getStatus} to receive the status of a {@link UrlRequest}. */
  public abstract static class StatusListener {
    /**
     * Invoked on {@link UrlRequest}'s {@link Executor}'s thread when request status is obtained.
     *
     * @param status integer representing the status of the request. It is one of the values defined
     *     in {@link Status}.
     */
    public abstract void onStatus(int status);
  }

  /**
   * Starts the request, all callbacks go to {@link Callback}. May only be called once. May not be
   * called if {@link #cancel} has been called.
   */
  public abstract void start();

  /**
   * Follows a pending redirect. Must only be called at most once for each invocation of {@link
   * Callback#onRedirectReceived onRedirectReceived()}.
   */
  public abstract void followRedirect();

  /**
   * Attempts to read part of the response body into the provided buffer. Must only be called at
   * most once in response to each invocation of the {@link Callback#onResponseStarted
   * onResponseStarted()} and {@link Callback#onReadCompleted onReadCompleted()} methods of the
   * {@link Callback}. Each call will result in an asynchronous call to either the {@link Callback
   * Callback's} {@link Callback#onReadCompleted onReadCompleted()} method if data is read, its
   * {@link Callback#onSucceeded onSucceeded()} method if there's no more data to read, or its
   * {@link Callback#onFailed onFailed()} method if there's an error.
   *
   * @param buffer {@link ByteBuffer} to write response body to. Must be a direct ByteBuffer. The
   *     embedder must not read or modify buffer's position, limit, or data between its position and
   *     limit until the request calls back into the {@link Callback}.
   */
  public abstract void read(ByteBuffer buffer);

  /**
   * Cancels the request. Can be called at any time. {@link Callback#onCanceled onCanceled()} will
   * be invoked when cancellation is complete and no further callback methods will be invoked. If
   * the request has completed or has not started, calling {@code cancel()} has no effect and {@code
   * onCanceled()} will not be invoked. If the {@link Executor} passed in during {@code UrlRequest}
   * construction runs tasks on a single thread, and {@code cancel()} is called on that thread, no
   * callback methods (besides {@code onCanceled()}) will be invoked after {@code cancel()} is
   * called. Otherwise, at most one callback method may be invoked after {@code cancel()} has
   * completed.
   */
  public abstract void cancel();

  /**
   * Returns {@code true} if the request was successfully started and is now finished (completed,
   * canceled, or failed).
   *
   * @return {@code true} if the request was successfully started and is now finished (completed,
   *     canceled, or failed).
   */
  public abstract boolean isDone();

  /**
   * Queries the status of the request.
   *
   * @param listener a {@link StatusListener} that will be invoked with the request's current
   *     status. {@code listener} will be invoked back on the {@link Executor} passed in when the
   *     request was created.
   */
  public abstract void getStatus(final StatusListener listener);

  // Note:  There are deliberately no accessors for the results of the request
  // here. Having none removes any ambiguity over when they are populated,
  // particularly in the redirect case.
}
package org.chromium.net;

/**
 * Subclass of {@link NetworkException} which contains a detailed <a
 * href="https://www.chromium.org/quic">QUIC</a> error code from <a
 * href="https://cs.chromium.org/search/?q=symbol:%5CbQuicErrorCode%5Cb">QuicErrorCode</a>. An
 * instance of {@code QuicException} is passed to {@code onFailed} callbacks when the error code is
 * {@link NetworkException#ERROR_QUIC_PROTOCOL_FAILED NetworkException.ERROR_QUIC_PROTOCOL_FAILED}.
 */
public abstract class QuicException extends NetworkException {
  /**
   * Constructs an exception that is caused by a QUIC protocol error.
   *
   * @param message explanation of failure.
   * @param cause the cause (which is saved for later retrieval by the {@link
   *     java.io.IOException#getCause getCause()} method). A null value is permitted, and indicates
   *     that the cause is nonexistent or unknown.
   */
  protected QuicException(String message, Throwable cause) { super(message, cause); }

  /**
   * Returns the <a href="https://www.chromium.org/quic">QUIC</a> error code, which is a value from
   * <a href="https://cs.chromium.org/search/?q=symbol:%5CbQuicErrorCode%5Cb">QuicErrorCode</a>.
   */
  public abstract int getQuicDetailedErrorCode();
}
package org.chromium.net;

import android.annotation.SuppressLint;
import java.nio.ByteBuffer;
import java.util.concurrent.Executor;

/**
 * Class for bidirectional sending and receiving of data over HTTP/2 or QUIC connections. Created by
 * {@link Builder}.
 *
 * <p>Note: There are ordering restrictions on methods of {@link BidirectionalStream}; please see
 * individual methods for description of restrictions.
 *
 * <p>{@hide experimental}
 */
public abstract class BidirectionalStream {
  /**
   * Builder for {@link BidirectionalStream}s. Allows configuring stream before constructing it via
   * {@link Builder#build}. Created by {@link
   * ExperimentalCronetEngine#newBidirectionalStreamBuilder}.
   */
  public abstract static class Builder {
    /**
     * Sets the HTTP method for the request. Returns builder to facilitate chaining.
     *
     * @param method the method to use for request. Default is 'POST'
     * @return the builder to facilitate chaining
     */
    public abstract Builder setHttpMethod(String method);

    /**
     * Adds a request header. Returns builder to facilitate chaining.
     *
     * @param header the header name
     * @param value the header value
     * @return the builder to facilitate chaining
     */
    public abstract Builder addHeader(String header, String value);

    /** Lowest stream priority. Passed to {@link #setPriority}. */
    public static final int STREAM_PRIORITY_IDLE = 0;
    /** Very low stream priority. Passed to {@link #setPriority}. */
    public static final int STREAM_PRIORITY_LOWEST = 1;
    /** Low stream priority. Passed to {@link #setPriority}. */
    public static final int STREAM_PRIORITY_LOW = 2;
    /**
     * Medium stream priority. Passed to {@link #setPriority}. This is the default priority given to
     * the stream.
     */
    public static final int STREAM_PRIORITY_MEDIUM = 3;
    /** Highest stream priority. Passed to {@link #setPriority}. */
    public static final int STREAM_PRIORITY_HIGHEST = 4;

    /**
     * Sets priority of the stream which should be one of the {@link #STREAM_PRIORITY_IDLE
     * STREAM_PRIORITY_*} values. The stream is given {@link #STREAM_PRIORITY_MEDIUM} priority if
     * this method is not called.
     *
     * @param priority priority of the stream which should be one of the {@link
     *     #STREAM_PRIORITY_IDLE STREAM_PRIORITY_*} values.
     * @return the builder to facilitate chaining.
     */
    public abstract Builder setPriority(int priority);

    /**
     * Delays sending request headers until {@link BidirectionalStream#flush()} is called. This flag
     * is currently only respected when QUIC is negotiated. When true, QUIC will send request header
     * frame along with data frame(s) as a single packet when possible.
     *
     * @param delayRequestHeadersUntilFirstFlush if true, sending request headers will be delayed
     *     until flush() is called.
     * @return the builder to facilitate chaining.
     */
    public abstract Builder
    delayRequestHeadersUntilFirstFlush(boolean delayRequestHeadersUntilFirstFlush);

    /**
     * Creates a {@link BidirectionalStream} using configuration from this {@link Builder}. The
     * returned {@code BidirectionalStream} can then be started by calling {@link
     * BidirectionalStream#start}.
     *
     * @return constructed {@link BidirectionalStream} using configuration from this {@link Builder}
     */
    public abstract BidirectionalStream build();
  }

  /** Callback class used to receive callbacks from a {@link BidirectionalStream}. */
  public abstract static class Callback {
    /**
     * Invoked when the stream is ready for reading and writing. Consumer may call {@link
     * BidirectionalStream#read read()} to start reading data. Consumer may call {@link
     * BidirectionalStream#write write()} to start writing data.
     *
     * @param stream the stream that is ready.
     */
    public abstract void onStreamReady(BidirectionalStream stream);

    /**
     * Invoked when initial response headers are received. Headers are available from {@code
     * info.}{@link UrlResponseInfo#getAllHeaders getAllHeaders()}. Consumer may call {@link
     * BidirectionalStream#read read()} to start reading. Consumer may call {@link
     * BidirectionalStream#write write()} to start writing or close the stream.
     *
     * @param stream the stream on which response headers were received.
     * @param info the response information.
     */
    public abstract void onResponseHeadersReceived(BidirectionalStream stream,
                                                   UrlResponseInfo info);

    /**
     * Invoked when data is read into the buffer passed to {@link BidirectionalStream#read read()}.
     * Only part of the buffer may be populated. To continue reading, call {@link
     * BidirectionalStream#read read()}. It may be invoked after {@code
     * onResponseTrailersReceived()}, if there was pending read data before trailers were received.
     *
     * @param stream the stream on which the read completed
     * @param info the response information
     * @param buffer the buffer that was passed to {@link BidirectionalStream#read read()}, now
     *     containing the received data. The buffer's limit is not changed. The buffer's position is
     *     set to the end of the received data. If position is not updated, it means the remote side
     *     has signaled that it will send no more data.
     * @param endOfStream if true, this is the last read data, remote will not send more data, and
     *     the read side is closed.
     */
    public abstract void onReadCompleted(BidirectionalStream stream, UrlResponseInfo info,
                                         ByteBuffer buffer, boolean endOfStream);

    /**
     * Invoked when the entire ByteBuffer passed to {@link BidirectionalStream#write write()} is
     * sent. The buffer's position is updated to be the same as the buffer's limit. The buffer's
     * limit is not changed. To continue writing, call {@link BidirectionalStream#write write()}.
     *
     * @param stream the stream on which the write completed
     * @param info the response information
     * @param buffer the buffer that was passed to {@link BidirectionalStream#write write()}. The
     *     buffer's position is set to the buffer's limit. The buffer's limit is not changed.
     * @param endOfStream the endOfStream flag that was passed to the corresponding {@link
     *     BidirectionalStream#write write()}. If true, the write side is closed.
     */
    public abstract void onWriteCompleted(BidirectionalStream stream, UrlResponseInfo info,
                                          ByteBuffer buffer, boolean endOfStream);

    /**
     * Invoked when trailers are received before closing the stream. Only invoked when server sends
     * trailers, which it may not. May be invoked while there is read data remaining in local
     * buffer.
     *
     * <p>Default implementation takes no action.
     *
     * @param stream the stream on which response trailers were received
     * @param info the response information
     * @param trailers the trailers received
     */
    public void onResponseTrailersReceived(BidirectionalStream stream, UrlResponseInfo info,
                                           UrlResponseInfo.HeaderBlock trailers) {}

    /**
     * Invoked when there is no data to be read or written and the stream is closed successfully
     * remotely and locally. Once invoked, no further {@link BidirectionalStream.Callback} methods
     * will be invoked.
     *
     * @param stream the stream which is closed successfully
     * @param info the response information
     */
    public abstract void onSucceeded(BidirectionalStream stream, UrlResponseInfo info);

    /**
     * Invoked if the stream failed for any reason after {@link BidirectionalStream#start}. <a
     * href="https://tools.ietf.org/html/rfc7540#section-7">HTTP/2 error codes</a> are mapped to
     * {@link UrlRequestException#getCronetInternalErrorCode} codes. Once invoked, no further {@link
     * BidirectionalStream.Callback} methods will be invoked.
     *
     * @param stream the stream which has failed
     * @param info the response information. May be {@code null} if no response was received.
     * @param error information about the failure
     */
    public abstract void onFailed(BidirectionalStream stream, UrlResponseInfo info,
                                  CronetException error);

    /**
     * Invoked if the stream was canceled via {@link BidirectionalStream#cancel}. Once invoked, no
     * further {@link BidirectionalStream.Callback} methods will be invoked. Default implementation
     * takes no action.
     *
     * @param stream the stream that was canceled
     * @param info the response information. May be {@code null} if no response was received.
     */
    public void onCanceled(BidirectionalStream stream, UrlResponseInfo info) {}
  }

  /**
   * Starts the stream, all callbacks go to the {@code callback} argument passed to {@link
   * BidirectionalStream.Builder}'s constructor. Should only be called once.
   */
  public abstract void start();

  /**
   * Reads data from the stream into the provided buffer. Can only be called at most once in
   * response to each invocation of the {@link Callback#onStreamReady onStreamReady()}/ {@link
   * Callback#onResponseHeadersReceived onResponseHeadersReceived()} and {@link
   * Callback#onReadCompleted onReadCompleted()} methods of the {@link Callback}. Each call will
   * result in an invocation of one of the {@link Callback Callback}'s {@link
   * Callback#onReadCompleted onReadCompleted()} method if data is read, or its {@link
   * Callback#onFailed onFailed()} method if there's an error.
   *
   * <p>An attempt to read data into {@code buffer} starting at {@code buffer.position()} is begun.
   * At most {@code buffer.remaining()} bytes are read. {@code buffer.position()} is updated upon
   * invocation of {@link Callback#onReadCompleted onReadCompleted()} to indicate how much data was
   * read.
   *
   * @param buffer the {@link ByteBuffer} to read data into. Must be a direct ByteBuffer. The
   *     embedder must not read or modify buffer's position, limit, or data between its position and
   *     limit until {@link Callback#onReadCompleted onReadCompleted()}, {@link Callback#onCanceled
   *     onCanceled()}, or {@link Callback#onFailed onFailed()} are invoked.
   */
  public abstract void read(ByteBuffer buffer);

  /**
   * Attempts to write data from the provided buffer into the stream. If auto flush is disabled,
   * data will be sent only after {@link #flush flush()} is called. Each call will result in an
   * invocation of one of the {@link Callback Callback}'s {@link Callback#onWriteCompleted
   * onWriteCompleted()} method if data is sent, or its {@link Callback#onFailed onFailed()} method
   * if there's an error.
   *
   * <p>An attempt to write data from {@code buffer} starting at {@code buffer.position()} is begun.
   * {@code buffer.remaining()} bytes will be written. {@link Callback#onWriteCompleted
   * onWriteCompleted()} will be invoked only when the full ByteBuffer is written.
   *
   * @param buffer the {@link ByteBuffer} to write data from. Must be a direct ByteBuffer. The
   *     embedder must not read or modify buffer's position, limit, or data between its position and
   *     limit until {@link Callback#onWriteCompleted onWriteCompleted()}, {@link
   *     Callback#onCanceled onCanceled()}, or {@link Callback#onFailed onFailed()} are invoked. Can
   *     be empty when {@code endOfStream} is {@code true}.
   * @param endOfStream if {@code true}, then {@code buffer} is the last buffer to be written, and
   *     once written, stream is closed from the client side, resulting in half-closed stream or a
   *     fully closed stream if the remote side has already closed.
   */
  public abstract void write(ByteBuffer buffer, boolean endOfStream);

  /**
   * Flushes pending writes. This method should not be invoked before {@link Callback#onStreamReady
   * onStreamReady()}. For previously delayed {@link #write write()}s, a corresponding {@link
   * Callback#onWriteCompleted onWriteCompleted()} will be invoked when the buffer is sent.
   */
  public abstract void flush();

  /**
   * Cancels the stream. Can be called at any time after {@link #start}. {@link Callback#onCanceled
   * onCanceled()} will be invoked when cancellation is complete and no further callback methods
   * will be invoked. If the stream has completed or has not started, calling {@code cancel()} has
   * no effect and {@code onCanceled()} will not be invoked. If the {@link Executor} passed in
   * during
   * {@code BidirectionalStream} construction runs tasks on a single thread, and {@code cancel()} is
   * called on that thread, no listener methods (besides {@code onCanceled()}) will be invoked after
   * {@code cancel()} is called. Otherwise, at most one callback method may be invoked after {@code
   * cancel()} has completed.
   */
  public abstract void cancel();

  /**
   * Returns {@code true} if the stream was successfully started and is now done (succeeded,
   * canceled, or failed).
   *
   * @return {@code true} if the stream was successfully started and is now done (completed,
   *     canceled, or failed), otherwise returns {@code false} to indicate stream is not yet started
   *     or is in progress.
   */
  public abstract boolean isDone();
}
package org.chromium.net;

import java.util.concurrent.Executor;

/**
 * Watches observations of various round trip times (RTTs) at various layers of the network stack.
 * These include RTT estimates by QUIC and TCP, as well as the time between when a URL request is
 * sent and when the first byte of the response is received. {@hide} as it's a prototype.
 */
public abstract class NetworkQualityRttListener {
  /**
   * The executor on which this listener will be notified. Set as a final field, so it can be safely
   * accessed across threads.
   */
  private final Executor mExecutor;

  /** @param executor The executor on which the observations are reported. */
  public NetworkQualityRttListener(Executor executor) {
    if (executor == null) {
      throw new IllegalStateException("Executor must not be null");
    }
    mExecutor = executor;
  }

  public Executor getExecutor() { return mExecutor; }

  /**
   * Reports a new round trip time observation.
   *
   * @param rttMs the round trip time in milliseconds.
   * @param whenMs milliseconds since the Epoch (January 1st 1970, 00:00:00.000).
   * @param source the observation source from {@link NetworkQualityObservationSource}.
   */
  public abstract void onRttObservation(int rttMs, long whenMs, int source);
}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="org.chromium.net">
    <uses-sdk
            android:minSdkVersion="21"
            android:targetSdkVersion="27" />

</manifest>
package org.chromium.net;

import java.util.concurrent.Executor;

/**
 * Listener that is notified of throughput observations from the network quality estimator. {@hide}
 * as it's a prototype.
 */
public abstract class NetworkQualityThroughputListener {
  /**
   * The executor on which this listener will be notified. Set as a final field, so it can be safely
   * accessed across threads.
   */
  private final Executor mExecutor;

  /** @param executor The executor on which the observations are reported. */
  public NetworkQualityThroughputListener(Executor executor) {
    if (executor == null) {
      throw new IllegalStateException("Executor must not be null");
    }
    mExecutor = executor;
  }

  public Executor getExecutor() { return mExecutor; }

  /**
   * Reports a new throughput observation.
   *
   * @param throughputKbps the downstream throughput in kilobits per second.
   * @param whenMs milliseconds since the Epoch (January 1st 1970, 00:00:00.000).
   * @param source the observation source from {@link NetworkQualityObservationSource}.
   */
  public abstract void onThroughputObservation(int throughputKbps, long whenMs, int source);
}
// Copyright 2015 The Chromium Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
package org.chromium.net;

import java.io.IOException;

/** Base exception passed to {@link UrlRequest.Callback#onFailed UrlRequest.Callback.onFailed()}. */
public abstract class CronetException extends IOException {
  /**
   * Constructs an exception that is caused by {@code cause}.
   *
   * @param message explanation of failure.
   * @param cause the cause (which is saved for later retrieval by the {@link
   *     java.io.IOException#getCause getCause()} method). A null value is permitted, and indicates
   *     that the cause is nonexistent or unknown.
   */
  protected CronetException(String message, Throwable cause) { super(message, cause); }
}
package org.chromium.net;

/**
 * {@link BidirectionalStream} that exposes experimental features. To obtain an instance of this
 * class, cast a {@code BidirectionalStream} to this type. Every instance of {@code
 * BidirectionalStream} can be cast to an instance of this class, as they are backed by the same
 * implementation and hence perform identically. Instances of this class are not meant for general
 * use, but instead only to access experimental features. Experimental features may be deprecated in
 * the future. Use at your own risk.
 *
 * <p>{@hide prototype}
 */
public abstract class ExperimentalBidirectionalStream extends BidirectionalStream {
  /**
   * {@link BidirectionalStream#Builder} that exposes experimental features. To obtain an instance
   * of this class, cast a {@code BidirectionalStream.Builder} to this type. Every instance of
   * {@code BidirectionalStream.Builder} can be cast to an instance of this class, as they are
   * backed by the same implementation and hence perform identically. Instances of this class are
   * not meant for general use, but instead only to access experimental features. Experimental
   * features may be deprecated in the future. Use at your own risk.
   */
  public abstract static class Builder extends BidirectionalStream.Builder {
    /**
     * Associates the annotation object with this request. May add more than one. Passed through to
     * a {@link RequestFinishedInfo.Listener}, see {@link RequestFinishedInfo#getAnnotations}.
     *
     * @param annotation an object to pass on to the {@link RequestFinishedInfo.Listener} with a
     *     {@link RequestFinishedInfo}.
     * @return the builder to facilitate chaining.
     */
    public Builder addRequestAnnotation(Object annotation) { return this; }

    /**
     * Sets {@link android.net.TrafficStats} tag to use when accounting socket traffic caused by
     * this request. See {@link android.net.TrafficStats} for more information. If no tag is set
     * (e.g. this method isn't called), then Android accounts for the socket traffic caused by this
     * request as if the tag value were set to 0.
     *
     * <p><b>NOTE:</b>Setting a tag disallows sharing of sockets with requests with other tags,
     * which may adversely effect performance by prohibiting connection sharing. In other words use
     * of multiplexed sockets (e.g. HTTP/2 and QUIC) will only be allowed if all requests have the
     * same socket tag.
     *
     * @param tag the tag value used to when accounting for socket traffic caused by this request.
     *     Tags between 0xFFFFFF00 and 0xFFFFFFFF are reserved and used internally by system
     *     services like {@link android.app.DownloadManager} when performing traffic on behalf of an
     *     application.
     * @return the builder to facilitate chaining.
     */
    public Builder setTrafficStatsTag(int tag) { return this; }

    /**
     * Sets specific UID to use when accounting socket traffic caused by this request. See {@link
     * android.net.TrafficStats} for more information. Designed for use when performing an operation
     * on behalf of another application. Caller must hold {@link
     * android.Manifest.permission#MODIFY_NETWORK_ACCOUNTING} permission. By default traffic is
     * attributed to UID of caller.
     *
     * <p><b>NOTE:</b>Setting a UID disallows sharing of sockets with requests with other UIDs,
     * which may adversely effect performance by prohibiting connection sharing. In other words use
     * of multiplexed sockets (e.g. HTTP/2 and QUIC) will only be allowed if all requests have the
     * same UID set.
     *
     * @param uid the UID to attribute socket traffic caused by this request.
     * @return the builder to facilitate chaining.
     */
    public Builder setTrafficStatsUid(int uid) { return this; }

    // To support method chaining, override superclass methods to return an
    // instance of this class instead of the parent.

    @Override public abstract Builder setHttpMethod(String method);

    @Override public abstract Builder addHeader(String header, String value);

    @Override public abstract Builder setPriority(int priority);

    @Override
    public abstract Builder
    delayRequestHeadersUntilFirstFlush(boolean delayRequestHeadersUntilFirstFlush);

    @Override public abstract ExperimentalBidirectionalStream build();
  }
}
package org.chromium.net.urlconnection;

import android.annotation.SuppressLint;
import android.net.TrafficStats;
import android.os.Build;
import android.util.Log;
import android.util.Pair;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.ProtocolException;
import java.net.URL;
import java.net.URLConnection;
import java.nio.ByteBuffer;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import org.chromium.net.CronetEngine;
import org.chromium.net.CronetException;
import org.chromium.net.ExperimentalUrlRequest;
import org.chromium.net.UrlRequest;
import org.chromium.net.UrlResponseInfo;

/**
 * An implementation of {@link HttpURLConnection} that uses Cronet to send
 * requests and receive responses.
 * {@hide}
 */
public final class CronvoyHttpURLConnection extends HttpURLConnection {
  private static final String TAG = CronvoyHttpURLConnection.class.getSimpleName();
  private static final String CONTENT_LENGTH = "Content-Length";
  private final CronetEngine mCronetEngine;
  private final CronvoyMessageLoop mMessageLoop;
  private UrlRequest mRequest;
  private final List<Pair<String, String>> mRequestHeaders;
  private boolean mTrafficStatsTagSet;
  private int mTrafficStatsTag;
  private boolean mTrafficStatsUidSet;
  private int mTrafficStatsUid;

  private CronvoyInputStream mInputStream;
  private CronvoyOutputStream mOutputStream;
  private UrlResponseInfo mResponseInfo;
  private IOException mException;
  private boolean mOnRedirectCalled;
  // Whether response headers are received, the request is failed, or the request is canceled.
  private boolean mHasResponseHeadersOrCompleted;
  private List<Map.Entry<String, String>> mResponseHeadersList;
  private Map<String, List<String>> mResponseHeadersMap;

  public CronvoyHttpURLConnection(URL url, CronetEngine cronetEngine) {
    super(url);
    mCronetEngine = cronetEngine;
    mMessageLoop = new CronvoyMessageLoop();
    mInputStream = new CronvoyInputStream(this);
    mRequestHeaders = new ArrayList<Pair<String, String>>();
  }

  /**
   * Opens a connection to the resource. If the connect method is called when
   * the connection has already been opened (indicated by the connected field
   * having the value {@code true}), the call is ignored.
   */
  @Override
  public void connect() throws IOException {
    getOutputStream();
    // If request is started in getOutputStream, calling startRequest()
    // again has no effect.
    startRequest();
  }

  /**
   * Releases this connection so that its resources may be either reused or
   * closed.
   */
  @Override
  public void disconnect() {
    // Disconnect before connection is made should have no effect.
    if (connected) {
      mRequest.cancel();
    }
  }

  /**
   * Returns the response message returned by the remote HTTP server.
   */
  @Override
  public String getResponseMessage() throws IOException {
    getResponse();
    return mResponseInfo.getHttpStatusText();
  }

  /**
   * Returns the response code returned by the remote HTTP server.
   */
  @Override
  public int getResponseCode() throws IOException {
    getResponse();
    return mResponseInfo.getHttpStatusCode();
  }

  /**
   * Returns an unmodifiable map of the response-header fields and values.
   */
  @Override
  public Map<String, List<String>> getHeaderFields() {
    try {
      getResponse();
    } catch (IOException e) {
      return Collections.emptyMap();
    }
    return getAllHeaders();
  }

  /**
   * Returns the value of the named header field. If called on a connection
   * that sets the same header multiple times with possibly different values,
   * only the last value is returned.
   */
  @Override
  public final String getHeaderField(String fieldName) {
    try {
      getResponse();
    } catch (IOException e) {
      return null;
    }
    Map<String, List<String>> map = getAllHeaders();
    if (!map.containsKey(fieldName)) {
      return null;
    }
    List<String> values = map.get(fieldName);
    return values.get(values.size() - 1);
  }

  /**
   * Returns the name of the header field at the given position {@code pos}, or {@code null}
   * if there are fewer than {@code pos} fields.
   */
  @Override
  public final String getHeaderFieldKey(int pos) {
    Map.Entry<String, String> header = getHeaderFieldEntry(pos);
    if (header == null) {
      return null;
    }
    return header.getKey();
  }

  /**
   * Returns the header value at the field position {@code pos} or {@code null} if the header
   * has fewer than {@code pos} fields.
   */
  @Override
  public final String getHeaderField(int pos) {
    Map.Entry<String, String> header = getHeaderFieldEntry(pos);
    if (header == null) {
      return null;
    }
    return header.getValue();
  }

  /**
   * Returns an InputStream for reading data from the resource pointed by this
   * {@link URLConnection}.
   * @throws FileNotFoundException if http response code is equal or greater
   *             than {@link HTTP_BAD_REQUEST}.
   * @throws IOException If the request gets a network error or HTTP error
   *             status code, or if the caller tried to read the response body
   *             of a redirect when redirects are disabled.
   */
  @Override
  public InputStream getInputStream() throws IOException {
    getResponse();
    if (!instanceFollowRedirects && mOnRedirectCalled) {
      throw new IOException("Cannot read response body of a redirect.");
    }
    // Emulate default implementation's behavior to throw
    // FileNotFoundException when we get a 400 and above.
    if (mResponseInfo.getHttpStatusCode() >= HTTP_BAD_REQUEST) {
      throw new FileNotFoundException(url.toString());
    }
    return mInputStream;
  }

  /**
   * Returns an {@link OutputStream} for writing data to this {@link URLConnection}.
   * @throws IOException if no {@code OutputStream} could be created.
   */
  @Override
  public OutputStream getOutputStream() throws IOException {
    if (mOutputStream == null && doOutput) {
      if (connected) {
        throw new ProtocolException("Cannot write to OutputStream after receiving response.");
      }
      if (isChunkedUpload()) {
        mOutputStream = new CronvoyChunkedOutputStream(this, chunkLength, mMessageLoop);
        // Start the request now since all headers can be sent.
        startRequest();
      } else {
        long fixedStreamingModeContentLength = getStreamingModeContentLength();
        if (fixedStreamingModeContentLength != -1) {
          mOutputStream =
              new CronvoyFixedModeOutputStream(this, fixedStreamingModeContentLength, mMessageLoop);
          // Start the request now since all headers can be sent.
          startRequest();
        } else {
          // For the buffered case, start the request only when
          // content-length bytes are received, or when a
          // connect action is initiated by the consumer.
          Log.d(TAG, "Outputstream is being buffered in memory.");
          String length = getRequestProperty(CONTENT_LENGTH);
          if (length == null) {
            mOutputStream = new CronvoyBufferedOutputStream(this);
          } else {
            long lengthParsed = Long.parseLong(length);
            mOutputStream = new CronvoyBufferedOutputStream(this, lengthParsed);
          }
        }
      }
    }
    return mOutputStream;
  }

  /**
   * Helper method to get content length passed in by
   * {@link #setFixedLengthStreamingMode}
   */
  // TODO(crbug.com/762630): Fix and remove suppression.
  @SuppressLint("NewApi")
  private long getStreamingModeContentLength() {
    long contentLength = fixedContentLength;
    // Use reflection to see whether fixedContentLengthLong (only added
    // in API 19) is inherited.
    try {
      Class<?> parent = this.getClass();
      long superFixedContentLengthLong = parent.getField("fixedContentLengthLong").getLong(this);
      if (superFixedContentLengthLong != -1) {
        contentLength = superFixedContentLengthLong;
      }
    } catch (NoSuchFieldException | IllegalAccessException e) {
      // Ignored.
    }
    return contentLength;
  }

  /**
   * Starts the request if {@code connected} is false.
   */
  private void startRequest() throws IOException {
    if (connected) {
      return;
    }
    final ExperimentalUrlRequest.Builder requestBuilder =
        (ExperimentalUrlRequest.Builder)mCronetEngine.newUrlRequestBuilder(
            getURL().toString(), new CronetUrlRequestCallback(), mMessageLoop);
    if (doOutput) {
      if (method.equals("GET")) {
        method = "POST";
      }
      if (mOutputStream != null) {
        requestBuilder.setUploadDataProvider(mOutputStream.getUploadDataProvider(), mMessageLoop);
        if (getRequestProperty(CONTENT_LENGTH) == null && !isChunkedUpload()) {
          addRequestProperty(CONTENT_LENGTH,
                             Long.toString(mOutputStream.getUploadDataProvider().getLength()));
        }
        // Tells mOutputStream that startRequest() has been called, so
        // the underlying implementation can prepare for reading if needed.
        mOutputStream.setConnected();
      } else {
        if (getRequestProperty(CONTENT_LENGTH) == null) {
          addRequestProperty(CONTENT_LENGTH, "0");
        }
      }
      // Default Content-Type to application/x-www-form-urlencoded
      if (getRequestProperty("Content-Type") == null) {
        addRequestProperty("Content-Type", "application/x-www-form-urlencoded");
      }
    }
    for (Pair<String, String> requestHeader : mRequestHeaders) {
      requestBuilder.addHeader(requestHeader.first, requestHeader.second);
    }
    if (!getUseCaches()) {
      requestBuilder.disableCache();
    }
    // Set HTTP method.
    requestBuilder.setHttpMethod(method);
    if (checkTrafficStatsTag()) {
      requestBuilder.setTrafficStatsTag(mTrafficStatsTag);
    }
    if (checkTrafficStatsUid()) {
      requestBuilder.setTrafficStatsUid(mTrafficStatsUid);
    }

    mRequest = requestBuilder.build();
    // Start the request.
    mRequest.start();
    connected = true;
  }

  private boolean checkTrafficStatsTag() {
    if (mTrafficStatsTagSet) {
      return true;
    }

    int tag = TrafficStats.getThreadStatsTag();
    if (tag != -1) {
      mTrafficStatsTag = tag;
      mTrafficStatsTagSet = true;
    }

    return mTrafficStatsTagSet;
  }

  private boolean checkTrafficStatsUid() {
    if (mTrafficStatsUidSet) {
      return true;
    }

    // TrafficStats#getThreadStatsUid() is available on API level 28+.
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.P) {
      return false;
    }

    int uid = TrafficStats.getThreadStatsUid();
    if (uid != -1) {
      mTrafficStatsUid = uid;
      mTrafficStatsUidSet = true;
    }

    return mTrafficStatsUidSet;
  }

  /**
   * Returns an input stream from the server in the case of an error such as
   * the requested file has not been found on the remote server.
   */
  @Override
  public InputStream getErrorStream() {
    try {
      getResponse();
    } catch (IOException e) {
      return null;
    }
    if (mResponseInfo.getHttpStatusCode() >= HTTP_BAD_REQUEST) {
      return mInputStream;
    }
    return null;
  }

  /**
   * Adds the given property to the request header.
   */
  @Override
  public final void addRequestProperty(String key, String value) {
    setRequestPropertyInternal(key, value, false);
  }

  /**
   * Sets the value of the specified request header field.
   */
  @Override
  public final void setRequestProperty(String key, String value) {
    setRequestPropertyInternal(key, value, true);
  }

  private final void setRequestPropertyInternal(String key, String value, boolean overwrite) {
    if (connected) {
      throw new IllegalStateException("Cannot modify request property after connection is made.");
    }
    int index = findRequestProperty(key);
    if (index >= 0) {
      if (overwrite) {
        mRequestHeaders.remove(index);
      } else {
        // Cronet does not support adding multiple headers
        // of the same key, see crbug.com/432719 for more details.
        throw new UnsupportedOperationException("Cannot add multiple headers of the same key, " +
                                                key + ". crbug.com/432719.");
      }
    }
    // Adds the new header at the end of mRequestHeaders.
    mRequestHeaders.add(Pair.create(key, value));
  }

  /**
   * Returns an unmodifiable map of general request properties used by this
   * connection.
   */
  @Override
  public Map<String, List<String>> getRequestProperties() {
    if (connected) {
      throw new IllegalStateException("Cannot access request headers after connection is set.");
    }
    Map<String, List<String>> map =
        new TreeMap<String, List<String>>(String.CASE_INSENSITIVE_ORDER);
    for (Pair<String, String> entry : mRequestHeaders) {
      if (map.containsKey(entry.first)) {
        // This should not happen due to setRequestPropertyInternal.
        throw new IllegalStateException("Should not have multiple values.");
      } else {
        List<String> values = new ArrayList<String>();
        values.add(entry.second);
        map.put(entry.first, Collections.unmodifiableList(values));
      }
    }
    return Collections.unmodifiableMap(map);
  }

  /**
   * Returns the value of the request header property specified by {@code
   * key} or {@code null} if there is no key with this name.
   */
  @Override
  public String getRequestProperty(String key) {
    int index = findRequestProperty(key);
    if (index >= 0) {
      return mRequestHeaders.get(index).second;
    }
    return null;
  }

  /**
   * Returns whether this connection uses a proxy server.
   */
  @Override
  public boolean usingProxy() {
    // TODO(xunjieli): implement this.
    return false;
  }

  @Override
  public void setConnectTimeout(int timeout) {
    // Per-request connect timeout is not supported because of late binding.
    // Sockets are assigned to requests according to request priorities
    // when sockets are connected. This requires requests with the same host,
    // domain and port to have same timeout.
    Log.d(TAG, "setConnectTimeout is not supported by CronvoyHttpURLConnection");
  }

  /**
   * Used by {@link CronetInputStream} to get more data from the network
   * stack. This should only be called after the request has started. Note
   * that this call might block if there isn't any more data to be read.
   * Since byteBuffer is passed to the UrlRequest, it must be a direct
   * ByteBuffer.
   */
  void getMoreData(ByteBuffer byteBuffer) throws IOException {
    mRequest.read(byteBuffer);
    mMessageLoop.loop(getReadTimeout());
  }

  /**
   * Sets {@link TrafficStats} tag to use when accounting socket traffic caused by
   * this request. See {@link TrafficStats} for more information. If no tag is
   * set (e.g. this method isn't called), then Android accounts for the socket traffic caused
   * by this request as if the tag value were set to 0.
   * <p>
   * <b>NOTE:</b>Setting a tag disallows sharing of sockets with requests
   * with other tags, which may adversely effect performance by prohibiting
   * connection sharing. In other words use of multiplexed sockets (e.g. HTTP/2
   * and QUIC) will only be allowed if all requests have the same socket tag.
   *
   * @param tag the tag value used to when accounting for socket traffic caused by this
   *            request. Tags between 0xFFFFFF00 and 0xFFFFFFFF are reserved and used
   *            internally by system services like {@link android.app.DownloadManager} when
   *            performing traffic on behalf of an application.
   */
  public void setTrafficStatsTag(int tag) {
    if (connected) {
      throw new IllegalStateException("Cannot modify traffic stats tag after connection is made.");
    }
    mTrafficStatsTagSet = true;
    mTrafficStatsTag = tag;
  }

  /**
   * Sets specific UID to use when accounting socket traffic caused by this request. See
   * {@link TrafficStats} for more information. Designed for use when performing
   * an operation on behalf of another application. Caller must hold
   * {@link android.Manifest.permission#MODIFY_NETWORK_ACCOUNTING} permission. By default
   * traffic is attributed to UID of caller.
   * <p>
   * <b>NOTE:</b>Setting a UID disallows sharing of sockets with requests
   * with other UIDs, which may adversely effect performance by prohibiting
   * connection sharing. In other words use of multiplexed sockets (e.g. HTTP/2
   * and QUIC) will only be allowed if all requests have the same UID set.
   *
   * @param uid the UID to attribute socket traffic caused by this request.
   */
  public void setTrafficStatsUid(int uid) {
    if (connected) {
      throw new IllegalStateException("Cannot modify traffic stats UID after connection is made.");
    }
    mTrafficStatsUidSet = true;
    mTrafficStatsUid = uid;
  }

  /**
   * Returns the index of request header in {@link #mRequestHeaders} or
   * -1 if not found.
   */
  private int findRequestProperty(String key) {
    for (int i = 0; i < mRequestHeaders.size(); i++) {
      Pair<String, String> entry = mRequestHeaders.get(i);
      if (entry.first.equalsIgnoreCase(key)) {
        return i;
      }
    }
    return -1;
  }

  private class CronetUrlRequestCallback extends UrlRequest.Callback {
    public CronetUrlRequestCallback() {}

    @Override
    public void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
      mResponseInfo = info;
      mHasResponseHeadersOrCompleted = true;
      // Quits the message loop since we have the headers now.
      mMessageLoop.quit();
    }

    @Override
    public void onReadCompleted(UrlRequest request, UrlResponseInfo info, ByteBuffer byteBuffer) {
      mResponseInfo = info;
      mMessageLoop.quit();
    }

    @Override
    public void onRedirectReceived(UrlRequest request, UrlResponseInfo info,
                                   String newLocationUrl) {
      mOnRedirectCalled = true;
      try {
        URL newUrl = new URL(newLocationUrl);
        boolean sameProtocol = newUrl.getProtocol().equals(url.getProtocol());
        if (instanceFollowRedirects) {
          // Update the url variable even if the redirect will not be
          // followed due to different protocols.
          url = newUrl;
        }
        if (instanceFollowRedirects && sameProtocol) {
          mRequest.followRedirect();
          return;
        }
      } catch (MalformedURLException e) {
        // Ignored. Just cancel the request and not follow the redirect.
      }
      mResponseInfo = info;
      mRequest.cancel();
      setResponseDataCompleted(null);
    }

    @Override
    public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
      mResponseInfo = info;
      setResponseDataCompleted(null);
    }

    @Override
    public void onFailed(UrlRequest request, UrlResponseInfo info, CronetException exception) {
      if (exception == null) {
        throw new IllegalStateException("Exception cannot be null in onFailed.");
      }
      mResponseInfo = info;
      setResponseDataCompleted(exception);
    }

    @Override
    public void onCanceled(UrlRequest request, UrlResponseInfo info) {
      mResponseInfo = info;
      setResponseDataCompleted(new IOException("disconnect() called"));
    }

    /**
     * Notifies {@link #mInputStream} that transferring of response data has
     * completed.
     * @param exception if not {@code null}, it is the exception to report when
     *            caller tries to read more data.
     */
    private void setResponseDataCompleted(IOException exception) {
      mException = exception;
      if (mInputStream != null) {
        mInputStream.setResponseDataCompleted(exception);
      }
      if (mOutputStream != null) {
        mOutputStream.setRequestCompleted(exception);
      }
      mHasResponseHeadersOrCompleted = true;
      mMessageLoop.quit();
    }
  }

  /**
   * Blocks until the respone headers are received.
   */
  private void getResponse() throws IOException {
    // Check to see if enough data has been received.
    if (mOutputStream != null) {
      mOutputStream.checkReceivedEnoughContent();
      if (isChunkedUpload()) {
        // Write last chunk.
        mOutputStream.close();
      }
    }
    if (!mHasResponseHeadersOrCompleted) {
      startRequest();
      // Blocks until onResponseStarted or onFailed is called.
      mMessageLoop.loop();
    }
    checkHasResponseHeaders();
  }

  /**
   * Checks whether response headers are received, and throws an exception if
   * an exception occurred before headers received. This method should only be
   * called after onResponseStarted or onFailed.
   */
  private void checkHasResponseHeaders() throws IOException {
    if (!mHasResponseHeadersOrCompleted)
      throw new IllegalStateException("No response.");
    if (mException != null) {
      throw mException;
    } else if (mResponseInfo == null) {
      throw new NullPointerException("Response info is null when there is no exception.");
    }
  }

  /**
   * Helper method to return the response header field at position pos.
   */
  private Map.Entry<String, String> getHeaderFieldEntry(int pos) {
    try {
      getResponse();
    } catch (IOException e) {
      return null;
    }
    List<Map.Entry<String, String>> headers = getAllHeadersAsList();
    if (pos >= headers.size()) {
      return null;
    }
    return headers.get(pos);
  }

  /**
   * Returns whether the client has used {@link #setChunkedStreamingMode} to
   * set chunked encoding for upload.
   */
  private boolean isChunkedUpload() { return chunkLength > 0; }

  // TODO(xunjieli): Refactor to reuse code in UrlResponseInfo.
  private Map<String, List<String>> getAllHeaders() {
    if (mResponseHeadersMap != null) {
      return mResponseHeadersMap;
    }
    Map<String, List<String>> map = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
    for (Map.Entry<String, String> entry : getAllHeadersAsList()) {
      List<String> values = new ArrayList<String>();
      if (map.containsKey(entry.getKey())) {
        values.addAll(map.get(entry.getKey()));
      }
      values.add(entry.getValue());
      map.put(entry.getKey(), Collections.unmodifiableList(values));
    }
    mResponseHeadersMap = Collections.unmodifiableMap(map);
    return mResponseHeadersMap;
  }

  private List<Map.Entry<String, String>> getAllHeadersAsList() {
    if (mResponseHeadersList != null) {
      return mResponseHeadersList;
    }
    mResponseHeadersList = new ArrayList<Map.Entry<String, String>>();
    for (Map.Entry<String, String> entry : mResponseInfo.getAllHeadersAsList()) {
      // Strips Content-Encoding response header. See crbug.com/592700.
      if (!entry.getKey().equalsIgnoreCase("Content-Encoding")) {
        mResponseHeadersList.add(new AbstractMap.SimpleImmutableEntry<String, String>(entry));
      }
    }
    mResponseHeadersList = Collections.unmodifiableList(mResponseHeadersList);
    return mResponseHeadersList;
  }
}
package org.chromium.net.urlconnection;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;

/**
 * An InputStream that is used by {@link CronvoyHttpURLConnection} to request
 * data from the network stack as needed.
 */
final class CronvoyInputStream extends InputStream {
  private final CronvoyHttpURLConnection mHttpURLConnection;
  // Indicates whether listener's onSucceeded or onFailed callback is invoked.
  private boolean mResponseDataCompleted;
  private ByteBuffer mBuffer;
  private IOException mException;

  private static final int READ_BUFFER_SIZE = 32 * 1024;

  /**
   * Constructs a CronvoyInputStream.
   * @param httpURLConnection the CronvoyHttpURLConnection that is associated
   *            with this InputStream.
   */
  public CronvoyInputStream(CronvoyHttpURLConnection httpURLConnection) {
    mHttpURLConnection = httpURLConnection;
  }

  @Override
  public int read() throws IOException {
    getMoreDataIfNeeded();
    if (hasUnreadData()) {
      return mBuffer.get() & 0xFF;
    }
    return -1;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    if (byteOffset < 0 || byteCount < 0 || byteOffset + byteCount > buffer.length) {
      throw new IndexOutOfBoundsException();
    }
    if (byteCount == 0) {
      return 0;
    }
    getMoreDataIfNeeded();
    if (hasUnreadData()) {
      int bytesRead = Math.min(mBuffer.limit() - mBuffer.position(), byteCount);
      mBuffer.get(buffer, byteOffset, bytesRead);
      return bytesRead;
    }
    return -1;
  }

  @Override
  public int available() throws IOException {
    if (mResponseDataCompleted) {
      if (mException != null) {
        throw mException;
      }
      return 0;
    }
    if (hasUnreadData()) {
      return mBuffer.remaining();
    } else {
      return 0;
    }
  }

  /**
   * Called by {@link CronvoyHttpURLConnection} to notify that the entire
   * response body has been read.
   * @param exception if not {@code null}, it is the exception to throw when caller
   *            tries to read more data.
   */
  void setResponseDataCompleted(IOException exception) {
    mException = exception;
    mResponseDataCompleted = true;
    // Nothing else to read, so can free the buffer.
    mBuffer = null;
  }

  private void getMoreDataIfNeeded() throws IOException {
    if (mResponseDataCompleted) {
      if (mException != null) {
        throw mException;
      }
      return;
    }
    if (!hasUnreadData()) {
      // Allocate read buffer if needed.
      if (mBuffer == null) {
        mBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE);
      }
      mBuffer.clear();

      // Requests more data from CronvoyHttpURLConnection.
      mHttpURLConnection.getMoreData(mBuffer);
      if (mException != null) {
        throw mException;
      }
      if (mBuffer != null) {
        mBuffer.flip();
      }
    }
  }

  /**
   * Returns whether {@link #mBuffer} has unread data.
   */
  private boolean hasUnreadData() { return mBuffer != null && mBuffer.hasRemaining(); }
}
package org.chromium.net.urlconnection;

import java.io.IOException;
import java.net.ProtocolException;
import java.nio.ByteBuffer;
import org.chromium.net.UploadDataProvider;
import org.chromium.net.UploadDataSink;

/**
 * An implementation of {@link java.io.OutputStream} that buffers entire request
 * body in memory. This is used when neither
 * {@link CronvoyHttpURLConnection#setFixedLengthStreamingMode}
 * nor {@link CronvoyHttpURLConnection#setChunkedStreamingMode} is set.
 */
final class CronvoyBufferedOutputStream extends CronvoyOutputStream {
  // QUIC uses a read buffer of 14520 bytes, SPDY uses 2852 bytes, and normal
  // stream uses 16384 bytes. Therefore, use 16384 for now to avoid growing
  // the buffer too many times.
  private static final int INITIAL_BUFFER_SIZE = 16384;
  // If content length is not passed in the constructor, this is -1.
  private final int mInitialContentLength;
  private final CronvoyHttpURLConnection mConnection;
  private final UploadDataProvider mUploadDataProvider = new UploadDataProviderImpl();
  // Internal buffer that is used to buffer the request body.
  private ByteBuffer mBuffer;
  private boolean mConnected;

  /**
   * Package protected constructor.
   * @param connection The CronvoyHttpURLConnection object.
   * @param contentLength The content length of the request body. It must not
   *            be smaller than 0 or bigger than {@link Integer.MAX_VALUE}.
   */
  CronvoyBufferedOutputStream(final CronvoyHttpURLConnection connection, final long contentLength) {
    if (connection == null) {
      throw new NullPointerException("Argument connection cannot be null.");
    }

    if (contentLength > Integer.MAX_VALUE) {
      throw new IllegalArgumentException(
          "Use setFixedLengthStreamingMode()"
          + " or setChunkedStreamingMode() for requests larger than 2GB.");
    }
    if (contentLength < 0) {
      throw new IllegalArgumentException("Content length < 0.");
    }
    mConnection = connection;
    mInitialContentLength = (int)contentLength;
    mBuffer = ByteBuffer.allocate(mInitialContentLength);
  }

  /**
   * Package protected constructor used when content length is not known.
   * @param connection The CronvoyHttpURLConnection object.
   */
  CronvoyBufferedOutputStream(final CronvoyHttpURLConnection connection) {
    if (connection == null) {
      throw new NullPointerException();
    }

    mConnection = connection;
    mInitialContentLength = -1;
    // Buffering without knowing content-length.
    mBuffer = ByteBuffer.allocate(INITIAL_BUFFER_SIZE);
  }

  @Override
  public void write(int oneByte) throws IOException {
    checkNotClosed();
    ensureCanWrite(1);
    mBuffer.put((byte)oneByte);
  }

  @Override
  public void write(byte[] buffer, int offset, int count) throws IOException {
    checkNotClosed();
    ensureCanWrite(count);
    mBuffer.put(buffer, offset, count);
  }

  /**
   * Ensures that {@code count} bytes can be written to the internal buffer.
   */
  private void ensureCanWrite(int count) throws IOException {
    if (mInitialContentLength != -1 && mBuffer.position() + count > mInitialContentLength) {
      // Error message is to match that of the default implementation.
      throw new ProtocolException("exceeded content-length limit of " + mInitialContentLength +
                                  " bytes");
    }
    if (mConnected) {
      throw new IllegalStateException("Use setFixedLengthStreamingMode() or "
                                      + "setChunkedStreamingMode() for writing after connect");
    }
    if (mInitialContentLength != -1) {
      // If mInitialContentLength is known, the buffer should not grow.
      return;
    }
    if (mBuffer.limit() - mBuffer.position() > count) {
      // If there is enough capacity, the buffer should not grow.
      return;
    }
    int afterSize = Math.max(mBuffer.capacity() * 2, mBuffer.capacity() + count);
    ByteBuffer newByteBuffer = ByteBuffer.allocate(afterSize);
    mBuffer.flip();
    newByteBuffer.put(mBuffer);
    mBuffer = newByteBuffer;
  }

  // Below are CronvoyOutputStream implementations:

  /**
   * Sets {@link #mConnected} to {@code true}.
   */
  @Override
  void setConnected() throws IOException {
    mConnected = true;
    if (mBuffer.position() < mInitialContentLength) {
      throw new ProtocolException("Content received is less than Content-Length");
    }
    // Flip the buffer to prepare it for UploadDataProvider read calls.
    mBuffer.flip();
  }

  @Override
  void checkReceivedEnoughContent() throws IOException {
    // Already checked in setConnected. Skip the check here, since mBuffer
    // might be flipped.
  }

  @Override
  UploadDataProvider getUploadDataProvider() {
    return mUploadDataProvider;
  }

  private class UploadDataProviderImpl extends UploadDataProvider {
    @Override
    public long getLength() {
      // This method is supposed to be called just before starting the request.
      // If content length is not initially passed in, the number of bytes
      // written will be used as the content length.
      // TODO(xunjieli): Think of a less fragile way, since getLength() can be
      // potentially called in other places in the future.
      if (mInitialContentLength == -1) {
        // Account for the fact that setConnected() flip()s mBuffer.
        return mConnected ? mBuffer.limit() : mBuffer.position();
      }
      return mInitialContentLength;
    }

    @Override
    public void read(UploadDataSink uploadDataSink, ByteBuffer byteBuffer) {
      final int availableSpace = byteBuffer.remaining();
      if (availableSpace < mBuffer.remaining()) {
        byteBuffer.put(mBuffer.array(), mBuffer.position(), availableSpace);
        mBuffer.position(mBuffer.position() + availableSpace);
      } else {
        byteBuffer.put(mBuffer);
      }
      uploadDataSink.onReadSucceeded(false);
    }

    @Override
    public void rewind(UploadDataSink uploadDataSink) {
      mBuffer.position(0);
      uploadDataSink.onRewindSucceeded();
    }
  }
}
package org.chromium.net.urlconnection;

import androidx.annotation.VisibleForTesting;
import java.io.IOException;
import java.net.HttpRetryException;
import java.net.ProtocolException;
import java.nio.ByteBuffer;
import org.chromium.net.UploadDataProvider;
import org.chromium.net.UploadDataSink;

/**
 * An implementation of {@link java.io.OutputStream} to send data to a server,
 * when {@link CronvoyHttpURLConnection#setFixedLengthStreamingMode} is used.
 * This implementation does not buffer the entire request body in memory.
 * It does not support rewind. Note that {@link #write} should only be called
 * from the thread on which the {@link #mConnection} is created.
 */
final class CronvoyFixedModeOutputStream extends CronvoyOutputStream {
  // CronvoyFixedModeOutputStream buffers up to this value and wait for UploadDataStream
  // to consume the data. This field is non-final, so it can be changed for tests.
  // Using 16384 bytes is because the internal read buffer is 14520 for QUIC,
  // 16384 for SPDY, and 16384 for normal HTTP/1.1 stream.
  @VisibleForTesting private static int sDefaultBufferLength = 16384;
  private final CronvoyHttpURLConnection mConnection;
  private final CronvoyMessageLoop mMessageLoop;
  private final long mContentLength;
  // Internal buffer for holding bytes from the client until the bytes are
  // copied to the UploadDataSink in UploadDataProvider.read().
  // CronvoyFixedModeOutputStream allows client to provide up to
  // sDefaultBufferLength bytes, and wait for UploadDataProvider.read() to be
  // called after which point mBuffer is cleared so client can fill in again.
  // While the client is filling the buffer (via {@code write()}), the buffer's
  // position points to the next byte to be provided by the client, and limit
  // points to the end of the buffer. The buffer is flipped before it is
  // passed to the UploadDataProvider for consuming. Once it is flipped,
  // buffer position points to the next byte to be copied to the
  // UploadDataSink, and limit points to the end of data available to be
  // copied to UploadDataSink. When the UploadDataProvider has provided all
  // remaining bytes from the buffer to UploadDataSink, it clears the buffer
  // so client can fill it again.
  private final ByteBuffer mBuffer;
  private final UploadDataProvider mUploadDataProvider = new UploadDataProviderImpl();
  private long mBytesWritten;

  /**
   * Package protected constructor.
   * @param connection The CronvoyHttpURLConnection object.
   * @param contentLength The content length of the request body. Non-zero for
   *            non-chunked upload.
   */
  CronvoyFixedModeOutputStream(CronvoyHttpURLConnection connection, long contentLength,
                               CronvoyMessageLoop messageLoop) {
    if (connection == null) {
      throw new NullPointerException();
    }
    if (contentLength < 0) {
      throw new IllegalArgumentException(
          "Content length must be larger than 0 for non-chunked upload.");
    }
    mContentLength = contentLength;
    int bufferSize = (int)Math.min(mContentLength, sDefaultBufferLength);
    mBuffer = ByteBuffer.allocate(bufferSize);
    mConnection = connection;
    mMessageLoop = messageLoop;
    mBytesWritten = 0;
  }

  @Override
  public void write(int oneByte) throws IOException {
    checkNotClosed();
    checkNotExceedContentLength(1);
    ensureBufferHasRemaining();
    mBuffer.put((byte)oneByte);
    mBytesWritten++;
    uploadIfComplete();
  }

  @Override
  public void write(byte[] buffer, int offset, int count) throws IOException {
    checkNotClosed();
    if (buffer.length - offset < count || offset < 0 || count < 0) {
      throw new IndexOutOfBoundsException();
    }
    checkNotExceedContentLength(count);
    int toSend = count;
    while (toSend > 0) {
      ensureBufferHasRemaining();
      int sent = Math.min(toSend, mBuffer.remaining());
      mBuffer.put(buffer, offset + count - toSend, sent);
      toSend -= sent;
    }
    mBytesWritten += count;
    uploadIfComplete();
  }

  /**
   * If {@code mBuffer} is full, wait until it is consumed and there is
   * space to write more data to it.
   */
  private void ensureBufferHasRemaining() throws IOException {
    if (!mBuffer.hasRemaining()) {
      uploadBufferInternal();
    }
  }

  /**
   * Waits for the native stack to upload {@code mBuffer}'s contents because
   * the client has provided all bytes to be uploaded and there is no need to
   * wait for or expect the client to provide more bytes.
   */
  private void uploadIfComplete() throws IOException {
    if (mBytesWritten == mContentLength) {
      // Entire post data has been received. Now wait for network stack to
      // read it.
      uploadBufferInternal();
    }
  }

  /**
   * Helper function to upload {@code mBuffer} to the native stack. This
   * function blocks until {@code mBuffer} is consumed and there is space to
   * write more data.
   */
  private void uploadBufferInternal() throws IOException {
    checkNotClosed();
    mBuffer.flip();
    mMessageLoop.loop();
    checkNoException();
  }

  /**
   * Throws {@link ProtocolException} if adding {@code numBytes} will
   * exceed content length.
   */
  private void checkNotExceedContentLength(int numBytes) throws ProtocolException {
    if (mBytesWritten + numBytes > mContentLength) {
      throw new ProtocolException("expected " + (mContentLength - mBytesWritten) +
                                  " bytes but received " + numBytes);
    }
  }

  // Below are CronvoyOutputStream implementations:

  @Override
  void setConnected() throws IOException {
    // Do nothing.
  }

  @Override
  void checkReceivedEnoughContent() throws IOException {
    if (mBytesWritten < mContentLength) {
      throw new ProtocolException("Content received is less than Content-Length.");
    }
  }

  @Override
  UploadDataProvider getUploadDataProvider() {
    return mUploadDataProvider;
  }

  private class UploadDataProviderImpl extends UploadDataProvider {
    @Override
    public long getLength() {
      return mContentLength;
    }

    @Override
    public void read(final UploadDataSink uploadDataSink, final ByteBuffer byteBuffer) {
      if (byteBuffer.remaining() >= mBuffer.remaining()) {
        byteBuffer.put(mBuffer);
        // Reuse this buffer.
        mBuffer.clear();
        uploadDataSink.onReadSucceeded(false);
        // Quit message loop so embedder can write more data.
        mMessageLoop.quit();
      } else {
        int oldLimit = mBuffer.limit();
        mBuffer.limit(mBuffer.position() + byteBuffer.remaining());
        byteBuffer.put(mBuffer);
        mBuffer.limit(oldLimit);
        uploadDataSink.onReadSucceeded(false);
      }
    }

    @Override
    public void rewind(UploadDataSink uploadDataSink) {
      uploadDataSink.onRewindError(new HttpRetryException("Cannot retry streamed Http body", -1));
    }
  }

  /**
   * Sets the default buffer length for use in tests.
   */
  @VisibleForTesting
  static void setDefaultBufferLengthForTesting(int length) {
    sDefaultBufferLength = length;
  }
}
package org.chromium.net.urlconnection;

import java.io.IOException;
import java.net.HttpRetryException;
import java.nio.ByteBuffer;
import org.chromium.net.UploadDataProvider;
import org.chromium.net.UploadDataSink;

/**
 * An implementation of {@link java.io.OutputStream} to send data to a server,
 * when {@link CronvoyHttpURLConnection#setChunkedStreamingMode} is used.
 * This implementation does not buffer the entire request body in memory.
 * It does not support rewind. Note that {@link #write} should only be called
 * from the thread on which the {@link #mConnection} is created.
 */
final class CronvoyChunkedOutputStream extends CronvoyOutputStream {
  private final CronvoyHttpURLConnection mConnection;
  private final CronvoyMessageLoop mMessageLoop;
  private final ByteBuffer mBuffer;
  private final UploadDataProvider mUploadDataProvider = new UploadDataProviderImpl();
  private boolean mLastChunk;

  /**
   * Package protected constructor.
   * @param connection The CronvoyHttpURLConnection object.
   * @param chunkLength The chunk length of the request body in bytes. It must
   *            be a positive number.
   */
  CronvoyChunkedOutputStream(CronvoyHttpURLConnection connection, int chunkLength,
                             CronvoyMessageLoop messageLoop) {
    if (connection == null) {
      throw new NullPointerException();
    }
    if (chunkLength <= 0) {
      throw new IllegalArgumentException("chunkLength should be greater than 0");
    }
    mBuffer = ByteBuffer.allocate(chunkLength);
    mConnection = connection;
    mMessageLoop = messageLoop;
  }

  @Override
  public void write(int oneByte) throws IOException {
    ensureBufferHasRemaining();
    mBuffer.put((byte)oneByte);
  }

  @Override
  public void write(byte[] buffer, int offset, int count) throws IOException {
    checkNotClosed();
    if (buffer.length - offset < count || offset < 0 || count < 0) {
      throw new IndexOutOfBoundsException();
    }
    int toSend = count;
    while (toSend > 0) {
      int sent = Math.min(toSend, mBuffer.remaining());
      mBuffer.put(buffer, offset + count - toSend, sent);
      toSend -= sent;
      // Upload mBuffer now if an entire chunk is written.
      ensureBufferHasRemaining();
    }
  }

  @Override
  public void close() throws IOException {
    super.close();
    if (!mLastChunk) {
      // Consumer can only call close() when message loop is not running.
      // Set mLastChunk to be true and flip mBuffer to upload its contents.
      mLastChunk = true;
      mBuffer.flip();
    }
  }

  // Below are CronvoyOutputStream implementations:

  @Override
  void setConnected() throws IOException {
    // Do nothing.
  }

  @Override
  void checkReceivedEnoughContent() throws IOException {
    // Do nothing.
  }

  @Override
  UploadDataProvider getUploadDataProvider() {
    return mUploadDataProvider;
  }

  private class UploadDataProviderImpl extends UploadDataProvider {
    @Override
    public long getLength() {
      return -1;
    }

    @Override
    public void read(final UploadDataSink uploadDataSink, final ByteBuffer byteBuffer) {
      if (byteBuffer.remaining() >= mBuffer.remaining()) {
        byteBuffer.put(mBuffer);
        mBuffer.clear();
        uploadDataSink.onReadSucceeded(mLastChunk);
        if (!mLastChunk) {
          // Quit message loop so embedder can write more data.
          mMessageLoop.quit();
        }
      } else {
        int oldLimit = mBuffer.limit();
        mBuffer.limit(mBuffer.position() + byteBuffer.remaining());
        byteBuffer.put(mBuffer);
        mBuffer.limit(oldLimit);
        uploadDataSink.onReadSucceeded(false);
      }
    }

    @Override
    public void rewind(UploadDataSink uploadDataSink) {
      uploadDataSink.onRewindError(new HttpRetryException("Cannot retry streamed Http body", -1));
    }
  }

  /**
   * If {@code mBuffer} is full, wait until it is consumed and there is
   * space to write more data to it.
   */
  private void ensureBufferHasRemaining() throws IOException {
    if (!mBuffer.hasRemaining()) {
      uploadBufferInternal();
    }
  }

  /**
   * Helper function to upload {@code mBuffer} to the native stack. This
   * function blocks until {@code mBuffer} is consumed and there is space to
   * write more data.
   */
  private void uploadBufferInternal() throws IOException {
    checkNotClosed();
    mBuffer.flip();
    mMessageLoop.loop();
    checkNoException();
  }
}
package org.chromium.net.urlconnection;

import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.SocketTimeoutException;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;

/**
 * A MessageLoop class for use in {@link CronetHttpURLConnection}.
 */
final class CronvoyMessageLoop implements Executor {
  private final BlockingQueue<Runnable> mQueue;

  // Indicates whether this message loop is currently running.
  private boolean mLoopRunning;

  // Indicates whether an InterruptedException or a RuntimeException has
  // occurred in loop(). If true, the loop cannot be safely started because
  // this might cause the loop to terminate immediately if there is a quit
  // task enqueued.
  private boolean mLoopFailed;
  // The exception that caused mLoopFailed to be set to true. Will be
  // rethrown if loop() is called again. If mLoopFailed is set then
  // exactly one of mPriorInterruptedIOException and mPriorRuntimeException
  // will be set.
  private InterruptedIOException mPriorInterruptedIOException;
  private RuntimeException mPriorRuntimeException;

  // Used when assertions are enabled to enforce single-threaded use.
  private static final long INVALID_THREAD_ID = -1;
  private long mThreadId = INVALID_THREAD_ID;

  CronvoyMessageLoop() { mQueue = new LinkedBlockingQueue<Runnable>(); }

  private boolean calledOnValidThread() {
    if (mThreadId == INVALID_THREAD_ID) {
      mThreadId = Thread.currentThread().getId();
      return true;
    }
    return mThreadId == Thread.currentThread().getId();
  }

  /**
   * Retrieves a task from the queue with the given timeout.
   *
   * @param useTimeout whether to use a timeout.
   * @param timeoutNano Time to wait, in nanoseconds.
   * @return A non-{@code null} Runnable from the queue.
   * @throws InterruptedIOException
   */
  private Runnable take(boolean useTimeout, long timeoutNano) throws InterruptedIOException {
    Runnable task = null;
    try {
      if (!useTimeout) {
        task = mQueue.take(); // Blocks if the queue is empty.
      } else {
        // poll returns null upon timeout.
        task = mQueue.poll(timeoutNano, TimeUnit.NANOSECONDS);
      }
    } catch (InterruptedException e) {
      InterruptedIOException exception = new InterruptedIOException();
      exception.initCause(e);
      throw exception;
    }
    if (task == null) {
      // This will terminate the loop.
      throw new SocketTimeoutException();
    }
    return task;
  }

  /**
   * Runs the message loop. Be sure to call {@link CronvoyMessageLoop#quit()}
   * to end the loop. If an interruptedException occurs, the loop cannot be
   * started again (see {@link #mLoopFailed}).
   * @throws IOException
   */
  public void loop() throws IOException { loop(0); }

  /**
   * Runs the message loop. Be sure to call {@link CronvoyMessageLoop#quit()}
   * to end the loop. If an interruptedException occurs, the loop cannot be
   * started again (see {@link #mLoopFailed}).
   * @param timeoutMilli Timeout, in milliseconds, or 0 for no timeout.
   * @throws IOException
   */
  public void loop(int timeoutMilli) throws IOException {
    assert calledOnValidThread();
    // Use System.nanoTime() which is monotonically increasing.
    long startNano = System.nanoTime();
    long timeoutNano = TimeUnit.NANOSECONDS.convert(timeoutMilli, TimeUnit.MILLISECONDS);
    if (mLoopFailed) {
      if (mPriorInterruptedIOException != null) {
        throw mPriorInterruptedIOException;
      } else {
        throw mPriorRuntimeException;
      }
    }
    if (mLoopRunning) {
      throw new IllegalStateException("Cannot run loop when it is already running.");
    }
    mLoopRunning = true;
    while (mLoopRunning) {
      try {
        if (timeoutMilli == 0) {
          take(false, 0).run();
        } else {
          take(true, timeoutNano - System.nanoTime() + startNano).run();
        }
      } catch (InterruptedIOException e) {
        mLoopRunning = false;
        mLoopFailed = true;
        mPriorInterruptedIOException = e;
        throw e;
      } catch (RuntimeException e) {
        mLoopRunning = false;
        mLoopFailed = true;
        mPriorRuntimeException = e;
        throw e;
      }
    }
  }

  /**
   * This causes {@link #loop()} to stop executing messages after the current
   * message being executed. Should only be called from the currently
   * executing message.
   */
  public void quit() {
    assert calledOnValidThread();
    mLoopRunning = false;
  }

  /**
   * Posts a task to the message loop.
   */
  @Override
  public void execute(Runnable task) throws RejectedExecutionException {
    if (task == null) {
      throw new IllegalArgumentException();
    }
    try {
      mQueue.put(task);
    } catch (InterruptedException e) {
      // In theory this exception won't happen, since we have an blocking
      // queue with Integer.MAX_Value capacity, put() call will not block.
      throw new RejectedExecutionException(e);
    }
  }

  /**
   * Returns whether the loop is currently running. Used in testing.
   */
  public boolean isRunning() { return mLoopRunning; }

  /**
   * Returns whether an exception occurred in {#loop()}. Used in testing.
   */
  public boolean hasLoopFailed() { return mLoopFailed; }
}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="org.urlconnection">
  <uses-sdk
      android:minSdkVersion="21"
      android:targetSdkVersion="29" />
</manifest>
package org.chromium.net.urlconnection;

import java.io.IOException;
import java.io.OutputStream;
import org.chromium.net.UploadDataProvider;

/**
 * An abstract class of {@link OutputStream} that concrete implementations must
 * extend in order to be used in {@link CronvoyHttpURLConnection}.
 */
abstract class CronvoyOutputStream extends OutputStream {
  private IOException mException;
  private boolean mClosed;
  private boolean mRequestCompleted;

  @Override
  public void close() throws IOException {
    mClosed = true;
  }

  /**
   * Tells the underlying implementation that connection has been established.
   * Used in {@link CronvoyHttpURLConnection}.
   */
  abstract void setConnected() throws IOException;

  /**
   * Checks whether content received is less than Content-Length.
   * Used in {@link CronvoyHttpURLConnection}.
   */
  abstract void checkReceivedEnoughContent() throws IOException;

  /**
   * Returns {@link UploadDataProvider} implementation.
   */
  abstract UploadDataProvider getUploadDataProvider();

  /**
   * Signals that the request is done. If there is no error,
   * {@code exception} is null. Used by {@link CronvoyHttpURLConnection}.
   */
  void setRequestCompleted(IOException exception) {
    mException = exception;
    mRequestCompleted = true;
  }

  /**
   * Throws an IOException if the stream is closed or the request is done.
   */
  protected void checkNotClosed() throws IOException {
    if (mRequestCompleted) {
      checkNoException();
      throw new IOException("Writing after request completed.");
    }
    if (mClosed) {
      throw new IOException("Stream has been closed.");
    }
  }

  /**
   * Throws the same IOException that the request is failed with. If there
   * is no exception reported, this method is no-op.
   */
  protected void checkNoException() throws IOException {
    if (mException != null) {
      throw mException;
    }
  }
}
package org.chromium.net.urlconnection;

import java.net.URLStreamHandler;
import java.net.URLStreamHandlerFactory;
import org.chromium.net.ExperimentalCronetEngine;

/**
 * An implementation of {@link URLStreamHandlerFactory} to handle HTTP and HTTPS
 * traffic. An instance of this class can be installed via
 * {@link java.net.URL#setURLStreamHandlerFactory} thus using Cronet by default for all requests
 * created via {@link java.net.URL#openConnection}.
 * <p>
 * Cronet does not use certain HTTP features provided via the system:
 * <ul>
 * <li>the HTTP cache installed via
 *     {@link android.net.http.HttpResponseCache#install}</li>
 * <li>the HTTP authentication method installed via
 *     {@link java.net.Authenticator#setDefault}</li>
 * <li>the HTTP cookie storage installed via {@link java.net.CookieHandler#setDefault}</li>
 * </ul>
 * <p>
 * While Cronet supports and encourages requests using the HTTPS protocol,
 * Cronet does not provide support for the
 * {@link javax.net.ssl.HttpsURLConnection} API. This lack of support also
 * includes not using certain HTTPS features provided via the system:
 * <ul>
 * <li>the HTTPS hostname verifier installed via {@link
 *     javax.net.ssl.HttpsURLConnection#setDefaultHostnameVerifier(javax.net.ssl.HostnameVerifier)
 *     HttpsURLConnection.setDefaultHostnameVerifier(javax.net.ssl.HostnameVerifier)}</li>
 * <li>the HTTPS socket factory installed via {@link
 *     javax.net.ssl.HttpsURLConnection#setDefaultSSLSocketFactory(javax.net.ssl.SSLSocketFactory)
 *     HttpsURLConnection.setDefaultSSLSocketFactory(javax.net.ssl.SSLSocketFactory)}</li>
 * </ul>
 *
 * {@hide}
 */
public final class CronvoyURLStreamHandlerFactory implements URLStreamHandlerFactory {
  private final ExperimentalCronetEngine mCronetEngine;

  /**
   * Creates a {@link CronvoyURLStreamHandlerFactory} to handle HTTP and HTTPS
   * traffic.
   * @param cronetEngine the {@link CronetEngine} to be used.
   * @throws NullPointerException if config is null.
   */
  public CronvoyURLStreamHandlerFactory(ExperimentalCronetEngine cronetEngine) {
    if (cronetEngine == null) {
      throw new NullPointerException("CronetEngine is null.");
    }
    mCronetEngine = cronetEngine;
  }

  /**
   * Returns a {@link CronvoyHttpURLStreamHandler} for HTTP and HTTPS, and
   * {@code null} for other protocols.
   */
  @Override
  public URLStreamHandler createURLStreamHandler(String protocol) {
    if ("http".equals(protocol) || "https".equals(protocol)) {
      return new CronvoyHttpURLStreamHandler(mCronetEngine);
    }
    return null;
  }
}
load("@build_bazel_rules_android//android:rules.bzl", "android_library")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@rules_jvm_external//:defs.bzl", "artifact")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

# Android libraries for urlconnection

# A URL connection interface backed by Envoy-Mobile.

android_library(
    name = "urlconnection",
    srcs = [
        "CronvoyBufferedOutputStream.java",
        "CronvoyChunkedOutputStream.java",
        "CronvoyFixedModeOutputStream.java",
        "CronvoyHttpURLConnection.java",
        "CronvoyHttpURLStreamHandler.java",
        "CronvoyInputStream.java",
        "CronvoyMessageLoop.java",
        "CronvoyOutputStream.java",
        "CronvoyURLStreamHandlerFactory.java",
    ],
    manifest = "URLConnectionManifest.xml",
    visibility = ["//visibility:public"],
    deps = [
        "//library/java/io/envoyproxy/envoymobile/utilities",
        "//library/java/org/chromium/net",
        artifact("androidx.annotation:annotation"),
    ],
)
package org.chromium.net.urlconnection;

import java.io.IOException;
import java.net.Proxy;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import org.chromium.net.ExperimentalCronetEngine;

/**
 * A {@link URLStreamHandler} that handles HTTP and HTTPS connections. One can use this class to
 * create {@link java.net.HttpURLConnection} instances implemented by Cronet; for example: <pre>
 *
 * CronvoyHttpURLStreamHandler streamHandler = new CronvoyHttpURLStreamHandler(myContext);
 * HttpURLConnection connection = (HttpURLConnection)streamHandler.openConnection(
 *         new URL("http://chromium.org"));</pre>
 * <b>Note:</b> Cronet's {@code HttpURLConnection} implementation is subject to some limitations
 * listed {@link CronvoyURLStreamHandlerFactory here}.
 */
final class CronvoyHttpURLStreamHandler extends URLStreamHandler {
  private final ExperimentalCronetEngine mCronetEngine;

  public CronvoyHttpURLStreamHandler(ExperimentalCronetEngine cronetEngine) {
    mCronetEngine = cronetEngine;
  }

  /**
   * Establishes a new connection to the resource specified by the {@link URL} {@code url}.
   * @return an {@link java.net.HttpURLConnection} instance implemented by Cronet.
   */
  @Override
  public URLConnection openConnection(URL url) throws IOException {
    return mCronetEngine.openConnection(url);
  }

  /**
   * Establishes a new connection to the resource specified by the {@link URL} {@code url}
   * using the given proxy.
   * @return an {@link java.net.HttpURLConnection} instance implemented by Cronet.
   */
  @Override
  public URLConnection openConnection(URL url, Proxy proxy) throws IOException {
    return mCronetEngine.openConnection(url, proxy);
  }
}
package org.chromium.net;

/**
 * Version based on chrome/VERSION.
 *
 * It's only used internally.
 */
public final class ApiVersion {
  // TODO(carloseltuerto) make this class a template and use "@MAJOR@.@MINOR@.@BUILD@.@PATCH@"
  private static final String CRONET_VERSION = "99.0.4512.7";
  // TODO(carloseltuerto) make this class a template and use @API_LEVEL@;
  private static final int API_LEVEL = 14;
  /**
   * The minimum API level of implementations that are compatible with this API.
   * The last API level which broke backwards API compatibility. In other words, the
   * Cronet API that this class is part of won't work with Cronet implementations that implement
   * API levels less than this value. That is if
   * ImplVersion.getApiLevel() < ApiVersion.getApiLevel(), then the Cronet implementation
   * providing ImplVersion cannot be used with the Cronet API providing ApiVersion; if they are
   * used together various unexpected Errors, like AbstractMethodError, may result.
   */
  private static final int MIN_COMPATIBLE_API_LEVEL = 3;
  // TODO(carloseltuerto) make this class a template and use "@LAST_CHANGE@";
  private static final String LAST_CHANGE = "20220222";

  /**
   * Private constructor. All members of this class should be static.
   */
  private ApiVersion() {}

  public static String getCronetVersionWithLastChange() {
    return CRONET_VERSION + "@" + LAST_CHANGE.substring(0, 8);
  }

  /**
   * Returns API level of the API linked into the application. This is the maximum API
   * level the application can use, even if the application is run with a newer implementation.
   */
  public static int getMaximumAvailableApiLevel() { return API_LEVEL; }

  /**
   * The minimum API level of implementations that are compatible with this API.
   * Returns the last API level which broke backwards API compatibility. In other words, the
   * Cronet API that this class is part of won't work with Cronet implementations that implement
   * API levels less than this value. That is if
   * ImplVersion.getApiLevel() < ApiVersion.getApiLevel(), then the Cronet implementation
   * providing ImplVersion cannot be used with the Cronet API providing ApiVersion; if they are
   * used together various unexpected Errors, like AbstractMethodError, may result.
   */
  public static int getApiLevel() { return MIN_COMPATIBLE_API_LEVEL; }

  public static String getCronetVersion() { return CRONET_VERSION; }

  public static String getLastChange() { return LAST_CHANGE; }
}
package org.chromium.net;

/**
 * Defines callbacks methods for {@link UploadDataProvider}. All methods may be called synchronously
 * or asynchronously, on any thread.
 */
public abstract class UploadDataSink {
  /**
   * Called by {@link UploadDataProvider} when a read succeeds.
   *
   * @param finalChunk For chunked uploads, {@code true} if this is the final read. It must be
   *     {@code false} for non-chunked uploads.
   */
  public abstract void onReadSucceeded(boolean finalChunk);

  /**
   * Called by {@link UploadDataProvider} when a read fails.
   *
   * @param exception Exception passed on to the embedder.
   */
  public abstract void onReadError(Exception exception);

  /** Called by {@link UploadDataProvider} when a rewind succeeds. */
  public abstract void onRewindSucceeded();

  /**
   * Called by {@link UploadDataProvider} when a rewind fails, or if rewinding uploads is not
   * supported.
   *
   * @param exception Exception passed on to the embedder.
   */
  public abstract void onRewindError(Exception exception);
}
package org.chromium.net;

import android.content.Context;
import android.util.Log;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

/**
 * Provides a factory method to create {@link CronetEngine.Builder} instances. A {@code
 * CronetEngine.Builder} instance can be used to create a specific {@link CronetEngine}
 * implementation. To get the list of available {@link CronvoyProvider}s call {@link
 * #getAllProviders(Context)}.
 *
 * <p><b>NOTE:</b> This class is for advanced users that want to select a particular Cronet
 * implementation. Most users should simply use {@code new} {@link
 * CronetEngine.Builder#CronetEngine.Builder(android.content.Context)}.
 *
 * <p>{@hide}
 */
public abstract class CronvoyProvider {
  /**
   * String returned by {@link CronvoyProvider#getName} for {@link CronvoyProvider} that provides
   * native Cronet implementation packaged inside an application. This implementation offers
   * significantly higher performance relative to the fallback Cronet implementations (see {@link
   * #PROVIDER_NAME_FALLBACK}).
   */
  public static final String PROVIDER_NAME_APP_PACKAGED = "App-Packaged-Cronet-Provider";

  /**
   * String returned by {@link CronvoyProvider#getName} for {@link CronvoyProvider} that provides
   * Cronet implementation based on the system's {@link java.net.HttpURLConnection} implementation.
   * This implementation offers significantly degraded performance relative to native Cronet
   * implementations (see {@link #PROVIDER_NAME_APP_PACKAGED}).
   */
  public static final String PROVIDER_NAME_FALLBACK = "Fallback-Cronet-Provider";

  private static final String TAG = CronvoyProvider.class.getSimpleName();

  protected final Context mContext;

  protected CronvoyProvider(Context context) {
    if (context == null) {
      throw new IllegalArgumentException("Context must not be null");
    }
    mContext = context;
  }

  /**
   * Creates and returns an instance of {@link CronetEngine.Builder}.
   *
   * <p><b>NOTE:</b> This class is for advanced users that want to select a particular Cronet
   * implementation. Most users should simply use {@code new} {@link
   * CronetEngine.Builder#CronetEngine.Builder(android.content.Context)}.
   *
   * @return {@code CronetEngine.Builder}.
   * @throws IllegalStateException if the provider is not enabled (see {@link #isEnabled}.
   */
  public abstract CronetEngine.Builder createBuilder();

  /**
   * Returns the provider name. The well-know provider names include:
   *
   * <ul>
   *   <li>{@link #PROVIDER_NAME_APP_PACKAGED}
   *   <li>{@link #PROVIDER_NAME_FALLBACK}
   * </ul>
   *
   * @return provider name.
   */
  public abstract String getName();

  /**
   * Returns the provider version. The version can be used to select the newest available provider
   * if multiple providers are available.
   *
   * @return provider version.
   */
  public abstract String getVersion();

  /**
   * Returns whether the provider is enabled and can be used to instantiate the Cronet engine. A
   * provider being out-of-date (older than the API) and needing updating is one potential reason it
   * could be disabled. Please read the provider documentation for enablement procedure.
   *
   * @return {@code true} if the provider is enabled.
   */
  public abstract boolean isEnabled();

  @Override
  public String toString() {
    return "["
        + "class=" + getClass().getName() + ", "
        + "name=" + getName() + ", "
        + "version=" + getVersion() + ", "
        + "enabled=" + isEnabled() + "]";
  }

  /** Name of the native {@link CronvoyProvider} class. */
  private static final String NATIVE_CRONVOY_PROVIDER_CLASS =
      "org.chromium.net.impl.NativeCronvoyProvider";

  /**
   * Returns an unmodifiable list of all available {@link CronvoyProvider}s. The providers are
   * returned in no particular order. Some of the returned providers may be in a disabled state and
   * should be enabled by the invoker. See {@link CronvoyProvider#isEnabled()}.
   *
   * @return the list of available providers.
   */
  public static List<CronvoyProvider> getAllProviders(Context context) {
    // Use LinkedHashSet to preserve the order and eliminate duplicate providers.
    Set<CronvoyProvider> providers = new LinkedHashSet<>();
    addCronvoyProviderImplByClassName(context, NATIVE_CRONVOY_PROVIDER_CLASS, providers, false);
    return Collections.unmodifiableList(new ArrayList<>(providers));
  }

  /**
   * Attempts to add a new provider referenced by the class name to a set.
   *
   * @param className the class name of the provider that should be instantiated.
   * @param providers the set of providers to add the new provider to.
   * @return {@code true} if the provider was added to the set; {@code false} if the provider
   *     couldn't be instantiated.
   */
  private static boolean addCronvoyProviderImplByClassName(Context context, String className,
                                                           Set<CronvoyProvider> providers,
                                                           boolean logError) {
    ClassLoader loader = context.getClassLoader();
    try {
      Class<? extends CronvoyProvider> providerClass =
          loader.loadClass(className).asSubclass(CronvoyProvider.class);
      Constructor<? extends CronvoyProvider> ctor = providerClass.getConstructor(Context.class);
      providers.add(ctor.newInstance(context));
      return true;
    } catch (InstantiationException e) {
      logReflectiveOperationException(className, logError, e);
    } catch (InvocationTargetException e) {
      logReflectiveOperationException(className, logError, e);
    } catch (NoSuchMethodException e) {
      logReflectiveOperationException(className, logError, e);
    } catch (IllegalAccessException e) {
      logReflectiveOperationException(className, logError, e);
    } catch (ClassNotFoundException e) {
      logReflectiveOperationException(className, logError, e);
    }
    return false;
  }

  /**
   * De-duplicates exception handling logic in {@link #addCronvoyProviderImplByClassName}. It should
   * be removed when support of API Levels lower than 19 is deprecated.
   */
  private static void logReflectiveOperationException(String className, boolean logError,
                                                      Exception e) {
    if (logError) {
      Log.e(TAG, "Unable to load provider class: " + className, e);
    } else {
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, "Tried to load " + className + " provider class but it wasn't"
                       + " included in the app classpath");
      }
    }
  }
}
package org.chromium.net;

/**
 * Exception passed to {@link UrlRequest.Callback#onFailed UrlRequest.Callback.onFailed()} when
 * {@link UrlRequest.Callback} or {@link UploadDataProvider} method throws an exception. In this
 * case {@link java.io.IOException#getCause getCause()} can be used to find the thrown exception.
 */
public abstract class CallbackException extends CronetException {
  /**
   * Constructs an exception that wraps {@code cause} thrown by a {@link UrlRequest.Callback}.
   *
   * @param message explanation of failure.
   * @param cause exception thrown by {@link UrlRequest.Callback} that's being wrapped. It is saved
   *     for later retrieval by the {@link java.io.IOException#getCause getCause()}.
   */
  protected CallbackException(String message, Throwable cause) { super(message, cause); }
}
package org.chromium.net;

import java.util.concurrent.Executor;

/**
 * {@link UrlRequest} that exposes experimental features. To obtain an instance of this class, cast
 * a {@code UrlRequest} to this type. Every instance of {@code UrlRequest} can be cast to an
 * instance of this class, as they are backed by the same implementation and hence perform
 * identically. Instances of this class are not meant for general use, but instead only to access
 * experimental features. Experimental features may be deprecated in the future. Use at your own
 * risk.
 *
 * <p>{@hide since this class exposes experimental features that should be hidden}.
 */
public abstract class ExperimentalUrlRequest extends UrlRequest {
  /**
   * {@link UrlRequest#Builder} that exposes experimental features. To obtain an instance of this
   * class, cast a {@code UrlRequest.Builder} to this type. Every instance of {@code
   * UrlRequest.Builder} can be cast to an instance of this class, as they are backed by the same
   * implementation and hence perform identically. Instances of this class are not meant for general
   * use, but instead only to access experimental features. Experimental features may be deprecated
   * in the future. Use at your own risk.
   */
  public abstract static class Builder extends UrlRequest.Builder {
    /**
     * Disables connection migration for the request if enabled for the session.
     *
     * @return the builder to facilitate chaining.
     */
    public Builder disableConnectionMigration() { return this; }

    /**
     * Associates the annotation object with this request. May add more than one. Passed through to
     * a {@link RequestFinishedInfo.Listener}, see {@link RequestFinishedInfo#getAnnotations}.
     *
     * @param annotation an object to pass on to the {@link RequestFinishedInfo.Listener} with a
     *     {@link RequestFinishedInfo}.
     * @return the builder to facilitate chaining.
     */
    public Builder addRequestAnnotation(Object annotation) { return this; }

    /**
     * Sets {@link android.net.TrafficStats} tag to use when accounting socket traffic caused by
     * this request. See {@link android.net.TrafficStats} for more information. If no tag is set
     * (e.g. this method isn't called), then Android accounts for the socket traffic caused by this
     * request as if the tag value were set to 0.
     *
     * <p><b>NOTE:</b>Setting a tag disallows sharing of sockets with requests with other tags,
     * which may adversely effect performance by prohibiting connection sharing. In other words use
     * of multiplexed sockets (e.g. HTTP/2 and QUIC) will only be allowed if all requests have the
     * same socket tag.
     *
     * @param tag the tag value used to when accounting for socket traffic caused by this request.
     *     Tags between 0xFFFFFF00 and 0xFFFFFFFF are reserved and used internally by system
     *     services like {@link android.app.DownloadManager} when performing traffic on behalf of an
     *     application.
     * @return the builder to facilitate chaining.
     */
    public Builder setTrafficStatsTag(int tag) { return this; }

    /**
     * Sets specific UID to use when accounting socket traffic caused by this request. See {@link
     * android.net.TrafficStats} for more information. Designed for use when performing an operation
     * on behalf of another application. Caller must hold {@link
     * android.Manifest.permission#MODIFY_NETWORK_ACCOUNTING} permission. By default traffic is
     * attributed to UID of caller.
     *
     * <p><b>NOTE:</b>Setting a UID disallows sharing of sockets with requests with other UIDs,
     * which may adversely effect performance by prohibiting connection sharing. In other words use
     * of multiplexed sockets (e.g. HTTP/2 and QUIC) will only be allowed if all requests have the
     * same UID set.
     *
     * @param uid the UID to attribute socket traffic caused by this request.
     * @return the builder to facilitate chaining.
     */
    public Builder setTrafficStatsUid(int uid) { return this; }

    /**
     * Sets a listener that gets invoked after {@link Callback#onCanceled onCanceled()}, {@link
     * Callback#onFailed onFailed()} or {@link Callback#onSucceeded onSucceeded()} return.
     *
     * <p>The listener is invoked with the request finished info on an {@link
     * java.util.concurrent.Executor} provided by {@link RequestFinishedInfo.Listener#getExecutor
     * getExecutor()}.
     *
     * @param listener the listener for finished requests.
     * @return the builder to facilitate chaining.
     */
    public Builder setRequestFinishedListener(RequestFinishedInfo.Listener listener) {
      return this;
    }

    /**
     * Default request idempotency, only enable 0-RTT for safe HTTP methods. Passed to {@link
     * #setIdempotency}.
     */
    public static final int DEFAULT_IDEMPOTENCY = 0;

    /** Request is idempotent. Passed to {@link #setIdempotency}. */
    public static final int IDEMPOTENT = 1;

    /** Request is not idempotent. Passed to {@link #setIdempotency}. */
    public static final int NOT_IDEMPOTENT = 2;

    /**
     * Sets idempotency of the request which should be one of the {@link #DEFAULT_IDEMPOTENCY
     * IDEMPOTENT NOT_IDEMPOTENT} values. The default idempotency indicates that 0-RTT is only
     * enabled for safe HTTP methods (GET, HEAD, OPTIONS, and TRACE).
     *
     * @param idempotency idempotency of the request which should be one of the {@link
     *     #DEFAULT_IDEMPOTENCY IDEMPOTENT NOT_IDEMPOTENT} values.
     * @return the builder to facilitate chaining.
     */
    public Builder setIdempotency(int idempotency) { return this; }

    // To support method chaining, override superclass methods to return an
    // instance of this class instead of the parent.

    @Override public abstract Builder setHttpMethod(String method);

    @Override public abstract Builder addHeader(String header, String value);

    @Override public abstract Builder disableCache();

    @Override public abstract Builder setPriority(int priority);

    @Override
    public abstract Builder setUploadDataProvider(UploadDataProvider uploadDataProvider,
                                                  Executor executor);

    @Override public abstract Builder allowDirectExecutor();

    @Override public abstract ExperimentalUrlRequest build();
  }
}
package org.chromium.net;

import java.util.concurrent.RejectedExecutionException;

/**
 * Thrown when an executor runs a submitted runnable inline in {@link
 * java.util.concurrent.Executor#execute(Runnable)} and {@link
 * UrlRequest.Builder#allowDirectExecutor} was not called.
 */
public final class InlineExecutionProhibitedException extends RejectedExecutionException {
  public InlineExecutionProhibitedException() {
    super("Inline execution is prohibited for this request");
  }
}
package org.chromium.net;

import androidx.annotation.IntDef;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@IntDef({EffectiveConnectionType.TYPE_UNKNOWN, EffectiveConnectionType.TYPE_OFFLINE,
         EffectiveConnectionType.TYPE_SLOW_2G, EffectiveConnectionType.TYPE_2G,
         EffectiveConnectionType.TYPE_3G, EffectiveConnectionType.TYPE_4G,
         EffectiveConnectionType.TYPE_LAST})
@Retention(RetentionPolicy.SOURCE)
public @interface EffectiveConnectionType {
  /** Effective connection type reported when the network quality is unknown. */
  int TYPE_UNKNOWN = 0;
  /**
   * Effective connection type reported when the Internet is unreachable because the device does not
   * have a connection (as reported by underlying platform APIs). Note that due to rare but
   * potential bugs in the platform APIs, it is possible that effective connection type is reported
   * as TYPE_OFFLINE. Callers must use caution when using acting on this.
   */
  int TYPE_OFFLINE = 1;
  /**
   * Effective connection type reported when the network has the quality of a poor 2G connection.
   */
  int TYPE_SLOW_2G = 2;
  /**
   * Effective connection type reported when the network has the quality of a faster 2G connection.
   */
  int TYPE_2G = 3;
  /** Effective connection type reported when the network has the quality of a 3G connection. */
  int TYPE_3G = 4;
  /** Effective connection type reported when the network has the quality of a 4G connection. */
  int TYPE_4G = 5;
  /** Last value of the effective connection type. This value is unused. */
  int TYPE_LAST = 6;
}
package org.chromium.net;

import java.util.Date;
import java.util.Set;

/**
 * Defines methods that the actual implementation of {@link CronetEngine.Builder} has to implement.
 * {@code CronetEngine.Builder} uses this interface to delegate the calls. For the documentation of
 * individual methods, please see the identically named methods in {@link
 * org.chromium.net.CronetEngine.Builder} and {@link
 * org.chromium.net.ExperimentalCronetEngine.Builder}.
 *
 * <p>{@hide internal class}
 */
public abstract class ICronetEngineBuilder {
  // Public API methods.
  public abstract ICronetEngineBuilder addPublicKeyPins(String hostName, Set<byte[]> pinsSha256,
                                                        boolean includeSubdomains,
                                                        Date expirationDate);

  public abstract ICronetEngineBuilder addQuicHint(String host, int port, int alternatePort);

  public abstract ICronetEngineBuilder enableHttp2(boolean value);

  public abstract ICronetEngineBuilder enableHttpCache(int cacheMode, long maxSize);

  public abstract ICronetEngineBuilder
  enablePublicKeyPinningBypassForLocalTrustAnchors(boolean value);

  public abstract ICronetEngineBuilder enableQuic(boolean value);

  public abstract ICronetEngineBuilder enableSdch(boolean value);

  public ICronetEngineBuilder enableBrotli(boolean value) {
    // Do nothing for older implementations.
    return this;
  }

  public abstract ICronetEngineBuilder setExperimentalOptions(String options);

  public abstract ICronetEngineBuilder setLibraryLoader(CronetEngine.Builder.LibraryLoader loader);

  public abstract ICronetEngineBuilder setStoragePath(String value);

  public abstract ICronetEngineBuilder setUserAgent(String userAgent);

  public abstract String getDefaultUserAgent();

  public abstract ExperimentalCronetEngine build();

  // Experimental API methods.
  //
  // Note: all experimental API methods should have default implementation. This will allow
  // removing the experimental methods from the implementation layer without breaking
  // the client.

  public ICronetEngineBuilder enableNetworkQualityEstimator(boolean value) { return this; }

  public ICronetEngineBuilder setThreadPriority(int priority) { return this; }
}
package org.chromium.net;

import android.os.ParcelFileDescriptor;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

/** Provides implementations of {@link UploadDataProvider} for common use cases. */
public final class UploadDataProviders {
  /**
   * Uploads an entire file.
   *
   * @param file The file to upload
   * @return A new UploadDataProvider for the given file
   */
  public static UploadDataProvider create(final File file) {
    return new FileUploadProvider(new FileChannelProvider() {
      @Override
      public FileChannel getChannel() throws IOException {
        return new FileInputStream(file).getChannel();
      }
    });
  }

  /**
   * Uploads an entire file, closing the descriptor when it is no longer needed.
   *
   * @param fd The file descriptor to upload
   * @throws IllegalArgumentException if {@code fd} is not a file.
   * @return A new UploadDataProvider for the given file descriptor
   */
  public static UploadDataProvider create(final ParcelFileDescriptor fd) {
    return new FileUploadProvider(new FileChannelProvider() {
      @Override
      public FileChannel getChannel() throws IOException {
        if (fd.getStatSize() != -1) {
          return new ParcelFileDescriptor.AutoCloseInputStream(fd).getChannel();
        } else {
          fd.close();
          throw new IllegalArgumentException("Not a file: " + fd);
        }
      }
    });
  }

  /**
   * Uploads a ByteBuffer, from the current {@code buffer.position()} to {@code buffer.limit()}
   *
   * @param buffer The data to upload
   * @return A new UploadDataProvider for the given buffer
   */
  public static UploadDataProvider create(ByteBuffer buffer) {
    return new ByteBufferUploadProvider(buffer.slice());
  }

  /**
   * Uploads {@code length} bytes from {@code data}, starting from {@code offset}
   *
   * @param data Array containing data to upload
   * @param offset Offset within data to start with
   * @param length Number of bytes to upload
   * @return A new UploadDataProvider for the given data
   */
  public static UploadDataProvider create(byte[] data, int offset, int length) {
    return new ByteBufferUploadProvider(ByteBuffer.wrap(data, offset, length).slice());
  }

  /**
   * Uploads the contents of {@code data}
   *
   * @param data Array containing data to upload
   * @return A new UploadDataProvider for the given data
   */
  public static UploadDataProvider create(byte[] data) { return create(data, 0, data.length); }

  private interface FileChannelProvider {
    FileChannel getChannel() throws IOException;
  }

  private static final class FileUploadProvider extends UploadDataProvider {
    private volatile FileChannel mChannel;
    private final FileChannelProvider mProvider;
    /** Guards initialization of {@code mChannel} */
    private final Object mLock = new Object();

    private FileUploadProvider(FileChannelProvider provider) { this.mProvider = provider; }

    @Override
    public long getLength() throws IOException {
      return getChannel().size();
    }

    @Override
    public void read(UploadDataSink uploadDataSink, ByteBuffer byteBuffer) throws IOException {
      if (!byteBuffer.hasRemaining()) {
        throw new IllegalStateException("Cronet passed a buffer with no bytes remaining");
      }
      FileChannel channel = getChannel();
      int bytesRead = 0;
      while (bytesRead == 0) {
        int read = channel.read(byteBuffer);
        if (read == -1) {
          break;
        } else {
          bytesRead += read;
        }
      }
      uploadDataSink.onReadSucceeded(false);
    }

    @Override
    public void rewind(UploadDataSink uploadDataSink) throws IOException {
      getChannel().position(0);
      uploadDataSink.onRewindSucceeded();
    }

    /**
     * Lazily initializes the channel so that a blocking operation isn't performed on a non-executor
     * thread.
     */
    private FileChannel getChannel() throws IOException {
      if (mChannel == null) {
        synchronized (mLock) {
          if (mChannel == null) {
            mChannel = mProvider.getChannel();
          }
        }
      }
      return mChannel;
    }

    @Override
    public void close() throws IOException {
      FileChannel channel = mChannel;
      if (channel != null) {
        channel.close();
      }
    }
  }

  private static final class ByteBufferUploadProvider extends UploadDataProvider {
    private final ByteBuffer mUploadBuffer;

    private ByteBufferUploadProvider(ByteBuffer uploadBuffer) { this.mUploadBuffer = uploadBuffer; }

    @Override
    public long getLength() {
      return mUploadBuffer.limit();
    }

    @Override
    public void read(UploadDataSink uploadDataSink, ByteBuffer byteBuffer) {
      if (!byteBuffer.hasRemaining()) {
        throw new IllegalStateException("Cronet passed a buffer with no bytes remaining");
      }
      if (byteBuffer.remaining() >= mUploadBuffer.remaining()) {
        byteBuffer.put(mUploadBuffer);
      } else {
        int oldLimit = mUploadBuffer.limit();
        mUploadBuffer.limit(mUploadBuffer.position() + byteBuffer.remaining());
        byteBuffer.put(mUploadBuffer);
        mUploadBuffer.limit(oldLimit);
      }
      uploadDataSink.onReadSucceeded(false);
    }

    @Override
    public void rewind(UploadDataSink uploadDataSink) {
      mUploadBuffer.position(0);
      uploadDataSink.onRewindSucceeded();
    }
  }

  // Prevent instantiation
  private UploadDataProviders() {}
}
package org.chromium.net;

import androidx.annotation.IntDef;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@IntDef({NetworkQualityObservationSource.HTTP, NetworkQualityObservationSource.TCP,
         NetworkQualityObservationSource.QUIC, NetworkQualityObservationSource.HTTP_CACHED_ESTIMATE,
         NetworkQualityObservationSource.DEFAULT_HTTP_FROM_PLATFORM,
         NetworkQualityObservationSource.DEPRECATED_HTTP_EXTERNAL_ESTIMATE,
         NetworkQualityObservationSource.TRANSPORT_CACHED_ESTIMATE,
         NetworkQualityObservationSource.DEFAULT_TRANSPORT_FROM_PLATFORM,
         NetworkQualityObservationSource.H2_PINGS, NetworkQualityObservationSource.MAX})
@Retention(RetentionPolicy.SOURCE)
public @interface NetworkQualityObservationSource {
  /**
   * The observation was taken at the request layer, e.g., a round trip time is recorded as the time
   * between the request being sent and the first byte being received.
   */
  int HTTP = 0;
  /** The observation is taken from TCP statistics maintained by the kernel. */
  int TCP = 1;
  /** The observation is taken at the QUIC layer. */
  int QUIC = 2;
  /**
   * The observation is a previously cached estimate of the metric. The metric was computed at the
   * HTTP layer.
   */
  int HTTP_CACHED_ESTIMATE = 3;
  /**
   * The observation is derived from network connection information provided by the platform. For
   * example, typical RTT and throughput values are used for a given type of network connection. The
   * metric was provided for use at the HTTP layer.
   */
  int DEFAULT_HTTP_FROM_PLATFORM = 4;
  /**
   * The observation came from a Chromium-external source. The metric was computed by the external
   * source at the HTTP layer. Deprecated since external estimate provider is not currently queried.
   */
  int DEPRECATED_HTTP_EXTERNAL_ESTIMATE = 5;
  /**
   * The observation is a previously cached estimate of the metric. The metric was computed at the
   * transport layer.
   */
  int TRANSPORT_CACHED_ESTIMATE = 6;
  /**
   * The observation is derived from the network connection information provided by the platform.
   * For example, typical RTT and throughput values are used for a given type of network connection.
   * The metric was provided for use at the transport layer.
   */
  int DEFAULT_TRANSPORT_FROM_PLATFORM = 7;
  /** Round trip ping latency reported by H2 connections. */
  int H2_PINGS = 8;

  int MAX = 9;
}
package org.chromium.net;

import android.content.Context;
import android.net.http.HttpResponseCache;
import android.util.Log;
import androidx.annotation.VisibleForTesting;
import java.io.IOException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLStreamHandlerFactory;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Executor;
import javax.net.ssl.HttpsURLConnection;

/**
 * An engine to process {@link UrlRequest}s, which uses the best HTTP stack available on the current
 * platform. An instance of this class can be created using {@link Builder}.
 */
public abstract class CronetEngine {
  private static final String TAG = CronetEngine.class.getSimpleName();

  /**
   * A builder for {@link CronetEngine}s, which allows runtime configuration of {@code
   * CronetEngine}. Configuration options are set on the builder and then {@link #build} is called
   * to create the {@code CronetEngine}.
   */
  // NOTE(kapishnikov): In order to avoid breaking the existing API clients, all future methods
  // added to this class and other API classes must have default implementation.
  public static class Builder {
    /**
     * A class which provides a method for loading the cronet native library. Apps needing to
     * implement custom library loading logic can inherit from this class and pass an instance to
     * {@link CronetEngine.Builder#setLibraryLoader}. For example, this might be required to work
     * around {@code UnsatisfiedLinkError}s caused by flaky installation on certain older devices.
     */
    public abstract static class LibraryLoader {
      /**
       * Loads the native library.
       *
       * @param libName name of the library to load
       */
      public abstract void loadLibrary(String libName);
    }

    /** Reference to the actual builder implementation. {@hide exclude from JavaDoc}. */
    protected final ICronetEngineBuilder mBuilderDelegate;

    /**
     * Constructs a {@link Builder} object that facilitates creating a {@link CronetEngine}. The
     * default configuration enables HTTP/2 and QUIC, but disables the HTTP cache.
     *
     * @param context Android {@link Context}, which is used by {@link Builder} to retrieve the
     *     application context. A reference to only the application context will be kept, so as to
     *     avoid extending the lifetime of {@code context} unnecessarily.
     */
    public Builder(Context context) { this(createBuilderDelegate(context)); }

    /**
     * Constructs {@link Builder} with a given delegate that provides the actual implementation of
     * the {@code Builder} methods. This constructor is used only by the internal implementation.
     *
     * @param builderDelegate delegate that provides the actual implementation.
     *     <p>{@hide}
     */
    public Builder(ICronetEngineBuilder builderDelegate) { mBuilderDelegate = builderDelegate; }

    /**
     * Constructs a User-Agent string including application name and version, system build version,
     * model and id, and Cronet version.
     *
     * @return User-Agent string.
     */
    public String getDefaultUserAgent() { return mBuilderDelegate.getDefaultUserAgent(); }

    /**
     * Overrides the User-Agent header for all requests. An explicitly set User-Agent header (set
     * using {@link UrlRequest.Builder#addHeader}) will override a value set using this function.
     *
     * @param userAgent the User-Agent string to use for all requests.
     * @return the builder to facilitate chaining.
     */
    public Builder setUserAgent(String userAgent) {
      mBuilderDelegate.setUserAgent(userAgent);
      return this;
    }

    /**
     * Sets directory for HTTP Cache and Cookie Storage. The directory must exist.
     *
     * <p><b>NOTE:</b> Do not use the same storage directory with more than one {@code CronetEngine}
     * at a time. Access to the storage directory does not support concurrent access by multiple
     * {@code CronetEngine}s.
     *
     * @param value path to existing directory.
     * @return the builder to facilitate chaining.
     */
    public Builder setStoragePath(String value) {
      mBuilderDelegate.setStoragePath(value);
      return this;
    }

    /**
     * Sets a {@link LibraryLoader} to be used to load the native library. If not set, the library
     * will be loaded using {@link System#loadLibrary}.
     *
     * @param loader {@code LibraryLoader} to be used to load the native library.
     * @return the builder to facilitate chaining.
     */
    public Builder setLibraryLoader(LibraryLoader loader) {
      mBuilderDelegate.setLibraryLoader(loader);
      return this;
    }

    /**
     * Sets whether <a href="https://www.chromium.org/quic">QUIC</a> protocol is enabled. Defaults
     * to enabled. If QUIC is enabled, then QUIC User Agent Id containing application name and
     * Cronet version is sent to the server.
     *
     * @param value {@code true} to enable QUIC, {@code false} to disable.
     * @return the builder to facilitate chaining.
     */
    public Builder enableQuic(boolean value) {
      mBuilderDelegate.enableQuic(value);
      return this;
    }

    /**
     * Sets whether <a href="https://tools.ietf.org/html/rfc7540">HTTP/2</a> protocol is enabled.
     * Defaults to enabled.
     *
     * @param value {@code true} to enable HTTP/2, {@code false} to disable.
     * @return the builder to facilitate chaining.
     */
    public Builder enableHttp2(boolean value) {
      mBuilderDelegate.enableHttp2(value);
      return this;
    }

    /**
     * @deprecated SDCH is deprecated in Cronet M63. This method is a no-op. {@hide exclude from
     *     JavaDoc}.
     */
    @Deprecated
    public Builder enableSdch(boolean value) {
      return this;
    }

    /**
     * Sets whether <a href="https://tools.ietf.org/html/rfc7932">Brotli</a> compression is enabled.
     * If enabled, Brotli will be advertised in Accept-Encoding request headers. Defaults to
     * disabled.
     *
     * @param value {@code true} to enable Brotli, {@code false} to disable.
     * @return the builder to facilitate chaining.
     */
    public Builder enableBrotli(boolean value) {
      mBuilderDelegate.enableBrotli(value);
      return this;
    }

    /**
     * Setting to disable HTTP cache. Some data may still be temporarily stored in memory. Passed to
     * {@link #enableHttpCache}.
     */
    public static final int HTTP_CACHE_DISABLED = 0;

    /**
     * Setting to enable in-memory HTTP cache, including HTTP data. Passed to {@link
     * #enableHttpCache}.
     */
    public static final int HTTP_CACHE_IN_MEMORY = 1;

    /**
     * Setting to enable on-disk cache, excluding HTTP data. {@link #setStoragePath} must be called
     * prior to passing this constant to {@link #enableHttpCache}.
     */
    public static final int HTTP_CACHE_DISK_NO_HTTP = 2;

    /**
     * Setting to enable on-disk cache, including HTTP data. {@link #setStoragePath} must be called
     * prior to passing this constant to {@link #enableHttpCache}.
     */
    public static final int HTTP_CACHE_DISK = 3;

    /**
     * Enables or disables caching of HTTP data and other information like QUIC server information.
     *
     * @param cacheMode control location and type of cached data. Must be one of {@link
     *     #HTTP_CACHE_DISABLED HTTP_CACHE_*}.
     * @param maxSize maximum size in bytes used to cache data (advisory and maybe exceeded at
     *     times).
     * @return the builder to facilitate chaining.
     */
    public Builder enableHttpCache(int cacheMode, long maxSize) {
      mBuilderDelegate.enableHttpCache(cacheMode, maxSize);
      return this;
    }

    /**
     * Adds hint that {@code host} supports QUIC. Note that {@link #enableHttpCache enableHttpCache}
     * ({@link #HTTP_CACHE_DISK}) is needed to take advantage of 0-RTT connection establishment
     * between sessions.
     *
     * @param host hostname of the server that supports QUIC.
     * @param port host of the server that supports QUIC.
     * @param alternatePort alternate port to use for QUIC.
     * @return the builder to facilitate chaining.
     */
    public Builder addQuicHint(String host, int port, int alternatePort) {
      mBuilderDelegate.addQuicHint(host, port, alternatePort);
      return this;
    }

    /**
     * Pins a set of public keys for a given host. By pinning a set of public keys, {@code
     * pinsSha256}, communication with {@code hostName} is required to authenticate with a
     * certificate with a public key from the set of pinned ones. An app can pin the public key of
     * the root certificate, any of the intermediate certificates or the end-entry certificate.
     * Authentication will fail and secure communication will not be established if none of the
     * public keys is present in the host's certificate chain, even if the host attempts to
     * authenticate with a certificate allowed by the device's trusted store of certificates.
     *
     * <p>Calling this method multiple times with the same host name overrides the previously set
     * pins for the host.
     *
     * <p>More information about the public key pinning can be found in <a
     * href="https://tools.ietf.org/html/rfc7469">RFC 7469</a>.
     *
     * @param hostName name of the host to which the public keys should be pinned. A host that
     *     consists only of digits and the dot character is treated as invalid.
     * @param pinsSha256 a set of pins. Each pin is the SHA-256 cryptographic hash of the
     *     DER-encoded ASN.1 representation of the Subject Public Key Info (SPKI) of the host's
     *     X.509 certificate. Use {@link java.security.cert.Certificate#getPublicKey()
     *     Certificate.getPublicKey()} and {@link java.security.Key#getEncoded() Key.getEncoded()}
     *     to obtain DER-encoded ASN.1 representation of the SPKI. Although, the method does not
     *     mandate the presence of the backup pin that can be used if the control of the primary
     *     private key has been lost, it is highly recommended to supply one.
     * @param includeSubdomains indicates whether the pinning policy should be applied to subdomains
     *     of {@code hostName}.
     * @param expirationDate specifies the expiration date for the pins.
     * @return the builder to facilitate chaining.
     * @throws NullPointerException if any of the input parameters are {@code null}.
     * @throws IllegalArgumentException if the given host name is invalid or {@code pinsSha256}
     *     contains a byte array that does not represent a valid SHA-256 hash.
     */
    public Builder addPublicKeyPins(String hostName, Set<byte[]> pinsSha256,
                                    boolean includeSubdomains, Date expirationDate) {
      mBuilderDelegate.addPublicKeyPins(hostName, pinsSha256, includeSubdomains, expirationDate);
      return this;
    }

    /**
     * Enables or disables public key pinning bypass for local trust anchors. Disabling the bypass
     * for local trust anchors is highly discouraged since it may prohibit the app from
     * communicating with the pinned hosts. E.g., a user may want to send all traffic through an SSL
     * enabled proxy by changing the device proxy settings and adding the proxy certificate to the
     * list of local trust anchor. Disabling the bypass will most likely prevent the app from
     * sending any traffic to the pinned hosts. For more information see 'How does key pinning
     * interact with local proxies and filters?' at
     * https://www.chromium.org/Home/chromium-security/security-faq
     *
     * @param value {@code true} to enable the bypass, {@code false} to disable.
     * @return the builder to facilitate chaining.
     */
    public Builder enablePublicKeyPinningBypassForLocalTrustAnchors(boolean value) {
      mBuilderDelegate.enablePublicKeyPinningBypassForLocalTrustAnchors(value);
      return this;
    }

    /**
     * Build a {@link CronetEngine} using this builder's configuration.
     *
     * @return constructed {@link CronetEngine}.
     */
    public CronetEngine build() { return mBuilderDelegate.build(); }

    /**
     * Creates an implementation of {@link ICronetEngineBuilder} that can be used to delegate the
     * builder calls to. The method uses {@link CronvoyProvider} to obtain the list of available
     * providers.
     *
     * @param context Android Context to use.
     * @return the created {@code ICronetEngineBuilder}.
     */
    private static ICronetEngineBuilder createBuilderDelegate(Context context) {
      List<CronvoyProvider> providers = new ArrayList<>(CronvoyProvider.getAllProviders(context));
      CronvoyProvider provider = getEnabledCronvoyProviders(context, providers).get(0);
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG,
              String.format("Using '%s' provider for creating CronetEngine.Builder.", provider));
      }
      return provider.createBuilder().mBuilderDelegate;
    }

    /**
     * Returns the list of available and enabled {@link CronvoyProvider}. The returned list is
     * sorted based on the provider versions and types.
     *
     * @param context Android Context to use.
     * @param providers the list of enabled and disabled providers to filter out and sort.
     * @return the sorted list of enabled providers. The list contains at least one provider.
     * @throws RuntimeException is the list of providers is empty or all of the providers are
     *     disabled.
     */
    @VisibleForTesting
    static List<CronvoyProvider> getEnabledCronvoyProviders(Context context,
                                                            List<CronvoyProvider> providers) {
      // Check that there is at least one available provider.
      if (providers.size() == 0) {
        throw new RuntimeException("Unable to find any Cronet provider."
                                   + " Have you included all necessary jars?");
      }

      // Exclude disabled providers from the list.
      for (Iterator<CronvoyProvider> i = providers.iterator(); i.hasNext();) {
        CronvoyProvider provider = i.next();
        if (!provider.isEnabled()) {
          i.remove();
        }
      }

      // Check that there is at least one enabled provider.
      if (providers.size() == 0) {
        throw new RuntimeException("All available Cronet providers are disabled."
                                   + " A provider should be enabled before it can be used.");
      }

      // Sort providers based on version and type.
      Collections.sort(providers, new Comparator<CronvoyProvider>() {
        @Override
        public int compare(CronvoyProvider p1, CronvoyProvider p2) {
          // The fallback provider should always be at the end of the list.
          if (CronvoyProvider.PROVIDER_NAME_FALLBACK.equals(p1.getName())) {
            return 1;
          }
          if (CronvoyProvider.PROVIDER_NAME_FALLBACK.equals(p2.getName())) {
            return -1;
          }
          // A provider with higher version should go first.
          return -compareVersions(p1.getVersion(), p2.getVersion());
        }
      });
      return providers;
    }

    /**
     * Compares two strings that contain versions. The string should only contain dot-separated
     * segments that contain an arbitrary number of digits digits [0-9].
     *
     * @param s1 the first string.
     * @param s2 the second string.
     * @return -1 if s1<s2, +1 if s1>s2 and 0 if s1=s2. If two versions are equal, the version with
     *     the higher number of segments is considered to be higher.
     * @throws IllegalArgumentException if any of the strings contains an illegal version number.
     */
    @VisibleForTesting
    static int compareVersions(String s1, String s2) {
      if (s1 == null || s2 == null) {
        throw new IllegalArgumentException("The input values cannot be null");
      }
      String[] s1segments = s1.split("\\.");
      String[] s2segments = s2.split("\\.");
      for (int i = 0; i < s1segments.length && i < s2segments.length; i++) {
        try {
          int s1segment = Integer.parseInt(s1segments[i]);
          int s2segment = Integer.parseInt(s2segments[i]);
          if (s1segment != s2segment) {
            return Integer.signum(s1segment - s2segment);
          }
        } catch (NumberFormatException e) {
          throw new IllegalArgumentException("Unable to convert version segments into"
                                                 + " integers: " + s1segments[i] + " & " +
                                                 s2segments[i],
                                             e);
        }
      }
      return Integer.signum(s1segments.length - s2segments.length);
    }
  }

  /** @return a human-readable version string of the engine. */
  public abstract String getVersionString();

  /**
   * Shuts down the {@link CronetEngine} if there are no active requests, otherwise throws an
   * exception.
   *
   * <p>Cannot be called on network thread - the thread Cronet calls into Executor on (which is
   * different from the thread the Executor invokes callbacks on). May block until all the {@code
   * CronetEngine}'s resources have been cleaned up.
   */
  public abstract void shutdown();

  /**
   * Starts NetLog logging to a file. The NetLog will contain events emitted by all live
   * CronetEngines. The NetLog is useful for debugging. The file can be viewed using a Chrome
   * browser navigated to chrome://net-internals/#import
   *
   * @param fileName the complete file path. It must not be empty. If the file exists, it is
   *     truncated before starting. If actively logging, this method is ignored.
   * @param logAll {@code true} to include basic events, user cookies, credentials and all
   *     transferred bytes in the log. This option presents a privacy risk, since it exposes the
   *     user's credentials, and should only be used with the user's consent and in situations where
   *     the log won't be public. {@code false} to just include basic events.
   */
  public abstract void startNetLogToFile(String fileName, boolean logAll);

  /**
   * Stops NetLog logging and flushes file to disk. If a logging session is not in progress, this
   * call is ignored.
   */
  public abstract void stopNetLog();

  /**
   * Returns differences in metrics collected by Cronet since the last call to this method.
   *
   * <p>Cronet collects these metrics globally. This means deltas returned by {@code
   * getGlobalMetricsDeltas()} will include measurements of requests processed by other {@link
   * CronetEngine} instances. Since this function returns differences in metrics collected since the
   * last call, and these metrics are collected globally, a call to any {@code CronetEngine}
   * instance's {@code getGlobalMetricsDeltas()} method will affect the deltas returned by any other
   * {@code CronetEngine} instance's {@code getGlobalMetricsDeltas()}.
   *
   * <p>Cronet starts collecting these metrics after the first call to {@code
   * getGlobalMetricsDeltras()}, so the first call returns no useful data as no metrics have yet
   * been collected.
   *
   * @return differences in metrics collected by Cronet, since the last call to {@code
   *     getGlobalMetricsDeltas()}, serialized as a <a
   *     href=https://developers.google.com/protocol-buffers>protobuf </a>.
   */
  public abstract byte[] getGlobalMetricsDeltas();

  /**
   * Establishes a new connection to the resource specified by the {@link URL} {@code url}.
   *
   * <p><b>Note:</b> Cronet's {@link java.net.HttpURLConnection} implementation is subject to
   * certain limitations, see {@link #createURLStreamHandlerFactory} for details.
   *
   * @param url URL of resource to connect to.
   * @return an {@link java.net.HttpURLConnection} instance implemented by this CronetEngine.
   * @throws IOException if an error occurs while opening the connection.
   */
  public abstract URLConnection openConnection(URL url) throws IOException;

  /**
   * Creates a {@link URLStreamHandlerFactory} to handle HTTP and HTTPS traffic. An instance of this
   * class can be installed via {@link URL#setURLStreamHandlerFactory} thus using this CronetEngine
   * by default for all requests created via {@link URL#openConnection}.
   *
   * <p>Cronet does not use certain HTTP features provided via the system:
   *
   * <ul>
   *   <li>the HTTP cache installed via {@link HttpResponseCache#install(java.io.File, long)
   *       HttpResponseCache.install()}
   *   <li>the HTTP authentication method installed via {@link java.net.Authenticator#setDefault}
   *   <li>the HTTP cookie storage installed via {@link java.net.CookieHandler#setDefault}
   * </ul>
   *
   * <p>While Cronet supports and encourages requests using the HTTPS protocol, Cronet does not
   * provide support for the {@link HttpsURLConnection} API. This lack of support also includes not
   * using certain HTTPS features provided via the system:
   *
   * <ul>
   *   <li>the HTTPS hostname verifier installed via {@link
   *       HttpsURLConnection#setDefaultHostnameVerifier(javax.net.ssl.HostnameVerifier)
   *       HttpsURLConnection.setDefaultHostnameVerifier()}
   *   <li>the HTTPS socket factory installed via {@link
   *       HttpsURLConnection#setDefaultSSLSocketFactory(javax.net.ssl.SSLSocketFactory)
   *       HttpsURLConnection.setDefaultSSLSocketFactory()}
   * </ul>
   *
   * @return an {@link URLStreamHandlerFactory} instance implemented by this CronetEngine.
   */
  public abstract URLStreamHandlerFactory createURLStreamHandlerFactory();

  /**
   * Creates a builder for {@link UrlRequest}. All callbacks for generated {@link UrlRequest}
   * objects will be invoked on {@code executor}'s threads. {@code executor} must not run tasks on
   * the thread calling {@link Executor#execute} to prevent blocking networking operations and
   * causing exceptions during shutdown.
   *
   * @param url URL for the generated requests.
   * @param callback callback object that gets invoked on different events.
   * @param executor {@link Executor} on which all callbacks will be invoked.
   */
  public abstract UrlRequest.Builder newUrlRequestBuilder(String url, UrlRequest.Callback callback,
                                                          Executor executor);
}
load("@build_bazel_rules_android//android:rules.bzl", "android_library")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@rules_jvm_external//:defs.bzl", "artifact")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

# Cronet API fork

# Copy of the original Cronet API
android_library(
    name = "net",
    srcs = glob(["*.java"]),
    manifest = "ChromiumNetManifest.xml",
    visibility = ["//visibility:public"],
    deps = [
        "//library/java/io/envoyproxy/envoymobile/utilities",
        artifact("androidx.annotation:annotation"),
    ],
)

# A binary target that includes transitive dependencies.
# Use this target along with libenvoy_jni.so to integrate
# Cronvoy with Cronet-dependent apps.
android_binary(
    name = "cronet",
    srcs = [],
    manifest = "ChromiumNetManifest.xml",
    proguard_specs = ["//library:proguard_rules"],
    visibility = ["//visibility:public"],
    deps = [
        ":net",
        "//library/java/org/chromium/net/impl:cronvoy",
        artifact("com.google.protobuf:protobuf-javalite"),
    ],
)
package org.chromium.net;

import java.io.Closeable;
import java.io.IOException;
import java.nio.ByteBuffer;

/**
 * Abstract class allowing the embedder to provide an upload body to {@link UrlRequest}. It supports
 * both non-chunked (size known in advanced) and chunked (size not known in advance) uploads. Be
 * aware that not all servers support chunked uploads.
 *
 * <p>An upload is either always chunked, across multiple uploads if the data ends up being sent
 * more than once, or never chunked.
 */
public abstract class UploadDataProvider implements Closeable {
  /**
   * If this is a non-chunked upload, returns the length of the upload. Must always return -1 if
   * this is a chunked upload.
   *
   * @return the length of the upload for non-chunked uploads, -1 otherwise.
   * @throws IOException if any IOException occurred during the process.
   */
  public abstract long getLength() throws IOException;

  /**
   * Reads upload data into {@code byteBuffer}. Upon completion, the buffer's position is updated to
   * the end of the bytes that were read. The buffer's limit is not changed. Each call of this
   * method must be followed be a single call, either synchronous or asynchronous, to {@code
   * uploadDataSink}: {@link UploadDataSink#onReadSucceeded} on success or {@link
   * UploadDataSink#onReadError} on failure. Neither read nor rewind will be called until one of
   * those methods or the other is called. Even if the associated {@link UrlRequest} is canceled,
   * one or the other must still be called before resources can be safely freed. Throwing an
   * exception will also result in resources being freed and the request being errored out.
   *
   * @param uploadDataSink The object to notify when the read has completed, successfully or
   *     otherwise.
   * @param byteBuffer The buffer to copy the read bytes into. Do not change byteBuffer's limit.
   * @throws IOException if any IOException occurred during the process. {@link
   *     UrlRequest.Callback#onFailed} will be called with the thrown exception set as the cause of
   *     the {@link CallbackException}.
   */
  public abstract void read(UploadDataSink uploadDataSink, ByteBuffer byteBuffer)
      throws IOException;

  /**
   * Rewinds upload data. Each call must be followed be a single call, either synchronous or
   * asynchronous, to {@code uploadDataSink}: {@link UploadDataSink#onRewindSucceeded} on success or
   * {@link UploadDataSink#onRewindError} on failure. Neither read nor rewind will be called until
   * one of those methods or the other is called. Even if the associated {@link UrlRequest} is
   * canceled, one or the other must still be called before resources can be safely freed. Throwing
   * an exception will also result in resources being freed and the request being errored out.
   *
   * <p>If rewinding is not supported, this should call {@link UploadDataSink#onRewindError}. Note
   * that rewinding is required to follow redirects that preserve the upload body, and for retrying
   * when the server times out stale sockets.
   *
   * @param uploadDataSink The object to notify when the rewind operation has completed,
   *     successfully or otherwise.
   * @throws IOException if any IOException occurred during the process. {@link
   *     UrlRequest.Callback#onFailed} will be called with the thrown exception set as the cause of
   *     the {@link CallbackException}.
   */
  public abstract void rewind(UploadDataSink uploadDataSink) throws IOException;

  /**
   * Called when this UploadDataProvider is no longer needed by a request, so that resources (like a
   * file) can be explicitly released.
   *
   * @throws IOException if any IOException occurred during the process. This will cause the request
   *     to fail if it is not yet complete; otherwise it will be logged.
   */
  @Override
  public void close() throws IOException {}
}
package org.chromium.net;

import androidx.annotation.Nullable;
import java.util.Collection;
import java.util.Date;
import java.util.concurrent.Executor;

/**
 * Information about a finished request. Passed to {@link RequestFinishedInfo.Listener}.
 *
 * <p>To associate the data with the original request, use {@link
 * ExperimentalUrlRequest.Builder#addRequestAnnotation} or {@link
 * ExperimentalBidirectionalStream.Builder#addRequestAnnotation} to add a unique identifier when
 * creating the request, and call {@link #getAnnotations} when the {@link RequestFinishedInfo} is
 * received to retrieve the identifier.
 *
 * <p>{@hide} as it's a prototype.
 */
public abstract class RequestFinishedInfo {
  /**
   * Listens for finished requests for the purpose of collecting metrics.
   *
   * <p>{@hide} as it's a prototype.
   */
  public abstract static class Listener {
    private final Executor mExecutor;

    public Listener(Executor executor) {
      if (executor == null) {
        throw new IllegalStateException("Executor must not be null");
      }
      mExecutor = executor;
    }

    /**
     * Invoked with request info. Will be called in a task submitted to the {@link
     * java.util.concurrent.Executor} returned by {@link #getExecutor}.
     *
     * @param requestInfo {@link RequestFinishedInfo} for finished request.
     */
    public abstract void onRequestFinished(RequestFinishedInfo requestInfo);

    /**
     * Returns this listener's executor. Can be called on any thread.
     *
     * @return this listener's {@link java.util.concurrent.Executor}
     */
    public Executor getExecutor() { return mExecutor; }
  }

  /**
   * Metrics collected for a single request. Most of these metrics are timestamps for events during
   * the lifetime of the request, which can be used to build a detailed timeline for investigating
   * performance.
   *
   * <p>Events happen in this order:
   *
   * <ol>
   *   <li>{@link #getRequestStart request start}
   *   <li>{@link #getDnsStart DNS start}
   *   <li>{@link #getDnsEnd DNS end}
   *   <li>{@link #getConnectStart connect start}
   *   <li>{@link #getSslStart SSL start}
   *   <li>{@link #getSslEnd SSL end}
   *   <li>{@link #getConnectEnd connect end}
   *   <li>{@link #getSendingStart sending start}
   *   <li>{@link #getSendingEnd sending end}
   *   <li>{@link #getResponseStart response start}
   *   <li>{@link #getRequestEnd request end}
   * </ol>
   *
   * Start times are reported as the time when a request started blocking on event, not when the
   * event actually occurred, with the exception of push start and end. If a metric is not
   * meaningful or not available, including cases when a request finished before reaching that
   * stage, start and end times will be {@code null}. If no time was spent blocking on an event,
   * start and end will be the same time.
   *
   * <p>If the system clock is adjusted during the request, some of the {@link java.util.Date}
   * values might not match it. Timestamps are recorded using a clock that is guaranteed not to run
   * backwards. All timestamps are correct relative to the system clock at the time of request
   * start, and taking the difference between two timestamps will give the correct difference
   * between the events. In order to preserve this property, timestamps for events other than
   * request start are not guaranteed to match the system clock at the times they represent.
   *
   * <p>Most timing metrics are taken from <a
   * href="https://cs.chromium.org/chromium/src/net/base/load_timing_info.h">LoadTimingInfo</a>,
   * which holds the information for <a href="http://w3c.github.io/navigation-timing/"></a> and <a
   * href="https://www.w3.org/TR/resource-timing/"></a>.
   *
   * <p>{@hide} as it's a prototype.
   */
  public abstract static class Metrics {
    /**
     * Returns time when the request started.
     *
     * @return {@link java.util.Date} representing when the native request actually started. This
     *     timestamp will match the system clock at the time it represents.
     */
    @Nullable public abstract Date getRequestStart();

    /**
     * Returns time when DNS lookup started. This and {@link #getDnsEnd} will return non-null values
     * regardless of whether the result came from a DNS server or the local cache.
     *
     * @return {@link java.util.Date} representing when DNS lookup started. {@code null} if the
     *     socket was reused (see {@link #getSocketReused}).
     */
    @Nullable public abstract Date getDnsStart();

    /**
     * Returns time when DNS lookup finished. This and {@link #getDnsStart} will return non-null
     * values regardless of whether the result came from a DNS server or the local cache.
     *
     * @return {@link java.util.Date} representing when DNS lookup finished. {@code null} if the
     *     socket was reused (see {@link #getSocketReused}).
     */
    @Nullable public abstract Date getDnsEnd();

    /**
     * Returns time when connection establishment started.
     *
     * @return {@link java.util.Date} representing when connection establishment started, typically
     *     when DNS resolution finishes. {@code null} if the socket was reused (see {@link
     *     #getSocketReused}).
     */
    @Nullable public abstract Date getConnectStart();

    /**
     * Returns time when connection establishment finished.
     *
     * @return {@link java.util.Date} representing when connection establishment finished, after TCP
     *     connection is established and, if using HTTPS, SSL handshake is completed. For QUIC
     *     0-RTT, this represents the time of handshake confirmation and might happen later than
     *     {@link #getSendingStart}. {@code null} if the socket was reused (see {@link
     *     #getSocketReused}).
     */
    @Nullable public abstract Date getConnectEnd();

    /**
     * Returns time when SSL handshake started. For QUIC, this will be the same time as {@link
     * #getConnectStart}.
     *
     * @return {@link java.util.Date} representing when SSL handshake started. {@code null} if SSL
     *     is not used or if the socket was reused (see {@link #getSocketReused}).
     */
    @Nullable public abstract Date getSslStart();

    /**
     * Returns time when SSL handshake finished. For QUIC, this will be the same time as {@link
     * #getConnectEnd}.
     *
     * @return {@link java.util.Date} representing when SSL handshake finished. {@code null} if SSL
     *     is not used or if the socket was reused (see {@link #getSocketReused}).
     */
    @Nullable public abstract Date getSslEnd();

    /**
     * Returns time when sending the request started.
     *
     * @return {@link java.util.Date} representing when sending HTTP request headers started.
     */
    @Nullable public abstract Date getSendingStart();

    /**
     * Returns time when sending the request finished.
     *
     * @return {@link java.util.Date} representing when sending HTTP request body finished. (Sending
     *     request body happens after sending request headers.)
     */
    @Nullable public abstract Date getSendingEnd();

    /**
     * Returns time when first byte of HTTP/2 server push was received.
     *
     * @return {@link java.util.Date} representing when the first byte of an HTTP/2 server push was
     *     received. {@code null} if server push is not used.
     */
    @Nullable public abstract Date getPushStart();

    /**
     * Returns time when last byte of HTTP/2 server push was received.
     *
     * @return {@link java.util.Date} representing when the last byte of an HTTP/2 server push was
     *     received. {@code null} if server push is not used.
     */
    @Nullable public abstract Date getPushEnd();

    /**
     * Returns time when the end of the response headers was received.
     *
     * @return {@link java.util.Date} representing when the end of the response headers was
     *     received.
     */
    @Nullable public abstract Date getResponseStart();

    /**
     * Returns time when the request finished.
     *
     * @return {@link java.util.Date} representing when the request finished.
     */
    @Nullable public abstract Date getRequestEnd();

    /**
     * Returns whether the socket was reused from a previous request. In HTTP/2 or QUIC, if streams
     * are multiplexed in a single connection, returns {@code true} for all streams after the first.
     *
     * @return whether this request reused a socket from a previous request. When {@code true}, DNS,
     *     connection, and SSL times will be {@code null}.
     */
    public abstract boolean getSocketReused();

    /**
     * Returns milliseconds between request initiation and first byte of response headers, or {@code
     * null} if not collected. TODO(mgersh): Remove once new API works http://crbug.com/629194
     * {@hide}
     */
    @Nullable public abstract Long getTtfbMs();

    /**
     * Returns milliseconds between request initiation and finish, including a failure or
     * cancellation, or {@code null} if not collected. TODO(mgersh): Remove once new API works
     * http://crbug.com/629194 {@hide}
     */
    @Nullable public abstract Long getTotalTimeMs();

    /**
     * Returns total bytes sent over the network transport layer, or {@code null} if not collected.
     */
    @Nullable public abstract Long getSentByteCount();

    /**
     * Returns total bytes received over the network transport layer, or {@code null} if not
     * collected. Number of bytes does not include any previous redirects.
     */
    @Nullable public abstract Long getReceivedByteCount();
  }

  /**
   * Reason value indicating that the request succeeded. Returned from {@link #getFinishedReason}.
   */
  public static final int SUCCEEDED = 0;
  /**
   * Reason value indicating that the request failed or returned an error. Returned from {@link
   * #getFinishedReason}.
   */
  public static final int FAILED = 1;
  /**
   * Reason value indicating that the request was canceled. Returned from {@link
   * #getFinishedReason}.
   */
  public static final int CANCELED = 2;

  /**
   * Returns the request's original URL.
   *
   * @return the request's original URL
   */
  public abstract String getUrl();

  /**
   * Returns the objects that the caller has supplied when initiating the request, using {@link
   * ExperimentalUrlRequest.Builder#addRequestAnnotation} or {@link
   * ExperimentalBidirectionalStream.Builder#addRequestAnnotation}. Annotations can be used to
   * associate a {@link RequestFinishedInfo} with the original request or type of request.
   *
   * @return annotations supplied when creating the request
   */
  public abstract Collection<Object> getAnnotations();

  // TODO(klm): Collect and return a chain of Metrics objects for redirect responses.
  // TODO(mgersh): Update this javadoc when new metrics are fully implemented
  /**
   * Returns metrics collected for this request.
   *
   * <p>The reported times and bytes account for all redirects, i.e. the TTFB is from the start of
   * the original request to the ultimate response headers, the TTLB is from the start of the
   * original request to the end of the ultimate response, the received byte count is for all
   * redirects and the ultimate response combined. These cumulative metric definitions are
   * debatable, but are chosen to make sense for user-facing latency analysis.
   *
   * @return metrics collected for this request.
   */
  public abstract Metrics getMetrics();

  /**
   * Returns the reason why the request finished.
   *
   * @return one of {@link #SUCCEEDED}, {@link #FAILED}, or {@link #CANCELED}
   */
  public abstract int getFinishedReason();

  /**
   * Returns a {@link UrlResponseInfo} for the request, if its response had started.
   *
   * @return {@link UrlResponseInfo} for the request, if its response had started.
   */
  @Nullable public abstract UrlResponseInfo getResponseInfo();

  /**
   * If the request failed, returns the same {@link CronetException} provided to {@link
   * UrlRequest.Callback#onFailed}.
   *
   * @return the request's {@link CronetException}, if the request failed
   */
  @Nullable public abstract CronetException getException();
}
package org.chromium.net;

import android.net.TrafficStats;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
/**
 * Class to wrap TrafficStats.setThreadStatsUid(int uid) and TrafficStats.clearThreadStatsUid()
 * which are hidden and so must be accessed via reflection.
 */
public class ThreadStatsUid {
  // Reference to TrafficStats.setThreadStatsUid(int uid).
  private static final Method sSetThreadStatsUid;
  // Reference to TrafficStats.clearThreadStatsUid().
  private static final Method sClearThreadStatsUid;
  // Get reference to TrafficStats.setThreadStatsUid(int uid) and
  // TrafficStats.clearThreadStatsUid() via reflection.
  static {
    try {
      sSetThreadStatsUid = TrafficStats.class.getMethod("setThreadStatsUid", Integer.TYPE);
      sClearThreadStatsUid = TrafficStats.class.getMethod("clearThreadStatsUid");
    } catch (NoSuchMethodException | SecurityException e) {
      throw new RuntimeException("Unable to get TrafficStats methods", e);
    }
  }
  /** Calls TrafficStats.setThreadStatsUid(uid) */
  public static void set(int uid) {
    try {
      sSetThreadStatsUid.invoke(null, uid); // Pass null for "this" as it's a static method.
    } catch (IllegalAccessException e) {
      throw new RuntimeException("TrafficStats.setThreadStatsUid failed", e);
    } catch (InvocationTargetException e) {
      throw new RuntimeException("TrafficStats.setThreadStatsUid failed", e);
    }
  }
  /** Calls TrafficStats.clearThreadStatsUid() */
  public static void clear() {
    try {
      sClearThreadStatsUid.invoke(null); // Pass null for "this" as it's a static method.
    } catch (IllegalAccessException e) {
      throw new RuntimeException("TrafficStats.clearThreadStatsUid failed", e);
    } catch (InvocationTargetException e) {
      throw new RuntimeException("TrafficStats.clearThreadStatsUid failed", e);
    }
  }
}
package org.chromium.net;

import android.content.Context;
import androidx.annotation.VisibleForTesting;
import java.io.IOException;
import java.net.Proxy;
import java.net.URL;
import java.net.URLConnection;
import java.util.Date;
import java.util.Set;
import java.util.concurrent.Executor;

/**
 * {@link CronetEngine} that exposes experimental features. To obtain an instance of this class,
 * cast a {@code CronetEngine} to this type. Every instance of {@code CronetEngine} can be cast to
 * an instance of this class, as they are backed by the same implementation and hence perform
 * identically. Instances of this class are not meant for general use, but instead only to access
 * experimental features. Experimental features may be deprecated in the future. Use at your own
 * risk.
 *
 * <p>{@hide since this class exposes experimental features that should be hidden.}
 */
public abstract class ExperimentalCronetEngine extends CronetEngine {
  /** The value of a connection metric is unknown. */
  public static final int CONNECTION_METRIC_UNKNOWN = -1;

  /**
   * The estimate of the effective connection type is unknown.
   *
   * @see #getEffectiveConnectionType
   */
  public static final int EFFECTIVE_CONNECTION_TYPE_UNKNOWN = 0;

  /**
   * The device is offline.
   *
   * @see #getEffectiveConnectionType
   */
  public static final int EFFECTIVE_CONNECTION_TYPE_OFFLINE = 1;

  /**
   * The estimate of the effective connection type is slow 2G.
   *
   * @see #getEffectiveConnectionType
   */
  public static final int EFFECTIVE_CONNECTION_TYPE_SLOW_2G = 2;

  /**
   * The estimate of the effective connection type is 2G.
   *
   * @see #getEffectiveConnectionType
   */
  public static final int EFFECTIVE_CONNECTION_TYPE_2G = 3;

  /**
   * The estimate of the effective connection type is 3G.
   *
   * @see #getEffectiveConnectionType
   */
  public static final int EFFECTIVE_CONNECTION_TYPE_3G = 4;

  /**
   * The estimate of the effective connection type is 4G.
   *
   * @see #getEffectiveConnectionType
   */
  public static final int EFFECTIVE_CONNECTION_TYPE_4G = 5;

  /**
   * A version of {@link CronetEngine.Builder} that exposes experimental features. Instances of this
   * class are not meant for general use, but instead only to access experimental features.
   * Experimental features may be deprecated in the future. Use at your own risk.
   */
  public static class Builder extends CronetEngine.Builder {
    /**
     * Constructs a {@link Builder} object that facilitates creating a {@link CronetEngine}. The
     * default configuration enables HTTP/2 and disables QUIC, SDCH and the HTTP cache.
     *
     * @param context Android {@link Context}, which is used by {@link Builder} to retrieve the
     *     application context. A reference to only the application context will be kept, so as to
     *     avoid extending the lifetime of {@code context} unnecessarily.
     */
    public Builder(Context context) { super(context); }

    /**
     * Constructs {@link Builder} with a given delegate that provides the actual implementation of
     * the {@code Builder} methods. This constructor is used only by the internal implementation.
     *
     * @param builderDelegate delegate that provides the actual implementation.
     *     <p>{@hide}
     */
    public Builder(ICronetEngineBuilder builderDelegate) { super(builderDelegate); }

    /**
     * Enables the network quality estimator, which collects and reports measurements of round trip
     * time (RTT) and downstream throughput at various layers of the network stack. After enabling
     * the estimator, listeners of RTT and throughput can be added with {@link #addRttListener} and
     * {@link #addThroughputListener} and removed with {@link #removeRttListener} and {@link
     * #removeThroughputListener}. The estimator uses memory and CPU only when enabled.
     *
     * @param value {@code true} to enable network quality estimator, {@code false} to disable.
     * @return the builder to facilitate chaining.
     */
    public Builder enableNetworkQualityEstimator(boolean value) {
      mBuilderDelegate.enableNetworkQualityEstimator(value);
      return this;
    }

    /**
     * Sets experimental options to be used in Cronet.
     *
     * @param options JSON formatted experimental options.
     * @return the builder to facilitate chaining.
     */
    public Builder setExperimentalOptions(String options) {
      mBuilderDelegate.setExperimentalOptions(options);
      return this;
    }

    /**
     * Sets the thread priority of Cronet's internal thread.
     *
     * @param priority the thread priority of Cronet's internal thread. A Linux priority level, from
     *     -20 for highest scheduling priority to 19 for lowest scheduling priority. For more
     *     information on values, see {@link android.os.Process#setThreadPriority(int, int)} and
     *     {@link android.os.Process#THREAD_PRIORITY_DEFAULT THREAD_PRIORITY_*} values.
     * @return the builder to facilitate chaining.
     */
    public Builder setThreadPriority(int priority) {
      mBuilderDelegate.setThreadPriority(priority);
      return this;
    }

    /**
     * Returns delegate, only for testing.
     *
     * @hide
     */
    @VisibleForTesting
    public ICronetEngineBuilder getBuilderDelegate() {
      return mBuilderDelegate;
    }

    // To support method chaining, override superclass methods to return an
    // instance of this class instead of the parent.

    @Override
    public Builder setUserAgent(String userAgent) {
      super.setUserAgent(userAgent);
      return this;
    }

    @Override
    public Builder setStoragePath(String value) {
      super.setStoragePath(value);
      return this;
    }

    @Override
    public Builder setLibraryLoader(LibraryLoader loader) {
      super.setLibraryLoader(loader);
      return this;
    }

    @Override
    public Builder enableQuic(boolean value) {
      super.enableQuic(value);
      return this;
    }

    @Override
    public Builder enableHttp2(boolean value) {
      super.enableHttp2(value);
      return this;
    }

    @Override
    public Builder enableSdch(boolean value) {
      return this;
    }

    @Override
    public Builder enableHttpCache(int cacheMode, long maxSize) {
      super.enableHttpCache(cacheMode, maxSize);
      return this;
    }

    @Override
    public Builder addQuicHint(String host, int port, int alternatePort) {
      super.addQuicHint(host, port, alternatePort);
      return this;
    }

    @Override
    public Builder addPublicKeyPins(String hostName, Set<byte[]> pinsSha256,
                                    boolean includeSubdomains, Date expirationDate) {
      super.addPublicKeyPins(hostName, pinsSha256, includeSubdomains, expirationDate);
      return this;
    }

    @Override
    public Builder enablePublicKeyPinningBypassForLocalTrustAnchors(boolean value) {
      super.enablePublicKeyPinningBypassForLocalTrustAnchors(value);
      return this;
    }

    @Override
    public ExperimentalCronetEngine build() {
      return mBuilderDelegate.build();
    }
  }

  /**
   * Creates a builder for {@link BidirectionalStream} objects. All callbacks for generated {@code
   * BidirectionalStream} objects will be invoked on {@code executor}. {@code executor} must not run
   * tasks on the current thread, otherwise the networking operations may block and exceptions may
   * be thrown at shutdown time.
   *
   * @param url URL for the generated streams.
   * @param callback the {@link BidirectionalStream.Callback} object that gets invoked upon
   *     different events occurring.
   * @param executor the {@link Executor} on which {@code callback} methods will be invoked.
   * @return the created builder.
   */
  public abstract ExperimentalBidirectionalStream.Builder
  newBidirectionalStreamBuilder(String url, BidirectionalStream.Callback callback,
                                Executor executor);

  @Override
  public abstract ExperimentalUrlRequest.Builder
  newUrlRequestBuilder(String url, UrlRequest.Callback callback, Executor executor);

  /**
   * Starts NetLog logging to a specified directory with a bounded size. The NetLog will contain
   * events emitted by all live CronetEngines. The NetLog is useful for debugging. Once logging has
   * stopped {@link #stopNetLog}, the data will be written to netlog.json in {@code dirPath}. If
   * logging is interrupted, you can stitch the files found in .inprogress subdirectory manually
   * using:
   * https://chromium.googlesource.com/chromium/src/+/master/net/tools/stitch_net_log_files.py. The
   * log can be viewed using a Chrome browser navigated to chrome://net-internals/#import.
   *
   * @param dirPath the directory where the netlog.json file will be created. dirPath must already
   *     exist. NetLog files must not exist in the directory. If actively logging, this method is
   *     ignored.
   * @param logAll {@code true} to include basic events, user cookies, credentials and all
   *     transferred bytes in the log. This option presents a privacy risk, since it exposes the
   *     user's credentials, and should only be used with the user's consent and in situations where
   *     the log won't be public. {@code false} to just include basic events.
   * @param maxSize the maximum total disk space in bytes that should be used by NetLog. Actual disk
   *     space usage may exceed this limit slightly.
   */
  public void startNetLogToDisk(String dirPath, boolean logAll, int maxSize) {}

  /**
   * Returns an estimate of the effective connection type computed by the network quality estimator.
   * Call {@link Builder#enableNetworkQualityEstimator} to begin computing this value.
   *
   * @return the estimated connection type. The returned value is one of {@link
   *     #EFFECTIVE_CONNECTION_TYPE_UNKNOWN EFFECTIVE_CONNECTION_TYPE_* }.
   */
  public int getEffectiveConnectionType() { return EFFECTIVE_CONNECTION_TYPE_UNKNOWN; }

  /**
   * Configures the network quality estimator for testing. This must be called before round trip
   * time and throughput listeners are added, and after the network quality estimator has been
   * enabled.
   *
   * @param useLocalHostRequests include requests to localhost in estimates.
   * @param useSmallerResponses include small responses in throughput estimates.
   * @param disableOfflineCheck when set to true, disables the device offline checks when computing
   *     the effective connection type or when writing the prefs.
   */
  public void configureNetworkQualityEstimatorForTesting(boolean useLocalHostRequests,
                                                         boolean useSmallerResponses,
                                                         boolean disableOfflineCheck) {}

  /**
   * Registers a listener that gets called whenever the network quality estimator witnesses a sample
   * round trip time. This must be called after {@link Builder#enableNetworkQualityEstimator}, and
   * with throw an exception otherwise. Round trip times may be recorded at various layers of the
   * network stack, including TCP, QUIC, and at the URL request layer. The listener is called on the
   * {@link java.util.concurrent.Executor} that is passed to {@link
   * Builder#enableNetworkQualityEstimator}.
   *
   * @param listener the listener of round trip times.
   */
  public void addRttListener(NetworkQualityRttListener listener) {}

  /**
   * Removes a listener of round trip times if previously registered with {@link #addRttListener}.
   * This should be called after a {@link NetworkQualityRttListener} is added in order to stop
   * receiving observations.
   *
   * @param listener the listener of round trip times.
   */
  public void removeRttListener(NetworkQualityRttListener listener) {}

  /**
   * Registers a listener that gets called whenever the network quality estimator witnesses a sample
   * throughput measurement. This must be called after {@link
   * Builder#enableNetworkQualityEstimator}. Throughput observations are computed by measuring bytes
   * read over the active network interface at times when at least one URL response is being
   * received. The listener is called on the {@link java.util.concurrent.Executor} that is passed to
   * {@link Builder#enableNetworkQualityEstimator}.
   *
   * @param listener the listener of throughput.
   */
  public void addThroughputListener(NetworkQualityThroughputListener listener) {}

  /**
   * Removes a listener of throughput. This should be called after a {@link
   * NetworkQualityThroughputListener} is added with {@link #addThroughputListener} in order to stop
   * receiving observations.
   *
   * @param listener the listener of throughput.
   */
  public void removeThroughputListener(NetworkQualityThroughputListener listener) {}

  /**
   * Establishes a new connection to the resource specified by the {@link URL} {@code url} using the
   * given proxy.
   *
   * <p><b>Note:</b> Cronet's {@link java.net.HttpURLConnection} implementation is subject to
   * certain limitations, see {@link #createURLStreamHandlerFactory} for details.
   *
   * @param url URL of resource to connect to.
   * @param proxy proxy to use when establishing connection.
   * @return an {@link java.net.HttpURLConnection} instance implemented by this CronetEngine.
   * @throws IOException if an error occurs while opening the connection.
   */
  // TODO(pauljensen): Expose once implemented, http://crbug.com/418111
  public URLConnection openConnection(URL url, Proxy proxy) throws IOException {
    return url.openConnection(proxy);
  }

  /**
   * Registers a listener that gets called after the end of each request with the request info.
   *
   * <p>The listener is called on an {@link java.util.concurrent.Executor} provided by the listener.
   *
   * @param listener the listener for finished requests.
   */
  public void addRequestFinishedListener(RequestFinishedInfo.Listener listener) {}

  /**
   * Removes a finished request listener.
   *
   * @param listener the listener to remove.
   */
  public void removeRequestFinishedListener(RequestFinishedInfo.Listener listener) {}

  /**
   * Returns the HTTP RTT estimate (in milliseconds) computed by the network quality estimator. Set
   * to {@link #CONNECTION_METRIC_UNKNOWN} if the value is unavailable. This must be called after
   * {@link Builder#enableNetworkQualityEstimator}, and will throw an exception otherwise.
   *
   * @return Estimate of the HTTP RTT in milliseconds.
   */
  public int getHttpRttMs() { return CONNECTION_METRIC_UNKNOWN; }

  /**
   * Returns the transport RTT estimate (in milliseconds) computed by the network quality estimator.
   * Set to {@link #CONNECTION_METRIC_UNKNOWN} if the value is unavailable. This must be called
   * after {@link Builder#enableNetworkQualityEstimator}, and will throw an exception otherwise.
   *
   * @return Estimate of the transport RTT in milliseconds.
   */
  public int getTransportRttMs() { return CONNECTION_METRIC_UNKNOWN; }

  /**
   * Returns the downstream throughput estimate (in kilobits per second) computed by the network
   * quality estimator. Set to {@link #CONNECTION_METRIC_UNKNOWN} if the value is unavailable. This
   * must be called after {@link Builder#enableNetworkQualityEstimator}, and will throw an exception
   * otherwise.
   *
   * @return Estimate of the downstream throughput in kilobits per second.
   */
  public int getDownstreamThroughputKbps() { return CONNECTION_METRIC_UNKNOWN; }
}
package org.chromium.net;

/**
 * Exception passed to {@link UrlRequest.Callback#onFailed UrlRequest.Callback.onFailed()} when
 * Cronet fails to process a network request. In this case {@link #getErrorCode} and {@link
 * #getCronetInternalErrorCode} can be used to get more information about the specific type of
 * failure. If {@link #getErrorCode} returns {@link #ERROR_QUIC_PROTOCOL_FAILED}, this exception can
 * be cast to a {@link QuicException} which can provide further details.
 */
public abstract class NetworkException extends CronetException {
  /**
   * Error code indicating the host being sent the request could not be resolved to an IP address.
   */
  public static final int ERROR_HOSTNAME_NOT_RESOLVED = 1;
  /** Error code indicating the device was not connected to any network. */
  public static final int ERROR_INTERNET_DISCONNECTED = 2;
  /**
   * Error code indicating that as the request was processed the network configuration changed. When
   * {@link #getErrorCode} returns this code, this exception may be cast to {@link QuicException}
   * for more information if <a href="https://www.chromium.org/quic">QUIC</a> protocol is used.
   */
  public static final int ERROR_NETWORK_CHANGED = 3;
  /**
   * Error code indicating a timeout expired. Timeouts expiring while attempting to connect will be
   * reported as the more specific {@link #ERROR_CONNECTION_TIMED_OUT}.
   */
  public static final int ERROR_TIMED_OUT = 4;
  /** Error code indicating the connection was closed unexpectedly. */
  public static final int ERROR_CONNECTION_CLOSED = 5;
  /** Error code indicating the connection attempt timed out. */
  public static final int ERROR_CONNECTION_TIMED_OUT = 6;
  /** Error code indicating the connection attempt was refused. */
  public static final int ERROR_CONNECTION_REFUSED = 7;
  /** Error code indicating the connection was unexpectedly reset. */
  public static final int ERROR_CONNECTION_RESET = 8;
  /**
   * Error code indicating the IP address being contacted is unreachable, meaning there is no route
   * to the specified host or network.
   */
  public static final int ERROR_ADDRESS_UNREACHABLE = 9;
  /**
   * Error code indicating an error related to the <a href="https://www.chromium.org/quic">QUIC</a>
   * protocol. When {@link #getErrorCode} returns this code, this exception can be cast to {@link
   * QuicException} for more information.
   */
  public static final int ERROR_QUIC_PROTOCOL_FAILED = 10;
  /**
   * Error code indicating another type of error was encountered. {@link
   * #getCronetInternalErrorCode} can be consulted to get a more specific cause.
   */
  public static final int ERROR_OTHER = 11;

  /**
   * Constructs an exception that is caused by a network error.
   *
   * @param message explanation of failure.
   * @param cause the cause (which is saved for later retrieval by the {@link
   *     java.io.IOException#getCause getCause()} method). A null value is permitted, and indicates
   *     that the cause is nonexistent or unknown.
   */
  protected NetworkException(String message, Throwable cause) { super(message, cause); }

  /**
   * Returns error code, one of {@link #ERROR_HOSTNAME_NOT_RESOLVED ERROR_*}.
   *
   * @return error code, one of {@link #ERROR_HOSTNAME_NOT_RESOLVED ERROR_*}.
   */
  public abstract int getErrorCode();

  /**
   * Returns a Cronet internal error code. This may provide more specific error diagnosis than
   * {@link #getErrorCode}, but the constant values are not exposed to Java and may change over
   * time. See <a
   * href=https://chromium.googlesource.com/chromium/src/+/master/net/base/net_error_list.h>here</a>
   * for the latest list of values.
   *
   * @return Cronet internal error code.
   */
  public abstract int getCronetInternalErrorCode();

  /**
   * Returns {@code true} if retrying this request right away might succeed, {@code false}
   * otherwise. For example returns {@code true} when {@link #getErrorCode} returns {@link
   * #ERROR_NETWORK_CHANGED} because trying the request might succeed using the new network
   * configuration, but {@code false} when {@code getErrorCode()} returns {@link
   * #ERROR_INTERNET_DISCONNECTED} because retrying the request right away will encounter the same
   * failure (instead retrying should be delayed until device regains network connectivity).
   *
   * @return {@code true} if retrying this request right away might succeed, {@code false}
   *     otherwise.
   */
  public abstract boolean immediatelyRetryable();
}
package io.envoyproxy.envoymobile.utilities;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.http.X509TrustManagerExtensions;
import android.os.Build;
import android.security.KeyChain;
import android.util.Pair;

import android.util.Log;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateExpiredException;
import java.security.cert.CertificateFactory;
import java.security.cert.CertificateNotYetValidException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import javax.security.auth.x500.X500Principal;

/**
 * Utility functions for verifying X.509 certificates.
 */
public final class X509Util {
  private static final String TAG = "X509Util";

  private static final class TrustStorageListener extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
      boolean shouldReloadTrustManager = false;
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        if (KeyChain.ACTION_KEYCHAIN_CHANGED.equals(intent.getAction()) ||
            KeyChain.ACTION_TRUST_STORE_CHANGED.equals(intent.getAction())) {
          // TODO(davidben): ACTION_KEYCHAIN_CHANGED indicates client certificates
          // changed, not the trust store. The two signals within CertDatabase are
          // identical, so we are reloading more than needed. But note b/36492171.
          shouldReloadTrustManager = true;
        } else if (KeyChain.ACTION_KEY_ACCESS_CHANGED.equals(intent.getAction()) &&
                   !intent.getBooleanExtra(KeyChain.EXTRA_KEY_ACCESSIBLE, false)) {
          // We lost access to a client certificate key. Reload all client certificate
          // state as we are not currently able to forget an individual identity.
          shouldReloadTrustManager = true;
        }
      } else {
        @SuppressWarnings("deprecation") String action = KeyChain.ACTION_STORAGE_CHANGED;
        // Before Android O, KeyChain only emitted a coarse-grained intent. This fires much
        // more often than it should (https://crbug.com/381912), but there are no APIs to
        // distinguish the various cases.
        shouldReloadTrustManager = action.equals(intent.getAction());
      }

      if (shouldReloadTrustManager) {
        try {
          reloadDefaultTrustManager();
        } catch (CertificateException e) {
          Log.e(TAG, "Unable to reload the default TrustManager", e);
        } catch (KeyStoreException e) {
          Log.e(TAG, "Unable to reload the default TrustManager", e);
        } catch (NoSuchAlgorithmException e) {
          Log.e(TAG, "Unable to reload the default TrustManager", e);
        }
      }
    }
  }

  private static List<X509Certificate>
  checkServerTrustedIgnoringRuntimeException(X509TrustManagerExtensions tm, X509Certificate[] chain,
                                             String authType, String host)
      throws CertificateException {
    try {
      return tm.checkServerTrusted(chain, authType, host);
    } catch (RuntimeException e) {
      // https://crbug.com/937354: checkServerTrusted() can unexpectedly throw runtime
      // exceptions, most often within conscrypt while parsing certificates.
      Log.e(TAG, "checkServerTrusted() unexpectedly threw: %s", e);
      throw new CertificateException(e);
    }
  }

  private static CertificateFactory sCertificateFactory;

  private static final String OID_TLS_SERVER_AUTH = "1.3.6.1.5.5.7.3.1";
  private static final String OID_ANY_EKU = "2.5.29.37.0";
  // Server-Gated Cryptography (necessary to support a few legacy issuers):
  //    Netscape:
  private static final String OID_SERVER_GATED_NETSCAPE = "2.16.840.1.113730.4.1";
  //    Microsoft:
  private static final String OID_SERVER_GATED_MICROSOFT = "1.3.6.1.4.1.311.10.3.3";

  /**
   * Trust manager backed up by the read-only system certificate store.
   */
  private static X509TrustManagerExtensions sDefaultTrustManager;

  /**
   * BroadcastReceiver that listens to change in the system keystore to invalidate certificate
   * caches.
   */
  private static TrustStorageListener sTrustStorageListener;

  /**
   * Trust manager backed up by a custom certificate store. We need such manager to plant test
   * root CA to the trust store in testing.
   */
  private static X509TrustManagerExtensions sTestTrustManager;
  private static KeyStore sTestKeyStore;

  /**
   * The system key store. This is used to determine whether a trust anchor is a system trust
   * anchor or user-installed.
   */
  private static KeyStore sSystemKeyStore;

  /**
   * The directory where system certificates are stored. This is used to determine whether a
   * trust anchor is a system trust anchor or user-installed. The KeyStore API alone is not
   * sufficient to efficiently query whether a given X500Principal, PublicKey pair is a trust
   * anchor.
   */
  private static File sSystemCertificateDirectory;

  /**
   * An in-memory cache of which trust anchors are system trust roots. This avoids reading and
   * decoding the root from disk on every verification. Mirrors a similar in-memory cache in
   * Conscrypt's X509TrustManager implementation.
   */
  private static Set<Pair<X500Principal, PublicKey>> sSystemTrustAnchorCache;

  /**
   * True if the system key store has been loaded. If the "AndroidCAStore" KeyStore instance
   * was not found, sSystemKeyStore may be null while sLoadedSystemKeyStore is true.
   */
  private static boolean sLoadedSystemKeyStore;

  /**
   * Lock object used to synchronize all calls that modify or depend on the trust managers.
   */
  private static final Object sLock = new Object();

  /**
   * Ensures that the trust managers and certificate factory are initialized.
   */
  private static void ensureInitialized()
      throws CertificateException, KeyStoreException, NoSuchAlgorithmException {
    synchronized (sLock) { ensureInitializedLocked(); }
  }

  /**
   * Ensures that the trust managers and certificate factory are initialized. Must be called with
   * |sLock| held.
   */
  // FindBugs' static field initialization warnings do not handle methods that are expected to be
  // called locked.
  private static void ensureInitializedLocked()
      throws CertificateException, KeyStoreException, NoSuchAlgorithmException {
    assert Thread.holdsLock(sLock);

    if (sCertificateFactory == null) {
      sCertificateFactory = CertificateFactory.getInstance("X.509");
    }
    if (sDefaultTrustManager == null) {
      sDefaultTrustManager = X509Util.createTrustManager(null);
    }
    if (!sLoadedSystemKeyStore) {
      try {
        sSystemKeyStore = KeyStore.getInstance("AndroidCAStore");
        try {
          sSystemKeyStore.load(null);
        } catch (IOException e) {
          // No IO operation is attempted.
        }
        sSystemCertificateDirectory =
            new File(System.getenv("ANDROID_ROOT") + "/etc/security/cacerts");
      } catch (KeyStoreException e) {
        // Could not load AndroidCAStore. Continue anyway; isKnownRoot will always
        // return false.
      }
      sLoadedSystemKeyStore = true;
    }
    if (sSystemTrustAnchorCache == null) {
      sSystemTrustAnchorCache = new HashSet<Pair<X500Principal, PublicKey>>();
    }
    if (sTestKeyStore == null) {
      sTestKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());
      try {
        sTestKeyStore.load(null);
      } catch (IOException e) {
        // No IO operation is attempted.
      }
    }
    if (sTestTrustManager == null) {
      sTestTrustManager = X509Util.createTrustManager(sTestKeyStore);
    }
    if (sTrustStorageListener == null) {
      sTrustStorageListener = new TrustStorageListener();
      IntentFilter filter = new IntentFilter();
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        filter.addAction(KeyChain.ACTION_KEYCHAIN_CHANGED);
        filter.addAction(KeyChain.ACTION_KEY_ACCESS_CHANGED);
        filter.addAction(KeyChain.ACTION_TRUST_STORE_CHANGED);
      } else {
        @SuppressWarnings("deprecation") String action = KeyChain.ACTION_STORAGE_CHANGED;
        filter.addAction(action);
      }
      ContextUtils.registerNonExportedBroadcastReceiver(ContextUtils.getApplicationContext(),
                                                        sTrustStorageListener, filter);
    }
  }

  /**
   * Creates a X509TrustManagerExtensions backed up by the given key
   * store. When null is passed as a key store, system default trust store is
   * used. Returns null if no created TrustManager was suitable.
   * @throws KeyStoreException, NoSuchAlgorithmException on error initializing the TrustManager.
   */
  private static X509TrustManagerExtensions createTrustManager(KeyStore keyStore)
      throws KeyStoreException, NoSuchAlgorithmException {
    String algorithm = TrustManagerFactory.getDefaultAlgorithm();
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm);
    tmf.init(keyStore);

    TrustManager[] trustManagers = null;
    try {
      trustManagers = tmf.getTrustManagers();
    } catch (RuntimeException e) {
      // https://crbug.com/937354: getTrustManagers() can unexpectedly throw runtime
      // exceptions, most often while processing the network security config XML file.
      Log.e(TAG, "TrustManagerFactory.getTrustManagers() unexpectedly threw: %s", e);
      throw new KeyStoreException(e);
    }

    for (TrustManager tm : trustManagers) {
      if (tm instanceof X509TrustManager) {
        try {
          return new X509TrustManagerExtensions((X509TrustManager)tm);
        } catch (IllegalArgumentException e) {
          String className = tm.getClass().getName();
          Log.e(TAG, "Error creating trust manager (" + className + "): " + e);
        }
      }
    }
    Log.e(TAG, "Could not find suitable trust manager");
    return null;
  }

  /**
   * After each modification of test key store, trust manager has to be generated again.
   */
  private static void reloadTestTrustManager() throws KeyStoreException, NoSuchAlgorithmException {
    assert Thread.holdsLock(sLock);

    sTestTrustManager = X509Util.createTrustManager(sTestKeyStore);
  }

  /**
   * After each modification by the system of the key store, trust manager has to be regenerated.
   */
  private static void reloadDefaultTrustManager()
      throws KeyStoreException, NoSuchAlgorithmException, CertificateException {
    synchronized (sLock) {
      sDefaultTrustManager = null;
      sSystemTrustAnchorCache = null;
      ensureInitializedLocked();
    }
    // TODO(stefanoduo): Hook envoy-mobile JNI
    // X509UtilJni.get().notifyKeyChainChanged();
  }

  /**
   * Convert a DER encoded certificate to an X509Certificate.
   */
  public static X509Certificate createCertificateFromBytes(byte[] derBytes)
      throws CertificateException, KeyStoreException, NoSuchAlgorithmException {
    ensureInitialized();
    return (X509Certificate)sCertificateFactory.generateCertificate(
        new ByteArrayInputStream(derBytes));
  }

  public static void addTestRootCertificate(byte[] rootCertBytes)
      throws CertificateException, KeyStoreException, NoSuchAlgorithmException {
    ensureInitialized();
    X509Certificate rootCert = createCertificateFromBytes(rootCertBytes);
    synchronized (sLock) {
      sTestKeyStore.setCertificateEntry("root_cert_" + Integer.toString(sTestKeyStore.size()),
                                        rootCert);
      reloadTestTrustManager();
    }
  }

  public static void clearTestRootCertificates()
      throws NoSuchAlgorithmException, CertificateException, KeyStoreException {
    ensureInitialized();
    synchronized (sLock) {
      try {
        sTestKeyStore.load(null);
        reloadTestTrustManager();
      } catch (IOException e) {
        // No IO operation is attempted.
      }
    }
  }

  private static final char[] HEX_DIGITS = {
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',
  };

  private static String hashPrincipal(X500Principal principal) throws NoSuchAlgorithmException {
    // Android hashes a principal as the first four bytes of its MD5 digest, encoded in
    // lowercase hex and reversed. Verified in 4.2, 4.3, and 4.4.
    byte[] digest = MessageDigest.getInstance("MD5").digest(principal.getEncoded());
    char[] hexChars = new char[8];
    for (int i = 0; i < 4; i++) {
      hexChars[2 * i] = HEX_DIGITS[(digest[3 - i] >> 4) & 0xf];
      hexChars[2 * i + 1] = HEX_DIGITS[digest[3 - i] & 0xf];
    }
    return new String(hexChars);
  }

  private static boolean isKnownRoot(X509Certificate root)
      throws NoSuchAlgorithmException, KeyStoreException {
    assert Thread.holdsLock(sLock);

    // Could not find the system key store. Conservatively report false.
    if (sSystemKeyStore == null)
      return false;

    // Check the in-memory cache first; avoid decoding the anchor from disk
    // if it has been seen before.
    Pair<X500Principal, PublicKey> key =
        new Pair<X500Principal, PublicKey>(root.getSubjectX500Principal(), root.getPublicKey());

    if (sSystemTrustAnchorCache.contains(key))
      return true;

    // Note: It is not sufficient to call sSystemKeyStore.getCertificiateAlias. If the server
    // supplies a copy of a trust anchor, X509TrustManagerExtensions returns the server's
    // version rather than the system one. getCertificiateAlias will then fail to find an anchor
    // name. This is fixed upstream in https://android-review.googlesource.com/#/c/91605/
    //
    // TODO(davidben): When the change trickles into an Android release, query sSystemKeyStore
    // directly.

    // System trust anchors are stored under a hash of the principal. In case of collisions,
    // a number is appended.
    String hash = hashPrincipal(root.getSubjectX500Principal());
    for (int i = 0; true; i++) {
      String alias = hash + '.' + i;
      if (!new File(sSystemCertificateDirectory, alias).exists())
        break;

      Certificate anchor = sSystemKeyStore.getCertificate("system:" + alias);
      // It is possible for this to return null if the user deleted a trust anchor. In
      // that case, the certificate remains in the system directory but is also added to
      // another file. Continue iterating as there may be further collisions after the
      // deleted anchor.
      if (anchor == null)
        continue;

      if (!(anchor instanceof X509Certificate)) {
        // This should never happen.
        String className = anchor.getClass().getName();
        Log.e(TAG, "Anchor " + alias + " not an X509Certificate: " + className);
        continue;
      }

      // If the subject and public key match, this is a system root.
      X509Certificate anchorX509 = (X509Certificate)anchor;
      if (root.getSubjectX500Principal().equals(anchorX509.getSubjectX500Principal()) &&
          root.getPublicKey().equals(anchorX509.getPublicKey())) {
        sSystemTrustAnchorCache.add(key);
        return true;
      }
    }

    return false;
  }

  /**
   * If an EKU extension is present in the end-entity certificate, it MUST contain either the
   * anyEKU or serverAuth or netscapeSGC or Microsoft SGC EKUs.
   *
   * @return true if there is no EKU extension or if any of the EKU extensions is one of the valid
   * OIDs for web server certificates.
   *
   * TODO(palmer): This can be removed after the equivalent change is made to the Android default
   * TrustManager and that change is shipped to a large majority of Android users.
   */
  static boolean verifyKeyUsage(X509Certificate certificate) throws CertificateException {
    List<String> ekuOids;
    try {
      ekuOids = certificate.getExtendedKeyUsage();
    } catch (NullPointerException e) {
      // getExtendedKeyUsage() can crash due to an Android platform bug. This probably
      // happens when the EKU extension data is malformed so return false here.
      // See http://crbug.com/233610
      return false;
    }
    if (ekuOids == null)
      return true;

    for (String ekuOid : ekuOids) {
      if (ekuOid.equals(OID_TLS_SERVER_AUTH) || ekuOid.equals(OID_ANY_EKU) ||
          ekuOid.equals(OID_SERVER_GATED_NETSCAPE) || ekuOid.equals(OID_SERVER_GATED_MICROSOFT)) {
        return true;
      }
    }

    return false;
  }

  public static AndroidCertVerifyResult verifyServerCertificates(byte[][] certChain,
                                                                 String authType, String host)
      throws KeyStoreException, NoSuchAlgorithmException {
    if (certChain == null || certChain.length == 0 || certChain[0] == null) {
      throw new IllegalArgumentException(
          "Expected non-null and non-empty certificate "
          + "chain passed as |certChain|. |certChain|=" + Arrays.deepToString(certChain));
    }

    try {
      ensureInitialized();
    } catch (CertificateException e) {
      return new AndroidCertVerifyResult(CertVerifyStatusAndroid.FAILED);
    }

    List<X509Certificate> serverCertificatesList = new ArrayList<X509Certificate>();
    try {
      serverCertificatesList.add(createCertificateFromBytes(certChain[0]));
    } catch (CertificateException e) {
      return new AndroidCertVerifyResult(CertVerifyStatusAndroid.UNABLE_TO_PARSE);
    }
    for (int i = 1; i < certChain.length; ++i) {
      try {
        serverCertificatesList.add(createCertificateFromBytes(certChain[i]));
      } catch (CertificateException e) {
        Log.w(TAG, "intermediate " + i + " failed parsing");
      }
    }
    X509Certificate[] serverCertificates =
        serverCertificatesList.toArray(new X509Certificate[serverCertificatesList.size()]);

    // Expired and not yet valid certificates would be rejected by the trust managers, but the
    // trust managers report all certificate errors using the general CertificateException. In
    // order to get more granular error information, cert validity time range is being checked
    // separately.
    try {
      serverCertificates[0].checkValidity();
      if (!verifyKeyUsage(serverCertificates[0])) {
        return new AndroidCertVerifyResult(CertVerifyStatusAndroid.INCORRECT_KEY_USAGE);
      }
    } catch (CertificateExpiredException e) {
      return new AndroidCertVerifyResult(CertVerifyStatusAndroid.EXPIRED);
    } catch (CertificateNotYetValidException e) {
      return new AndroidCertVerifyResult(CertVerifyStatusAndroid.NOT_YET_VALID);
    } catch (CertificateException e) {
      return new AndroidCertVerifyResult(CertVerifyStatusAndroid.FAILED);
    }

    synchronized (sLock) {
      // If no trust manager was found, fail without crashing on the null pointer.
      if (sDefaultTrustManager == null) {
        return new AndroidCertVerifyResult(CertVerifyStatusAndroid.FAILED);
      }

      List<X509Certificate> verifiedChain;
      try {
        verifiedChain = checkServerTrustedIgnoringRuntimeException(
            sDefaultTrustManager, serverCertificates, authType, host);
      } catch (CertificateException eDefaultManager) {
        try {
          verifiedChain = checkServerTrustedIgnoringRuntimeException(
              sTestTrustManager, serverCertificates, authType, host);
        } catch (CertificateException eTestManager) {
          // Neither of the trust managers confirms the validity of the certificate chain,
          // log the error message returned by the system trust manager.
          Log.i(TAG,
                "Failed to validate the certificate chain, error: " + eDefaultManager.getMessage());
          return new AndroidCertVerifyResult(CertVerifyStatusAndroid.NO_TRUSTED_ROOT);
        }
      }

      boolean isIssuedByKnownRoot = false;
      if (verifiedChain.size() > 0) {
        X509Certificate root = verifiedChain.get(verifiedChain.size() - 1);
        isIssuedByKnownRoot = isKnownRoot(root);
      }

      return new AndroidCertVerifyResult(CertVerifyStatusAndroid.OK, isIssuedByKnownRoot,
                                         verifiedChain);
    }
  }

  // TODO(stefanoduo): Hook envoy-mobile JNI
  //@NativeMethods
  // interface Natives {
  //    /**
  //     * Notify the native net::CertDatabase instance that the system database has been updated.
  //     */
  //    void notifyKeyChainChanged();
  //}
}
package io.envoyproxy.envoymobile.utilities;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 * Fake utility functions to verify X.509 certificates.
 *
 * FakeX509Util is not particularly clever: from its perspective a certificate is just a string and
 * its contents have no particular meaning. For a verification to succeed:
 * - all certificates in a chain must have been previously registered as root certificates
 * - host and authentication type must match the expected hardcoded values
 * This doesn't make much sense w.r.t. how X.509 certificates are really validated, but we're not
 * interested in mimicking that, we just want something to confirm that JNI calls have taken place.
 */
public final class FakeX509Util {
  private static final Set<String> validFakeCerts = new HashSet<String>();

  public static final String expectedAuthType = "RSA";
  private static String expectedHost = "www.example.com";

  public static String getExpectedHost() { return expectedHost; }
  public static void setExpectedHost(String host) { expectedHost = host; }

  public static void addTestRootCertificate(byte[] rootCertBytes) {
    String fakeCertificate = new String(rootCertBytes);
    validFakeCerts.add(fakeCertificate);
  }

  public static void clearTestRootCertificates() { validFakeCerts.clear(); }

  /**
   * Performs fake certificate chain verification. Returns CertVerifyStatusAndroid.NO_TRUSTED_ROOT
   * if at least one of the certificates in the chain has not been previously registered as a root.
   * Returns CertVerifyStatusAndroid.OK if authType and host match respectively expectedAuthType and
   * expectedHost; CertVerifyStatusAndroid.FAILED otherwise.
   */
  public static AndroidCertVerifyResult verifyServerCertificates(byte[][] certChain,
                                                                 String authType, String host) {
    if (certChain == null || certChain.length == 0 || certChain[0] == null) {
      throw new IllegalArgumentException(
          "Expected non-null and non-empty certificate "
          + "chain passed as |certChain|. |certChain|=" + Arrays.deepToString(certChain));
    }

    if (ContextUtils.getApplicationContext() == null) {
      throw new NullPointerException(
          "ContextUtils is not initialized with a proper context. Call initApplicationContext() during startup.");
    }

    for (byte[] cert : certChain) {
      String fakeCert = new String(cert);
      if (!validFakeCerts.contains(fakeCert)) {
        return new AndroidCertVerifyResult(CertVerifyStatusAndroid.NO_TRUSTED_ROOT);
      }
    }

    return authType.equals(expectedAuthType) && host.equals(expectedHost)
        ? new AndroidCertVerifyResult(CertVerifyStatusAndroid.OK)
        : new AndroidCertVerifyResult(CertVerifyStatusAndroid.FAILED);
  }
}
package io.envoyproxy.envoymobile.utilities;

import android.os.Build;
import android.os.StrictMode;

import java.io.Closeable;

/**
 * Enables try-with-resources compatible StrictMode violation allowlisting.
 *
 * Prefer "ignored" as the variable name to appease Android Studio's "Unused symbol" inspection.
 *
 * Example:
 * <pre>
 *     try (StrictModeContext ignored = StrictModeContext.allowDiskWrites()) {
 *         return Example.doThingThatRequiresDiskWrites();
 *     }
 * </pre>
 *
 */
public final class StrictModeContext implements Closeable {
  private final StrictMode.ThreadPolicy mThreadPolicy;
  private final StrictMode.VmPolicy mVmPolicy;

  private StrictModeContext(StrictMode.ThreadPolicy threadPolicy, StrictMode.VmPolicy vmPolicy) {
    mThreadPolicy = threadPolicy;
    mVmPolicy = vmPolicy;
  }

  private StrictModeContext(StrictMode.ThreadPolicy threadPolicy) { this(threadPolicy, null); }

  private StrictModeContext(StrictMode.VmPolicy vmPolicy) { this(null, vmPolicy); }

  /**
   * Convenience method for disabling all VM-level StrictMode checks with try-with-resources.
   * Includes everything listed here:
   *     https://developer.android.com/reference/android/os/StrictMode.VmPolicy.Builder.html
   */
  public static StrictModeContext allowAllVmPolicies() {
    StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy();
    StrictMode.setVmPolicy(StrictMode.VmPolicy.LAX);
    return new StrictModeContext(oldPolicy);
  }

  /**
   * Convenience method for disabling all thread-level StrictMode checks with try-with-resources.
   * Includes everything listed here:
   *     https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy.Builder.html
   */
  public static StrictModeContext allowAllThreadPolicies() {
    StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
    StrictMode.setThreadPolicy(StrictMode.ThreadPolicy.LAX);
    return new StrictModeContext(oldPolicy);
  }

  /**
   * Convenience method for disabling StrictMode for disk-writes with try-with-resources.
   */
  public static StrictModeContext allowDiskWrites() {
    StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();
    return new StrictModeContext(oldPolicy);
  }

  /**
   * Convenience method for disabling StrictMode for disk-reads with try-with-resources.
   */
  public static StrictModeContext allowDiskReads() {
    StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
    return new StrictModeContext(oldPolicy);
  }

  /**
   * Convenience method for disabling StrictMode for slow calls with try-with-resources.
   */
  public static StrictModeContext allowSlowCalls() {
    StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
    StrictMode.setThreadPolicy(
        new StrictMode.ThreadPolicy.Builder(oldPolicy).permitCustomSlowCalls().build());
    return new StrictModeContext(oldPolicy);
  }

  /**
   * Convenience method for disabling StrictMode for unbuffered input/output operations with
   * try-with-resources.
   * For API level 25- this method will do nothing;
   * because StrictMode.ThreadPolicy.Builder#permitUnbufferedIo is added in API level 26.
   */
  public static StrictModeContext allowUnbufferedIo() {
    StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
      StrictMode.setThreadPolicy(
          new StrictMode.ThreadPolicy.Builder(oldPolicy).permitUnbufferedIo().build());
    }
    return new StrictModeContext(oldPolicy);
  }

  @Override
  public void close() {
    if (mThreadPolicy != null) {
      StrictMode.setThreadPolicy(mThreadPolicy);
    }
    if (mVmPolicy != null) {
      StrictMode.setVmPolicy(mVmPolicy);
    }
  }
}
package io.envoyproxy.envoymobile.utilities;

import androidx.annotation.IntDef;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@IntDef({CertVerifyStatusAndroid.OK, CertVerifyStatusAndroid.FAILED,
         CertVerifyStatusAndroid.NO_TRUSTED_ROOT, CertVerifyStatusAndroid.EXPIRED,
         CertVerifyStatusAndroid.NOT_YET_VALID, CertVerifyStatusAndroid.UNABLE_TO_PARSE,
         CertVerifyStatusAndroid.INCORRECT_KEY_USAGE})
@Retention(RetentionPolicy.SOURCE)
public @interface CertVerifyStatusAndroid {
  /**
   * Certificate is trusted.
   */
  int OK = 0;
  /**
   * Certificate verification could not be conducted.
   */
  int FAILED = -1;
  /**
   * Certificate is not trusted due to non-trusted root of the certificate chain.
   */
  int NO_TRUSTED_ROOT = -2;
  /**
   * Certificate is not trusted because it has expired.
   */
  int EXPIRED = -3;
  /**
   * Certificate is not trusted because it is not valid yet.
   */
  int NOT_YET_VALID = -4;
  /**
   * Certificate is not trusted because it could not be parsed.
   */
  int UNABLE_TO_PARSE = -5;
  /**
   * Certificate is not trusted because it has an extendedKeyUsage field, but its value is not
   * correct for a web server.
   */
  int INCORRECT_KEY_USAGE = -6;
}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="io.envoyproxy.envoymobile.utilities">
    <uses-sdk
            android:minSdkVersion="21"
            android:targetSdkVersion="29"/>

</manifest>
package io.envoyproxy.envoymobile.utilities;

import android.app.Activity;
import android.app.Application;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.ContextWrapper;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.res.AssetManager;
import android.os.Build;
import android.os.Handler;
import android.os.Process;
import android.preference.PreferenceManager;

import androidx.annotation.Nullable;
import androidx.annotation.VisibleForTesting;

/**
 * This class provides Android application context related utility methods.
 */
public final class ContextUtils {
  private static final String TAG = "ContextUtils";
  private static Context sApplicationContext;

  private static boolean sSdkSandboxProcess;

  /**
   * Flag for {@link Context#registerReceiver}: The receiver can receive broadcasts from other
   * Apps. Has the same behavior as marking a statically registered receiver with "exported=true".
   *
   * TODO(mthiesse): Move to ApiHelperForT when we build against T SDK.
   */
  public static final int RECEIVER_EXPORTED = 0x2;
  public static final int RECEIVER_NOT_EXPORTED = 0x4;

  /**
   * Initialization-on-demand holder. This exists for thread-safe lazy initialization.
   */
  private static class Holder {
    // Not final for tests.
    private static SharedPreferences sSharedPreferences = fetchAppSharedPreferences();
  }

  /**
   * Get the Android application context.
   *
   * Under normal circumstances there is only one application context in a process, so it's safe
   * to treat this as a global. In WebView it's possible for more than one app using WebView to be
   * running in a single process, but this mechanism is rarely used and this is not the only
   * problem in that scenario, so we don't currently forbid using it as a global.
   *
   * Do not downcast the context returned by this method to Application (or any subclass). It may
   * not be an Application object; it may be wrapped in a ContextWrapper. The only assumption you
   * may make is that it is a Context whose lifetime is the same as the lifetime of the process.
   */
  public static Context getApplicationContext() { return sApplicationContext; }

  /**
   * Initializes the java application context.
   *
   * This should be called exactly once early on during startup, before native is loaded and
   * before any other clients make use of the application context through this class.
   *
   * @param appContext The application context.
   */
  public static void initApplicationContext(Context appContext) {
    // Conceding that occasionally in tests, native is loaded before the browser process is
    // started, in which case the browser process re-sets the application context.
    assert sApplicationContext == null || sApplicationContext == appContext ||
        ((ContextWrapper)sApplicationContext).getBaseContext() == appContext;
    initJavaSideApplicationContext(appContext);
  }

  /**
   * Only called by the static holder class and tests.
   *
   * @return The application-wide shared preferences.
   */
  @SuppressWarnings("DefaultSharedPreferencesCheck")
  private static SharedPreferences fetchAppSharedPreferences() {
    // This may need to create the prefs directory if we've never used shared prefs before, so
    // allow disk writes. This is rare but can happen if code used early in startup reads prefs.
    try (StrictModeContext ignored = StrictModeContext.allowDiskWrites()) {
      return PreferenceManager.getDefaultSharedPreferences(sApplicationContext);
    }
  }

  /**
   * This is used to ensure that we always use the application context to fetch the default shared
   * preferences. This avoids needless I/O for android N and above. It also makes it clear that
   * the app-wide shared preference is desired, rather than the potentially context-specific one.
   *
   * @return application-wide shared preferences.
   */
  public static SharedPreferences getAppSharedPreferences() { return Holder.sSharedPreferences; }

  /**
   * Occasionally tests cannot ensure the application context doesn't change between tests (junit)
   * and sometimes specific tests has its own special needs, initApplicationContext should be used
   * as much as possible, but this method can be used to override it.
   *
   * @param appContext The new application context.
   */
  @VisibleForTesting
  public static void initApplicationContextForTests(Context appContext) {
    initJavaSideApplicationContext(appContext);
    Holder.sSharedPreferences = fetchAppSharedPreferences();
  }

  /**
   * Tests that use the applicationContext may unintentionally use the Context
   * set by a previously run test.
   */
  @VisibleForTesting
  public static void clearApplicationContextForTests() {
    sApplicationContext = null;
    Holder.sSharedPreferences = null;
  }

  private static void initJavaSideApplicationContext(Context appContext) {
    assert appContext != null;
    // Guard against anyone trying to downcast.
    if (appContext instanceof Application) {
      appContext = new ContextWrapper(appContext);
    }
    sApplicationContext = appContext;
  }

  /**
   * As to Exported V.S. NonExported receiver, please refer to
   * https://developer.android.com/reference/android/content/Context#registerReceiver(android.content.BroadcastReceiver,%20android.content.IntentFilter,%20int)
   */
  public static Intent registerExportedBroadcastReceiver(Context context,
                                                         BroadcastReceiver receiver,
                                                         IntentFilter filter, String permission) {
    return registerBroadcastReceiver(context, receiver, filter, permission, /*scheduler=*/null,
                                     RECEIVER_EXPORTED);
  }

  public static Intent registerNonExportedBroadcastReceiver(Context context,
                                                            BroadcastReceiver receiver,
                                                            IntentFilter filter) {
    return registerBroadcastReceiver(context, receiver, filter, /*permission=*/null,
                                     /*scheduler=*/null, RECEIVER_NOT_EXPORTED);
  }

  public static Intent registerNonExportedBroadcastReceiver(Context context,
                                                            BroadcastReceiver receiver,
                                                            IntentFilter filter,
                                                            Handler scheduler) {
    return registerBroadcastReceiver(context, receiver, filter, /*permission=*/null, scheduler,
                                     RECEIVER_NOT_EXPORTED);
  }

  private static Intent registerBroadcastReceiver(Context context, BroadcastReceiver receiver,
                                                  IntentFilter filter, String permission,
                                                  Handler scheduler, int flags) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
      return context.registerReceiver(receiver, filter, permission, scheduler, flags);
    } else {
      return context.registerReceiver(receiver, filter, permission, scheduler);
    }
  }
}
package io.envoyproxy.envoymobile.utilities;

import android.net.TrafficStats;
import android.os.ParcelFileDescriptor;
import android.os.Build;
import android.os.Build.VERSION_CODES;
import android.security.NetworkSecurityPolicy;

import java.io.FileDescriptor;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.SocketImpl;
import java.net.URLConnection;
import java.net.Socket;

import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;

import java.nio.charset.StandardCharsets;

/**
 * This class implements net utilities required by the net component.
 */
public final class AndroidNetworkLibrary {

  private static final String TAG = "AndroidNetworkLibrary";

  private static boolean mUseFakeCertificateVerification;

  /**
   * Whether a fake should be used in place of X509Util. This allows to easily test the JNI
   * call interaction in robolectric tests.
   *
   * @param useFakeCertificateVerification Whether FakeX509Util should be used or not.
   */
  public static synchronized void
  setFakeCertificateVerificationForTesting(boolean useFakeCertificateVerification) {
    mUseFakeCertificateVerification = useFakeCertificateVerification;
  }

  public static synchronized boolean getFakeCertificateVerificationForTesting() {
    return mUseFakeCertificateVerification;
  }

  /**
   * Validate the server's certificate chain is trusted. Note that the caller
   * must still verify the name matches that of the leaf certificate.
   * This is called from native code.
   *
   * @param certChain The ASN.1 DER encoded bytes for certificates.
   * @param authType Bytes representing the UTF-8 encoding of the key exchange algorithm name (e.g.
   *     RSA).
   * @param host Bytes representing the UTF-8 encoding of the hostname of the server.
   * @return Android certificate verification result code.
   */
  public static synchronized AndroidCertVerifyResult verifyServerCertificates(byte[][] certChain,
                                                                              byte[] authTypeBytes,
                                                                              byte[] hostBytes) {
    String authType = new String(authTypeBytes, StandardCharsets.UTF_8);
    String host = new String(hostBytes, StandardCharsets.UTF_8);
    if (mUseFakeCertificateVerification) {
      AndroidCertVerifyResult result =
          FakeX509Util.verifyServerCertificates(certChain, authType, host);
      return result;
    }

    try {
      return X509Util.verifyServerCertificates(certChain, authType, host);
    } catch (KeyStoreException e) {
      return new AndroidCertVerifyResult(CertVerifyStatusAndroid.FAILED);
    } catch (NoSuchAlgorithmException e) {
      return new AndroidCertVerifyResult(CertVerifyStatusAndroid.FAILED);
    } catch (IllegalArgumentException e) {
      return new AndroidCertVerifyResult(CertVerifyStatusAndroid.FAILED);
    }
  }

  /**
   * Adds a test root certificate to the local trust store.
   * This is called from native code.
   *
   * @param rootCert DER encoded bytes of the certificate.
   */
  public static void addTestRootCertificate(byte[] rootCert)
      throws CertificateException, KeyStoreException, NoSuchAlgorithmException {
    if (mUseFakeCertificateVerification) {
      FakeX509Util.addTestRootCertificate(rootCert);
    } else {
      X509Util.addTestRootCertificate(rootCert);
    }
  }

  /**
   * Removes all test root certificates added by |addTestRootCertificate| calls from the local
   * trust store.
   * This is called from native code.
   */
  public static void clearTestRootCertificates()
      throws NoSuchAlgorithmException, CertificateException, KeyStoreException {
    if (mUseFakeCertificateVerification) {
      FakeX509Util.clearTestRootCertificates();
    } else {
      X509Util.clearTestRootCertificates();
    }
  }

  /*
   * Returns true if cleartext traffic to a given host is allowed by the current app.
   */
  public static boolean isCleartextTrafficPermitted(String host) {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
      // This API was not implemented before Android M.
      return true;
    } else if (Build.VERSION.SDK_INT == Build.VERSION_CODES.M) {
      // M only supported global checks.
      return NetworkSecurityPolicy.getInstance().isCleartextTrafficPermitted();
    } else {
      // The host-specific API was implemented in Android N (which came after Android M).
      return NetworkSecurityPolicy.getInstance().isCleartextTrafficPermitted(host);
    }
  }

  /**
   * Class to wrap FileDescriptor.setInt$() which is hidden and so must be accessed via
   * reflection.
   */
  private static class SetFileDescriptor {
    // Reference to FileDescriptor.setInt$(int fd).
    private static final Method sFileDescriptorSetInt;

    // Get reference to FileDescriptor.setInt$(int fd) via reflection.
    static {
      try {
        sFileDescriptorSetInt = FileDescriptor.class.getMethod("setInt$", Integer.TYPE);
      } catch (NoSuchMethodException | SecurityException e) {
        throw new RuntimeException("Unable to get FileDescriptor.setInt$", e);
      }
    }

    /** Creates a FileDescriptor and calls FileDescriptor.setInt$(int fd) on it. */
    public static FileDescriptor createWithFd(int fd) {
      try {
        FileDescriptor fileDescriptor = new FileDescriptor();
        sFileDescriptorSetInt.invoke(fileDescriptor, fd);
        return fileDescriptor;
      } catch (IllegalAccessException e) {
        throw new RuntimeException("FileDescriptor.setInt$() failed", e);
      } catch (InvocationTargetException e) {
        throw new RuntimeException("FileDescriptor.setInt$() failed", e);
      }
    }
  }

  /**
   * This class provides an implementation of {@link java.net.Socket} that serves only as a
   * conduit to pass a file descriptor integer to {@link android.net.TrafficStats#tagSocket}
   * when called by {@link #tagSocket}. This class does not take ownership of the file descriptor,
   * so calling {@link #close} will not actually close the file descriptor.
   */
  private static class SocketFd extends Socket {
    /**
     * This class provides an implementation of {@link java.net.SocketImpl} that serves only as
     * a conduit to pass a file descriptor integer to {@link android.net.TrafficStats#tagSocket}
     * when called by {@link #tagSocket}. This class does not take ownership of the file
     * descriptor, so calling {@link #close} will not actually close the file descriptor.
     */
    private static class SocketImplFd extends SocketImpl {
      /**
       * Create a {@link java.net.SocketImpl} that sets {@code fd} as the underlying file
       * descriptor. Does not take ownership of the file descriptor, so calling {@link #close}
       * will not actually close the file descriptor.
       */
      SocketImplFd(FileDescriptor fd) { this.fd = fd; }

      protected void accept(SocketImpl s) { throw new RuntimeException("accept not implemented"); }
      protected int available() { throw new RuntimeException("accept not implemented"); }
      protected void bind(InetAddress host, int port) {
        throw new RuntimeException("accept not implemented");
      }
      protected void close() {}
      protected void connect(InetAddress address, int port) {
        throw new RuntimeException("connect not implemented");
      }
      protected void connect(SocketAddress address, int timeout) {
        throw new RuntimeException("connect not implemented");
      }
      protected void connect(String host, int port) {
        throw new RuntimeException("connect not implemented");
      }
      protected void create(boolean stream) {}
      protected InputStream getInputStream() {
        throw new RuntimeException("getInputStream not implemented");
      }
      protected OutputStream getOutputStream() {
        throw new RuntimeException("getOutputStream not implemented");
      }
      protected void listen(int backlog) { throw new RuntimeException("listen not implemented"); }
      protected void sendUrgentData(int data) {
        throw new RuntimeException("sendUrgentData not implemented");
      }
      public Object getOption(int optID) {
        throw new RuntimeException("getOption not implemented");
      }
      public void setOption(int optID, Object value) {
        throw new RuntimeException("setOption not implemented");
      }
    }

    /**
     * Create a {@link java.net.Socket} that sets {@code fd} as the underlying file
     * descriptor. Does not take ownership of the file descriptor, so calling {@link #close}
     * will not actually close the file descriptor.
     */
    SocketFd(FileDescriptor fd) throws IOException { super(new SocketImplFd(fd)); }
  }

  /**
   * Tag socket referenced by {@code ifd} with {@code tag} for UID {@code uid}.
   *
   * Assumes thread UID tag isn't set upon entry, and ensures thread UID tag isn't set upon exit.
   * Unfortunately there is no TrafficStatis.getThreadStatsUid().
   */
  private static void tagSocket(int ifd, int uid, int tag) throws IOException {
    // Set thread tags.
    int oldTag = TrafficStats.getThreadStatsTag();
    if (tag != oldTag) {
      TrafficStats.setThreadStatsTag(tag);
    }
    if (uid != -1) {
      ThreadStatsUid.set(uid);
    }

    // Apply thread tags to socket.

    // First, convert integer file descriptor (ifd) to FileDescriptor.
    final ParcelFileDescriptor pfd;
    final FileDescriptor fd;
    // The only supported way to generate a FileDescriptor from an integer file
    // descriptor is via ParcelFileDescriptor.adoptFd(). Unfortunately prior to Android
    // Marshmallow ParcelFileDescriptor.detachFd() didn't actually detach from the
    // FileDescriptor, so use reflection to set {@code fd} into the FileDescriptor for
    // versions prior to Marshmallow. Here's the fix that went into Marshmallow:
    // https://android.googlesource.com/platform/frameworks/base/+/b30ad6f
    if (Build.VERSION.SDK_INT < VERSION_CODES.M) {
      pfd = null;
      fd = SetFileDescriptor.createWithFd(ifd);
    } else {
      pfd = ParcelFileDescriptor.adoptFd(ifd);
      fd = pfd.getFileDescriptor();
    }
    // Second, convert FileDescriptor to Socket.
    Socket s = new SocketFd(fd);
    // Third, tag the Socket.
    TrafficStats.tagSocket(s);
    s.close(); // No-op but always good to close() Closeables.
    // Have ParcelFileDescriptor relinquish ownership of the file descriptor.
    if (pfd != null) {
      pfd.detachFd();
    }

    // Restore prior thread tags.
    if (tag != oldTag) {
      TrafficStats.setThreadStatsTag(oldTag);
    }
    if (uid != -1) {
      ThreadStatsUid.clear();
    }
  }
}
package io.envoyproxy.envoymobile.utilities;

import java.util.HashMap;
import java.util.Map;

/**
 * Class for utilities around Envoy stats.
 */
public class StatsUtils {

  /**
   * Takes in a stats string from engine.dumpStats() and parses it into individual map entries.
   * @param statsString, the string from dumpStats
   * @return a map of stats entries, e.g. "runtime.load_success", "1"
   */
  public static Map<String, String> statsToList(String statsString) {
    Map<String, String> stats = new HashMap<>();

    for (String line : statsString.split("\n")) {
      String[] keyValue = line.split(": ");
      if (keyValue.length != 2) {
        System.out.println("Unexpected stats token");
        continue;
      }
      stats.put(keyValue[0], keyValue[1]);
    }
    return stats;
  }
}
load("@build_bazel_rules_android//android:rules.bzl", "android_library")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@rules_jvm_external//:defs.bzl", "artifact")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

android_library(
    name = "utilities",
    srcs = glob(["*.java"]),
    manifest = "UtilitiesManifest.xml",
    visibility = ["//visibility:public"],
    deps = [
        artifact("androidx.annotation:annotation"),
    ],
)
package io.envoyproxy.envoymobile.utilities;

import android.net.TrafficStats;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * Class to wrap TrafficStats.setThreadStatsUid(int uid) and TrafficStats.clearThreadStatsUid()
 * which are hidden and so must be accessed via reflection.
 */
public class ThreadStatsUid {

  // Reference to TrafficStats.setThreadStatsUid(int uid).
  private static final Method sSetThreadStatsUid;
  // Reference to TrafficStats.clearThreadStatsUid().
  private static final Method sClearThreadStatsUid;
  // Get reference to TrafficStats.setThreadStatsUid(int uid) and
  // TrafficStats.clearThreadStatsUid() via reflection.
  static {
    try {
      sSetThreadStatsUid = TrafficStats.class.getMethod("setThreadStatsUid", Integer.TYPE);
      sClearThreadStatsUid = TrafficStats.class.getMethod("clearThreadStatsUid");
    } catch (NoSuchMethodException | SecurityException e) {
      throw new RuntimeException("Unable to get TrafficStats methods", e);
    }
  }
  /** Calls TrafficStats.setThreadStatsUid(uid) */
  public static void set(int uid) {
    try {
      sSetThreadStatsUid.invoke(null, uid); // Pass null for "this" as it's a static method.
    } catch (IllegalAccessException | InvocationTargetException e) {
      throw new RuntimeException("TrafficStats.setThreadStatsUid failed", e);
    }
  }
  /** Calls TrafficStats.clearThreadStatsUid() */
  public static void clear() {
    try {
      sClearThreadStatsUid.invoke(null); // Pass null for "this" as it's a static method.
    } catch (InvocationTargetException | IllegalAccessException e) {
      throw new RuntimeException("TrafficStats.clearThreadStatsUid failed", e);
    }
  }
}
package io.envoyproxy.envoymobile.utilities;

import java.security.cert.CertificateEncodingException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * The result of a certification verification.
 */
public final class AndroidCertVerifyResult {

  /**
   * The verification status. One of the values in CertVerifyStatusAndroid.
   */
  private final int mStatus;

  /**
   * True if the root CA in the chain is in the system store.
   */
  private final boolean mIsIssuedByKnownRoot;

  /**
   * The properly ordered certificate chain used for verification.
   */
  private final List<X509Certificate> mCertificateChain;

  public AndroidCertVerifyResult(int status, boolean isIssuedByKnownRoot,
                                 List<X509Certificate> certificateChain) {
    mStatus = status;
    mIsIssuedByKnownRoot = isIssuedByKnownRoot;
    mCertificateChain = new ArrayList<X509Certificate>(certificateChain);
  }

  public AndroidCertVerifyResult(int status) {
    mStatus = status;
    mIsIssuedByKnownRoot = false;
    mCertificateChain = Collections.<X509Certificate>emptyList();
  }

  // TODO(stefanoduo): Hook envoy-mobile JNI.
  //@CalledByNative
  public int getStatus() { return mStatus; }

  // TODO(stefanoduo): Hook envoy-mobile JNI.
  //@CalledByNative
  public boolean isIssuedByKnownRoot() { return mIsIssuedByKnownRoot; }

  // TODO(stefanoduo): Hook envoy-mobile JNI.
  //@CalledByNative
  public byte[][] getCertificateChainEncoded() {
    byte[][] verifiedChainArray = new byte[mCertificateChain.size()][];
    try {
      for (int i = 0; i < mCertificateChain.size(); i++) {
        verifiedChainArray[i] = mCertificateChain.get(i).getEncoded();
      }
    } catch (CertificateEncodingException e) {
      return new byte[0][];
    }
    return verifiedChainArray;
  }
}
package io.envoyproxy.envoymobile.engine;

import io.envoyproxy.envoymobile.engine.types.EnvoyNetworkType;

import android.Manifest;
import android.annotation.TargetApi;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.os.Build;
import androidx.annotation.VisibleForTesting;
import androidx.core.content.ContextCompat;

import java.util.Collections;

/**
 * This class makes use of some deprecated APIs, but it's only current purpose is to attempt to
 * distill some notion of a preferred network from the OS, upon which we can assume new sockets will
 * be opened.
 */
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
public class AndroidNetworkMonitor extends BroadcastReceiver {
  private static final String PERMISSION_DENIED_STATS_ELEMENT =
      "android_permissions.network_state_denied";
  private static final int ENVOY_NET_GENERIC = 0;
  private static final int ENVOY_NET_WWAN = 1;
  private static final int ENVOY_NET_WLAN = 2;

  private static volatile AndroidNetworkMonitor instance = null;

  private int previousNetworkType = ConnectivityManager.TYPE_DUMMY;
  private EnvoyEngine envoyEngine;
  private ConnectivityManager connectivityManager;
  private NetworkCallback networkCallback;
  private NetworkRequest networkRequest;

  public static void load(Context context, EnvoyEngine envoyEngine) {
    if (instance != null) {
      return;
    }

    synchronized (AndroidNetworkMonitor.class) {
      if (instance != null) {
        return;
      }
      instance = new AndroidNetworkMonitor(context, envoyEngine);
    }
  }

  private AndroidNetworkMonitor(Context context, EnvoyEngine envoyEngine) {
    int permission =
        ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_NETWORK_STATE);
    if (permission == PackageManager.PERMISSION_DENIED) {
      try {
        envoyEngine.recordCounterInc(PERMISSION_DENIED_STATS_ELEMENT, Collections.emptyMap(), 1);
      } catch (Throwable t) {
        // no-op if this errors out and return
      }
      return;
    }

    this.envoyEngine = envoyEngine;

    connectivityManager =
        (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
    networkRequest = new NetworkRequest.Builder()
                         .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                         .build();

    networkCallback = new NetworkCallback() {
      @Override
      public void onAvailable(Network network) {
        handleNetworkChange();
      }
      @Override
      public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
        handleNetworkChange();
      }
      @Override
      public void onLosing(Network network, int maxMsToLive) {
        handleNetworkChange();
      }
      @Override
      public void onLost(final Network network) {
        handleNetworkChange();
      }
    };

    try {
      connectivityManager.registerNetworkCallback(networkRequest, networkCallback);

      context.registerReceiver(this, new IntentFilter() {
        { addAction(ConnectivityManager.CONNECTIVITY_ACTION); }
      });
    } catch (Throwable t) {
      // no-op
    }
  }

  /** @returns The singleton instance of {@link AndroidNetworkMonitor}. */
  public static AndroidNetworkMonitor getInstance() {
    assert instance != null;
    return instance;
  }

  @Override
  public void onReceive(Context context, Intent intent) {
    handleNetworkChange();
  }

  /** @returns True if there is connectivity */
  public boolean isOnline() { return previousNetworkType != -1; }

  private void handleNetworkChange() {
    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
    int networkType = networkInfo == null ? -1 : networkInfo.getType();
    if (networkType == previousNetworkType) {
      return;
    }
    previousNetworkType = networkType;

    switch (networkType) {
    case ConnectivityManager.TYPE_MOBILE:
      envoyEngine.setPreferredNetwork(EnvoyNetworkType.ENVOY_NETWORK_TYPE_WWAN);
      return;
    case ConnectivityManager.TYPE_WIFI:
      envoyEngine.setPreferredNetwork(EnvoyNetworkType.ENVOY_NETWORK_TYPE_WLAN);
      return;
    default:
      envoyEngine.setPreferredNetwork(EnvoyNetworkType.ENVOY_NETWORK_TYPE_GENERIC);
    }
  }

  /** Expose connectivityManager only for testing */
  @VisibleForTesting
  public ConnectivityManager getConnectivityManager() {
    return connectivityManager;
  }
}
package io.envoyproxy.envoymobile.engine;

import android.annotation.TargetApi;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.Proxy;
import android.net.ProxyInfo;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;

@TargetApi(Build.VERSION_CODES.LOLLIPOP)
class AndroidProxyMonitor extends BroadcastReceiver {
  static volatile AndroidProxyMonitor instance = null;
  private ConnectivityManager connectivityManager;
  private EnvoyEngine envoyEngine;

  static void load(Context context, EnvoyEngine envoyEngine) {
    if (instance != null) {
      return;
    }

    synchronized (AndroidProxyMonitor.class) {
      if (instance != null) {
        return;
      }
      instance = new AndroidProxyMonitor(context, envoyEngine);
    }
  }

  private AndroidProxyMonitor(Context context, EnvoyEngine envoyEngine) {
    this.envoyEngine = envoyEngine;
    this.connectivityManager =
        (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
    // PROXY_INFO is not guaranteed to be a sticky intent so we need to trigger
    // a manual poll of proxy settings. Proxy settings received as a result of PROXY_INFO
    // intent updates should take precedence/override locally polled settings,
    // hence we trigger a manual proxy settings poll before we subscribe to PROXY_INFO intent
    // updates.
    handleProxyChange(null);
    registerReceiver(context);
  }

  private void registerReceiver(Context context) {
    context.getApplicationContext().registerReceiver(this, new IntentFilter() {
      { addAction(Proxy.PROXY_CHANGE_ACTION); }
    });
  }

  @Override
  public void onReceive(Context context, Intent intent) {
    handleProxyChange(intent);
  }

  private void handleProxyChange(final Intent intent) {
    ProxyInfo info = this.extractProxyInfo(intent);

    if (info == null) {
      envoyEngine.setProxySettings("", 0);
    } else {
      envoyEngine.setProxySettings(info.getHost(), info.getPort());
    }
  }

  private ProxyInfo extractProxyInfo(final Intent intent) {
    ProxyInfo info = connectivityManager.getDefaultProxy();
    if (info == null) {
      return null;
    }

    // If a proxy is configured using the PAC file use
    // Android's injected localhost HTTP proxy.
    //
    // Android's injected localhost proxy can be accessed using a proxy host
    // equal to `localhost` and a proxy port retrieved from intent's 'extras'.
    // We cannot take a proxy port from the ProxyInfo object that's exposed by
    // the connectivity manager as it's always equal to -1 for cases when PAC
    // proxy is configured.
    //
    // See https://github.com/envoyproxy/envoy-mobile/issues/2531 for more details.
    if (info.getPacFileUrl() != null && info.getPacFileUrl() != Uri.EMPTY) {
      if (intent == null) {
        // PAC proxies are supported only when Intent is present
        return null;
      }

      Bundle extras = intent.getExtras();
      if (extras == null) {
        return null;
      }

      info = (ProxyInfo)extras.get("android.intent.extra.PROXY_INFO");
    }

    return info;
  }
}
package io.envoyproxy.envoymobile.engine;

/**
 * This interface exists solely to scope the types accepted by EnvoyNativeResourceRegistry.
 *
 * Implemented by objects that require a native resource to be tied to their lifecycle.
 */
interface EnvoyNativeResourceWrapper {}
package io.envoyproxy.envoymobile.engine;

import io.envoyproxy.envoymobile.engine.types.EnvoyEventTracker;
import io.envoyproxy.envoymobile.engine.types.EnvoyLogger;
import io.envoyproxy.envoymobile.engine.types.EnvoyOnEngineRunning;
import java.nio.ByteBuffer;

public class JniLibrary {

  private static String envoyLibraryName = "envoy_jni";

  // Internal reference to helper object used to load and initialize the native
  // library.
  // Volatile to ensure double-checked locking works correctly.
  private static volatile JavaLoader loader = null;

  // Load test libraries based on the jvm_flag `envoy_jni_library_name`.
  // WARNING: This should only be used for testing.
  public static void loadTestLibrary() {
    if (System.getProperty("envoy_jni_library_name") != null) {
      envoyLibraryName = System.getProperty("envoy_jni_library_name");
    }
  }

  // Load and initialize Envoy and its dependencies, but only once.
  public static void load() {
    if (loader != null) {
      return;
    }

    synchronized (JavaLoader.class) {
      if (loader != null) {
        return;
      }

      loader = new JavaLoader();
    }
  }

  // Private helper class used by the load method to ensure the native library and
  // its
  // dependencies are loaded and initialized at most once.
  private static class JavaLoader {
    private JavaLoader() { System.loadLibrary(envoyLibraryName); }
  }

  /**
   * Initialize an underlying HTTP stream.
   *
   * @param engine, handle to the engine that will manage this stream.
   * @return long, handle to the underlying stream.
   */
  protected static native long initStream(long engine);

  /**
   * Open an underlying HTTP stream. Note: Streams must be started before other
   * other interaction can can occur.
   *
   * @param engine,  handle to the stream's associated engine.
   * @param stream,  handle to the stream to be started.
   * @param context, context that contains dispatch logic to fire callbacks
   *                 callbacks.
   * @param explicitFlowControl, whether explicit flow control should be enabled
   *                             for the stream.
   * @return envoy_stream, with a stream handle and a success status, or a failure
   * status.
   */
  protected static native int startStream(long engine, long stream, JvmCallbackContext context,
                                          boolean explicitFlowControl);

  /**
   * Send headers over an open HTTP stream. This method can be invoked once and
   * needs to be called before send_data.
   *
   * @param engine,    the stream's associated engine.
   * @param stream,    the stream to send headers over.
   * @param headers,   the headers to send.
   * @param endStream, supplies whether this is headers only.
   * @return int, the resulting status of the operation.
   */
  protected static native int sendHeaders(long engine, long stream, byte[][] headers,
                                          boolean endStream);

  /**
   * Send data over an open HTTP stream. This method can be invoked multiple
   * times.
   *
   * @param engine,    the stream's associated engine.
   * @param stream,    the stream to send data over.
   * @param data,      the data to send.
   * @param length,    the size in bytes of the data to send. 0 <= length <= data.length
   * @param endStream, supplies whether this is the last data in the stream.
   * @return int,      the resulting status of the operation.
   */
  protected static native int sendDataByteArray(long engine, long stream, byte[] data, int length,
                                                boolean endStream);

  /**
   * Send data over an open HTTP stream. This method can be invoked multiple
   * times.
   *
   * @param engine,    the stream's associated engine.
   * @param stream,    the stream to send data over.
   * @param data,      the data to send; must be a <b>direct</b> ByteBuffer.
   * @param length,    the size in bytes of the data to send. 0 <= length <= data.capacity()
   * @param endStream, supplies whether this is the last data in the stream.
   * @return int,      the resulting status of the operation.
   */
  protected static native int sendData(long engine, long stream, ByteBuffer data, int length,
                                       boolean endStream);

  /**
   * Read data from the response stream. Returns immediately.
   * Has no effect if explicit flow control is not enabled.
   *
   * @param engine,    the stream's associated engine.
   * @param stream,    the stream.
   * @param byteCount, Maximum number of bytes that may be be passed by the next data callback.
   * @return int, the resulting status of the operation.
   */
  protected static native int readData(long engine, long stream, long byteCount);

  /**
   * Send trailers over an open HTTP stream. This method can only be invoked once
   * per stream. Note that this method implicitly ends the stream.
   *
   * @param engine,   the stream's associated engine.
   * @param stream,   the stream to send trailers over.
   * @param trailers, the trailers to send.
   * @return int, the resulting status of the operation.
   */
  protected static native int sendTrailers(long engine, long stream, byte[][] trailers);

  /**
   * Detach all callbacks from a stream and send an interrupt upstream if
   * supported by transport.
   *
   * @param engine, the stream's associated engine.
   * @param stream, the stream to evict.
   * @return int, the resulting status of the operation.
   */
  protected static native int resetStream(long engine, long stream);

  /**
   * Register a factory for creating platform filter instances for each HTTP stream.
   *
   * @param filterName, unique name identifying this filter in the chain.
   * @param context,    context containing logic necessary to invoke a new filter instance.
   * @return int, the resulting status of the operation.
   */
  protected static native int registerFilterFactory(String filterName,
                                                    JvmFilterFactoryContext context);

  // Native entry point

  /**
   * Initialize an engine for handling network streams.
   *
   * @param runningCallback, called when the engine finishes its async startup and begins running.
   * @param logger,          the logging interface.
   * @param eventTracker     the event tracking interface.
   * @return envoy_engine_t, handle to the underlying engine.
   */
  protected static native long initEngine(EnvoyOnEngineRunning runningCallback, EnvoyLogger logger,
                                          EnvoyEventTracker eventTracker);

  /**
   * External entry point for library.
   *
   * This should be run either with a non-empty config, or a non-zero bootstrap.
   * If a bootstrap pointer is passed, the engine will take ownership of the proto.
   *
   * @param engine,          the engine to run.
   * @param config,          the configuration blob to run envoy with.
   * @param bootstrap,       a bootstrap pointer generated by createBootstrap, or 0 to use config.
   * @param logLevel,        the logging level to run envoy with.
   * @return int, the resulting status of the operation.
   */
  protected static native int runEngine(long engine, String config, long bootstrap,
                                        String logLevel);

  /**
   * Terminate the engine.
   *
   * @param engine handle for the engine to terminate.
   */
  protected static native void terminateEngine(long engine);

  // Other native methods

  /**
   * Increment a counter with the given count.
   *
   * @param engine,  handle to the engine that owns the counter.
   * @param elements Elements of the counter stat.
   * @param tags Tags of the counter.
   * @param count Amount to add to the counter.
   * @return A status indicating if the action was successful.
   */
  protected static native int recordCounterInc(long engine, String elements, byte[][] tags,
                                               int count);

  /**
   * Retrieve the value of all active stats. Note that this function may block for some time.
   * @param engine,  handle to the engine that owns the counter.
   * @return The list of active stats and their values, or empty string of the operation failed
   */
  protected static native String dumpStats(long engine);

  /**
   * Register a platform-provided key-value store implementation.
   *
   * @param name,    unique name identifying this key-value store.
   * @param context, context containing logic necessary to invoke the key-value store.
   * @return int,    the resulting status of the operation.
   */
  protected static native int registerKeyValueStore(String name, JvmKeyValueStoreContext context);

  /**
   * Register a string accessor to get strings from the platform.
   *
   * @param accessorName, unique name identifying this accessor.
   * @param context,      context containing logic necessary to invoke the accessor.
   * @return int, the resulting status of the operation.
   */
  protected static native int registerStringAccessor(String accessorName,
                                                     JvmStringAccessorContext context);

  /**
   * Refresh DNS, and drain connections owned by this Engine.
   *
   * @param engine Handle to the engine for which to drain connections.
   */
  protected static native int resetConnectivityState(long engine);

  /**
   * Update the network interface to the preferred network for opening new
   * streams. Note that this state is shared by all engines.
   *
   * @param engine  Handle to the engine whose preferred network will be set.
   * @param network the network to be preferred for new streams.
   * @return The resulting status of the operation.
   */
  protected static native int setPreferredNetwork(long engine, int network);

  /**
   * Update the proxy settings.
   *
   * @param engine Handle to the engine whose proxy settings should be updated.
   * @param host The proxy host.
   * @param port The proxy port.
   * @return The resulting status of the operation.
   */
  protected static native int setProxySettings(long engine, String host, int port);

  /**
   * Update the log level for all active logs
   *
   * @param log_level The Log level to change to. Must be an integer 0-6.
   */
  protected static native void setLogLevel(int log_level);

  /**
   * Mimic a call to AndroidNetworkLibrary#verifyServerCertificates from native code.
   * To be used for testing only.
   *
   * @param certChain The ASN.1 DER encoded bytes for certificates.
   * @param authType The key exchange algorithm name (e.g. RSA).
   * @param host The hostname of the server.
   * @return Android certificate verification result code.
   */
  public static native Object callCertificateVerificationFromNative(byte[][] certChain,
                                                                    byte[] authType, byte[] host);
  /**
   * Mimic a call to AndroidNetworkLibrary#addTestRootCertificate from native code.
   * To be used for testing only.
   *
   * @param rootCert DER encoded bytes of the certificate.
   */
  public static native void callAddTestRootCertificateFromNative(byte[] cert);

  /**
   * Mimic a call to AndroidNetworkLibrary#clearTestRootCertificate from native code.
   * To be used for testing only.
   *
   */
  public static native void callClearTestRootCertificateFromNative();

  /**
   * Uses the provided fields to generate an Envoy bootstrap proto.
   * The returned pointer is "owned" by the caller until ownership is passed back to C++ via
   * runEngine.
   *
   * Returns a pointer to the bootstrap that can be used to run the engine.
   *
   */
  public static native long createBootstrap(
      long connectTimeoutSeconds, long dnsRefreshSeconds, long dnsFailureRefreshSecondsBase,
      long dnsFailureRefreshSecondsMax, long dnsQueryTimeoutSeconds, long dnsMinRefreshSeconds,
      byte[][] dnsPreresolveHostnames, boolean enableDNSCache, long dnsCacheSaveIntervalSeconds,
      boolean enableDrainPostDnsRefresh, boolean enableHttp3, String http3ConnectionOptions,
      String http3ClientConnectionOptions, byte[][] quicHints, byte[][] quicCanonicalSuffixes,
      boolean enableGzipDecompression, boolean enableBrotliDecompression,
      boolean enableSocketTagging, boolean enableInterfaceBinding,
      long h2ConnectionKeepaliveIdleIntervalMilliseconds, long h2ConnectionKeepaliveTimeoutSeconds,
      long maxConnectionsPerHost, long streamIdleTimeoutSeconds, long perTryIdleTimeoutSeconds,
      String appVersion, String appId, boolean trustChainVerification, byte[][] filterChain,
      boolean enablePlatformCertificatesValidation, byte[][] runtimeGuards, String rtdsResourceName,
      long rtdsTimeoutSeconds, String xdsAddress, long xdsPort, byte[][] xdsGrpcInitialMetadata,
      String xdsRootCerts, String nodeId, String nodeRegion, String nodeZone, String nodeSubZone,
      byte[] nodeMetadata, String cdsResourcesLocator, long cdsTimeoutSeconds, boolean enableCds);
}
package io.envoyproxy.envoymobile.engine;

public interface EnvoyNativeResourceReleaser {

  /**
   * Release a native resource held by a Java object.
   *
   * @param @nativeHandle, JNI identifier for the native resource.
   */
  public void release(long nativeHandle);
}
package io.envoyproxy.envoymobile.engine;

import io.envoyproxy.envoymobile.engine.types.EnvoyStringAccessor;
import java.nio.charset.StandardCharsets;

class JvmStringAccessorContext {
  private final EnvoyStringAccessor accessor;

  public JvmStringAccessorContext(EnvoyStringAccessor accessor) { this.accessor = accessor; }

  /**
   * Invokes getEnvoyString callback. This method signature is used within the jni_impl.cc.
   * Changing naming of this class or methods will likely require an audit across the jni usages
   * and proguard rules.
   *
   * @return byte[], the string retrieved from the platform.
   */
  public byte[] getEnvoyString() {
    // This class returns a byte[] instead of a String because dealing with Java Strings in the
    // JNI is a bit finicky.
    return accessor.getEnvoyString().getBytes(StandardCharsets.UTF_8);
  }
}
package io.envoyproxy.envoymobile.engine.types;

public interface EnvoyKeyValueStore {
  /**
   * Read a value from the key value store implementation.
   *
   * @param key,     key identifying the value to be returned.
   * @return String, value mapped to the key, or null if not present.
   */
  String read(String key);

  /**
   * Remove a value from the key value store implementation.
   *
   * @param key,     key identifying the value to be removed.
   */
  void remove(String key);

  /**
   * Save a value to the key value store implementation.
   *
   * @param key,     key identifying the value to be saved.
   * @param value,   the value to be saved.
   */
  void save(String key, String value);
}
package io.envoyproxy.envoymobile.engine.types;

import java.util.Map;

public interface EnvoyEventTracker {
  void track(Map<String, String> events);
}
package io.envoyproxy.envoymobile.engine.types;

/**
 * Exposes internal HTTP stream metrics, context, and other details sent once on stream end.
 *
 * Note: a value of -1 means "not present" for any field where the name is suffixed with "Ms".
 */
public interface EnvoyFinalStreamIntel {
  /*
   * The time the stream started (a.k.a request started), in ms since the epoch.
   */
  public long getStreamStartMs();
  /*
   * The time the DNS resolution for this request started, in ms since the epoch.
   */
  public long getDnsStartMs();
  /*
   * The time the DNS resolution for this request completed, in ms since the epoch.
   */
  public long getDnsEndMs();
  /*
   * The time the upstream connection started, in ms since the epoch.
   * This may not be set if socket_reused is false.
   */
  public long getConnectStartMs();
  /*
   * The time the upstream connection completed, in ms since the epoch.
   * This may not be set if socket_reused is false.
   */
  public long getConnectEndMs();
  /*
   * The time the SSL handshake started, in ms since the epoch.
   * This may not be set if socket_reused is false.
   */
  public long getSslStartMs();
  /*
   * The time the SSL handshake completed, in ms since the epoch.
   * This may not be set if socket_reused is false.
   */
  public long getSslEndMs();
  /*
   * The time the first byte of the request was sent upstream, in ms since the epoch.
   */
  public long getSendingStartMs();
  /*
   * The time the last byte of the request was sent upstream, in ms since the epoch.
   */
  public long getSendingEndMs();
  /*
   * The time the first byte of the response was received, in ms since the epoch.
   */
  public long getResponseStartMs();
  /*
   * The time when the stream reached a final state (Error, Cancel, Success), in ms since the epoch.
   */
  public long getStreamEndMs();
  /*
   * True if the upstream socket had been used previously.
   */
  public boolean getSocketReused();
  /*
   * The number of bytes sent upstream.
   */
  public long getSentByteCount();
  /*
   * The number of bytes received from upstream.
   */
  public long getReceivedByteCount();
  /*
   * The response flags for the stream. See
   * https://github.com/envoyproxy/envoy/blob/main/envoy/stream_info/stream_info.h#L39
   * for values.
   */
  public long getResponseFlags();

  /* The protocol for the upstream stream, if one was established, else -1 See
   * https://github.com/envoyproxy/envoy/blob/main/envoy/http/protocol.h#L39 for values. */
  public long getUpstreamProtocol();
}
package io.envoyproxy.envoymobile.engine.types;

import java.nio.ByteBuffer;
import java.util.concurrent.Executor;
import java.util.List;
import java.util.Map;

public interface EnvoyHTTPFilter {
  /**
   * Called when request headers are sent on the HTTP stream.
   *
   * @param headers,     the headers received.
   * @param endStream,   whether the response is headers-only.
   * @param streamIntel, contains internal HTTP stream metrics, context, and other details.
   */
  Object[] onRequestHeaders(Map<String, List<String>> headers, boolean endStream,
                            EnvoyStreamIntel streamIntel);

  /**
   * Called when a request data frame is sent on the HTTP stream. This
   * callback can be invoked multiple times.
   *
   * @param data,        the buffer of the data received.
   * @param endStream,   whether the data is the last data frame.
   * @param streamIntel, contains internal HTTP stream metrics, context, and other details.
   */
  Object[] onRequestData(ByteBuffer data, boolean endStream, EnvoyStreamIntel streamIntel);

  /**
   * Called when request trailers are sent on the HTTP stream.
   *
   * @param trailers,    the trailers received.
   * @param streamIntel, contains internal HTTP stream metrics, context, and other details.
   */
  Object[] onRequestTrailers(Map<String, List<String>> trailers, EnvoyStreamIntel streamIntel);

  /**
   * Called when response headers are received on the HTTP stream.
   *
   * @param headers,     the headers received.
   * @param endStream,   whether the response is headers-only.
   * @param streamIntel, contains internal HTTP stream metrics, context, and other details.
   */
  Object[] onResponseHeaders(Map<String, List<String>> headers, boolean endStream,
                             EnvoyStreamIntel streamIntel);

  /**
   * Called when a data frame is received on the HTTP stream. This
   * callback can be invoked multiple times.
   *
   * @param data,        the buffer of the data received.
   * @param endStream,   whether the data is the last data frame.
   * @param streamIntel, contains internal HTTP stream metrics, context, and other details.
   */
  Object[] onResponseData(ByteBuffer data, boolean endStream, EnvoyStreamIntel streamIntel);

  /**
   * Called when response trailers are received on the HTTP stream.
   *
   * @param trailers,    the trailers received.
   * @param streamIntel, contains internal HTTP stream metrics, context, and other details.
   */
  Object[] onResponseTrailers(Map<String, List<String>> trailers, EnvoyStreamIntel streamIntel);

  /**
   * Provides asynchronous callbacks to implementations that elect to use them.
   *
   * @param callbacks, thread-safe internal callbacks that enable asynchronous filter interaction.
   */
  void setRequestFilterCallbacks(EnvoyHTTPFilterCallbacks callbacks);

  /**
   * Called when request filter iteration has been asynchronsouly resumed via callback.
   *
   * @param headers,     pending headers that have not yet been forwarded along the filter chain.
   * @param data,        pending data that has not yet been forwarded along the filter chain.
   * @param trailers,    pending trailers that have not yet been forwarded along the filter chain.
   * @param streamIntel, contains internal HTTP stream metrics, context, and other details.
   */
  Object[] onResumeRequest(Map<String, List<String>> headers, ByteBuffer data,
                           Map<String, List<String>> trailers, boolean endStream,
                           EnvoyStreamIntel streamIntel);

  /**
   * Provides asynchronous callbacks to implementations that elect to use them.
   *
   * @param callbacks, thread-safe internal callbacks that enable asynchronous filter interaction.
   */
  void setResponseFilterCallbacks(EnvoyHTTPFilterCallbacks callbacks);

  /**
   * Called when response filter iteration has been asynchronsouly resumed via callback.
   *
   * @param headers,     pending headers that have not yet been forwarded along the filter chain.
   * @param data,        pending data that has not yet been forwarded along the filter chain.
   * @param trailers,    pending trailers that have not yet been forwarded along the filter chain.
   * @param streamIntel, contains internal HTTP stream metrics, context, and other details.
   */
  Object[] onResumeResponse(Map<String, List<String>> headers, ByteBuffer data,
                            Map<String, List<String>> trailers, boolean endStream,
                            EnvoyStreamIntel streamIntel);

  /**
   * Called when the async HTTP stream has an error.
   *
   * @param errorCode,    the error code.
   * @param message,      the error message.
   * @param attemptCount, the number of times an operation was attempted before firing this error.
   *                      -1 is used in scenarios where it does not make sense to have an attempt
   *                      count for an error. This is different from 0, which intentionally conveys
   *                      that the action was _not_ executed.
   * @param streamIntel,  contains internal HTTP stream metrics, context, and other details.
   * @param finalStreamIntel,  contains final internal HTTP stream metrics, context, and other
   *     details.
   */
  void onError(int errorCode, String message, int attemptCount, EnvoyStreamIntel streamIntel,
               EnvoyFinalStreamIntel finalStreamIntel);

  /**
   * Called when the async HTTP stream is canceled.
   *
   * @param streamIntel,  contains internal HTTP stream metrics, context, and other details.
   * @param finalStreamIntel, contains final internal HTTP stream metrics, context, and other
   *     details.
   */
  void onCancel(EnvoyStreamIntel streamIntel, EnvoyFinalStreamIntel finalSteamIntel);

  /**
   * Called when the async HTTP stream is complete.
   *
   * @param streamIntel,  contains internal HTTP stream metrics, context, and other details.
   * @param finalStreamIntel, contains final internal HTTP stream metrics, context, and other
   *     details.
   */
  void onComplete(EnvoyStreamIntel streamIntel, EnvoyFinalStreamIntel finalSteamIntel);
}
package io.envoyproxy.envoymobile.engine.types;

/**
 * Callbacks for asynchronous interaction with the filter.
 */
public interface EnvoyHTTPFilterCallbacks {
  /**
   * Resume filter iteration asynchronously. This will result in an on-resume invocation of the
   * filter.
   */
  void resumeIteration();

  /**
   * Reset the underlying stream idle timeout to its configured threshold. This may be useful if
   * a filter stops iteration for an extended period of time, since ordinarily timeouts will still
   * apply. This may be called periodically to continue to indicate "activity" on the stream.
   */
  void resetIdleTimer();
}
package io.envoyproxy.envoymobile.engine.types;

// Network interface type
public enum EnvoyNetworkType {
  // WWAN
  ENVOY_NETWORK_TYPE_WWAN,
  // WLAN
  ENVOY_NETWORK_TYPE_WLAN,
  // GENERIC
  ENVOY_NETWORK_TYPE_GENERIC;
}
package io.envoyproxy.envoymobile.engine.types;

import java.nio.ByteBuffer;
import java.util.concurrent.Executor;
import java.util.List;
import java.util.Map;

public interface EnvoyHTTPCallbacks {

  Executor getExecutor();

  /**
   * Called when all headers get received on the async HTTP stream.
   *
   * @param headers,     the headers received.
   * @param endStream,   whether the response is headers-only.
   * @param streamIntel, contains internal HTTP stream metrics, context, and other details.
   */
  void onHeaders(Map<String, List<String>> headers, boolean endStream,
                 EnvoyStreamIntel streamIntel);

  /**
   * Called when a data frame gets received on the async HTTP stream. This
   * callback can be invoked multiple times if the data gets streamed.
   *
   * @param data,        the buffer of the data received.
   * @param endStream,   whether the data is the last data frame.
   * @param streamIntel, contains internal HTTP stream metrics, context, and other details.
   */
  void onData(ByteBuffer data, boolean endStream, EnvoyStreamIntel streamIntel);

  /**
   * Called when all trailers get received on the async HTTP stream. Note that end
   * stream is implied when on_trailers is called.
   *
   * @param trailers,    the trailers received.
   * @param streamIntel, contains internal HTTP stream metrics, context, and other details.
   */
  void onTrailers(Map<String, List<String>> trailers, EnvoyStreamIntel streamIntel);

  /**
   * Called when the async HTTP stream has an error.
   *
   * @param errorCode,    the error code.
   * @param message,      the error message.
   * @param attemptCount, the number of times an operation was attempted before firing this error.
   *                      -1 is used in scenarios where it does not make sense to have an attempt
   *                      count for an error. This is different from 0, which intentionally conveys
   *                      that the action was _not_ executed.
   * @param streamIntel,  contains internal HTTP stream metrics, context, and other details.
   * @param finalStreamIntel,  contains final internal HTTP stream metrics, context, and other
   *     details.
   */
  void onError(int errorCode, String message, int attemptCount, EnvoyStreamIntel streamIntel,
               EnvoyFinalStreamIntel finalStreamIntel);

  /**
   * Called when the async HTTP stream is canceled.
   * @param streamIntel,  contains internal HTTP stream metrics, context, and other details.
   * @param finalStreamIntel,  contains final internal HTTP stream metrics, context, and other
   *     details.
   */
  void onCancel(EnvoyStreamIntel streamIntel, EnvoyFinalStreamIntel finalStreamIntel);

  /**
   * Called to signal there is buffer space available for continued request body upload.
   *
   * This is only ever called when the library is in explicit flow control mode. When enabled,
   * the issuer should wait for this callback after calling sendData, before making another call
   * to sendData.
   *
   * @param streamIntel,  contains internal HTTP stream metrics, context, and other details.
   */
  void onSendWindowAvailable(EnvoyStreamIntel streamIntel);

  /**
   * Called once after the final data for the stream has been received.
   *
   * @param streamIntel,  contains internal HTTP stream metrics, context, and other details.
   * @param finalStreamIntel,  contains final internal HTTP stream metrics.
   */
  void onComplete(EnvoyStreamIntel streamIntel, EnvoyFinalStreamIntel finalStreamIntel);
}
package io.envoyproxy.envoymobile.engine.types;

public interface EnvoyHTTPFilterFactory {

  String getFilterName();

  EnvoyHTTPFilter create();
}
package io.envoyproxy.envoymobile.engine.types;

/**
 * Exposes internal HTTP stream metrics, context, and other details.
 */
public interface EnvoyStreamIntel {

  /**
   * An internal identifier for the stream.
   */
  public long getStreamId();

  /**
   * An internal identifier for the connection carrying the stream.
   */
  public long getConnectionId();

  /**
   * The number of internal attempts to carry out a request/operation.
   */
  public long getAttemptCount();

  /**
   * The number of bytes consumed by the non terminal callbacks, from the response.
   *
   * <p>>NOTE: on terminal callbacks (on_complete, on_error_, on_cancel), this value will not be
   * equal to {@link EnvoyFinalStreamIntel#getReceivedByteCount()}. The latter represents the real
   * number of bytes received before decompression. getConsumedBytesFromResponse() omits the number
   * number of bytes related to the Status Line, and is after decompression.
   */
  public long getConsumedBytesFromResponse();
}
package io.envoyproxy.envoymobile.engine.types;

public interface EnvoyStringAccessor {

  /**
   * Called to retrieve a string from the Application
   */
  String getEnvoyString();
}
package io.envoyproxy.envoymobile.engine.types;

public enum EnvoyStatus { ENVOY_SUCCESS, ENVOY_FAILURE }
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@rules_java//java:defs.bzl", "java_library")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

java_library(
    name = "envoy_c_types_lib",
    srcs = [
        "EnvoyEventTracker.java",
        "EnvoyFinalStreamIntel.java",
        "EnvoyHTTPCallbacks.java",
        "EnvoyHTTPFilter.java",
        "EnvoyHTTPFilterCallbacks.java",
        "EnvoyHTTPFilterFactory.java",
        "EnvoyKeyValueStore.java",
        "EnvoyLogger.java",
        "EnvoyNetworkType.java",
        "EnvoyOnEngineRunning.java",
        "EnvoyStatus.java",
        "EnvoyStreamIntel.java",
        "EnvoyStringAccessor.java",
    ],
    visibility = ["//visibility:public"],
)
package io.envoyproxy.envoymobile.engine.types;

/* Interface used to support lambdas being passed from Kotlin for engine setup completion. */
public interface EnvoyOnEngineRunning {
  Object invokeOnEngineRunning();
}
package io.envoyproxy.envoymobile.engine.types;

public interface EnvoyLogger {
  void log(String str);
}
package io.envoyproxy.envoymobile.engine;

import java.nio.charset.StandardCharsets;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Class to assist with passing types from the JVM to native code. Currently supports
 * HTTP headers.
 */
public final class JniBridgeUtility {

  private JniBridgeUtility() {}

  public static byte[][] toJniHeaders(Map<String, List<String>> headers) {
    // Perform no conversion on null headers.
    if (headers == null) {
      return null;
    }

    // Create array with some room for potential headers that have more than one
    // value.
    final List<byte[]> convertedHeaders = new ArrayList<byte[]>(2 * headers.size());
    for (Map.Entry<String, List<String>> entry : headers.entrySet()) {
      for (String value : entry.getValue()) {
        convertedHeaders.add(entry.getKey().getBytes(StandardCharsets.UTF_8));
        convertedHeaders.add(value.getBytes(StandardCharsets.UTF_8));
      }
    }
    return convertedHeaders.toArray(new byte[0][0]);
  }

  public static byte[][] toJniBytes(List<EnvoyNativeFilterConfig> nativeFilterChain) {
    final List<byte[]> convertedBytes = new ArrayList<byte[]>(nativeFilterChain.size());
    for (EnvoyNativeFilterConfig filter : nativeFilterChain) {
      convertedBytes.add(filter.name.getBytes(StandardCharsets.UTF_8));
      convertedBytes.add(filter.typedConfig.getBytes(StandardCharsets.UTF_8));
    }
    return convertedBytes.toArray(new byte[0][0]);
  }

  public static byte[][] stringsToJniBytes(List<String> stringList) {
    final List<byte[]> convertedBytes = new ArrayList<byte[]>(stringList.size());
    for (String str : stringList) {
      convertedBytes.add(str.getBytes(StandardCharsets.UTF_8));
    }
    return convertedBytes.toArray(new byte[0][0]);
  }

  public static byte[][] mapToJniBytes(Map<String, String> stringMap) {
    final List<byte[]> convertedBytes = new ArrayList<byte[]>(stringMap.size() * 2);
    for (Map.Entry<String, String> entry : stringMap.entrySet()) {
      convertedBytes.add(entry.getKey().getBytes(StandardCharsets.UTF_8));
      convertedBytes.add(entry.getValue().getBytes(StandardCharsets.UTF_8));
    }
    return convertedBytes.toArray(new byte[0][0]);
  }

  public static byte[][] toJniTags(Map<String, String> tags) {
    if (tags == null) {
      return null;
    }
    final List<byte[]> convertedTags = new ArrayList<byte[]>(2 * tags.size());
    for (Map.Entry<String, String> tag : tags.entrySet()) {
      convertedTags.add(tag.getKey().getBytes(StandardCharsets.UTF_8));
      convertedTags.add(tag.getValue().getBytes(StandardCharsets.UTF_8));
    }
    return convertedTags.toArray(new byte[0][0]);
  }
}
package io.envoyproxy.envoymobile.engine;

import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;
import io.envoyproxy.envoymobile.engine.types.EnvoyNetworkType;
import io.envoyproxy.envoymobile.engine.types.EnvoyStringAccessor;
import io.envoyproxy.envoymobile.engine.types.EnvoyStatus;

import java.util.Map;

/* Wrapper layer for calling into Envoy's C/++ API. */
public interface EnvoyEngine {
  /**
   * Creates a new stream with the provided callbacks.
   *
   * @param callbacks The callbacks for receiving callbacks from the stream.
   * @param explicitFlowControl Whether explicit flow control will be enabled for this stream.
   * @return A stream that may be used for sending data.
   */
  EnvoyHTTPStream startStream(EnvoyHTTPCallbacks callbacks, boolean explicitFlowControl);

  /**
   * Terminates the running engine.
   */
  void terminate();

  /**
   * Performs any registrations necessary before running Envoy.
   *
   * The envoyConfiguration is used to determined what to register.
   *
   * @param envoyConfiguration The EnvoyConfiguration used to start Envoy.
   */
  void performRegistration(EnvoyConfiguration envoyConfiguration);

  /**
   * Run the Envoy engine with the provided yaml string and log level.
   *
   * This does not perform registration, and performRegistration() may need to be called first.
   *
   * @param configurationYAML The configuration yaml with which to start Envoy.
   * @param logLevel          The log level to use when starting Envoy.
   * @return A status indicating if the action was successful.
   */
  EnvoyStatus runWithYaml(String configurationYAML, String logLevel);

  /**
   * Run the Envoy engine with the provided EnvoyConfiguration and log level.
   *
   * This automatically performs any necessary registrations.
   *
   * @param envoyConfiguration The EnvoyConfiguration used to start Envoy.
   * @param logLevel           The log level to use when starting Envoy.
   * @return A status indicating if the action was successful.
   */
  EnvoyStatus runWithConfig(EnvoyConfiguration envoyConfiguration, String logLevel);

  /**
   * Increments a counter with the given count.
   *
   * @param elements Elements of the counter stat.
   * @param tags     Tags of the counter stat.
   * @param count    Amount to add to the counter.
   * @return A status indicating if the action was successful.
   */
  int recordCounterInc(String elements, Map<String, String> tags, int count);

  int registerStringAccessor(String accessor_name, EnvoyStringAccessor accessor);

  String dumpStats();

  /**
   * Refresh DNS, and drain connections owned by this Engine.
   */
  void resetConnectivityState();

  /**
   * Update the network interface to the preferred network for opening new
   * streams.
   *
   * @param network The network to be preferred for new streams.
   */
  void setPreferredNetwork(EnvoyNetworkType network);

  /**
   * Update proxy settings.
   *
   * @param host The proxy host defined as a hostname or an IP address. Android
   *             allow users to specify proxy using either one of these.
   * @param port The proxy port.
   */
  void setProxySettings(String host, int port);

  /*
   * These are the available log levels for Envoy Mobile.
   */
  public enum LogLevel { TRACE, DEBUG, INFO, WARN, ERR, CRITICAL, OFF }

  /**
   * Set the log level for Envoy mobile
   *
   * @param log_level the verbosity of logging Envoy should use.
   */
  public void setLogLevel(LogLevel log_level);
}
package io.envoyproxy.envoymobile.engine;

import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;

import java.nio.charset.StandardCharsets;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class EnvoyHTTPStream {
  private final long engineHandle;
  private final long streamHandle;
  private final boolean explicitFlowControl;
  private final JvmCallbackContext callbacksContext;

  /**
   * Start the stream via the JNI library.
   */
  void start() {
    JniLibrary.startStream(engineHandle, streamHandle, callbacksContext, explicitFlowControl);
  }

  /**
   * Initialize a new stream.
   * @param engineHandle Underlying handle of the Envoy engine.
   * @param streamHandle Underlying handle of the HTTP stream owned by an Envoy engine.
   * @param callbacks The callbacks for the stream.
   * @param explicitFlowControl Whether explicit flow control will be enabled for this stream.
   */
  public EnvoyHTTPStream(long engineHandle, long streamHandle, EnvoyHTTPCallbacks callbacks,
                         boolean explicitFlowControl) {
    this.engineHandle = engineHandle;
    this.streamHandle = streamHandle;
    this.explicitFlowControl = explicitFlowControl;
    callbacksContext = new JvmCallbackContext(callbacks);
  }

  /**
   * Send headers over an open HTTP streamHandle. This method can be invoked once
   * and needs to be called before send_data.
   *
   * @param headers,   the headers to send.
   * @param endStream, supplies whether this is headers only.
   */
  public void sendHeaders(Map<String, List<String>> headers, boolean endStream) {
    JniLibrary.sendHeaders(engineHandle, streamHandle, JniBridgeUtility.toJniHeaders(headers),
                           endStream);
  }

  /**
   * Send data over an open HTTP streamHandle. This method can be invoked multiple
   * times. The data length is the {@link ByteBuffer#capacity}.
   *
   * @param data,      the data to send.
   * @param endStream, supplies whether this is the last data in the streamHandle.
   * @throws UnsupportedOperationException - if the provided buffer is neither a
   *                                       direct ByteBuffer nor backed by an
   *                                       on-heap byte array.
   */
  public void sendData(ByteBuffer data, boolean endStream) {
    sendData(data, data.capacity(), endStream);
  }

  /**
   * Send data over an open HTTP streamHandle. This method can be invoked multiple
   * times.
   *
   * @param data,      the data to send.
   * @param length,    number of bytes to send: 0 <= length <= ByteBuffer.capacity()
   * @param endStream, supplies whether this is the last data in the streamHandle.
   * @throws UnsupportedOperationException - if the provided buffer is neither a
   *                                       direct ByteBuffer nor backed by an
   *                                       on-heap byte array.
   */
  public void sendData(ByteBuffer data, int length, boolean endStream) {
    if (length < 0 || length > data.capacity()) {
      throw new IllegalArgumentException("Length out of bound");
    }
    if (data.isDirect()) {
      JniLibrary.sendData(engineHandle, streamHandle, data, length, endStream);
    } else if (data.hasArray()) {
      JniLibrary.sendDataByteArray(engineHandle, streamHandle, data.array(), length, endStream);
    } else {
      throw new UnsupportedOperationException("Unsupported ByteBuffer implementation.");
    }
  }

  /**
   * Read data from the response stream. Returns immediately.
   *
   * @param byteCount, Maximum number of bytes that may be be passed by the next data callback.
   * @throws UnsupportedOperationException - if explicit flow control is not enabled.
   */
  public void readData(long byteCount) {
    if (!explicitFlowControl) {
      throw new UnsupportedOperationException("Called readData without explicit flow control.");
    }
    JniLibrary.readData(engineHandle, streamHandle, byteCount);
  }

  /**
   * Send trailers over an open HTTP streamHandle. This method can only be invoked
   * once per streamHandle. Note that this method implicitly ends the
   * streamHandle.
   *
   * @param trailers, the trailers to send.
   */
  public void sendTrailers(Map<String, List<String>> trailers) {
    JniLibrary.sendTrailers(engineHandle, streamHandle, JniBridgeUtility.toJniHeaders(trailers));
  }

  /**
   * Cancel the stream. This functions as an interrupt, and aborts further
   * callbacks and handling of the stream.
   *
   * @return int, success unless the stream has already been canceled.
   */
  public int cancel() { return JniLibrary.resetStream(engineHandle, streamHandle); }
}
package io.envoyproxy.envoymobile.engine;

import java.util.List;

/* Datatype used by the EnvoyConfiguration to header matches for virtual clusters
 *
 * All the fields here map to the fields by the respective names in the HeaderMatcher message
 * defined here:
 * https://github.com/envoyproxy/envoy/blob/main/api/envoy/config/route/v3/route_components.proto
 * */
public class HeaderMatchConfig {
  public enum Type {
    // Indicates the match value is for an exact match.
    EXACT,
    // Indicates the match value is a regular expression.
    SAFE_REGEX
  }
  ;

  // The name of the matcher.
  public final String name;
  // The type of the matcher.
  public final Type type;
  // The value of the matcher, interpreted based on the defined type.
  public final String value;

  public HeaderMatchConfig(String name, Type type, String value) {
    this.name = name;
    this.type = type;
    this.value = value;
  }
}
package io.envoyproxy.envoymobile.engine;

import io.envoyproxy.envoymobile.engine.types.EnvoyStreamIntel;

class EnvoyStreamIntelImpl implements EnvoyStreamIntel {
  private long streamId;
  private long connectionId;
  private long attemptCount;
  private long consumedBytesFromResponse;

  EnvoyStreamIntelImpl(long[] values) {
    streamId = values[0];
    connectionId = values[1];
    attemptCount = values[2];
    consumedBytesFromResponse = values[3];
  }

  @Override
  public long getStreamId() {
    return streamId;
  }

  @Override
  public long getConnectionId() {
    return connectionId;
  }

  @Override
  public long getAttemptCount() {
    return attemptCount;
  }

  @Override
  public long getConsumedBytesFromResponse() {
    return consumedBytesFromResponse;
  }
}
package io.envoyproxy.envoymobile.engine;

import io.envoyproxy.envoymobile.engine.types.EnvoyFinalStreamIntel;

class EnvoyFinalStreamIntelImpl implements EnvoyFinalStreamIntel {
  private long streamStartMs;
  private long dnsStartMs;
  private long dnsEndMs;
  private long connectStartMs;
  private long connectEndMs;
  private long sslStartMs;
  private long sslEndMs;
  private long sendingStartMs;
  private long sendingEndMs;
  private long responseStartMs;
  private long streamEndMs;
  private boolean socketReused;
  private long sentByteCount;
  private long receivedByteCount;
  private long responseFlags;
  private long upstreamProtocol;

  EnvoyFinalStreamIntelImpl(long[] values) {
    streamStartMs = values[0];
    dnsStartMs = values[1];
    dnsEndMs = values[2];
    connectStartMs = values[3];
    connectEndMs = values[4];
    sslStartMs = values[5];
    sslEndMs = values[6];
    sendingStartMs = values[7];
    sendingEndMs = values[8];
    responseStartMs = values[9];
    streamEndMs = values[10];
    socketReused = values[11] != 0;
    sentByteCount = values[12];
    receivedByteCount = values[13];
    responseFlags = values[14];
    upstreamProtocol = values[15];
  }

  @Override
  public long getStreamStartMs() {
    return streamStartMs;
  }
  @Override
  public long getDnsStartMs() {
    return dnsStartMs;
  }
  @Override
  public long getDnsEndMs() {
    return dnsEndMs;
  }
  @Override
  public long getConnectStartMs() {
    return connectStartMs;
  }
  @Override
  public long getConnectEndMs() {
    return connectEndMs;
  }
  @Override
  public long getSslStartMs() {
    return sslStartMs;
  }
  @Override
  public long getSslEndMs() {
    return sslEndMs;
  }
  @Override
  public long getSendingStartMs() {
    return sendingStartMs;
  }
  @Override
  public long getSendingEndMs() {
    return sendingEndMs;
  }
  @Override
  public long getResponseStartMs() {
    return responseStartMs;
  }
  @Override
  public long getStreamEndMs() {
    return streamEndMs;
  }
  @Override
  public boolean getSocketReused() {
    return socketReused;
  }
  @Override
  public long getSentByteCount() {
    return sentByteCount;
  }
  @Override
  public long getReceivedByteCount() {
    return receivedByteCount;
  }
  @Override
  public long getResponseFlags() {
    return responseFlags;
  }
  @Override
  public long getUpstreamProtocol() {
    return upstreamProtocol;
  }
}
package io.envoyproxy.envoymobile.engine;

import android.content.Context;
import android.net.ConnectivityManager;

public class AndroidJniLibrary {
  // Internal reference to helper object used to load and initialize the native
  // library.
  // Volatile to ensure double-checked locking works correctly.
  private static volatile AndroidLoader loader = null;

  // Load test libraries based on the jvm_flag `envoy_jni_library_name`.
  // WARNING: This should only be used for testing.
  public static void loadTestLibrary() { JniLibrary.loadTestLibrary(); }

  public static void load(Context context) {
    if (loader != null) {
      return;
    }

    synchronized (AndroidLoader.class) {
      if (loader != null) {
        return;
      }

      JniLibrary.load();
      loader = new AndroidLoader(context);
    }
  }

  // Private helper class used by the load method to ensure the native library and
  // its dependencies are loaded and initialized at most once.
  private static class AndroidLoader {
    private AndroidLoader(Context context) {
      AndroidJniLibrary.initialize(context.getClassLoader());
    }
  }

  /**
   * Native binding to register the ConnectivityManager to C-Ares.
   *
   * @param classLoader Application's class loader.
   * @return The resulting status of the initialization.
   */
  protected static native int initialize(ClassLoader classLoader);
}
package io.envoyproxy.envoymobile.engine;

import io.envoyproxy.envoymobile.engine.JvmFilterContext;
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilterFactory;

/**
 * Wrapper class for EnvoyHTTPFilterFactory for receiving JNI calls.
 */
class JvmFilterFactoryContext {
  private final EnvoyHTTPFilterFactory filterFactory;

  public JvmFilterFactoryContext(EnvoyHTTPFilterFactory filterFactory) {
    this.filterFactory = filterFactory;
  }

  public JvmFilterContext create() { return new JvmFilterContext(filterFactory.create()); }
}
package io.envoyproxy.envoymobile.engine;

/* Datatype used by the EnvoyConfiguration to create a native http filter chain. */
public class EnvoyNativeFilterConfig {
  public final String name;
  public final String typedConfig;

  /**
   * Create a new instance of the configuration
   *
   * @param name        the name of the filter.
   * @param typedConfig the filter configuration.
   */
  public EnvoyNativeFilterConfig(String name, String typedConfig) {
    this.name = name;
    this.typedConfig = typedConfig;
  }
}
package io.envoyproxy.envoymobile.engine;

import android.content.Context;
import io.envoyproxy.envoymobile.engine.types.EnvoyEventTracker;
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;
import io.envoyproxy.envoymobile.engine.types.EnvoyLogger;
import io.envoyproxy.envoymobile.engine.types.EnvoyNetworkType;
import io.envoyproxy.envoymobile.engine.types.EnvoyOnEngineRunning;
import io.envoyproxy.envoymobile.engine.types.EnvoyStringAccessor;
import io.envoyproxy.envoymobile.engine.types.EnvoyStatus;
import io.envoyproxy.envoymobile.utilities.ContextUtils;

import java.util.Map;

/* Android-specific implementation of the `EnvoyEngine` interface. */
public class AndroidEngineImpl implements EnvoyEngine {
  private final EnvoyEngine envoyEngine;

  /**
   * @param runningCallback Called when the engine finishes its async startup and begins running.
   */
  public AndroidEngineImpl(Context context, EnvoyOnEngineRunning runningCallback,
                           EnvoyLogger logger, EnvoyEventTracker eventTracker,
                           Boolean enableProxying) {
    this.envoyEngine = new EnvoyEngineImpl(runningCallback, logger, eventTracker);
    if (ContextUtils.getApplicationContext() == null) {
      ContextUtils.initApplicationContext(context.getApplicationContext());
    }
    AndroidJniLibrary.load(context);
    AndroidNetworkMonitor.load(context, envoyEngine);
    if (enableProxying) {
      AndroidProxyMonitor.load(context, envoyEngine);
    }
  }

  @Override
  public EnvoyHTTPStream startStream(EnvoyHTTPCallbacks callbacks, boolean explicitFlowControl) {
    return envoyEngine.startStream(callbacks, explicitFlowControl);
  }

  @Override
  public void performRegistration(EnvoyConfiguration envoyConfiguration) {
    envoyEngine.performRegistration(envoyConfiguration);
  }

  @Override
  public EnvoyStatus runWithYaml(String configurationYAML, String logLevel) {
    return envoyEngine.runWithYaml(configurationYAML, logLevel);
  }

  @Override
  public EnvoyStatus runWithConfig(EnvoyConfiguration envoyConfiguration, String logLevel) {
    return envoyEngine.runWithConfig(envoyConfiguration, logLevel);
  }

  @Override
  public void terminate() {
    envoyEngine.terminate();
  }

  @Override
  public String dumpStats() {
    return envoyEngine.dumpStats();
  }

  @Override
  public int recordCounterInc(String elements, Map<String, String> tags, int count) {
    return envoyEngine.recordCounterInc(elements, tags, count);
  }

  @Override
  public int registerStringAccessor(String accessorName, EnvoyStringAccessor accessor) {
    return envoyEngine.registerStringAccessor(accessorName, accessor);
  }

  @Override
  public void resetConnectivityState() {
    envoyEngine.resetConnectivityState();
  }

  @Override
  public void setPreferredNetwork(EnvoyNetworkType network) {
    envoyEngine.setPreferredNetwork(network);
  }

  public void setProxySettings(String host, int port) { envoyEngine.setProxySettings(host, port); }

  public void setLogLevel(LogLevel log_level) { envoyEngine.setLogLevel(log_level); }
}
package io.envoyproxy.envoymobile.engine;

import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Set;

import io.envoyproxy.envoymobile.engine.EnvoyNativeResourceReleaser;
import io.envoyproxy.envoymobile.engine.EnvoyNativeResourceWrapper;

/**
 * Central class to manage releasing native resources when wrapper objects are flagged as
 * unreachable by the garbage collector.
 */
public enum EnvoyNativeResourceRegistry {
  SINGLETON();

  // References are automatically enqueued when the gc flags them as unreachable.
  private ReferenceQueue<EnvoyNativeResourceWrapper> refQueue;
  // Maintains references in the object graph while we wait for them to be enqueued.
  private Set refMaintainer;
  // Blocks on the reference queue and calls the releaser of queued references.
  private RefQueueThread refQueueThread;

  private class RefQueueThread extends Thread {
    public void run() {
      EnvoyPhantomRef ref;
      while (true) {
        try {
          ref = (EnvoyPhantomRef)refQueue.remove();
        } catch (InterruptedException e) {
          continue;
        }

        ref.releaseResource();
        refMaintainer.remove(ref);
      }
    }
  }

  private class EnvoyPhantomRef extends PhantomReference<EnvoyNativeResourceWrapper> {
    private final EnvoyNativeResourceReleaser releaser;
    private final long nativeHandle;

    EnvoyPhantomRef(EnvoyNativeResourceWrapper owner, long nativeHandle,
                    EnvoyNativeResourceReleaser releaser) {
      super(owner, refQueue);
      this.nativeHandle = nativeHandle;
      this.releaser = releaser;
    }

    void releaseResource() { releaser.release(nativeHandle); }
  }

  private EnvoyNativeResourceRegistry() {
    refQueue = new ReferenceQueue<>();
    refQueueThread = new RefQueueThread();
    refMaintainer = new ConcurrentHashMap().newKeySet();
    refQueueThread.start();
  }

  /**
   * Register an EnvoyNativeResourceWrapper to schedule cleanup of its native resources when the
   * Java object is flagged for collection by the garbage collector.
   *
   * @param owner,        The object that has retained the native resource.
   * @param nativeHandle, An opaque identifier for the native resource.
   * @param releaser,     A lambda that makes the native call to release the resource.
   */
  public void register(EnvoyNativeResourceWrapper owner, long nativeHandle,
                       EnvoyNativeResourceReleaser releaser) {
    EnvoyPhantomRef ref = new EnvoyPhantomRef(owner, nativeHandle, releaser);
    refMaintainer.add(ref);
  }

  /**
   * Register an EnvoyNativeResourceWrapper to schedule cleanup of its native resources when the
   * Java object is flagged for collection by the garbage collector.
   *
   * @param owner,        The object that has retained the native resource.
   * @param nativeHandle, An opaque identifier for the native resource.
   * @param releaser,     A lambda that makes the native call to release the resource.
   */
  public static void globalRegister(EnvoyNativeResourceWrapper owner, long nativeHandle,
                                    EnvoyNativeResourceReleaser releaser) {
    SINGLETON.register(owner, nativeHandle, releaser);
  }
}
package io.envoyproxy.envoymobile.engine;

import io.envoyproxy.envoymobile.engine.types.EnvoyEventTracker;
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilterFactory;
import io.envoyproxy.envoymobile.engine.types.EnvoyKeyValueStore;
import io.envoyproxy.envoymobile.engine.types.EnvoyLogger;
import io.envoyproxy.envoymobile.engine.types.EnvoyNetworkType;
import io.envoyproxy.envoymobile.engine.types.EnvoyOnEngineRunning;
import io.envoyproxy.envoymobile.engine.types.EnvoyStringAccessor;
import io.envoyproxy.envoymobile.engine.types.EnvoyStatus;
import java.util.Map;

/* Concrete implementation of the `EnvoyEngine` interface. */
public class EnvoyEngineImpl implements EnvoyEngine {
  private static final int ENVOY_NET_GENERIC = 0;
  private static final int ENVOY_NET_WWAN = 1;
  private static final int ENVOY_NET_WLAN = 2;

  private final long engineHandle;

  /**
   * @param runningCallback Called when the engine finishes its async startup and begins running.
   * @param logger          The logging interface.
   * @param eventTracker    The event tracking interface.
   */
  public EnvoyEngineImpl(EnvoyOnEngineRunning runningCallback, EnvoyLogger logger,
                         EnvoyEventTracker eventTracker) {
    JniLibrary.load();
    this.engineHandle = JniLibrary.initEngine(runningCallback, logger, eventTracker);
  }

  /**
   * Creates a new stream with the provided callbacks.
   *
   * @param callbacks The callbacks for the stream.
   * @param explicitFlowControl Whether explicit flow control will be enabled for this stream.
   * @return A stream that may be used for sending data.
   */
  @Override
  public EnvoyHTTPStream startStream(EnvoyHTTPCallbacks callbacks, boolean explicitFlowControl) {
    long streamHandle = JniLibrary.initStream(engineHandle);
    EnvoyHTTPStream stream =
        new EnvoyHTTPStream(engineHandle, streamHandle, callbacks, explicitFlowControl);
    stream.start();
    return stream;
  }

  @Override
  public void terminate() {
    JniLibrary.terminateEngine(engineHandle);
  }

  @Override
  public String dumpStats() {
    return JniLibrary.dumpStats(engineHandle);
  }

  /**
   * Performs various JNI registration prior to engine running.
   *
   * @param envoyConfiguration The EnvoyConfiguration used to start Envoy.
   */
  @Override
  public void performRegistration(EnvoyConfiguration envoyConfiguration) {
    for (EnvoyHTTPFilterFactory filterFactory : envoyConfiguration.httpPlatformFilterFactories) {
      JniLibrary.registerFilterFactory(filterFactory.getFilterName(),
                                       new JvmFilterFactoryContext(filterFactory));
    }

    for (Map.Entry<String, EnvoyStringAccessor> entry :
         envoyConfiguration.stringAccessors.entrySet()) {
      JniLibrary.registerStringAccessor(entry.getKey(),
                                        new JvmStringAccessorContext(entry.getValue()));
    }

    for (Map.Entry<String, EnvoyKeyValueStore> entry :
         envoyConfiguration.keyValueStores.entrySet()) {
      JniLibrary.registerKeyValueStore(entry.getKey(),
                                       new JvmKeyValueStoreContext(entry.getValue()));
    }
  }

  /**
   * Run the Envoy engine with the provided yaml string and log level.
   *
   * This does not perform registration, and performRegistration may need to be called first.
   *
   * @param configurationYAML The configuration yaml with which to start Envoy.
   * @param logLevel          The log level to use when starting Envoy.
   * @return A status indicating if the action was successful.
   */
  @Override
  public EnvoyStatus runWithYaml(String configurationYAML, String logLevel) {
    return runWithResolvedYAML(configurationYAML, logLevel);
  }

  /**
   * Run the Envoy engine with the provided envoyConfiguration and log level.
   *
   * @param envoyConfiguration The EnvoyConfiguration used to start Envoy.
   * @param logLevel           The log level to use when starting Envoy.
   * @return EnvoyStatus A status indicating if the action was successful.
   */
  @Override
  public EnvoyStatus runWithConfig(EnvoyConfiguration envoyConfiguration, String logLevel) {
    performRegistration(envoyConfiguration);
    int status =
        JniLibrary.runEngine(this.engineHandle, "", envoyConfiguration.createBootstrap(), logLevel);
    if (status == 0) {
      return EnvoyStatus.ENVOY_SUCCESS;
    }
    return EnvoyStatus.ENVOY_FAILURE;
  }

  private EnvoyStatus runWithResolvedYAML(String configurationYAML, String logLevel) {
    try {
      int status = JniLibrary.runEngine(this.engineHandle, configurationYAML, 0, logLevel);
      if (status == 0) {
        return EnvoyStatus.ENVOY_SUCCESS;
      }
    } catch (Throwable throwable) {
      // TODO: Need to have a way to log the exception somewhere.
    }
    return EnvoyStatus.ENVOY_FAILURE;
  }

  /**
   * Increment a counter with the given count.
   *
   * @param elements Elements of the counter stat.
   * @param tags Tags of the counter stat.
   * @param count Amount to add to the counter.
   * @return A status indicating if the action was successful.
   */
  @Override
  public int recordCounterInc(String elements, Map<String, String> tags, int count) {
    return JniLibrary.recordCounterInc(engineHandle, elements, JniBridgeUtility.toJniTags(tags),
                                       count);
  }

  @Override
  public int registerStringAccessor(String accessor_name, EnvoyStringAccessor accessor) {
    return JniLibrary.registerStringAccessor(accessor_name, new JvmStringAccessorContext(accessor));
  }

  @Override
  public void resetConnectivityState() {
    JniLibrary.resetConnectivityState(engineHandle);
  }

  @Override
  public void setPreferredNetwork(EnvoyNetworkType network) {
    switch (network) {
    case ENVOY_NETWORK_TYPE_WWAN:
      JniLibrary.setPreferredNetwork(engineHandle, ENVOY_NET_WWAN);
      return;
    case ENVOY_NETWORK_TYPE_WLAN:
      JniLibrary.setPreferredNetwork(engineHandle, ENVOY_NET_WLAN);
      return;
    case ENVOY_NETWORK_TYPE_GENERIC:
      JniLibrary.setPreferredNetwork(engineHandle, ENVOY_NET_GENERIC);
      return;
    default:
      JniLibrary.setPreferredNetwork(engineHandle, ENVOY_NET_GENERIC);
      return;
    }
  }

  public void setProxySettings(String host, int port) {
    JniLibrary.setProxySettings(engineHandle, host, port);
  }

  @Override
  public void setLogLevel(LogLevel log_level) {
    JniLibrary.setLogLevel(log_level.ordinal());
  }
}
package io.envoyproxy.envoymobile.engine;

import java.nio.ByteBuffer;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;

class JvmCallbackContext {
  private final JvmBridgeUtility bridgeUtility;
  private final EnvoyHTTPCallbacks callbacks;

  public JvmCallbackContext(EnvoyHTTPCallbacks callbacks) {
    bridgeUtility = new JvmBridgeUtility();
    this.callbacks = callbacks;
  }

  /**
   * Delegates header retrieval to the bridge utility.
   *
   * @param key,        the name of the HTTP header.
   * @param value,      the value of the HTTP header.
   * @param start,      indicates this is the first header pair of the block.
   */
  void passHeader(byte[] key, byte[] value, boolean start) {
    bridgeUtility.passHeader(key, value, start);
  }

  /**
   * Invokes onHeaders callback using headers passed via passHeaders.
   *
   * @param headerCount, the total number of headers included in this header block.
   * @param endStream,   whether this header block is the final remote frame.
   * @param streamIntel, internal HTTP stream metrics, context, and other details.
   * @return Object,     not used for response callbacks.
   */
  public Object onResponseHeaders(long headerCount, boolean endStream, long[] streamIntel) {
    assert bridgeUtility.validateCount(headerCount);
    final Map headers = bridgeUtility.retrieveHeaders();

    callbacks.getExecutor().execute(new Runnable() {
      public void run() {
        callbacks.onHeaders(headers, endStream, new EnvoyStreamIntelImpl(streamIntel));
      }
    });

    return null;
  }

  /**
   * Invokes onTrailers callback using trailers passed via passHeaders.
   *
   * @param trailerCount, the total number of trailers included in this header block.
   * @param streamIntel,  internal HTTP stream metrics, context, and other details.
   * @return Object,      not used for response callbacks.
   */
  public Object onResponseTrailers(long trailerCount, long[] streamIntel) {
    assert bridgeUtility.validateCount(trailerCount);
    final Map trailers = bridgeUtility.retrieveHeaders();

    callbacks.getExecutor().execute(new Runnable() {
      public void run() { callbacks.onTrailers(trailers, new EnvoyStreamIntelImpl(streamIntel)); }
    });

    return null;
  }

  /**
   * Dispatches data received from the JNI layer up to the platform.
   *
   * @param data,        chunk of body data from the HTTP response.
   * @param endStream,   indicates this is the last remote frame of the stream.
   * @param streamIntel, internal HTTP stream metrics, context, and other details.
   * @return Object,     not used for response callbacks.
   */
  public Object onResponseData(byte[] data, boolean endStream, long[] streamIntel) {
    callbacks.getExecutor().execute(new Runnable() {
      public void run() {
        ByteBuffer dataBuffer = ByteBuffer.wrap(data);
        callbacks.onData(dataBuffer, endStream, new EnvoyStreamIntelImpl(streamIntel));
      }
    });

    return null;
  }

  /**
   * Dispatches error received from the JNI layer up to the platform.
   *
   * @param errorCode,         the error code.
   * @param message,           the error message.
   * @param attemptCount,      the number of times an operation was attempted before firing this
   *     error.
   * @param streamIntel,       internal HTTP stream metrics, context, and other details.
   * @param finalStreamIntel,  final internal HTTP stream metrics, context, and other details.
   * @return Object,           not used for response callbacks.
   */
  public Object onError(int errorCode, byte[] message, int attemptCount, long[] streamIntel,
                        long[] finalStreamIntel) {
    callbacks.getExecutor().execute(new Runnable() {
      public void run() {
        String errorMessage = new String(message);
        callbacks.onError(errorCode, errorMessage, attemptCount,
                          new EnvoyStreamIntelImpl(streamIntel),
                          new EnvoyFinalStreamIntelImpl(finalStreamIntel));
      }
    });

    return null;
  }

  /**
   * Dispatches cancellation notice up to the platform
   *
   * @param streamIntel,       internal HTTP stream metrics, context, and other details.
   * @param finalStreamIntel, final internal HTTP stream metrics, context, and other details.
   * @return Object, not used for response callbacks.
   */
  public Object onCancel(long[] streamIntel, long[] finalStreamIntel) {
    callbacks.getExecutor().execute(new Runnable() {
      public void run() {
        // This call is atomically gated at the call-site and will only happen once.
        callbacks.onCancel(new EnvoyStreamIntelImpl(streamIntel),
                           new EnvoyFinalStreamIntelImpl(finalStreamIntel));
      }
    });

    return null;
  }

  /**
   * Dispatches onSendWindowAvailable notice up to the platform
   *
   * @param streamIntel, internal HTTP stream metrics, context, and other details.
   * @return Object, not used for response callbacks.
   */
  public Object onSendWindowAvailable(long[] streamIntel) {
    callbacks.getExecutor().execute(new Runnable() {
      public void run() {
        // This call is atomically gated at the call-site and will only happen once.
        callbacks.onSendWindowAvailable(new EnvoyStreamIntelImpl(streamIntel));
      }
    });

    return null;
  }
  /**
   * Called with all stream metrics after the final headers/data/trailers call.
   *
   * @param streamIntel,       internal HTTP stream metrics, context, and other details.
   * @param finalStreamIntel, final internal HTTP stream metrics for the end of stream.
   * @return Object, not used for response callbacks.
   */
  public Object onComplete(long[] streamIntel, long[] finalStreamIntel) {
    callbacks.getExecutor().execute(new Runnable() {
      public void run() {
        // This call is atomically gated at the call-site and will only happen once.
        callbacks.onComplete(new EnvoyStreamIntelImpl(streamIntel),
                             new EnvoyFinalStreamIntelImpl(finalStreamIntel));
      }
    });

    return null;
  }
}
package io.envoyproxy.envoymobile.engine;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.Map;

import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilter;

/**
 * Wrapper class for EnvoyHTTPFilter for receiving JNI calls.
 */
class JvmFilterContext {
  private final JvmBridgeUtility headerUtility;
  private final JvmBridgeUtility trailerUtility;
  private final EnvoyHTTPFilter filter;

  public JvmFilterContext(EnvoyHTTPFilter filter) {
    headerUtility = new JvmBridgeUtility();
    trailerUtility = new JvmBridgeUtility();
    this.filter = filter;
  }

  /**
   * Delegates header retrieval to the bridge utility.
   *
   * @param key,        the name of the HTTP header.
   * @param value,      the value of the HTTP header.
   * @param start,      indicates this is the first header pair of the block.
   */
  public void passHeader(byte[] key, byte[] value, boolean start) {
    headerUtility.passHeader(key, value, start);
  }

  /**
   * Delegates trailer retrieval to the secondary bridge utility.
   *
   * @param key,        the name of the HTTP trailer.
   * @param value,      the value of the HTTP trailer.
   * @param start,      indicates this is the first trailer pair of the block.
   */
  public void passTrailer(byte[] key, byte[] value, boolean start) {
    trailerUtility.passHeader(key, value, start);
  }

  /**
   * Invokes onHeaders callback using headers passed via passHeaders.
   *
   * @param headerCount, the total number of headers included in this header block.
   * @param endStream,   whether this header block is the final remote frame.
   * @param streamIntel, internal HTTP stream metrics, context, and other details.
   * @return Object[],   pair of HTTP filter status and optional modified headers.
   */
  public Object onRequestHeaders(long headerCount, boolean endStream, long[] streamIntel) {
    assert headerUtility.validateCount(headerCount);
    final Map headers = headerUtility.retrieveHeaders();
    return toJniFilterHeadersStatus(
        filter.onRequestHeaders(headers, endStream, new EnvoyStreamIntelImpl(streamIntel)));
  }

  /**
   * Dispatches data received from the JNI layer up to the platform.
   *
   * @param data,        chunk of body data from the HTTP request.
   * @param endStream,   indicates this is the last remote frame of the stream.
   * @param streamIntel, internal HTTP stream metrics, context, and other details.
   * @return Object[],   pair of HTTP filter status and optional modified data.
   */
  public Object onRequestData(byte[] data, boolean endStream, long[] streamIntel) {
    ByteBuffer dataBuffer = ByteBuffer.wrap(data);
    return toJniFilterDataStatus(
        filter.onRequestData(dataBuffer, endStream, new EnvoyStreamIntelImpl(streamIntel)));
  }

  /**
   * Invokes onTrailers callback using trailers passed via passHeaders.
   *
   * @param trailerCount, the total number of trailers included in this header block.
   * @param streamIntel,  internal HTTP stream metrics, context, and other details.
   * @return Object[],    pair of HTTP filter status and optional modified trailers.
   */
  public Object onRequestTrailers(long trailerCount, long[] streamIntel) {
    assert headerUtility.validateCount(trailerCount);
    final Map trailers = headerUtility.retrieveHeaders();
    return toJniFilterTrailersStatus(
        filter.onRequestTrailers(trailers, new EnvoyStreamIntelImpl(streamIntel)));
  }

  /**
   * Invokes onHeaders callback using headers passed via passHeaders.
   *
   * @param headerCount, the total number of headers included in this header block.
   * @param endStream,   whether this header block is the final remote frame.
   * @param streamIntel, internal HTTP stream metrics, context, and other details.
   * @return Object[],   pair of HTTP filter status and optional modified headers.
   */
  public Object onResponseHeaders(long headerCount, boolean endStream, long[] streamIntel) {
    assert headerUtility.validateCount(headerCount);
    final Map headers = headerUtility.retrieveHeaders();
    return toJniFilterHeadersStatus(
        filter.onResponseHeaders(headers, endStream, new EnvoyStreamIntelImpl(streamIntel)));
  }

  /**
   * Dispatches data received from the JNI layer up to the platform.
   *
   * @param data,        chunk of body data from the HTTP response.
   * @param endStream,   indicates this is the last remote frame of the stream.
   * @param streamIntel, internal HTTP stream metrics, context, and other details.
   * @return Object[],   pair of HTTP filter status and optional modified data.
   */
  public Object onResponseData(byte[] data, boolean endStream, long[] streamIntel) {
    ByteBuffer dataBuffer = ByteBuffer.wrap(data);
    return toJniFilterDataStatus(
        filter.onResponseData(dataBuffer, endStream, new EnvoyStreamIntelImpl(streamIntel)));
  }

  /**
   * Invokes onTrailers callback using trailers passed via passHeaders.
   *
   * @param trailerCount, the total number of trailers included in this header block.
   * @param streamIntel,  internal HTTP stream metrics, context, and other details.
   * @return Object[],    pair of HTTP filter status and optional modified trailers.
   */
  public Object onResponseTrailers(long trailerCount, long[] streamIntel) {
    assert headerUtility.validateCount(trailerCount);
    final Map trailers = headerUtility.retrieveHeaders();
    return toJniFilterTrailersStatus(
        filter.onResponseTrailers(trailers, new EnvoyStreamIntelImpl(streamIntel)));
  }

  /**
   * Invokes onResumeRequest callback with pending HTTP entities.
   *
   * @param headerCount,  total pending headers included in the header block.
   * @param data,         buffered body data.
   * @param trailerCount, total pending trailers included in the trailer block.
   * @param endStream,    whether the stream is closed at this point.
   * @param streamIntel,  internal HTTP stream metrics, context, and other details.
   * @return Object[],    tuple of status with updated entities to be forwarded.
   */
  public Object onResumeRequest(long headerCount, byte[] data, long trailerCount, boolean endStream,
                                long[] streamIntel) {
    // Headers are optional in this call, and a negative length indicates omission.
    Map<String, List<String>> headers = null;
    if (headerCount >= 0) {
      assert headerUtility.validateCount(headerCount);
      headers = headerUtility.retrieveHeaders();
    }
    ByteBuffer dataBuffer = data == null ? null : ByteBuffer.wrap(data);
    // Trailers are optional in this call, and a negative length indicates omission.
    Map<String, List<String>> trailers = null;
    if (trailerCount >= 0) {
      assert trailerUtility.validateCount(trailerCount);
      trailers = trailerUtility.retrieveHeaders();
    }
    return toJniFilterResumeStatus(filter.onResumeRequest(headers, dataBuffer, trailers, endStream,
                                                          new EnvoyStreamIntelImpl(streamIntel)));
  }

  /**
   * Invokes onResumeResponse callback with pending HTTP entities.
   *
   * @param headerCount,  total pending headers included in the header block.
   * @param data,         buffered body data.
   * @param trailerCount, total pending trailers included in the trailer block.
   * @param endStream,    whether the stream is closed at this point.
   * @param streamIntel,  internal HTTP stream metrics, context, and other details.
   * @return Object[],    tuple of status with updated entities to be forwarded.
   */
  public Object onResumeResponse(long headerCount, byte[] data, long trailerCount,
                                 boolean endStream, long[] streamIntel) {
    // Headers are optional in this call, and a negative length indicates omission.
    Map<String, List<String>> headers = null;
    if (headerCount >= 0) {
      assert headerUtility.validateCount(headerCount);
      headers = headerUtility.retrieveHeaders();
    }
    ByteBuffer dataBuffer = data == null ? null : ByteBuffer.wrap(data);
    // Trailers are optional in this call, and a negative length indicates omission.
    Map<String, List<String>> trailers = null;
    if (trailerCount >= 0) {
      assert trailerUtility.validateCount(trailerCount);
      trailers = trailerUtility.retrieveHeaders();
    }
    return toJniFilterResumeStatus(filter.onResumeResponse(headers, dataBuffer, trailers, endStream,
                                                           new EnvoyStreamIntelImpl(streamIntel)));
  }

  /**
   * Sets request filter callbacks with memory-managed wrapper around native implementation.
   *
   * @param callbackHandle, native identifier for resource management.
   */
  public void setRequestFilterCallbacks(long callbackHandle) {
    filter.setRequestFilterCallbacks(EnvoyHTTPFilterCallbacksImpl.create(callbackHandle));
  }

  /**
   * Sets response filter callbacks with memory-managed wrapper around native implementation.
   *
   * @param callbackHandle, native identifier for resource management.
   */
  public void setResponseFilterCallbacks(long callbackHandle) {
    filter.setResponseFilterCallbacks(EnvoyHTTPFilterCallbacksImpl.create(callbackHandle));
  }

  /**
   * Dispatches error received from the JNI layer up to the platform.
   *
   * @param errorCode,    the error code.
   * @param message,      the error message.
   * @param attemptCount, the number of times an operation was attempted before firing this error.
   * @param streamIntel,  internal HTTP stream metrics, context, and other details.
   * @param finalStreamIntel,  final internal HTTP stream metrics, context, and other details.
   * @return Object,      not used in HTTP filters.
   */
  public Object onError(int errorCode, byte[] message, int attemptCount, long[] streamIntel,
                        long[] finalStreamIntel) {
    String errorMessage = new String(message);
    filter.onError(errorCode, errorMessage, attemptCount, new EnvoyStreamIntelImpl(streamIntel),
                   new EnvoyFinalStreamIntelImpl(finalStreamIntel));
    return null;
  }

  /**
   * Dispatches cancellation notice up to the platform.
   *
   * @param streamIntel,  internal HTTP stream metrics, context, and other details.
   * @param finalStreamIntel, final internal HTTP stream metrics, context, and other details.
   * @return Object,     not used in HTTP filters.
   */
  public Object onCancel(long[] streamIntel, long[] finalStreamIntel) {
    filter.onCancel(new EnvoyStreamIntelImpl(streamIntel),
                    new EnvoyFinalStreamIntelImpl(finalStreamIntel));
    return null;
  }

  /**
   * Dispatches stream completion notice up to the platform.
   *
   * @param streamIntel,  internal HTTP stream metrics, context, and other details.
   * @param finalStreamIntel, final internal HTTP stream metrics, context, and other details.
   * @return Object,     not used in HTTP filters.
   */
  public Object onComplete(long[] streamIntel, long[] finalStreamIntel) {
    filter.onComplete(new EnvoyStreamIntelImpl(streamIntel),
                      new EnvoyFinalStreamIntelImpl(finalStreamIntel));
    return null;
  }

  private static byte[][] toJniHeaders(Object headers) {
    return JniBridgeUtility.toJniHeaders((Map<String, List<String>>)headers);
  }

  private static Object[] toJniFilterHeadersStatus(Object[] result) {
    assert result.length == 2;
    result[1] = toJniHeaders(result[1]);
    return result;
  }

  private static Object[] toJniFilterDataStatus(Object[] result) {
    if (result.length == 3) {
      // Convert optionally-included headers on ResumeIteration.
      result[2] = toJniHeaders(result[2]);
      return result;
    }
    assert result.length == 2;
    return result;
  }

  private static Object[] toJniFilterTrailersStatus(Object[] result) {
    result[1] = toJniHeaders(result[1]);
    if (result.length == 4) {
      // Convert optionally-included headers on ResumeIteration.
      result[2] = toJniHeaders(result[2]);
      return result;
    }
    assert result.length == 2;
    return result;
  }

  private static Object[] toJniFilterResumeStatus(Object[] result) {
    assert result.length == 4;
    result[1] = toJniHeaders(result[1]);
    result[3] = toJniHeaders(result[3]);
    return result;
  }
}
package io.envoyproxy.envoymobile.engine;

import io.envoyproxy.envoymobile.engine.types.EnvoyKeyValueStore;
import java.nio.charset.StandardCharsets;

/**
 * JNI compatibility class to translate calls to EnvoyKeyValueStore implementations.
 *
 * Dealing with Java Strings directly in the JNI is awkward due to how Java encodes them.
 */
class JvmKeyValueStoreContext {
  private static final byte[] EMPTY_BYTES = {};
  private final EnvoyKeyValueStore keyValueStore;

  public JvmKeyValueStoreContext(EnvoyKeyValueStore keyValueStore) {
    this.keyValueStore = keyValueStore;
  }

  public byte[] read(byte[] key) {
    final String value = keyValueStore.read(new String(key, StandardCharsets.UTF_8));
    if (value == null) {
      return EMPTY_BYTES;
    }
    return value.getBytes(StandardCharsets.UTF_8);
  }

  public void remove(byte[] key) { keyValueStore.remove(new String(key, StandardCharsets.UTF_8)); }

  public void save(byte[] key, byte[] value) {
    keyValueStore.save(new String(key, StandardCharsets.UTF_8),
                       new String(value, StandardCharsets.UTF_8));
  }
}
package io.envoyproxy.envoymobile.engine;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Class to assist with passing types from native code over the JNI. Currently supports
 * HTTP headers.
 */
class JvmBridgeUtility {
  // State-tracking for header accumulation
  private Map<String, List<String>> headerAccumulator = null;
  private long headerCount = 0;

  JvmBridgeUtility() {}

  /**
   * Receives pairs of strings passed via the JNI.
   *
   * @param key,        the name of the HTTP header.
   * @param value,      the value of the HTTP header.
   * @param start,      indicates this is the first header pair of the block.
   */
  void passHeader(byte[] key, byte[] value, boolean start) {
    if (start) {
      assert headerAccumulator == null;
      assert headerCount == 0;
      headerAccumulator = new LinkedHashMap<>();
    }
    assert headerAccumulator != null;

    String headerKey;
    String headerValue;

    try {
      headerKey = new String(key, "UTF-8");
      headerValue = new String(value, "UTF-8");
    } catch (java.io.UnsupportedEncodingException e) {
      throw new RuntimeException(e);
    }

    // Ensure list is present in dictionary value
    List<String> values = headerAccumulator.get(headerKey);
    if (values == null) {
      values = new ArrayList(1);
      headerAccumulator.put(headerKey, values);
    }
    values.add(headerValue);

    headerCount++;
  }

  /**
   * Retrieves accumulated headers and resets state.
   *
   * @return Map, a map of header names to one or more values.
   */
  Map<String, List<String>> retrieveHeaders() {
    final Map<String, List<String>> headers = headerAccumulator;
    headerAccumulator = null;
    headerCount = 0;
    return headers;
  }

  /**
   * May be called *prior* to retrieveHeaders to validate the quantity received.
   *
   * @param headerCount, the expected number of headers.
   * @return boolean, true if the expected number matches the accumulated count.
   */
  boolean validateCount(long headerCount) { return this.headerCount == headerCount; }
}
package io.envoyproxy.envoymobile.engine;

import androidx.annotation.LongDef;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * The upstream protocol, if an upstream connection was established. Field
 * entries are based off of Envoy's Http::Protocol
 * https://github.com/envoyproxy/envoy/blob/main/envoy/http/protocol.h
 */
@LongDef({UpstreamHttpProtocol.HTTP10, UpstreamHttpProtocol.HTTP11, UpstreamHttpProtocol.HTTP2,
          UpstreamHttpProtocol.HTTP3})
@Retention(RetentionPolicy.SOURCE)
public @interface UpstreamHttpProtocol {
  long HTTP10 = 0;
  long HTTP11 = 1;
  long HTTP2 = 2;
  long HTTP3 = 3;
}
load("@build_bazel_rules_android//android:rules.bzl", "android_library")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@rules_java//java:defs.bzl", "java_library")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

android_library(
    name = "envoy_engine_lib",
    srcs = [
        "AndroidEngineImpl.java",
        "AndroidJniLibrary.java",
        "AndroidNetworkMonitor.java",
        "AndroidProxyMonitor.java",
        "UpstreamHttpProtocol.java",
    ],
    custom_package = "io.envoyproxy.envoymobile.engine",
    manifest = "AndroidEngineManifest.xml",
    visibility = ["//visibility:public"],
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine/types:envoy_c_types_lib",
        "//library/java/io/envoyproxy/envoymobile/utilities",
        "@maven//:androidx_annotation_annotation",
        "@maven//:androidx_core_core",
    ],
)

java_library(
    name = "envoy_base_engine_lib",
    srcs = [
        "EnvoyConfiguration.java",
        "EnvoyEngine.java",
        "EnvoyEngineImpl.java",
        "EnvoyFinalStreamIntelImpl.java",
        "EnvoyHTTPFilterCallbacksImpl.java",
        "EnvoyHTTPStream.java",
        "EnvoyNativeFilterConfig.java",
        "EnvoyNativeResourceRegistry.java",
        "EnvoyNativeResourceReleaser.java",
        "EnvoyNativeResourceWrapper.java",
        "EnvoyStreamIntelImpl.java",
        "HeaderMatchConfig.java",
        "JniBridgeUtility.java",
        "JniLibrary.java",
        "JvmCallbackContext.java",
        "JvmFilterContext.java",
        "JvmFilterFactoryContext.java",
        "JvmKeyValueStoreContext.java",
        "JvmStringAccessorContext.java",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib_srcs",
    ],
    visibility = ["//visibility:public"],
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine/types:envoy_c_types_lib",
        "@maven//:com_google_code_findbugs_jsr305",
        "@maven//:com_google_protobuf_protobuf_javalite",
    ],
)

filegroup(
    name = "envoy_base_engine_lib_srcs",
    srcs = ["JvmBridgeUtility.java"],
    visibility = ["//visibility:public"],
)
package io.envoyproxy.envoymobile.engine;

import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilterCallbacks;

final class EnvoyHTTPFilterCallbacksImpl
    implements EnvoyHTTPFilterCallbacks, EnvoyNativeResourceWrapper {

  private static final EnvoyNativeResourceReleaser releaseCallbacks = (long handle) -> {
    callReleaseCallbacks(handle);
  };

  private final long callbackHandle;

  /**
   * @param callbackHandle, native handle for callback execution. This must be eventually passed to
                            `callReleaseCallbacks` to release underlying memory.
   */
  EnvoyHTTPFilterCallbacksImpl(long callbackHandle) { this.callbackHandle = callbackHandle; }

  static EnvoyHTTPFilterCallbacksImpl create(long callbackHandle) {
    final EnvoyHTTPFilterCallbacksImpl object = new EnvoyHTTPFilterCallbacksImpl(callbackHandle);
    EnvoyNativeResourceRegistry.globalRegister(object, callbackHandle, releaseCallbacks);
    return object;
  }

  public void resumeIteration() { callResumeIteration(callbackHandle, this); }

  public void resetIdleTimer() { callResetIdleTimer(callbackHandle, this); }

  /**
   * @param callbackHandle, native handle for callback execution.
   * @param object, pass this object so that the JNI retains it, preventing it from potentially
   *                being concurrently garbage-collected while the native call is executing.
   */
  private native void callResumeIteration(long callbackHandle, EnvoyHTTPFilterCallbacksImpl object);

  /**
   * @param callbackHandle, native handle for callback execution.
   * @param object, pass this object so that the JNI retains it, preventing it from potentially
   *                being concurrently garbage-collected while the native call is executing.
   */
  private native void callResetIdleTimer(long callbackHandle, EnvoyHTTPFilterCallbacksImpl object);

  private static native void callReleaseCallbacks(long callbackHandle);
}
package io.envoyproxy.envoymobile.engine;

import com.google.protobuf.Struct;
import java.util.Collections;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;

import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilterFactory;
import io.envoyproxy.envoymobile.engine.types.EnvoyStringAccessor;
import io.envoyproxy.envoymobile.engine.types.EnvoyKeyValueStore;

/* Typed configuration that may be used for starting Envoy. */
public class EnvoyConfiguration {
  // Peer certificate verification mode.
  // Must match the CertificateValidationContext.TrustChainVerification proto enum.
  public enum TrustChainVerification {
    // Perform default certificate verification (e.g., against CA / verification lists)
    VERIFY_TRUST_CHAIN,
    // Connections where the certificate fails verification will be permitted.
    // For HTTP connections, the result of certificate verification can be used in route matching.
    // Used for testing.
    ACCEPT_UNTRUSTED;
  }

  public final Integer connectTimeoutSeconds;
  public final Integer dnsRefreshSeconds;
  public final Integer dnsFailureRefreshSecondsBase;
  public final Integer dnsFailureRefreshSecondsMax;
  public final Integer dnsQueryTimeoutSeconds;
  public final Integer dnsMinRefreshSeconds;
  public final List<String> dnsPreresolveHostnames;
  public final Boolean enableDNSCache;
  public final Integer dnsCacheSaveIntervalSeconds;
  public final Boolean enableDrainPostDnsRefresh;
  public final Boolean enableHttp3;
  public final String http3ConnectionOptions;
  public final String http3ClientConnectionOptions;
  public final Map<String, String> quicHints;
  public final List<String> quicCanonicalSuffixes;
  public final Boolean enableGzipDecompression;
  public final Boolean enableBrotliDecompression;
  public final Boolean enableSocketTagging;
  public final Boolean enableInterfaceBinding;
  public final Integer h2ConnectionKeepaliveIdleIntervalMilliseconds;
  public final Integer h2ConnectionKeepaliveTimeoutSeconds;
  public final Integer maxConnectionsPerHost;
  public final List<EnvoyHTTPFilterFactory> httpPlatformFilterFactories;
  public final Integer streamIdleTimeoutSeconds;
  public final Integer perTryIdleTimeoutSeconds;
  public final String appVersion;
  public final String appId;
  public final TrustChainVerification trustChainVerification;
  public final List<EnvoyNativeFilterConfig> nativeFilterChain;
  public final Map<String, EnvoyStringAccessor> stringAccessors;
  public final Map<String, EnvoyKeyValueStore> keyValueStores;
  public final Map<String, String> runtimeGuards;
  public final Boolean enablePlatformCertificatesValidation;
  public final String rtdsResourceName;
  public final Integer rtdsTimeoutSeconds;
  public final String xdsAddress;
  public final Integer xdsPort;
  public final Map<String, String> xdsGrpcInitialMetadata;
  public final String xdsRootCerts;
  public final String nodeId;
  public final String nodeRegion;
  public final String nodeZone;
  public final String nodeSubZone;
  public final Struct nodeMetadata;
  public final String cdsResourcesLocator;
  public final Integer cdsTimeoutSeconds;
  public final Boolean enableCds;

  private static final Pattern UNRESOLVED_KEY_PATTERN = Pattern.compile("\\{\\{ (.+) \\}\\}");

  /**
   * Create a new instance of the configuration.
   *
   * @param connectTimeoutSeconds                         timeout for new network connections to
   *     hosts in
   *                                                      the cluster.
   * @param dnsRefreshSeconds                             default rate in seconds at which to
   *     refresh DNS.
   * @param dnsFailureRefreshSecondsBase                  base rate in seconds to refresh DNS on
   *     failure.
   * @param dnsFailureRefreshSecondsMax                   max rate in seconds to refresh DNS on
   *     failure.
   * @param dnsQueryTimeoutSeconds                        rate in seconds to timeout DNS queries.
   * @param dnsMinRefreshSeconds                          minimum rate in seconds at which to
   *     refresh DNS.
   * @param dnsPreresolveHostnames                        hostnames to preresolve on Envoy Client
   *     construction.
   * @param enableDNSCache                                whether to enable DNS cache.
   * @param dnsCacheSaveIntervalSeconds                   the interval at which to save results to
   *     the configured key value store.
   * @param enableDrainPostDnsRefresh                     whether to drain connections after soft
   *     DNS refresh.
   * @param enableHttp3                                   whether to enable experimental support for
   *     HTTP/3 (QUIC).
   * @param http3ConnectionOptions                        connection options to be used in HTTP/3.
   * @param http3ClientConnectionOptions                  client connection options to be used in
   *     HTTP/3.
   * @param quicHints                                     A list of host port pairs that's known
   *     to speak QUIC.
   * @param quicCanonicalSuffixes                         A list of canonical suffixes that are
   *     known to speak QUIC.
   * @param enableGzipDecompression                       whether to enable response gzip
   *     decompression.
   * @param enableBrotliDecompression                     whether to enable response brotli
   *     decompression.
   * @param enableSocketTagging                           whether to enable socket tagging.
   * @param enableInterfaceBinding                        whether to allow interface binding.
   * @param h2ConnectionKeepaliveIdleIntervalMilliseconds rate in milliseconds seconds to send h2
   *                                                      pings on stream creation.
   * @param h2ConnectionKeepaliveTimeoutSeconds           rate in seconds to timeout h2 pings.
   * @param maxConnectionsPerHost                         maximum number of connections to open to a
   *                                                      single host.
   * @param streamIdleTimeoutSeconds                      idle timeout for HTTP streams.
   * @param perTryIdleTimeoutSeconds                      per try idle timeout for HTTP streams.
   * @param appVersion                                    the App Version of the App using this
   *     Envoy Client.
   * @param appId                                         the App ID of the App using this Envoy
   *     Client.
   * @param trustChainVerification                        whether to mute TLS Cert verification -
   *     for tests.
   * @param nativeFilterChain                             the configuration for native filters.
   * @param httpPlatformFilterFactories                   the configuration for platform filters.
   * @param stringAccessors                               platform string accessors to register.
   * @param keyValueStores                                platform key-value store implementations.
   * @param enablePlatformCertificatesValidation          whether to use the platform verifier.
   * @param rtdsResourceName                                 the RTDS layer name for this client.
   * @param rtdsTimeoutSeconds                            the timeout for RTDS fetches.
   * @param xdsAddress                                    the address for the xDS management server.
   * @param xdsPort                                       the port for the xDS server.
   * @param xdsGrpcInitialMetadata                        The Headers (as key/value pairs) that must
   *                                                      be included in the xDs gRPC stream's
   *                                                      initial metadata (as HTTP headers).
   * @param xdsRootCerts                                  the root certificates to use for the TLS
   *                                                      handshake during connection establishment
   *                                                      with the xDS management server.
   * @param nodeId                                        the node ID in the Node metadata.
   * @param nodeRegion                                    the node region in the Node metadata.
   * @param nodeZone                                      the node zone in the Node metadata.
   * @param nodeSubZone                                   the node sub-zone in the Node metadata.
   * @param nodeMetadata                                  the node metadata.
   * @param cdsResourcesLocator                           the resources locator for CDS.
   * @param cdsTimeoutSeconds                             the timeout for CDS fetches.
   * @param enableCds                                     enables CDS, used because all CDS params
   *     could be empty.
   */
  public EnvoyConfiguration(
      int connectTimeoutSeconds, int dnsRefreshSeconds, int dnsFailureRefreshSecondsBase,
      int dnsFailureRefreshSecondsMax, int dnsQueryTimeoutSeconds, int dnsMinRefreshSeconds,
      List<String> dnsPreresolveHostnames, boolean enableDNSCache, int dnsCacheSaveIntervalSeconds,
      boolean enableDrainPostDnsRefresh, boolean enableHttp3, String http3ConnectionOptions,
      String http3ClientConnectionOptions, Map<String, Integer> quicHints,
      List<String> quicCanonicalSuffixes, boolean enableGzipDecompression,
      boolean enableBrotliDecompression, boolean enableSocketTagging,
      boolean enableInterfaceBinding, int h2ConnectionKeepaliveIdleIntervalMilliseconds,
      int h2ConnectionKeepaliveTimeoutSeconds, int maxConnectionsPerHost,
      int streamIdleTimeoutSeconds, int perTryIdleTimeoutSeconds, String appVersion, String appId,
      TrustChainVerification trustChainVerification,
      List<EnvoyNativeFilterConfig> nativeFilterChain,
      List<EnvoyHTTPFilterFactory> httpPlatformFilterFactories,
      Map<String, EnvoyStringAccessor> stringAccessors,
      Map<String, EnvoyKeyValueStore> keyValueStores, Map<String, Boolean> runtimeGuards,
      boolean enablePlatformCertificatesValidation, String rtdsResourceName,
      Integer rtdsTimeoutSeconds, String xdsAddress, Integer xdsPort,
      Map<String, String> xdsGrpcInitialMetadata, String xdsRootCerts, String nodeId,
      String nodeRegion, String nodeZone, String nodeSubZone, Struct nodeMetadata,
      String cdsResourcesLocator, Integer cdsTimeoutSeconds, boolean enableCds) {
    JniLibrary.load();
    this.connectTimeoutSeconds = connectTimeoutSeconds;
    this.dnsRefreshSeconds = dnsRefreshSeconds;
    this.dnsFailureRefreshSecondsBase = dnsFailureRefreshSecondsBase;
    this.dnsFailureRefreshSecondsMax = dnsFailureRefreshSecondsMax;
    this.dnsQueryTimeoutSeconds = dnsQueryTimeoutSeconds;
    this.dnsMinRefreshSeconds = dnsMinRefreshSeconds;
    this.dnsPreresolveHostnames = dnsPreresolveHostnames;
    this.enableDNSCache = enableDNSCache;
    this.dnsCacheSaveIntervalSeconds = dnsCacheSaveIntervalSeconds;
    this.enableDrainPostDnsRefresh = enableDrainPostDnsRefresh;
    this.enableHttp3 = enableHttp3;
    this.http3ConnectionOptions = http3ConnectionOptions;
    this.http3ClientConnectionOptions = http3ClientConnectionOptions;
    this.quicHints = new HashMap<>();
    for (Map.Entry<String, Integer> hostAndPort : quicHints.entrySet()) {
      this.quicHints.put(hostAndPort.getKey(), String.valueOf(hostAndPort.getValue()));
    }
    this.quicCanonicalSuffixes = quicCanonicalSuffixes;
    this.enableGzipDecompression = enableGzipDecompression;
    this.enableBrotliDecompression = enableBrotliDecompression;
    this.enableSocketTagging = enableSocketTagging;
    this.enableInterfaceBinding = enableInterfaceBinding;
    this.h2ConnectionKeepaliveIdleIntervalMilliseconds =
        h2ConnectionKeepaliveIdleIntervalMilliseconds;
    this.h2ConnectionKeepaliveTimeoutSeconds = h2ConnectionKeepaliveTimeoutSeconds;
    this.maxConnectionsPerHost = maxConnectionsPerHost;
    this.streamIdleTimeoutSeconds = streamIdleTimeoutSeconds;
    this.perTryIdleTimeoutSeconds = perTryIdleTimeoutSeconds;
    this.appVersion = appVersion;
    this.appId = appId;
    this.trustChainVerification = trustChainVerification;
    int index = 0;
    // Insert in this order to preserve prior ordering constraints.
    for (EnvoyHTTPFilterFactory filterFactory : httpPlatformFilterFactories) {
      String config =
          "{'@type': type.googleapis.com/envoymobile.extensions.filters.http.platform_bridge.PlatformBridge, platform_filter_name: " +
          filterFactory.getFilterName() + "}";
      EnvoyNativeFilterConfig ins =
          new EnvoyNativeFilterConfig("envoy.filters.http.platform_bridge", config);
      nativeFilterChain.add(index++, ins);
    }
    this.nativeFilterChain = nativeFilterChain;

    this.httpPlatformFilterFactories = httpPlatformFilterFactories;
    this.stringAccessors = stringAccessors;
    this.keyValueStores = keyValueStores;

    this.runtimeGuards = new HashMap<String, String>();
    for (Map.Entry<String, Boolean> guardAndValue : runtimeGuards.entrySet()) {
      this.runtimeGuards.put(guardAndValue.getKey(), String.valueOf(guardAndValue.getValue()));
    }
    this.enablePlatformCertificatesValidation = enablePlatformCertificatesValidation;
    this.rtdsResourceName = rtdsResourceName;
    this.rtdsTimeoutSeconds = rtdsTimeoutSeconds;
    this.xdsAddress = xdsAddress;
    this.xdsPort = xdsPort;
    this.xdsGrpcInitialMetadata = new HashMap<>(xdsGrpcInitialMetadata);
    this.xdsRootCerts = xdsRootCerts;
    this.nodeId = nodeId;
    this.nodeRegion = nodeRegion;
    this.nodeZone = nodeZone;
    this.nodeSubZone = nodeSubZone;
    this.nodeMetadata = nodeMetadata;
    this.cdsResourcesLocator = cdsResourcesLocator;
    this.cdsTimeoutSeconds = cdsTimeoutSeconds;
    this.enableCds = enableCds;
  }

  public long createBootstrap() {
    Boolean enforceTrustChainVerification =
        trustChainVerification == EnvoyConfiguration.TrustChainVerification.VERIFY_TRUST_CHAIN;
    List<EnvoyNativeFilterConfig> reverseFilterChain = new ArrayList<>(nativeFilterChain);
    Collections.reverse(reverseFilterChain);

    byte[][] filterChain = JniBridgeUtility.toJniBytes(reverseFilterChain);
    byte[][] dnsPreresolve = JniBridgeUtility.stringsToJniBytes(dnsPreresolveHostnames);
    byte[][] runtimeGuards = JniBridgeUtility.mapToJniBytes(this.runtimeGuards);
    byte[][] quicHints = JniBridgeUtility.mapToJniBytes(this.quicHints);
    byte[][] quicSuffixes = JniBridgeUtility.stringsToJniBytes(quicCanonicalSuffixes);
    byte[][] xdsGrpcInitialMetadata = JniBridgeUtility.mapToJniBytes(this.xdsGrpcInitialMetadata);

    return JniLibrary.createBootstrap(
        connectTimeoutSeconds, dnsRefreshSeconds, dnsFailureRefreshSecondsBase,
        dnsFailureRefreshSecondsMax, dnsQueryTimeoutSeconds, dnsMinRefreshSeconds, dnsPreresolve,
        enableDNSCache, dnsCacheSaveIntervalSeconds, enableDrainPostDnsRefresh, enableHttp3,
        http3ConnectionOptions, http3ClientConnectionOptions, quicHints, quicSuffixes,
        enableGzipDecompression, enableBrotliDecompression, enableSocketTagging,
        enableInterfaceBinding, h2ConnectionKeepaliveIdleIntervalMilliseconds,
        h2ConnectionKeepaliveTimeoutSeconds, maxConnectionsPerHost, streamIdleTimeoutSeconds,
        perTryIdleTimeoutSeconds, appVersion, appId, enforceTrustChainVerification, filterChain,
        enablePlatformCertificatesValidation, runtimeGuards, rtdsResourceName, rtdsTimeoutSeconds,
        xdsAddress, xdsPort, xdsGrpcInitialMetadata, xdsRootCerts, nodeId, nodeRegion, nodeZone,
        nodeSubZone, nodeMetadata.toByteArray(), cdsResourcesLocator, cdsTimeoutSeconds, enableCds);
  }

  static class ConfigurationException extends RuntimeException {
    ConfigurationException(String unresolvedKey) {
      super("Unresolved template key: " + unresolvedKey);
    }
  }
}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="io.envoyproxy.envoymobile.engine">
    <uses-sdk
            android:minSdkVersion="21"
            android:targetSdkVersion="29"/>

</manifest>
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.EnvoyConfiguration
import io.envoyproxy.envoymobile.engine.EnvoyEngine
import io.envoyproxy.envoymobile.engine.EnvoyHTTPStream
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks
import io.envoyproxy.envoymobile.engine.types.EnvoyNetworkType
import io.envoyproxy.envoymobile.engine.types.EnvoyStatus
import io.envoyproxy.envoymobile.engine.types.EnvoyStringAccessor

/**
 * Mock implementation of `EnvoyEngine`. Used internally for testing the bridging layer & mocking.
 */
internal class MockEnvoyEngine : EnvoyEngine {
  override fun runWithConfig(
    envoyConfiguration: EnvoyConfiguration?,
    logLevel: String?
  ): EnvoyStatus = EnvoyStatus.ENVOY_SUCCESS

  override fun performRegistration(envoyConfiguration: EnvoyConfiguration) = Unit

  override fun runWithYaml(configurationYAML: String, logLevel: String): EnvoyStatus =
    EnvoyStatus.ENVOY_SUCCESS

  override fun startStream(
    callbacks: EnvoyHTTPCallbacks?,
    explicitFlowControl: Boolean
  ): EnvoyHTTPStream {
    return MockEnvoyHTTPStream(callbacks!!, explicitFlowControl)
  }

  override fun terminate() = Unit

  override fun recordCounterInc(
    elements: String,
    tags: MutableMap<String, String>,
    count: Int
  ): Int = 0

  override fun registerStringAccessor(accessorName: String, accessor: EnvoyStringAccessor): Int = 0

  override fun dumpStats(): String = ""

  override fun resetConnectivityState() = Unit

  override fun setPreferredNetwork(network: EnvoyNetworkType) = Unit

  override fun setProxySettings(host: String, port: Int) = Unit

  override fun setLogLevel(level: EnvoyEngine.LogLevel) = Unit
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.EnvoyHTTPStream
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks
import java.nio.ByteBuffer

/**
 * Internal no-op mock implementation of the engine's `EnvoyHTTPStream`.
 *
 * @param callbacks Callbacks associated with the stream.
 */
internal class MockEnvoyHTTPStream(
  val callbacks: EnvoyHTTPCallbacks,
  val explicitFlowControl: Boolean
) : EnvoyHTTPStream(0, 0, callbacks, explicitFlowControl) {
  override fun sendHeaders(headers: MutableMap<String, MutableList<String>>?, endStream: Boolean) {}

  override fun sendData(data: ByteBuffer?, endStream: Boolean) {}

  override fun readData(byteCount: Long) {}

  override fun sendTrailers(trailers: MutableMap<String, MutableList<String>>?) {}

  override fun cancel(): Int {
    return 0
  }
}
package io.envoyproxy.envoymobile

import java.util.concurrent.Executor

/**
 * Mock implementation of `StreamPrototype` which is used to produce `MockStream` instances.
 *
 * @param onStart Closure that will be called each time a new stream is started from the prototype.
 */
class MockStreamPrototype
internal constructor(private val onStart: ((stream: MockStream) -> Unit)?) :
  StreamPrototype(MockEnvoyEngine()) {
  override fun start(executor: Executor): Stream {
    val callbacks = createCallbacks(executor)
    val stream = MockStream(MockEnvoyHTTPStream(callbacks, false))
    onStart?.invoke(stream)
    return stream
  }
}
package io.envoyproxy.envoymobile

/**
 * Mock implementation of `StreamClient` which produces `MockStreamPrototype` values.
 *
 * @param onStartStream Closure that may be set to observe the creation of new streams. It will be
 *   called each time `newStreamPrototype()` is executed. Typically, this is used to capture streams
 *   on creation before sending values through them.
 */
class MockStreamClient(var onStartStream: ((MockStream) -> Unit)?) : StreamClient {
  override fun newStreamPrototype(): StreamPrototype {
    return MockStreamPrototype { onStartStream?.invoke(it) }
  }
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.types.EnvoyFinalStreamIntel
import io.envoyproxy.envoymobile.engine.types.EnvoyStreamIntel
import java.nio.ByteBuffer

/**
 * Mock implementation of `Stream` that also provides an interface for sending mocked responses
 * through to the stream's callbacks. Created via `MockStreamPrototype`.
 */
class MockStream internal constructor(underlyingStream: MockEnvoyHTTPStream) :
  Stream(underlyingStream, useByteBufferPosition = false) {
  private val mockStream: MockEnvoyHTTPStream = underlyingStream

  private val mockStreamIntel =
    object : EnvoyStreamIntel {
      override fun getStreamId(): Long {
        return 0
      }

      override fun getConnectionId(): Long {
        return 0
      }

      override fun getAttemptCount(): Long {
        return 0
      }

      override fun getConsumedBytesFromResponse(): Long {
        return 0
      }
    }

  private val mockFinalStreamIntel =
    object : EnvoyFinalStreamIntel {
      override fun getStreamStartMs(): Long {
        return 0
      }

      override fun getDnsStartMs(): Long {
        return 0
      }

      override fun getDnsEndMs(): Long {
        return 0
      }

      override fun getConnectStartMs(): Long {
        return 0
      }

      override fun getConnectEndMs(): Long {
        return 0
      }

      override fun getSslStartMs(): Long {
        return 0
      }

      override fun getSslEndMs(): Long {
        return 0
      }

      override fun getSendingStartMs(): Long {
        return 0
      }

      override fun getSendingEndMs(): Long {
        return 0
      }

      override fun getResponseStartMs(): Long {
        return 0
      }

      override fun getStreamEndMs(): Long {
        return 0
      }

      override fun getSocketReused(): Boolean {
        return false
      }

      override fun getSentByteCount(): Long {
        return 0
      }

      override fun getReceivedByteCount(): Long {
        return 0
      }

      override fun getResponseFlags(): Long {
        return 0
      }

      override fun getUpstreamProtocol(): Long {
        return 0
      }
    }
  /** Closure that will be called when request headers are sent. */
  var onRequestHeaders: ((headers: RequestHeaders, endStream: Boolean) -> Unit)? = null
  /** Closure that will be called when request data is sent. */
  var onRequestData: ((data: ByteBuffer, endStream: Boolean) -> Unit)? = null
  /** Closure that will be called when request trailers are sent. */
  var onRequestTrailers: ((trailers: RequestTrailers) -> Unit)? = null
  /** Closure that will be called when the stream is canceled by the client. */
  var onCancel: (() -> Unit)? = null

  override fun sendHeaders(headers: RequestHeaders, endStream: Boolean): Stream {
    onRequestHeaders?.invoke(headers, endStream)
    return this
  }

  override fun sendData(data: ByteBuffer): Stream {
    onRequestData?.invoke(data, false)
    return this
  }

  override fun close(data: ByteBuffer) {
    onRequestData?.invoke(data, true)
  }

  override fun close(trailers: RequestTrailers) {
    onRequestTrailers?.invoke(trailers)
  }

  override fun cancel() {
    onCancel?.invoke()
  }

  /**
   * Simulate response headers coming back over the stream.
   *
   * @param headers Response headers to receive.
   * @param endStream Whether this is a headers-only response.
   */
  fun receiveHeaders(headers: ResponseHeaders, endStream: Boolean) {
    mockStream.callbacks.onHeaders(headers.caseSensitiveHeaders(), endStream, mockStreamIntel)
  }

  /**
   * Simulate response data coming back over the stream.
   *
   * @param data Response data to receive.
   * @param endStream Whether this is the last data frame.
   */
  fun receiveData(data: ByteBuffer, endStream: Boolean) {
    mockStream.callbacks.onData(data, endStream, mockStreamIntel)
  }

  /**
   * Simulate trailers coming back over the stream.
   *
   * @param trailers Response trailers to receive.
   */
  fun receiveTrailers(trailers: ResponseTrailers) {
    mockStream.callbacks.onTrailers(trailers.caseSensitiveHeaders(), mockStreamIntel)
  }

  /** Simulate the stream receiving a cancellation signal from Envoy. */
  fun receiveCancel() {
    mockStream.callbacks.onCancel(mockStreamIntel, mockFinalStreamIntel)
  }

  /**
   * Simulate Envoy returning an error.
   *
   * @param error The error to receive.
   */
  fun receiveError(error: EnvoyError) {
    mockStream.callbacks.onError(
      error.errorCode,
      error.message,
      error.attemptCount ?: 0,
      mockStreamIntel,
      mockFinalStreamIntel
    )
  }
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.EnvoyEngine

/** Envoy implementation of `PulseClient`. */
internal class PulseClientImpl constructor(internal val engine: EnvoyEngine) : PulseClient {

  override fun counter(vararg elements: Element): Counter {
    return CounterImpl(engine, elements.asList())
  }

  override fun counter(vararg elements: Element, tags: Tags): Counter {
    return CounterImpl(engine, elements.asList(), tags)
  }
}
package io.envoyproxy.envoymobile

/** Builder used for constructing instances of `RequestTrailers`. */
class RequestTrailersBuilder : HeadersBuilder {
  /*
   * Instantiate a new builder.
   */
  constructor() : super(HeadersContainer(mapOf()))

  /*
   * Instantiate a new instance of the builder.
   *
   * @param container: The headers container to start with.
   */
  internal constructor(container: HeadersContainer) : super(container)

  /*
   * Instantiate a new builder. Used only by RequestTrailers to convert back to
   * RequestTrailersBuilder.
   *
   * @param trailers: The trailers to start with.
   */
  internal constructor(
    trailers: MutableMap<String, MutableList<String>>
  ) : super(HeadersContainer(trailers))

  override fun add(name: String, value: String): RequestTrailersBuilder {
    super.add(name, value)
    return this
  }

  override fun set(name: String, value: MutableList<String>): RequestTrailersBuilder {
    super.set(name, value)
    return this
  }

  override fun remove(name: String): RequestTrailersBuilder {
    super.remove(name)
    return this
  }

  override fun internalSet(name: String, value: MutableList<String>): RequestTrailersBuilder {
    super.internalSet(name, value)
    return this
  }

  /**
   * Build the request trailers using the current builder.
   *
   * @return RequestTrailers, New instance of request trailers.
   */
  fun build(): RequestTrailers {
    return RequestTrailers(container)
  }
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilterCallbacks

/** Envoy implementation of `ResponseFilterCallbacks`. */
internal class ResponseFilterCallbacksImpl
constructor(internal val callbacks: EnvoyHTTPFilterCallbacks) : ResponseFilterCallbacks {

  override fun resumeResponse() {
    callbacks.resumeIteration()
  }

  override fun resetIdleTimer() {
    callbacks.resetIdleTimer()
  }
}
package io.envoyproxy.envoymobile

import java.nio.ByteBuffer

/*
 * ResponseFilter supporting asynchronous resumption.
 */
interface AsyncResponseFilter : ResponseFilter {
  /**
   * Called by the filter manager once to initialize the filter callbacks that the filter should
   * use.
   *
   * @param callbacks: The callbacks for this filter to use to interact with the chain.
   */
  fun setResponseFilterCallbacks(callbacks: ResponseFilterCallbacks)

  /**
   * Invoked explicitly in response to an asynchronous `resumeResponse()` callback when filter
   * iteration has been stopped. The parameters passed to this invocation will be a snapshot of any
   * stream state that has not yet been forwarded along the filter chain.
   *
   * As with other filter invocations, this will be called on Envoy's main thread, and thus no
   * additional synchronization is required between this and other invocations.
   *
   * @param headers: Headers, if `StopIteration` was returned from `onResponseHeaders`.
   * @param data: Any data that has been buffered where `StopIterationAndBuffer` was returned.
   * @param trailers: Trailers, if `StopIteration` was returned from `onReponseTrailers`.
   * @param endStream: True, if the stream ended with the previous (and thus, last) invocation.
   * @param streamIntel: Internal HTTP stream metrics, context, and other details.
   *
   * @return: The resumption status including any HTTP entities that will be forwarded.
   */
  fun onResumeResponse(
    headers: ResponseHeaders?,
    data: ByteBuffer?,
    trailers: ResponseTrailers?,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterResumeStatus<ResponseHeaders, ResponseTrailers>
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.types.EnvoyFinalStreamIntel
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilter
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilterCallbacks
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilterFactory
import io.envoyproxy.envoymobile.engine.types.EnvoyStreamIntel
import java.nio.ByteBuffer

/*
 * Interface representing a filter. See `RequestFilter` and `ResponseFilter` for more details.
 */
@Suppress("EmptyClassBlock") interface Filter

internal class FilterFactory(private val filterName: String, private val factory: () -> Filter) :
  EnvoyHTTPFilterFactory {
  override fun getFilterName(): String {
    return filterName
  }

  override fun create(): EnvoyHTTPFilter {
    return EnvoyHTTPFilterAdapter(factory())
  }
}

internal class EnvoyHTTPFilterAdapter(private val filter: Filter) : EnvoyHTTPFilter {

  override fun onRequestHeaders(
    headers: Map<String, List<String>>,
    endStream: Boolean,
    streamIntel: EnvoyStreamIntel
  ): Array<Any?> {
    (filter as? RequestFilter)?.let { requestFilter ->
      val result =
        requestFilter.onRequestHeaders(RequestHeaders(headers), endStream, StreamIntel(streamIntel))
      return when (result) {
        is FilterHeadersStatus.Continue ->
          arrayOf(result.status, result.headers.caseSensitiveHeaders())
        is FilterHeadersStatus.StopIteration ->
          arrayOf(result.status, emptyMap<String, List<String>>())
      }
    }
    return arrayOf(0, headers)
  }

  override fun onResponseHeaders(
    headers: Map<String, List<String>>,
    endStream: Boolean,
    streamIntel: EnvoyStreamIntel
  ): Array<Any?> {
    (filter as? ResponseFilter)?.let { responseFilter ->
      val result =
        responseFilter.onResponseHeaders(
          ResponseHeaders(headers),
          endStream,
          StreamIntel(streamIntel)
        )
      return when (result) {
        is FilterHeadersStatus.Continue ->
          arrayOf(result.status, result.headers.caseSensitiveHeaders())
        is FilterHeadersStatus.StopIteration ->
          arrayOf(result.status, emptyMap<String, List<String>>())
      }
    }
    return arrayOf(0, headers)
  }

  override fun onRequestData(
    data: ByteBuffer,
    endStream: Boolean,
    streamIntel: EnvoyStreamIntel
  ): Array<Any?> {
    (filter as? RequestFilter)?.let { requestFilter ->
      val result = requestFilter.onRequestData(data, endStream, StreamIntel(streamIntel))
      return when (result) {
        is FilterDataStatus.Continue<*> -> arrayOf(result.status, result.data)
        is FilterDataStatus.StopIterationAndBuffer<*> ->
          arrayOf(result.status, ByteBuffer.allocate(0))
        is FilterDataStatus.StopIterationNoBuffer<*> ->
          arrayOf(result.status, ByteBuffer.allocate(0))
        is FilterDataStatus.ResumeIteration<*> ->
          arrayOf(result.status, result.data, result.headers?.caseSensitiveHeaders())
      }
    }
    return arrayOf(0, data)
  }

  override fun onResponseData(
    data: ByteBuffer,
    endStream: Boolean,
    streamIntel: EnvoyStreamIntel
  ): Array<Any?> {
    (filter as? ResponseFilter)?.let { responseFilter ->
      val result = responseFilter.onResponseData(data, endStream, StreamIntel(streamIntel))
      return when (result) {
        is FilterDataStatus.Continue<*> -> arrayOf(result.status, result.data)
        is FilterDataStatus.StopIterationAndBuffer<*> ->
          arrayOf(result.status, ByteBuffer.allocate(0))
        is FilterDataStatus.StopIterationNoBuffer<*> ->
          arrayOf(result.status, ByteBuffer.allocate(0))
        is FilterDataStatus.ResumeIteration<*> ->
          arrayOf(result.status, result.data, result.headers?.caseSensitiveHeaders())
      }
    }
    return arrayOf(0, data)
  }

  override fun onRequestTrailers(
    trailers: Map<String, List<String>>,
    streamIntel: EnvoyStreamIntel
  ): Array<Any?> {
    (filter as? RequestFilter)?.let { requestFilter ->
      val result =
        requestFilter.onRequestTrailers(RequestTrailers(trailers), StreamIntel(streamIntel))
      return when (result) {
        is FilterTrailersStatus.Continue<*, *> ->
          arrayOf(result.status, result.trailers.caseSensitiveHeaders())
        is FilterTrailersStatus.StopIteration<*, *> ->
          arrayOf(result.status, emptyMap<String, List<String>>())
        is FilterTrailersStatus.ResumeIteration<*, *> ->
          arrayOf(
            result.status,
            result.trailers.caseSensitiveHeaders(),
            result.headers?.caseSensitiveHeaders(),
            result.data
          )
      }
    }
    return arrayOf(0, trailers)
  }

  override fun onResponseTrailers(
    trailers: Map<String, List<String>>,
    streamIntel: EnvoyStreamIntel
  ): Array<Any?> {
    (filter as? ResponseFilter)?.let { responseFilter ->
      val result =
        responseFilter.onResponseTrailers(ResponseTrailers(trailers), StreamIntel(streamIntel))
      return when (result) {
        is FilterTrailersStatus.Continue<*, *> ->
          arrayOf(result.status, result.trailers.caseSensitiveHeaders())
        is FilterTrailersStatus.StopIteration<*, *> ->
          arrayOf(result.status, emptyMap<String, List<String>>())
        is FilterTrailersStatus.ResumeIteration<*, *> ->
          arrayOf(
            result.status,
            result.trailers.caseSensitiveHeaders(),
            result.headers?.caseSensitiveHeaders(),
            result.data
          )
      }
    }
    return arrayOf(0, trailers)
  }

  override fun onError(
    errorCode: Int,
    message: String,
    attemptCount: Int,
    streamIntel: EnvoyStreamIntel,
    finalStreamIntel: EnvoyFinalStreamIntel
  ) {
    (filter as? ResponseFilter)?.let { responseFilter ->
      responseFilter.onError(
        EnvoyError(errorCode, message, attemptCount),
        FinalStreamIntel(streamIntel, finalStreamIntel)
      )
    }
  }

  override fun onCancel(streamIntel: EnvoyStreamIntel, finalStreamIntel: EnvoyFinalStreamIntel) {
    (filter as? ResponseFilter)?.let { responseFilter ->
      responseFilter.onCancel(FinalStreamIntel(streamIntel, finalStreamIntel))
    }
  }

  override fun onComplete(streamIntel: EnvoyStreamIntel, finalStreamIntel: EnvoyFinalStreamIntel) {
    (filter as? ResponseFilter)?.let { responseFilter ->
      responseFilter.onComplete(FinalStreamIntel(streamIntel, finalStreamIntel))
    }
  }

  override fun setRequestFilterCallbacks(callbacks: EnvoyHTTPFilterCallbacks) {
    (filter as? AsyncRequestFilter)?.let { asyncRequestFilter ->
      asyncRequestFilter.setRequestFilterCallbacks(RequestFilterCallbacksImpl(callbacks))
    }
  }

  override fun onResumeRequest(
    headers: Map<String, List<String>>?,
    data: ByteBuffer?,
    trailers: Map<String, List<String>>?,
    endStream: Boolean,
    streamIntel: EnvoyStreamIntel
  ): Array<Any?> {
    (filter as? AsyncRequestFilter)?.let { asyncRequestFilter ->
      val result =
        asyncRequestFilter.onResumeRequest(
          headers?.let(::RequestHeaders),
          data,
          trailers?.let(::RequestTrailers),
          endStream,
          StreamIntel(streamIntel)
        )
      return when (result) {
        is FilterResumeStatus.ResumeIteration<*, *> ->
          arrayOf(
            result.status,
            result.headers?.caseSensitiveHeaders(),
            result.data,
            result.trailers?.caseSensitiveHeaders()
          )
      }
    }
    return arrayOf(-1, headers, data, trailers)
  }

  override fun setResponseFilterCallbacks(callbacks: EnvoyHTTPFilterCallbacks) {
    (filter as? AsyncResponseFilter)?.let { asyncResponseFilter ->
      asyncResponseFilter.setResponseFilterCallbacks(ResponseFilterCallbacksImpl(callbacks))
    }
  }

  override fun onResumeResponse(
    headers: Map<String, List<String>>?,
    data: ByteBuffer?,
    trailers: Map<String, List<String>>?,
    endStream: Boolean,
    streamIntel: EnvoyStreamIntel
  ): Array<Any?> {
    (filter as? AsyncResponseFilter)?.let { asyncResponseFilter ->
      val result =
        asyncResponseFilter.onResumeResponse(
          headers?.let(::ResponseHeaders),
          data,
          trailers?.let(::ResponseTrailers),
          endStream,
          StreamIntel(streamIntel)
        )
      return when (result) {
        is FilterResumeStatus.ResumeIteration<*, *> ->
          arrayOf(
            result.status,
            result.headers?.caseSensitiveHeaders(),
            result.data,
            result.trailers?.caseSensitiveHeaders()
          )
      }
    }
    return arrayOf(-1, headers, data, trailers)
  }
}
package io.envoyproxy.envoymobile

import java.nio.ByteBuffer

/*
 * Filter executed for inbound responses, providing the ability to observe and mutate streams.
 */
interface ResponseFilter : Filter {
  /**
   * Called once when the response is initiated.
   *
   * Filters may mutate or delay the response headers.
   *
   * @param headers: The current response headers.
   * @param endStream: Whether this is a headers-only response.
   * @param streamIntel: Internal HTTP stream metrics, context, and other details.
   *
   * @return: The header status containing headers with which to continue or buffer.
   */
  fun onResponseHeaders(
    headers: ResponseHeaders,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterHeadersStatus<ResponseHeaders>

  /**
   * Called any number of times whenever body data is received.
   *
   * Filters may mutate or buffer (defer and concatenate) the data.
   *
   * @param body: The inbound body data chunk.
   * @param endStream: Whether this is the last data frame.
   * @param streamIntel: Internal HTTP stream metrics, context, and other details.
   *
   * @return: The data status containing body with which to continue or buffer.
   */
  fun onResponseData(
    body: ByteBuffer,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterDataStatus<ResponseHeaders>

  /**
   * Called at most once when the response is closed from the server with trailers.
   *
   * Filters may mutate or delay the trailers. Note trailers imply the stream has ended.
   *
   * @param trailers: The inbound trailers.
   * @param streamIntel: Internal HTTP stream metrics, context, and other details.
   *
   * @return: The trailer status containing body with which to continue or buffer.
   */
  fun onResponseTrailers(
    trailers: ResponseTrailers,
    streamIntel: StreamIntel
  ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers>

  /**
   * Called at most once when an error within Envoy occurs.
   *
   * Only one of onError, onCancel, or onComplete will be called per stream. This should be
   * considered a terminal state, and invalidates any previous attempts to `stopIteration{...}`.
   *
   * @param error: The error that occurred within Envoy.
   * @param finalStreamIntel: Final internal HTTP stream metrics, context, and other details.
   */
  fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel)

  /**
   * Called at most once when the client cancels the stream.
   *
   * Only one of onError, onCancel, or onComplete will be called per stream. This should be
   * considered a terminal state, and invalidates any previous attempts to `stopIteration{...}`.
   *
   * @param finalStreamIntel: Final internal HTTP stream metrics, context, and other details.
   */
  fun onCancel(finalStreamIntel: FinalStreamIntel)

  /**
   * Called at most once when the stream completes gracefully.
   *
   * Only one of onError, onCancel, or onComplete will be called per stream. This should be
   * considered a terminal state, and invalidates any previous attempts to `stopIteration{...}`.
   *
   * @param finalStreamIntel: Final internal HTTP stream metrics, context, and other details.
   */
  fun onComplete(finalStreamIntel: FinalStreamIntel)
}
package io.envoyproxy.envoymobile

import java.nio.ByteBuffer

/*
 * Status to be returned by filters when transmitting or receiving data.
 */
sealed class FilterDataStatus<T : Headers>(val status: Int) {
  /**
   * Continue filter chain iteration. If headers have not yet been sent to the next filter, they
   * will be sent first via `onRequestHeaders()`/`onResponseHeaders()`.
   *
   * @param data: The (potentially-modified) data to be forwarded along the filter chain.
   */
  class Continue<T : Headers>(val data: ByteBuffer) : FilterDataStatus<T>(0)

  /**
   * Do not iterate to any of the remaining filters in the chain, and buffer body data for later
   * dispatching. The data passed to this invocation will be buffered internally.
   *
   * `onData` will continue to be called with any new chunks of data appended to all data that has
   * been buffered so far.
   *
   * Returning `ResumeIteration` from another filter invocation or calling
   * `resumeRequest()`/`resumeResponse()` MUST be called when continued filter iteration is desired.
   *
   * This should be called by filters which must parse a larger block of the incoming data before
   * continuing processing.
   */
  class StopIterationAndBuffer<T : Headers> : FilterDataStatus<T>(1)

  /**
   * Do not iterate to any of the remaining filters in the chain, and do not internally buffer data.
   *
   * `onData` will continue to be called with new chunks of data.
   *
   * Returning `ResumeIteration` from another filter invocation or calling
   * `resumeRequest()`/`resumeResponse()` MUST be called when continued filter iteration is desired.
   *
   * This may be called by filters which must parse a larger block of the incoming data before
   * continuing processing, and will handle their own buffering.
   */
  class StopIterationNoBuffer<T : Headers> : FilterDataStatus<T>(3)

  /**
   * Resume previously-stopped iteration, possibly forwarding headers if iteration was stopped
   * during an on*Headers invocation.
   *
   * It is an error to return `ResumeIteration` if iteration is not currently stopped, and it is an
   * error to include headers if headers have already been forwarded to the next filter (i.e.
   * iteration was stopped during an on*Data invocation instead of on*Headers).
   *
   * @param headers: Headers to be forwarded (if needed).
   * @param data: Data to be forwarded.
   */
  class ResumeIteration<T : Headers>(val headers: T?, val data: ByteBuffer) :
    FilterDataStatus<T>(-1)
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilterCallbacks

/** Envoy implementation of `RequestFilterCallbacks`. */
internal class RequestFilterCallbacksImpl
constructor(internal val callbacks: EnvoyHTTPFilterCallbacks) : RequestFilterCallbacks {

  override fun resumeRequest() {
    callbacks.resumeIteration()
  }

  override fun resetIdleTimer() {
    callbacks.resetIdleTimer()
  }
}
package io.envoyproxy.envoymobile

/*
 * Status to be returned by filters when transmitting or receiving headers.
 */
sealed class FilterHeadersStatus<T : Headers>(val status: Int) {
  /**
   * Continue filter chain iteration, passing the provided headers through.
   *
   * @param headers: The (potentially-modified) headers to be forwarded along the filter chain.
   */
  class Continue<T : Headers>(val headers: T) : FilterHeadersStatus<T>(0)

  /**
   * Do not iterate to any of the remaining filters in the chain with headers.
   *
   * Returning `ResumeIteration` from another filter invocation or calling
   * `resumeRequest()`/`resumeResponse()` MUST occur when continued filter iteration is desired.
   */
  class StopIteration<T : Headers> : FilterHeadersStatus<T>(1)
}
package io.envoyproxy.envoymobile

interface RequestFilterCallbacks {
  /**
   * Resume iterating through the filter chain with buffered headers and body data.
   *
   * This can only be called if the filter has previously returned `stopIteration{...}` from
   * `onHeaders()`/`onData()`/`onTrailers()`.
   *
   * This will result in an `onResumeRequest()` callback on the RequestFilter.
   *
   * If the request is not complete, the filter may receive further `onData()`/`onTrailers()` calls.
   */
  fun resumeRequest()

  /**
   * Reset the underlying stream idle timeout to its configured threshold.
   *
   * This may be useful if a filter stops iteration for an extended period of time, since ordinarily
   * timeouts will still apply. This may be called periodically to continue to indicate "activity"
   * on the stream.
   */
  fun resetIdleTimer()
}
package io.envoyproxy.envoymobile

import java.nio.ByteBuffer

/*
 * RequestFilter supporting asynchronous resumption.
 */
interface AsyncRequestFilter : RequestFilter {
  /**
   * Called by the filter manager once to initialize the filter callbacks that the filter should
   * use.
   *
   * @param callbacks: The callbacks for this filter to use to interact with the chain.
   */
  fun setRequestFilterCallbacks(callbacks: RequestFilterCallbacks)

  /**
   * Invoked explicitly in response to an asynchronous `resumeRequest()` callback when filter
   * iteration has been stopped. The parameters passed to this invocation will be a snapshot of any
   * stream state that has not yet been forwarded along the filter chain.
   *
   * As with other filter invocations, this will be called on Envoy's main thread, and thus no
   * additional synchronization is required between this and other invocations.
   *
   * @param headers: Headers, if `StopIteration` was returned from `onRequestHeaders`.
   * @param data: Any data that has been buffered where `StopIterationAndBuffer` was returned.
   * @param trailers: Trailers, if `StopIteration` was returned from `onRequestTrailers`.
   * @param endStream: True, if the stream ended with the previous (and thus, last) invocation.
   * @param streamIntel: Internal HTTP stream metrics, context, and other details.
   *
   * @return: The resumption status including any HTTP entities that will be forwarded.
   */
  fun onResumeRequest(
    headers: RequestHeaders?,
    data: ByteBuffer?,
    trailers: RequestTrailers?,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterResumeStatus<RequestHeaders, RequestTrailers>
}
package io.envoyproxy.envoymobile

import java.nio.ByteBuffer

/*
 * Filter executed for outbound requests, providing the ability to observe and mutate streams.
 */
interface RequestFilter : Filter {
  /**
   * Called once when the request is initiated.
   *
   * Filters may mutate or delay the request headers.
   *
   * @param headers: The current request headers.
   * @param endStream: Whether this is a headers-only request.
   * @param streamIntel: Internal HTTP stream metrics, context, and other details.
   *
   * @return: The header status containing headers with which to continue or buffer.
   */
  fun onRequestHeaders(
    headers: RequestHeaders,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterHeadersStatus<RequestHeaders>

  /**
   * Called any number of times whenever body data is sent.
   *
   * Filters may mutate or buffer (defer and concatenate) the data.
   *
   * @param body: The outbound body data chunk.
   * @param endStream: Whether this is the last data frame.
   * @param streamIntel: Internal HTTP stream metrics, context, and other details.
   *
   * @return: The data status containing body with which to continue or buffer.
   */
  fun onRequestData(
    body: ByteBuffer,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterDataStatus<RequestHeaders>

  /**
   * Called at most once when the request is closed from the client with trailers.
   *
   * Filters may mutate or delay the trailers. Note trailers imply the stream has ended.
   *
   * @param trailers: The outbound trailers.
   * @param streamIntel: Internal HTTP stream metrics, context, and other details.
   *
   * @return: The trailer status containing body with which to continue or buffer.
   */
  fun onRequestTrailers(
    trailers: RequestTrailers,
    streamIntel: StreamIntel
  ): FilterTrailersStatus<RequestHeaders, RequestTrailers>
}
package io.envoyproxy.envoymobile

import java.nio.ByteBuffer

/*
 * Status to be returned by filters after resuming iteration asynchronously.
 */
sealed class FilterResumeStatus<T : Headers, U : Trailers>(val status: Int) {
  /**
   * Resume previously-stopped iteration, potentially forwarding headers, data, and/or trailers that
   * have not yet been passed along the filter chain.
   *
   * It is an error to return ResumeIteration if iteration is not currently stopped, and it is an
   * error to include headers if headers have already been forwarded to the next filter (i.e.
   * iteration was stopped during an on*Data invocation instead of on*Headers). It is also an error
   * to include data or trailers if `endStream` was previously set or if trailers have already been
   * forwarded.
   *
   * @param headers: Headers to be forwarded (if needed).
   * @param data: Data to be forwarded (if needed).
   * @param trailers: Trailers to be forwarded (if needed).
   */
  class ResumeIteration<T : Headers, U : Trailers>(
    val headers: T?,
    val data: ByteBuffer?,
    val trailers: U?
  ) : FilterResumeStatus<T, U>(-1)
}
package io.envoyproxy.envoymobile

import java.nio.ByteBuffer

/*
 * Status to be returned by filters when transmitting or receiving trailers.
 */
sealed class FilterTrailersStatus<T : Headers, U : Trailers>(val status: Int) {
  /**
   * Continue filter chain iteration, passing the provided trailers through.
   *
   * @param trailers: The (potentially-modified) trailers to be forwarded along the filter chain.
   */
  class Continue<T : Headers, U : Trailers>(val trailers: U) : FilterTrailersStatus<T, U>(0)

  /**
   * Do not iterate to any of the remaining filters in the chain with trailers.
   *
   * Because trailers are by definition the last HTTP entity of a request or response, only
   * asynchronous filters support resumption after returning `StopIteration` from on*Trailers.
   * Calling `resumeRequest()`/`resumeResponse()` MUST occur if continued filter iteration is
   * desired.
   */
  class StopIteration<T : Headers, U : Trailers> : FilterTrailersStatus<T, U>(1)

  /**
   * Resume previously-stopped iteration, possibly forwarding headers and data if iteration was
   * stopped during an on*Headers or on*Data invocation.
   *
   * It is an error to return `ResumeIteration` if iteration is not currently stopped, and it is an
   * error to include headers if headers have already been forwarded to the next filter (i.e.
   * iteration was stopped during an on*Data invocation instead of on*Headers).
   *
   * @param headers: Headers to be forwarded (if needed).
   * @param data: Data to be forwarded (if needed).
   * @param trailers: Trailers to be forwarded.
   */
  class ResumeIteration<T : Headers, U : Trailers>(
    val headers: T?,
    val data: ByteBuffer?,
    val trailers: U
  ) : FilterTrailersStatus<T, U>(-1)
}
package io.envoyproxy.envoymobile

interface ResponseFilterCallbacks {
  /**
   * Resume iterating through the filter chain with buffered headers and body data.
   *
   * This can only be called if the filter has previously returned `stopIteration{...}` from
   * `onHeaders()`/`onData()`/`onTrailers()`.
   *
   * This will result in an `onResumeResponse()` callback on the ResponseFilter.
   *
   * If the response is not complete, the filter may receive further `onData()`/`onTrailers()`
   * calls.
   */
  fun resumeResponse()

  /**
   * Reset the underlying stream idle timeout to its configured threshold.
   *
   * This may be useful if a filter stops iteration for an extended period of time, since ordinarily
   * timeouts will still apply. This may be called periodically to continue to indicate "activity"
   * on the stream.
   */
  fun resetIdleTimer()
}
package io.envoyproxy.envoymobile

/**
 * Base builder class used to construct `Headers` instances. See `{Request|Response}HeadersBuilder`
 * for usage.
 */
open class HeadersBuilder {
  protected val container: HeadersContainer

  /**
   * Instantiate a new builder, only used by child classes.
   *
   * @param container: The headers container to start with.
   */
  internal constructor(container: HeadersContainer) {
    this.container = container
  }

  /**
   * Append a value to the header name.
   *
   * @param name: The header name.
   * @param value: The value associated to the header name.
   * @return HeadersBuilder, This builder.
   */
  open fun add(name: String, value: String): HeadersBuilder {
    if (isRestrictedHeader(name)) {
      return this
    }
    container.add(name, value)
    return this
  }

  /**
   * Replace all values at the provided name with a new set of header values.
   *
   * @param name: The header name.
   * @param value: The value associated to the header name.
   * @return HeadersBuilder, This builder.
   */
  open fun set(name: String, value: MutableList<String>): HeadersBuilder {
    if (isRestrictedHeader(name)) {
      return this
    }
    container.set(name, value)
    return this
  }

  /**
   * Remove all headers with this name.
   *
   * @param name: The header name to remove.
   * @return HeadersBuilder, This builder.
   */
  open fun remove(name: String): HeadersBuilder {
    if (isRestrictedHeader(name)) {
      return this
    }
    container.remove(name)
    return this
  }

  /**
   * Allows for setting headers that are not publicly mutable (i.e., restricted headers).
   *
   * @param name: The header name.
   * @param value: The value associated to the header name.
   * @return HeadersBuilder, This builder.
   */
  internal open fun internalSet(name: String, value: MutableList<String>): HeadersBuilder {
    container.set(name, value)
    return this
  }

  private fun isRestrictedHeader(name: String) =
    name.startsWith(":") ||
      name.startsWith("x-envoy-mobile", ignoreCase = true) ||
      name.equals("host", ignoreCase = true)
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.EnvoyEngine
import java.nio.ByteBuffer
import java.util.concurrent.Executor
import java.util.concurrent.Executors

/**
 * A type representing a stream that has not yet been started.
 *
 * Constructed via `StreamClient`, and used to assign response callbacks prior to starting an
 * `Stream` by calling `start()`.
 *
 * @param engine Engine to use for starting streams.
 */
open class StreamPrototype(private val engine: EnvoyEngine) {
  private val callbacks = StreamCallbacks()
  private var explicitFlowControl = false
  private var useByteBufferPosition = false

  /**
   * Start a new stream.
   *
   * @param executor Executor on which to receive callback events.
   * @return The new stream.
   */
  open fun start(executor: Executor = Executors.newSingleThreadExecutor()): Stream {
    val engineStream = engine.startStream(createCallbacks(executor), explicitFlowControl)
    return Stream(engineStream, useByteBufferPosition)
  }

  /**
   * Allows explicit flow control to be enabled. When flow control is enabled, the owner of a stream
   * is responsible for providing a buffer to receive response body data. If the buffer is smaller
   * than the amount of data available, response callbacks will halt, and the underlying network
   * protocol may signal for the server to stop sending data, until more space is available. This
   * can limit the memory consumed by a server response, but may also result in reduced overall
   * throughput, depending on usage.
   *
   * @param enabled Whether explicit flow control will be enabled for the stream.
   * @return This stream, for chaining syntax.
   */
  fun setExplicitFlowControl(enabled: Boolean): StreamPrototype {
    this.explicitFlowControl = enabled
    return this
  }

  /**
   * Specify how to determine the length of data to send for a given ByteBuffer.
   *
   * @param enabled Use ByteBuffer's position when true, otherwise use its capacity.
   * @return This stream, for chaining syntax.
   */
  fun setUseByteBufferPosition(enabled: Boolean): StreamPrototype {
    this.useByteBufferPosition = enabled
    return this
  }

  /**
   * Specify a callback for when response headers are received by the stream. If `endStream` is
   * `true`, the stream is complete, pending an onComplete callback.
   *
   * @param closure Closure which will receive the headers and flag indicating if the stream is
   *   headers-only.
   * @return This stream, for chaining syntax.
   */
  fun setOnResponseHeaders(
    closure: (headers: ResponseHeaders, endStream: Boolean, streamIntel: StreamIntel) -> Unit
  ): StreamPrototype {
    callbacks.onHeaders = closure
    return this
  }

  /**
   * Specify a callback for when a data frame is received by the stream. If `endStream` is `true`,
   * the stream is complete, pending an onComplete callback.
   *
   * @param closure Closure which will receive the data and flag indicating whether this is the last
   *   data frame.
   * @return This stream, for chaining syntax.
   */
  fun setOnResponseData(
    closure: (data: ByteBuffer, endStream: Boolean, streamIntel: StreamIntel) -> Unit
  ): StreamPrototype {
    callbacks.onData = closure
    return this
  }

  /**
   * Specify a callback for when trailers are received by the stream. If the closure is called, the
   * stream is complete, pending an onComplete callback.
   *
   * @param closure Closure which will receive the trailers.
   * @return This stream, for chaining syntax.
   */
  fun setOnResponseTrailers(
    closure: (trailers: ResponseTrailers, streamIntel: StreamIntel) -> Unit
  ): StreamPrototype {
    callbacks.onTrailers = closure
    return this
  }

  /**
   * Specify a callback for when an internal Envoy exception occurs with the stream. If the closure
   * is called, the stream is complete.
   *
   * @param closure Closure which will be called when an error occurs.
   * @return This stream, for chaining syntax.
   */
  fun setOnError(
    closure: (error: EnvoyError, finalStreamIntel: FinalStreamIntel) -> Unit
  ): StreamPrototype {
    callbacks.onError = closure
    return this
  }

  /**
   * Specify a callback for when a stream is complete. If the closure is called, the stream is
   * complete.
   *
   * @param closure Closure which will be called when an error occurs.
   * @return This stream, for chaining syntax.
   */
  fun setOnComplete(closure: (finalStreamIntel: FinalStreamIntel) -> Unit): StreamPrototype {
    callbacks.onComplete = closure
    return this
  }

  /**
   * Specify a callback for when the stream is canceled. If the closure is called, the stream is
   * complete.
   *
   * @param closure Closure which will be called when the stream is canceled.
   * @return This stream, for chaining syntax.
   */
  fun setOnCancel(closure: (finalStreamIntel: FinalStreamIntel) -> Unit): StreamPrototype {
    callbacks.onCancel = closure
    return this
  }

  /**
   * Specify a callback for when additional send window becomes available. This is only ever called
   * when the library is in explicit flow control mode. When enabled, the issuer should wait for
   * this callback after calling sendData, before making another call to sendData.
   *
   * @param closure Closure which will be called when additional send window becomes available.
   * @return This stream, for chaining syntax.
   */
  fun setOnSendWindowAvailable(closure: (streamIntel: StreamIntel) -> Unit): StreamPrototype {
    callbacks.onSendWindowAvailable = closure
    return this
  }

  /**
   * Create engine callbacks using the provided queue.
   *
   * @param executor Executor on which to receive callback events.
   * @return A new set of engine callbacks.
   */
  internal fun createCallbacks(executor: Executor): EnvoyHTTPCallbacksAdapter {
    return EnvoyHTTPCallbacksAdapter(executor, callbacks)
  }
}
package io.envoyproxy.envoymobile

import java.lang.IllegalArgumentException

/**
 * Specifies how a request may be retried, containing one or more rules.
 *
 * @param maxRetryCount Maximum number of retries that a request may be performed.
 * @param retryOn Rules checked for retrying.
 * @param retryStatusCodes Additional list of status codes that should be retried.
 * @param perRetryTimeoutMS Timeout (in milliseconds) to apply to each retry. Must be <=
 *   `totalUpstreamTimeoutMS` if it's a positive number.
 * @param totalUpstreamTimeoutMS Total timeout (in milliseconds) that includes all retries. Spans
 *   the point at which the entire downstream request has been processed and when the upstream
 *   response has been completely processed. Null or 0 may be specified to disable it.
 */
data class RetryPolicy(
  val maxRetryCount: Int,
  val retryOn: List<RetryRule>,
  val retryStatusCodes: List<Int> = emptyList(),
  val perRetryTimeoutMS: Long? = null,
  val totalUpstreamTimeoutMS: Long? = 15000
) {
  init {
    if (
      perRetryTimeoutMS != null &&
        totalUpstreamTimeoutMS != null &&
        perRetryTimeoutMS > totalUpstreamTimeoutMS &&
        totalUpstreamTimeoutMS != 0L
    ) {
      throw IllegalArgumentException("Per-retry timeout cannot be less than total timeout")
    }
  }

  companion object {
    /**
     * Initialize the retry policy from a set of headers.
     *
     * @param headers: The headers with which to initialize the retry policy.
     */
    internal fun from(headers: RequestHeaders): RetryPolicy? {
      val maxRetries = headers.value("x-envoy-max-retries")?.first()?.toIntOrNull() ?: return null

      return RetryPolicy(
        maxRetries,
        // Envoy internally coalesces multiple x-envoy header values into one comma-delimited value.
        // These flatMap transformations split those values up to correctly map back to
        // Kotlin enums.
        headers
          .value("x-envoy-retry-on")
          ?.flatMap { it.split(",") }
          ?.map { retryOn -> RetryRule.enumValue(retryOn) }
          ?.filterNotNull() ?: emptyList(),
        headers
          .value("x-envoy-retriable-status-codes")
          ?.flatMap { it.split(",") }
          ?.map { statusCode -> statusCode.toIntOrNull() }
          ?.filterNotNull() ?: emptyList(),
        headers.value("x-envoy-upstream-rq-per-try-timeout-ms")?.firstOrNull()?.toLongOrNull(),
        headers.value("x-envoy-upstream-rq-timeout-ms")?.firstOrNull()?.toLongOrNull()
      )
    }
  }
}

/**
 * Rules that may be used with `RetryPolicy`. See the `x-envoy-retry-on` Envoy header for
 * documentation.
 */
enum class RetryRule(internal val stringValue: String) {
  STATUS_5XX("5xx"),
  GATEWAY_ERROR("gateway-error"),
  CONNECT_FAILURE("connect-failure"),
  REFUSED_STREAM("refused-stream"),
  RETRIABLE_4XX("retriable-4xx"),
  RETRIABLE_HEADERS("retriable-headers"),
  RESET("reset");

  companion object {
    internal fun enumValue(stringRepresentation: String): RetryRule? {
      return when (stringRepresentation) {
        "5xx" -> STATUS_5XX
        "gateway-error" -> GATEWAY_ERROR
        "connect-failure" -> CONNECT_FAILURE
        "refused-stream" -> REFUSED_STREAM
        "retriable-4xx" -> RETRIABLE_4XX
        "retriable-headers" -> RETRIABLE_HEADERS
        "reset" -> RESET
        // This is mapped to null because this string value is added to headers automatically
        // in RetryPolicy.outboundHeaders()
        "retriable-status-codes" -> null
        else -> throw IllegalArgumentException("invalid value $stringRepresentation")
      }
    }
  }
}
package io.envoyproxy.envoymobile

/**
 * Base class representing trailers data structures. To instantiate new instances see
 * `{Request|Response}TrailersBuilder`.
 */
open class Trailers : Headers {
  /**
   * Internal constructor used by builders.
   *
   * @param trailers: Trailers to set.
   */
  protected constructor(
    trailers: Map<String, List<String>>
  ) : super(HeadersContainer.create(trailers))

  protected constructor(container: HeadersContainer) : super(container)
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.types.EnvoyFinalStreamIntel
import io.envoyproxy.envoymobile.engine.types.EnvoyStreamIntel

/**
 * Exposes one time HTTP stream metrics, context, and other details.
 *
 * Note: a timestamp field (ends with "Ms") with a value of -1 indicates that it is absent.
 *
 * @param streamId The stream identifier.
 * @param connectionId The connection identifier.
 * @param attemptCount The number of attempts used to perform a given request.
 * @param streamStartMs The time the stream started (a.k.a. request started), in ms since the epoch.
 * @param dnsStartMs The time the DNS resolution for this request started, in ms since the epoch.
 * @param dnsEndMs The time the DNS resolution for this request completed, in ms since the epoch.
 * @param connectStartMs The time the upstream connection started, in ms since the epoch. This may
 *   not be set if socketReused is false.
 * @param connectEndMs The time the upstream connection completed, in ms since the epoch. This may
 *   not be set if socketReused is false.
 * @param sslStartMs The time the SSL handshake started, in ms since the epoch. This may not be set
 *   if socketReused is false.
 * @param sslEndMs The time the SSL handshake completed, in ms since the epoch. This may not be set
 *   if socketReused is false.
 * @param sendingStartMs The time the first byte of the request was sent upstream, in ms since the
 *   epoch.
 * @param sendingEndMs The time the last byte of the request was sent upstream, in ms since the
 *   epoch.
 * @param responseStartMs The time the first byte of the response was received, in ms since the
 *   epoch.
 * @param streamEndMs The time when the stream reached a final state (Error, Cancel, Success), in ms
 *   since the epoch.
 * @param socketReused True if the upstream socket had been used previously.
 * @param sentByteCount The number of bytes sent upstream.
 * @param receivedByteCount The number of bytes received from upstream.
 * @param responseFlags The response flags for the stream.
 */
@Suppress("LongParameterList")
class FinalStreamIntel
constructor(
  streamId: Long,
  connectionId: Long,
  attemptCount: Long,
  val streamStartMs: Long,
  val dnsStartMs: Long,
  val dnsEndMs: Long,
  val connectStartMs: Long,
  val connectEndMs: Long,
  val sslStartMs: Long,
  val sslEndMs: Long,
  val sendingStartMs: Long,
  val sendingEndMs: Long,
  val responseStartMs: Long,
  val streamEndMs: Long,
  val socketReused: Boolean,
  val sentByteCount: Long,
  val receivedByteCount: Long,
  val responseFlags: Long
) : StreamIntel(streamId, connectionId, attemptCount) {
  constructor(
    superBase: EnvoyStreamIntel,
    base: EnvoyFinalStreamIntel
  ) : this(
    superBase.streamId,
    superBase.connectionId,
    superBase.attemptCount,
    base.streamStartMs,
    base.dnsStartMs,
    base.dnsEndMs,
    base.connectStartMs,
    base.connectEndMs,
    base.sslStartMs,
    base.sslEndMs,
    base.sendingStartMs,
    base.sendingEndMs,
    base.responseStartMs,
    base.streamEndMs,
    base.socketReused,
    base.sentByteCount,
    base.receivedByteCount,
    base.responseFlags
  )
}
package io.envoyproxy.envoymobile

/**
 * Engine represents a running instance of Envoy Mobile, and provides client interfaces that run on
 * that instance.
 */
interface Engine {

  /** @return a {@link StreamClient} for opening and managing HTTP streams. */
  fun streamClient(): StreamClient

  /** @return a {@link PulseClient} for recording time series metrics. */
  fun pulseClient(): PulseClient

  /** Terminates the running engine. */
  fun terminate()

  /**
   * Retrieve the value of all active stats. Note that this function may block for some time.
   *
   * @return The list of active stats and their values, or empty string of the operation failed
   */
  fun dumpStats(): String

  /** Refresh DNS, and drain connections owned by this Engine. */
  fun resetConnectivityState()
}
package io.envoyproxy.envoymobile

import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.util.concurrent.Executor
import java.util.concurrent.Executors

/**
 * A type representing a gRPC stream that has not yet been started.
 *
 * Constructed via `GRPCClient`, and used to assign response callbacks prior to starting a
 * `GRPCStream` by calling `start()`.
 */
class GRPCStreamPrototype(private val underlyingStream: StreamPrototype) {
  /**
   * Start a new gRPC stream.
   *
   * @param executor Executor on which to receive callback events.
   * @return The new gRPC stream.
   */
  fun start(executor: Executor = Executors.newSingleThreadExecutor()): GRPCStream {
    val stream = underlyingStream.start(executor)
    return GRPCStream(stream)
  }

  /**
   * Specify a callback for when response headers are received by the stream.
   *
   * @param closure Closure which will receive the headers and flag indicating if the stream is
   *   headers-only.
   * @return This stream, for chaining syntax.
   */
  fun setOnResponseHeaders(
    closure: (headers: ResponseHeaders, endStream: Boolean, streamIntel: StreamIntel) -> Unit
  ): GRPCStreamPrototype {
    underlyingStream.setOnResponseHeaders(closure)
    return this
  }

  /**
   * Specify a callback for when a new message has been received by the stream. If `endStream` is
   * `true`, the stream is complete.
   *
   * @param closure Closure which will receive messages on the stream.
   * @return This stream, for chaining syntax.
   */
  fun setOnResponseMessage(
    closure: (data: ByteBuffer, streamIntel: StreamIntel) -> Unit
  ): GRPCStreamPrototype {
    val byteBufferedOutputStream = ByteArrayOutputStream()
    val processor = GRPCMessageProcessor()
    var processState: GRPCMessageProcessor.ProcessState =
      GRPCMessageProcessor.ProcessState.CompressionFlag
    underlyingStream.setOnResponseData { byteBuffer, _, streamIntel ->
      val byteBufferArray =
        if (byteBuffer.hasArray()) {
          byteBuffer.array()
        } else {
          val array = ByteArray(byteBuffer.remaining())
          byteBuffer.get(array)
          array
        }
      byteBufferedOutputStream.write(byteBufferArray)

      processState =
        processor.processData(byteBufferedOutputStream, processState, streamIntel, closure)
    }

    return this
  }

  /**
   * Specify a callback for when trailers are received by the stream. If the closure is called, the
   * stream is complete.
   *
   * @param closure Closure which will receive the trailers.
   * @return This stream, for chaining syntax.
   */
  fun setOnResponseTrailers(
    closure: (trailers: ResponseTrailers, streamIntel: StreamIntel) -> Unit
  ): GRPCStreamPrototype {
    underlyingStream.setOnResponseTrailers(closure)
    return this
  }

  /**
   * Specify a callback for when an internal Envoy exception occurs with the stream. If the closure
   * is called, the stream is complete.
   *
   * @param closure Closure which will be called when an error occurs.
   * @return This stream, for chaining syntax.
   */
  fun setOnError(
    closure: (error: EnvoyError, finalStreamIntel: FinalStreamIntel) -> Unit
  ): GRPCStreamPrototype {
    underlyingStream.setOnError(closure)
    return this
  }

  /**
   * Specify a callback for when the stream is canceled. If the closure is called, the stream is
   * complete.
   *
   * @param closure Closure which will be called when the stream is canceled.
   * @return This stream, for chaining syntax.
   */
  fun setOnCancel(closure: (finalStreamIntel: FinalStreamIntel) -> Unit): GRPCStreamPrototype {
    underlyingStream.setOnCancel(closure)
    return this
  }
}

private class GRPCMessageProcessor {
  /** Represents the process state of the response stream's body data. */
  sealed class ProcessState {
    // Awaiting a gRPC compression flag.
    object CompressionFlag : ProcessState()

    // Awaiting the length specification of the next message.
    object MessageLength : ProcessState()

    // Awaiting a message with the specified length.
    class Message(val messageLength: Int) : ProcessState()
  }

  /**
   * Recursively processes a buffer of data, buffering it into messages based on state. When a
   * message has been fully buffered, `onMessage` will be called with the message.
   *
   * @param bufferedStream The buffer of data from which to determine state and messages.
   * @param processState The current process state of the buffering.
   * @param onMessage Closure to call when a new message is available.
   * @return The state after processing the passed data.
   */
  fun processData(
    bufferedStream: ByteArrayOutputStream,
    processState: GRPCMessageProcessor.ProcessState,
    streamIntel: StreamIntel,
    onMessage: (byteBuffer: ByteBuffer, streamIntel: StreamIntel) -> Unit
  ): GRPCMessageProcessor.ProcessState {
    var nextState = processState

    when (processState) {
      is ProcessState.CompressionFlag -> {
        val byteArray = bufferedStream.toByteArray()
        if (byteArray.isEmpty()) {
          // We don't have enough information to extract the compression flag, so we'll just return
          return ProcessState.CompressionFlag
        }

        val compressionFlag = byteArray[0]
        // TODO: Support gRPC compression https://github.com/envoyproxy/envoy-mobile/issues/501.
        if (compressionFlag.compareTo(0) != 0) {
          bufferedStream.reset()
        }

        nextState = ProcessState.MessageLength
      }
      is ProcessState.MessageLength -> {
        if (bufferedStream.size() < GRPC_PREFIX_LENGTH) {
          // We don't have enough information to extract the message length, so we'll just return
          return ProcessState.MessageLength
        }

        val byteArray = bufferedStream.toByteArray()
        val buffer = ByteBuffer.wrap(byteArray.sliceArray(1..4))
        buffer.order(ByteOrder.BIG_ENDIAN)
        val messageLength = buffer.int
        nextState = ProcessState.Message(messageLength)
      }
      is ProcessState.Message -> {
        if (bufferedStream.size() < processState.messageLength + GRPC_PREFIX_LENGTH) {
          // We don't have enough bytes to construct the message, so we'll just return
          return ProcessState.Message(processState.messageLength)
        }

        val byteArray = bufferedStream.toByteArray()
        onMessage(
          ByteBuffer.wrap(
            byteArray.sliceArray(
              GRPC_PREFIX_LENGTH until GRPC_PREFIX_LENGTH + processState.messageLength
            )
          ),
          streamIntel
        )
        bufferedStream.reset()
        bufferedStream.write(
          byteArray.sliceArray(GRPC_PREFIX_LENGTH + processState.messageLength until byteArray.size)
        )

        val remainingLength = GRPC_PREFIX_LENGTH + processState.messageLength until byteArray.size
        if (byteArray.sliceArray(remainingLength).isEmpty()) {
          return ProcessState.CompressionFlag
        } else {
          nextState = ProcessState.CompressionFlag
        }
      }
    }

    return processData(bufferedStream, nextState, streamIntel, onMessage)
  }
}
package io.envoyproxy.envoymobile

/*
 * Headers representing an outbound gRPC request.
 */
class GRPCRequestHeaders : RequestHeaders {
  /**
   * Internal constructor used by builders.
   *
   * @param headers: Headers to set.
   */
  internal constructor(headers: Map<String, MutableList<String>>) : super(HeadersContainer(headers))

  internal constructor(container: HeadersContainer) : super(container)

  /**
   * Convert the headers back to a builder for mutation.
   *
   * @return GRPCRequestHeadersBuilder, The new builder.
   */
  fun toGRPCRequestHeadersBuilder() = GRPCRequestHeadersBuilder(container)
}
package io.envoyproxy.envoymobile

import java.nio.ByteBuffer
import java.nio.ByteOrder

/**
 * A type representing a gRPC stream that is actively transferring data.
 *
 * Constructed using `GRPCStreamPrototype`, and used to write to the network.
 */
class GRPCStream(private val underlyingStream: Stream) {
  /**
   * Send headers over the gRPC stream.
   *
   * @param headers Headers to send over the stream.
   * @param endStream Whether this is a headers-only request.
   * @return This stream, for chaining syntax.
   */
  fun sendHeaders(headers: GRPCRequestHeaders, endStream: Boolean): GRPCStream {
    underlyingStream.sendHeaders(headers as RequestHeaders, endStream)
    return this
  }

  /**
   * Send a protobuf message's binary data over the gRPC stream.
   *
   * @param messageData Binary data of a protobuf message to send.
   * @return This stream, for chaining syntax.
   */
  fun sendMessage(messageData: ByteBuffer): GRPCStream {
    // https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests
    // Length-Prefixed-Message = Compressed-Flag | Message-Length | Message
    // Compressed-Flag = 0 / 1, encoded as 1 byte unsigned integer
    // Message-Length = length of Message, encoded as 4 byte unsigned integer (big endian)
    // Message = binary representation of protobuf messageData
    val byteBuffer = ByteBuffer.allocate(GRPC_PREFIX_LENGTH)

    // Compression flag (1 byte) - 0, not compressed
    byteBuffer.put(0)

    // Message length
    val messageLength = messageData.remaining()
    byteBuffer.order(ByteOrder.BIG_ENDIAN)
    byteBuffer.putInt(messageLength)

    underlyingStream.sendData(byteBuffer)
    underlyingStream.sendData(messageData)
    return this
  }

  /** Cancel the stream forcefully regardless of whether the peer has more data to send. */
  fun cancel() {
    underlyingStream.cancel()
  }
}
package io.envoyproxy.envoymobile

// 1 byte for the compression flag, 4 bytes for the message length (int)
internal const val GRPC_PREFIX_LENGTH = 5

/**
 * Client that supports sending and receiving gRPC traffic.
 *
 * @param streamClient The stream client to use for gRPC streams.
 */
class GRPCClient(private val streamClient: StreamClient) {
  /**
   * Create a new gRPC stream prototype which can be used to start streams.
   *
   * @return The new gRPC stream prototype.
   */
  fun newGRPCStreamPrototype() = GRPCStreamPrototype(streamClient.newStreamPrototype())
}
package io.envoyproxy.envoymobile

/*
 * Builder used for constructing instances of `GRPCRequestHeaders`.
 */
class GRPCRequestHeadersBuilder : HeadersBuilder {
  /**
   * Internal constructor used by builders.
   *
   * @param headers: Headers to set.
   */
  internal constructor(headers: Map<String, MutableList<String>>) : super(HeadersContainer(headers))

  /**
   * Instantiate a new builder.
   *
   * @param container: The headers container to start with.
   */
  internal constructor(container: HeadersContainer) : super(container)

  override fun add(name: String, value: String): GRPCRequestHeadersBuilder {
    super.add(name, value)
    return this
  }

  override fun set(name: String, value: MutableList<String>): GRPCRequestHeadersBuilder {
    super.set(name, value)
    return this
  }

  override fun remove(name: String): GRPCRequestHeadersBuilder {
    super.remove(name)
    return this
  }

  override fun internalSet(name: String, value: MutableList<String>): GRPCRequestHeadersBuilder {
    super.internalSet(name, value)
    return this
  }

  /**
   * Initialize a new builder.
   *
   * @param scheme The URL scheme for the request (i.e., "https").
   * @param authority The URL authority for the request (i.e., "api.foo.com").
   * @param path Path for the RPC (i.e., `/pb.api.v1.Foo/GetBar`).
   */
  constructor(
    scheme: String,
    authority: String,
    path: String
  ) : super(
    HeadersContainer(
      mapOf<String, MutableList<String>>(
        ":authority" to mutableListOf<String>(authority),
        ":method" to mutableListOf<String>("POST"),
        ":path" to mutableListOf<String>(path),
        ":scheme" to mutableListOf<String>(scheme),
        "content-type" to mutableListOf<String>("application/grpc"),
      )
    )
  )

  /**
   * Add a specific timeout for the gRPC request. This will be sent in the `grpc-timeout` header.
   *
   * @param timeoutMs Timeout, in milliseconds.
   * @return This builder.
   */
  fun addtimeoutMs(timeoutMs: Int?): GRPCRequestHeadersBuilder {
    val headerName = "grpc-timeout"
    if (timeoutMs == null) {
      remove(headerName)
    } else {
      add(headerName, "${timeoutMs}m")
    }
    return this
  }

  /**
   * Build the request headers using the current builder.
   *
   * @return New instance of request headers.
   */
  fun build(): GRPCRequestHeaders {
    return GRPCRequestHeaders(container)
  }
}
package io.envoyproxy.envoymobile

/** Trailers representing an inbound response. */
@Suppress("EmptyClassBlock")
class ResponseTrailers : Trailers {
  /**
   * Internal constructor used by builders.
   *
   * @param trailers: Trailers to set.
   */
  internal constructor(trailers: Map<String, List<String>>) : super(trailers)

  /**
   * Instantiate a new builder.
   *
   * @param container: The headers container to start with.
   */
  internal constructor(container: HeadersContainer) : super(container)

  /**
   * Convert the trailers back to a builder for mutation.
   *
   * @return ResponseTrailersBuilder, The new builder.
   */
  fun toResponseTrailersBuilder() = ResponseTrailersBuilder(container)
}
package io.envoyproxy.envoymobile

/** Builder used for constructing instances of `ResponseTrailers`. */
class ResponseTrailersBuilder : HeadersBuilder {
  /** Initialize a new instance of the builder. */
  constructor() : super(HeadersContainer(mapOf()))

  /**
   * Instantiate a new builder. Used only by ResponseTrailers to convert back to
   * ResponseTrailersBuilder.
   *
   * @param trailers: The trailers to start with.
   */
  internal constructor(
    trailers: MutableMap<String, MutableList<String>>
  ) : super(HeadersContainer(trailers))

  internal constructor(container: HeadersContainer) : super(container)

  override fun add(name: String, value: String): ResponseTrailersBuilder {
    super.add(name, value)
    return this
  }

  override fun set(name: String, value: MutableList<String>): ResponseTrailersBuilder {
    super.set(name, value)
    return this
  }

  override fun remove(name: String): ResponseTrailersBuilder {
    super.remove(name)
    return this
  }

  override fun internalSet(name: String, value: MutableList<String>): ResponseTrailersBuilder {
    super.internalSet(name, value)
    return this
  }

  /**
   * Build the response trailers using the current builder.
   *
   * @return ResponseTrailers, New instance of response trailers.
   */
  fun build(): ResponseTrailers {
    return ResponseTrailers(container)
  }
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.types.EnvoyStringAccessor

/** `StringAccessor` is bridged through to `EnvoyStringAccessor` to communicate with the engine. */
class StringAccessor
constructor(
  /** Accessor for a string exposed by a platform. */
  val getEnvoyString: (() -> String)
)

/**
 * Class responsible for bridging between the platform-level `StringAccessor` and the engine's
 * `EnvoyStringAccessor`.
 */
internal class EnvoyStringAccessorAdapter(private val callbacks: StringAccessor) :
  EnvoyStringAccessor {
  override fun getEnvoyString(): String {
    return callbacks.getEnvoyString()
  }
}
package io.envoyproxy.envoymobile

/**
 * Base class that is used to represent header/trailer data structures. To instantiate new
 * instances, see `{Request|Response}HeadersBuilder`.
 */
open class Headers {
  internal val container: HeadersContainer

  /**
   * Internal constructor used by builders.
   *
   * @param container: The headers container to set.
   */
  internal constructor(container: HeadersContainer) {
    this.container = container
  }

  /**
   * Get the value for the provided header name. It's discouraged to use this dictionary for
   * equality key-based lookups as this may lead to issues with headers that do not follow expected
   * casing i.e., "Content-Length" instead of "content-length".
   *
   * @param name: Header name for which to get the current value.
   * @return The current headers specified for the provided name.
   */
  fun value(name: String): List<String>? {
    return container.value(name)
  }

  /**
   * Accessor for all underlying headers as a map.
   *
   * @return The underlying headers.
   */
  fun caseSensitiveHeaders(): Map<String, List<String>> {
    return container.caseSensitiveHeaders()
  }
}
package io.envoyproxy.envoymobile

/** Builder used for constructing instances of RequestHeaders`. */
class RequestHeadersBuilder : HeadersBuilder {
  /**
   * Initialize a new instance of the builder.
   *
   * @param method: Method for the request.
   * @param scheme: The URL scheme for the request (i.e., "https").
   * @param authority: The URL authority for the request (i.e., "api.foo.com").
   * @param path: The URL path for the request (i.e., "/foo").
   */
  constructor(
    method: RequestMethod,
    scheme: String = "https",
    authority: String,
    path: String
  ) : super(
    HeadersContainer(
      mapOf(
        ":authority" to mutableListOf(authority),
        ":method" to mutableListOf(method.stringValue),
        ":path" to mutableListOf(path),
        ":scheme" to mutableListOf(scheme)
      )
    )
  )

  /**
   * Instantiate a new builder. Used only by RequestHeaders to convert back to
   * RequestHeadersBuilder.
   *
   * @param headers: The headers to start with.
   */
  internal constructor(headers: Map<String, MutableList<String>>) : super(HeadersContainer(headers))

  /**
   * Instantiate a new builder.
   *
   * @param container: The headers container to start with.
   */
  internal constructor(container: HeadersContainer) : super(container)

  override fun add(name: String, value: String): RequestHeadersBuilder {
    super.add(name, value)
    return this
  }

  override fun set(name: String, value: MutableList<String>): RequestHeadersBuilder {
    super.set(name, value)
    return this
  }

  override fun remove(name: String): RequestHeadersBuilder {
    super.remove(name)
    return this
  }

  override fun internalSet(name: String, value: MutableList<String>): RequestHeadersBuilder {
    super.internalSet(name, value)
    return this
  }

  /**
   * Add a retry policy to be used with this request.
   *
   * @param retryPolicy: The retry policy to use.
   * @return RequestHeadersBuilder, This builder.
   */
  fun addRetryPolicy(retryPolicy: RetryPolicy): RequestHeadersBuilder {
    for ((name, value) in retryPolicy.outboundHeaders()) {
      internalSet(name, value.toMutableList())
    }

    return this
  }

  /**
   * Add a socket tag to be applied to the socket.
   *
   * @param uid: Traffic stats UID to be applied.
   * @param tag: Traffic stats tag to be applied.
   *
   * See: https://source.android.com/devices/tech/datausage/tags-explained See:
   * https://developer.android.com/reference/android/net/TrafficStats#setThreadStatsTag(int) See:
   * https://developer.android.com/reference/android/net/TrafficStats#setThreadStatsUid(int) See:
   * https://developer.android.com/reference/android/net/TrafficStats#tagSocket(java.net.Socket)
   *
   * @return RequestHeadersBuilder, This builder.
   */
  fun addSocketTag(uid: Int, tag: Int): RequestHeadersBuilder {
    internalSet("x-envoy-mobile-socket-tag", mutableListOf(uid.toString() + "," + tag.toString()))
    return this
  }

  /**
   * Build the request headers using the current builder.
   *
   * @return RequestHeaders, New instance of request headers.
   */
  fun build(): RequestHeaders {
    return RequestHeaders(container)
  }
}
package io.envoyproxy.envoymobile

/**
 * Error type containing information on failures reported by Envoy.
 *
 * @param errorCode internal error code associated with the exception that occurred.
 * @param message a description of what exception that occurred.
 * @param attemptCount an optional number of times an operation was attempted before firing this
 *   error.
 * @param cause an optional cause for the exception.
 */
class EnvoyError
constructor(
  val errorCode: Int,
  val message: String,
  val attemptCount: Int? = null,
  val cause: Throwable? = null
)
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.types.EnvoyFinalStreamIntel
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks
import io.envoyproxy.envoymobile.engine.types.EnvoyStreamIntel
import java.nio.ByteBuffer
import java.util.concurrent.Executor

/**
 * A collection of platform-level callbacks that are specified by consumers who wish to interact
 * with streams.
 *
 * `StreamCallbacks` are bridged through to `EnvoyHTTPCallbacks` to communicate with the engine.
 */
internal class StreamCallbacks {
  var onHeaders:
    ((headers: ResponseHeaders, endStream: Boolean, streamIntel: StreamIntel) -> Unit)? =
    null
  var onData: ((data: ByteBuffer, endStream: Boolean, streamIntel: StreamIntel) -> Unit)? = null
  var onTrailers: ((trailers: ResponseTrailers, streamIntel: StreamIntel) -> Unit)? = null
  var onCancel: ((finalStreamIntel: FinalStreamIntel) -> Unit)? = null
  var onError: ((error: EnvoyError, finalStreamIntel: FinalStreamIntel) -> Unit)? = null
  var onSendWindowAvailable: ((streamIntel: StreamIntel) -> Unit)? = null
  var onComplete: ((finalStreamIntel: FinalStreamIntel) -> Unit)? = null
}

/**
 * Class responsible for bridging between the platform-level `StreamCallbacks` and the engine's
 * `EnvoyHTTPCallbacks`.
 */
internal class EnvoyHTTPCallbacksAdapter(
  private val executor: Executor,
  private val callbacks: StreamCallbacks
) : EnvoyHTTPCallbacks {
  override fun getExecutor(): Executor {
    return executor
  }

  override fun onHeaders(
    headers: Map<String, List<String>>,
    endStream: Boolean,
    streamIntel: EnvoyStreamIntel
  ) {
    callbacks.onHeaders?.invoke(ResponseHeaders(headers), endStream, StreamIntel(streamIntel))
  }

  override fun onData(byteBuffer: ByteBuffer, endStream: Boolean, streamIntel: EnvoyStreamIntel) {
    callbacks.onData?.invoke(byteBuffer, endStream, StreamIntel(streamIntel))
  }

  override fun onTrailers(trailers: Map<String, List<String>>, streamIntel: EnvoyStreamIntel) {
    callbacks.onTrailers?.invoke(ResponseTrailers((trailers)), StreamIntel(streamIntel))
  }

  override fun onError(
    errorCode: Int,
    message: String,
    attemptCount: Int,
    streamIntel: EnvoyStreamIntel,
    finalStreamIntel: EnvoyFinalStreamIntel
  ) {
    callbacks.onError?.invoke(
      EnvoyError(errorCode, message, attemptCount),
      FinalStreamIntel(streamIntel, finalStreamIntel)
    )
  }

  override fun onCancel(streamIntel: EnvoyStreamIntel, finalStreamIntel: EnvoyFinalStreamIntel) {
    callbacks.onCancel?.invoke(FinalStreamIntel(streamIntel, finalStreamIntel))
  }

  override fun onSendWindowAvailable(streamIntel: EnvoyStreamIntel) {
    callbacks.onSendWindowAvailable?.invoke(StreamIntel(streamIntel))
  }

  override fun onComplete(streamIntel: EnvoyStreamIntel, finalStreamIntel: EnvoyFinalStreamIntel) {
    callbacks.onComplete?.invoke(FinalStreamIntel(streamIntel, finalStreamIntel))
  }
}
package io.envoyproxy.envoymobile

/**
 * Converts the retry policy to a set of headers recognized by Envoy.
 *
 * @return The header representation of the retry policy.
 */
internal fun RetryPolicy.outboundHeaders(): Map<String, List<String>> {
  val upstreamTimeoutMS = totalUpstreamTimeoutMS ?: 0L
  val headers =
    mutableMapOf(
      "x-envoy-max-retries" to listOf("$maxRetryCount"),
      "x-envoy-upstream-rq-timeout-ms" to listOf("$upstreamTimeoutMS")
    )

  if (perRetryTimeoutMS != null) {
    headers["x-envoy-upstream-rq-per-try-timeout-ms"] = listOf("$perRetryTimeoutMS")
  }

  val retryOn = retryOn.map { elm -> elm.stringValue }.toMutableList()
  if (retryStatusCodes.isNotEmpty()) {
    retryOn.add("retriable-status-codes")
    headers["x-envoy-retriable-status-codes"] = retryStatusCodes.map { value -> "$value" }
  }
  headers["x-envoy-retry-on"] = retryOn
  return headers
}
package io.envoyproxy.envoymobile

/**
 * Client for Envoy Mobile's stats library, Pulse, used to record client time series metrics.
 *
 * Note: this is an experimental interface and is subject to change The implementation has not been
 * optimized, and there may be performance implications in production usage.
 */
interface PulseClient {

  /** @return A counter based on the joined elements. */
  fun counter(vararg elements: Element): Counter

  /** @return A counter based on the joined elements with tags. */
  fun counter(vararg elements: Element, tags: Tags): Counter
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.EnvoyEngine

/** Envoy implementation of `StreamClient`. */
internal class StreamClientImpl constructor(internal val engine: EnvoyEngine) : StreamClient {

  override fun newStreamPrototype() = StreamPrototype(engine)
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.EnvoyConfiguration
import io.envoyproxy.envoymobile.engine.EnvoyEngine
import io.envoyproxy.envoymobile.engine.types.EnvoyStatus

/** An implementation of {@link Engine}. */
class EngineImpl
constructor(
  internal val envoyEngine: EnvoyEngine,
  internal val envoyConfiguration: EnvoyConfiguration,
  internal val configurationYAML: String?,
  internal val logLevel: LogLevel
) : Engine {

  private val streamClient: StreamClient
  private val pulseClient: PulseClient

  constructor(
    envoyEngine: EnvoyEngine,
    envoyConfiguration: EnvoyConfiguration,
    logLevel: LogLevel = LogLevel.INFO
  ) : this(envoyEngine, envoyConfiguration, null, logLevel)

  init {
    streamClient = StreamClientImpl(envoyEngine)
    pulseClient = PulseClientImpl(envoyEngine)
    val envoyStatus =
      if (configurationYAML != null) {
        envoyEngine.performRegistration(envoyConfiguration)
        envoyEngine.runWithYaml(configurationYAML, logLevel.level)
      } else {
        envoyEngine.runWithConfig(envoyConfiguration, logLevel.level)
      }
    if (envoyStatus == EnvoyStatus.ENVOY_FAILURE) {
      throw IllegalStateException("Unable to start Envoy.")
    }
  }

  override fun streamClient(): StreamClient {
    return streamClient
  }

  override fun pulseClient(): PulseClient {
    return pulseClient
  }

  override fun terminate() {
    envoyEngine.terminate()
  }

  override fun dumpStats(): String {
    return envoyEngine.dumpStats()
  }

  override fun resetConnectivityState() {
    envoyEngine.resetConnectivityState()
  }
}
package io.envoyproxy.envoymobile

import android.content.Context
import io.envoyproxy.envoymobile.engine.AndroidEngineImpl

/** The engine builder to use to create Envoy engine on Android. */
class AndroidEngineBuilder
@JvmOverloads
constructor(context: Context, baseConfiguration: BaseConfiguration = Standard()) :
  EngineBuilder(baseConfiguration) {
  init {
    addEngineType {
      AndroidEngineImpl(context, onEngineRunning, logger, eventTracker, enableProxying)
    }
  }
}
package io.envoyproxy.envoymobile

/** Builder used for constructing instances of `ResponseHeaders`. */
class ResponseHeadersBuilder : HeadersBuilder {

  /*
   * Instantiate a new builder.
   */
  constructor() : super(HeadersContainer(mapOf()))

  /*
   * Instantiate a new builder. Used only by ResponseHeaders to convert back to
   * ResponseHeadersBuilder.
   *
   * @param headers: The headers to start with.
   */
  internal constructor(
    headers: MutableMap<String, MutableList<String>>
  ) : super(HeadersContainer(headers))

  /*
   * Instantiate a new builder.
   *
   * @param container: The headers container to start with.
   */
  internal constructor(container: HeadersContainer) : super(container)

  override fun add(name: String, value: String): ResponseHeadersBuilder {
    super.add(name, value)
    return this
  }

  override fun set(name: String, value: MutableList<String>): ResponseHeadersBuilder {
    super.set(name, value)
    return this
  }

  override fun remove(name: String): ResponseHeadersBuilder {
    super.remove(name)
    return this
  }

  override fun internalSet(name: String, value: MutableList<String>): ResponseHeadersBuilder {
    super.internalSet(name, value)
    return this
  }

  /**
   * Add an HTTP status to the response headers. Must be a positive integer.
   *
   * @param status: The HTTP status to add.
   * @return ResponseHeadersBuilder, This builder.
   */
  fun addHttpStatus(status: Int): ResponseHeadersBuilder {
    if (status < 0) {
      return this
    }
    internalSet(":status", mutableListOf("$status"))
    return this
  }

  /**
   * Build the response headers using the current builder.
   *
   * @return ResponseHeaders, New instance of response headers.
   */
  fun build(): ResponseHeaders {
    return ResponseHeaders(container)
  }
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.types.EnvoyStreamIntel

/**
 * Exposes internal HTTP stream metrics, context, and other details.
 *
 * @param streamId An internal identifier for the stream. -1 if not set.
 * @param connectionId An internal identifier for the connection carrying the stream. -1 if not set.
 * @param attemptCount The number of internal attempts to carry out a request/operation. 0 if not
 *   set.
 */
open class StreamIntel
constructor(val streamId: Long, val connectionId: Long, val attemptCount: Long) {
  constructor(base: EnvoyStreamIntel) : this(base.streamId, base.connectionId, base.attemptCount)
}
package io.envoyproxy.envoymobile.android

import android.content.SharedPreferences
import io.envoyproxy.envoymobile.KeyValueStore

/** Simple implementation of a `KeyValueStore` leveraging `SharedPreferences` for persistence. */
class SharedPreferencesStore(sharedPreferences: SharedPreferences) : KeyValueStore {
  private val preferences = sharedPreferences
  private val editor = sharedPreferences.edit()

  override fun read(key: String): String? {
    return preferences.getString(key, null)
  }

  override fun remove(key: String) {
    editor.remove(key)
    editor.apply()
  }

  override fun save(key: String, value: String) {
    editor.putString(key, value)
    editor.apply()
  }
}
package io.envoyproxy.envoymobile

/** Headers representing an inbound response. */
class ResponseHeaders : Headers {
  /**
   * Internal constructor used by builders.
   *
   * @param headers: Headers to set.
   */
  internal constructor(headers: Map<String, List<String>>) : super(HeadersContainer.create(headers))

  internal constructor(container: HeadersContainer) : super(container)

  /** HTTP status code received with the response. */
  val httpStatus: Int? by lazy { value(":status")?.first()?.toIntOrNull()?.takeIf { it >= 0 } }

  /**
   * Convert the headers back to a builder for mutation.
   *
   * @return ResponseHeadersBuilder, The new builder.
   */
  fun toResponseHeadersBuilder() = ResponseHeadersBuilder(container)
}
package io.envoyproxy.envoymobile

/**
 * The container that manages the underlying headers map. It maintains the original casing of passed
 * header names. It treats headers names as case-insensitive for the purpose of header lookups and
 * header name conflict resolutions.
 */
open class HeadersContainer {
  protected val headers: MutableMap<String, Header>

  /**
   * Represents a header name together with all of its values. It preserves the original casing of
   * the header name.
   *
   * @param name The name of the header. Its casing is preserved.
   * @param value The value associated with a given header.
   */
  data class Header(val name: String, var value: MutableList<String>) {
    constructor(name: String) : this(name, mutableListOf())

    /**
     * Add values.
     *
     * @param values The list of values to add.
     */
    fun add(values: List<String>) {
      this.value.addAll(values)
    }

    /**
     * Add a value.
     *
     * @param value The value to add.
     */
    fun add(value: String) {
      this.value.add(value)
    }
  }

  /**
   * Instantiate a new instance of the receiver using the provided headers map
   *
   * @param headers The headers to start with.
   */
  internal constructor(headers: Map<String, MutableList<String>>) {
    var underlyingHeaders = mutableMapOf<String, Header>()
    /**
     * Dictionaries are unordered collections. Process headers with names that are the same when
     * lowercased in an alphabetical order to avoid a situation in which the result of the
     * initialization is non-derministic i.e., we want mapOf("A" to listOf("1"), "a" to listOf("2"))
     * headers to be always converted to mapOf("A" to listOf("1", "2")) and never to mapOf("a" to
     * listOf("2", "1")).
     *
     * If a given header name already exists in the processed headers map, check if the currently
     * processed header name is before the existing header name as determined by an alphabetical
     * order.
     */
    headers.forEach {
      val lowercased = it.key.lowercase()
      val existing = underlyingHeaders[lowercased]

      if (existing == null) {
        underlyingHeaders[lowercased] = Header(it.key, it.value)
      } else if (existing.name > it.key) {
        underlyingHeaders[lowercased] = Header(it.key, (it.value + existing.value).toMutableList())
      } else {
        underlyingHeaders[lowercased]?.add(it.value)
      }
    }

    this.headers = underlyingHeaders
  }

  companion object {
    /**
     * Create a new instance of the receiver using a provider headers map. Not implemented as a
     * constructor due to conflicting JVM signatures with other constructors.
     *
     * @param headers The headers to create the container with.
     */
    fun create(headers: Map<String, List<String>>): HeadersContainer {
      return HeadersContainer(headers.mapValues { it.value.toMutableList() })
    }
  }

  /**
   * Add a value to a header with a given name.
   *
   * @param name The name of the header. For the purpose of headers lookup and header name conflict
   *   resolution, the name of the header is considered to be case-insensitive.
   * @param value The value to add.
   */
  fun add(name: String, value: String) {
    val lowercased = name.lowercase()
    headers[lowercased]?.let { it.add(value) }
      ?: run { headers.put(lowercased, Header(name, mutableListOf(value))) }
  }

  /**
   * Set the value of a given header.
   *
   * @param name The name of the header.
   * @param value The value to set the header value to.
   */
  fun set(name: String, value: List<String>) {
    headers[name.lowercase()] = Header(name, value.toMutableList())
  }

  /**
   * Remove a given header.
   *
   * @param name The name of the header to remove.
   */
  fun remove(name: String) {
    headers.remove(name.lowercase())
  }

  /**
   * Get the value for the provided header name.
   *
   * @param name The case-insensitive header name for which to get the current value.
   * @return The value associated with a given header.
   */
  fun value(name: String): List<String>? {
    return headers[name.lowercase()]?.value
  }

  /**
   * Accessor for all underlying case-sensitive headers. When possible, use case-insensitive
   * accessors instead.
   *
   * @return The underlying headers.
   */
  fun caseSensitiveHeaders(): Map<String, List<String>> {
    var caseSensitiveHeaders = mutableMapOf<String, List<String>>()
    headers.forEach { caseSensitiveHeaders.put(it.value.name, it.value.value) }

    return caseSensitiveHeaders
  }
}
package io.envoyproxy.envoymobile

import com.google.protobuf.Struct
import io.envoyproxy.envoymobile.engine.EnvoyConfiguration
import io.envoyproxy.envoymobile.engine.EnvoyConfiguration.TrustChainVerification
import io.envoyproxy.envoymobile.engine.EnvoyEngine
import io.envoyproxy.envoymobile.engine.EnvoyEngineImpl
import io.envoyproxy.envoymobile.engine.EnvoyNativeFilterConfig
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilterFactory
import io.envoyproxy.envoymobile.engine.types.EnvoyKeyValueStore
import io.envoyproxy.envoymobile.engine.types.EnvoyStringAccessor
import java.util.UUID

/** Envoy engine configuration. */
sealed class BaseConfiguration

/** The standard configuration. */
class Standard : BaseConfiguration()

/**
 * The configuration based off a custom yaml.
 *
 * @param yaml the custom config.
 */
class Custom(val yaml: String) : BaseConfiguration()

/**
 * Builder for generating the xDS configuration for the Envoy Mobile engine. xDS is a protocol for
 * dynamic configuration of Envoy instances, more information can be found in
 * https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol.
 *
 * This class is typically used as input to the EngineBuilder's setXds() method.
 */
open class XdsBuilder(internal val xdsServerAddress: String, internal val xdsServerPort: Int) {
  companion object {
    private const val DEFAULT_XDS_TIMEOUT_IN_SECONDS: Int = 5
  }

  internal var grpcInitialMetadata = mutableMapOf<String, String>()
  internal var sslRootCerts: String? = null
  internal var rtdsResourceName: String? = null
  internal var rtdsTimeoutInSeconds: Int = DEFAULT_XDS_TIMEOUT_IN_SECONDS
  internal var enableCds: Boolean = false
  internal var cdsResourcesLocator: String? = null
  internal var cdsTimeoutInSeconds: Int = DEFAULT_XDS_TIMEOUT_IN_SECONDS

  /**
   * Adds a header to the initial HTTP metadata headers sent on the gRPC stream.
   *
   * A common use for the initial metadata headers is for authentication to the xDS management
   * server.
   *
   * For example, if using API keys to authenticate to Traffic Director on GCP (see
   * https://cloud.google.com/docs/authentication/api-keys for details), invoke:
   * builder.addInitialStreamHeader("x-goog-api-key", apiKeyToken)
   * .addInitialStreamHeader("X-Android-Package", appPackageName)
   * .addInitialStreamHeader("X-Android-Cert", sha1KeyFingerprint)
   *
   * @param header The HTTP header name to add to the initial gRPC stream's metadata.
   * @param value The HTTP header value to add to the initial gRPC stream's metadata.
   * @return this builder.
   */
  fun addInitialStreamHeader(header: String, value: String): XdsBuilder {
    this.grpcInitialMetadata.put(header, value)
    return this
  }

  /**
   * Sets the PEM-encoded server root certificates used to negotiate the TLS handshake for the gRPC
   * connection. If no root certs are specified, the operating system defaults are used.
   *
   * @param rootCerts The PEM-encoded server root certificates.
   * @return this builder.
   */
  fun setSslRootCerts(rootCerts: String): XdsBuilder {
    this.sslRootCerts = rootCerts
    return this
  }

  /**
   * Adds Runtime Discovery Service (RTDS) to the Runtime layers of the Bootstrap configuration, to
   * retrieve dynamic runtime configuration via the xDS management server.
   *
   * @param resourceName The runtime config resource to subscribe to.
   * @param timeoutInSeconds <optional> specifies the `initial_fetch_timeout` field on the
   *   api.v3.core.ConfigSource. Unlike the ConfigSource default of 15s, we set a default fetch
   *   timeout value of 5s, to prevent mobile app initialization from stalling. The default
   *   parameter value may change through the course of experimentation and no assumptions should be
   *   made of its exact value.
   * @return this builder.
   */
  fun addRuntimeDiscoveryService(
    resourceName: String,
    timeoutInSeconds: Int = DEFAULT_XDS_TIMEOUT_IN_SECONDS
  ): XdsBuilder {
    this.rtdsResourceName = resourceName
    this.rtdsTimeoutInSeconds = timeoutOrXdsDefault(timeoutInSeconds)
    return this
  }

  /**
   * Adds the Cluster Discovery Service (CDS) configuration for retrieving dynamic cluster resources
   * via the xDS management server.
   *
   * @param cdsResourcesLocator <optional> the xdstp:// URI for subscribing to the cluster
   *   resources. If not using xdstp, then `cds_resources_locator` should be set to the empty
   *   string.
   * @param timeoutInSeconds <optional> specifies the `initial_fetch_timeout` field on the
   *   api.v3.core.ConfigSource. Unlike the ConfigSource default of 15s, we set a default fetch
   *   timeout value of 5s, to prevent mobile app initialization from stalling. The default
   *   parameter value may change through the course of experimentation and no assumptions should be
   *   made of its exact value.
   * @return this builder.
   */
  public fun addClusterDiscoveryService(
    cdsResourcesLocator: String? = null,
    timeoutInSeconds: Int = DEFAULT_XDS_TIMEOUT_IN_SECONDS
  ): XdsBuilder {
    this.enableCds = true
    this.cdsResourcesLocator = cdsResourcesLocator
    this.cdsTimeoutInSeconds = timeoutOrXdsDefault(timeoutInSeconds)
    return this
  }

  private fun timeoutOrXdsDefault(timeout: Int): Int {
    return if (timeout > 0) timeout else DEFAULT_XDS_TIMEOUT_IN_SECONDS
  }
}

/** Builder used for creating and running a new `Engine` instance. */
open class EngineBuilder(private val configuration: BaseConfiguration = Standard()) {
  protected var onEngineRunning: (() -> Unit) = {}
  protected var logger: ((String) -> Unit)? = null
  protected var eventTracker: ((Map<String, String>) -> Unit)? = null
  protected var enableProxying = false
  private var runtimeGuards = mutableMapOf<String, Boolean>()
  private var engineType: () -> EnvoyEngine = {
    EnvoyEngineImpl(onEngineRunning, logger, eventTracker)
  }
  private var logLevel = LogLevel.INFO
  private var connectTimeoutSeconds = 30
  private var dnsRefreshSeconds = 60
  private var dnsFailureRefreshSecondsBase = 2
  private var dnsFailureRefreshSecondsMax = 10
  private var dnsQueryTimeoutSeconds = 25
  private var dnsMinRefreshSeconds = 60
  private var dnsPreresolveHostnames = listOf<String>()
  private var enableDNSCache = false
  private var dnsCacheSaveIntervalSeconds = 1
  private var enableDrainPostDnsRefresh = false
  internal var enableHttp3 = true
  private var http3ConnectionOptions = ""
  private var http3ClientConnectionOptions = ""
  private var quicHints = mutableMapOf<String, Int>()
  private var quicCanonicalSuffixes = mutableListOf<String>()
  private var enableGzipDecompression = true
  private var enableBrotliDecompression = false
  private var enableSocketTagging = false
  private var enableInterfaceBinding = false
  private var h2ConnectionKeepaliveIdleIntervalMilliseconds = 1
  private var h2ConnectionKeepaliveTimeoutSeconds = 10
  private var maxConnectionsPerHost = 7
  private var streamIdleTimeoutSeconds = 15
  private var perTryIdleTimeoutSeconds = 15
  private var appVersion = "unspecified"
  private var appId = "unspecified"
  private var trustChainVerification = TrustChainVerification.VERIFY_TRUST_CHAIN
  private var platformFilterChain = mutableListOf<EnvoyHTTPFilterFactory>()
  private var nativeFilterChain = mutableListOf<EnvoyNativeFilterConfig>()
  private var stringAccessors = mutableMapOf<String, EnvoyStringAccessor>()
  private var keyValueStores = mutableMapOf<String, EnvoyKeyValueStore>()
  private var enablePlatformCertificatesValidation = false
  private var nodeId: String = ""
  private var nodeRegion: String = ""
  private var nodeZone: String = ""
  private var nodeSubZone: String = ""
  private var nodeMetadata: Struct = Struct.getDefaultInstance()
  private var xdsBuilder: XdsBuilder? = null

  /**
   * Add a log level to use with Envoy.
   *
   * @param logLevel the log level to use with Envoy.
   * @return this builder.
   */
  fun addLogLevel(logLevel: LogLevel): EngineBuilder {
    this.logLevel = logLevel
    return this
  }

  /**
   * Add a timeout for new network connections to hosts in the cluster.
   *
   * @param connectTimeoutSeconds timeout for new network connections to hosts in the cluster.
   * @return this builder.
   */
  fun addConnectTimeoutSeconds(connectTimeoutSeconds: Int): EngineBuilder {
    this.connectTimeoutSeconds = connectTimeoutSeconds
    return this
  }

  /**
   * Add a default rate at which to refresh DNS.
   *
   * @param dnsRefreshSeconds default rate in seconds at which to refresh DNS.
   * @return this builder.
   */
  fun addDNSRefreshSeconds(dnsRefreshSeconds: Int): EngineBuilder {
    this.dnsRefreshSeconds = dnsRefreshSeconds
    return this
  }

  /**
   * Add a rate at which to refresh DNS in case of DNS failure.
   *
   * @param base rate in seconds.
   * @param max rate in seconds.
   * @return this builder.
   */
  fun addDNSFailureRefreshSeconds(base: Int, max: Int): EngineBuilder {
    this.dnsFailureRefreshSecondsBase = base
    this.dnsFailureRefreshSecondsMax = max
    return this
  }

  /**
   * Add a rate at which to timeout DNS queries.
   *
   * @param dnsQueryTimeoutSeconds rate in seconds to timeout DNS queries.
   * @return this builder.
   */
  fun addDNSQueryTimeoutSeconds(dnsQueryTimeoutSeconds: Int): EngineBuilder {
    this.dnsQueryTimeoutSeconds = dnsQueryTimeoutSeconds
    return this
  }

  /**
   * Add the minimum rate at which to refresh DNS. Once DNS has been resolved for a host, DNS TTL
   * will be respected, subject to this minimum. Defaults to 60 seconds.
   *
   * @param dnsMinRefreshSeconds minimum rate in seconds at which to refresh DNS.
   * @return this builder.
   */
  fun addDNSMinRefreshSeconds(dnsMinRefreshSeconds: Int): EngineBuilder {
    this.dnsMinRefreshSeconds = dnsMinRefreshSeconds
    return this
  }

  /**
   * Add a list of hostnames to preresolve on Engine startup.
   *
   * @param dnsPreresolveHostnames hostnames to preresolve.
   * @return this builder.
   */
  fun addDNSPreresolveHostnames(dnsPreresolveHostnames: List<String>): EngineBuilder {
    this.dnsPreresolveHostnames = dnsPreresolveHostnames
    return this
  }

  /**
   * Specify whether to drain connections after the resolution of a soft DNS refresh. A refresh may
   * be triggered directly via the Engine API, or as a result of a network status update provided by
   * the OS. Draining connections does not interrupt existing connections or requests, but will
   * establish new connections for any further requests.
   *
   * @param enableDrainPostDnsRefresh whether to drain connections after soft DNS refresh.
   * @return This builder.
   */
  fun enableDrainPostDnsRefresh(enableDrainPostDnsRefresh: Boolean): EngineBuilder {
    this.enableDrainPostDnsRefresh = enableDrainPostDnsRefresh
    return this
  }

  /**
   * Specify whether to enable DNS cache.
   *
   * Note that DNS cache requires an addition of a key value store named 'reserved.platform_store'.
   *
   * @param enableDNSCache whether to enable DNS cache. Disabled by default.
   * @param saveInterval the interval at which to save results to the configured key value store.
   * @return This builder.
   */
  fun enableDNSCache(enableDNSCache: Boolean, saveInterval: Int = 1): EngineBuilder {
    this.enableDNSCache = enableDNSCache
    this.dnsCacheSaveIntervalSeconds = saveInterval
    return this
  }

  /**
   * Specify whether to do gzip response decompression or not. Defaults to true.
   *
   * @param enableGzipDecompression whether or not to gunzip responses.
   * @return This builder.
   */
  fun enableGzipDecompression(enableGzipDecompression: Boolean): EngineBuilder {
    this.enableGzipDecompression = enableGzipDecompression
    return this
  }

  /**
   * Specify whether to enable HTTP3. Defaults to true.
   *
   * @param enableHttp3 whether or not to enable HTTP3.
   * @return This builder.
   */
  fun enableHttp3(enableHttp3: Boolean): EngineBuilder {
    this.enableHttp3 = enableHttp3
    return this
  }

  /**
   * Specify whether to do brotli response decompression or not. Defaults to false.
   *
   * @param enableBrotliDecompression whether or not to brotli decompress responses.
   * @return This builder.
   */
  fun enableBrotliDecompression(enableBrotliDecompression: Boolean): EngineBuilder {
    this.enableBrotliDecompression = enableBrotliDecompression
    return this
  }

  /**
   * Specify whether to support socket tagging or not. Defaults to false.
   *
   * @param enableSocketTagging whether or not support socket tagging.
   * @return This builder.
   */
  fun enableSocketTagging(enableSocketTagging: Boolean): EngineBuilder {
    this.enableSocketTagging = enableSocketTagging
    return this
  }

  /**
   * Specify whether sockets may attempt to bind to a specific interface, based on network
   * conditions.
   *
   * @param enableInterfaceBinding whether to allow interface binding.
   * @return This builder.
   */
  fun enableInterfaceBinding(enableInterfaceBinding: Boolean): EngineBuilder {
    this.enableInterfaceBinding = enableInterfaceBinding
    return this
  }

  /**
   * Specify whether system proxy settings should be respected. If yes, Envoy Mobile will use
   * Android APIs to query Android Proxy settings configured on a device and will respect these
   * settings when establishing connections with remote services.
   *
   * The method is introduced for experimentation purposes and as a safety guard against critical
   * issues in the implementation of the proxying feature. It's intended to be removed after it's
   * confirmed that proxies on Android work as expected.
   *
   * @param enableProxying whether to enable Envoy's support for proxies.
   * @return This builder.
   */
  fun enableProxying(enableProxying: Boolean): EngineBuilder {
    this.enableProxying = enableProxying
    return this
  }

  /**
   * Add a rate at which to ping h2 connections on new stream creation if the connection has sat
   * idle. Defaults to 1 millisecond which effectively enables h2 ping functionality and results in
   * a connection ping on every new stream creation. Set it to 100000000 milliseconds to effectively
   * disable the ping.
   *
   * @param idleIntervalMs rate in milliseconds.
   * @return this builder.
   */
  fun addH2ConnectionKeepaliveIdleIntervalMilliseconds(idleIntervalMs: Int): EngineBuilder {
    this.h2ConnectionKeepaliveIdleIntervalMilliseconds = idleIntervalMs
    return this
  }

  /**
   * Add a rate at which to timeout h2 pings.
   *
   * @param timeoutSeconds rate in seconds to timeout h2 pings.
   * @return this builder.
   */
  fun addH2ConnectionKeepaliveTimeoutSeconds(timeoutSeconds: Int): EngineBuilder {
    this.h2ConnectionKeepaliveTimeoutSeconds = timeoutSeconds
    return this
  }

  /**
   * Set the maximum number of connections to open to a single host. Default is 7.
   *
   * @param maxConnectionsPerHost the maximum number of connections per host.
   * @return this builder.
   */
  fun setMaxConnectionsPerHost(maxConnectionsPerHost: Int): EngineBuilder {
    this.maxConnectionsPerHost = maxConnectionsPerHost
    return this
  }

  /**
   * Add a custom idle timeout for HTTP streams. Defaults to 15 seconds.
   *
   * @param streamIdleTimeoutSeconds idle timeout for HTTP streams.
   * @return this builder.
   */
  fun addStreamIdleTimeoutSeconds(streamIdleTimeoutSeconds: Int): EngineBuilder {
    this.streamIdleTimeoutSeconds = streamIdleTimeoutSeconds
    return this
  }

  /**
   * Add a custom per try idle timeout for HTTP streams. Defaults to 15 seconds.
   *
   * @param perTryIdleTimeoutSeconds per try idle timeout for HTTP streams.
   * @return this builder.
   */
  fun addPerTryIdleTimeoutSeconds(perTryIdleTimeoutSeconds: Int): EngineBuilder {
    this.perTryIdleTimeoutSeconds = perTryIdleTimeoutSeconds
    return this
  }

  /**
   * Add an HTTP filter factory used to create platform filters for streams sent by this client.
   *
   * @param name Custom name to use for this filter factory. Useful for having more meaningful trace
   *   logs, but not required. Should be unique per factory registered.
   * @param factory closure returning an instantiated filter.
   * @return this builder.
   */
  fun addPlatformFilter(name: String, factory: () -> Filter): EngineBuilder {
    this.platformFilterChain.add(FilterFactory(name, factory))
    return this
  }

  /**
   * Add an HTTP filter factory used to create platform filters for streams sent by this client.
   *
   * @param factory closure returning an instantiated filter.
   * @return this builder.
   */
  fun addPlatformFilter(factory: () -> Filter): EngineBuilder {
    this.platformFilterChain.add(FilterFactory(UUID.randomUUID().toString(), factory))
    return this
  }

  /**
   * Add an HTTP filter config used to create native filters for streams sent by this client.
   *
   * @param name Custom name to use for this filter factory. Useful for having more meaningful trace
   *   logs, but not required. Should be unique per filter.
   * @param typedConfig config string for the filter.
   * @return this builder.
   */
  fun addNativeFilter(
    name: String = UUID.randomUUID().toString(),
    typedConfig: String
  ): EngineBuilder {
    this.nativeFilterChain.add(EnvoyNativeFilterConfig(name, typedConfig))
    return this
  }

  /**
   * Set a closure to be called when the engine finishes its async startup and begins running.
   *
   * @param closure the closure to be called.
   * @return this builder.
   */
  fun setOnEngineRunning(closure: () -> Unit): EngineBuilder {
    this.onEngineRunning = closure
    return this
  }

  /**
   * Set a closure to be called when the engine's logger logs.
   *
   * @param closure: The closure to be called.
   * @return This builder.
   */
  fun setLogger(closure: (String) -> Unit): EngineBuilder {
    this.logger = closure
    return this
  }

  /** Set event tracker for the engine to call when it emits an event. */
  fun setEventTracker(eventTracker: (Map<String, String>) -> Unit): EngineBuilder {
    this.eventTracker = eventTracker
    return this
  }

  /**
   * Add a string accessor to this Envoy Client.
   *
   * @param name the name of the accessor.
   * @param accessor the string accessor.
   * @return this builder.
   */
  fun addStringAccessor(name: String, accessor: () -> String): EngineBuilder {
    this.stringAccessors.put(name, EnvoyStringAccessorAdapter(StringAccessor(accessor)))
    return this
  }

  /**
   * Register a key-value store implementation for internal use.
   *
   * @param name the name of the KV store.
   * @param keyValueStore the KV store implementation.
   * @return this builder.
   */
  fun addKeyValueStore(name: String, keyValueStore: KeyValueStore): EngineBuilder {
    this.keyValueStores.put(name, keyValueStore)
    return this
  }

  /**
   * Add the App Version of the App using this Envoy Client.
   *
   * @param appVersion the version.
   * @return this builder.
   */
  fun addAppVersion(appVersion: String): EngineBuilder {
    this.appVersion = appVersion
    return this
  }

  /**
   * Add the App ID of the App using this Envoy Client.
   *
   * @param appId the ID.
   * @return this builder.
   */
  fun addAppId(appId: String): EngineBuilder {
    this.appId = appId
    return this
  }

  /**
   * Set how the TrustChainVerification must be handled.
   *
   * @param trustChainVerification whether to mute TLS Cert verification - intended for testing
   * @return this builder.
   */
  fun setTrustChainVerification(trustChainVerification: TrustChainVerification): EngineBuilder {
    this.trustChainVerification = trustChainVerification
    return this
  }

  /**
   * Sets the node.id field in the Bootstrap configuration.
   *
   * @param nodeId the node ID.
   * @return this builder.
   */
  fun setNodeId(nodeId: String): EngineBuilder {
    this.nodeId = nodeId
    return this
  }

  /**
   * Sets the node.locality field in the Bootstrap configuration.
   *
   * @param region the region of the node locality.
   * @param zone the zone of the node locality.
   * @param subZone the sub-zone of the node locality.
   * @return this builder.
   */
  fun setNodeLocality(region: String, zone: String, subZone: String): EngineBuilder {
    this.nodeRegion = region
    this.nodeZone = zone
    this.nodeSubZone = subZone
    return this
  }

  /**
   * Sets the node.metadata field in the Bootstrap configuration.
   *
   * @param metadata the metadata of the node.
   * @return this builder.
   */
  fun setNodeMetadata(metadata: Struct): EngineBuilder {
    this.nodeMetadata = metadata
    return this
  }

  /**
   * Sets the xDS configuration for the Envoy Mobile engine.
   *
   * @param xdsBuilder The XdsBuilder instance from which to construct the xDS configuration.
   * @return this builder.
   */
  fun setXds(xdsBuilder: XdsBuilder): EngineBuilder {
    this.xdsBuilder = xdsBuilder
    return this
  }

  /**
   * Set a runtime guard with the provided value.
   *
   * @param name the name of the runtime guard, e.g. test_feature_false.
   * @param value the value for the runtime guard.
   * @return This builder.
   */
  fun setRuntimeGuard(name: String, value: Boolean): EngineBuilder {
    this.runtimeGuards.put(name, value)
    return this
  }

  /**
   * Add a host port pair that's known to speak QUIC.
   *
   * @param host the host's name.
   * @param port the port number.
   * @return This builder.
   */
  fun addQuicHint(host: String, port: Int): EngineBuilder {
    this.quicHints.put(host, port)
    return this
  }

  /**
   * Add a host suffix that's known to speak QUIC.
   *
   * @param suffix the suffix string.
   * @return This builder.
   */
  fun addQuicCanonicalSuffix(suffix: String): EngineBuilder {
    this.quicCanonicalSuffixes.add(suffix)
    return this
  }

  /**
   * Builds and runs a new Engine instance with the provided configuration.
   *
   * @return A new instance of Envoy.
   */
  @Suppress("LongMethod")
  fun build(): Engine {
    val engineConfiguration =
      EnvoyConfiguration(
        connectTimeoutSeconds,
        dnsRefreshSeconds,
        dnsFailureRefreshSecondsBase,
        dnsFailureRefreshSecondsMax,
        dnsQueryTimeoutSeconds,
        dnsMinRefreshSeconds,
        dnsPreresolveHostnames,
        enableDNSCache,
        dnsCacheSaveIntervalSeconds,
        enableDrainPostDnsRefresh,
        enableHttp3,
        http3ConnectionOptions,
        http3ClientConnectionOptions,
        quicHints,
        quicCanonicalSuffixes,
        enableGzipDecompression,
        enableBrotliDecompression,
        enableSocketTagging,
        enableInterfaceBinding,
        h2ConnectionKeepaliveIdleIntervalMilliseconds,
        h2ConnectionKeepaliveTimeoutSeconds,
        maxConnectionsPerHost,
        streamIdleTimeoutSeconds,
        perTryIdleTimeoutSeconds,
        appVersion,
        appId,
        trustChainVerification,
        nativeFilterChain,
        platformFilterChain,
        stringAccessors,
        keyValueStores,
        runtimeGuards,
        enablePlatformCertificatesValidation,
        xdsBuilder?.rtdsResourceName,
        xdsBuilder?.rtdsTimeoutInSeconds ?: 0,
        xdsBuilder?.xdsServerAddress,
        xdsBuilder?.xdsServerPort ?: 0,
        xdsBuilder?.grpcInitialMetadata ?: mapOf<String, String>(),
        xdsBuilder?.sslRootCerts,
        nodeId,
        nodeRegion,
        nodeZone,
        nodeSubZone,
        nodeMetadata,
        xdsBuilder?.cdsResourcesLocator,
        xdsBuilder?.cdsTimeoutInSeconds ?: 0,
        xdsBuilder?.enableCds ?: false,
      )

    return when (configuration) {
      is Custom -> {
        EngineImpl(engineType(), engineConfiguration, configuration.yaml, logLevel)
      }
      is Standard -> {
        EngineImpl(engineType(), engineConfiguration, logLevel)
      }
    }
  }

  /**
   * Add a specific implementation of `EnvoyEngine` to use for starting Envoy.
   *
   * A new instance of this engine will be created when `build()` is called.
   */
  fun addEngineType(engineType: () -> EnvoyEngine): EngineBuilder {
    this.engineType = engineType
    return this
  }

  /**
   * Specify whether to use platform provided certificate validation APIs or Envoy built-in
   * validation logic. Defaults to false.
   *
   * @param enablePlatformCertificatesValidation true if using platform APIs is desired.
   * @return This builder.
   */
  fun enablePlatformCertificatesValidation(
    enablePlatformCertificatesValidation: Boolean
  ): EngineBuilder {
    this.enablePlatformCertificatesValidation = enablePlatformCertificatesValidation
    return this
  }
}
package io.envoyproxy.envoymobile

/** Client used to create HTTP streams. */
interface StreamClient {
  /**
   * Create a new stream prototype which can be used to start streams.
   *
   * @return The new stream prototype.
   */
  fun newStreamPrototype(): StreamPrototype
}
package io.envoyproxy.envoymobile

/** Headers representing an outbound request. */
open class RequestHeaders : Headers {
  /**
   * Internal constructor used by builders.
   *
   * @param headers: Headers to set.
   */
  internal constructor(headers: Map<String, List<String>>) : super(HeadersContainer.create(headers))

  internal constructor(container: HeadersContainer) : super(container)

  /** Method for the request. */
  val method: RequestMethod by lazy { RequestMethod.enumValue(value(":method")?.first()!!) }

  /** The URL scheme for the request (i.e., "https"). */
  val scheme: String by lazy { value(":scheme")?.first()!! }

  /** The URL authority for the request (i.e., "api.foo.com"). */
  val authority: String by lazy { value(":authority")?.first()!! }

  /** The URL path for the request (i.e., "/foo"). */
  val path: String by lazy { value(":path")?.first()!! }

  /** Retry policy to use for this request. */
  val retryPolicy: RetryPolicy? by lazy { RetryPolicy.from(this) }

  /**
   * Convert the headers back to a builder for mutation.
   *
   * @return RequestHeadersBuilder, The new builder.
   */
  fun toRequestHeadersBuilder() = RequestHeadersBuilder(container)
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:android_artifacts.bzl", "android_artifacts")
load("@envoy_mobile//bazel:kotlin_lib.bzl", "envoy_mobile_kt_library")
load("@io_bazel_rules_kotlin//kotlin:android.bzl", "kt_android_library")
load("@rules_detekt//detekt:defs.bzl", "detekt")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

android_artifacts(
    name = "envoy_aar",
    android_library = ":envoy_lib",
    archive_name = "envoy",
    manifest = "EnvoyManifest.xml",
    native_deps = select({
        "@envoy//bazel:opt_build": ["//library/common/jni:libenvoy_jni.so.debug_info"],
        "//conditions:default": ["//library/common/jni:libenvoy_jni.so"],
    }),
    proguard_rules = "//library:proguard_rules",
    substitutions = {
        "{pom_artifact_id}": "envoy",
        "{pom_extra_dependencies}": "",
    },
    visibility = ["//visibility:public"],
)

android_artifacts(
    name = "envoy_xds_aar",
    android_library = ":envoy_lib",
    archive_name = "envoy_xds",
    manifest = "EnvoyManifest.xml",
    native_deps = select({
        "@envoy//bazel:opt_build": ["//library/common/jni:libenvoy_jni.so.debug_info"],
        "//conditions:default": ["//library/common/jni:libenvoy_jni.so"],
    }),
    proguard_rules = "//library:proguard_rules",
    substitutions = {
        "{pom_artifact_id}": "envoy-xds",
        "{pom_extra_dependencies}": """
        <dependency>
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-javalite</artifactId>
            <version>3.24.4</version>
        </dependency>""",
    },
    visibility = ["//visibility:public"],
)

kt_android_library(
    name = "envoy_lib",
    srcs = [
        "AndroidEngineBuilder.kt",
        "android/SharedPreferencesStore.kt",
    ],
    custom_package = "io.envoyproxy.envoymobile",
    manifest = "EnvoyManifest.xml",
    visibility = ["//visibility:public"],
    deps = [
        ":envoy_interfaces_lib",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine/types:envoy_c_types_lib",
        "//library/java/io/envoyproxy/envoymobile/utilities",
    ],
)

envoy_mobile_kt_library(
    name = "envoy_interfaces_lib",
    srcs = glob([
        "Engine.kt",
        "EngineBuilder.kt",
        "EngineImpl.kt",
        "EnvoyError.kt",
        "Headers.kt",
        "HeadersBuilder.kt",
        "HeadersContainer.kt",
        "KeyValueStore.kt",
        "LogLevel.kt",
        "PulseClient.kt",
        "PulseClientImpl.kt",
        "RequestHeaders.kt",
        "RequestHeadersBuilder.kt",
        "RequestMethod.kt",
        "RequestTrailers.kt",
        "RequestTrailersBuilder.kt",
        "ResponseHeaders.kt",
        "ResponseHeadersBuilder.kt",
        "ResponseTrailers.kt",
        "ResponseTrailersBuilder.kt",
        "RetryPolicy.kt",
        "RetryPolicyMapper.kt",
        "Stream.kt",
        "StreamCallbacks.kt",
        "StreamClient.kt",
        "StreamClientImpl.kt",
        "StreamIntel.kt",
        "FinalStreamIntel.kt",
        "StreamPrototype.kt",
        "StringAccessor.kt",
        "Trailers.kt",
        "filters/*.kt",
        "grpc/*.kt",
        "mocks/*.kt",
        "stats/*.kt",
    ]),
    visibility = ["//visibility:public"],
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
    ],
)

detekt(
    name = "envoy_lib_lint",
    srcs = glob(["*.kt"]),
    build_upon_default_config = True,
    cfgs = ["//:kotlin_lint_config"],
)
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="io.envoyproxy.envoymobile">
    <uses-sdk
            android:minSdkVersion="21"
            android:targetSdkVersion="29"/>

</manifest>
package io.envoyproxy.envoymobile

/** Trailers representing an outbound request. */
@Suppress("EmptyClassBlock")
class RequestTrailers : Trailers {
  /**
   * Internal constructor used by builders.
   *
   * @param trailers: Trailers to set.
   */
  internal constructor(trailers: Map<String, List<String>>) : super(trailers)

  /**
   * Instantiate a new builder.
   *
   * @param container: The headers container to start with.
   */
  internal constructor(container: HeadersContainer) : super(container)

  /**
   * Convert the trailers back to a builder for mutation.
   *
   * @return RequestTrailersBuilder, The new builder.
   */
  fun toRequestTrailersBuilder() = RequestTrailersBuilder(container)
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.types.EnvoyKeyValueStore

/**
 * `KeyValueStore` is an interface that may be implemented to provide access to an arbitrary
 * key-value store implementation that may be made accessible to native Envoy Mobile code.
 */
interface KeyValueStore : EnvoyKeyValueStore
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.EnvoyHTTPStream
import java.nio.ByteBuffer

/**
 * A type representing a stream that is actively transferring data.
 *
 * Constructed using `StreamPrototype`, and used to write to the network.
 */
open class Stream(
  private val underlyingStream: EnvoyHTTPStream,
  private val useByteBufferPosition: Boolean
) {
  /**
   * Send headers over the stream.
   *
   * @param headers Headers to send over the stream.
   * @param endStream Whether this is a headers-only request.
   * @return This stream, for chaining syntax.
   */
  open fun sendHeaders(headers: RequestHeaders, endStream: Boolean): Stream {
    underlyingStream.sendHeaders(headers.caseSensitiveHeaders(), endStream)
    return this
  }

  /**
   * Read data from the response stream. Returns immediately.
   *
   * @param byteCount Maximum number of bytes that may be be passed by the next data callback.
   * @return This stream, for chaining syntax.
   */
  open fun readData(byteCount: Long): Stream {
    underlyingStream.readData(byteCount)
    return this
  }

  /**
   * For sending data to an associated stream. By default, the length sent is the
   * **[ByteBuffer.capacity]**. However, the length will rather be **[ByteBuffer.position]** if the
   * Stream was configured to do so - see **[StreamPrototype.useByteBufferPosition]**.
   *
   * Note: the provided ByteBuffer won't be mutated in any case. On the other hand, until the stream
   * is closed, any further mutations may lead to an unpredictable outcome.
   *
   * @param data Data to send over the stream.
   * @return This stream, for chaining syntax.
   */
  open fun sendData(data: ByteBuffer): Stream {
    var length = if (useByteBufferPosition) data.position() else data.capacity()
    underlyingStream.sendData(data, length, false)
    return this
  }

  /**
   * Close the stream with trailers.
   *
   * @param trailers Trailers with which to close the stream.
   */
  open fun close(trailers: RequestTrailers) {
    underlyingStream.sendTrailers(trailers.caseSensitiveHeaders())
  }

  /**
   * Close the stream with a data frame. By default, the length sent is the
   * **[ByteBuffer.capacity]**. However, the length will rather be **[ByteBuffer.position]** if the
   * Stream was configured to do so - see **[StreamPrototype.useByteBufferPosition]**.
   *
   * Note: the provided ByteBuffer won't be mutated in any case. On the other hand, until the stream
   * is closed, any further mutations may lead to an unpredictable outcome.
   *
   * @param data Data with which to close the stream.
   */
  open fun close(data: ByteBuffer) {
    var length = if (useByteBufferPosition) data.position() else data.capacity()
    underlyingStream.sendData(data, length, true)
  }

  /** Cancel the stream. */
  open fun cancel() {
    underlyingStream.cancel()
  }
}
package io.envoyproxy.envoymobile

import java.lang.IllegalArgumentException

/** Represents an HTTP request method. */
enum class RequestMethod(internal val stringValue: String) {
  DELETE("DELETE"),
  GET("GET"),
  HEAD("HEAD"),
  OPTIONS("OPTIONS"),
  PATCH("PATCH"),
  POST("POST"),
  PUT("PUT"),
  TRACE("TRACE");

  companion object {
    internal fun enumValue(stringRepresentation: String): RequestMethod {
      return when (stringRepresentation) {
        "DELETE" -> RequestMethod.DELETE
        "GET" -> RequestMethod.GET
        "HEAD" -> RequestMethod.HEAD
        "OPTIONS" -> RequestMethod.OPTIONS
        "PATCH" -> RequestMethod.PATCH
        "POST" -> RequestMethod.POST
        "PUT" -> RequestMethod.PUT
        "TRACE" -> RequestMethod.TRACE
        else -> throw IllegalArgumentException("invalid value $stringRepresentation")
      }
    }
  }
}
package io.envoyproxy.envoymobile

/**
 * Available logging levels for an Envoy instance. Note some levels may be compiled out.
 *
 * @param level string representation of a given log level.
 * @param levelInt integer representation of a given log level.
 */
enum class LogLevel(internal val level: String, val levelInt: Int) {
  TRACE("trace", 0),
  DEBUG("debug", 1),
  INFO("info", 2),
  WARN("warn", 3),
  ERROR("error", 4),
  CRITICAL("critical", 5),
  OFF("off", -1)
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.EnvoyEngine
import java.lang.ref.WeakReference

/** Envoy implementation of a `Counter`. */
internal class CounterImpl : Counter {
  var envoyEngine: WeakReference<EnvoyEngine>
  var series: String
  var tags: Tags

  internal constructor(
    engine: EnvoyEngine,
    elements: List<Element>,
    tags: Tags = TagsBuilder().build()
  ) {
    this.envoyEngine = WeakReference<EnvoyEngine>(engine)
    this.series = elements.joinToString(separator = ".") { it.value }
    this.tags = tags
  }

  // TODO: potentially raise error to platform if the operation is not successful.
  override fun increment(count: Int) {
    envoyEngine.get()?.recordCounterInc(series, this.tags.allTags(), count)
  }

  override fun increment(tags: Tags, count: Int) {
    envoyEngine.get()?.recordCounterInc(series, tags.allTags(), count)
  }
}
package io.envoyproxy.envoymobile

/** A time series counter. */
interface Counter {

  /** Increments the counter by the given count. */
  fun increment(count: Int = 1)

  /** Increments the counter by the given count and tags. */
  fun increment(tags: Tags = TagsBuilder().build(), count: Int = 1)
}
package io.envoyproxy.envoymobile

/*
 * Base class that is used to represent tags structures.
 * To instantiate new instances, see `TagsBuilder`.
 */
class Tags {
  @Suppress("MemberNameEqualsClassName") val tags: Map<String, String>

  /**
   * Internal constructor used by builders.
   *
   * @param tags: tags to set.
   */
  internal constructor(tags: Map<String, String>) {
    this.tags = tags
  }

  /**
   * Get the value for the provided tag name.
   *
   * @param name: Tag name for which to get the current value.
   * @return String?, The current tags specified for the provided name.
   */
  fun value(name: String): String? {
    return tags[name]
  }

  /**
   * Accessor for all underlying tags as a map.
   *
   * @return Map<String, String>, The underlying tags.
   */
  fun allTags(): Map<String, String> {
    return tags
  }
}
package io.envoyproxy.envoymobile

/*
 * Builder class used to construct `Tags` instances.
 */
public class TagsBuilder {
  protected val tags: MutableMap<String, String>

  /**
   * Instantiate a new builder.
   *
   * @param Tags: The Tags to start with.
   */
  public constructor(tags: MutableMap<String, String>) {
    this.tags = tags
  }

  public constructor() {
    this.tags = mutableMapOf<String, String>()
  }

  /**
   * Append a value to the Tag name.
   *
   * @param name: The Tag name.
   * @param value: The value associated to the Tag name.
   * @return TagsBuilder, This builder.
   */
  public fun add(name: String, value: String): TagsBuilder {
    tags.getOrPut(name) { value }
    return this
  }

  /**
   * Replace all values at the provided name with a new set of Tag values.
   *
   * @param name: The Tag name.
   * @param value: The value associated to the Tag name.
   * @return TagsBuilder, This builder.
   */
  public fun set(name: String, value: String): TagsBuilder {
    tags[name] = value
    return this
  }

  /**
   * Remove all Tags with this name.
   *
   * @param name: The Tag name to remove.
   * @return TagsBuilder, This builder.
   */
  public fun remove(name: String): TagsBuilder {
    tags.remove(name)
    return this
  }

  /**
   * Adds all tags from map to this builder.
   *
   * @param tags: A map of tags.
   * @return TagsBuilder, This builder.
   */
  public fun putAll(tags: Map<String, String>): TagsBuilder {
    this.tags.putAll(tags)
    return this
  }

  /**
   * Build the tags using the current builder.
   *
   * @return Tags, New instance of Tags.
   */
  public fun build(): Tags {
    return Tags(tags)
  }
}
package io.envoyproxy.envoymobile

import java.util.regex.Pattern

/**
 * Element represents one dot-delimited component of a time series name.
 *
 * Element values must conform to the [Element.ELEMENT_REGEX].
 */
class Element(internal val value: String) {
  init {
    require(ELEMENT_PATTERN.matcher(value).matches()) {
      "Element values must conform to the regex $ELEMENT_REGEX"
    }
  }

  companion object {
    private const val ELEMENT_REGEX = "^[A-Za-z_]+$"
    private val ELEMENT_PATTERN = Pattern.compile(ELEMENT_REGEX)
  }
}
#pragma once

#include "envoy/server/lifecycle_notifier.h"
#include "envoy/stats/store.h"

#include "source/common/common/logger.h"

#include "absl/base/call_once.h"
#include "extension_registry.h"
#include "library/common/common/lambda_logger_delegate.h"
#include "library/common/engine_common.h"
#include "library/common/http/client.h"
#include "library/common/network/connectivity_manager.h"
#include "library/common/types/c_types.h"

namespace Envoy {

class Engine : public Logger::Loggable<Logger::Id::main> {
public:
  /**
   * Constructor for a new engine instance.
   * @param callbacks, the callbacks to use for engine lifecycle monitoring.
   * @param logger, the callbacks to use for engine logging.
   * @param event_tracker, the event tracker to use for the emission of events.
   */
  Engine(envoy_engine_callbacks callbacks, envoy_logger logger, envoy_event_tracker event_tracker);

  /**
   * Engine destructor.
   */
  ~Engine();

  /**
   * Run the engine with the provided configuration.
   * @param config, the Envoy bootstrap configuration to use.
   * @param log_level, the log level.
   */
  envoy_status_t run(const std::string& config, const std::string& log_level);
  envoy_status_t run(std::unique_ptr<Envoy::OptionsImplBase>&& options);

  /**
   * Immediately terminate the engine, if running.
   */
  envoy_status_t terminate();

  /**
   * Accessor for the provisional event dispatcher.
   * @return Event::ProvisionalDispatcher&, the engine dispatcher.
   */
  Event::ProvisionalDispatcher& dispatcher();

  envoy_stream_t initStream();

  // These functions are wrappers around http client functions, which hand off
  // to http client functions of the same name after doing a dispatcher post
  // (thread context switch)
  envoy_status_t startStream(envoy_stream_t stream, envoy_http_callbacks bridge_callbacks,
                             bool explicit_flow_control) {
    return dispatcher_->post([&, stream, bridge_callbacks, explicit_flow_control]() {
      http_client_->startStream(stream, bridge_callbacks, explicit_flow_control);
    });
  }
  envoy_status_t sendHeaders(envoy_stream_t stream, envoy_headers headers, bool end_stream) {
    return dispatcher_->post([&, stream, headers, end_stream]() {
      http_client_->sendHeaders(stream, headers, end_stream);
    });
  }
  envoy_status_t readData(envoy_stream_t stream, size_t bytes_to_read) {
    return dispatcher_->post(
        [&, stream, bytes_to_read]() { http_client_->readData(stream, bytes_to_read); });
  }
  envoy_status_t sendData(envoy_stream_t stream, envoy_data data, bool end_stream) {
    return dispatcher_->post(
        [&, stream, data, end_stream]() { http_client_->sendData(stream, data, end_stream); });
  }
  envoy_status_t sendTrailers(envoy_stream_t stream, envoy_headers trailers) {
    return dispatcher_->post(
        [&, stream, trailers]() { http_client_->sendTrailers(stream, trailers); });
  }

  envoy_status_t cancelStream(envoy_stream_t stream) {
    return dispatcher_->post([&, stream]() { http_client_->cancelStream(stream); });
  }

  // These functions are wrappers around networkConnectivityManager functions, which hand off
  // to networkConnectivityManager after doing a dispatcher post (thread context switch)
  envoy_status_t setProxySettings(const char* host, const uint16_t port);
  envoy_status_t resetConnectivityState();
  envoy_status_t setPreferredNetwork(envoy_network_t network);

  /**
   * Increment a counter with a given string of elements and by the given count.
   * @param elements, joined elements of the timeseries.
   * @param tags, custom tags of the reporting stat.
   * @param count, amount to add to the counter.
   */
  envoy_status_t recordCounterInc(absl::string_view elements, envoy_stats_tags tags,
                                  uint64_t count);

  /**
   * Dump Envoy stats into the provided envoy_data
   * @params envoy_data which will be filed with referenced stats dumped in Envoy's standard text
   * format.
   * @return failure status if the engine is no longer running.
   * This can be called from any thread, but will block on engine-thread processing.
   */
  envoy_status_t dumpStats(envoy_data* out);

  /**
   * Get cluster manager from the Engine.
   */
  Upstream::ClusterManager& getClusterManager();

  /*
   * Get the stats store from the Engine.
   */
  Stats::Store& getStatsStore();

private:
  envoy_status_t main(std::unique_ptr<Envoy::OptionsImplBase>&& options);
  static void logInterfaces(absl::string_view event,
                            std::vector<Network::InterfacePair>& interfaces);

  Event::Dispatcher* event_dispatcher_{};
  Stats::ScopeSharedPtr client_scope_;
  Stats::StatNameSetPtr stat_name_set_;
  envoy_engine_callbacks callbacks_;
  envoy_logger logger_;
  envoy_event_tracker event_tracker_;
  Assert::ActionRegistrationPtr assert_handler_registration_;
  Assert::ActionRegistrationPtr bug_handler_registration_;
  Thread::MutexBasicLockable mutex_;
  Thread::CondVar cv_;
  Http::ClientPtr http_client_;
  Network::ConnectivityManagerSharedPtr connectivity_manager_;
  Event::ProvisionalDispatcherPtr dispatcher_;
  // Used by the cerr logger to ensure logs don't overwrite each other.
  absl::Mutex log_mutex_;
  Logger::EventTrackingDelegatePtr log_delegate_ptr_{};
  Server::Instance* server_{};
  Server::ServerLifecycleNotifier::HandlePtr postinit_callback_handler_;
  // main_thread_ should be destroyed first, hence it is the last member variable. Objects with
  // instructions scheduled on the main_thread_ need to have a longer lifetime.
  std::thread main_thread_{}; // Empty placeholder to be populated later.
};

using EngineSharedPtr = std::shared_ptr<Engine>;
using EngineWeakPtr = std::weak_ptr<Engine>;

} // namespace Envoy
#include "library/common/stream_info/extra_stream_info.h"

#include "source/common/common/macros.h"

namespace Envoy {
namespace StreamInfo {
namespace {

void setFromOptional(int64_t& to_set, const absl::optional<MonotonicTime>& time,
                     int64_t offset_ms) {
  if (time.has_value()) {
    to_set = offset_ms +
             std::chrono::duration_cast<std::chrono::milliseconds>(time.value().time_since_epoch())
                 .count();
  }
}

} // namespace

const std::string& ExtraStreamInfo::key() {
  CONSTRUCT_ON_FIRST_USE(std::string, "envoy_mobile.extra_stream_info");
}

void setFinalStreamIntel(StreamInfo& stream_info, TimeSource& time_source,
                         envoy_final_stream_intel& final_intel) {
  // The wall clock starting time is the one provided by StreamInfo.startTime(). Its Epoch value in
  // ms goes to final_intel.stream_start_ms directly. This is the only value that was taken from
  // the "wall clock" (a.k.a std::chrono::system_clock:now())
  final_intel.stream_start_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                                    stream_info.startTime().time_since_epoch())
                                    .count();

  // All the following timestamps are monotonic, rebased on the above stream_info.startTime().
  // StreamInfo.startTimeMonotonic() is used to compute the offset for the rebasing. Both
  // StreamInfo.startTimeMonotonic() and StreamInfo.startTime() are a snapshot that was taken
  // at the same time: when invoking the constructor of StreamInfoImpl.
  // NOTE: it worth noticing that here time_since_epoch() does not return the time since epoch.
  //       This is particularly counterintuitive, but that's the usual escape hatch to transform
  //       a duration to a long (int64_t in this case).
  int64_t offset_ms =
      final_intel.stream_start_ms - std::chrono::duration_cast<std::chrono::milliseconds>(
                                        stream_info.startTimeMonotonic().time_since_epoch())
                                        .count();

  // Unfortunately, stream_info.requestComplete() is not set yet.
  final_intel.stream_end_ms = offset_ms + std::chrono::duration_cast<std::chrono::milliseconds>(
                                              time_source.monotonicTime().time_since_epoch())
                                              .count();

  if (stream_info.upstreamInfo()) {
    const auto& upstream_info = stream_info.upstreamInfo();
    const UpstreamTiming& timing = upstream_info->upstreamTiming();
    setFromOptional(final_intel.sending_start_ms, timing.first_upstream_tx_byte_sent_, offset_ms);
    setFromOptional(final_intel.sending_end_ms, timing.last_upstream_tx_byte_sent_, offset_ms);
    setFromOptional(final_intel.response_start_ms, timing.first_upstream_rx_byte_received_,
                    offset_ms);
    setFromOptional(final_intel.connect_start_ms, timing.upstream_connect_start_, offset_ms);
    setFromOptional(final_intel.connect_end_ms, timing.upstream_connect_complete_, offset_ms);
    if (timing.upstream_handshake_complete_.has_value()) {
      setFromOptional(final_intel.ssl_start_ms, timing.upstream_connect_complete_, offset_ms);
    }
    setFromOptional(final_intel.ssl_end_ms, timing.upstream_handshake_complete_, offset_ms);
    final_intel.socket_reused = upstream_info->upstreamNumStreams() > 1;
    if (stream_info.upstreamInfo()->upstreamProtocol().has_value()) {
      final_intel.upstream_protocol =
          static_cast<int64_t>(stream_info.upstreamInfo()->upstreamProtocol().value());
    }
  }

  setFromOptional(
      final_intel.dns_start_ms,
      stream_info.downstreamTiming().getValue("envoy.dynamic_forward_proxy.dns_start_ms"),
      offset_ms);
  setFromOptional(final_intel.dns_end_ms,
                  stream_info.downstreamTiming().getValue("envoy.dynamic_forward_proxy.dns_end_ms"),
                  offset_ms);
  if (stream_info.getUpstreamBytesMeter()) {
    final_intel.sent_byte_count = stream_info.getUpstreamBytesMeter()->wireBytesSent();
    final_intel.received_byte_count = stream_info.getUpstreamBytesMeter()->wireBytesReceived();
  }
  final_intel.response_flags = stream_info.responseFlags();
}

bool isStreamIdleTimeout(const StreamInfo& stream_info) {
  return stream_info.responseCodeDetails().has_value() &&
         stream_info.responseCodeDetails().value() == ResponseCodeDetails::get().StreamIdleTimeout;
}

} // namespace StreamInfo
} // namespace Envoy
#pragma once

#include "envoy/stream_info/filter_state.h"

#include "source/common/stream_info/utility.h"

#include "library/common/network/connectivity_manager.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace StreamInfo {

struct ExtraStreamInfo : public FilterState::Object {
  absl::optional<envoy_netconf_t> configuration_key_{};
  static const std::string& key();
};

// Set fields in final_intel based on stream_info.
void setFinalStreamIntel(StreamInfo& stream_info, TimeSource& time_source,
                         envoy_final_stream_intel& final_intel);

// Returns true if the response code details indicate that this stream info
// has a stream idle timeout error.
bool isStreamIdleTimeout(const StreamInfo& stream_info);

using ExtraStreamInfoPtr = std::unique_ptr<ExtraStreamInfo>;

} // namespace StreamInfo
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "extra_stream_info_lib",
    srcs = ["extra_stream_info.cc"],
    hdrs = ["extra_stream_info.h"],
    repository = "@envoy",
    deps = [
        "//library/common/network:connectivity_manager_lib",
        "//library/common/types:c_types_lib",
        "@envoy//envoy/stream_info:stream_info_interface",
        "@envoy//source/common/stream_info:utility_lib",
    ],
)
#pragma once

#include "library/common/types/c_types.h"

namespace Envoy {
namespace Types {

/**
 * A wrapper around envoy_headers that's responsible for freeing
 * the underlying headers when they are not needed anymore.
 */
class ManagedEnvoyHeaders {
public:
  /**
   * Initialize a new instance of the receiver using a given instance of envoy headers.
   *
   * @param headers, that should be wrapped by the receiver. The wrapper will hold onto
   *                 the passed headers and free them once the receiver is not used anymore.
   */
  ManagedEnvoyHeaders(envoy_headers headers) : headers_(headers){};
  ~ManagedEnvoyHeaders() { release_envoy_headers(headers_); }
  const envoy_headers& get() const { return headers_; }

private:
  envoy_headers headers_;
  // Make copy and assignment operators private to prevent copying of the receiver.
  ManagedEnvoyHeaders(const ManagedEnvoyHeaders&);
  ManagedEnvoyHeaders& operator=(const ManagedEnvoyHeaders&);
};

} // namespace Types
} // namespace Envoy
#pragma once

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

// NOLINT(namespace-envoy)

/**
 * Throughout this file one may note that most callbacks take a void* context parameter, and most
 * callback structs have a void* context field. In typical practice, the value for context on the
 * struct is the one passed through in every call made to a callback. This allows platform
 * callbacks to propagate state when supplying the callbacks and later, receiving them. Common code
 * will not attempt to use or modify this state - it's purely for the platform implementation to
 * leverage. Often that might mean it contains references to platform-native objects and/or thread
 * dispatch mechanisms that can be used to dispatch the callback as appropriate to platform code.
 */

/**
 * Handle to an Envoy engine instance. Valid only for the lifetime of the engine and not intended
 * for any external interpretation or use.
 */
typedef intptr_t envoy_engine_t;

/**
 * Handle to an outstanding Envoy HTTP stream. Valid only for the duration of the stream and not
 * intended for any external interpretation or use.
 */
typedef intptr_t envoy_stream_t;

/**
 * Result codes returned by all calls made to this interface.
 */
typedef enum {
  ENVOY_SUCCESS = 0,
  ENVOY_FAILURE = 1,
} envoy_status_t;

typedef enum {
  UNSPECIFIED = 0, // Measured quantity does not require a unit, e.g. "items".
  BYTES = 1,
  MICROSECONDS = 2,
  MILLISECONDS = 3,
} envoy_histogram_stat_unit_t;

/**
 * Equivalent constants to envoy_status_t, for contexts where the enum may not be usable.
 */
extern const int kEnvoySuccess;
extern const int kEnvoyFailure;

/**
 * Error code associated with terminal status of a HTTP stream.
 */
typedef enum {
  ENVOY_UNDEFINED_ERROR,
  ENVOY_STREAM_RESET,
  ENVOY_CONNECTION_FAILURE,
  ENVOY_BUFFER_LIMIT_EXCEEDED,
  ENVOY_REQUEST_TIMEOUT,
} envoy_error_code_t;

/**
 * Networks classified by last physical link.
 * ENVOY_NET_GENERIC is default and includes cases where network characteristics are unknown.
 * ENVOY_NET_WLAN includes WiFi and other local area wireless networks.
 * ENVOY_NET_WWAN includes all mobile phone networks.
 */
typedef enum {
  ENVOY_NET_GENERIC = 0,
  ENVOY_NET_WLAN = 1,
  ENVOY_NET_WWAN = 2,
} envoy_network_t;

// The name used to registered event tracker api.
extern const char* envoy_event_tracker_api_name;

#ifdef __cplusplus
extern "C" { // release function
#endif
/**
 * Callback indicating Envoy has drained the associated buffer.
 */
typedef void (*envoy_release_f)(void* context);

/**
 * No-op callback.
 */
void envoy_noop_release(void* context);

/**
 * Const version of no-op release callback.
 */
void envoy_noop_const_release(const void* context);

#ifdef __cplusplus
} // release function
#endif

/**
 * Holds raw binary data as an array of bytes.
 */
typedef struct {
  size_t length;
  const uint8_t* bytes;
  envoy_release_f release;
  void* context;
} envoy_data;

/**
 * Holds a single key/value pair.
 */
typedef struct {
  envoy_data key;
  envoy_data value;
} envoy_map_entry;

/**
 * Consistent type for dealing with encodable/processable header counts.
 */
typedef int envoy_map_size_t;

/**
 * Holds a map as an array of envoy_map_entry structs.
 */
typedef struct {
  // Number of entries in the array.
  envoy_map_size_t length;
  // Array of map entries.
  envoy_map_entry* entries;
} envoy_map;

// Multiple header values for the same header key are supported via a comma-delimited string.
typedef envoy_map envoy_headers;

typedef envoy_map envoy_stats_tags;

/*
 * Error struct.
 */
typedef struct {
  envoy_error_code_t error_code;
  envoy_data message;
  // the number of times an operation was attempted before firing this error.
  // For instance this is used in envoy_on_error_f to account for the number of upstream requests
  // made in a retry series before the on error callback fired.
  // -1 is used in scenarios where it does not make sense to have an attempt count for an error.
  // This is different from 0, which intentionally conveys that the action was _not_ executed.
  int32_t attempt_count;
} envoy_error;

/**
 * Contains internal HTTP stream metrics, context, and other details which are
 * sent with most callbacks.
 *
 * Note these values may change over the lifecycle of a stream.
 */
typedef struct {
  // An internal identifier for the stream. -1 if not preset.
  int64_t stream_id;
  // An internal identifier for the connection carrying the stream. -1 if not present.
  int64_t connection_id;
  // The number of internal attempts to carry out a request/operation. 0 if not present.
  uint64_t attempt_count;
  // Number of bytes consumed by the non terminal callbacks out of the response.
  // NOTE: on terminal callbacks (on_complete, on_error_, on_cancel), this value will not be equal
  //       to envoy_final_stream_intel.received_byte_count. The latter represents the real number
  //       of bytes received before decompression. consumed_bytes_from_response omits the number
  //       number of bytes related to the Status Line, and is after decompression.
  uint64_t consumed_bytes_from_response;
} envoy_stream_intel;

/**
 * Contains internal HTTP stream metrics which sent at stream end.
 *
 * Note: for the signed fields, -1 means not present.
 */
typedef struct {
  // The time the stream started (a.k.a request started), in ms since the epoch.
  int64_t stream_start_ms;
  // The time the DNS resolution for this request started, in ms since the epoch.
  int64_t dns_start_ms;
  // The time the DNS resolution for this request completed, in ms since the epoch.
  int64_t dns_end_ms;
  // The time the upstream connection started, in ms since the epoch.
  // This may not be set if socket_reused is false.
  int64_t connect_start_ms;
  // The time the upstream connection completed, in ms since the epoch.
  // This may not be set if socket_reused is false.
  int64_t connect_end_ms;
  // The time the SSL handshake started, in ms since the epoch.
  // This may not be set if socket_reused is false.
  int64_t ssl_start_ms;
  // The time the SSL handshake completed, in ms since the epoch.
  // This may not be set if socket_reused is false.
  int64_t ssl_end_ms;
  // The time the first byte of the request was sent upstream, in ms since the epoch.
  int64_t sending_start_ms;
  // The time the last byte of the request was sent upstream, in ms since the epoch.
  int64_t sending_end_ms;
  // The time the first byte of the response was received, in ms since the epoch.
  int64_t response_start_ms;
  // The time when the stream reached a final state: Error, Cancel, Success.
  int64_t stream_end_ms;
  // True if the upstream socket had been used previously.
  uint64_t socket_reused;
  // The number of bytes sent upstream.
  uint64_t sent_byte_count;
  // The number of bytes received from upstream.
  uint64_t received_byte_count;
  // The final response flags for the stream. See
  // https://github.com/envoyproxy/envoy/blob/main/envoy/stream_info/stream_info.h
  // for the ResponseFlag enum.
  uint64_t response_flags;
  // The upstream protocol, if an upstream connection was established. Field
  // entries are based off of Envoy's Http::Protocol
  // Http10 == 0
  // Http11 == 1
  // Http2 == 2
  // Http3 == 3
  int64_t upstream_protocol;
} envoy_final_stream_intel;

#ifdef __cplusplus
extern "C" { // utility functions
#endif

/**
 * malloc wrapper that asserts that the returned pointer is valid. Otherwise, the program exits.
 * @param size, the size of memory to be allocated in bytes.
 * @return void*, pointer to the allocated memory.
 */
void* safe_malloc(size_t size);

/**
 * calloc wrapper that asserts that the returned pointer is valid. Otherwise, the program exits.
 * @param count, the number of elements to be allocated.
 * @param size, the size of elements in bytes.
 * @return void*, pointer to the allocated memory.
 */
void* safe_calloc(size_t count, size_t size);

/**
 * Called by a receiver of envoy_data to indicate memory/resources can be released.
 * @param data, envoy_data to release.
 */
void release_envoy_data(envoy_data data);

/**
 * Called by a receiver of envoy_map to indicate memory/resources can be released.
 * @param map, envoy_map to release.
 */
void release_envoy_map(envoy_map map);

/**
 * Called by a receiver of envoy_headers to indicate memory/resources can be released.
 * @param headers, envoy_headers to release.
 */
void release_envoy_headers(envoy_headers headers);

/**
 * Called by a receiver of envoy_stats_tags to indicate memory/resources can be released.
 * @param stats_tags, envoy_stats_tags to release.
 */
void release_envoy_stats_tags(envoy_stats_tags stats_tags);

/**
 * Called by a receiver of envoy_error to indicate memory/resources can be released.
 * @param error, envoy_error to release.
 */
void release_envoy_error(envoy_error error);

/**
 * Helper function to copy envoy_headers.
 * @param src, the envoy_headers to copy from.
 * @param envoy_headers, copied headers.
 */
envoy_headers copy_envoy_headers(envoy_headers src);

/**
 * Helper function to copy envoy_data.
 * @param src, the envoy_data to copy from.
 * @return envoy_data, the envoy_data copied from the src.
 */
envoy_data copy_envoy_data(envoy_data src);

#ifdef __cplusplus
} // utility functions
#endif

// Convenience constant to pass to function calls with no data.
// For example when sending a headers-only request.
extern const envoy_data envoy_nodata;

// Convenience constant to pass to function calls with no headers.
extern const envoy_headers envoy_noheaders;

// Convenience constant to pass to function calls with no tags.
extern const envoy_stats_tags envoy_stats_notags;

#ifdef __cplusplus
extern "C" { // function pointers
#endif

/**
 * Callback signature for headers on an HTTP stream.
 *
 * @param headers, the headers received.
 * @param end_stream, whether the response is headers-only.
 * @param stream_intel, contains internal stream metrics, context, and other details.
 * @param context, contains the necessary state to carry out platform-specific dispatch and
 * execution.
 * @return void*, return context (may be unused).
 */
typedef void* (*envoy_on_headers_f)(envoy_headers headers, bool end_stream,
                                    envoy_stream_intel stream_intel, void* context);

/**
 * Callback signature for data on an HTTP stream.
 *
 * This callback can be invoked multiple times when data is streamed.
 *
 * @param data, the data received.
 * @param end_stream, whether the data is the last data frame.
 * @param stream_intel, contains internal stream metrics, context, and other details.
 * @param context, contains the necessary state to carry out platform-specific dispatch and
 * execution.
 * @return void*, return context (may be unused).
 */
typedef void* (*envoy_on_data_f)(envoy_data data, bool end_stream, envoy_stream_intel stream_intel,
                                 void* context);

/**
 * Callback signature for metadata on an HTTP stream.
 *
 * Note that metadata frames are prohibited from ending a stream.
 *
 * @param metadata, the metadata received.
 * @param stream_intel, contains internal stream metrics, context, and other details.
 * @param context, contains the necessary state to carry out platform-specific dispatch and
 * execution.
 * @return void*, return context (may be unused).
 */
typedef void* (*envoy_on_metadata_f)(envoy_headers metadata, envoy_stream_intel stream_intel,
                                     void* context);

/**
 * Callback signature for trailers on an HTTP stream.
 *
 * Note that end stream is implied when on_trailers is called.
 *
 * @param trailers, the trailers received.
 * @param stream_intel, contains internal stream metrics, context, and other details.
 * @param context, contains the necessary state to carry out platform-specific dispatch and
 * execution.
 * @return void*, return context (may be unused).
 */
typedef void* (*envoy_on_trailers_f)(envoy_headers trailers, envoy_stream_intel stream_intel,
                                     void* context);

/**
 * Callback signature for errors with an HTTP stream.
 *
 * This is a TERMINAL callback. Exactly one terminal callback will be called per stream.
 *
 * @param envoy_error, the error received/caused by the async HTTP stream.
 * @param stream_intel, contains internal stream metrics, context, and other details.
 * @param final_stream_intel, contains final internal stream metrics, context, and other details.
 * @param context, contains the necessary state to carry out platform-specific dispatch and
 * execution.
 * @return void*, return context (may be unused).
 */
typedef void* (*envoy_on_error_f)(envoy_error error, envoy_stream_intel stream_intel,
                                  envoy_final_stream_intel final_stream_intel, void* context);

/**
 * Callback signature for when an HTTP stream bi-directionally completes without error.
 *
 * This is a TERMINAL callback. Exactly one terminal callback will be called per stream.
 *
 * @param stream_intel, contains internal stream metrics, context, and other details.
 * @param final_stream_intel, contains final internal stream metrics, context, and other details.
 * @param context, contains the necessary state to carry out platform-specific dispatch and
 * execution.
 * @return void*, return context (may be unused).
 */
typedef void* (*envoy_on_complete_f)(envoy_stream_intel stream_intel,
                                     envoy_final_stream_intel final_stream_intel, void* context);

/**
 * Callback signature for when an HTTP stream is cancelled.
 *
 * This is a TERMINAL callback. Exactly one terminal callback will be called per stream.
 *
 * @param stream_intel, contains internal stream metrics, context, and other details.
 * @param final_stream_intel, contains final internal stream metrics, context, and other details.
 * @param context, contains the necessary state to carry out platform-specific dispatch and
 * execution.
 * @return void*, return context (may be unused).
 */
typedef void* (*envoy_on_cancel_f)(envoy_stream_intel stream_intel,
                                   envoy_final_stream_intel final_stream_intel, void* context);

/**
 * Called when the envoy engine is exiting.
 */
typedef void (*envoy_on_exit_f)(void* context);

/**
 * Called when the envoy has finished its async setup and returned post-init callbacks.
 *
 * @param context, contains the necessary state to carry out platform-specific dispatch and
 * execution.
 */
typedef void (*envoy_on_engine_running_f)(void* context);

/**
 * Called when envoy's logger logs data.
 *
 * @param data, the logged data.
 * @param context, contains the necessary state to carry out platform-specific dispatch and
 * execution.
 */
typedef void (*envoy_logger_log_f)(envoy_data data, const void* context);

/**
 * Called when Envoy is done with the logger.
 *
 * @param context, contains the necessary state to carry out platform-specific dispatch and
 * execution.
 */
typedef void (*envoy_logger_release_f)(const void* context);

/**
 * Callback signature which notify when there is buffer available for request
 * body upload.
 *
 * This is only ever called when the library is in explicit flow control mode.
 * In explicit mode, this will be called after the first call to decodeData, when
 * more buffer is available locally for request body. It will then be called once per
 * decodeData call to inform the sender when it is safe to send more data.
 *
 * @param stream_intel, contains internal stream metrics, context, and other details.
 * @param context, contains the necessary state to carry out platform-specific dispatch and
 * execution.
 * @return void*, return context (may be unused).
 */
typedef void* (*envoy_on_send_window_available_f)(envoy_stream_intel stream_intel, void* context);

/**
 * Called when envoy's event tracker tracks an event.
 *
 * @param event, the dictionary with attributes that describe the event.
 * @param context, contains the necessary state to carry out platform-specific dispatch and
 * execution.
 */
typedef void (*envoy_event_tracker_track_f)(envoy_map event, const void* context);

#ifdef __cplusplus
} // function pointers
#endif

/**
 * Interface to handle HTTP callbacks.
 */
typedef struct {
  envoy_on_headers_f on_headers;
  envoy_on_data_f on_data;
  envoy_on_metadata_f on_metadata;
  envoy_on_trailers_f on_trailers;
  envoy_on_error_f on_error;
  envoy_on_complete_f on_complete;
  envoy_on_cancel_f on_cancel;
  envoy_on_send_window_available_f on_send_window_available;
  // Context passed through to callbacks to provide dispatch and execution state.
  void* context;
} envoy_http_callbacks;

/**
 * Interface that can handle engine callbacks.
 */
typedef struct {
  envoy_on_engine_running_f on_engine_running;
  envoy_on_exit_f on_exit;
  // Context passed through to callbacks to provide dispatch and execution state.
  void* context;
} envoy_engine_callbacks;

/**
 * Interface for logging.
 */
typedef struct {
  envoy_logger_log_f log;
  envoy_logger_release_f release;
  // Context passed through to callbacks to provide dispatch and execution state.
  const void* context;
} envoy_logger;

/**
 * Interface for event tracking.
 */
typedef struct {
  envoy_event_tracker_track_f track;
  // Context passed through to callbacks to provide dispatch and execution state.
  const void* context;
} envoy_event_tracker;

/**
 * The list of certificate verification results returned from Java side to the
 * C++ side.
 * A Java counterpart lives in org.chromium.net.CertVerifyStatusAndroid.java
 */
typedef enum {
  // Certificate is trusted.
  CERT_VERIFY_STATUS_OK = 0,
  // Certificate verification could not be conducted.
  CERT_VERIFY_STATUS_FAILED = -1,
  // Certificate is not trusted due to non-trusted root of the certificate
  // chain.
  CERT_VERIFY_STATUS_NO_TRUSTED_ROOT = -2,
  // Certificate is not trusted because it has expired.
  CERT_VERIFY_STATUS_EXPIRED = -3,
  // Certificate is not trusted because it is not valid yet.
  CERT_VERIFY_STATUS_NOT_YET_VALID = -4,
  // Certificate is not trusted because it could not be parsed.
  CERT_VERIFY_STATUS_UNABLE_TO_PARSE = -5,
  // Certificate is not trusted because it has an extendedKeyUsage field, but
  // its value is not correct for a web server.
  CERT_VERIFY_STATUS_INCORRECT_KEY_USAGE = -6,
} envoy_cert_verify_status_t;
#pragma once

// NOLINT(namespace-envoy)

#include <string>

/* This struct contains data to configure Envoy's envoy::config::route::v3::HeaderMatcher
 * We use a separate struct both to avoid the proliferation of protos but also
 * because only a limited set of HeaderMatcher arguments are supported through
 * the JNI interface */
struct MatcherData {
  std::string name;
  enum Type {
    EXACT = 0,
    SAFE_REGEX = 1,
  };
  Type type;
  std::string value;
  MatcherData(std::string name, Type type, std::string value)
      : name(name), type(type), value(value) {}
};
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "c_types_lib",
    srcs = [
        "c_types.cc",
    ],
    hdrs = [
        "c_types.h",
    ],
    repository = "@envoy",
    visibility = ["//visibility:public"],
    deps = [
        "@envoy//source/common/common:assert_lib",
    ],
)

envoy_cc_library(
    name = "matcher_data_lib",
    srcs = [
        "matcher_data.h",
    ],
    repository = "@envoy",
    visibility = ["//visibility:public"],
    deps = [
        "//library/common/types:c_types_lib",
    ],
)

envoy_cc_library(
    name = "managed_types_lib",
    srcs = [
        "managed_envoy_headers.h",
    ],
    repository = "@envoy",
    visibility = ["//visibility:public"],
    deps = [
        "//library/common/types:c_types_lib",
    ],
)
// NOLINT(namespace-envoy)
#include "library/common/types/c_types.h"

#include <string>

#include "source/common/common/assert.h"

const int kEnvoySuccess = ENVOY_SUCCESS;
const int kEnvoyFailure = ENVOY_FAILURE;

void* safe_malloc(size_t size) {
  void* ptr = malloc(size);
  if (size > 0) {
    RELEASE_ASSERT(ptr != nullptr, "malloc failure");
  }
  return ptr;
}

void* safe_calloc(size_t count, size_t size) {
  void* ptr = calloc(count, size);
  if (count > 0 && size > 0) {
    RELEASE_ASSERT(ptr != nullptr, "calloc failure");
  }
  return ptr;
}

void envoy_noop_release(void* context) { (void)context; }

void envoy_noop_const_release(const void* context) { (void)context; }

void release_envoy_data(envoy_data data) { data.release(data.context); }

void release_envoy_map(envoy_map map) {
  for (envoy_map_size_t i = 0; i < map.length; i++) {
    envoy_map_entry entry = map.entries[i];
    release_envoy_data(entry.key);
    release_envoy_data(entry.value);
  }
  free(map.entries);
}

void release_envoy_headers(envoy_headers headers) { release_envoy_map(headers); }

void release_envoy_error(envoy_error error) { error.message.release(error.message.context); }

void release_envoy_stats_tags(envoy_stats_tags stats_tags) { release_envoy_map(stats_tags); }

envoy_map copy_envoy_data_map(envoy_map src) {
  envoy_map_entry* dst_entries =
      static_cast<envoy_map_entry*>(safe_malloc(sizeof(envoy_map_entry) * src.length));
  for (envoy_map_size_t i = 0; i < src.length; i++) {
    envoy_map_entry new_entry = {copy_envoy_data(src.entries[i].key),
                                 copy_envoy_data(src.entries[i].value)};
    dst_entries[i] = new_entry;
  }
  envoy_map dst = {src.length, dst_entries};
  return dst;
}

envoy_headers copy_envoy_headers(envoy_headers src) { return copy_envoy_data_map(src); }

envoy_data copy_envoy_data(envoy_data src) {
  uint8_t* dst_bytes = static_cast<uint8_t*>(safe_malloc(sizeof(uint8_t) * src.length));
  memcpy(dst_bytes, src.bytes, src.length); // NOLINT(safe-memcpy)
  // Note: since this function is copying the bytes over to freshly allocated memory, free is an
  // appropriate release function and dst_bytes is an appropriate context.
  return {src.length, dst_bytes, free, dst_bytes};
}

const envoy_data envoy_nodata = {0, NULL, envoy_noop_release, NULL};

const envoy_headers envoy_noheaders = {0, NULL};

const envoy_stats_tags envoy_stats_notags = {0, NULL};

const char* envoy_event_tracker_api_name = "event_tracker_api";
#include "library/common/engine_common.h"

#include "source/common/common/random_generator.h"
#include "source/common/runtime/runtime_impl.h"
#include "source/server/null_overload_manager.h"

#if !defined(ENVOY_ENABLE_FULL_PROTOS)

#include "bazel/cc_proto_descriptor_library/file_descriptor_info.h"
#include "source/common/protobuf/protobuf.h"

#include "library/common/extensions/cert_validator/platform_bridge/platform_bridge_descriptor.pb.h"
#include "library/common/extensions/filters/http/local_error/filter_descriptor.pb.h"
#include "library/common/extensions/filters/http/network_configuration/filter_descriptor.pb.h"
#include "library/common/extensions/filters/http/platform_bridge/filter_descriptor.pb.h"
#include "library/common/extensions/filters/http/socket_tag/filter_descriptor.pb.h"
#include "library/common/extensions/key_value/platform/platform_descriptor.pb.h"
#include "library/common/extensions/retry/options/network_configuration/predicate_descriptor.pb.h"

namespace Envoy {

bool initialize() {
  std::vector<FileDescriptorInfo> file_descriptors = {
      protobuf::reflection::
          library_common_extensions_cert_validator_platform_bridge_platform_bridge::
              kFileDescriptorInfo,
      protobuf::reflection::library_common_extensions_filters_http_local_error_filter::
          kFileDescriptorInfo,
      protobuf::reflection::library_common_extensions_filters_http_network_configuration_filter::
          kFileDescriptorInfo,
      protobuf::reflection::library_common_extensions_filters_http_platform_bridge_filter::
          kFileDescriptorInfo,
      protobuf::reflection::library_common_extensions_filters_http_socket_tag_filter::
          kFileDescriptorInfo,
      protobuf::reflection::library_common_extensions_key_value_platform_platform::
          kFileDescriptorInfo,
      protobuf::reflection::
          library_common_extensions_retry_options_network_configuration_predicate::
              kFileDescriptorInfo,
  };
  for (const FileDescriptorInfo& descriptor : file_descriptors) {
    loadFileDescriptors(descriptor);
  }
  return true;
}

void registerMobileProtoDescriptors() {
  static bool initialized = initialize();
  (void)initialized;
}

} // namespace Envoy

#endif

namespace Envoy {

class ServerLite : public Server::InstanceBase {
public:
  using Server::InstanceBase::InstanceBase;
  void maybeCreateHeapShrinker() override {}
  std::unique_ptr<Envoy::Server::OverloadManager> createOverloadManager() override {
    return std::make_unique<Envoy::Server::NullOverloadManager>(threadLocal(), true);
  }
  std::unique_ptr<Server::GuardDog> maybeCreateGuardDog(absl::string_view) override {
    return nullptr;
  }
};

EngineCommon::EngineCommon(std::unique_ptr<Envoy::OptionsImplBase>&& options)
    : options_(std::move(options)) {

#if !defined(ENVOY_ENABLE_FULL_PROTOS)
  registerMobileProtoDescriptors();
#endif

  StrippedMainBase::CreateInstanceFunction create_instance =
      [](Init::Manager& init_manager, const Server::Options& options,
         Event::TimeSystem& time_system, ListenerHooks& hooks, Server::HotRestart& restarter,
         Stats::StoreRoot& store, Thread::BasicLockable& access_log_lock,
         Server::ComponentFactory& component_factory, Random::RandomGeneratorPtr&& random_generator,
         ThreadLocal::Instance& tls, Thread::ThreadFactory& thread_factory,
         Filesystem::Instance& file_system, std::unique_ptr<ProcessContext> process_context,
         Buffer::WatermarkFactorySharedPtr watermark_factory) {
        auto local_address = Network::Utility::getLocalAddress(options.localAddressIpVersion());
        auto server = std::make_unique<ServerLite>(
            init_manager, options, time_system, hooks, restarter, store, access_log_lock,
            std::move(random_generator), tls, thread_factory, file_system,
            std::move(process_context), watermark_factory);
        server->initialize(local_address, component_factory);
        return server;
      };
  base_ = std::make_unique<StrippedMainBase>(
      *options_, real_time_system_, default_listener_hooks_, prod_component_factory_,
      std::make_unique<PlatformImpl>(), std::make_unique<Random::RandomGeneratorImpl>(), nullptr,
      create_instance);
  // Disabling signal handling in the options makes it so that the server's event dispatcher _does
  // not_ listen for termination signals such as SIGTERM, SIGINT, etc
  // (https://github.com/envoyproxy/envoy/blob/048f4231310fbbead0cbe03d43ffb4307fff0517/source/server/server.cc#L519).
  // Previous crashes in iOS were experienced due to early event loop exit as described in
  // https://github.com/envoyproxy/envoy-mobile/issues/831. Ignoring termination signals makes it
  // more likely that the event loop will only exit due to Engine destruction
  // https://github.com/envoyproxy/envoy-mobile/blob/a72a51e64543882ea05fba3c76178b5784d39cdc/library/common/engine.cc#L105.
  options_->setSignalHandling(false);
}

} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_library", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "certificates_lib",
    srcs = select({
        "//bazel:exclude_certificates": [],
        "//conditions:default": [
            "certificates.inc",
        ],
    }),
    copts = select({
        "//bazel:exclude_certificates": ["-DEXCLUDE_CERTIFICATES"],
        "//conditions:default": [],
    }),
    repository = "@envoy",
)
R"certs(
  # $OpenBSD: cert.pem,v 1.24 2021/09/30 18:16:11 deraadt Exp $
  ### /C=ES/CN=Autoridad de Certificacion Firmaprofesional CIF A62634068

  === /C=ES/CN=Autoridad de Certificacion Firmaprofesional CIF A62634068
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 6047274297262753887 (0x53ec3beefbb2485f)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: May 20 08:38:15 2009 GMT
              Not After : Dec 31 08:38:15 2030 GMT
          Subject: C=ES, CN=Autoridad de Certificacion Firmaprofesional CIF A62634068
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE, pathlen:1
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  65:CD:EB:AB:35:1E:00:3E:7E:D5:74:C0:1C:B4:73:47:0E:1A:64:2F
              X509v3 Certificate Policies:
                  Policy: X509v3 Any Policy
                    CPS: http://www.firmaprofesional.com/cps
                    User Notice:
                      Explicit Text:

  SHA1 Fingerprint=AE:C5:FB:3F:C8:E1:BF:C4:E5:4F:03:07:5A:9A:E8:00:B7:F7:B6:FA
  SHA256 Fingerprint=04:04:80:28:BF:1F:28:64:D4:8F:9A:D4:D8:32:94:36:6A:82:88:56:55:3F:3B:14:30:3F:90:14:7F:5D:40:EF
  -----BEGIN CERTIFICATE-----
  MIIGFDCCA/ygAwIBAgIIU+w77vuySF8wDQYJKoZIhvcNAQEFBQAwUTELMAkGA1UE
  BhMCRVMxQjBABgNVBAMMOUF1dG9yaWRhZCBkZSBDZXJ0aWZpY2FjaW9uIEZpcm1h
  cHJvZmVzaW9uYWwgQ0lGIEE2MjYzNDA2ODAeFw0wOTA1MjAwODM4MTVaFw0zMDEy
  MzEwODM4MTVaMFExCzAJBgNVBAYTAkVTMUIwQAYDVQQDDDlBdXRvcmlkYWQgZGUg
  Q2VydGlmaWNhY2lvbiBGaXJtYXByb2Zlc2lvbmFsIENJRiBBNjI2MzQwNjgwggIi
  MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDKlmuO6vj78aI14H9M2uDDUtd9
  thDIAl6zQyrET2qyyhxdKJp4ERppWVevtSBC5IsP5t9bpgOSL/UR5GLXMnE42QQM
  cas9UX4PB99jBVzpv5RvwSmCwLTaUbDBPLutN0pcyvFLNg4kq7/DhHf9qFD0sefG
  L9ItWY16Ck6WaVICqjaY7Pz6FIMMNx/Jkjd/14Et5cS54D40/mf0PmbR0/RAz15i
  NA9wBj4gGFrO93IbJWyTdBSTo3OxDqqHECNZXyAFGUftaI6SEspd/NYrspI8IM/h
  X68gvqB2f3bl7BqGYTM+53u0P6APjqK5am+5hyZvQWyIplD9amML9ZMWGxmPsu2b
  m8mQ9QEM3xk9Dz44I8kvjwzRAv4bVdZO0I08r0+k8/6vKtMFnXkIoctXMbScyJCy
  Z/QYFpM6/EfY0XiWMR+6KwxfXZmtY4laJCB22N/9q06mIqqdXuYnin1oKaPnirja
  EbsXLZmdEyRG98Xi2J+Of8ePdG1asuhy9azuJBCtLxTa/y2aRnFHvkLfuwHb9H/T
  KI8xWVvTyQKmtFLKbpf7Q8UIJm+K9Lv9nyiqDdVF8xM6HdjAeI9BZzwelGSuewvF
  6NkBiDkal4ZkQdU7hwxu+g/GvUgUvzlN1J5Bto+WHWOWk9mVBngxaJ43BjuAiUVh
  OSPHG0SjFeUc+JIwuwIDAQABo4HvMIHsMBIGA1UdEwEB/wQIMAYBAf8CAQEwDgYD
  VR0PAQH/BAQDAgEGMB0GA1UdDgQWBBRlzeurNR4APn7VdMActHNHDhpkLzCBpgYD
  VR0gBIGeMIGbMIGYBgRVHSAAMIGPMC8GCCsGAQUFBwIBFiNodHRwOi8vd3d3LmZp
  cm1hcHJvZmVzaW9uYWwuY29tL2NwczBcBggrBgEFBQcCAjBQHk4AUABhAHMAZQBv
  ACAAZABlACAAbABhACAAQgBvAG4AYQBuAG8AdgBhACAANAA3ACAAQgBhAHIAYwBl
  AGwAbwBuAGEAIAAwADgAMAAxADcwDQYJKoZIhvcNAQEFBQADggIBABd9oPm03cXF
  661LJLWhAqvdpYhKsg9VSytXjDvlMd3+xDLx51tkljYyGOylMnfX40S2wBEqgLk9
  am58m9Ot/MPWo+ZkKXzR4Tgegiv/J2Wv+xYVxC5xhOW1//qkR71kMrv2JYSiJ0L1
  ILDCExARzRAVukKQKtJE4ZYm6zFIEv0q2skGz3QeqUvVhyj5eTSSPi5E6PaPT481
  PyWzOdxjKpBrIF/EUhJOlywqrJ2X3kjyo2bbwtKDlaZmp54lD+kLM5FlClrD2VQS
  3a/DTg4fJl4N3LON7NWBcN7STyQF82xO9UxJZo3R/9ILJUFI/lGExkKvgATP0H5k
  SeTy36LssUzAKh3ntLFlosS88Zj0qnAHY7S42jtM+kAiMFsRpvAFDsYCA0irhpuF
  3dvd6qJ2gHN99ZwExEWN57kci57q13XRcrHedUTnQn3iV2t93Jm8PYMo6oCTjcVM
  ZcFwgbg4/EMxsvYDNEeyrPsiBsse3RdHHF9mudMaotoRsaS8I8nkvof/uZS2+F0g
  StRf571oe2XyFR7SOqkt6dhrJKyXWERHrVkY8SFlcN7ONGCoQPHzPKTDKCOM/icz
  Q0CgFzzr6juwcqajuUpLXhZI9LK8yIySxZ2frHI2vDSANGupi5LAuBft7HZT9SQB
  jLMi6Et8Vcad+qMUu2WFbm5PEn4KPJ2V
  -----END CERTIFICATE-----

  ### ACCV

  === /CN=ACCVRAIZ1/OU=PKIACCV/O=ACCV/C=ES
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 6828503384748696800 (0x5ec3b7a6437fa4e0)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: May  5 09:37:37 2011 GMT
              Not After : Dec 31 09:37:37 2030 GMT
          Subject: CN=ACCVRAIZ1, OU=PKIACCV, O=ACCV, C=ES
          X509v3 extensions:
              Authority Information Access:
                  CA Issuers - URI:http://www.accv.es/fileadmin/Archivos/certificados/raizaccv1.crt
                  OCSP - URI:http://ocsp.accv.es

              X509v3 Subject Key Identifier:
                  D2:87:B4:E3:DF:37:27:93:55:F6:56:EA:81:E5:36:CC:8C:1E:3F:BD
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Authority Key Identifier:
                  keyid:D2:87:B4:E3:DF:37:27:93:55:F6:56:EA:81:E5:36:CC:8C:1E:3F:BD

              X509v3 Certificate Policies:
                  Policy: X509v3 Any Policy
                    User Notice:
                      Explicit Text:
                    CPS: http://www.accv.es/legislacion_c.htm

              X509v3 CRL Distribution Points:

                  Full Name:
                    URI:http://www.accv.es/fileadmin/Archivos/certificados/raizaccv1_der.crl

              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Alternative Name:
                  email:accv@accv.es
  SHA1 Fingerprint=93:05:7A:88:15:C6:4F:CE:88:2F:FA:91:16:52:28:78:BC:53:64:17
  SHA256 Fingerprint=9A:6E:C0:12:E1:A7:DA:9D:BE:34:19:4D:47:8A:D7:C0:DB:18:22:FB:07:1D:F1:29:81:49:6E:D1:04:38:41:13
  -----BEGIN CERTIFICATE-----
  MIIH0zCCBbugAwIBAgIIXsO3pkN/pOAwDQYJKoZIhvcNAQEFBQAwQjESMBAGA1UE
  AwwJQUNDVlJBSVoxMRAwDgYDVQQLDAdQS0lBQ0NWMQ0wCwYDVQQKDARBQ0NWMQsw
  CQYDVQQGEwJFUzAeFw0xMTA1MDUwOTM3MzdaFw0zMDEyMzEwOTM3MzdaMEIxEjAQ
  BgNVBAMMCUFDQ1ZSQUlaMTEQMA4GA1UECwwHUEtJQUNDVjENMAsGA1UECgwEQUND
  VjELMAkGA1UEBhMCRVMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCb
  qau/YUqXry+XZpp0X9DZlv3P4uRm7x8fRzPCRKPfmt4ftVTdFXxpNRFvu8gMjmoY
  HtiP2Ra8EEg2XPBjs5BaXCQ316PWywlxufEBcoSwfdtNgM3802/J+Nq2DoLSRYWo
  G2ioPej0RGy9ocLLA76MPhMAhN9KSMDjIgro6TenGEyxCQ0jVn8ETdkXhBilyNpA
  lHPrzg5XPAOBOp0KoVdDaaxXbXmQeOW1tDvYvEyNKKGno6e6Ak4l0Squ7a4DIrhr
  IA8wKFSVf+DuzgpmndFALW4ir50awQUZ0m/A8p/4e7MCQvtQqR0tkw8jq8bBD5L/
  0KIV9VMJcRz/RROE5iZe+OCIHAr8Fraocwa48GOEAqDGWuzndN9wrqODJerWx5eH
  k6fGioozl2A3ED6XPm4pFdahD9GILBKfb6qkxkLrQaLjlUPTAYVtjrs78yM2x/47
  4KElB0iryYl0/wiPgL/AlmXz7uxLaL2diMMxs0Dx6M/2OLuc5NF/1OVYm3z61PMO
  m3WR5LpSLhl+0fXNWhn8ugb2+1KoS5kE3fj5tItQo05iifCHJPqDQsGH+tUtKSpa
  cXpkatcnYGMN285J9Y0fkIkyF/hzQ7jSWpOGYdbhdQrqeWZ2iE9x6wQl1gpaepPl
  uUsXQA+xtrn13k/c4LOsOxFwYIRKQ26ZIMApcQrAZQIDAQABo4ICyzCCAscwfQYI
  KwYBBQUHAQEEcTBvMEwGCCsGAQUFBzAChkBodHRwOi8vd3d3LmFjY3YuZXMvZmls
  ZWFkbWluL0FyY2hpdm9zL2NlcnRpZmljYWRvcy9yYWl6YWNjdjEuY3J0MB8GCCsG
  AQUFBzABhhNodHRwOi8vb2NzcC5hY2N2LmVzMB0GA1UdDgQWBBTSh7Tj3zcnk1X2
  VuqB5TbMjB4/vTAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFNKHtOPfNyeT
  VfZW6oHlNsyMHj+9MIIBcwYDVR0gBIIBajCCAWYwggFiBgRVHSAAMIIBWDCCASIG
  CCsGAQUFBwICMIIBFB6CARAAQQB1AHQAbwByAGkAZABhAGQAIABkAGUAIABDAGUA
  cgB0AGkAZgBpAGMAYQBjAGkA8wBuACAAUgBhAO0AegAgAGQAZQAgAGwAYQAgAEEA
  QwBDAFYAIAAoAEEAZwBlAG4AYwBpAGEAIABkAGUAIABUAGUAYwBuAG8AbABvAGcA
  7QBhACAAeQAgAEMAZQByAHQAaQBmAGkAYwBhAGMAaQDzAG4AIABFAGwAZQBjAHQA
  cgDzAG4AaQBjAGEALAAgAEMASQBGACAAUQA0ADYAMAAxADEANQA2AEUAKQAuACAA
  QwBQAFMAIABlAG4AIABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBjAGMAdgAuAGUA
  czAwBggrBgEFBQcCARYkaHR0cDovL3d3dy5hY2N2LmVzL2xlZ2lzbGFjaW9uX2Mu
  aHRtMFUGA1UdHwROMEwwSqBIoEaGRGh0dHA6Ly93d3cuYWNjdi5lcy9maWxlYWRt
  aW4vQXJjaGl2b3MvY2VydGlmaWNhZG9zL3JhaXphY2N2MV9kZXIuY3JsMA4GA1Ud
  DwEB/wQEAwIBBjAXBgNVHREEEDAOgQxhY2N2QGFjY3YuZXMwDQYJKoZIhvcNAQEF
  BQADggIBAJcxAp/n/UNnSEQU5CmH7UwoZtCPNdpNYbdKl02125DgBS4OxnnQ8pdp
  D70ER9m+27Up2pvZrqmZ1dM8MJP1jaGo/AaNRPTKFpV8M9xii6g3+CfYCS0b78gU
  JyCpZET/LtZ1qmxNYEAZSUNUY9rizLpm5U9EelvZaoErQNV/+QEnWCzI7UiRfD+m
  AM/EKXMRNt6GGT6d7hmKG9Ww7Y49nCrADdg9ZuM8Db3VlFzi4qc1GwQA9j9ajepD
  vV+JHanBsMyZ4k0ACtrJJ1vnE5Bc5PUzolVt3OAJTS+xJlsndQAJxGJ3KQhfnlms
  tn6tn1QwIgPBHnFk/vk4CpYY3QIUrCPLBhwepH2NDd4nQeit2hW3sCPdK6jT2iWH
  7ehVRE2I9DZ+hJp4rPcOVkkO1jMl1oRQQmwgEh0q1b688nCBpHBgvgW1m54ERL5h
  I6zppSSMEYCUWqKiuUnSwdzRp+0xESyeGabu4VXhwOrPDYTkF7eifKXeVSUG7szA
  h1xA2syVP1XgNce4hL60Xc16gwFy7ofmXx2utYXGJt/mwZrpHgJHnyqobalbz+xF
  d3+YJ5oyXSrjhO7FmGYvliAd3djDJ9ew+f7Zfc3Qn48LFFhRny+Lwzgt3uiP1o2H
  pPVWQxaZLPSkVrQ0uGE3ycJYgBugl6H8WY3pEfbRD0tVNEYqi4Y7
  -----END CERTIFICATE-----

  ### Actalis S.p.A./03358520967

  === /C=IT/L=Milan/O=Actalis S.p.A./03358520967/CN=Actalis Authentication Root CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 6271844772424770508 (0x570a119742c4e3cc)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Sep 22 11:22:02 2011 GMT
              Not After : Sep 22 11:22:02 2030 GMT
          Subject: C=IT, L=Milan, O=Actalis S.p.A./03358520967, CN=Actalis Authentication Root CA
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  52:D8:88:3A:C8:9F:78:66:ED:89:F3:7B:38:70:94:C9:02:02:36:D0
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Authority Key Identifier:
                  keyid:52:D8:88:3A:C8:9F:78:66:ED:89:F3:7B:38:70:94:C9:02:02:36:D0

              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
  SHA1 Fingerprint=F3:73:B3:87:06:5A:28:84:8A:F2:F3:4A:CE:19:2B:DD:C7:8E:9C:AC
  SHA256 Fingerprint=55:92:60:84:EC:96:3A:64:B9:6E:2A:BE:01:CE:0B:A8:6A:64:FB:FE:BC:C7:AA:B5:AF:C1:55:B3:7F:D7:60:66
  -----BEGIN CERTIFICATE-----
  MIIFuzCCA6OgAwIBAgIIVwoRl0LE48wwDQYJKoZIhvcNAQELBQAwazELMAkGA1UE
  BhMCSVQxDjAMBgNVBAcMBU1pbGFuMSMwIQYDVQQKDBpBY3RhbGlzIFMucC5BLi8w
  MzM1ODUyMDk2NzEnMCUGA1UEAwweQWN0YWxpcyBBdXRoZW50aWNhdGlvbiBSb290
  IENBMB4XDTExMDkyMjExMjIwMloXDTMwMDkyMjExMjIwMlowazELMAkGA1UEBhMC
  SVQxDjAMBgNVBAcMBU1pbGFuMSMwIQYDVQQKDBpBY3RhbGlzIFMucC5BLi8wMzM1
  ODUyMDk2NzEnMCUGA1UEAwweQWN0YWxpcyBBdXRoZW50aWNhdGlvbiBSb290IENB
  MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAp8bEpSmkLO/lGMWwUKNv
  UTufClrJwkg4CsIcoBh/kbWHuUA/3R1oHwiD1S0eiKD4j1aPbZkCkpAW1V8IbInX
  4ay8IMKx4INRimlNAJZaby/ARH6jDuSRzVju3PvHHkVH3Se5CAGfpiEd9UEtL0z9
  KK3giq0itFZljoZUj5NDKd45RnijMCO6zfB9E1fAXdKDa0hMxKufgFpbOr3JpyI/
  gCczWw63igxdBzcIy2zSekciRDXFzMwujt0q7bd9Zg1fYVEiVRvjRuPjPdA1Yprb
  rxTIW6HMiRvhMCb8oJsfgadHHwTrozmSBp+Z07/T6k9QnBn+locePGX2oxgkg4YQ
  51Q+qDp2JE+BIcXjDwL4k5RHILv+1A7TaLndxHqEguNTVHnd25zS8gebLra8Pu2F
  be8lEfKXGkJh90qX6IuxEAf6ZYGyojnP9zz/GPvG8VqLWeICrHuS0E4UT1lF9gxe
  KF+w6D9Fz8+vm2/7hNN3WpVvrJSEnu68wEqPSpP4RCHiMUVhUE4Q2OM1fEwZtN4F
  v6MGn8i1zeQf1xcGDXqVdFUNaBr8EBtiZJ1t4JWgw5QHVw0U5r0F+7if5t+L4sbn
  fpb2U8WANFAoWPASUHEXMLrmeGO89LKtmyuy/uE5jF66CyCU3nuDuP/jVo23Eek7
  jPKxwV2dpAtMK9myGPW1n0sCAwEAAaNjMGEwHQYDVR0OBBYEFFLYiDrIn3hm7Ynz
  ezhwlMkCAjbQMA8GA1UdEwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAUUtiIOsifeGbt
  ifN7OHCUyQICNtAwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBCwUAA4ICAQAL
  e3KHwGCmSUyIWOYdiPcUZEim2FgKDk8TNd81HdTtBjHIgT5q1d07GjLukD0R0i70
  jsNjLiNmsGe+b7bAEzlgqqI0JZN1Ut6nna0Oh4lScWoWPBkdg/iaKWW+9D+a2fDz
  WochcYBNy+A4mz+7+uAwTc+G02UQGRjRlwKxK3JCaKygvU5a2hi/a5iB0P2avl4V
  SM0RFbnAKVy06Ij3Pjaut2L9HmLecHgQHEhb2rykOLpn7VU+Xlff1ANATIGk0k9j
  pwlCCRT8AKnCgHNPLsBA2RF7SOp6AsDT6ygBJlh0wcBzIm2Tlf05fbsq4/aC4yyX
  X04fkZT6/iyj2HYauE2yOE+b+h1IYHkm4vP9qdCa6HCPSXrW5b0KDtst842/6+Ok
  fcvHlXHo2qN8xcL4dJIEG4aspCJTQLas/kx2z/uUMsA1n3Y/buWQbqCmJqK4LL7R
  K4X9p2jIugErsWx0Hbhzlefut8cl8ABMALJ+tguLHPPAUJ4lueAI3jZm/zel0btU
  ZCzJJ7VLkn5l/9Mt4blOvH+kQSGQQXemOR/qnuOf0GZvBeyqdn6/axag67XH/JJU
  LysRJyU3eExRarDzzFhdFPFqSBX/wge2sY0PjlxQRrM9vwGYT7JZVEc+NHt4bVaT
  LnPqZih4zR0Uv6CPLy64Lo7yFIrM6bV8+2ydDKXhlg==
  -----END CERTIFICATE-----

  ### AffirmTrust

  === /C=US/O=AffirmTrust/CN=AffirmTrust Commercial
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 8608355977964138876 (0x7777062726a9b17c)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jan 29 14:06:06 2010 GMT
              Not After : Dec 31 14:06:06 2030 GMT
          Subject: C=US, O=AffirmTrust, CN=AffirmTrust Commercial
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  9D:93:C6:53:8B:5E:CA:AF:3F:9F:1E:0F:E5:99:95:BC:24:F6:94:8F
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
  SHA1 Fingerprint=F9:B5:B6:32:45:5F:9C:BE:EC:57:5F:80:DC:E9:6E:2C:C7:B2:78:B7
  SHA256 Fingerprint=03:76:AB:1D:54:C5:F9:80:3C:E4:B2:E2:01:A0:EE:7E:EF:7B:57:B6:36:E8:A9:3C:9B:8D:48:60:C9:6F:5F:A7
  -----BEGIN CERTIFICATE-----
  MIIDTDCCAjSgAwIBAgIId3cGJyapsXwwDQYJKoZIhvcNAQELBQAwRDELMAkGA1UE
  BhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVz
  dCBDb21tZXJjaWFsMB4XDTEwMDEyOTE0MDYwNloXDTMwMTIzMTE0MDYwNlowRDEL
  MAkGA1UEBhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZp
  cm1UcnVzdCBDb21tZXJjaWFsMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
  AQEA9htPZwcroRX1BiLLHwGy43NFBkRJLLtJJRTWzsO3qyxPxkEylFf6EqdbDuKP
  Hx6GGaeqtS25Xw2Kwq+FNXkyLbscYjfysVtKPcrNcV/pQr6U6Mje+SJIZMblq8Yr
  ba0F8PrVC8+a5fBQpIs7R6UjW3p6+DM/uO+Zl+MgwdYoic+U+7lF7eNAFxHUdPAL
  MeIrJmqbTFeurCA+ukV6BfO9m2kVrn1OIGPENXY6BwLJN/3HR+7o8XYdcxXyl6S1
  yHp52UKqK39c/s4mT6NmgTWvRLpUHhwwMmWd5jyTXlBOeuM61G7MGvv50jeuJCqr
  VwMiKA1JdX+3KNp1v47j3A55MQIDAQABo0IwQDAdBgNVHQ4EFgQUnZPGU4teyq8/
  nx4P5ZmVvCT2lI8wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwDQYJ
  KoZIhvcNAQELBQADggEBAFis9AQOzcAN/wr91LoWXym9e2iZWEnStB03TX8nfUYG
  XUPGhi4+c7ImfU+TqbbEKpqrIZcUsd6M06uJFdhrJNTxFq7YpFzUf1GO7RgBsZNj
  vbz4YYCanrHOQnDiqX0GJX0nof5v7LMeJNrjS1UaADs1tDvZ110w/YETifLCBivt
  Z8SOyUOyXGsViQK8YvxO8rUzqrJv0wqiUOP2O+guRMLbZjipM1ZI8W0bM40NjD9g
  N53Tym1+NH4Nn3J2ixufcv1SNUFFApYvHLKac0khsUlHRUe072o0EclNmsxZt9YC
  nlpOZbWUrhvfKbAW8b8Angc6F2S1BLUjIZkKlTuXfO8=
  -----END CERTIFICATE-----
  === /C=US/O=AffirmTrust/CN=AffirmTrust Networking
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 8957382827206547757 (0x7c4f04391cd4992d)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Jan 29 14:08:24 2010 GMT
              Not After : Dec 31 14:08:24 2030 GMT
          Subject: C=US, O=AffirmTrust, CN=AffirmTrust Networking
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  07:1F:D2:E7:9C:DA:C2:6E:A2:40:B4:B0:7A:50:10:50:74:C4:C8:BD
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
  SHA1 Fingerprint=29:36:21:02:8B:20:ED:02:F5:66:C5:32:D1:D6:ED:90:9F:45:00:2F
  SHA256 Fingerprint=0A:81:EC:5A:92:97:77:F1:45:90:4A:F3:8D:5D:50:9F:66:B5:E2:C5:8F:CD:B5:31:05:8B:0E:17:F3:F0:B4:1B
  -----BEGIN CERTIFICATE-----
  MIIDTDCCAjSgAwIBAgIIfE8EORzUmS0wDQYJKoZIhvcNAQEFBQAwRDELMAkGA1UE
  BhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVz
  dCBOZXR3b3JraW5nMB4XDTEwMDEyOTE0MDgyNFoXDTMwMTIzMTE0MDgyNFowRDEL
  MAkGA1UEBhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZp
  cm1UcnVzdCBOZXR3b3JraW5nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
  AQEAtITMMxcua5Rsa2FSoOujz3mUTOWUgJnLVWREZY9nZOIG41w3SfYvm4SEHi3y
  YJ0wTsyEheIszx6e/jarM3c1RNg1lho9Nuh6DtjVR6FqaYvZ/Ls6rnla1fTWcbua
  kCNrmreIdIcMHl+5ni36q1Mr3Lt2PpNMCAiMHqIjHNRqrSK6mQEubWXLviRmVSRL
  QESxG9fhwoXA3hA/Pe24/PHxI1Pcv2WXb9n5QHGNfb2V1M6+oF4nI979ptAmDgAp
  6zxG8D1gvz9Q0twmQVGeFDdCBKNwV6gbh+0t+nvujArjqWaJGctB+d1ENmHP4ndG
  yH329JKBNv3bNPFyfvMMFr20FQIDAQABo0IwQDAdBgNVHQ4EFgQUBx/S55zawm6i
  QLSwelAQUHTEyL0wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwDQYJ
  KoZIhvcNAQEFBQADggEBAIlXshZ6qML91tmbmzTCnLQyFE2npN/svqe++EPbkTfO
  tDIuUFUaNU52Q3Eg75N3ThVwLofDwR1t3Mu1J9QsVtFSUzpE0nPIxBsFZVpikpzu
  QY0x2+c06lkh1QF612S4ZDnNye2v7UsDSKegmQGA3GWjNq5lWUhPgkvIZfFXHeVZ
  Lgo/bNjR9eUJtGxUAArgFU2HdW23WJZa3W3SAKD0m0i+wzekujbgfIeFlxoVot4u
  olu9rxj5kFDNcFn4J2dHy8egBzp90SxdbBk6ZrV9/ZFvgrG+CJPbFEfxojfHRZ48
  x3evZKiT3/Zpg4Jg8klCNO1aAFSFHBY2kgxc+qatv9s=
  -----END CERTIFICATE-----
  === /C=US/O=AffirmTrust/CN=AffirmTrust Premium
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 7893706540734352110 (0x6d8c1446b1a60aee)
      Signature Algorithm: sha384WithRSAEncryption
          Validity
              Not Before: Jan 29 14:10:36 2010 GMT
              Not After : Dec 31 14:10:36 2040 GMT
          Subject: C=US, O=AffirmTrust, CN=AffirmTrust Premium
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  9D:C0:67:A6:0C:22:D9:26:F5:45:AB:A6:65:52:11:27:D8:45:AC:63
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
  SHA1 Fingerprint=D8:A6:33:2C:E0:03:6F:B1:85:F6:63:4F:7D:6A:06:65:26:32:28:27
  SHA256 Fingerprint=70:A7:3F:7F:37:6B:60:07:42:48:90:45:34:B1:14:82:D5:BF:0E:69:8E:CC:49:8D:F5:25:77:EB:F2:E9:3B:9A
  -----BEGIN CERTIFICATE-----
  MIIFRjCCAy6gAwIBAgIIbYwURrGmCu4wDQYJKoZIhvcNAQEMBQAwQTELMAkGA1UE
  BhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MRwwGgYDVQQDDBNBZmZpcm1UcnVz
  dCBQcmVtaXVtMB4XDTEwMDEyOTE0MTAzNloXDTQwMTIzMTE0MTAzNlowQTELMAkG
  A1UEBhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MRwwGgYDVQQDDBNBZmZpcm1U
  cnVzdCBQcmVtaXVtMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAxBLf
  qV/+Qd3d9Z+K4/as4Tx4mrzY8H96oDMq3I0gW64tb+eT2TZwamjPjlGjhVtnBKAQ
  JG9dKILBl1fYSCkTtuG+kU3fhQxTGJoeJKJPj/CihQvL9Cl/0qRY7iZNyaqoe5rZ
  +jjeRFcV5fiMyNlI4g0WJx0eyIOFJbe6qlVBzAMiSy2RjYvmia9mx+n/K+k8rNrS
  s8PhaJyJ+HoAVt70VZVs+7pk3WKL3wt3MutizCaam7uqYoNMtAZ6MMgpv+0GTZe5
  HMQxK9VfvFMSF5yZVylmd2EhMQcuJUmdGPLu8ytxjLW6OQdJd/zvLpKQBY0tL3d7
  70O/Nbua2Plzpyzy0FfuKE4mX4+QaAkvuPjcBukumj5Rp9EixAqnOEhss/n/fauG
  V+O61oV4d7pD6kh/9ti+I20ev9E2bFhc8e6kGVQa9QPSdubhjL08s9NIS+LI+H+S
  qHZGnEJlPqQewQcDWkYtuJfzt9WyVSHvutxMAJf7FJUnM7/oQ0dG0giZFmA7mn7S
  5u046uwBHjxIVkkJx0w3AJ6IDsBz4W9m6XJHMD4Q5QsDyZpCAGzFlH5hxIrff4Ia
  C1nEWTJ3s7xgaVY5/bQGeyzWZDbZvUjthB9+pSKPKrhC9IK31FOQeE4tGv2Bb0TX
  OwF0lkLgAOIua+rF7nKsu7/+6qqo+Nz2snmKtmcCAwEAAaNCMEAwHQYDVR0OBBYE
  FJ3AZ6YMItkm9UWrpmVSESfYRaxjMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/
  BAQDAgEGMA0GCSqGSIb3DQEBDAUAA4ICAQCzV00QYk465KzquByvMiPIs0laUZx2
  KI15qldGF9X1Uva3ROgIRL8YhNILgM3FEv0AVQVhh0HctSSePMTYyPtwni94loMg
  Nt58D2kTiKV1NpgIpsbfrM7jWNa3Pt668+s0QNiigfV4Py/VpfzZotReBA4Xrf5B
  8OWycvpEgjNC6C1Y91aMYj+6QrCcDFx+LmUmXFNPALJ4fqENmS2NuB2OosSw/WDQ
  MKSOyARiqcTtNd56l+0OOF6SL5Nwpamcb6d9Ex1+xghIsV5n61EIJenmJWtSKZGc
  0jlzCFfemQa0W50QBuHCAKi4HEoCChTQwUHK+4w1IX2COPKpVJEZNZOUbWo6xbLQ
  u4mGk+ibyQ86p3q4ofB4Rvr8Ny/lioTz3/4E2aFooC8k4gmVBtWVyuEklut89pMF
  u+1z6S3RdTnX5yTb2E5fQ4+e0BQ5v1VwSJlXMbSc7kqYA5YwH2AG7hsj/oFgIxpH
  YoWlzBk0gG+zrBrjn/B7SK3VAdlntqlyk+otZrWyuOQ9PLLvTIzq6we/qzWaVYa8
  GKa1qF60g2xraUDTn9zxw2lrueFtCfTxqlB2Cnp9ehehVZZCmTEJ3WARjQUwfuaO
  RtGdFNrHF+QFlozEJLUbzxQHskD4o55BhrwE0GuWyCqANP2/7waj3VjFhT0+j/6e
  KeC2uAloGRwYQw==
  -----END CERTIFICATE-----
  === /C=US/O=AffirmTrust/CN=AffirmTrust Premium ECC
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 8401224907861490260 (0x7497258ac73f7a54)
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Jan 29 14:20:24 2010 GMT
              Not After : Dec 31 14:20:24 2040 GMT
          Subject: C=US, O=AffirmTrust, CN=AffirmTrust Premium ECC
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  9A:AF:29:7A:C0:11:35:35:26:51:30:00:C3:6A:FE:40:D5:AE:D6:3C
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
  SHA1 Fingerprint=B8:23:6B:00:2F:1D:16:86:53:01:55:6C:11:A4:37:CA:EB:FF:C3:BB
  SHA256 Fingerprint=BD:71:FD:F6:DA:97:E4:CF:62:D1:64:7A:DD:25:81:B0:7D:79:AD:F8:39:7E:B4:EC:BA:9C:5E:84:88:82:14:23
  -----BEGIN CERTIFICATE-----
  MIIB/jCCAYWgAwIBAgIIdJclisc/elQwCgYIKoZIzj0EAwMwRTELMAkGA1UEBhMC
  VVMxFDASBgNVBAoMC0FmZmlybVRydXN0MSAwHgYDVQQDDBdBZmZpcm1UcnVzdCBQ
  cmVtaXVtIEVDQzAeFw0xMDAxMjkxNDIwMjRaFw00MDEyMzExNDIwMjRaMEUxCzAJ
  BgNVBAYTAlVTMRQwEgYDVQQKDAtBZmZpcm1UcnVzdDEgMB4GA1UEAwwXQWZmaXJt
  VHJ1c3QgUHJlbWl1bSBFQ0MwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQNMF4bFZ0D
  0KF5Nbc6PJJ6yhUczWLznCZcBz3lVPqj1swS6vQUX+iOGasvLkjmrBhDeKzQN8O9
  ss0s5kfiGuZjuD0uL3jET9v0D6RoTFVya5UdThhClXjMNzyR4ptlKymjQjBAMB0G
  A1UdDgQWBBSaryl6wBE1NSZRMADDav5A1a7WPDAPBgNVHRMBAf8EBTADAQH/MA4G
  A1UdDwEB/wQEAwIBBjAKBggqhkjOPQQDAwNnADBkAjAXCfOHiFBar8jAQr9HX/Vs
  aobgxCd05DhT1wV/GzTjxi+zygk8N53X57hG8f2h4nECMEJZh0PUUd+60wkyWs6I
  flc9nF9Ca/UHLbXwgpP5WW+uZPpY5Yse42O+tYHNbwKMeQ==
  -----END CERTIFICATE-----

  ### Agencia Catalana de Certificacio (NIF Q-0801176-I)

  === /C=ES/O=Agencia Catalana de Certificacio (NIF Q-0801176-I)/OU=Serveis Publics de Certificacio/OU=Vegeu https://www.catcert.net/verarrel (c)03/OU=Jerarquia Entitats de Certificacio Catalanes/CN=EC-ACC
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
               (Negative)11:d4:c2:14:2b:de:21:eb:57:9d:53:fb:0c:22:3b:ff
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Jan  7 23:00:00 2003 GMT
              Not After : Jan  7 22:59:59 2031 GMT
          Subject: C=ES, O=Agencia Catalana de Certificacio (NIF Q-0801176-I), OU=Serveis Publics de Certificacio, OU=Vegeu https://www.catcert.net/verarrel (c)03, OU=Jerarquia Entitats de Certificacio Catalanes, CN=EC-ACC
          X509v3 extensions:
              X509v3 Subject Alternative Name:
                  email:ec_acc@catcert.net
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  A0:C3:8B:44:AA:37:A5:45:BF:97:80:5A:D1:F1:78:A2:9B:E9:5D:8D
              X509v3 Certificate Policies:
                  Policy: 1.3.6.1.4.1.15096.1.3.1.10
                    CPS: https://www.catcert.net/verarrel
                    User Notice:
                      Explicit Text: Vegeu https://www.catcert.net/verarrel

  SHA1 Fingerprint=28:90:3A:63:5B:52:80:FA:E6:77:4C:0B:6D:A7:D6:BA:A6:4A:F2:E8
  SHA256 Fingerprint=88:49:7F:01:60:2F:31:54:24:6A:E2:8C:4D:5A:EF:10:F1:D8:7E:BB:76:62:6F:4A:E0:B7:F9:5B:A7:96:87:99
  -----BEGIN CERTIFICATE-----
  MIIFVjCCBD6gAwIBAgIQ7is969Qh3hSoYqwE893EATANBgkqhkiG9w0BAQUFADCB
  8zELMAkGA1UEBhMCRVMxOzA5BgNVBAoTMkFnZW5jaWEgQ2F0YWxhbmEgZGUgQ2Vy
  dGlmaWNhY2lvIChOSUYgUS0wODAxMTc2LUkpMSgwJgYDVQQLEx9TZXJ2ZWlzIFB1
  YmxpY3MgZGUgQ2VydGlmaWNhY2lvMTUwMwYDVQQLEyxWZWdldSBodHRwczovL3d3
  dy5jYXRjZXJ0Lm5ldC92ZXJhcnJlbCAoYykwMzE1MDMGA1UECxMsSmVyYXJxdWlh
  IEVudGl0YXRzIGRlIENlcnRpZmljYWNpbyBDYXRhbGFuZXMxDzANBgNVBAMTBkVD
  LUFDQzAeFw0wMzAxMDcyMzAwMDBaFw0zMTAxMDcyMjU5NTlaMIHzMQswCQYDVQQG
  EwJFUzE7MDkGA1UEChMyQWdlbmNpYSBDYXRhbGFuYSBkZSBDZXJ0aWZpY2FjaW8g
  KE5JRiBRLTA4MDExNzYtSSkxKDAmBgNVBAsTH1NlcnZlaXMgUHVibGljcyBkZSBD
  ZXJ0aWZpY2FjaW8xNTAzBgNVBAsTLFZlZ2V1IGh0dHBzOi8vd3d3LmNhdGNlcnQu
  bmV0L3ZlcmFycmVsIChjKTAzMTUwMwYDVQQLEyxKZXJhcnF1aWEgRW50aXRhdHMg
  ZGUgQ2VydGlmaWNhY2lvIENhdGFsYW5lczEPMA0GA1UEAxMGRUMtQUNDMIIBIjAN
  BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsyLHT+KXQpWIR4NA9h0X84NzJB5R
  85iKw5K4/0CQBXCHYMkAqbWUZRkiFRfCQ2xmRJoNBD45b6VLeqpjt4pEndljkYRm
  4CgPukLjbo73FCeTae6RDqNfDrHrZqJyTxIThmV6PttPB/SnCWDaOkKZx7J/sxaV
  HMf5NLWUhdWZXqBIoH7nF2W4onW4HvPlQn2v7fOKSGRdghST2MDk/7NQcvJ29rNd
  QlB50JQ+awwAvthrDk4q7D7SzIKiGGUzE3eeml0aE9jD2z3Il3rucO2n5nzbcc8t
  lGLfbdb1OL4/pYUKGbio2Al1QnDE6u/LDsg0qBIimAy4E5S2S+zw0JDnJwIDAQAB
  o4HjMIHgMB0GA1UdEQQWMBSBEmVjX2FjY0BjYXRjZXJ0Lm5ldDAPBgNVHRMBAf8E
  BTADAQH/MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUoMOLRKo3pUW/l4Ba0fF4
  opvpXY0wfwYDVR0gBHgwdjB0BgsrBgEEAfV4AQMBCjBlMCwGCCsGAQUFBwIBFiBo
  dHRwczovL3d3dy5jYXRjZXJ0Lm5ldC92ZXJhcnJlbDA1BggrBgEFBQcCAjApGidW
  ZWdldSBodHRwczovL3d3dy5jYXRjZXJ0Lm5ldC92ZXJhcnJlbCAwDQYJKoZIhvcN
  AQEFBQADggEBAKBIW4IB9k1IuDlVNZyAelOZ1Vr/sXE7zDkJlF7W2u++AVtd0x7Y
  /X1PzaBB4DSTv8vihpw3kpBWHNzrKQXlxJ7HNd+KDM3FIUPpqojlNcAZQmNaAl6k
  SBg6hW/cnbw/nZzBh7h6YQjpdwt/cKt63dmXLGQehb+8dJahw3oS7AwaboMMPOhy
  Rp/7SNVel+axofjk70YllJyJ22k4vuxcDlbHZVHlUIiIv0LVKz3l+bqeLrPK9HOS
  Agu+TGbrIP65y7WZf+a2E/rKS03Z7lNGBjvGTq2TWoF+bCpLagVFjPIhpDGQh2xl
  nJ2lYJU6Un/10asIbvPuW/mIPX64b24D5EI=
  -----END CERTIFICATE-----

  ### Amazon

  === /C=US/O=Amazon/CN=Amazon Root CA 1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              06:6c:9f:cf:99:bf:8c:0a:39:e2:f0:78:8a:43:e6:96:36:5b:ca
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: May 26 00:00:00 2015 GMT
              Not After : Jan 17 00:00:00 2038 GMT
          Subject: C=US, O=Amazon, CN=Amazon Root CA 1
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  84:18:CC:85:34:EC:BC:0C:94:94:2E:08:59:9C:C7:B2:10:4E:0A:08
  SHA1 Fingerprint=8D:A7:F9:65:EC:5E:FC:37:91:0F:1C:6E:59:FD:C1:CC:6A:6E:DE:16
  SHA256 Fingerprint=8E:CD:E6:88:4F:3D:87:B1:12:5B:A3:1A:C3:FC:B1:3D:70:16:DE:7F:57:CC:90:4F:E1:CB:97:C6:AE:98:19:6E
  -----BEGIN CERTIFICATE-----
  MIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF
  ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6
  b24gUm9vdCBDQSAxMB4XDTE1MDUyNjAwMDAwMFoXDTM4MDExNzAwMDAwMFowOTEL
  MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv
  b3QgQ0EgMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJ4gHHKeNXj
  ca9HgFB0fW7Y14h29Jlo91ghYPl0hAEvrAIthtOgQ3pOsqTQNroBvo3bSMgHFzZM
  9O6II8c+6zf1tRn4SWiw3te5djgdYZ6k/oI2peVKVuRF4fn9tBb6dNqcmzU5L/qw
  IFAGbHrQgLKm+a/sRxmPUDgH3KKHOVj4utWp+UhnMJbulHheb4mjUcAwhmahRWa6
  VOujw5H5SNz/0egwLX0tdHA114gk957EWW67c4cX8jJGKLhD+rcdqsq08p8kDi1L
  93FcXmn/6pUCyziKrlA4b9v7LWIbxcceVOF34GfID5yHI9Y/QCB/IIDEgEw+OyQm
  jgSubJrIqg0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC
  AYYwHQYDVR0OBBYEFIQYzIU07LwMlJQuCFmcx7IQTgoIMA0GCSqGSIb3DQEBCwUA
  A4IBAQCY8jdaQZChGsV2USggNiMOruYou6r4lK5IpDB/G/wkjUu0yKGX9rbxenDI
  U5PMCCjjmCXPI6T53iHTfIUJrU6adTrCC2qJeHZERxhlbI1Bjjt/msv0tadQ1wUs
  N+gDS63pYaACbvXy8MWy7Vu33PqUXHeeE6V/Uq2V8viTO96LXFvKWlJbYK8U90vv
  o/ufQJVtMVT8QtPHRh8jrdkPSHCa2XV4cdFyQzR1bldZwgJcJmApzyMZFo6IQ6XU
  5MsI+yMRQ+hDKXJioaldXgjUkK642M4UwtBV8ob2xJNDd2ZhwLnoQdeXeGADbkpy
  rqXRfboQnoZsG4q5WTP468SQvvG5
  -----END CERTIFICATE-----
  === /C=US/O=Amazon/CN=Amazon Root CA 2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              06:6c:9f:d2:96:35:86:9f:0a:0f:e5:86:78:f8:5b:26:bb:8a:37
      Signature Algorithm: sha384WithRSAEncryption
          Validity
              Not Before: May 26 00:00:00 2015 GMT
              Not After : May 26 00:00:00 2040 GMT
          Subject: C=US, O=Amazon, CN=Amazon Root CA 2
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  B0:0C:F0:4C:30:F4:05:58:02:48:FD:33:E5:52:AF:4B:84:E3:66:52
  SHA1 Fingerprint=5A:8C:EF:45:D7:A6:98:59:76:7A:8C:8B:44:96:B5:78:CF:47:4B:1A
  SHA256 Fingerprint=1B:A5:B2:AA:8C:65:40:1A:82:96:01:18:F8:0B:EC:4F:62:30:4D:83:CE:C4:71:3A:19:C3:9C:01:1E:A4:6D:B4
  -----BEGIN CERTIFICATE-----
  MIIFQTCCAymgAwIBAgITBmyf0pY1hp8KD+WGePhbJruKNzANBgkqhkiG9w0BAQwF
  ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6
  b24gUm9vdCBDQSAyMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTEL
  MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv
  b3QgQ0EgMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK2Wny2cSkxK
  gXlRmeyKy2tgURO8TW0G/LAIjd0ZEGrHJgw12MBvIITplLGbhQPDW9tK6Mj4kHbZ
  W0/jTOgGNk3Mmqw9DJArktQGGWCsN0R5hYGCrVo34A3MnaZMUnbqQ523BNFQ9lXg
  1dKmSYXpN+nKfq5clU1Imj+uIFptiJXZNLhSGkOQsL9sBbm2eLfq0OQ6PBJTYv9K
  8nu+NQWpEjTj82R0Yiw9AElaKP4yRLuH3WUnAnE72kr3H9rN9yFVkE8P7K6C4Z9r
  2UXTu/Bfh+08LDmG2j/e7HJV63mjrdvdfLC6HM783k81ds8P+HgfajZRRidhW+me
  z/CiVX18JYpvL7TFz4QuK/0NURBs+18bvBt+xa47mAExkv8LV/SasrlX6avvDXbR
  8O70zoan4G7ptGmh32n2M8ZpLpcTnqWHsFcQgTfJU7O7f/aS0ZzQGPSSbtqDT6Zj
  mUyl+17vIWR6IF9sZIUVyzfpYgwLKhbcAS4y2j5L9Z469hdAlO+ekQiG+r5jqFoz
  7Mt0Q5X5bGlSNscpb/xVA1wf+5+9R+vnSUeVC06JIglJ4PVhHvG/LopyboBZ/1c6
  +XUyo05f7O0oYtlNc/LMgRdg7c3r3NunysV+Ar3yVAhU/bQtCSwXVEqY0VThUWcI
  0u1ufm8/0i2BWSlmy5A5lREedCf+3euvAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB
  Af8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSwDPBMMPQFWAJI/TPlUq9LhONm
  UjANBgkqhkiG9w0BAQwFAAOCAgEAqqiAjw54o+Ci1M3m9Zh6O+oAA7CXDpO8Wqj2
  LIxyh6mx/H9z/WNxeKWHWc8w4Q0QshNabYL1auaAn6AFC2jkR2vHat+2/XcycuUY
  +gn0oJMsXdKMdYV2ZZAMA3m3MSNjrXiDCYZohMr/+c8mmpJ5581LxedhpxfL86kS
  k5Nrp+gvU5LEYFiwzAJRGFuFjWJZY7attN6a+yb3ACfAXVU3dJnJUH/jWS5E4ywl
  7uxMMne0nxrpS10gxdr9HIcWxkPo1LsmmkVwXqkLN1PiRnsn/eBG8om3zEK2yygm
  btmlyTrIQRNg91CMFa6ybRoVGld45pIq2WWQgj9sAq+uEjonljYE1x2igGOpm/Hl
  urR8FLBOybEfdF849lHqm/osohHUqS0nGkWxr7JOcQ3AWEbWaQbLU8uz/mtBzUF+
  fUwPfHJ5elnNXkoOrJupmHN5fLT0zLm4BwyydFy4x2+IoZCn9Kr5v2c69BoVYh63
  n749sSmvZ6ES8lgQGVMDMBu4Gon2nL2XA46jCfMdiyHxtN/kHNGfZQIG6lzWE7OE
  76KlXIx3KadowGuuQNKotOrN8I1LOJwZmhsoVLiJkO/KdYE+HvJkJMcYr07/R54H
  9jVlpNMKVv/1F2Rs76giJUmTtt8AF9pYfl3uxRuw0dFfIRDH+fO6AgonB8Xx1sfT
  4PsJYGw=
  -----END CERTIFICATE-----
  === /C=US/O=Amazon/CN=Amazon Root CA 3
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              06:6c:9f:d5:74:97:36:66:3f:3b:0b:9a:d9:e8:9e:76:03:f2:4a
      Signature Algorithm: ecdsa-with-SHA256
          Validity
              Not Before: May 26 00:00:00 2015 GMT
              Not After : May 26 00:00:00 2040 GMT
          Subject: C=US, O=Amazon, CN=Amazon Root CA 3
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  AB:B6:DB:D7:06:9E:37:AC:30:86:07:91:70:C7:9C:C4:19:B1:78:C0
  SHA1 Fingerprint=0D:44:DD:8C:3C:8C:1A:1A:58:75:64:81:E9:0F:2E:2A:FF:B3:D2:6E
  SHA256 Fingerprint=18:CE:6C:FE:7B:F1:4E:60:B2:E3:47:B8:DF:E8:68:CB:31:D0:2E:BB:3A:DA:27:15:69:F5:03:43:B4:6D:B3:A4
  -----BEGIN CERTIFICATE-----
  MIIBtjCCAVugAwIBAgITBmyf1XSXNmY/Owua2eiedgPySjAKBggqhkjOPQQDAjA5
  MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g
  Um9vdCBDQSAzMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG
  A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg
  Q0EgMzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCmXp8ZBf8ANm+gBG1bG8lKl
  ui2yEujSLtf6ycXYqm0fc4E7O5hrOXwzpcVOho6AF2hiRVd9RFgdszflZwjrZt6j
  QjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSr
  ttvXBp43rDCGB5Fwx5zEGbF4wDAKBggqhkjOPQQDAgNJADBGAiEA4IWSoxe3jfkr
  BqWTrBqYaGFy+uGh0PsceGCmQ5nFuMQCIQCcAu/xlJyzlvnrxir4tiz+OpAUFteM
  YyRIHN8wfdVoOw==
  -----END CERTIFICATE-----
  === /C=US/O=Amazon/CN=Amazon Root CA 4
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              06:6c:9f:d7:c1:bb:10:4c:29:43:e5:71:7b:7b:2c:c8:1a:c1:0e
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: May 26 00:00:00 2015 GMT
              Not After : May 26 00:00:00 2040 GMT
          Subject: C=US, O=Amazon, CN=Amazon Root CA 4
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  D3:EC:C7:3A:65:6E:CC:E1:DA:76:9A:56:FB:9C:F3:86:6D:57:E5:81
  SHA1 Fingerprint=F6:10:84:07:D6:F8:BB:67:98:0C:C2:E2:44:C2:EB:AE:1C:EF:63:BE
  SHA256 Fingerprint=E3:5D:28:41:9E:D0:20:25:CF:A6:90:38:CD:62:39:62:45:8D:A5:C6:95:FB:DE:A3:C2:2B:0B:FB:25:89:70:92
  -----BEGIN CERTIFICATE-----
  MIIB8jCCAXigAwIBAgITBmyf18G7EEwpQ+Vxe3ssyBrBDjAKBggqhkjOPQQDAzA5
  MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g
  Um9vdCBDQSA0MB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG
  A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg
  Q0EgNDB2MBAGByqGSM49AgEGBSuBBAAiA2IABNKrijdPo1MN/sGKe0uoe0ZLY7Bi
  9i0b2whxIdIA6GO9mif78DluXeo9pcmBqqNbIJhFXRbb/egQbeOc4OO9X4Ri83Bk
  M6DLJC9wuoihKqB1+IGuYgbEgds5bimwHvouXKNCMEAwDwYDVR0TAQH/BAUwAwEB
  /zAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYEFNPsxzplbszh2naaVvuc84ZtV+WB
  MAoGCCqGSM49BAMDA2gAMGUCMDqLIfG9fhGt0O9Yli/W651+kI0rz2ZVwyzjKKlw
  CkcO8DdZEv8tmZQoTipPNU0zWgIxAOp1AE47xDqUEpHJWEadIRNyp4iciuRMStuW
  1KyLa2tJElMzrdfkviT8tQp21KW8EA==
  -----END CERTIFICATE-----

  ### Atos

  === /CN=Atos TrustedRoot 2011/O=Atos/C=DE
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 6643877497813316402 (0x5c33cb622c5fb332)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jul  7 14:58:30 2011 GMT
              Not After : Dec 31 23:59:59 2030 GMT
          Subject: CN=Atos TrustedRoot 2011, O=Atos, C=DE
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  A7:A5:06:B1:2C:A6:09:60:EE:D1:97:E9:70:AE:BC:3B:19:6C:DB:21
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Authority Key Identifier:
                  keyid:A7:A5:06:B1:2C:A6:09:60:EE:D1:97:E9:70:AE:BC:3B:19:6C:DB:21

              X509v3 Certificate Policies:
                  Policy: 1.3.6.1.4.1.6189.3.4.1.1

              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
  SHA1 Fingerprint=2B:B1:F5:3E:55:0C:1D:C5:F1:D4:E6:B7:6A:46:4B:55:06:02:AC:21
  SHA256 Fingerprint=F3:56:BE:A2:44:B7:A9:1E:B3:5D:53:CA:9A:D7:86:4A:CE:01:8E:2D:35:D5:F8:F9:6D:DF:68:A6:F4:1A:A4:74
  -----BEGIN CERTIFICATE-----
  MIIDdzCCAl+gAwIBAgIIXDPLYixfszIwDQYJKoZIhvcNAQELBQAwPDEeMBwGA1UE
  AwwVQXRvcyBUcnVzdGVkUm9vdCAyMDExMQ0wCwYDVQQKDARBdG9zMQswCQYDVQQG
  EwJERTAeFw0xMTA3MDcxNDU4MzBaFw0zMDEyMzEyMzU5NTlaMDwxHjAcBgNVBAMM
  FUF0b3MgVHJ1c3RlZFJvb3QgMjAxMTENMAsGA1UECgwEQXRvczELMAkGA1UEBhMC
  REUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCVhTuXbyo7LjvPpvMp
  Nb7PGKw+qtn4TaA+Gke5vJrf8v7MPkfoepbCJI419KkM/IL9bcFyYie96mvr54rM
  VD6QUM+A1JX76LWC1BTFtqlVJVfbsVD2sGBkWXppzwO3bw2+yj5vdHLqqjAqc2K+
  SZFhyBH+DgMq92og3AIVDV4VavzjgsG1xZ1kCWyjWZgHJ8cblithdHFsQ/H3NYkQ
  4J7sVaE3IqKHBAUsR320HLliKWYoyrfhk/WklAOZuXCFteZI6o1Q/NnezG8HDt0L
  cp2AMBYHlT8oDv3FdU9T1nSatCQujgKRz3bFmx5VdJx4IbHwLfELn8LVlhgf8FQi
  eowHAgMBAAGjfTB7MB0GA1UdDgQWBBSnpQaxLKYJYO7Rl+lwrrw7GWzbITAPBgNV
  HRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFKelBrEspglg7tGX6XCuvDsZbNshMBgG
  A1UdIAQRMA8wDQYLKwYBBAGwLQMEAQEwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3
  DQEBCwUAA4IBAQAmdzTblEiGKkGdLD4GkGDEjKwLVLgfuXvTBznk+j57sj1O7Z8j
  vZfza1zv7v1Apt+hk6EKhqzvINB5Ab149xnYJDE0BAGmuhWawyfc2E8PzBhj/5kP
  DpFrdRbhIfzYJsdHt6bPWHJxfrrhTZVHO8mvbaG0weyJ9rQPOLXiZNwlz6bb65pc
  maHFCN795trV1lpFDMS3wrUU77QR/w4VtfX128a961qn8FYiqTxlVMYVqL2Gns2D
  lmh6cYGJ4Qvh6hEbaAjMaZ7snkGeRDImeuKHCnE96+RapNLbxc3G3mB/ufNPRJLv
  KrcYPqcZ2Qt9sTdBQrC6YB3y/gkRsPCHe6ed
  -----END CERTIFICATE-----

  ### Baltimore

  === /C=IE/O=Baltimore/OU=CyberTrust/CN=Baltimore CyberTrust Root
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 33554617 (0x20000b9)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: May 12 18:46:00 2000 GMT
              Not After : May 12 23:59:00 2025 GMT
          Subject: C=IE, O=Baltimore, OU=CyberTrust, CN=Baltimore CyberTrust Root
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  E5:9D:59:30:82:47:58:CC:AC:FA:08:54:36:86:7B:3A:B5:04:4D:F0
              X509v3 Basic Constraints: critical
                  CA:TRUE, pathlen:3
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
  SHA1 Fingerprint=D4:DE:20:D0:5E:66:FC:53:FE:1A:50:88:2C:78:DB:28:52:CA:E4:74
  SHA256 Fingerprint=16:AF:57:A9:F6:76:B0:AB:12:60:95:AA:5E:BA:DE:F2:2A:B3:11:19:D6:44:AC:95:CD:4B:93:DB:F3:F2:6A:EB
  -----BEGIN CERTIFICATE-----
  MIIDdzCCAl+gAwIBAgIEAgAAuTANBgkqhkiG9w0BAQUFADBaMQswCQYDVQQGEwJJ
  RTESMBAGA1UEChMJQmFsdGltb3JlMRMwEQYDVQQLEwpDeWJlclRydXN0MSIwIAYD
  VQQDExlCYWx0aW1vcmUgQ3liZXJUcnVzdCBSb290MB4XDTAwMDUxMjE4NDYwMFoX
  DTI1MDUxMjIzNTkwMFowWjELMAkGA1UEBhMCSUUxEjAQBgNVBAoTCUJhbHRpbW9y
  ZTETMBEGA1UECxMKQ3liZXJUcnVzdDEiMCAGA1UEAxMZQmFsdGltb3JlIEN5YmVy
  VHJ1c3QgUm9vdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKMEuyKr
  mD1X6CZymrV51Cni4eiVgLGw41uOKymaZN+hXe2wCQVt2yguzmKiYv60iNoS6zjr
  IZ3AQSsBUnuId9Mcj8e6uYi1agnnc+gRQKfRzMpijS3ljwumUNKoUMMo6vWrJYeK
  mpYcqWe4PwzV9/lSEy/CG9VwcPCPwBLKBsua4dnKM3p31vjsufFoREJIE9LAwqSu
  XmD+tqYF/LTdB1kC1FkYmGP1pWPgkAx9XbIGevOF6uvUA65ehD5f/xXtabz5OTZy
  dc93Uk3zyZAsuT3lySNTPx8kmCFcB5kpvcY67Oduhjprl3RjM71oGDHweI12v/ye
  jl0qhqdNkNwnGjkCAwEAAaNFMEMwHQYDVR0OBBYEFOWdWTCCR1jMrPoIVDaGezq1
  BE3wMBIGA1UdEwEB/wQIMAYBAf8CAQMwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3
  DQEBBQUAA4IBAQCFDF2O5G9RaEIFoN27TyclhAO992T9Ldcw46QQF+vaKSm2eT92
  9hkTI7gQCvlYpNRhcL0EYWoSihfVCr3FvDB81ukMJY2GQE/szKN+OMY3EU/t3Wgx
  jkzSswF07r51XgdIGn9w/xZchMB5hbgF/X++ZRGjD8ACtPhSNzkE1akxehi/oCr0
  Epn3o0WC4zxe9Z2etciefC7IpJ5OCBRLbf1wbWsaY71k5h+3zvDyny67G7fyUIhz
  ksLi4xaNmjICq44Y3ekQEe5+NauQrz4wlHrQMz2nZQ/1/I6eYs9HRCwBXbsdtTLS
  R9I4LtD+gdwyah617jzV/OeBHRnDJELqYzmp
  -----END CERTIFICATE-----

  ### Buypass AS-983163327

  === /C=NO/O=Buypass AS-983163327/CN=Buypass Class 2 Root CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 2 (0x2)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Oct 26 08:38:03 2010 GMT
              Not After : Oct 26 08:38:03 2040 GMT
          Subject: C=NO, O=Buypass AS-983163327, CN=Buypass Class 2 Root CA
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  C9:80:77:E0:62:92:82:F5:46:9C:F3:BA:F7:4C:C3:DE:B8:A3:AD:39
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
  SHA1 Fingerprint=49:0A:75:74:DE:87:0A:47:FE:58:EE:F6:C7:6B:EB:C6:0B:12:40:99
  SHA256 Fingerprint=9A:11:40:25:19:7C:5B:B9:5D:94:E6:3D:55:CD:43:79:08:47:B6:46:B2:3C:DF:11:AD:A4:A0:0E:FF:15:FB:48
  -----BEGIN CERTIFICATE-----
  MIIFWTCCA0GgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJOTzEd
  MBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxIDAeBgNVBAMMF0J1eXBhc3Mg
  Q2xhc3MgMiBSb290IENBMB4XDTEwMTAyNjA4MzgwM1oXDTQwMTAyNjA4MzgwM1ow
  TjELMAkGA1UEBhMCTk8xHTAbBgNVBAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MSAw
  HgYDVQQDDBdCdXlwYXNzIENsYXNzIDIgUm9vdCBDQTCCAiIwDQYJKoZIhvcNAQEB
  BQADggIPADCCAgoCggIBANfHXvfBB9R3+0Mh9PT1aeTuMgHbo4Yf5FkNuud1g1Lr
  6hxhFUi7HQfKjK6w3Jad6sNgkoaCKHOcVgb/S2TwDCo3SbXlzwx87vFKu3MwZfPV
  L4O2fuPn9Z6rYPnT8Z2SdIrkHJasW4DptfQxh6NR/Md+oW+OU3fUl8FVM5I+GC91
  1K2GScuVr1QGbNgGE41b/+EmGVnAJLqBcXmQRFBoJJRfuLMR8SlBYaNByyM21cHx
  MlAQTn/0hpPshNOOvEu/XAFOBz3cFIqUCqTqc/sLUegTBxj6DvEr0VQVfTzh97QZ
  QmdiXnfgolXsttlpF9U6r0TtSsWe5HonfOV116rLJeffawrbD02TTqigzXsu8lkB
  arcNuAeBfos4GzjmCleZPe4h6KP1DBbdi+w0jpwqHAAVF41og9JwnxgIzRFo1clr
  Us3ERo/ctfPYV3Me6ZQ5BL/T3jjetFPsaRyifsSP5BtwrfKi+fv3FmRmaZ9JUaLi
  FRhnBkp/1Wy1TbMz4GHrXb7pmA8y1x1LPC5aAVKRCfLf6o3YBkBjqhHk/sM3nhRS
  P/TizPJhk9H9Z2vXUq6/aKtAQ6BXNVN48FP4YUIHZMbXb5tMOA1jrGKvNouicwoN
  9SG9dKpN6nIDSdvHXx1iY8f93ZHsM+71bbRuMGjeyNYmsHVee7QHIJihdjK4TWxP
  AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFMmAd+BikoL1Rpzz
  uvdMw964o605MA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAU18h
  9bqwOlI5LJKwbADJ784g7wbylp7ppHR/ehb8t/W2+xUbP6umwHJdELFx7rxP462s
  A20ucS6vxOOto70MEae0/0qyexAQH6dXQbLArvQsWdZHEIjzIVEpMMpghq9Gqx3t
  OluwlN5E40EIosHsHdb9T7bWR9AUC8rmyrV7d35BH16Dx7aMOZawP5aBQW9gkOLo
  +fsicdl9sz1Gv7SEr5AcD48Saq/v7h56rgJKihcrdv6sVIkkLE8/trKnToyokZf7
  KcZ7XC25y2a2t6hbElGFtQl+Ynhw/qlqYLYdDnkM/crqJIByw5c/8nerQyIKx+u2
  DISCLIBrQYoIwOula9+ZEsuK1V6ADJHgJgg2SMX6OBE1/yWDLfJ6v9r9jv6ly0Us
  H8SIU653DtmadsWOLB2jutXsMq7Aqqz30XpN69QH4kj3Io6wpJ9qzo6ysmD0oyLQ
  I+uUWnpp3Q+/QFesa1lQ2aOZ4W7+jQF5JyMV3pKdewlNWudLSDBaGOYKbeaP4NK7
  5t98biGCwWg5TbSYWGZizEqQXsP6JwSxeRV0mcy+rSDeJmAc61ZRpqPq5KM/p/9h
  3PFaTWwyI0PurKju7koSCTxdccK+efrCh2gdC/1cacwG0Jp9VJkqyTkaGa9LKkPz
  Y11aWOIv4x3kqdbQCtCev9eBCfHJxyYNrJgWVqA=
  -----END CERTIFICATE-----
  === /C=NO/O=Buypass AS-983163327/CN=Buypass Class 3 Root CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 2 (0x2)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Oct 26 08:28:58 2010 GMT
              Not After : Oct 26 08:28:58 2040 GMT
          Subject: C=NO, O=Buypass AS-983163327, CN=Buypass Class 3 Root CA
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  47:B8:CD:FF:E5:6F:EE:F8:B2:EC:2F:4E:0E:F9:25:B0:8E:3C:6B:C3
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
  SHA1 Fingerprint=DA:FA:F7:FA:66:84:EC:06:8F:14:50:BD:C7:C2:81:A5:BC:A9:64:57
  SHA256 Fingerprint=ED:F7:EB:BC:A2:7A:2A:38:4D:38:7B:7D:40:10:C6:66:E2:ED:B4:84:3E:4C:29:B4:AE:1D:5B:93:32:E6:B2:4D
  -----BEGIN CERTIFICATE-----
  MIIFWTCCA0GgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJOTzEd
  MBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxIDAeBgNVBAMMF0J1eXBhc3Mg
  Q2xhc3MgMyBSb290IENBMB4XDTEwMTAyNjA4Mjg1OFoXDTQwMTAyNjA4Mjg1OFow
  TjELMAkGA1UEBhMCTk8xHTAbBgNVBAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MSAw
  HgYDVQQDDBdCdXlwYXNzIENsYXNzIDMgUm9vdCBDQTCCAiIwDQYJKoZIhvcNAQEB
  BQADggIPADCCAgoCggIBAKXaCpUWUOOV8l6ddjEGMnqb8RB2uACatVI2zSRHsJ8Y
  ZLya9vrVediQYkwiL944PdbgqOkcLNt4EemOaFEVcsfzM4fkoF0LXOBXByow9c3E
  N3coTRiR5r/VUv1xLXA+58bEiuPwKAv0dpihi4dVsjoT/Lc+JzeOIuOoTyrvYLs9
  tznDDgFHmV0ST9tD+leh7fmdvhFHJlsTmKtdFoqwNxxXnUX/iJY2v7vKB3tvh2PX
  0DJq1l1sDPGzbjniazEuOQAnFN44wOwZZoYS6J1yFhNkUsepNxz9gjDthBgd9K5c
  /3ATAOux9TN6S9ZV+AWNS2mw9bMoNlwUxFFzTWsL8TQH2xc519woe2v1n/MuwU8X
  KhDzzMro6/1rqy6any2CbgTUUgGTLT2G/H783+9CHaZr77kgxve9oKeV/afmiSTY
  zIw0bOIjL9kSGiG5VZFvC5F5GQytQIgLcOJ60g7YaEi7ghM5EFjp2CoHxhLbWNvS
  O1UQRwUVZ2J+GGOmRj8JDlQyXr8NYnon74Do29lLBlo3WiXQCBJ31G8JUJc9yB3D
  34xFMFbG02SrZvPAXpacw8Tvw3xrizp5f7NJzz3iiZ+gMEuFuZyUJHmPfWupRWgP
  K9Dx2hzLabjKSWJtyNBjYt1gD1iqj6G8BaVmos8bdrKEZLFMOVLAMLrwjEsCsLa3
  AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFEe4zf/lb+74suwv
  Tg75JbCOPGvDMA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAACAj
  QTUEkMJAYmDv4jVM1z+s4jSQuKFvdvoWFqRINyzpkMLyPPgKn9iB5btb2iUspKdV
  cSQy9sgL8rxq+JOssgfCX5/bzMiKqr5qb+FJEMwx14C7u8jYog5kV+qi9cKpMRXS
  IGrs/CIBKM+GuIAeqcwRpTzyFrNHnfzSgCHEy9BHcEGhyoMZCCxt8l13nIoUE9Q2
  HJLw5QY33KbmkJs4j1xrG0aGQ0JfPgEHU1RdZX33inOhmlRaHylDFCfChQ+1iHsa
  O5S3HWCntZznKWlXWpuTekMwGwPXYshApqr8ZORK15FTAaggiG6cX0S5y2CBNOxv
  033aSF/rtJC8LakcC6wc1aJoIIAE1vyxjy+7SjENSoYc6+I2KSb12tjE8nVhz36u
  dmNKekBlk4f4HoCMhuWG1o8O/FMsYOgWYRqiPkN7zTlgVGr18okmAWiDSKIz6MkE
  kbIRNBE+6tBDGR8Dk5AM/1E9V/RBbuHLoL7ryWPNbczk+DaqaJ3tvV2XcEQNtg41
  3OEMXbugUZTLfhbrES+jkkXITHHZvMmZUldGL1DPvTVp9D0VzgalLA8+9oG6lLvD
  u79leNKGef9JOxqDDPDeeOzI8k1MGt6CKfjBWtrt7uYnXuhF0J0cUahoq0Tj0Itq
  4/g7u9xN12TyUb7mqqta6THuBrxzvxNiCp/HuZc=
  -----END CERTIFICATE-----

  ### certSIGN

  === /C=RO/O=certSIGN/OU=certSIGN ROOT CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 35210227249154 (0x200605167002)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Jul  4 17:20:04 2006 GMT
              Not After : Jul  4 17:20:04 2031 GMT
          Subject: C=RO, O=certSIGN, OU=certSIGN ROOT CA
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Non Repudiation, Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  E0:8C:9B:DB:25:49:B3:F1:7C:86:D6:B2:42:87:0B:D0:6B:A0:D9:E4
  SHA1 Fingerprint=FA:B7:EE:36:97:26:62:FB:2D:B0:2A:F6:BF:03:FD:E8:7C:4B:2F:9B
  SHA256 Fingerprint=EA:A9:62:C4:FA:4A:6B:AF:EB:E4:15:19:6D:35:1C:CD:88:8D:4F:53:F3:FA:8A:E6:D7:C4:66:A9:4E:60:42:BB
  -----BEGIN CERTIFICATE-----
  MIIDODCCAiCgAwIBAgIGIAYFFnACMA0GCSqGSIb3DQEBBQUAMDsxCzAJBgNVBAYT
  AlJPMREwDwYDVQQKEwhjZXJ0U0lHTjEZMBcGA1UECxMQY2VydFNJR04gUk9PVCBD
  QTAeFw0wNjA3MDQxNzIwMDRaFw0zMTA3MDQxNzIwMDRaMDsxCzAJBgNVBAYTAlJP
  MREwDwYDVQQKEwhjZXJ0U0lHTjEZMBcGA1UECxMQY2VydFNJR04gUk9PVCBDQTCC
  ASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALczuX7IJUqOtdu0KBuqV5Do
  0SLTZLrTk+jUrIZhQGpgV2hUhE28alQCBf/fm5oqrl0Hj0rDKH/v+yv6efHHrfAQ
  UySQi2bJqIirr1qjAOm+ukbuW3N7LBeCgV5iLKECZbO9xSsAfsT8AzNXDe3i+s5d
  RdY4zTW2ssHQnIFKquSyAVwdj1+ZxLGt24gh65AIgoDzMKND5pCCrlUoSe1b16kQ
  OA7+j0xbm0bqQfWwCHTD0IgztnzXdN/chNFDDnU5oSVAKOp4yw4sLjmdjItuFhwv
  JoIQ4uNllAoEwF73XVv4EOLQunpL+943AAAaWyjj0pxzPjKHmKHJUS/X3qwzs08C
  AwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAcYwHQYDVR0O
  BBYEFOCMm9slSbPxfIbWskKHC9BroNnkMA0GCSqGSIb3DQEBBQUAA4IBAQA+0hyJ
  LjX8+HXd5n9liPRyTMks1zJO890ZeUe9jjtbkw9QSSQTaxQGcu8J06Gh40CEyecY
  MnQ8SG4Pn0vU9x7Tk4ZkVJdjclDVVc/6IJMCopvDI5NOFlV2oHB5bc0hH88vLbwZ
  44gx+FkagQnIl6Z0x2DEW8xXjrJ1/RsCCdtZb3KTafcxQdaIOL+Hsr0Wefmq5L6I
  Jd1hJyMctTEHBDa0GpC9oHRxUIltvBTjD4au8as+x6AJzKNI0eDbZOeStc+vckNw
  i/nDhDwTqn6Sm1dTk/pwwpEOMfmbZ13pljheX7NzTogVZ96edhBiIL5VaZVDADlN
  9u6wWk5JRFRYX0KD
  -----END CERTIFICATE-----

  ### CERTSIGN SA

  === /C=RO/O=CERTSIGN SA/OU=certSIGN ROOT CA G2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              11:00:34:b6:4e:c6:36:2d:36
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Feb  6 09:27:35 2017 GMT
              Not After : Feb  6 09:27:35 2042 GMT
          Subject: C=RO, O=CERTSIGN SA, OU=certSIGN ROOT CA G2
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  82:21:2D:66:C6:D7:A0:E0:15:EB:CE:4C:09:77:C4:60:9E:54:6E:03
  SHA1 Fingerprint=26:F9:93:B4:ED:3D:28:27:B0:B9:4B:A7:E9:15:1D:A3:8D:92:E5:32
  SHA256 Fingerprint=65:7C:FE:2F:A7:3F:AA:38:46:25:71:F3:32:A2:36:3A:46:FC:E7:02:09:51:71:07:02:CD:FB:B6:EE:DA:33:05
  -----BEGIN CERTIFICATE-----
  MIIFRzCCAy+gAwIBAgIJEQA0tk7GNi02MA0GCSqGSIb3DQEBCwUAMEExCzAJBgNV
  BAYTAlJPMRQwEgYDVQQKEwtDRVJUU0lHTiBTQTEcMBoGA1UECxMTY2VydFNJR04g
  Uk9PVCBDQSBHMjAeFw0xNzAyMDYwOTI3MzVaFw00MjAyMDYwOTI3MzVaMEExCzAJ
  BgNVBAYTAlJPMRQwEgYDVQQKEwtDRVJUU0lHTiBTQTEcMBoGA1UECxMTY2VydFNJ
  R04gUk9PVCBDQSBHMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMDF
  dRmRfUR0dIf+DjuW3NgBFszuY5HnC2/OOwppGnzC46+CjobXXo9X69MhWf05N0Iw
  vlDqtg+piNguLWkh59E3GE59kdUWX2tbAMI5Qw02hVK5U2UPHULlj88F0+7cDBrZ
  uIt4ImfkabBoxTzkbFpG583H+u/E7Eu9aqSs/cwoUe+StCmrqzWaTOTECMYmzPhp
  n+Sc8CnTXPnGFiWeI8MgwT0PPzhAsP6CRDiqWhqKa2NYOLQV07YRaXseVO6MGiKs
  cpc/I1mbySKEwQdPzH/iV8oScLumZfNpdWO9lfsbl83kqK/20U6o2YpxJM02PbyW
  xPFsqa7lzw1uKA2wDrXKUXt4FMMgL3/7FFXhEZn91QqhngLjYl/rNUssuHLoPj1P
  rCy7Lobio3aP5ZMqz6WryFyNSwb/EkaseMsUBzXgqd+L6a8VTxaJW732jcZZroiF
  DsGJ6x9nxUWO/203Nit4ZoORUSs9/1F3dmKh7Gc+PoGD4FapUB8fepmrY7+EF3fx
  DTvf95xhszWYijqy7DwaNz9+j5LP2RIUZNoQAhVB/0/E6xyjyfqZ90bp4RjZsbgy
  LcsUDFDYg2WD7rlcz8sFWkz6GZdr1l0T08JcVLwyc6B49fFtHsufpaafItzRUZ6C
  eWRgKRM+o/1Pcmqr4tTluCRVLERLiohEnMqE0yo7AgMBAAGjQjBAMA8GA1UdEwEB
  /wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBSCIS1mxteg4BXrzkwJ
  d8RgnlRuAzANBgkqhkiG9w0BAQsFAAOCAgEAYN4auOfyYILVAzOBywaK8SJJ6ejq
  kX/GM15oGQOGO0MBzwdw5AgeZYWR5hEit/UCI46uuR59H35s5r0l1ZUa8gWmr4UC
  b6741jH/JclKyMeKqdmfS0mbEVeZkkMR3rYzpMzXjWR91M08KCy0mpbqTfXERMQl
  qiCA2ClV9+BB/AYm/7k29UMUA2Z44RGx2iBfRgB4ACGlHgAoYXhvqAEBj500mv/0
  OJD7uNGzcgbJceaBxXntC6Z58hMLnPddDnskk7RI24Zf3lCGeOdA5jGokHZwYa+c
  NywRtYK3qq4kNFtyDGkNzVmf9nGvnAvRCjj5BiKDUyUM/FHE5r7iOZULJK2v0ZXk
  ltd0ZGtxTgI8qoXzIKNDOXZbbFD+mpwUHmUUihW9o4JFWklWatKcsWMy5WHgUyIO
  pwpJ6st+H6jiYoD2EEVSmAYY3qXNL3+q1Ok+CHLsIwMCPKaq2LxndD0UF/tUSxfj
  03k9bWtJySgOLnRQvwzZRjoQhsmnP+mg7H/rpXdYaXHmgwo38oZJar55CJD2AhZk
  PuXaTH4MNMn5X7azKFGnpyuqSfqNZSlO42sTp5SjLVFteAxEy9/eCG/Oo2Sr05WE
  1LlSVHJ7liXMvGnjSG4N0MedJ5qq+BOS3R7fY581qRY27Iy4g/Q9iY/NtBde17MX
  QRBdJ3NghVdJIgc=
  -----END CERTIFICATE-----

  ### China Financial Certification Authority

  === /C=CN/O=China Financial Certification Authority/CN=CFCA EV ROOT
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 407555286 (0x184accd6)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Aug  8 03:07:01 2012 GMT
              Not After : Dec 31 03:07:01 2029 GMT
          Subject: C=CN, O=China Financial Certification Authority, CN=CFCA EV ROOT
          X509v3 extensions:
              X509v3 Authority Key Identifier:
                  keyid:E3:FE:2D:FD:28:D0:0B:B5:BA:B6:A2:C4:BF:06:AA:05:8C:93:FB:2F

              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  E3:FE:2D:FD:28:D0:0B:B5:BA:B6:A2:C4:BF:06:AA:05:8C:93:FB:2F
  SHA1 Fingerprint=E2:B8:29:4B:55:84:AB:6B:58:C2:90:46:6C:AC:3F:B8:39:8F:84:83
  SHA256 Fingerprint=5C:C3:D7:8E:4E:1D:5E:45:54:7A:04:E6:87:3E:64:F9:0C:F9:53:6D:1C:CC:2E:F8:00:F3:55:C4:C5:FD:70:FD
  -----BEGIN CERTIFICATE-----
  MIIFjTCCA3WgAwIBAgIEGErM1jANBgkqhkiG9w0BAQsFADBWMQswCQYDVQQGEwJD
  TjEwMC4GA1UECgwnQ2hpbmEgRmluYW5jaWFsIENlcnRpZmljYXRpb24gQXV0aG9y
  aXR5MRUwEwYDVQQDDAxDRkNBIEVWIFJPT1QwHhcNMTIwODA4MDMwNzAxWhcNMjkx
  MjMxMDMwNzAxWjBWMQswCQYDVQQGEwJDTjEwMC4GA1UECgwnQ2hpbmEgRmluYW5j
  aWFsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MRUwEwYDVQQDDAxDRkNBIEVWIFJP
  T1QwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDXXWvNED8fBVnVBU03
  sQ7smCuOFR36k0sXgiFxEFLXUWRwFsJVaU2OFW2fvwwbwuCjZ9YMrM8irq93VCpL
  TIpTUnrD7i7es3ElweldPe6hL6P3KjzJIx1qqx2hp/Hz7KDVRM8Vz3IvHWOX6Jn5
  /ZOkVIBMUtRSqy5J35DNuF++P96hyk0g1CXohClTt7GIH//62pCfCqktQT+x8Rgp
  7hZZLDRJGqgG16iI0gNyejLi6mhNbiyWZXvKWfry4t3uMCz7zEasxGPrb382KzRz
  EpR/38wmnvFyXVBlWY9ps4deMm/DGIq1lY+wejfeWkU7xzbh72fROdOXW3NiGUgt
  hxwG+3SYIElz8AXSG7Ggo7cbcNOIabla1jj0Ytwli3i/+Oh+uFzJlU9fpy25IGvP
  a931DfSCt/SyZi4QKPaXWnuWFo8BGS1sbn85WAZkgwGDg8NNkt0yxoekN+kWzqot
  aK8KgWU6cMGbrU1tVMoqLUuFG7OA5nBFDWteNfB/O7ic5ARwiRIlk9oKmSJgamNg
  TnYGmE69g60dWIolhdLHZR4tjsbftsbhf4oEIRUpdPA+nJCdDC7xij5aqgwJHsfV
  PKPtl8MeNPo4+QgO48BdK4PRVmrJtqhUUy54Mmc9gn900PvhtgVguXDbjgv5E1hv
  cWAQUhC5wUEJ73IfZzF4/5YFjQIDAQABo2MwYTAfBgNVHSMEGDAWgBTj/i39KNAL
  tbq2osS/BqoFjJP7LzAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAd
  BgNVHQ4EFgQU4/4t/SjQC7W6tqLEvwaqBYyT+y8wDQYJKoZIhvcNAQELBQADggIB
  ACXGumvrh8vegjmWPfBEp2uEcwPenStPuiB/vHiyz5ewG5zz13ku9Ui20vsXiObT
  ej/tUxPQ4i9qecsAIyjmHjdXNYmEwnZPNDatZ8POQQaIxffu2Bq41gt/UP+TqhdL
  jOztUmCypAbqTuv0axn96/Ua4CUqmtzHQTb3yHQFhDmVOdYLO6Qn+gjYXB74BGBS
  ESgoA//vU2YApUo0FmZ8/Qmkrp5nGm9BC2sGE5uPhnEFtC+NiWYzKXZUmhH4J/qy
  P5Hgzg0b8zAarb8iXRvTvyUFTeGSGn+ZnzxEk8rUQElsgIfXBDrDMlI1Dlb4pd19
  xIsNER9Tyx6yF7Zod1rg1MvIB671Oi6ON7fQAUtDKXeMOZePglr4UeWJoBjnaH9d
  Ci77o0cOPaYjesYBx4/IXr9tgFa+iiS6M+qf4TIRnvHST4D2G0CvOJ4RUHlzEhLN
  5mydLIhyPDCBBpEi6lmt2hkuIsKNuYyH4Ga8cyNfIWRjgEj1oDwYPZTISEEdQLpe
  /v5WOaHIz16eGWRGENoXkbcFgKyLmZJ956LYBws2J+dIeWCKw9cTXPhyQN9Ky8+Z
  AAoACxGV2lZFA4gKn2fQ1XmxqI1AbQ3CekD6819kR5LLU7m7Wc5P/dAVUwHY3+vZ
  5nbv0CO7O6l5s9UCKc2Jo5YPSjXnTkLAdc0Hz+Ys63su
  -----END CERTIFICATE-----

  ### Chunghwa Telecom Co., Ltd.

  === /C=TW/O=Chunghwa Telecom Co., Ltd./OU=ePKI Root Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              15:c8:bd:65:47:5c:af:b8:97:00:5e:e4:06:d2:bc:9d
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Dec 20 02:31:27 2004 GMT
              Not After : Dec 20 02:31:27 2034 GMT
          Subject: C=TW, O=Chunghwa Telecom Co., Ltd., OU=ePKI Root Certification Authority
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  1E:0C:F7:B6:67:F2:E1:92:26:09:45:C0:55:39:2E:77:3F:42:4A:A2
              X509v3 Basic Constraints:
                  CA:TRUE
              setCext-hashedRoot:
                  0/0-...0...+......0...g*.....E...
  V|.[x....S.....
  SHA1 Fingerprint=67:65:0D:F1:7E:8E:7E:5B:82:40:A4:F4:56:4B:CF:E2:3D:69:C6:F0
  SHA256 Fingerprint=C0:A6:F4:DC:63:A2:4B:FD:CF:54:EF:2A:6A:08:2A:0A:72:DE:35:80:3E:2F:F5:FF:52:7A:E5:D8:72:06:DF:D5
  -----BEGIN CERTIFICATE-----
  MIIFsDCCA5igAwIBAgIQFci9ZUdcr7iXAF7kBtK8nTANBgkqhkiG9w0BAQUFADBe
  MQswCQYDVQQGEwJUVzEjMCEGA1UECgwaQ2h1bmdod2EgVGVsZWNvbSBDby4sIEx0
  ZC4xKjAoBgNVBAsMIWVQS0kgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAe
  Fw0wNDEyMjAwMjMxMjdaFw0zNDEyMjAwMjMxMjdaMF4xCzAJBgNVBAYTAlRXMSMw
  IQYDVQQKDBpDaHVuZ2h3YSBUZWxlY29tIENvLiwgTHRkLjEqMCgGA1UECwwhZVBL
  SSBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIICIjANBgkqhkiG9w0BAQEF
  AAOCAg8AMIICCgKCAgEA4SUP7o3biDN1Z82tH306Tm2d0y8U82N0ywEhajfqhFAH
  SyZbCUNsIZ5qyNUD9WBpj8zwIuQf5/dqIjG3LBXy4P4AakP/h2XGtRrBp0xtInAh
  ijHyl3SJCRImHJ7K2RKilTza6We/CKBk49ZCt0Xvl/T29de1ShUCWH2YWEtgvM3X
  DZoTM1PRYfl61dd4s5oz9wCGzh1NlDivqOx4UXCKXBCDUSH3ET00hl7lSM2XgYI1
  TBnsZfZrxQWh7kcT1rMhJ5QQCtkkO7q+RBNGMD+XPNjX12ruOzjjK9SXDrkb5wdJ
  fzcq+Xd4z1TtW0ado4AOkUPB1ltfFLqfpo0kR0BZv3I4sjZsN/+Z0V0OWQqraffA
  sgRFelQArr5T9rXn4fg8ozHSqf4hUmTFpmfwdQcGlBSBVcYn5AGPF8Fqcde+S/uU
  WH1+ETOxQvdibBjWzwloPn9s9h6PYq2lY9sJpx8iQkEeb5mKPtf5P0B6ebClAZLS
  nT0IFaUQAS2zMnaolQ2zepr7BxB4EW/hj8e6DyUadCrlHJhBmd8hh+iVBmoKs2pH
  dmX2Os+PYhcZewoozRrSgx4hxyy/vv9haLdnG7t4TY3OZ+XkwY63I2binZB1NJip
  NiuKmpS5nezMirH4JYlcWrYvjB9teSSnUmjDhDXiZo1jDiVN1Rmy5nk3pyKdVDEC
  AwEAAaNqMGgwHQYDVR0OBBYEFB4M97Zn8uGSJglFwFU5Lnc/QkqiMAwGA1UdEwQF
  MAMBAf8wOQYEZyoHAAQxMC8wLQIBADAJBgUrDgMCGgUAMAcGBWcqAwAABBRFsMLH
  ClZ87lt4DJX5GFPBphzYEDANBgkqhkiG9w0BAQUFAAOCAgEACbODU1kBPpVJufGB
  uvl2ICO1J2B01GqZNF5sAFPZn/KmsSQHRGoqxqWOeBLoR9lYGxMqXnmbnwoqZ6Yl
  PwZpVnPDimZI+ymBV3QGypzqKOg4ZyYr8dW1P2WT+DZdjo2NQCCHGervJ8A9tDkP
  JXtoUHRVnAxZfVo9QZQlUgjgRywVMRnVvwdVxrsStZf0X4OFunHB2WyBEXYKCrC/
  gpf36j36+uwtqSiUO1bd0lEursC9CBWMd1I0ltabrNMdjmEPNXubrjlpC2JgQCA2
  j6/7Nu4tCEoduL+bXPjqpRugc6bY+G7gMwRfaKonh+3ZwZCc7b3jajWvY9+rGNm6
  5ulK6lCKD2GTHuItGeIwlDWSXQ62B68ZgI9HkFFLLk3dheLSClIKF5r8GrBQAuUB
  o2M3IUxExJtRmREOc5wGj1QupyheRDmHVi03vYVElOEMSyycw5KFNGHLD7ibSkNS
  /jQ6fbjpKdx2qcgw+BRxgMYeNkh0IkFch4LoGHGLQYlE535YW6i4jRPpp2zDR+2z
  Gp1iro2C6pSe3VkQw63d4k3jMdXH7OjysP6SHhYKGvzZ8/gntsm+HbRsZJB/9OTE
  W9c3rkIO3aQab3yIVMUWbuF6aC74Or8NpDyJO3inTmODBCEIZ43ygknQW/2xzQ+D
  hNQ+IIX3Sj0rnP0qCglN6oH4EZw=
  -----END CERTIFICATE-----

  ### Comodo CA Limited

  === /C=GB/ST=Greater Manchester/L=Salford/O=Comodo CA Limited/CN=AAA Certificate Services
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 1 (0x1)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Jan  1 00:00:00 2004 GMT
              Not After : Dec 31 23:59:59 2028 GMT
          Subject: C=GB, ST=Greater Manchester, L=Salford, O=Comodo CA Limited, CN=AAA Certificate Services
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  A0:11:0A:23:3E:96:F1:07:EC:E2:AF:29:EF:82:A5:7F:D0:30:A4:B4
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 CRL Distribution Points:

                  Full Name:
                    URI:http://crl.comodoca.com/AAACertificateServices.crl

                  Full Name:
                    URI:http://crl.comodo.net/AAACertificateServices.crl

  SHA1 Fingerprint=D1:EB:23:A4:6D:17:D6:8F:D9:25:64:C2:F1:F1:60:17:64:D8:E3:49
  SHA256 Fingerprint=D7:A7:A0:FB:5D:7E:27:31:D7:71:E9:48:4E:BC:DE:F7:1D:5F:0C:3E:0A:29:48:78:2B:C8:3E:E0:EA:69:9E:F4
  -----BEGIN CERTIFICATE-----
  MIIEMjCCAxqgAwIBAgIBATANBgkqhkiG9w0BAQUFADB7MQswCQYDVQQGEwJHQjEb
  MBkGA1UECAwSR3JlYXRlciBNYW5jaGVzdGVyMRAwDgYDVQQHDAdTYWxmb3JkMRow
  GAYDVQQKDBFDb21vZG8gQ0EgTGltaXRlZDEhMB8GA1UEAwwYQUFBIENlcnRpZmlj
  YXRlIFNlcnZpY2VzMB4XDTA0MDEwMTAwMDAwMFoXDTI4MTIzMTIzNTk1OVowezEL
  MAkGA1UEBhMCR0IxGzAZBgNVBAgMEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UE
  BwwHU2FsZm9yZDEaMBgGA1UECgwRQ29tb2RvIENBIExpbWl0ZWQxITAfBgNVBAMM
  GEFBQSBDZXJ0aWZpY2F0ZSBTZXJ2aWNlczCCASIwDQYJKoZIhvcNAQEBBQADggEP
  ADCCAQoCggEBAL5AnfRu4ep2hxxNRUSOvkbIgwadwSr+GB+O5AL686tdUIoWMQua
  BtDFcCLNSS1UY8y2bmhGC1Pqy0wkwLxyTurxFa70VJoSCsN6sjNg4tqJVfMiWPPe
  3M/vg4aijJRPn2jymJBGhCfHdr/jzDUsi14HZGWCwEiwqJH5YZ92IFCokcdmtet4
  YgNW8IoaE+oxox6gmf049vYnMlhvB/VruPsUK6+3qszWY19zjNoFmag4qMsXeDZR
  rOme9Hg6jc8P2ULimAyrL58OAd7vn5lJ8S3frHRNG5i1R8XlKdH5kBjHYpy+g8cm
  ez6KJcfA3Z3mNWgQIJ2P2N7Sw4ScDV7oL8kCAwEAAaOBwDCBvTAdBgNVHQ4EFgQU
  oBEKIz6W8Qfs4q8p74Klf9AwpLQwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQF
  MAMBAf8wewYDVR0fBHQwcjA4oDagNIYyaHR0cDovL2NybC5jb21vZG9jYS5jb20v
  QUFBQ2VydGlmaWNhdGVTZXJ2aWNlcy5jcmwwNqA0oDKGMGh0dHA6Ly9jcmwuY29t
  b2RvLm5ldC9BQUFDZXJ0aWZpY2F0ZVNlcnZpY2VzLmNybDANBgkqhkiG9w0BAQUF
  AAOCAQEACFb8AvCb6P+k+tZ7xkSAzk/ExfYAWMymtrwUSWgEdujm7l3sAg9g1o1Q
  GE8mTgHj5rCl7r+8dFRBv/38ErjHT1r0iWAFf2C3BUrz9vHCv8S5dIa2LX1rzNLz
  Rt0vxuBqw8M0Ayx9lt1awg6nCpnBBYurDC/zXDrPbDdVCYfeU0BsWO/8tqtlbgT2
  G9w84FoVxp7Z8VlIMCFlA2zs6SFz7JsDoeA3raAVGI/6ugLOpyypEBMs1OUIJqsi
  l2D4kF501KKaU73yqWjgom7C12yxow+ev+to51byrvLjKzg6CYG1a4XXvi3tPxq3
  smPi9WIsgtRqAEFQ8TmDn5XpNpaYbg==
  -----END CERTIFICATE-----

  ### COMODO CA Limited

  === /C=GB/ST=Greater Manchester/L=Salford/O=COMODO CA Limited/CN=COMODO Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              4e:81:2d:8a:82:65:e0:0b:02:ee:3e:35:02:46:e5:3d
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Dec  1 00:00:00 2006 GMT
              Not After : Dec 31 23:59:59 2029 GMT
          Subject: C=GB, ST=Greater Manchester, L=Salford, O=COMODO CA Limited, CN=COMODO Certification Authority
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  0B:58:E5:8B:C6:4C:15:37:A4:40:A9:30:A9:21:BE:47:36:5A:56:FF
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 CRL Distribution Points:

                  Full Name:
                    URI:http://crl.comodoca.com/COMODOCertificationAuthority.crl

  SHA1 Fingerprint=66:31:BF:9E:F7:4F:9E:B6:C9:D5:A6:0C:BA:6A:BE:D1:F7:BD:EF:7B
  SHA256 Fingerprint=0C:2C:D6:3D:F7:80:6F:A3:99:ED:E8:09:11:6B:57:5B:F8:79:89:F0:65:18:F9:80:8C:86:05:03:17:8B:AF:66
  -----BEGIN CERTIFICATE-----
  MIIEHTCCAwWgAwIBAgIQToEtioJl4AsC7j41AkblPTANBgkqhkiG9w0BAQUFADCB
  gTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4G
  A1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxJzAlBgNV
  BAMTHkNPTU9ETyBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wNjEyMDEwMDAw
  MDBaFw0yOTEyMzEyMzU5NTlaMIGBMQswCQYDVQQGEwJHQjEbMBkGA1UECBMSR3Jl
  YXRlciBNYW5jaGVzdGVyMRAwDgYDVQQHEwdTYWxmb3JkMRowGAYDVQQKExFDT01P
  RE8gQ0EgTGltaXRlZDEnMCUGA1UEAxMeQ09NT0RPIENlcnRpZmljYXRpb24gQXV0
  aG9yaXR5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0ECLi3LjkRv3
  UcEbVASY06m/weaKXTuH+7uIzg3jLz8GlvCiKVCZrts7oVewdFFxze1CkU1B/qnI
  2GqGd0S7WWaXUF601CxwRM/aN5VCaTwwxHGzUvAhTaHYujl8HJ6jJJ3ygxaYqhZ8
  Q5sVW7euNJH+1GImGEaaP+vB+fGQV+useg2L23IwambV4EajcNxo2f8ESIl33rXp
  +2dtQem8Ob0y2WIC8bGoPW43nOIv4tOiJovGuFVDiOEjPqXSJDlqR6sA1KGzqSX+
  DT+nHbrTUcELpNqsOO9VUCQFZUaTNE8tja3G1CEZ0o7KBWFxB3NH5YoZEr0ETc5O
  nKVIrLsm9wIDAQABo4GOMIGLMB0GA1UdDgQWBBQLWOWLxkwVN6RAqTCpIb5HNlpW
  /zAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zBJBgNVHR8EQjBAMD6g
  PKA6hjhodHRwOi8vY3JsLmNvbW9kb2NhLmNvbS9DT01PRE9DZXJ0aWZpY2F0aW9u
  QXV0aG9yaXR5LmNybDANBgkqhkiG9w0BAQUFAAOCAQEAPpiem/Yb6dc5t3iuHXIY
  SdOH5EOC6z/JqvWote9VfCFSZfnVDeFs9D6Mk3ORLgLETgdxb8CPOGEIqB6BCsAv
  IC9Bi5HcSEW88cbeunZrM8gALTFGTO3nnc+IlP8zwFboJIYmuNg4ON8qa90SzMc/
  RxdMosIGlgnW2/4/PEZB31jiVg88O8EckzXZOFKs7sjsLjBOlDW0JB9LeGna8gI4
  zJVSk/BwJVmcIGfE7vmLV2H0knZ9P4SNVbfo5azV8fUZVqZa+5Acr5Pr5RzUZ5dd
  BA6+C4OmF4O5MBKgxTMVBbkN+8cFduPYSo38NBejxiEovjBFMR7HeL5YYTisO+IB
  ZQ==
  -----END CERTIFICATE-----
  === /C=GB/ST=Greater Manchester/L=Salford/O=COMODO CA Limited/CN=COMODO ECC Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              1f:47:af:aa:62:00:70:50:54:4c:01:9e:9b:63:99:2a
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Mar  6 00:00:00 2008 GMT
              Not After : Jan 18 23:59:59 2038 GMT
          Subject: C=GB, ST=Greater Manchester, L=Salford, O=COMODO CA Limited, CN=COMODO ECC Certification Authority
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  75:71:A7:19:48:19:BC:9D:9D:EA:41:47:DF:94:C4:48:77:99:D3:79
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=9F:74:4E:9F:2B:4D:BA:EC:0F:31:2C:50:B6:56:3B:8E:2D:93:C3:11
  SHA256 Fingerprint=17:93:92:7A:06:14:54:97:89:AD:CE:2F:8F:34:F7:F0:B6:6D:0F:3A:E3:A3:B8:4D:21:EC:15:DB:BA:4F:AD:C7
  -----BEGIN CERTIFICATE-----
  MIICiTCCAg+gAwIBAgIQH0evqmIAcFBUTAGem2OZKjAKBggqhkjOPQQDAzCBhTEL
  MAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UE
  BxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMT
  IkNPTU9ETyBFQ0MgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDgwMzA2MDAw
  MDAwWhcNMzgwMTE4MjM1OTU5WjCBhTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdy
  ZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09N
  T0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBFQ0MgQ2VydGlmaWNhdGlv
  biBBdXRob3JpdHkwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQDR3svdcmCFYX7deSR
  FtSrYpn1PlILBs5BAH+X4QokPB0BBO490o0JlwzgdeT6+3eKKvUDYEs2ixYjFq0J
  cfRK9ChQtP6IHG4/bC8vCVlbpVsLM5niwz2J+Wos77LTBumjQjBAMB0GA1UdDgQW
  BBR1cacZSBm8nZ3qQUfflMRId5nTeTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/
  BAUwAwEB/zAKBggqhkjOPQQDAwNoADBlAjEA7wNbeqy3eApyt4jf/7VGFAkK+qDm
  fQjGGoe9GKhzvSbKYAydzpmfz1wPMOG+FDHqAjAU9JM8SaczepBGR7NjfRObTrdv
  GDeAU/7dIOA1mjbRxwG55tzd8/8dLDoWV9mSOdY=
  -----END CERTIFICATE-----
  === /C=GB/ST=Greater Manchester/L=Salford/O=COMODO CA Limited/CN=COMODO RSA Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              4c:aa:f9:ca:db:63:6f:e0:1f:f7:4e:d8:5b:03:86:9d
      Signature Algorithm: sha384WithRSAEncryption
          Validity
              Not Before: Jan 19 00:00:00 2010 GMT
              Not After : Jan 18 23:59:59 2038 GMT
          Subject: C=GB, ST=Greater Manchester, L=Salford, O=COMODO CA Limited, CN=COMODO RSA Certification Authority
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  BB:AF:7E:02:3D:FA:A6:F1:3C:84:8E:AD:EE:38:98:EC:D9:32:32:D4
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=AF:E5:D2:44:A8:D1:19:42:30:FF:47:9F:E2:F8:97:BB:CD:7A:8C:B4
  SHA256 Fingerprint=52:F0:E1:C4:E5:8E:C6:29:29:1B:60:31:7F:07:46:71:B8:5D:7E:A8:0D:5B:07:27:34:63:53:4B:32:B4:02:34
  -----BEGIN CERTIFICATE-----
  MIIF2DCCA8CgAwIBAgIQTKr5yttjb+Af907YWwOGnTANBgkqhkiG9w0BAQwFADCB
  hTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4G
  A1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNV
  BAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMTE5
  MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBhTELMAkGA1UEBhMCR0IxGzAZBgNVBAgT
  EkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEaMBgGA1UEChMR
  Q09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNh
  dGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCR
  6FSS0gpWsawNJN3Fz0RndJkrN6N9I3AAcbxT38T6KhKPS38QVr2fcHK3YX/JSw8X
  pz3jsARh7v8Rl8f0hj4K+j5c+ZPmNHrZFGvnnLOFoIJ6dq9xkNfs/Q36nGz637CC
  9BR++b7Epi9Pf5l/tfxnQ3K9DADWietrLNPtj5gcFKt+5eNu/Nio5JIk2kNrYrhV
  /erBvGy2i/MOjZrkm2xpmfh4SDBF1a3hDTxFYPwyllEnvGfDyi62a+pGx8cgoLEf
  Zd5ICLqkTqnyg0Y3hOvozIFIQ2dOciqbXL1MGyiKXCJ7tKuY2e7gUYPDCUZObT6Z
  +pUX2nwzV0E8jVHtC7ZcryxjGt9XyD+86V3Em69FmeKjWiS0uqlWPc9vqv9JWL7w
  qP/0uK3pN/u6uPQLOvnoQ0IeidiEyxPx2bvhiWC4jChWrBQdnArncevPDt09qZah
  SL0896+1DSJMwBGB7FY79tOi4lu3sgQiUpWAk2nojkxl8ZEDLXB0AuqLZxUpaVIC
  u9ffUGpVRr+goyhhf3DQw6KqLCGqR84onAZFdr+CGCe01a60y1Dma/RMhnEw6abf
  Fobg2P9A3fvQQoh/ozM6LlweQRGBY84YcWsr7KaKtzFcOmpH4MN5WdYgGq/yapiq
  crxXStJLnbsQ/LBMQeXtHT1eKJ2czL+zUdqnR+WEUwIDAQABo0IwQDAdBgNVHQ4E
  FgQUu69+Aj36pvE8hI6t7jiY7NkyMtQwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB
  /wQFMAMBAf8wDQYJKoZIhvcNAQEMBQADggIBAArx1UaEt65Ru2yyTUEUAJNMnMvl
  wFTPoCWOAvn9sKIN9SCYPBMtrFaisNZ+EZLpLrqeLppysb0ZRGxhNaKatBYSaVqM
  4dc+pBroLwP0rmEdEBsqpIt6xf4FpuHA1sj+nq6PK7o9mfjYcwlYRm6mnPTXJ9OV
  2jeDchzTc+CiR5kDOF3VSXkAKRzH7JsgHAckaVd4sjn8OoSgtZx8jb8uk2Intzna
  FxiuvTwJaP+EmzzV1gsD41eeFPfR60/IvYcjt7ZJQ3mFXLrrkguhxuhoqEwWsRqZ
  CuhTLJK7oQkYdQxlqHvLI7cawiiFwxv/0Cti76R7CZGYZ4wUAc1oBmpjIXUDgIiK
  boHGhfKppC3n9KUkEEeDys30jXlYsQab5xoq2Z0B15R97QNKyvDb6KkBPvVWmcke
  jkk9u+UJueBPSZI9FoJAzMxZxuY67RIuaTxslbH9qh17f4a+Hg4yRvv7E491f0yL
  S0Zj/gA0QHDBw7mh3aZw4gSzQbzpgJHqZJx64SIDqZxubw5lT2yHh17zbqD5daWb
  QOhTsiedSrnAdyGN/4fy3ryM7xfft0kL0fJuMAsaDk527RH89elWsn2/x20Kk4yl
  0MC2Hb46TpSi125sC8KKfPog88Tk5c0NqMuRkrF8hey1FGlmDoLnzc7ILaZRfyHB
  NVOFBkpdn627G190
  -----END CERTIFICATE-----

  ### Cybertrust, Inc

  === /O=Cybertrust, Inc/CN=Cybertrust Global Root
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              04:00:00:00:00:01:0f:85:aa:2d:48
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Dec 15 08:00:00 2006 GMT
              Not After : Dec 15 08:00:00 2021 GMT
          Subject: O=Cybertrust, Inc, CN=Cybertrust Global Root
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  B6:08:7B:0D:7A:CC:AC:20:4C:86:56:32:5E:CF:AB:6E:85:2D:70:57
              X509v3 CRL Distribution Points:

                  Full Name:
                    URI:http://www2.public-trust.com/crl/ct/ctroot.crl

              X509v3 Authority Key Identifier:
                  keyid:B6:08:7B:0D:7A:CC:AC:20:4C:86:56:32:5E:CF:AB:6E:85:2D:70:57

  SHA1 Fingerprint=5F:43:E5:B1:BF:F8:78:8C:AC:1C:C7:CA:4A:9A:C6:22:2B:CC:34:C6
  SHA256 Fingerprint=96:0A:DF:00:63:E9:63:56:75:0C:29:65:DD:0A:08:67:DA:0B:9C:BD:6E:77:71:4A:EA:FB:23:49:AB:39:3D:A3
  -----BEGIN CERTIFICATE-----
  MIIDoTCCAomgAwIBAgILBAAAAAABD4WqLUgwDQYJKoZIhvcNAQEFBQAwOzEYMBYG
  A1UEChMPQ3liZXJ0cnVzdCwgSW5jMR8wHQYDVQQDExZDeWJlcnRydXN0IEdsb2Jh
  bCBSb290MB4XDTA2MTIxNTA4MDAwMFoXDTIxMTIxNTA4MDAwMFowOzEYMBYGA1UE
  ChMPQ3liZXJ0cnVzdCwgSW5jMR8wHQYDVQQDExZDeWJlcnRydXN0IEdsb2JhbCBS
  b290MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA+Mi8vRRQZhP/8NN5
  7CPytxrHjoXxEnOmGaoQ25yiZXRadz5RfVb23CO21O1fWLE3TdVJDm71aofW0ozS
  J8bi/zafmGWgE07GKmSb1ZASzxQG9Dvj1Ci+6A74q05IlG2OlTEQXO2iLb3VOm2y
  HLtgwEZLAfVJrn5GitB0jaEMAs7u/OePuGtm839EAL9mJRQr3RAwHQeWP032a7iP
  t3sMpTjr3kfb1V05/Iin89cqdPHoWqI7n1C6poxFNcJQZZXcY4Lv3b93TZxiyWNz
  FtApD0mpSPCzqrdsxacwOUBdrsTiXSZT8M4cIwhhqJQZugRiQOwfOHB3EgZxpzAY
  XSUnpQIDAQABo4GlMIGiMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/
  MB0GA1UdDgQWBBS2CHsNesysIEyGVjJez6tuhS1wVzA/BgNVHR8EODA2MDSgMqAw
  hi5odHRwOi8vd3d3Mi5wdWJsaWMtdHJ1c3QuY29tL2NybC9jdC9jdHJvb3QuY3Js
  MB8GA1UdIwQYMBaAFLYIew16zKwgTIZWMl7Pq26FLXBXMA0GCSqGSIb3DQEBBQUA
  A4IBAQBW7wojoFROlZfJ+InaRcHUowAl9B8Tq7ejhVhpwjCt2BWKLePJzYFa+HMj
  Wqd8BfP9IjsO0QbE2zZMcwSO5bAi5MXzLqXZI+O4Tkogp24CJJ8iYGd7ix1yCcUx
  XOl5n4BHPa2hCwcUPUf/A2kaDAtE52Mlp3+yybh2hO0j9n0Hq0V+09+zv+mKts2o
  omcrUtW3ZfA5TGOgkXmTUg9U3YO7n9GPp1Nzw8v/MOx8BLjYRB+TX3EJIrduPuoc
  A06dGiBh+4E37F78CkWr1+cXVdCg6mCbpvbjjFspwgZgFJ0tl0ypkxWdYcQBX0jW
  WL1WMRJOEcgh4LMRkWXbtKaIOM5V
  -----END CERTIFICATE-----

  ### D-Trust GmbH

  === /C=DE/O=D-Trust GmbH/CN=D-TRUST Root Class 3 CA 2 2009
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 623603 (0x983f3)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Nov  5 08:35:58 2009 GMT
              Not After : Nov  5 08:35:58 2029 GMT
          Subject: C=DE, O=D-Trust GmbH, CN=D-TRUST Root Class 3 CA 2 2009
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  FD:DA:14:C4:9F:30:DE:21:BD:1E:42:39:FC:AB:63:23:49:E0:F1:84
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 CRL Distribution Points:

                  Full Name:
                    URI:ldap://directory.d-trust.net/CN=D-TRUST%20Root%20Class%203%20CA%202%202009,O=D-Trust%20GmbH,C=DE?certificaterevocationlist

                  Full Name:
                    URI:http://www.d-trust.net/crl/d-trust_root_class_3_ca_2_2009.crl

  SHA1 Fingerprint=58:E8:AB:B0:36:15:33:FB:80:F7:9B:1B:6D:29:D3:FF:8D:5F:00:F0
  SHA256 Fingerprint=49:E7:A4:42:AC:F0:EA:62:87:05:00:54:B5:25:64:B6:50:E4:F4:9E:42:E3:48:D6:AA:38:E0:39:E9:57:B1:C1
  -----BEGIN CERTIFICATE-----
  MIIEMzCCAxugAwIBAgIDCYPzMA0GCSqGSIb3DQEBCwUAME0xCzAJBgNVBAYTAkRF
  MRUwEwYDVQQKDAxELVRydXN0IEdtYkgxJzAlBgNVBAMMHkQtVFJVU1QgUm9vdCBD
  bGFzcyAzIENBIDIgMjAwOTAeFw0wOTExMDUwODM1NThaFw0yOTExMDUwODM1NTha
  ME0xCzAJBgNVBAYTAkRFMRUwEwYDVQQKDAxELVRydXN0IEdtYkgxJzAlBgNVBAMM
  HkQtVFJVU1QgUm9vdCBDbGFzcyAzIENBIDIgMjAwOTCCASIwDQYJKoZIhvcNAQEB
  BQADggEPADCCAQoCggEBANOySs96R+91myP6Oi/WUEWJNTrGa9v+2wBoqOADER03
  UAifTUpolDWzU9GUY6cgVq/eUXjsKj3zSEhQPgrfRlWLJ23DEE0NkVJD2IfgXU42
  tSHKXzlABF9bfsyjxiupQB7ZNoTWSPOSHjRGICTBpFGOShrvUD9pXRl/RcPHAY9R
  ySPocq60vFYJfxLLHLGvKZAKyVXMD9O0Gu1HNVpK7ZxzBCHQqr0ME7UAyiZsxGsM
  lFqVlNpQmvH/pStmMaTJOKDfHR+4CS7zp+hnUquVH+BGPtikw8paxTGA6Eian5Rp
  /hnd2HN8gcqW3o7tszIFZYQ05ub9VxC1X3a/L7AQDcUCAwEAAaOCARowggEWMA8G
  A1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFP3aFMSfMN4hvR5COfyrYyNJ4PGEMA4G
  A1UdDwEB/wQEAwIBBjCB0wYDVR0fBIHLMIHIMIGAoH6gfIZ6bGRhcDovL2RpcmVj
  dG9yeS5kLXRydXN0Lm5ldC9DTj1ELVRSVVNUJTIwUm9vdCUyMENsYXNzJTIwMyUy
  MENBJTIwMiUyMDIwMDksTz1ELVRydXN0JTIwR21iSCxDPURFP2NlcnRpZmljYXRl
  cmV2b2NhdGlvbmxpc3QwQ6BBoD+GPWh0dHA6Ly93d3cuZC10cnVzdC5uZXQvY3Js
  L2QtdHJ1c3Rfcm9vdF9jbGFzc18zX2NhXzJfMjAwOS5jcmwwDQYJKoZIhvcNAQEL
  BQADggEBAH+X2zDI36ScfSF6gHDOFBJpiBSVYEQBrLLpME+bUMJm2H6NMLVwMeni
  acfzcNsgFYbQDfC+rAF1hM5+n02/t2A7nPPKHeJeaNijnZflQGDSNiH+0LS4F9p0
  o3/U37CYAqxva2ssJSRyoWXuJVrl5jLn8t+rSfrzkGkj2wTZ51xY/GXUl77M/C4K
  zCUqNQT4YJEVdT1B/yMfGchs64JTBKbkTCJNjYy6zltz7GRUUG3RnFX7acM2w4y8
  PIWmawomDeCTmGCufsYkl4phX5GOZpIJhzbNi5stPvZR1FDUWSi9g/LMKHtThm3Y
  Johw1+qRzT65ysCQblrGXnRl11z+o+I=
  -----END CERTIFICATE-----
  === /C=DE/O=D-Trust GmbH/CN=D-TRUST Root Class 3 CA 2 EV 2009
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 623604 (0x983f4)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Nov  5 08:50:46 2009 GMT
              Not After : Nov  5 08:50:46 2029 GMT
          Subject: C=DE, O=D-Trust GmbH, CN=D-TRUST Root Class 3 CA 2 EV 2009
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  D3:94:8A:4C:62:13:2A:19:2E:CC:AF:72:8A:7D:36:D7:9A:1C:DC:67
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 CRL Distribution Points:

                  Full Name:
                    URI:ldap://directory.d-trust.net/CN=D-TRUST%20Root%20Class%203%20CA%202%20EV%202009,O=D-Trust%20GmbH,C=DE?certificaterevocationlist

                  Full Name:
                    URI:http://www.d-trust.net/crl/d-trust_root_class_3_ca_2_ev_2009.crl

  SHA1 Fingerprint=96:C9:1B:0B:95:B4:10:98:42:FA:D0:D8:22:79:FE:60:FA:B9:16:83
  SHA256 Fingerprint=EE:C5:49:6B:98:8C:E9:86:25:B9:34:09:2E:EC:29:08:BE:D0:B0:F3:16:C2:D4:73:0C:84:EA:F1:F3:D3:48:81
  -----BEGIN CERTIFICATE-----
  MIIEQzCCAyugAwIBAgIDCYP0MA0GCSqGSIb3DQEBCwUAMFAxCzAJBgNVBAYTAkRF
  MRUwEwYDVQQKDAxELVRydXN0IEdtYkgxKjAoBgNVBAMMIUQtVFJVU1QgUm9vdCBD
  bGFzcyAzIENBIDIgRVYgMjAwOTAeFw0wOTExMDUwODUwNDZaFw0yOTExMDUwODUw
  NDZaMFAxCzAJBgNVBAYTAkRFMRUwEwYDVQQKDAxELVRydXN0IEdtYkgxKjAoBgNV
  BAMMIUQtVFJVU1QgUm9vdCBDbGFzcyAzIENBIDIgRVYgMjAwOTCCASIwDQYJKoZI
  hvcNAQEBBQADggEPADCCAQoCggEBAJnxhDRwui+3MKCOvXwEz75ivJn9gpfSegpn
  ljgJ9hBOlSJzmY3aFS3nBfwZcyK3jpgAvDw9rKFs+9Z5JUut8Mxk2og+KbgPCdM0
  3TP1YtHhzRnp7hhPTFiu4h7WDFsVWtg6uMQYZB7jM7K1iXdODL/ZlGsTl28So/6Z
  qQTMFexgaDbtCHu39b+T7WYxg4zGcTSHThfqr4uRjRxWQa4iN1438h3Z0S0NL2lR
  p75mpoo6Kr3HGrHhFPC+Oh25z1uxav60sUYgovseO3Dvk5h9jHOW8sXvhXCtKSb8
  HgQ+HKDYD8tSg2J87otTlZCpV6LqYQXY+U3EJ/pure3511H3a6UCAwEAAaOCASQw
  ggEgMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFNOUikxiEyoZLsyvcop9Ntea
  HNxnMA4GA1UdDwEB/wQEAwIBBjCB3QYDVR0fBIHVMIHSMIGHoIGEoIGBhn9sZGFw
  Oi8vZGlyZWN0b3J5LmQtdHJ1c3QubmV0L0NOPUQtVFJVU1QlMjBSb290JTIwQ2xh
  c3MlMjAzJTIwQ0ElMjAyJTIwRVYlMjAyMDA5LE89RC1UcnVzdCUyMEdtYkgsQz1E
  RT9jZXJ0aWZpY2F0ZXJldm9jYXRpb25saXN0MEagRKBChkBodHRwOi8vd3d3LmQt
  dHJ1c3QubmV0L2NybC9kLXRydXN0X3Jvb3RfY2xhc3NfM19jYV8yX2V2XzIwMDku
  Y3JsMA0GCSqGSIb3DQEBCwUAA4IBAQA07XtaPKSUiO8aEXUHL7P+PPoeUSbrh/Yp
  3uDx1MYkCenBz1UbtDDZzhr+BlGmFaQt77JLvyAoJUnRpjZ3NOhk31KxEcdzes05
  nsKtjHEh8lprr988TlWvsoRlFIm5d8sqMb7Po23Pb0iUMkZv53GMoKaEGTcH8gNF
  CSuGdXzfX2lXANtu2KZyIktQ1HWYVt+3GP9DQ1CuekR78HlR10M9p9OB0/DJT7na
  xpeG0ILD5EJt/rDiZE4OJudANCa1CInXCGNjOCd1HjPqbqjdn5lPdE2BiYBL3ZqX
  KVwvvoFBuYz/6n1gBp7N1z3TLqMVvKjmJuVvw9y4AyHqnxbxLFS1
  -----END CERTIFICATE-----

  ### Dhimyotis

  === /C=FR/O=Dhimyotis/CN=Certigna
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              fe:dc:e3:01:0f:c9:48:ff
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Jun 29 15:13:05 2007 GMT
              Not After : Jun 29 15:13:05 2027 GMT
          Subject: C=FR, O=Dhimyotis, CN=Certigna
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  1A:ED:FE:41:39:90:B4:24:59:BE:01:F2:52:D5:45:F6:5A:39:DC:11
              X509v3 Authority Key Identifier:
                  keyid:1A:ED:FE:41:39:90:B4:24:59:BE:01:F2:52:D5:45:F6:5A:39:DC:11
                  DirName:/C=FR/O=Dhimyotis/CN=Certigna
                  serial:FE:DC:E3:01:0F:C9:48:FF

              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              Netscape Cert Type:
                  SSL CA, S/MIME CA, Object Signing CA
  SHA1 Fingerprint=B1:2E:13:63:45:86:A4:6F:1A:B2:60:68:37:58:2D:C4:AC:FD:94:97
  SHA256 Fingerprint=E3:B6:A2:DB:2E:D7:CE:48:84:2F:7A:C5:32:41:C7:B7:1D:54:14:4B:FB:40:C1:1F:3F:1D:0B:42:F5:EE:A1:2D
  -----BEGIN CERTIFICATE-----
  MIIDqDCCApCgAwIBAgIJAP7c4wEPyUj/MA0GCSqGSIb3DQEBBQUAMDQxCzAJBgNV
  BAYTAkZSMRIwEAYDVQQKDAlEaGlteW90aXMxETAPBgNVBAMMCENlcnRpZ25hMB4X
  DTA3MDYyOTE1MTMwNVoXDTI3MDYyOTE1MTMwNVowNDELMAkGA1UEBhMCRlIxEjAQ
  BgNVBAoMCURoaW15b3RpczERMA8GA1UEAwwIQ2VydGlnbmEwggEiMA0GCSqGSIb3
  DQEBAQUAA4IBDwAwggEKAoIBAQDIaPHJ1tazNHUmgh7stL7qXOEm7RFHYeGifBZ4
  QCHkYJ5ayGPhxLGWkv8YbWkj4Sti993iNi+RB7lIzw7sebYs5zRLcAglozyHGxny
  gQcPOJAZ0xH+hrTy0V4eHpbNgGzOOzGTtvKg0KmVEn2lmsxryIRWijOp5yIVUxbw
  zBfsV1/pogqYCd7jX5xv3EjjhQsVWqa6n6xI4wmy9/Qy3l40vhx4XUJbzg4ij02Q
  130yGLMLLGq/jj8UEYkgDncUtT2UCIf3JR7VsmAA7G8qKCVuKj4YYxclPz5EIBb2
  JsglrgVKtOdjLPOMFlN+XPsRGgjBRmKfIrjxwo1p3Po6WAbfAgMBAAGjgbwwgbkw
  DwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUGu3+QTmQtCRZvgHyUtVF9lo53BEw
  ZAYDVR0jBF0wW4AUGu3+QTmQtCRZvgHyUtVF9lo53BGhOKQ2MDQxCzAJBgNVBAYT
  AkZSMRIwEAYDVQQKDAlEaGlteW90aXMxETAPBgNVBAMMCENlcnRpZ25hggkA/tzj
  AQ/JSP8wDgYDVR0PAQH/BAQDAgEGMBEGCWCGSAGG+EIBAQQEAwIABzANBgkqhkiG
  9w0BAQUFAAOCAQEAhQMeknH2Qq/ho2Ge6/PAD/Kl1NqV5ta+aDY9fm4fTIrv0Q8h
  bV6lUmPOEvjvKtpv6zf+EwLHyzs+ImvaYS5/1HI93TDhHkxAGYwP15zRgzB7mFnc
  fca5DClMoTOi62c6ZYTTluLtdkVwj7Ur3vkj1kluPBS1xp81HlDQwY9qcEQCYsuu
  HWhBp6pX6FOqB9IG9tUUBguRA3UsbHK1YZWaDYu5Def131TN3ubY1gkIl2PlwS6w
  t0QmwCbAr1UwnjvVNioZBPRcHv/PLLf/0P2HQBHVESO7SMAhqaQoLf0V+LBOK/Qw
  WyH8EZE0vkHve52Xdf+XlcCWWC/qu0bXu+TZLg==
  -----END CERTIFICATE-----
  === /C=FR/O=Dhimyotis/OU=0002 48146308100036/CN=Certigna Root CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              ca:e9:1b:89:f1:55:03:0d:a3:e6:41:6d:c4:e3:a6:e1
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Oct  1 08:32:27 2013 GMT
              Not After : Oct  1 08:32:27 2033 GMT
          Subject: C=FR, O=Dhimyotis, OU=0002 48146308100036, CN=Certigna Root CA
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  18:87:56:E0:6E:77:EE:24:35:3C:4E:73:9A:1F:D6:E1:E2:79:7E:2B
              X509v3 Authority Key Identifier:
                  keyid:18:87:56:E0:6E:77:EE:24:35:3C:4E:73:9A:1F:D6:E1:E2:79:7E:2B

              X509v3 Certificate Policies:
                  Policy: X509v3 Any Policy
                    CPS: https://wwww.certigna.fr/autorites/

              X509v3 CRL Distribution Points:

                  Full Name:
                    URI:http://crl.certigna.fr/certignarootca.crl

                  Full Name:
                    URI:http://crl.dhimyotis.com/certignarootca.crl

  SHA1 Fingerprint=2D:0D:52:14:FF:9E:AD:99:24:01:74:20:47:6E:6C:85:27:27:F5:43
  SHA256 Fingerprint=D4:8D:3D:23:EE:DB:50:A4:59:E5:51:97:60:1C:27:77:4B:9D:7B:18:C9:4D:5A:05:95:11:A1:02:50:B9:31:68
  -----BEGIN CERTIFICATE-----
  MIIGWzCCBEOgAwIBAgIRAMrpG4nxVQMNo+ZBbcTjpuEwDQYJKoZIhvcNAQELBQAw
  WjELMAkGA1UEBhMCRlIxEjAQBgNVBAoMCURoaW15b3RpczEcMBoGA1UECwwTMDAw
  MiA0ODE0NjMwODEwMDAzNjEZMBcGA1UEAwwQQ2VydGlnbmEgUm9vdCBDQTAeFw0x
  MzEwMDEwODMyMjdaFw0zMzEwMDEwODMyMjdaMFoxCzAJBgNVBAYTAkZSMRIwEAYD
  VQQKDAlEaGlteW90aXMxHDAaBgNVBAsMEzAwMDIgNDgxNDYzMDgxMDAwMzYxGTAX
  BgNVBAMMEENlcnRpZ25hIFJvb3QgQ0EwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAw
  ggIKAoICAQDNGDllGlmx6mQWDoyUJJV8g9PFOSbcDO8WV43X2KyjQn+Cyu3NW9sO
  ty3tRQgXstmzy9YXUnIo245Onoq2C/mehJpNdt4iKVzSs9IGPjA5qXSjklYcoW9M
  CiBtnyN6tMbaLOQdLNyzKNAT8kxOAkmhVECe5uUFoC2EyP+YbNDrihqECB63aCPu
  I9Vwzm1RaRDuoXrC0SIxwoKF0vJVdlB8JXrJhFwLrN1CTivngqIkicuQstDuI7pm
  TLtipPlTWmR7fJj6o0ieD5Wupxj0auwuA0Wv8HT4Ks16XdG+RCYyKfHx9WzMfgIh
  C59vpD++nVPiz32pLHxYGpfhPTc3GGYo0kDFUYqMwy3OU4gkWGQwFsWq4NYKpkDf
  ePb1BHxpE4S80dGnBs8B92jAqFe7OmGtBIyT46388NtEbVncSVmurJqZNjBBe3Yz
  IoejwpKGbvlw7q6Hh5UbxHq9MfPU0uWZ/75I7HX1eBYdpnDBfzwboZL7z8g81sWT
  Co/1VTp2lc5ZmIoJlXcymoO6LAQ6l73UL77XbJuiyn1tJslV1c/DeVIICZkHJC1k
  JWumIWmbat10TWuXekG9qxf5kBdIjzb5LdXF2+6qhUVB+s06RbFo5jZMm5BX7CO5
  hwjCxAnxl4YqKE3idMDaxIzb3+KhF1nOJFl0Mdp//TBt2dzhauH8XwIDAQABo4IB
  GjCCARYwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYE
  FBiHVuBud+4kNTxOc5of1uHieX4rMB8GA1UdIwQYMBaAFBiHVuBud+4kNTxOc5of
  1uHieX4rMEQGA1UdIAQ9MDswOQYEVR0gADAxMC8GCCsGAQUFBwIBFiNodHRwczov
  L3d3d3cuY2VydGlnbmEuZnIvYXV0b3JpdGVzLzBtBgNVHR8EZjBkMC+gLaArhilo
  dHRwOi8vY3JsLmNlcnRpZ25hLmZyL2NlcnRpZ25hcm9vdGNhLmNybDAxoC+gLYYr
  aHR0cDovL2NybC5kaGlteW90aXMuY29tL2NlcnRpZ25hcm9vdGNhLmNybDANBgkq
  hkiG9w0BAQsFAAOCAgEAlLieT/DjlQgi581oQfccVdV8AOItOoldaDgvUSILSo3L
  6btdPrtcPbEo/uRTVRPPoZAbAh1fZkYJMyjhDSSXcNMQH+pkV5a7XdrnxIxPTGRG
  HVyH41neQtGbqH6mid2PHMkwgu07nM3A6RngatgCdTer9zQoKJHyBApPNeNgJgH6
  0BGM+RFq7q89w1DTj18zeTyGqHNFkIwgtnJzFyO+B2XleJINugHA64wcZr+shncB
  lA2c5uk5jR+mUYyZDDl34bSb+hxnV29qao6pK0xXeXpXIs/NX2NGjVxZOob4Mkdi
  o2cNGJHc+6Zr9UhhcyNZjgKnvETq9Emd8VRY+WCv2hikLyhF3HqgiIZd8zvn/yk1
  gPxkQ5Tm4xxvvq0OKmOZK8l+hfZx6AYDlf7ej0gcWtSS6Cvu5zHbugRqh5jnxV/v
  faci9wHYTfmJ0A6aBVmknpjZbyvKcL5kwlWj9Omvw5Ip3IgWJJk8jSaYtlu3zM63
  Nwf9JtmYhST/WSMDmu2dnajkXjjO11INb9I/bbEFa0nOipFGc/T2L/Coc3cOZayh
  jWZSaX5LaAzHHjcng6WMxwLkFM1JAbBzs/3GkDpv0mztO+7skb6iQ12LAEpmJURw
  3kAP+HwV96LOPNdeE4yBFxgX0b3xdxA61GU5wSesVywlVP+i2k+KYTlerj1KjL0=
  -----END CERTIFICATE-----

  ### DigiCert Inc

  === /C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Assured ID Root CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              0c:e7:e0:e5:17:d8:46:fe:8f:e5:60:fc:1b:f0:30:39
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Nov 10 00:00:00 2006 GMT
              Not After : Nov 10 00:00:00 2031 GMT
          Subject: C=US, O=DigiCert Inc, OU=www.digicert.com, CN=DigiCert Assured ID Root CA
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  45:EB:A2:AF:F4:92:CB:82:31:2D:51:8B:A7:A7:21:9D:F3:6D:C8:0F
              X509v3 Authority Key Identifier:
                  keyid:45:EB:A2:AF:F4:92:CB:82:31:2D:51:8B:A7:A7:21:9D:F3:6D:C8:0F

  SHA1 Fingerprint=05:63:B8:63:0D:62:D7:5A:BB:C8:AB:1E:4B:DF:B5:A8:99:B2:4D:43
  SHA256 Fingerprint=3E:90:99:B5:01:5E:8F:48:6C:00:BC:EA:9D:11:1E:E7:21:FA:BA:35:5A:89:BC:F1:DF:69:56:1E:3D:C6:32:5C
  -----BEGIN CERTIFICATE-----
  MIIDtzCCAp+gAwIBAgIQDOfg5RfYRv6P5WD8G/AwOTANBgkqhkiG9w0BAQUFADBl
  MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
  d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJv
  b3QgQ0EwHhcNMDYxMTEwMDAwMDAwWhcNMzExMTEwMDAwMDAwWjBlMQswCQYDVQQG
  EwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNl
  cnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgQ0EwggEi
  MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCtDhXO5EOAXLGH87dg+XESpa7c
  JpSIqvTO9SA5KFhgDPiA2qkVlTJhPLWxKISKityfCgyDF3qPkKyK53lTXDGEKvYP
  mDI2dsze3Tyoou9q+yHyUmHfnyDXH+Kx2f4YZNISW1/5WBg1vEfNoTb5a3/UsDg+
  wRvDjDPZ2C8Y/igPs6eD1sNuRMBhNZYW/lmci3Zt1/GiSw0r/wty2p5g0I6QNcZ4
  VYcgoc/lbQrISXwxmDNsIumH0DJaoroTghHtORedmTpyoeb6pNnVFzF1roV9Iq4/
  AUaG9ih5yLHa5FcXxH4cDrC0kqZWs72yl+2qp/C3xag/lRbQ/6GW6whfGHdPAgMB
  AAGjYzBhMA4GA1UdDwEB/wQEAwIBhjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQW
  BBRF66Kv9JLLgjEtUYunpyGd823IDzAfBgNVHSMEGDAWgBRF66Kv9JLLgjEtUYun
  pyGd823IDzANBgkqhkiG9w0BAQUFAAOCAQEAog683+Lt8ONyc3pklL/3cmbYMuRC
  dWKuh+vy1dneVrOfzM4UKLkNl2BcEkxY5NM9g0lFWJc1aRqoR+pWxnmrEthngYTf
  fwk8lOa4JiwgvT2zKIn3X/8i4peEH+ll74fg38FnSbNd67IJKusm7Xi+fT8r87cm
  NW1fiQG2SVufAQWbqz0lwcy2f8Lxb4bG+mRo64EtlOtCt/qMHt1i8b5QZ7dsvfPx
  H2sMNgcWfzd8qVttevESRmCD1ycEvkvOl77DZypoEd+A5wwzZr8TDRRu838fYxAe
  +o0bJW1sj6W3YQGx0qMmoRBxna3iw/nDmVG3KwcIzi7mULKn+gpFL6Lw8g==
  -----END CERTIFICATE-----
  === /C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Assured ID Root G2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              0b:93:1c:3a:d6:39:67:ea:67:23:bf:c3:af:9a:f4:4b
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Aug  1 12:00:00 2013 GMT
              Not After : Jan 15 12:00:00 2038 GMT
          Subject: C=US, O=DigiCert Inc, OU=www.digicert.com, CN=DigiCert Assured ID Root G2
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  CE:C3:4A:B9:99:55:F2:B8:DB:60:BF:A9:7E:BD:56:B5:97:36:A7:D6
  SHA1 Fingerprint=A1:4B:48:D9:43:EE:0A:0E:40:90:4F:3C:E0:A4:C0:91:93:51:5D:3F
  SHA256 Fingerprint=7D:05:EB:B6:82:33:9F:8C:94:51:EE:09:4E:EB:FE:FA:79:53:A1:14:ED:B2:F4:49:49:45:2F:AB:7D:2F:C1:85
  -----BEGIN CERTIFICATE-----
  MIIDljCCAn6gAwIBAgIQC5McOtY5Z+pnI7/Dr5r0SzANBgkqhkiG9w0BAQsFADBl
  MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
  d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJv
  b3QgRzIwHhcNMTMwODAxMTIwMDAwWhcNMzgwMTE1MTIwMDAwWjBlMQswCQYDVQQG
  EwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNl
  cnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgRzIwggEi
  MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDZ5ygvUj82ckmIkzTz+GoeMVSA
  n61UQbVH35ao1K+ALbkKz3X9iaV9JPrjIgwrvJUXCzO/GU1BBpAAvQxNEP4Htecc
  biJVMWWXvdMX0h5i89vqbFCMP4QMls+3ywPgym2hFEwbid3tALBSfK+RbLE4E9Hp
  EgjAALAcKxHad3A2m67OeYfcgnDmCXRwVWmvo2ifv922ebPynXApVfSr/5Vh88lA
  bx3RvpO704gqu52/clpWcTs/1PPRCv4o76Pu2ZmvA9OPYLfykqGxvYmJHzDNw6Yu
  YjOuFgJ3RFrngQo8p0Quebg/BLxcoIfhG69Rjs3sLPr4/m3wOnyqi+RnlTGNAgMB
  AAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQW
  BBTOw0q5mVXyuNtgv6l+vVa1lzan1jANBgkqhkiG9w0BAQsFAAOCAQEAyqVVjOPI
  QW5pJ6d1Ee88hjZv0p3GeDgdaZaikmkuOGybfQTUiaWxMTeKySHMq2zNixya1r9I
  0jJmwYrA8y8678Dj1JGG0VDjA9tzd29KOVPt3ibHtX2vK0LRdWLjSisCx1BL4Gni
  lmwORGYQRI+tBev4eaymG+g3NJ1TyWGqolKvSnAWhsI6yLETcDbYz+70CjTVW0z9
  B5yiutkBclzzTcHdDrEcDcRjvq30FPuJ7KJBDkzMyFdA0G4Dqs0MjomZmWzwPDCv
  ON9vvKO+KSAnq3T/EyJ43pdSVR6DtVQgA+6uwE9W3jfMw3+qBCe703e4YtsXfJwo
  IhNzbM8m9Yop5w==
  -----END CERTIFICATE-----
  === /C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Assured ID Root G3
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              0b:a1:5a:fa:1d:df:a0:b5:49:44:af:cd:24:a0:6c:ec
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Aug  1 12:00:00 2013 GMT
              Not After : Jan 15 12:00:00 2038 GMT
          Subject: C=US, O=DigiCert Inc, OU=www.digicert.com, CN=DigiCert Assured ID Root G3
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  CB:D0:BD:A9:E1:98:05:51:A1:4D:37:A2:83:79:CE:8D:1D:2A:E4:84
  SHA1 Fingerprint=F5:17:A2:4F:9A:48:C6:C9:F8:A2:00:26:9F:DC:0F:48:2C:AB:30:89
  SHA256 Fingerprint=7E:37:CB:8B:4C:47:09:0C:AB:36:55:1B:A6:F4:5D:B8:40:68:0F:BA:16:6A:95:2D:B1:00:71:7F:43:05:3F:C2
  -----BEGIN CERTIFICATE-----
  MIICRjCCAc2gAwIBAgIQC6Fa+h3foLVJRK/NJKBs7DAKBggqhkjOPQQDAzBlMQsw
  CQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cu
  ZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3Qg
  RzMwHhcNMTMwODAxMTIwMDAwWhcNMzgwMTE1MTIwMDAwWjBlMQswCQYDVQQGEwJV
  UzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu
  Y29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgRzMwdjAQBgcq
  hkjOPQIBBgUrgQQAIgNiAAQZ57ysRGXtzbg/WPuNsVepRC0FFfLvC/8QdJ+1YlJf
  Zn4f5dwbRXkLzMZTCp2NXQLZqVneAlr2lSoOjThKiknGvMYDOAdfVdp+CW7if17Q
  RSAPWXYQ1qAk8C3eNvJsKTmjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/
  BAQDAgGGMB0GA1UdDgQWBBTL0L2p4ZgFUaFNN6KDec6NHSrkhDAKBggqhkjOPQQD
  AwNnADBkAjAlpIFFAmsSS3V0T8gj43DydXLefInwz5FyYZ5eEJJZVrmDxxDnOOlY
  JjZ91eQ0hjkCMHw2U/Aw5WJjOpnitqM7mzT6HtoQknFekROn3aRukswy1vUhZscv
  6pZjamVFkpUBtA==
  -----END CERTIFICATE-----
  === /C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Global Root CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              08:3b:e0:56:90:42:46:b1:a1:75:6a:c9:59:91:c7:4a
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Nov 10 00:00:00 2006 GMT
              Not After : Nov 10 00:00:00 2031 GMT
          Subject: C=US, O=DigiCert Inc, OU=www.digicert.com, CN=DigiCert Global Root CA
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  03:DE:50:35:56:D1:4C:BB:66:F0:A3:E2:1B:1B:C3:97:B2:3D:D1:55
              X509v3 Authority Key Identifier:
                  keyid:03:DE:50:35:56:D1:4C:BB:66:F0:A3:E2:1B:1B:C3:97:B2:3D:D1:55

  SHA1 Fingerprint=A8:98:5D:3A:65:E5:E5:C4:B2:D7:D6:6D:40:C6:DD:2F:B1:9C:54:36
  SHA256 Fingerprint=43:48:A0:E9:44:4C:78:CB:26:5E:05:8D:5E:89:44:B4:D8:4F:96:62:BD:26:DB:25:7F:89:34:A4:43:C7:01:61
  -----BEGIN CERTIFICATE-----
  MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh
  MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
  d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD
  QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT
  MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j
  b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG
  9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKPC3eQyaKl7hLOllsB
  CSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscFs3YnFo97
  nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt
  43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7P
  T19sdl6gSzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4
  gdW7jVg/tRvoSSiicNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAO
  BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR
  TLtm8KPiGxvDl7I90VUwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxvDl7I90VUw
  DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr
  hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg
  06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF
  PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls
  YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk
  CAUw7C29C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=
  -----END CERTIFICATE-----
  === /C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Global Root G2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              03:3a:f1:e6:a7:11:a9:a0:bb:28:64:b1:1d:09:fa:e5
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Aug  1 12:00:00 2013 GMT
              Not After : Jan 15 12:00:00 2038 GMT
          Subject: C=US, O=DigiCert Inc, OU=www.digicert.com, CN=DigiCert Global Root G2
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  4E:22:54:20:18:95:E6:E3:6E:E6:0F:FA:FA:B9:12:ED:06:17:8F:39
  SHA1 Fingerprint=DF:3C:24:F9:BF:D6:66:76:1B:26:80:73:FE:06:D1:CC:8D:4F:82:A4
  SHA256 Fingerprint=CB:3C:CB:B7:60:31:E5:E0:13:8F:8D:D3:9A:23:F9:DE:47:FF:C3:5E:43:C1:14:4C:EA:27:D4:6A:5A:B1:CB:5F
  -----BEGIN CERTIFICATE-----
  MIIDjjCCAnagAwIBAgIQAzrx5qcRqaC7KGSxHQn65TANBgkqhkiG9w0BAQsFADBh
  MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
  d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBH
  MjAeFw0xMzA4MDExMjAwMDBaFw0zODAxMTUxMjAwMDBaMGExCzAJBgNVBAYTAlVT
  MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j
  b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IEcyMIIBIjANBgkqhkiG
  9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuzfNNNx7a8myaJCtSnX/RrohCgiN9RlUyfuI
  2/Ou8jqJkTx65qsGGmvPrC3oXgkkRLpimn7Wo6h+4FR1IAWsULecYxpsMNzaHxmx
  1x7e/dfgy5SDN67sH0NO3Xss0r0upS/kqbitOtSZpLYl6ZtrAGCSYP9PIUkY92eQ
  q2EGnI/yuum06ZIya7XzV+hdG82MHauVBJVJ8zUtluNJbd134/tJS7SsVQepj5Wz
  tCO7TG1F8PapspUwtP1MVYwnSlcUfIKdzXOS0xZKBgyMUNGPHgm+F6HmIcr9g+UQ
  vIOlCsRnKPZzFBQ9RnbDhxSJITRNrw9FDKZJobq7nMWxM4MphQIDAQABo0IwQDAP
  BgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjAdBgNVHQ4EFgQUTiJUIBiV
  5uNu5g/6+rkS7QYXjzkwDQYJKoZIhvcNAQELBQADggEBAGBnKJRvDkhj6zHd6mcY
  1Yl9PMWLSn/pvtsrF9+wX3N3KjITOYFnQoQj8kVnNeyIv/iPsGEMNKSuIEyExtv4
  NeF22d+mQrvHRAiGfzZ0JFrabA0UWTW98kndth/Jsw1HKj2ZL7tcu7XUIOGZX1NG
  Fdtom/DzMNU+MeKNhJ7jitralj41E6Vf8PlwUHBHQRFXGU7Aj64GxJUTFy8bJZ91
  8rGOmaFvE7FBcf6IKshPECBV1/MUReXgRPTqh5Uykw7+U0b6LJ3/iyK5S9kJRaTe
  pLiaWN0bfVKfjllDiIGknibVb63dDcY3fe0Dkhvld1927jyNxF1WW6LZZm6zNTfl
  MrY=
  -----END CERTIFICATE-----
  === /C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Global Root G3
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              05:55:56:bc:f2:5e:a4:35:35:c3:a4:0f:d5:ab:45:72
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Aug  1 12:00:00 2013 GMT
              Not After : Jan 15 12:00:00 2038 GMT
          Subject: C=US, O=DigiCert Inc, OU=www.digicert.com, CN=DigiCert Global Root G3
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  B3:DB:48:A4:F9:A1:C5:D8:AE:36:41:CC:11:63:69:62:29:BC:4B:C6
  SHA1 Fingerprint=7E:04:DE:89:6A:3E:66:6D:00:E6:87:D3:3F:FA:D9:3B:E8:3D:34:9E
  SHA256 Fingerprint=31:AD:66:48:F8:10:41:38:C7:38:F3:9E:A4:32:01:33:39:3E:3A:18:CC:02:29:6E:F9:7C:2A:C9:EF:67:31:D0
  -----BEGIN CERTIFICATE-----
  MIICPzCCAcWgAwIBAgIQBVVWvPJepDU1w6QP1atFcjAKBggqhkjOPQQDAzBhMQsw
  CQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cu
  ZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBHMzAe
  Fw0xMzA4MDExMjAwMDBaFw0zODAxMTUxMjAwMDBaMGExCzAJBgNVBAYTAlVTMRUw
  EwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20x
  IDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IEczMHYwEAYHKoZIzj0CAQYF
  K4EEACIDYgAE3afZu4q4C/sLfyHS8L6+c/MzXRq8NOrexpu80JX28MzQC7phW1FG
  fp4tn+6OYwwX7Adw9c+ELkCDnOg/QW07rdOkFFk2eJ0DQ+4QE2xy3q6Ip6FrtUPO
  Z9wj/wMco+I+o0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjAd
  BgNVHQ4EFgQUs9tIpPmhxdiuNkHMEWNpYim8S8YwCgYIKoZIzj0EAwMDaAAwZQIx
  AK288mw/EkrRLTnDCgmXc/SINoyIJ7vmiI1Qhadj+Z4y3maTD/HMsQmP3Wyr+mt/
  oAIwOWZbwmSNuJ5Q3KjVSaLtx9zRSX8XAbjIho9OjIgrqJqpisXRAL34VOKa5Vt8
  sycX
  -----END CERTIFICATE-----
  === /C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert High Assurance EV Root CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              02:ac:5c:26:6a:0b:40:9b:8f:0b:79:f2:ae:46:25:77
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Nov 10 00:00:00 2006 GMT
              Not After : Nov 10 00:00:00 2031 GMT
          Subject: C=US, O=DigiCert Inc, OU=www.digicert.com, CN=DigiCert High Assurance EV Root CA
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  B1:3E:C3:69:03:F8:BF:47:01:D4:98:26:1A:08:02:EF:63:64:2B:C3
              X509v3 Authority Key Identifier:
                  keyid:B1:3E:C3:69:03:F8:BF:47:01:D4:98:26:1A:08:02:EF:63:64:2B:C3

  SHA1 Fingerprint=5F:B7:EE:06:33:E2:59:DB:AD:0C:4C:9A:E6:D3:8F:1A:61:C7:DC:25
  SHA256 Fingerprint=74:31:E5:F4:C3:C1:CE:46:90:77:4F:0B:61:E0:54:40:88:3B:A9:A0:1E:D0:0B:A6:AB:D7:80:6E:D3:B1:18:CF
  -----BEGIN CERTIFICATE-----
  MIIDxTCCAq2gAwIBAgIQAqxcJmoLQJuPC3nyrkYldzANBgkqhkiG9w0BAQUFADBs
  MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
  d3cuZGlnaWNlcnQuY29tMSswKQYDVQQDEyJEaWdpQ2VydCBIaWdoIEFzc3VyYW5j
  ZSBFViBSb290IENBMB4XDTA2MTExMDAwMDAwMFoXDTMxMTExMDAwMDAwMFowbDEL
  MAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3
  LmRpZ2ljZXJ0LmNvbTErMCkGA1UEAxMiRGlnaUNlcnQgSGlnaCBBc3N1cmFuY2Ug
  RVYgUm9vdCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMbM5XPm
  +9S75S0tMqbf5YE/yc0lSbZxKsPVlDRnogocsF9ppkCxxLeyj9CYpKlBWTrT3JTW
  PNt0OKRKzE0lgvdKpVMSOO7zSW1xkX5jtqumX8OkhPhPYlG++MXs2ziS4wblCJEM
  xChBVfvLWokVfnHoNb9Ncgk9vjo4UFt3MRuNs8ckRZqnrG0AFFoEt7oT61EKmEFB
  Ik5lYYeBQVCmeVyJ3hlKV9Uu5l0cUyx+mM0aBhakaHPQNAQTXKFx01p8VdteZOE3
  hzBWBOURtCmAEvF5OYiiAhF8J2a3iLd48soKqDirCmTCv2ZdlYTBoSUeh10aUAsg
  EsxBu24LUTi4S8sCAwEAAaNjMGEwDgYDVR0PAQH/BAQDAgGGMA8GA1UdEwEB/wQF
  MAMBAf8wHQYDVR0OBBYEFLE+w2kD+L9HAdSYJhoIAu9jZCvDMB8GA1UdIwQYMBaA
  FLE+w2kD+L9HAdSYJhoIAu9jZCvDMA0GCSqGSIb3DQEBBQUAA4IBAQAcGgaX3Nec
  nzyIZgYIVyHbIUf4KmeqvxgydkAQV8GK83rZEWWONfqe/EW1ntlMMUu4kehDLI6z
  eM7b41N5cdblIZQB2lWHmiRk9opmzN6cN82oNLFpmyPInngiK3BD41VHMWEZ71jF
  hS9OMPagMRYjyOfiZRYzy78aG6A9+MpeizGLYAiJLQwGXFK3xPkKmNEVX58Svnw2
  Yzi9RKR/5CYrCsSXaQ3pjOLAEFe4yHYSkVXySGnYvCoCWw9E1CAx2/S6cCZdkGCe
  vEsXCS+0yx5DaMkHJ8HSXPfqIbloEpw8nL+e/IBcm2PN7EeqJSdnoDfzAIJ9VNep
  +OkuE6N36B9K
  -----END CERTIFICATE-----
  === /C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Trusted Root G4
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              05:9b:1b:57:9e:8e:21:32:e2:39:07:bd:a7:77:75:5c
      Signature Algorithm: sha384WithRSAEncryption
          Validity
              Not Before: Aug  1 12:00:00 2013 GMT
              Not After : Jan 15 12:00:00 2038 GMT
          Subject: C=US, O=DigiCert Inc, OU=www.digicert.com, CN=DigiCert Trusted Root G4
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  EC:D7:E3:82:D2:71:5D:64:4C:DF:2E:67:3F:E7:BA:98:AE:1C:0F:4F
  SHA1 Fingerprint=DD:FB:16:CD:49:31:C9:73:A2:03:7D:3F:C8:3A:4D:7D:77:5D:05:E4
  SHA256 Fingerprint=55:2F:7B:DC:F1:A7:AF:9E:6C:E6:72:01:7F:4F:12:AB:F7:72:40:C7:8E:76:1A:C2:03:D1:D9:D2:0A:C8:99:88
  -----BEGIN CERTIFICATE-----
  MIIFkDCCA3igAwIBAgIQBZsbV56OITLiOQe9p3d1XDANBgkqhkiG9w0BAQwFADBi
  MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
  d3cuZGlnaWNlcnQuY29tMSEwHwYDVQQDExhEaWdpQ2VydCBUcnVzdGVkIFJvb3Qg
  RzQwHhcNMTMwODAxMTIwMDAwWhcNMzgwMTE1MTIwMDAwWjBiMQswCQYDVQQGEwJV
  UzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu
  Y29tMSEwHwYDVQQDExhEaWdpQ2VydCBUcnVzdGVkIFJvb3QgRzQwggIiMA0GCSqG
  SIb3DQEBAQUAA4ICDwAwggIKAoICAQC/5pBzaN675F1KPDAiMGkz7MKnJS7JIT3y
  ithZwuEppz1Yq3aaza57G4QNxDAf8xukOBbrVsaXbR2rsnnyyhHS5F/WBTxSD1If
  xp4VpX6+n6lXFllVcq9ok3DCsrp1mWpzMpTREEQQLt+C8weE5nQ7bXHiLQwb7iDV
  ySAdYyktzuxeTsiT+CFhmzTrBcZe7FsavOvJz82sNEBfsXpm7nfISKhmV1efVFiO
  DCu3T6cw2Vbuyntd463JT17lNecxy9qTXtyOj4DatpGYQJB5w3jHtrHEtWoYOAMQ
  jdjUN6QuBX2I9YI+EJFwq1WCQTLX2wRzKm6RAXwhTNS8rhsDdV14Ztk6MUSaM0C/
  CNdaSaTC5qmgZ92kJ7yhTzm1EVgX9yRcRo9k98FpiHaYdj1ZXUJ2h4mXaXpI8OCi
  EhtmmnTK3kse5w5jrubU75KSOp493ADkRSWJtppEGSt+wJS00mFt6zPZxd9LBADM
  fRyVw4/3IbKyEbe7f/LVjHAsQWCqsWMYRJUadmJ+9oCw++hkpjPRiQfhvbfmQ6QY
  uKZ3AeEPlAwhHbJUKSWJbOUOUlFHdL4mrLZBdd56rF+NP8m800ERElvlEFDrMcXK
  chYiCd98THU/Y+whX8QgUWtvsauGi0/C1kVfnSD8oR7FwI+isX4KJpn15GkvmB0t
  9dmpsh3lGwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB
  hjAdBgNVHQ4EFgQU7NfjgtJxXWRM3y5nP+e6mK4cD08wDQYJKoZIhvcNAQEMBQAD
  ggIBALth2X2pbL4XxJEbw6GiAI3jZGgPVs93rnD5/ZpKmbnJeFwMDF/k5hQpVgs2
  SV1EY+CtnJYYZhsjDT156W1r1lT40jzBQ0CuHVD1UvyQO7uYmWlrx8GnqGikJ9yd
  +SeuMIW59mdNOj6PWTkiU0TryF0Dyu1Qen1iIQqAyHNm0aAFYF/opbSnr6j3bTWc
  fFqK1qI4mfN4i/RN0iAL3gTujJtHgXINwBQy7zBZLq7gcfJW5GqXb5JQbZaNaHqa
  sjYUegbyJLkJEVDXCLG4iXqEI2FCKeWjzaIgQdfRnGTZ6iahixTXTBmyUEFxPT9N
  cCOGDErcgdLMMpSEDQgJlxxPwO5rIHQw0uA5NBCFIRUBCOhVMt5xSdkoF1BN5r5N
  0XWs0Mr7QbhDparTwwVETyw2m+L64kW4I1NsBm9nVX9GtUw/bihaeSbSpKhil9Ie
  4u1Ki7wb/UdKDd9nZn6yW0HQO+T0O/QEY+nvwlQAUaCKKsnOeMzV6ocEGLPOr0mI
  r/OSmbaz5mEP0oUA51Aa5BuVnRmhuZyxm7EAHu/QD09CbMkKvO5D+jpxpchNJqU1
  /YldvIViHTLSoCtU7ZpXwdv6EM8Zt4tKG48BtieVU+i2iW1bvGjUI+iLUaJW+fCm
  gKDWHrO8Dw9TdSmq6hN35N6MgSGtBxBHEa2HPQfRdbzP82Z+
  -----END CERTIFICATE-----

  ### Disig a.s.

  === /C=SK/L=Bratislava/O=Disig a.s./CN=CA Disig Root R2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              92:b8:88:db:b0:8a:c1:63
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jul 19 09:15:30 2012 GMT
              Not After : Jul 19 09:15:30 2042 GMT
          Subject: C=SK, L=Bratislava, O=Disig a.s., CN=CA Disig Root R2
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  B5:99:F8:AF:B0:94:F5:E3:20:D6:0A:AD:CE:4E:56:A4:2E:6E:42:ED
  SHA1 Fingerprint=B5:61:EB:EA:A4:DE:E4:25:4B:69:1A:98:A5:57:47:C2:34:C7:D9:71
  SHA256 Fingerprint=E2:3D:4A:03:6D:7B:70:E9:F5:95:B1:42:20:79:D2:B9:1E:DF:BB:1F:B6:51:A0:63:3E:AA:8A:9D:C5:F8:07:03
  -----BEGIN CERTIFICATE-----
  MIIFaTCCA1GgAwIBAgIJAJK4iNuwisFjMA0GCSqGSIb3DQEBCwUAMFIxCzAJBgNV
  BAYTAlNLMRMwEQYDVQQHEwpCcmF0aXNsYXZhMRMwEQYDVQQKEwpEaXNpZyBhLnMu
  MRkwFwYDVQQDExBDQSBEaXNpZyBSb290IFIyMB4XDTEyMDcxOTA5MTUzMFoXDTQy
  MDcxOTA5MTUzMFowUjELMAkGA1UEBhMCU0sxEzARBgNVBAcTCkJyYXRpc2xhdmEx
  EzARBgNVBAoTCkRpc2lnIGEucy4xGTAXBgNVBAMTEENBIERpc2lnIFJvb3QgUjIw
  ggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCio8QACdaFXS1tFPbCw3Oe
  NcJxVX6B+6tGUODBfEl45qt5WDza/3wcn9iXAng+a0EE6UG9vgMsRfYvZNSrXaNH
  PWSb6WiaxswbP7q+sos0Ai6YVRn8jG+qX9pMzk0DIaPY0jSTVpbLTAwAFjxfGs3I
  x2ymrdMxp7zo5eFm1tL7A7RBZckQrg4FY8aAamkw/dLukO8NJ9+flXP04SXabBbe
  QTg06ov80egEFGEtQX6sx3dOy1FU+16SGBsEWmjGycT6txOgmLcRK7fWV8x8nhfR
  yyX+hk4kLlYMeE2eARKmK6cBZW58Yh2EhN/qwGu1pSqVg8NTEQxzHQuyRpDRQjrO
  QG6Vrf/GlK1ul4SOfW+eioANSW1z4nuSHsPzwfPrLgVv2RvPN3YEyLRa5Beny912
  H9AZdugsBbPWnDTYltxhh5EF5EQIM8HauQhl1K6yNg3ruji6DOWbnuuNZt2Zz9aJ
  QfYEkoopKW1rOhzndX0CcQ7zwOe9yxndnWCywmZgtrEE7snmhrmaZkCo5xHtgUUD
  i/ZnWejBBhG93c+AAk9lQHhcR1DIm+YfgXvkRKhbhZri3lrVx/k6RGZL5DJUfORs
  nLMOPReisjQS1n6yqEm70XooQL6iFh/f5DcfEXP7kAplQ6INfPgGAVUzfbANuPT1
  rqVCV3w2EYx7XsQDnYx5nQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1Ud
  DwEB/wQEAwIBBjAdBgNVHQ4EFgQUtZn4r7CU9eMg1gqtzk5WpC5uQu0wDQYJKoZI
  hvcNAQELBQADggIBACYGXnDnZTPIgm7ZnBc6G3pmsgH2eDtpXi/q/075KMOYKmFM
  tCQSin1tERT3nLXK5ryeJ45MGcipvXrA1zYObYVybqjGom32+nNjf7xueQgcnYqf
  GopTpti72TVVsRHFqQOzVju5hJMiXn7B9hJSi+osZ7z+Nkz1uM/Rs0mSO9MpDpkb
  lvdhuDvEK7Z4bLQjb/D907JedR+Zlais9trhxTF7+9FGs9K8Z7RiVLoJ92Owk6Ka
  +elSLotgEqv89WBW7xBci8QaQtyDW2QOy7W81k/BfDxujRNt+3vrMNDcTa/F1bal
  TFtxyegxvug4BkihGuLq0t4SOVga/4AOgnXmt8kHbA7v/zjxmHHEt38OFdAlab0i
  nSvtBfZGR6ztwPDUO+Ls7pZbkBNOHlY667DvlruWIxG68kOGdGSVyCh13x01utI3
  gzhTODY7z2zp+WsO0PsE6E9312UBeIYMej4hYvF/Y3EMyZ9E26gnonW+boE+18Dr
  G5gPcFw0sorMwIUY6256s/daoQe/qUKS82Ail+QUoQebTnbAjn39pCXHR+3/H3Os
  zMOl6W8KjptlwlCFtaOgUxLMVYdh84GuEEZhvUQhuMI9dM9+JDX6HAcOmz0iyu8x
  L4ysEr3vQCj8KWefshNPZiTEUxnpHikV7+ZtsH8tZ/3zbBt1RqPlShfppNcL
  -----END CERTIFICATE-----

  ### E-Tu\U011Fra EBG Bili\U015Fim Teknolojileri ve Hizmetleri A.\U015E.

  === /C=TR/L=Ankara/O=E-Tu\xC4\x9Fra EBG Bili\xC5\x9Fim Teknolojileri ve Hizmetleri A.\xC5\x9E./OU=E-Tugra Sertifikasyon Merkezi/CN=E-Tugra Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 7667447206703254355 (0x6a683e9c519bcb53)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Mar  5 12:09:48 2013 GMT
              Not After : Mar  3 12:09:48 2023 GMT
          Subject: C=TR, L=Ankara, O=E-Tu\xC4\x9Fra EBG Bili\xC5\x9Fim Teknolojileri ve Hizmetleri A.\xC5\x9E., OU=E-Tugra Sertifikasyon Merkezi, CN=E-Tugra Certification Authority
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  2E:E3:DB:B2:49:D0:9C:54:79:5C:FA:27:2A:FE:CC:4E:D2:E8:4E:54
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Authority Key Identifier:
                  keyid:2E:E3:DB:B2:49:D0:9C:54:79:5C:FA:27:2A:FE:CC:4E:D2:E8:4E:54

              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
  SHA1 Fingerprint=51:C6:E7:08:49:06:6E:F3:92:D4:5C:A0:0D:6D:A3:62:8F:C3:52:39
  SHA256 Fingerprint=B0:BF:D5:2B:B0:D7:D9:BD:92:BF:5D:4D:C1:3D:A2:55:C0:2C:54:2F:37:83:65:EA:89:39:11:F5:5E:55:F2:3C
  -----BEGIN CERTIFICATE-----
  MIIGSzCCBDOgAwIBAgIIamg+nFGby1MwDQYJKoZIhvcNAQELBQAwgbIxCzAJBgNV
  BAYTAlRSMQ8wDQYDVQQHDAZBbmthcmExQDA+BgNVBAoMN0UtVHXEn3JhIEVCRyBC
  aWxpxZ9pbSBUZWtub2xvamlsZXJpIHZlIEhpem1ldGxlcmkgQS7Fni4xJjAkBgNV
  BAsMHUUtVHVncmEgU2VydGlmaWthc3lvbiBNZXJrZXppMSgwJgYDVQQDDB9FLVR1
  Z3JhIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTEzMDMwNTEyMDk0OFoXDTIz
  MDMwMzEyMDk0OFowgbIxCzAJBgNVBAYTAlRSMQ8wDQYDVQQHDAZBbmthcmExQDA+
  BgNVBAoMN0UtVHXEn3JhIEVCRyBCaWxpxZ9pbSBUZWtub2xvamlsZXJpIHZlIEhp
  em1ldGxlcmkgQS7Fni4xJjAkBgNVBAsMHUUtVHVncmEgU2VydGlmaWthc3lvbiBN
  ZXJrZXppMSgwJgYDVQQDDB9FLVR1Z3JhIENlcnRpZmljYXRpb24gQXV0aG9yaXR5
  MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA4vU/kwVRHoViVF56C/UY
  B4Oufq9899SKa6VjQzm5S/fDxmSJPZQuVIBSOTkHS0vdhQd2h8y/L5VMzH2nPbxH
  D5hw+IyFHnSOkm0bQNGZDbt1bsipa5rAhDGvykPL6ys06I+XawGb1Q5KCKpbknSF
  Q9OArqGIW66z6l7LFpp3RMih9lRozt6Plyu6W0ACDGQXwLWTzeHxE2bODHnv0ZEo
  q1+gElIwcxmOj+GMB6LDu0rw6h8VqO4lzKRG+Bsi77MOQ7osJLjFLFzUHPhdZL3D
  k14opz8n8Y4e0ypQBaNV2cvnOVPAmJ6MVGKLJrD3fY185MaeZkJVgkfnsliNZvcH
  fC425lAcP9tDJMW/hkd5s3kc91r0E+xs+D/iWR+V7kI+ua2oMoVJl0b+SzGPWsut
  dEcf6ZG33ygEIqDUD13ieU/qbIWGvaimzuT6w+Gzrt48Ue7LE3wBf4QOXVGUnhMM
  ti6lTPk5cDZvlsouDERVxcr6XQKj39ZkjFqzAQqptQpHF//vkUAqjqFGOjGY5RH8
  zLtJVor8udBhmm9lbObDyz51Sf6Pp+KJxWfXnUYTTjF2OySznhFlhqt/7x3U+Lzn
  rFpct1pHXFXOVbQicVtbC/DP3KBhZOqp12gKY6fgDT+gr9Oq0n7vUaDmUStVkhUX
  U8u3Zg5mTPj5dUyQ5xJwx0UCAwEAAaNjMGEwHQYDVR0OBBYEFC7j27JJ0JxUeVz6
  Jyr+zE7S6E5UMA8GA1UdEwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAULuPbsknQnFR5
  XPonKv7MTtLoTlQwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBCwUAA4ICAQAF
  Nzr0TbdF4kV1JI+2d1LoHNgQk2Xz8lkGpD4eKexd0dCrfOAKkEh47U6YA5n+KGCR
  HTAduGN8qOY1tfrTYXbm1gdLymmasoR6d5NFFxWfJNCYExL/u6Au/U5Mh/jOXKqY
  GwXgAEZKgoClM4so3O0409/lPun++1ndYYRP0lSWE2ETPo+Aab6TR7U1Q9Jauz1c
  77NCR807VRMGsAnb/WP2OogKmW9+4c4bU2pEZiNRCHu8W1Ki/QY3OEBhj0qWuJA3
  +GbHeJAAFS6LrVE1Uweoa2iu+U48BybNCAVwzDk/dr2l02cmAYamU9JgO3xDf1WK
  vJUawSg5TB9D0pH0clmKuVb8P7Sd2nCcdlqMQ1DujjByTd//SffGqWfZbawCEeI6
  FiWnWAjLb1NBnEg4R2gz0dfHj9R0IdTDBZB6/86WiLEVKV0jq9BgoRJP3vQXzTLl
  yb/IQ639Lo7xr+L0mPoSHyDYwKcMhcWQ9DstliaxLL5Mq+ux0orJ23gTDx4JnW2P
  AJ8C2sH6H3p6CcRK5ogql5+Ji/03X186zjhZhkuvcQu02PJwT58yE+Owp1fl2tpD
  y4Q08ijE6m30Ku/Ba3ba+367hTzSU8JNvnHhRdH9I2cNE3X7z2VnIp2usAnRCf8d
  NL/+I5c30jn6PQ0GC7TbO6Orb1wdtn7os4I07QZcJA==
  -----END CERTIFICATE-----

  ### eMudhra Inc

  === /C=US/OU=emSign PKI/O=eMudhra Inc/CN=emSign ECC Root CA - C3
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              7b:71:b6:82:56:b8:12:7c:9c:a8
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Feb 18 18:30:00 2018 GMT
              Not After : Feb 18 18:30:00 2043 GMT
          Subject: C=US, OU=emSign PKI, O=eMudhra Inc, CN=emSign ECC Root CA - C3
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  FB:5A:48:D0:80:20:40:F2:A8:E9:00:07:69:19:77:A7:E6:C3:F4:CF
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=B6:AF:43:C2:9B:81:53:7D:F6:EF:6B:C3:1F:1F:60:15:0C:EE:48:66
  SHA256 Fingerprint=BC:4D:80:9B:15:18:9D:78:DB:3E:1D:8C:F4:F9:72:6A:79:5D:A1:64:3C:A5:F1:35:8E:1D:DB:0E:DC:0D:7E:B3
  -----BEGIN CERTIFICATE-----
  MIICKzCCAbGgAwIBAgIKe3G2gla4EnycqDAKBggqhkjOPQQDAzBaMQswCQYDVQQG
  EwJVUzETMBEGA1UECxMKZW1TaWduIFBLSTEUMBIGA1UEChMLZU11ZGhyYSBJbmMx
  IDAeBgNVBAMTF2VtU2lnbiBFQ0MgUm9vdCBDQSAtIEMzMB4XDTE4MDIxODE4MzAw
  MFoXDTQzMDIxODE4MzAwMFowWjELMAkGA1UEBhMCVVMxEzARBgNVBAsTCmVtU2ln
  biBQS0kxFDASBgNVBAoTC2VNdWRocmEgSW5jMSAwHgYDVQQDExdlbVNpZ24gRUND
  IFJvb3QgQ0EgLSBDMzB2MBAGByqGSM49AgEGBSuBBAAiA2IABP2lYa57JhAd6bci
  MK4G9IGzsUJxlTm801Ljr6/58pc1kjZGDoeVjbk5Wum739D+yAdBPLtVb4Ojavti
  sIGJAnB9SMVK4+kiVCJNk7tCDK93nCOmfddhEc5lx/h//vXyqaNCMEAwHQYDVR0O
  BBYEFPtaSNCAIEDyqOkAB2kZd6fmw/TPMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMB
  Af8EBTADAQH/MAoGCCqGSM49BAMDA2gAMGUCMQC02C8Cif22TGK6Q04ThHK1rt0c
  3ta13FaPWEBaLd4gTCKDypOofu4SQMfWh0/434UCMBwUZOR8loMRnLDRWmFLpg9J
  0wD8ofzkpf9/rdcw0Md3f76BB1UwUCAU9Vc4CqgxUQ==
  -----END CERTIFICATE-----
  === /C=US/OU=emSign PKI/O=eMudhra Inc/CN=emSign Root CA - C1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              ae:cf:00:ba:c4:cf:32:f8:43:b2
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Feb 18 18:30:00 2018 GMT
              Not After : Feb 18 18:30:00 2043 GMT
          Subject: C=US, OU=emSign PKI, O=eMudhra Inc, CN=emSign Root CA - C1
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  FE:A1:E0:70:1E:2A:03:39:52:5A:42:BE:5C:91:85:7A:18:AA:4D:B5
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=E7:2E:F1:DF:FC:B2:09:28:CF:5D:D4:D5:67:37:B1:51:CB:86:4F:01
  SHA256 Fingerprint=12:56:09:AA:30:1D:A0:A2:49:B9:7A:82:39:CB:6A:34:21:6F:44:DC:AC:9F:39:54:B1:42:92:F2:E8:C8:60:8F
  -----BEGIN CERTIFICATE-----
  MIIDczCCAlugAwIBAgILAK7PALrEzzL4Q7IwDQYJKoZIhvcNAQELBQAwVjELMAkG
  A1UEBhMCVVMxEzARBgNVBAsTCmVtU2lnbiBQS0kxFDASBgNVBAoTC2VNdWRocmEg
  SW5jMRwwGgYDVQQDExNlbVNpZ24gUm9vdCBDQSAtIEMxMB4XDTE4MDIxODE4MzAw
  MFoXDTQzMDIxODE4MzAwMFowVjELMAkGA1UEBhMCVVMxEzARBgNVBAsTCmVtU2ln
  biBQS0kxFDASBgNVBAoTC2VNdWRocmEgSW5jMRwwGgYDVQQDExNlbVNpZ24gUm9v
  dCBDQSAtIEMxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz+upufGZ
  BczYKCFK83M0UYRWEPWgTywS4/oTmifQz/l5GnRfHXk5/Fv4cI7gklL35CX5VIPZ
  HdPIWoU/Xse2B+4+wM6ar6xWQio5JXDWv7V7Nq2s9nPczdcdioOl+yuQFTdrHCZH
  3DspVpNqs8FqOp099cGXOFgFixwR4+S0uF2FHYP+eF8LRWgYSKVGczQ7/g/IdrvH
  GPMF0Ybzhe3nudkyrVWIzqa2kbBPrH4VI5b2P/AgNBbeCsbEBEV5f6f9vtKppa+c
  xSMq9zwhbL2vj07FOrLzNBL834AaSaTUqZX3noleoomslMuoaJuvimUnzYnu3Yy1
  aylwQ6BpC+S5DwIDAQABo0IwQDAdBgNVHQ4EFgQU/qHgcB4qAzlSWkK+XJGFehiq
  TbUwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEL
  BQADggEBAMJKVvoVIXsoounlHfv4LcQ5lkFMOycsxGwYFYDGrK9HWS8mC+M2sO87
  /kOXSTKZEhVb3xEp/6tT+LvBeA+snFOvV71ojD1pM/CjoCNjO2RnIkSt1XHLVip4
  kqNPEjE2NuLe/gDEo2APJ62gsIq1NnpSob0n9CAnYuhNlCQT5AoE6TyrLshDCUrG
  YQTlSTR+08TI9Q/Aqum6VF7zYytPT1DU/rl7mYw9wC68AivTxEDkigcxHpvOJpkT
  +xHqmiIMERnHXhuBUDDIlhJu58tBf5E7oke3VIAb3ADMmpDqw8NQBmIMMMAVSKeo
  WXzhriKi4gp6D/piq1JM4fHfyr6DDUI=
  -----END CERTIFICATE-----

  ### eMudhra Technologies Limited

  === /C=IN/OU=emSign PKI/O=eMudhra Technologies Limited/CN=emSign ECC Root CA - G3
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              3c:f6:07:a9:68:70:0e:da:8b:84
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Feb 18 18:30:00 2018 GMT
              Not After : Feb 18 18:30:00 2043 GMT
          Subject: C=IN, OU=emSign PKI, O=eMudhra Technologies Limited, CN=emSign ECC Root CA - G3
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  7C:5D:02:84:13:D4:CC:8A:9B:81:CE:17:1C:2E:29:1E:9C:48:63:42
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=30:43:FA:4F:F2:57:DC:A0:C3:80:EE:2E:58:EA:78:B2:3F:E6:BB:C1
  SHA256 Fingerprint=86:A1:EC:BA:08:9C:4A:8D:3B:BE:27:34:C6:12:BA:34:1D:81:3E:04:3C:F9:E8:A8:62:CD:5C:57:A3:6B:BE:6B
  -----BEGIN CERTIFICATE-----
  MIICTjCCAdOgAwIBAgIKPPYHqWhwDtqLhDAKBggqhkjOPQQDAzBrMQswCQYDVQQG
  EwJJTjETMBEGA1UECxMKZW1TaWduIFBLSTElMCMGA1UEChMcZU11ZGhyYSBUZWNo
  bm9sb2dpZXMgTGltaXRlZDEgMB4GA1UEAxMXZW1TaWduIEVDQyBSb290IENBIC0g
  RzMwHhcNMTgwMjE4MTgzMDAwWhcNNDMwMjE4MTgzMDAwWjBrMQswCQYDVQQGEwJJ
  TjETMBEGA1UECxMKZW1TaWduIFBLSTElMCMGA1UEChMcZU11ZGhyYSBUZWNobm9s
  b2dpZXMgTGltaXRlZDEgMB4GA1UEAxMXZW1TaWduIEVDQyBSb290IENBIC0gRzMw
  djAQBgcqhkjOPQIBBgUrgQQAIgNiAAQjpQy4LRL1KPOxst3iAhKAnjlfSU2fySU0
  WXTsuwYc58Byr+iuL+FBVIcUqEqy6HyC5ltqtdyzdc6LBtCGI79G1Y4PPwT01xyS
  fvalY8L1X44uT6EYGQIrMgqCZH0Wk9GjQjBAMB0GA1UdDgQWBBR8XQKEE9TMipuB
  zhccLikenEhjQjAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAKBggq
  hkjOPQQDAwNpADBmAjEAvvNhzwIQHWSVB7gYboiFBS+DCBeQyh+KTOgNG3qxrdWB
  CUfvO6wIBHxcmbHtRwfSAjEAnbpV/KlK6O3t5nYBQnvI+GDZjVGLVTv7jHvrZQnD
  +JbNR6iC8hZVdyR+EhCVBCyj
  -----END CERTIFICATE-----
  === /C=IN/OU=emSign PKI/O=eMudhra Technologies Limited/CN=emSign Root CA - G1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              31:f5:e4:62:0c:6c:58:ed:d6:d8
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Feb 18 18:30:00 2018 GMT
              Not After : Feb 18 18:30:00 2043 GMT
          Subject: C=IN, OU=emSign PKI, O=eMudhra Technologies Limited, CN=emSign Root CA - G1
          X509v3 extensions:
              X509v3 Subject Key Identifier:
                  FB:EF:0D:86:9E:B0:E3:DD:A9:B9:F1:21:17:7F:3E:FC:F0:77:2B:1A
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
  SHA1 Fingerprint=8A:C7:AD:8F:73:AC:4E:C1:B5:75:4D:A5:40:F4:FC:CF:7C:B5:8E:8C
  SHA256 Fingerprint=40:F6:AF:03:46:A9:9A:A1:CD:1D:55:5A:4E:9C:CE:62:C7:F9:63:46:03:EE:40:66:15:83:3D:C8:C8:D0:03:67
  -----BEGIN CERTIFICATE-----
  MIIDlDCCAnygAwIBAgIKMfXkYgxsWO3W2DANBgkqhkiG9w0BAQsFADBnMQswCQYD
  VQQGEwJJTjETMBEGA1UECxMKZW1TaWduIFBLSTElMCMGA1UEChMcZU11ZGhyYSBU
  ZWNobm9sb2dpZXMgTGltaXRlZDEcMBoGA1UEAxMTZW1TaWduIFJvb3QgQ0EgLSBH
  MTAeFw0xODAyMTgxODMwMDBaFw00MzAyMTgxODMwMDBaMGcxCzAJBgNVBAYTAklO
  MRMwEQYDVQQLEwplbVNpZ24gUEtJMSUwIwYDVQQKExxlTXVkaHJhIFRlY2hub2xv
  Z2llcyBMaW1pdGVkMRwwGgYDVQQDExNlbVNpZ24gUm9vdCBDQSAtIEcxMIIBIjAN
  BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAk0u76WaK7p1b1TST0Bsew+eeuGQz
  f2N4aLTNLnF115sgxk0pvLZoYIr3IZpWNVrzdr3YzZr/k1ZLpVkGoZM0Kd0WNHVO
  8oG0x5ZOrRkVUkr+PHB1cM2vK6sVmjM8qrOLqs1D/fXqcP/tzxE7lM5OMhbTI0Aq
  d7OvPAEsbO2ZLIvZTmmYsvePQbAyeGHWDV/D+qJAkh1cF+ZwPjXnorfCYuKrpDhM
  tTk1b+oDafo6VGiFbdbyL0NVHpENDtjVaqSW0RM8LHhQ6DqS0hdW5TUaQBw+jSzt
  Od9C4INBdN+jzcKGYEho42kLVACL5HZpIQ15TjQIXhTCzLG3rdd8cIrHhQIDAQAB
  o0IwQDAdBgNVHQ4EFgQU++8Nhp6w492pufEhF38+/PB3KxowDgYDVR0PAQH/BAQD
  AgEGMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAFn/8oz1h31x
  PaOfG1vR2vjTnGs2vZupYeveFix0PZ7mddrXuqe8QhfnPZHr5X3dPpzxz5KsbEjM
  wiI/aTvFthUvozXGaCocV685743QNcMYDHsAVhzNixl03r4PEuDQqqE/AjSxcM6d
  GNYIAwlG7mDgfrbESQRRfXBgvKqy/3lyeqYdPV8q+Mri/Tm3R7nrft8EI6/6nAYH
  6ftjk4BAtcZsCjEozgyfz7MjNYBBjWzEN3uBL4ChQEKF6dk4jeihU80Bv2noWgby
  RQuQ+q7hv53yrlc8pa6yVvSLZUDp/TGBLPQ5Cdjua6e0ph0VpZj3AYHYhX3zUVxx
  iN66zB+Afko=
  -----END CERTIFICATE-----

  ### Entrust, Inc.

  === /C=US/O=Entrust, Inc./OU=See www.entrust.net/legal-terms/OU=(c) 2009 Entrust, Inc. - for authorized use only/CN=Entrust Root Certification Authority - G2
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 1246989352 (0x4a538c28)
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Jul  7 17:25:54 2009 GMT
              Not After : Dec  7 17:55:54 2030 GMT
          Subject: C=US, O=Entrust, Inc., OU=See www.entrust.net/legal-terms, OU=(c) 2009 Entrust, Inc. - for authorized use only, CN=Entrust Root Certification Authority - G2
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  6A:72:26:7A:D0:1E:EF:7D:E7:3B:69:51:D4:6C:8D:9F:90:12:66:AB
  SHA1 Fingerprint=8C:F4:27:FD:79:0C:3A:D1:66:06:8D:E8:1E:57:EF:BB:93:22:72:D4
  SHA256 Fingerprint=43:DF:57:74:B0:3E:7F:EF:5F:E4:0D:93:1A:7B:ED:F1:BB:2E:6B:42:73:8C:4E:6D:38:41:10:3D:3A:A7:F3:39
  -----BEGIN CERTIFICATE-----
  MIIEPjCCAyagAwIBAgIESlOMKDANBgkqhkiG9w0BAQsFADCBvjELMAkGA1UEBhMC
  VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50
  cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDA5IEVudHJ1c3Qs
  IEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEyMDAGA1UEAxMpRW50cnVz
  dCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRzIwHhcNMDkwNzA3MTcy
  NTU0WhcNMzAxMjA3MTc1NTU0WjCBvjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVu
  dHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwt
  dGVybXMxOTA3BgNVBAsTMChjKSAyMDA5IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0
  aG9yaXplZCB1c2Ugb25seTEyMDAGA1UEAxMpRW50cnVzdCBSb290IENlcnRpZmlj
  YXRpb24gQXV0aG9yaXR5IC0gRzIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK
  AoIBAQC6hLZy254Ma+KZ6TABp3bqMriVQRrJ2mFOWHLP/vaCeb9zYQYKpSfYs1/T
  RU4cctZOMvJyig/3gxnQaoCAAEUesMfnmr8SVycco2gvCoe9amsOXmXzHHfV1IWN
  cCG0szLni6LVhjkCsbjSR87kyUnEO6fe+1R9V77w6G7CebI6C1XiUJgWMhNcL3hW
  wcKUs/Ja5CeanyTXxuzQmyWC48zCxEXFjJd6BmsqEZ+pCm5IO2/b1BEZQvePB7/1
  U1+cPvQXLOZprE4yTGJ36rfo5bs0vBmLrpxR57d+tVOxMyLlbc9wPBr64ptntoP0
  jaWvYkxN4FisZDQSA/i2jZRjJKRxAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAP
  BgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRqciZ60B7vfec7aVHUbI2fkBJmqzAN
  BgkqhkiG9w0BAQsFAAOCAQEAeZ8dlsa2eT8ijYfThwMEYGprmi5ZiXMRrEPR9RP/
  jTkrwPK9T3CMqS/qF8QLVJ7UG5aYMzyorWKiAHarWWluBh1+xLlEjZivEtRh2woZ
  Rkfz6/djwUAFQKXSt/S1mja/qYh2iARVBCuch38aNzx+LaUa2NSJXsq9rD1s2G2v
  1fN2D807iDginWyTmsQ9v4IbZT+mD12q/OWyFcq1rca8PdCE6OoGcrBNOTJ4vz4R
  nAuknZoh8/CbCzB428Hch0P+vGOaysXCHMnHjf87ElgI5rY97HosTvuDls4MPGmH
  VHOkc8KT/1EQrBVUAdj8BbGJoX90g5pJ19xOe4pIb4tF9g==
  -----END CERTIFICATE-----
  === /C=US/O=Entrust, Inc./OU=See www.entrust.net/legal-terms/OU=(c) 2012 Entrust, Inc. - for authorized use only/CN=Entrust Root Certification Authority - EC1
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              a6:8b:79:29:00:00:00:00:50:d0:91:f9
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Dec 18 15:25:36 2012 GMT
              Not After : Dec 18 15:55:36 2037 GMT
          Subject: C=US, O=Entrust, Inc., OU=See www.entrust.net/legal-terms, OU=(c) 2012 Entrust, Inc. - for authorized use only, CN=Entrust Root Certification Authority - EC1
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  B7:63:E7:1A:DD:8D:E9:08:A6:55:83:A4:E0:6A:50:41:65:11:42:49
  SHA1 Fingerprint=20:D8:06:40:DF:9B:25:F5:12:25:3A:11:EA:F7:59:8A:EB:14:B5:47
  SHA256 Fingerprint=02:ED:0E:B2:8C:14:DA:45:16:5C:56:67:91:70:0D:64:51:D7:FB:56:F0:B2:AB:1D:3B:8E:B0:70:E5:6E:DF:F5
  -----BEGIN CERTIFICATE-----
  MIIC+TCCAoCgAwIBAgINAKaLeSkAAAAAUNCR+TAKBggqhkjOPQQDAzCBvzELMAkG
  A1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3
  d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDEyIEVu
  dHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEzMDEGA1UEAxMq
  RW50cnVzdCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRUMxMB4XDTEy
  MTIxODE1MjUzNloXDTM3MTIxODE1NTUzNlowgb8xCzAJBgNVBAYTAlVTMRYwFAYD
  VQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQLEx9TZWUgd3d3LmVudHJ1c3QubmV0
  L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykgMjAxMiBFbnRydXN0LCBJbmMuIC0g
  Zm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxMzAxBgNVBAMTKkVudHJ1c3QgUm9vdCBD
  ZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEVDMTB2MBAGByqGSM49AgEGBSuBBAAi
  A2IABIQTydC6bUF74mzQ61VfZgIaJPRbiWlH47jCffHyAsWfoPZb1YsGGYZPUxBt
  ByQnoaD41UcZYUx9ypMn6nQM72+WCf5j7HBdNq1nd67JnXxVRDqiY1Ef9eNi1KlH
  Bz7MIKNCMEAwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0O
  BBYEFLdj5xrdjekIplWDpOBqUEFlEUJJMAoGCCqGSM49BAMDA2cAMGQCMGF52OVC
  R98crlOZF7ZvHH3hvxGU0QOIdeSNiaSKd0bebWHvAvX7td/M/k7//qnmpwIwW5nX
  hTcGtXsI/esni0qU+eH6p44mCOh8kmhtc9hvJqwhAriZtyZBWyVgrtBIGu4G
  -----END CERTIFICATE-----
  === /C=US/O=Entrust, Inc./OU=See www.entrust.net/legal-terms/OU=(c) 2015 Entrust, Inc. - for authorized use only/CN=Entrust Root Certification Authority - G4
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              d9:b5:43:7f:af:a9:39:0f:00:00:00:00:55:65:ad:58
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: May 27 11:11:16 2015 GMT
              Not After : Dec 27 11:41:16 2037 GMT
          Subject: C=US, O=Entrust, Inc., OU=See www.entrust.net/legal-terms, OU=(c) 2015 Entrust, Inc. - for authorized use only, CN=Entrust Root Certification Authority - G4
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  9F:38:C4:56:23:C3:39:E8:A0:71:6C:E8:54:4C:E4:E8:3A:B1:BF:67
  SHA1 Fingerprint=14:88:4E:86:26:37:B0:26:AF:59:62:5C:40:77:EC:35:29:BA:96:01
  SHA256 Fingerprint=DB:35:17:D1:F6:73:2A:2D:5A:B9:7C:53:3E:C7:07:79:EE:32:70:A6:2F:B4:AC:42:38:37:24:60:E6:F0:1E:88
  -----BEGIN CERTIFICATE-----
  MIIGSzCCBDOgAwIBAgIRANm1Q3+vqTkPAAAAAFVlrVgwDQYJKoZIhvcNAQELBQAw
  gb4xCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQL
  Ex9TZWUgd3d3LmVudHJ1c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykg
  MjAxNSBFbnRydXN0LCBJbmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxMjAw
  BgNVBAMTKUVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEc0
  MB4XDTE1MDUyNzExMTExNloXDTM3MTIyNzExNDExNlowgb4xCzAJBgNVBAYTAlVT
  MRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQLEx9TZWUgd3d3LmVudHJ1
  c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykgMjAxNSBFbnRydXN0LCBJ
  bmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxMjAwBgNVBAMTKUVudHJ1c3Qg
  Um9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEc0MIICIjANBgkqhkiG9w0B
  AQEFAAOCAg8AMIICCgKCAgEAsewsQu7i0TD/pZJH4i3DumSXbcr3DbVZwbPLqGgZ
  2K+EbTBwXX7zLtJTmeH+H17ZSK9dE43b/2MzTdMAArzE+NEGCJR5WIoV3imz/f3E
  T+iq4qA7ec2/a0My3dl0ELn39GjUu9CH1apLiipvKgS1sqbHoHrmSKvS0VnM1n4j
  5pds8ELl3FFLFUHtSUrJ3hCX1nbB76W1NhSXNdh4IjVS70O92yfbYVaCNNzLiGAM
  C1rlLAHGVK/XqsEQe9IFWrhAnoanw5CGAlZSCXqc0ieCU0plUmr1POeo8pyvi73T
  DtTUXm6Hnmo9RR3RXRv06QqsYJn7ibT/mCzPfB3pAqoEmh643IhuJbNsZvc8kPNX
  wbMv9W3y+8qh+CmdRouzavbmZwe+LGcKKh9asj5XxNMhIWNlUpEbsZmOeX7m640A
  2Vqq6nPopIICR5b+W45UYaPrL0swsIsjdXJ8ITzI9vF01Bx7owVV7rtNOzK+mndm
  nqxpkCIHH2E6lr7lmk/MBTwoWdPBDFSoWWG9yHJM6Nyfh3+9nEg2XpWjDrk4JFX8
  dWbrAuMINClKxuMrLzOg2qOGpRKX/YAr2hRC45K9PvJdXmd0LhyIRyk0X+IyqJwl
  N4y6mACXi0mWHv0liqzc2thddG5msP9E36EYxr5ILzeUePiVSj9/E15dWf10hkNj
  c0kCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYD
  VR0OBBYEFJ84xFYjwznooHFs6FRM5Og6sb9nMA0GCSqGSIb3DQEBCwUAA4ICAQAS
  5UKme4sPDORGpbZgQIeMJX6tuGguW8ZAdjwD+MlZ9POrYs4QjbRaZIxowLByQzTS
  Gwv2LFPSypBLhmb8qoMi9IsabyZIrHZ3CL/FmFz0Jomee8O5ZDIBf9PD3Vht7LGr
  hFV0d4QEJ1JrhkzO3bll/9bGXp+aEJlLdWr+aumXIOTkdnrG0CSqkM0gkLpHZPt/
  B7NTeLUKYvJzQ85BK4FqLoUWlFPUa19yIqtRLULVAJyZv967lDtX/Zr1hstWO1uI
  AeV8KEsD+UmDfLJ/fOPtjqF/YFOOVZ1QNBIPt5d7bIdKROf1beyAN/BYGW5KaHbw
  H5Lk6rWS02FREAutp9lfx1/cH6NcjKF+m7ee01ZvZl4HliDtC3T7Zk6LERXpgUl+
  b7DUUH8i119lAg2m9IUe2K4GS0qn0jFmwvjO5QimpAKWRGhXxNUzzxkvFMSUHHuk
  2fCfDrGA4tGeEWSpiBE6doLlYsKA2KSD7ZPvfC+QsDJMlhVoSFLUmQjAJOgc47Ol
  IQ6SwJAfzyBfyjs4x7dtOvPmRLgOMWuIjnDrnBdSqEGULoe256YSxXXfW8AKbnuk
  5F6G+TaU33fD6Q3AOfF5u0aOq0NZJ7cguyPpVkAh7DE9ZapD8j3fcEThuk0mEDuY
  n/PIjhs4ViFqUZPTkcpG2om3PVODLAgfi49T3f+sHw==
  -----END CERTIFICATE-----
  === /C=US/O=Entrust, Inc./OU=www.entrust.net/CPS is incorporated by reference/OU=(c) 2006 Entrust, Inc./CN=Entrust Root Certification Authority
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 1164660820 (0x456b5054)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Nov 27 20:23:42 2006 GMT
              Not After : Nov 27 20:53:42 2026 GMT
          Subject: C=US, O=Entrust, Inc., OU=www.entrust.net/CPS is incorporated by reference, OU=(c) 2006 Entrust, Inc., CN=Entrust Root Certification Authority
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Private Key Usage Period:
                  Not Before: Nov 27 20:23:42 2006 GMT, Not After: Nov 27 20:53:42 2026 GMT
              X509v3 Authority Key Identifier:
                  keyid:68:90:E4:67:A4:A6:53:80:C7:86:66:A4:F1:F7:4B:43:FB:84:BD:6D

              X509v3 Subject Key Identifier:
                  68:90:E4:67:A4:A6:53:80:C7:86:66:A4:F1:F7:4B:43:FB:84:BD:6D
              1.2.840.113533.7.65.0:
                  0...V7.1:4.0....
  SHA1 Fingerprint=B3:1E:B1:B7:40:E3:6C:84:02:DA:DC:37:D4:4D:F5:D4:67:49:52:F9
  SHA256 Fingerprint=73:C1:76:43:4F:1B:C6:D5:AD:F4:5B:0E:76:E7:27:28:7C:8D:E5:76:16:C1:E6:E6:14:1A:2B:2C:BC:7D:8E:4C
  -----BEGIN CERTIFICATE-----
  MIIEkTCCA3mgAwIBAgIERWtQVDANBgkqhkiG9w0BAQUFADCBsDELMAkGA1UEBhMC
  VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xOTA3BgNVBAsTMHd3dy5lbnRydXN0
  Lm5ldC9DUFMgaXMgaW5jb3Jwb3JhdGVkIGJ5IHJlZmVyZW5jZTEfMB0GA1UECxMW
  KGMpIDIwMDYgRW50cnVzdCwgSW5jLjEtMCsGA1UEAxMkRW50cnVzdCBSb290IENl
  cnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA2MTEyNzIwMjM0MloXDTI2MTEyNzIw
  NTM0MlowgbAxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMTkw
  NwYDVQQLEzB3d3cuZW50cnVzdC5uZXQvQ1BTIGlzIGluY29ycG9yYXRlZCBieSBy
  ZWZlcmVuY2UxHzAdBgNVBAsTFihjKSAyMDA2IEVudHJ1c3QsIEluYy4xLTArBgNV
  BAMTJEVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASIwDQYJ
  KoZIhvcNAQEBBQADggEPADCCAQoCggEBALaVtkNC+sZtKm9I35RMOVcF7sN5EUFo
  Nu3s/poBj6E4KPz3EEZmLk0eGrEaTsbRwJWIsMn/MYszA9u3g3s+IIRe7bJWKKf4
  4LlAcTfFy0cOlypowCKVYhXbR9n10Cv/gkvJrT7eTNuQgFA/CYqEAOwwCj0Yzfv9
  KlmaI5UXLEWeH25DeW0MXJj+SKfFI0dcXv1u5x609mhF0YaDW6KKjbHjKYD+JXGI
  rb68j6xSlkuqUY3kEzEZ6E5Nn9uss2rVvDlUccp6en+Q3X0dgNmBu1kmwhH+5pPi
  94DkZfs0Nw4pgHBNrziGLp5/V6+eF67rHMsoIV+2HNjnogQi+dPa2MsCAwEAAaOB
  sDCBrTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zArBgNVHRAEJDAi
  gA8yMDA2MTEyNzIwMjM0MlqBDzIwMjYxMTI3MjA1MzQyWjAfBgNVHSMEGDAWgBRo
  kORnpKZTgMeGZqTx90tD+4S9bTAdBgNVHQ4EFgQUaJDkZ6SmU4DHhmak8fdLQ/uE
  vW0wHQYJKoZIhvZ9B0EABBAwDhsIVjcuMTo0LjADAgSQMA0GCSqGSIb3DQEBBQUA
  A4IBAQCT1DCw1wMgKtD5Y+iRDAUgqV8ZyntyTtSx29CW+1RaGSwMCPeyvIWonX9t
  O1KzKtvn1ISMY/YPyyYBkVBs9F8U4pN0wBOeMDpQ47RgxRzwIkSNcUesyBrJ6Zua
  AGAT/3B+XxFNSRuzFVJ7yVTav52Vr2ua2J7p8eRDjeIRRDq/r72DQnNSi6q7pynP
  9WQcCk3RvKqsnyrQ/39/2n3qse0wJcGE2jTSW3iDVuycNsMm4hH2Z0kdkquM++v/
  eu6FSqdQgPCnXEqULl8FmTxSQeDNtGPPAUO6nIPcj2A781q0tHuu2guQOHXvgR1m
  0vdXcDazv/wor3ElhVsT/h5/WrQ8
  -----END CERTIFICATE-----

  ### Entrust.net

  === /O=Entrust.net/OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.)/OU=(c) 1999 Entrust.net Limited/CN=Entrust.net Certification Authority (2048)
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number: 946069240 (0x3863def8)
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Dec 24 17:50:51 1999 GMT
              Not After : Jul 24 14:15:12 2029 GMT
          Subject: O=Entrust.net, OU=www.entrust.net/CPS_2048 incorp. by ref. (limits liab.), OU=(c) 1999 Entrust.net Limited, CN=Entrust.net Certification Authority (2048)
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  55:E4:81:D1:11:80:BE:D8:89:B9:08:A3:31:F9:A1:24:09:16:B9:70
  SHA1 Fingerprint=50:30:06:09:1D:97:D4:F5:AE:39:F7:CB:E7:92:7D:7D:65:2D:34:31
  SHA256 Fingerprint=6D:C4:71:72:E0:1C:BC:B0:BF:62:58:0D:89:5F:E2:B8:AC:9A:D4:F8:73:80:1E:0C:10:B9:C8:37:D2:1E:B1:77
  -----BEGIN CERTIFICATE-----
  MIIEKjCCAxKgAwIBAgIEOGPe+DANBgkqhkiG9w0BAQUFADCBtDEUMBIGA1UEChML
  RW50cnVzdC5uZXQxQDA+BgNVBAsUN3d3dy5lbnRydXN0Lm5ldC9DUFNfMjA0OCBp
  bmNvcnAuIGJ5IHJlZi4gKGxpbWl0cyBsaWFiLikxJTAjBgNVBAsTHChjKSAxOTk5
  IEVudHJ1c3QubmV0IExpbWl0ZWQxMzAxBgNVBAMTKkVudHJ1c3QubmV0IENlcnRp
  ZmljYXRpb24gQXV0aG9yaXR5ICgyMDQ4KTAeFw05OTEyMjQxNzUwNTFaFw0yOTA3
  MjQxNDE1MTJaMIG0MRQwEgYDVQQKEwtFbnRydXN0Lm5ldDFAMD4GA1UECxQ3d3d3
  LmVudHJ1c3QubmV0L0NQU18yMDQ4IGluY29ycC4gYnkgcmVmLiAobGltaXRzIGxp
  YWIuKTElMCMGA1UECxMcKGMpIDE5OTkgRW50cnVzdC5uZXQgTGltaXRlZDEzMDEG
  A1UEAxMqRW50cnVzdC5uZXQgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgKDIwNDgp
  MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArU1LqRKGsuqjIAcVFmQq
  K0vRvwtKTY7tgHalZ7d4QMBzQshowNtTK91euHaYNZOLGp18EzoOH1u3Hs/lJBQe
  sYGpjX24zGtLA/ECDNyrpUAkAH90lKGdCCmziAv1h3edVc3kw37XamSrhRSGlVuX
  MlBvPci6Zgzj/L24ScF2iUkZ/cCovYmjZy/Gn7xxGWC4LeksyZB2ZnuU4q941mVT
  XTzWnLLPKQP5L6RQstRIzgUyVYr9smRMDuSYB3Xbf9+5CFVghTAp+XtIpGmG4zU/
  HoZdenoVve8AjhUiVBcAkCaTvA5JaJG/+EfTnZVCwQ5N328mz8MYIWJmQ3DW1cAH
  4QIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV
  HQ4EFgQUVeSB0RGAvtiJuQijMfmhJAkWuXAwDQYJKoZIhvcNAQEFBQADggEBADub
  j1abMOdTmXx6eadNl9cZlZD7Bh/KM3xGY4+WZiT6QBshJ8rmcnPyT/4xmf3IDExo
  U8aAghOY+rat2l098c5u9hURlIIM7j+VrxGrD9cv3h8Dj1csHsm7mhpElesYT6Yf
  zX1XEC+bBAlahLVu2B064dae0Wx5XnkcFMXj0EyTO2U87d89vqbllRrDtRnDvV5b
  u/8j72gZyxKTJ1wDLW8w0B62GqzeWvfRqqgnpv55gcR5mTNXuhKwqeBCbJPKVt7+
  bYQLCIt+jerXmCHG8+c8eS9enNFMFY3h7CI3zJpDC5fcgJCNs2ebb0gIFVbPv/Er
  fF6adulZkMV8gzURZVE=
  -----END CERTIFICATE-----

  ### FNMT-RCM

  === /C=ES/O=FNMT-RCM/OU=AC RAIZ FNMT-RCM
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              5d:93:8d:30:67:36:c8:06:1d:1a:c7:54:84:69:07
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Oct 29 15:59:56 2008 GMT
              Not After : Jan  1 00:00:00 2030 GMT
          Subject: C=ES, O=FNMT-RCM, OU=AC RAIZ FNMT-RCM
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  F7:7D:C5:FD:C4:E8:9A:1B:77:64:A7:F5:1D:A0:CC:BF:87:60:9A:6D
              X509v3 Certificate Policies:
                  Policy: X509v3 Any Policy
                    CPS: http://www.cert.fnmt.es/dpcs/

  SHA1 Fingerprint=EC:50:35:07:B2:15:C4:95:62:19:E2:A8:9A:5B:42:99:2C:4C:2C:20
  SHA256 Fingerprint=EB:C5:57:0C:29:01:8C:4D:67:B1:AA:12:7B:AF:12:F7:03:B4:61:1E:BC:17:B7:DA:B5:57:38:94:17:9B:93:FA
  -----BEGIN CERTIFICATE-----
  MIIFgzCCA2ugAwIBAgIPXZONMGc2yAYdGsdUhGkHMA0GCSqGSIb3DQEBCwUAMDsx
  CzAJBgNVBAYTAkVTMREwDwYDVQQKDAhGTk1ULVJDTTEZMBcGA1UECwwQQUMgUkFJ
  WiBGTk1ULVJDTTAeFw0wODEwMjkxNTU5NTZaFw0zMDAxMDEwMDAwMDBaMDsxCzAJ
  BgNVBAYTAkVTMREwDwYDVQQKDAhGTk1ULVJDTTEZMBcGA1UECwwQQUMgUkFJWiBG
  Tk1ULVJDTTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBALpxgHpMhm5/
  yBNtwMZ9HACXjywMI7sQmkCpGreHiPibVmr75nuOi5KOpyVdWRHbNi63URcfqQgf
  BBckWKo3Shjf5TnUV/3XwSyRAZHiItQDwFj8d0fsjz50Q7qsNI1NOHZnjrDIbzAz
  WHFctPVrbtQBULgTfmxKo0nRIBnuvMApGGWn3v7v3QqQIecaZ5JCEJhfTzC8PhxF
  tBDXaEAUwED653cXeuYLj2VbPNmaUtu1vZ5Gzz3rkQUCwJaydkxNEJY7kvqcfw+Z
  374jNUUeAlz+taibmSXaXvMiwzn15Cou08YfxGyqxRxqAQVKL9LFwag0Jl1mpdIC
  IfkYtwb1TplvqKtMUejPUBjFd8g5CSxJkjKZqLsXF3mwWsXmo8RZZUc1g16p6DUL
  mbvkzSDGm0oGObVo/CK67lWMK07q87Hj/LaZmtVC+nFNCM+HHmpxffnTtOmlcYF7
  wk5HlqX2doWjKI/pgG6BU6VtX7hI+cL5NqYuSf+4lsKMB7ObiFj86xsc3i1w4peS
  MKGJ47xVqCfWS+2QrYv6YyVZLag13cqXM7zlzced0ezvXg5KkAYmY6252TUtB7p2
  ZSysV4999AeU14ECll2jB0nVetBX+RvnU0Z1qrB5QstocQjpYL05ac70r8NWQMet
  UqIJ5G+GR4of6ygnXYMgrwTJbFaai0b1AgMBAAGjgYMwgYAwDwYDVR0TAQH/BAUw
  AwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFPd9xf3E6Jobd2Sn9R2gzL+H
  YJptMD4GA1UdIAQ3MDUwMwYEVR0gADArMCkGCCsGAQUFBwIBFh1odHRwOi8vd3d3
  LmNlcnQuZm5tdC5lcy9kcGNzLzANBgkqhkiG9w0BAQsFAAOCAgEAB5BK3/MjTvDD
  nFFlm5wioooMhfNzKWtN/gHiqQxjAb8EZ6WdmF/9ARP67Jpi6Yb+tmLSbkyU+8B1
  RXxlDPiyN8+sD8+Nb/kZ94/sHvJwnvDKuO+3/3Y3dlv2bojzr2IyIpMNOmqOFGYM
  LVN0V2Ue1bLdI4E7pWYjJ2cJj+F3qkPNZVEI7VFY/uY5+ctHhKQV8Xa7pO6kO8Rf
  77IzlhEYt8llvhjho6Tc+hj507wTmzl6NLrTQfv6MooqtyuGC2mDOL7Nii4LcK2N
  JpLuHvUBKwrZ1pebbuCoGRw6IYsMHkCtA+fdZn71uSANA+iW+YJF1DngoABd15jm
  fZ5nc8OaKveri6E6FO80vFIOiZiaBECEHX5FaZNXzuvO+FB8TxxuBEOb+dY7Ixjp
  6o7RTUaN8Tvkasq6+yO3m/qZASlaWFot4/nUbQ4mrcFuNLwy+AwF+mWj2zs3gyLp
  1txyM/1d8iC9djwj2ij3+RvrWWTV3F9yfiD8zYm1kGdNYno/Tq0dwzn+evQoFt9B
  9kiABdcPUXmsEKvU7ANm5mqwujGSQkBqvjrTcuFqN1W8rB2Vt2lh8kORdOag0wok
  RqEIr9baRRmW1FMdW4R58MD3R++Lj8UGrp1MYp3/RgT408m2ECVAdf4WqslKYIYv
  uu8wd+RU4riEmViAqhOLUTpPSPaLtrM=
  -----END CERTIFICATE-----
  === /C=ES/O=FNMT-RCM/OU=Ceres/2.5.4.97=VATES-Q2826004J/CN=AC RAIZ FNMT-RCM SERVIDORES SEGUROS
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              62:f6:32:6c:e5:c4:e3:68:5c:1b:62:dd:9c:2e:9d:95
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Dec 20 09:37:33 2018 GMT
              Not After : Dec 20 09:37:33 2043 GMT
          Subject: C=ES, O=FNMT-RCM, OU=Ceres/2.5.4.97=VATES-Q2826004J, CN=AC RAIZ FNMT-RCM SERVIDORES SEGUROS
          X509v3 extensions:
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Subject Key Identifier:
                  01:B9:2F:EF:BF:11:86:60:F2:4F:D0:41:6E:AB:73:1F:E7:D2:6E:49
  SHA1 Fingerprint=62:FF:D9:9E:C0:65:0D:03:CE:75:93:D2:ED:3F:2D:32:C9:E3:E5:4A
  SHA256 Fingerprint=55:41:53:B1:3D:2C:F9:DD:B7:53:BF:BE:1A:4E:0A:E0:8D:0A:A4:18:70:58:FE:60:A2:B8:62:B2:E4:B8:7B:CB
  -----BEGIN CERTIFICATE-----
  MIICbjCCAfOgAwIBAgIQYvYybOXE42hcG2LdnC6dlTAKBggqhkjOPQQDAzB4MQsw
  CQYDVQQGEwJFUzERMA8GA1UECgwIRk5NVC1SQ00xDjAMBgNVBAsMBUNlcmVzMRgw
  FgYDVQRhDA9WQVRFUy1RMjgyNjAwNEoxLDAqBgNVBAMMI0FDIFJBSVogRk5NVC1S
  Q00gU0VSVklET1JFUyBTRUdVUk9TMB4XDTE4MTIyMDA5MzczM1oXDTQzMTIyMDA5
  MzczM1oweDELMAkGA1UEBhMCRVMxETAPBgNVBAoMCEZOTVQtUkNNMQ4wDAYDVQQL
  DAVDZXJlczEYMBYGA1UEYQwPVkFURVMtUTI4MjYwMDRKMSwwKgYDVQQDDCNBQyBS
  QUlaIEZOTVQtUkNNIFNFUlZJRE9SRVMgU0VHVVJPUzB2MBAGByqGSM49AgEGBSuB
  BAAiA2IABPa6V1PIyqvfNkpSIeSX0oNnnvBlUdBeh8dHsVnyV0ebAAKTRBdp20LH
  sbI6GA60XYyzZl2hNPk2LEnb80b8s0RpRBNm/dfF/a82Tc4DTQdxz69qBdKiQ1oK
  Um8BA06Oi6NCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYD
  VR0OBBYEFAG5L++/EYZg8k/QQW6rcx/n0m5JMAoGCCqGSM49BAMDA2kAMGYCMQCu
  SuMrQMN0EfKVrRYj3k4MGuZdpSRea0R7/DjiT8ucRRcRTBQnJlU5dUoDzBOQn5IC
  MQD6SmxgiHPz7riYYqnOK8LZiqZwMR2vsJRM60/G49HzYqc8/5MuB1xJAWdpEgJy
  v+c=
  -----END CERTIFICATE-----

  ### GlobalSign

  === /OU=GlobalSign ECC Root CA - R4/O=GlobalSign/CN=GlobalSign
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              2a:38:a4:1c:96:0a:04:de:42:b2:28:a5:0b:e8:34:98:02
      Signature Algorithm: ecdsa-with-SHA256
          Validity
              Not Before: Nov 13 00:00:00 2012 GMT
              Not After : Jan 19 03:14:07 2038 GMT
          Subject: OU=GlobalSign ECC Root CA - R4, O=GlobalSign, CN=GlobalSign
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  54:B0:7B:AD:45:B8:E2:40:7F:FB:0A:6E:FB:BE:33:C9:3C:A3:84:D5
  SHA1 Fingerprint=69:69:56:2E:40:80:F4:24:A1:E7:19:9F:14:BA:F3:EE:58:AB:6A:BB
  SHA256 Fingerprint=BE:C9:49:11:C2:95:56:76:DB:6C:0A:55:09:86:D7:6E:3B:A0:05:66:7C:44:2C:97:62:B4:FB:B7:73:DE:22:8C
  -----BEGIN CERTIFICATE-----
  MIIB4TCCAYegAwIBAgIRKjikHJYKBN5CsiilC+g0mAIwCgYIKoZIzj0EAwIwUDEk
  MCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI0MRMwEQYDVQQKEwpH
  bG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWduMB4XDTEyMTExMzAwMDAwMFoX
  DTM4MDExOTAzMTQwN1owUDEkMCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBD
  QSAtIFI0MRMwEQYDVQQKEwpHbG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWdu
  MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEuMZ5049sJQ6fLjkZHAOkrprlOQcJ
  FspjsbmG+IpXwVfOQvpzofdlQv8ewQCybnMO/8ch5RikqtlxP6jUuc6MHaNCMEAw
  DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFFSwe61F
  uOJAf/sKbvu+M8k8o4TVMAoGCCqGSM49BAMCA0gAMEUCIQDckqGgE6bPA7DmxCGX
  kPoUVy0D7O48027KqGx2vKLeuwIgJ6iFJzWbVsaj8kfSt24bAgAXqmemFZHe+pTs
  ewv4n4Q=
  -----END CERTIFICATE-----
  === /OU=GlobalSign ECC Root CA - R5/O=GlobalSign/CN=GlobalSign
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              60:59:49:e0:26:2e:bb:55:f9:0a:77:8a:71:f9:4a:d8:6c
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Nov 13 00:00:00 2012 GMT
              Not After : Jan 19 03:14:07 2038 GMT
          Subject: OU=GlobalSign ECC Root CA - R5, O=GlobalSign, CN=GlobalSign
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  3D:E6:29:48:9B:EA:07:CA:21:44:4A:26:DE:6E:DE:D2:83:D0:9F:59
  SHA1 Fingerprint=1F:24:C6:30:CD:A4:18:EF:20:69:FF:AD:4F:DD:5F:46:3A:1B:69:AA
  SHA256 Fingerprint=17:9F:BC:14:8A:3D:D0:0F:D2:4E:A1:34:58:CC:43:BF:A7:F5:9C:81:82:D7:83:A5:13:F6:EB:EC:10:0C:89:24
  -----BEGIN CERTIFICATE-----
  MIICHjCCAaSgAwIBAgIRYFlJ4CYuu1X5CneKcflK2GwwCgYIKoZIzj0EAwMwUDEk
  MCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI1MRMwEQYDVQQKEwpH
  bG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWduMB4XDTEyMTExMzAwMDAwMFoX
  DTM4MDExOTAzMTQwN1owUDEkMCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBD
  QSAtIFI1MRMwEQYDVQQKEwpHbG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWdu
  MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAER0UOlvt9Xb/pOdEh+J8LttV7HpI6SFkc
  8GIxLcB6KP4ap1yztsyX50XUWPrRd21DosCHZTQKH3rd6zwzocWdTaRvQZU4f8ke
  hOvRnkmSh5SHDDqFSmafnVmTTZdhBoZKo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYD
  VR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUPeYpSJvqB8ohREom3m7e0oPQn1kwCgYI
  KoZIzj0EAwMDaAAwZQIxAOVpEslu28YxuglB4Zf4+/2a4n0Sye18ZNPLBSWLVtmg
  515dTguDnFt2KaAJJiFqYgIwcdK1j1zqO+F4CYWodZI7yFz9SO8NdCKoCOJuxUnO
  xwy8p2Fp8fc74SrL+SvzZpA3
  -----END CERTIFICATE-----
  === /OU=GlobalSign Root CA - R2/O=GlobalSign/CN=GlobalSign
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              04:00:00:00:00:01:0f:86:26:e6:0d
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Dec 15 08:00:00 2006 GMT
              Not After : Dec 15 08:00:00 2021 GMT
          Subject: OU=GlobalSign Root CA - R2, O=GlobalSign, CN=GlobalSign
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  9B:E2:07:57:67:1C:1E:C0:6A:06:DE:59:B4:9A:2D:DF:DC:19:86:2E
              X509v3 CRL Distribution Points:

                  Full Name:
                    URI:http://crl.globalsign.net/root-r2.crl

              X509v3 Authority Key Identifier:
                  keyid:9B:E2:07:57:67:1C:1E:C0:6A:06:DE:59:B4:9A:2D:DF:DC:19:86:2E

  SHA1 Fingerprint=75:E0:AB:B6:13:85:12:27:1C:04:F8:5F:DD:DE:38:E4:B7:24:2E:FE
  SHA256 Fingerprint=CA:42:DD:41:74:5F:D0:B8:1E:B9:02:36:2C:F9:D8:BF:71:9D:A1:BD:1B:1E:FC:94:6F:5B:4C:99:F4:2C:1B:9E
  -----BEGIN CERTIFICATE-----
  MIIDujCCAqKgAwIBAgILBAAAAAABD4Ym5g0wDQYJKoZIhvcNAQEFBQAwTDEgMB4G
  A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjIxEzARBgNVBAoTCkdsb2JhbFNp
  Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDYxMjE1MDgwMDAwWhcNMjExMjE1
  MDgwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMjETMBEG
  A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
  hvcNAQEBBQADggEPADCCAQoCggEBAKbPJA6+Lm8omUVCxKs+IVSbC9N/hHD6ErPL
  v4dfxn+G07IwXNb9rfF73OX4YJYJkhD10FPe+3t+c4isUoh7SqbKSaZeqKeMWhG8
  eoLrvozps6yWJQeXSpkqBy+0Hne/ig+1AnwblrjFuTosvNYSuetZfeLQBoZfXklq
  tTleiDTsvHgMCJiEbKjNS7SgfQx5TfC4LcshytVsW33hoCmEofnTlEnLJGKRILzd
  C9XZzPnqJworc5HGnRusyMvo4KD0L5CLTfuwNhv2GXqF4G3yYROIXJ/gkwpRl4pa
  zq+r1feqCapgvdzZX99yqWATXgAByUr6P6TqBwMhAo6CygPCm48CAwEAAaOBnDCB
  mTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm+IH
  V2ccHsBqBt5ZtJot39wZhi4wNgYDVR0fBC8wLTAroCmgJ4YlaHR0cDovL2NybC5n
  bG9iYWxzaWduLm5ldC9yb290LXIyLmNybDAfBgNVHSMEGDAWgBSb4gdXZxwewGoG
  3lm0mi3f3BmGLjANBgkqhkiG9w0BAQUFAAOCAQEAmYFThxxol4aR7OBKuEQLq4Gs
  J0/WwbgcQ3izDJr86iw8bmEbTUsp9Z8FHSbBuOmDAGJFtqkIk7mpM0sYmsL4h4hO
  291xNBrBVNpGP+DTKqttVCL1OmLNIG+6KYnX3ZHu01yiPqFbQfXf5WRDLenVOavS
  ot+3i9DAgBkcRcAtjOj4LaR0VknFBbVPFd5uRHg5h6h+u/N5GJG79G+dwfCMNYxd
  AfvDbbnvRG15RjF+Cv6pgsH/76tuIMRQyV+dTZsXjAzlAcmgQWpzU/qlULRuJQ/7
  TBj0/VLZjmmx6BEP3ojY+x1J96relc8geMJgEtslQIxq/H5COEBkEveegeGTLg==
  -----END CERTIFICATE-----
  === /OU=GlobalSign Root CA - R3/O=GlobalSign/CN=GlobalSign
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              04:00:00:00:00:01:21:58:53:08:a2
      Signature Algorithm: sha256WithRSAEncryption
          Validity
              Not Before: Mar 18 10:00:00 2009 GMT
              Not After : Mar 18 10:00:00 2029 GMT
          Subject: OU=GlobalSign Root CA - R3, O=GlobalSign, CN=GlobalSign
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  8F:F0:4B:7F:A8:2E:45:24:AE:4D:50:FA:63:9A:8B:DE:E2:DD:1B:BC
  SHA1 Fingerprint=D6:9B:56:11:48:F0:1C:77:C5:45:78:C1:09:26:DF:5B:85:69:76:AD
  SHA256 Fingerprint=CB:B5:22:D7:B7:F1:27:AD:6A:01:13:86:5B:DF:1C:D4:10:2E:7D:07:59:AF:63:5A:7C:F4:72:0D:C9:63:C5:3B
  -----BEGIN CERTIFICATE-----
  MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G
  A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp
  Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4
  MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG
  A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
  hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8
  RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT
  gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm
  KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
  QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ
  XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw
  DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o
  LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU
  RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp
  jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK
  6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX
  mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs
  Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
  WD9f
  -----END CERTIFICATE-----
  === /OU=GlobalSign Root CA - R6/O=GlobalSign/CN=GlobalSign
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              45:e6:bb:03:83:33:c3:85:65:48:e6:ff:45:51
      Signature Algorithm: sha384WithRSAEncryption
          Validity
              Not Before: Dec 10 00:00:00 2014 GMT
              Not After : Dec 10 00:00:00 2034 GMT
          Subject: OU=GlobalSign Root CA - R6, O=GlobalSign, CN=GlobalSign
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  AE:6C:05:A3:93:13:E2:A2:E7:E2:D7:1C:D6:C7:F0:7F:C8:67:53:A0
              X509v3 Authority Key Identifier:
                  keyid:AE:6C:05:A3:93:13:E2:A2:E7:E2:D7:1C:D6:C7:F0:7F:C8:67:53:A0

  SHA1 Fingerprint=80:94:64:0E:B5:A7:A1:CA:11:9C:1F:DD:D5:9F:81:02:63:A7:FB:D1
  SHA256 Fingerprint=2C:AB:EA:FE:37:D0:6C:A2:2A:BA:73:91:C0:03:3D:25:98:29:52:C4:53:64:73:49:76:3A:3A:B5:AD:6C:CF:69
  -----BEGIN CERTIFICATE-----
  MIIFgzCCA2ugAwIBAgIORea7A4Mzw4VlSOb/RVEwDQYJKoZIhvcNAQEMBQAwTDEg
  MB4GA1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjYxEzARBgNVBAoTCkdsb2Jh
  bFNpZ24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMTQxMjEwMDAwMDAwWhcNMzQx
  MjEwMDAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSNjET
  MBEGA1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCAiIwDQYJ
  KoZIhvcNAQEBBQADggIPADCCAgoCggIBAJUH6HPKZvnsFMp7PPcNCPG0RQssgrRI
  xutbPK6DuEGSMxSkb3/pKszGsIhrxbaJ0cay/xTOURQh7ErdG1rG1ofuTToVBu1k
  ZguSgMpE3nOUTvOniX9PeGMIyBJQbUJmL025eShNUhqKGoC3GYEOfsSKvGRMIRxD
  aNc9PIrFsmbVkJq3MQbFvuJtMgamHvm566qjuL++gmNQ0PAYid/kD3n16qIfKtJw
  LnvnvJO7bVPiSHyMEAc4/2ayd2F+4OqMPKq0pPbzlUoSB239jLKJz9CgYXfIWHSw
  1CM69106yqLbnQneXUQtkPGBzVeS+n68UARjNN9rkxi+azayOeSsJDa38O+2HBNX
  k7besvjihbdzorg1qkXy4J02oW9UivFyVm4uiMVRQkQVlO6jxTiWm05OWgtH8wY2
  SXcwvHE35absIQh1/OZhFj931dmRl4QKbNQCTXTAFO39OfuD8l4UoQSwC+n+7o/h
  bguyCLNhZglqsQY6ZZZZwPA1/cnaKI0aEYdwgQqomnUdnjqGBQCe24DWJfncBZ4n
  WUx2OVvq+aWh2IMP0f/fMBH5hc8zSPXKbWQULHpYT9NLCEnFlWQaYw55PfWzjMpY
  rZxCRXluDocZXFSxZba/jJvcE+kNb7gu3GduyYsRtYQUigAZcIN5kZeR1Bonvzce
  MgfYFGM8KEyvAgMBAAGjYzBhMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTAD
  AQH/MB0GA1UdDgQWBBSubAWjkxPioufi1xzWx/B/yGdToDAfBgNVHSMEGDAWgBSu
  bAWjkxPioufi1xzWx/B/yGdToDANBgkqhkiG9w0BAQwFAAOCAgEAgyXt6NH9lVLN
  nsAEoJFp5lzQhN7craJP6Ed41mWYqVuoPId8AorRbrcWc+ZfwFSY1XS+wc3iEZGt
  Ixg93eFyRJa0lV7Ae46ZeBZDE1ZXs6KzO7V33EByrKPrmzU+sQghoefEQzd5Mr61
  55wsTLxDKZmOMNOsIeDjHfrYBzN2VAAiKrlNIC5waNrlU/yDXNOd8v9EDERm8tLj
  vUYAGm0CuiVdjaExUd1URhxN25mW7xocBFymFe944Hn+Xds+qkxV/ZoVqW/hpvvf
  cDDpw+5CRu3CkwWJ+n1jez/QcYF8AOiYrg54NMMl+68KnyBr3TsTjxKM4kEaSHpz
  oHdpx7Zcf4LIHv5YGygrqGytXm3ABdJ7t+uA/iU3/gKbaKxCXcPu9czc8FB10jZp
  nOZ7BN9uBmm23goJSFmH63sUYHpkqmlD75HHTOwY3WzvUy2MmeFe8nI+z1TIvWfs
  pA9MRf/TuTAjB0yPEL+GltmZWrSZVxykzLsViVO6LAUP5MSeGbEYNNVMnbrt9x+v
  JJUEeKgDu+6B5dpffItKoZB0JaezPkvILFa9x8jvOOJckvB595yEunQtYQEgfn7R
  8k8HWV+LLUNS60YMlOH1Zkd5d9VUWx+tJDfLRVpOoERIyNiwmcUVhAn21klJwGW4
  5hpxbqCo8YLoRT5s1gLXCmeDBVrJpBA=
  -----END CERTIFICATE-----

  ### GlobalSign nv-sa

  === /C=BE/O=GlobalSign nv-sa/CN=GlobalSign Root E46
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              11:d2:bb:ba:33:6e:d4:bc:e6:24:68:c5:0d:84:1d:98:e8:43
      Signature Algorithm: ecdsa-with-SHA384
          Validity
              Not Before: Mar 20 00:00:00 2019 GMT
              Not After : Mar 20 00:00:00 2046 GMT
          Subject: C=BE, O=GlobalSign nv-sa, CN=GlobalSign Root E46
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  31:0A:90:8F:B6:C6:9D:D2:44:4B:80:B5:A2:E6:1F:B1:12:4F:1B:95
  SHA1 Fingerprint=39:B4:6C:D5:FE:80:06:EB:E2:2F:4A:BB:08:33:A0:AF:DB:B9:DD:84
  SHA256 Fingerprint=CB:B9:C4:4D:84:B8:04:3E:10:50:EA:31:A6:9F:51:49:55:D7:BF:D2:E2:C6:B4:93:01:01:9A:D6:1D:9F:50:58
  -----BEGIN CERTIFICATE-----
  MIICCzCCAZGgAwIBAgISEdK7ujNu1LzmJGjFDYQdmOhDMAoGCCqGSM49BAMDMEYx
  CzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRwwGgYDVQQD
  ExNHbG9iYWxTaWduIFJvb3QgRTQ2MB4XDTE5MDMyMDAwMDAwMFoXDTQ2MDMyMDAw
  MDAwMFowRjELMAkGA1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2Ex
  HDAaBgNVBAMTE0dsb2JhbFNpZ24gUm9vdCBFNDYwdjAQBgcqhkjOPQIBBgUrgQQA
  IgNiAAScDrHPt+ieUnd1NPqlRqetMhkytAepJ8qUuwzSChDH2omwlwxwEwkBjtjq
  R+q+soArzfwoDdusvKSGN+1wCAB16pMLey5SnCNoIwZD7JIvU4Tb+0cUB+hflGdd
  yXqBPCCjQjBAMA4GA1UdDwEB/wQEAwIBhjAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
  DgQWBBQxCpCPtsad0kRLgLWi5h+xEk8blTAKBggqhkjOPQQDAwNoADBlAjEA31SQ
  7Zvvi5QCkxeCmb6zniz2C5GMn0oUsfZkvLtoURMMA/cVi4RguYv/Uo7njLwcAjA8
  +RHUjE7AwWHCFUyqqx0LMV87HOIAl0Qx5v5zli/altP+CAezNIm8BZ/3Hobui3A=
  -----END CERTIFICATE-----
  === /C=BE/O=GlobalSign nv-sa/CN=GlobalSign Root R46
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              11:d2:bb:b9:d7:23:18:9e:40:5f:0a:9d:2d:d0:df:25:67:d1
      Signature Algorithm: sha384WithRSAEncryption
          Validity
              Not Before: Mar 20 00:00:00 2019 GMT
              Not After : Mar 20 00:00:00 2046 GMT
          Subject: C=BE, O=GlobalSign nv-sa, CN=GlobalSign Root R46
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Digital Signature, Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  03:5C:AB:73:81:87:A8:CC:B0:A6:D5:94:E2:36:96:49:FF:05:99:2C
  SHA1 Fingerprint=53:A2:B0:4B:CA:6B:D6:45:E6:39:8A:8E:C4:0D:D2:BF:77:C3:A2:90
  SHA256 Fingerprint=4F:A3:12:6D:8D:3A:11:D1:C4:85:5A:4F:80:7C:BA:D6:CF:91:9D:3A:5A:88:B0:3B:EA:2C:63:72:D9:3C:40:C9
  -----BEGIN CERTIFICATE-----
  MIIFWjCCA0KgAwIBAgISEdK7udcjGJ5AXwqdLdDfJWfRMA0GCSqGSIb3DQEBDAUA
  MEYxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRwwGgYD
  VQQDExNHbG9iYWxTaWduIFJvb3QgUjQ2MB4XDTE5MDMyMDAwMDAwMFoXDTQ2MDMy
  MDAwMDAwMFowRjELMAkGA1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYt
  c2ExHDAaBgNVBAMTE0dsb2JhbFNpZ24gUm9vdCBSNDYwggIiMA0GCSqGSIb3DQEB
  AQUAA4ICDwAwggIKAoICAQCsrHQy6LNl5brtQyYdpokNRbopiLKkHWPd08EsCVeJ
  OaFV6Wc0dwxu5FUdUiXSE2te4R2pt32JMl8Nnp8semNgQB+msLZ4j5lUlghYruQG
  vGIFAha/r6gjA7aUD7xubMLL1aa7DOn2wQL7Id5m3RerdELv8HQvJfTqa1VbkNud
  316HCkD7rRlr+/fKYIje2sGP1q7Vf9Q8g+7XFkyDRTNrJ9CG0Bwta/OrffGFqfUo
  0q3v84RLHIf8E6M6cqJaESvWJ3En7YEtbWaBkoe0G1h6zD8K+kZPTXhc+CtI4wSE
  y132tGqzZfxCnlEmIyDLPRT5ge1lFgBPGmSXZgjPjHvjK8Cd+RTyG/FWaha/LIWF
  zXg4mutCagI0GIMXTpRW+LaCtfOW3T3zvn8gdz57GSNrLNRyc0NXfeD412lPFzYE
  +cCQYDdF3uYM2HSNrpyibXRdQr4G9dlkbgIQrImwTDsHTUB+JMWKmIJ5jqSngiCN
  I/onccnfxkF0oE32kRbcRoxfKWMxWXEM2G/CtjJ9++ZdU6Z+Ffy7dXxd7Pj2Fxzs
  x2sZy/N78CsHpdlseVR2bJ0cpm4O6XkMqCNqo98bMDGfsVR7/mrLZqrcZdCinkqa
  ByFrgY/bxFn63iLABJzjqls2k+g9vXqhnQt2sQvHnf3PmKgGwvgqo6GDoLclcqUC
  4wIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV
  HQ4EFgQUA1yrc4GHqMywptWU4jaWSf8FmSwwDQYJKoZIhvcNAQEMBQADggIBAHx4
  7PYCLLtbfpIrXTncvtgdokIzTfnvpCo7RGkerNlFo048p9gkUbJUHJNOxO97k4Vg
  JuoJSOD1u8fpaNK7ajFxzHmuEajwmf3lH7wvqMxX63bEIaZHU1VNaL8FpO7XJqti
  2kM3S+LGteWygxk6x9PbTZ4IevPuzz5i+6zoYMzRx6Fcg0XERczzF2sUyQQCPtIk
  pnnpHs6i58FZFZ8d4kuaPp92CC1r2LpXFNqD6v6MVenQTqnMdzGxRBF6XLE+0xRF
  FRhiJBPSy03OXIPBNvIQtQ6IbbjhVp+J3pZmOUdkLG5NrmJ7v2B0GbhWrJKsFjLt
  rWhV/pi60zTe9Mlhww6G9kuEYO4Ne7UyWHmRVSyBQ7N0H3qqJZ4d16GLuc1CLgSk
  ZoNNiTW2bKg2SnkheCLQQrzRQDGQob4Ez8pn7fXwgNNgyYMqIgXQBztSvwyeqiv5
  u+YfjyW6hY0XHgL+XVAEV8/+LbzvXMAaq7afJMbfc2hIkCwU9D9SGuTSyxTDYWnP
  4vkYxboznxSjBF25cfe1lNj2M8FawTSLfJvdkzrnE6JwYZ+vj+vYxXX4M2bUdGc6
  N3ec592kD3ZDZopD8p/7DEJ4Y9HiD2971KE9dJeFt0g5QdYg/NA6s/rob8SKunE3
  vouXsXgxT7PntgMTzlSdriVZzH81Xwj3QEUxeCp6
  -----END CERTIFICATE-----
  === /C=BE/O=GlobalSign nv-sa/OU=Root CA/CN=GlobalSign Root CA
  Certificate:
      Data:
          Version: 3 (0x2)
          Serial Number:
              04:00:00:00:00:01:15:4b:5a:c3:94
      Signature Algorithm: sha1WithRSAEncryption
          Validity
              Not Before: Sep  1 12:00:00 1998 GMT
              Not After : Jan 28 12:00:00 2028 GMT
          Subject: C=BE, O=GlobalSign nv-sa, OU=Root CA, CN=GlobalSign Root CA
          X509v3 extensions:
              X509v3 Key Usage: critical
                  Certificate Sign, CRL Sign
              X509v3 Basic Constraints: critical
                  CA:TRUE
              X509v3 Subject Key Identifier:
                  60:7B:66:1A:45:0D:97:CA:89:50:2F:7D:04:CD:34:A8:FF:FC:FD:4B
  SHA1 Fingerprint=B1:BC:96:8B:D4:F4:9D:62:2A:A8:9A:81:F2:15:01:52:A4:1D:82:9C
  SHA256 Fingerprint=EB:D4:10:40:E4:BB:3E:C7:42:C9:E3:81:D3:1E:F2:A4:1A:48:B6:68:5C:96:E7:CE:F3:C1:DF:6C:D4:33:1C:99
  -----BEGIN CERTIFICATE-----
  MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG
  A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv
  b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw
  MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i
  YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT
  aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ
  jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp
  xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp
  1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG
  snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ
  U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8
  9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E
  BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B
  AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz
  yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE
  38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP
  AbEVtQwdpf5pLGkkeB6z