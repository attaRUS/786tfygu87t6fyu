 callback.blockForDone();
    testFramework.mCronetEngine.stopNetLog();
    assertTrue(file.exists());
    assertTrue(hasDebugInNetLog(file));
    assertFalse(hasTraceInNetLog(file));
    assertTrue(file.delete());
    assertFalse(file.exists());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBoundedFileNetLogStartMultipleTimes() throws Exception {
    final CronetTestFramework testFramework = mTestRule.startCronetTestFramework();
    File directory = new File(PathUtils.getDataDirectory());
    File netLogDir = new File(directory, "NetLog");
    assertFalse(netLogDir.exists());
    assertTrue(netLogDir.mkdir());
    File logFile = new File(netLogDir, "netlog.json");
    // Start NetLog multiple times. This should be equivalent to starting NetLog
    // once. Each subsequent start (without calling stopNetLog) should be a no-op.
    testFramework.mCronetEngine.startNetLogToDisk(netLogDir.getPath(), false, MAX_FILE_SIZE);
    testFramework.mCronetEngine.startNetLogToDisk(netLogDir.getPath(), false, MAX_FILE_SIZE);
    testFramework.mCronetEngine.startNetLogToDisk(netLogDir.getPath(), false, MAX_FILE_SIZE);
    testFramework.mCronetEngine.startNetLogToDisk(netLogDir.getPath(), false, MAX_FILE_SIZE);
    // Start a request.
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        testFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    testFramework.mCronetEngine.stopNetLog();
    assertTrue(logFile.exists());
    assertTrue(logFile.length() != 0);
    assertFalse(hasTraceInNetLog(logFile));
    FileUtils.recursivelyDeleteFile(netLogDir, FileUtils.DELETE_ALL);
    assertFalse(netLogDir.exists());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testNetLogStopMultipleTimes() throws Exception {
    final CronetTestFramework testFramework = mTestRule.startCronetTestFramework();
    File directory = new File(PathUtils.getDataDirectory());
    File file = File.createTempFile("cronet", "json", directory);
    testFramework.mCronetEngine.startNetLogToFile(file.getPath(), false);
    // Start a request.
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        testFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    // Stop NetLog multiple times.
    testFramework.mCronetEngine.stopNetLog();
    testFramework.mCronetEngine.stopNetLog();
    testFramework.mCronetEngine.stopNetLog();
    testFramework.mCronetEngine.stopNetLog();
    testFramework.mCronetEngine.stopNetLog();
    assertTrue(file.exists());
    assertTrue(hasDebugInNetLog(file));
    assertFalse(hasTraceInNetLog(file));
    assertTrue(file.delete());
    assertFalse(file.exists());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBoundedFileNetLogStopMultipleTimes() throws Exception {
    final CronetTestFramework testFramework = mTestRule.startCronetTestFramework();
    File directory = new File(PathUtils.getDataDirectory());
    File netLogDir = new File(directory, "NetLog");
    assertFalse(netLogDir.exists());
    assertTrue(netLogDir.mkdir());
    File logFile = new File(netLogDir, "netlog.json");
    testFramework.mCronetEngine.startNetLogToDisk(netLogDir.getPath(), false, MAX_FILE_SIZE);
    // Start a request.
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        testFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    // Stop NetLog multiple times. This should be equivalent to stopping NetLog once.
    // Each subsequent stop (without calling startNetLogToDisk first) should be a no-op.
    testFramework.mCronetEngine.stopNetLog();
    testFramework.mCronetEngine.stopNetLog();
    testFramework.mCronetEngine.stopNetLog();
    testFramework.mCronetEngine.stopNetLog();
    testFramework.mCronetEngine.stopNetLog();
    assertTrue(logFile.exists());
    assertTrue(logFile.length() != 0);
    assertFalse(hasTraceInNetLog(logFile));
    FileUtils.recursivelyDeleteFile(netLogDir, FileUtils.DELETE_ALL);
    assertFalse(netLogDir.exists());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testNetLogWithBytes() throws Exception {
    Context context = getContext();
    File directory = new File(PathUtils.getDataDirectory());
    File file = File.createTempFile("cronet", "json", directory);
    CronetEngine cronetEngine = new CronetEngine.Builder(context).build();
    // Start NetLog with logAll as true.
    cronetEngine.startNetLogToFile(file.getPath(), true);
    // Start a request.
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        cronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    cronetEngine.stopNetLog();
    assertTrue(file.exists());
    assertTrue(hasDebugInNetLog(file));
    assertTrue(hasTraceInNetLog(file));
    assertTrue(file.delete());
    assertFalse(file.exists());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBoundedFileNetLogWithBytes() throws Exception {
    Context context = getContext();
    File directory = new File(PathUtils.getDataDirectory());
    File netLogDir = new File(directory, "NetLog");
    assertFalse(netLogDir.exists());
    assertTrue(netLogDir.mkdir());
    File logFile = new File(netLogDir, "netlog.json");
    ExperimentalCronetEngine cronetEngine = new ExperimentalCronetEngine.Builder(context).build();
    // Start NetLog with logAll as true.
    cronetEngine.startNetLogToDisk(netLogDir.getPath(), true, MAX_FILE_SIZE);
    // Start a request.
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        cronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    cronetEngine.stopNetLog();

    assertTrue(logFile.exists());
    assertTrue(logFile.length() != 0);
    assertTrue(hasTraceInNetLog(logFile));
    FileUtils.recursivelyDeleteFile(netLogDir, FileUtils.DELETE_ALL);
    assertFalse(netLogDir.exists());
  }

  private boolean hasTraceInNetLog(File logFile) throws Exception {
    return containsStringInNetLog(logFile, "trace");
  }

  private boolean hasDebugInNetLog(File logFile) throws Exception {
    return containsStringInNetLog(logFile, "debug");
  }

  private boolean containsStringInNetLog(File logFile, String content) throws Exception {
    BufferedReader logReader = new BufferedReader(new FileReader(logFile));
    try {
      String logLine;
      while ((logLine = logReader.readLine()) != null) {
        if (logLine.contains(content)) {
          return true;
        }
      }
      return false;
    } finally {
      logReader.close();
    }
  }

  /**
   * Helper method to make a request to {@code url}, wait for it to
   * complete, and check that the status code is the same as {@code expectedStatusCode}.
   */
  private void makeRequestAndCheckStatus(CronetEngine engine, String url, int expectedStatusCode) {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest request = engine.newUrlRequestBuilder(url, callback, callback.getExecutor()).build();
    request.start();
    callback.blockForDone();
    assertEquals(expectedStatusCode, callback.mResponseInfo.getHttpStatusCode());
  }

  private void checkRequestCaching(CronetEngine engine, String url, boolean expectCached) {
    checkRequestCaching(engine, url, expectCached, false);
  }

  private void checkRequestCaching(CronetEngine engine, String url, boolean expectCached,
                                   boolean disableCache) {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        engine.newUrlRequestBuilder(url, callback, callback.getExecutor());
    if (disableCache) {
      urlRequestBuilder.disableCache();
    }
    urlRequestBuilder.build().start();
    callback.blockForDone();
    assertEquals(expectCached, callback.mResponseInfo.wasCached());
    assertEquals("this is a cacheable file\n", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Caching not implemented yet: https://github.com/envoyproxy/envoy-mobile/issues/1578")
  public void testEnableHttpCacheDisabled() throws Exception {
    CronetEngine cronetEngine =
        createCronetEngineWithCache(CronetEngine.Builder.HTTP_CACHE_DISABLED);
    String url = NativeTestServer.getFileURL("/cacheable.txt");
    checkRequestCaching(cronetEngine, url, false);
    checkRequestCaching(cronetEngine, url, false);
    checkRequestCaching(cronetEngine, url, false);
    cronetEngine.shutdown();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Caching not implemented yet: https://github.com/envoyproxy/envoy-mobile/issues/1578")
  public void testEnableHttpCacheInMemory() throws Exception {
    CronetEngine cronetEngine =
        createCronetEngineWithCache(CronetEngine.Builder.HTTP_CACHE_IN_MEMORY);
    String url = NativeTestServer.getFileURL("/cacheable.txt");
    checkRequestCaching(cronetEngine, url, false);
    checkRequestCaching(cronetEngine, url, true);
    NativeTestServer.shutdownNativeTestServer();
    checkRequestCaching(cronetEngine, url, true);
    cronetEngine.shutdown();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Caching not implemented yet: https://github.com/envoyproxy/envoy-mobile/issues/1578")
  public void testEnableHttpCacheDisk() throws Exception {
    CronetEngine cronetEngine = createCronetEngineWithCache(CronetEngine.Builder.HTTP_CACHE_DISK);
    String url = NativeTestServer.getFileURL("/cacheable.txt");
    checkRequestCaching(cronetEngine, url, false);
    checkRequestCaching(cronetEngine, url, true);
    NativeTestServer.shutdownNativeTestServer();
    checkRequestCaching(cronetEngine, url, true);
    cronetEngine.shutdown();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Caching not implemented yet: https://github.com/envoyproxy/envoy-mobile/issues/1578")
  public void testNoConcurrentDiskUsage() throws Exception {
    CronetEngine cronetEngine = createCronetEngineWithCache(CronetEngine.Builder.HTTP_CACHE_DISK);
    try {
      createCronetEngineWithCache(CronetEngine.Builder.HTTP_CACHE_DISK);
      fail();
    } catch (IllegalStateException e) {
      assertEquals("Disk cache storage path already in use", e.getMessage());
    }
    String url = NativeTestServer.getFileURL("/cacheable.txt");
    checkRequestCaching(cronetEngine, url, false);
    checkRequestCaching(cronetEngine, url, true);
    NativeTestServer.shutdownNativeTestServer();
    checkRequestCaching(cronetEngine, url, true);
    cronetEngine.shutdown();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Caching not implemented yet: https://github.com/envoyproxy/envoy-mobile/issues/1578")
  public void testEnableHttpCacheDiskNoHttp() throws Exception {
    CronetEngine cronetEngine =
        createCronetEngineWithCache(CronetEngine.Builder.HTTP_CACHE_DISK_NO_HTTP);
    String url = NativeTestServer.getFileURL("/cacheable.txt");
    checkRequestCaching(cronetEngine, url, false);
    checkRequestCaching(cronetEngine, url, false);
    checkRequestCaching(cronetEngine, url, false);

    // Make a new CronetEngine and try again to make sure the response didn't get cached on the
    // first request. See https://crbug.com/743232.
    cronetEngine.shutdown();
    cronetEngine = createCronetEngineWithCache(CronetEngine.Builder.HTTP_CACHE_DISK_NO_HTTP);
    checkRequestCaching(cronetEngine, url, false);
    checkRequestCaching(cronetEngine, url, false);
    checkRequestCaching(cronetEngine, url, false);
    cronetEngine.shutdown();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Caching not implemented yet: https://github.com/envoyproxy/envoy-mobile/issues/1578")
  public void testDisableCache() throws Exception {
    CronetEngine cronetEngine = createCronetEngineWithCache(CronetEngine.Builder.HTTP_CACHE_DISK);
    String url = NativeTestServer.getFileURL("/cacheable.txt");

    // When cache is disabled, making a request does not write to the cache.
    checkRequestCaching(cronetEngine, url, false, true /** disable cache */);
    checkRequestCaching(cronetEngine, url, false);

    // When cache is enabled, the second request is cached.
    checkRequestCaching(cronetEngine, url, false, true /** disable cache */);
    checkRequestCaching(cronetEngine, url, true);

    // Shut down the server, next request should have a cached response.
    NativeTestServer.shutdownNativeTestServer();
    checkRequestCaching(cronetEngine, url, true);

    // Cache is disabled after server is shut down, request should fail.
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        cronetEngine.newUrlRequestBuilder(url, callback, callback.getExecutor());
    urlRequestBuilder.disableCache();
    urlRequestBuilder.build().start();
    callback.blockForDone();
    assertNotNull(callback.mError);
    assertContains("Exception in CronetUrlRequest: net::ERR_CONNECTION_REFUSED",
                   callback.mError.getMessage());
    cronetEngine.shutdown();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Caching not implemented yet: https://github.com/envoyproxy/envoy-mobile/issues/1578")
  public void testEnableHttpCacheDiskNewEngine() throws Exception {
    CronetEngine cronetEngine = createCronetEngineWithCache(CronetEngine.Builder.HTTP_CACHE_DISK);
    String url = NativeTestServer.getFileURL("/cacheable.txt");
    checkRequestCaching(cronetEngine, url, false);
    checkRequestCaching(cronetEngine, url, true);
    NativeTestServer.shutdownNativeTestServer();
    checkRequestCaching(cronetEngine, url, true);

    // Shutdown original context and create another that uses the same cache.
    cronetEngine.shutdown();
    cronetEngine = mTestRule.enableDiskCache(new CronetEngine.Builder(getContext())).build();
    checkRequestCaching(cronetEngine, url, true);
    cronetEngine.shutdown();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testInitEngineAndStartRequest() {
    // Immediately make a request after initializing the engine.
    CronetEngine cronetEngine = new CronetEngine.Builder(getContext()).build();
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        cronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    cronetEngine.shutdown();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testInitEngineStartTwoRequests() throws Exception {
    // Make two requests after initializing the context.
    CronetEngine cronetEngine = new CronetEngine.Builder(getContext()).build();
    int[] statusCodes = {0, 0};
    String[] urls = {mUrl, mUrl404};
    for (int i = 0; i < 2; i++) {
      TestUrlRequestCallback callback = new TestUrlRequestCallback();
      UrlRequest.Builder urlRequestBuilder =
          cronetEngine.newUrlRequestBuilder(urls[i], callback, callback.getExecutor());
      urlRequestBuilder.build().start();
      callback.blockForDone();
      statusCodes[i] = callback.mResponseInfo.getHttpStatusCode();
    }
    assertEquals(200, statusCodes[0]);
    assertEquals(404, statusCodes[1]);
    cronetEngine.shutdown();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore(
      "Multiple Engines are not yet supported: https://github.com/envoyproxy/envoy-mobile/issues/332")
  public void
  testInitTwoEnginesSimultaneously() throws Exception {
    // Threads will block on runBlocker to ensure simultaneous execution.
    ConditionVariable runBlocker = new ConditionVariable(false);
    RequestThread thread1 = new RequestThread(mUrl, runBlocker);
    RequestThread thread2 = new RequestThread(mUrl404, runBlocker);

    thread1.start();
    thread2.start();
    runBlocker.open();
    thread1.join();
    thread2.join();
    assertEquals(200, thread1.mCallback.mResponseInfo.getHttpStatusCode());
    assertEquals(404, thread2.mCallback.mResponseInfo.getHttpStatusCode());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testInitTwoEnginesInSequence() throws Exception {
    ConditionVariable runBlocker = new ConditionVariable(true);
    RequestThread thread1 = new RequestThread(mUrl, runBlocker);
    RequestThread thread2 = new RequestThread(mUrl404, runBlocker);

    thread1.start();
    thread1.join();
    thread2.start();
    thread2.join();
    assertEquals(200, thread1.mCallback.mResponseInfo.getHttpStatusCode());
    assertEquals(404, thread2.mCallback.mResponseInfo.getHttpStatusCode());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore(
      "Multiple Engines are not yet supported: https://github.com/envoyproxy/envoy-mobile/issues/332")
  public void
  testInitDifferentEngines() throws Exception {
    // Test that concurrently instantiating Cronet context's upon various
    // different versions of the same Android Context does not cause crashes
    // like crbug.com/453845
    CronetEngine firstEngine = new CronetEngine.Builder(getContext()).build();
    CronetEngine secondEngine =
        new CronetEngine.Builder(getContext().getApplicationContext()).build();
    CronetEngine thirdEngine = new CronetEngine.Builder(new ContextWrapper(getContext())).build();
    firstEngine.shutdown();
    secondEngine.shutdown();
    thirdEngine.shutdown();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("UMA not implemented yet: https://github.com/envoyproxy/envoy-mobile/issues/1615")
  public void testGetGlobalMetricsDeltas() throws Exception {
    final CronetTestFramework testFramework = mTestRule.startCronetTestFramework();

    byte[] delta1 = testFramework.mCronetEngine.getGlobalMetricsDeltas();

    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder =
        testFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    builder.build().start();
    callback.blockForDone();
    // Fetch deltas on a different thread the second time to make sure this is permitted.
    // See crbug.com/719448
    FutureTask<byte[]> task = new FutureTask<>(new Callable<byte[]>() {
      @Override
      public byte[] call() {
        return testFramework.mCronetEngine.getGlobalMetricsDeltas();
      }
    });
    new Thread(task).start();
    byte[] delta2 = task.get();
    assertTrue(delta2.length != 0);
    assertFalse(Arrays.equals(delta1, delta2));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Look into another way to verify this setup")
  public void testCronetEngineBuilderConfig() throws Exception {
    // This is to prompt load of native library.
    mTestRule.startCronetTestFramework();
    // Verify CronetEngine.Builder config is passed down accurately to native code.
    ExperimentalCronetEngine.Builder builder = new ExperimentalCronetEngine.Builder(getContext());
    builder.enableHttp2(false);
    builder.enableQuic(true);
    builder.addQuicHint("example.com", 12, 34);
    builder.enableHttpCache(HTTP_CACHE_IN_MEMORY, 54321);
    builder.setUserAgent("efgh");
    builder.setExperimentalOptions("ijkl");
    builder.setStoragePath(getTestStorage());
    builder.enablePublicKeyPinningBypassForLocalTrustAnchors(false);
    // TODO(colibie)
    // nativeVerifyUrlRequestContextConfig(
    //         CronetUrlRequestContext.createNativeUrlRequestContextConfig(
    //                 (CronetEngineBuilderImpl) builder.mBuilderDelegate),
    //         getTestStorage());
  }

  // Verifies that CronetEngine.Builder config from testCronetEngineBuilderConfig() is properly
  // translated to a native UrlRequestContextConfig.
  private static native void nativeVerifyUrlRequestContextConfig(long config, String storagePath);

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Look into another way to verify this setup")
  public void testCronetEngineQuicOffConfig() throws Exception {
    // This is to prompt load of native library.
    mTestRule.startCronetTestFramework();
    // Verify CronetEngine.Builder config is passed down accurately to native code.
    ExperimentalCronetEngine.Builder builder = new ExperimentalCronetEngine.Builder(getContext());
    builder.enableHttp2(false);
    // QUIC is on by default. Disabling it here to make sure the built config can correctly
    // reflect the change.
    builder.enableQuic(false);
    builder.enableHttpCache(HTTP_CACHE_IN_MEMORY, 54321);
    builder.setExperimentalOptions("ijkl");
    builder.setUserAgent("efgh");
    builder.setStoragePath(getTestStorage());
    builder.enablePublicKeyPinningBypassForLocalTrustAnchors(false);
    // nativeVerifyUrlRequestContextQuicOffConfig(
    //         CronetUrlRequestContext.createNativeUrlRequestContextConfig(
    //                 (CronetEngineBuilderImpl) builder.mBuilderDelegate),
    //         getTestStorage());
  }

  // Verifies that CronetEngine.Builder config from testCronetEngineQuicOffConfig() is properly
  // translated to a native UrlRequestContextConfig and QUIC is turned off.
  private static native void nativeVerifyUrlRequestContextQuicOffConfig(long config,
                                                                        String storagePath);

  private static class TestBadLibraryLoader extends CronetEngine.Builder.LibraryLoader {
    private boolean mWasCalled;

    @Override
    public void loadLibrary(String libName) {
      // Report that this method was called, but don't load the library
      mWasCalled = true;
    }

    boolean wasCalled() { return mWasCalled; }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Library Loader not needed")
  public void testSetLibraryLoaderIsEnforcedByDefaultEmbeddedProvider() throws Exception {
    CronetEngine.Builder builder = new CronetEngine.Builder(getContext());
    TestBadLibraryLoader loader = new TestBadLibraryLoader();
    builder.setLibraryLoader(loader);
    try {
      builder.build();
      fail("Native library should not be loaded");
    } catch (UnsatisfiedLinkError e) {
      assertTrue(loader.wasCalled());
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Library Loader not needed")
  public void testSetLibraryLoaderIsIgnoredInNativeCronetEngineBuilderImpl() throws Exception {
    CronetEngine.Builder builder =
        new CronetEngine.Builder(new NativeCronvoyEngineBuilderImpl(getContext()));
    TestBadLibraryLoader loader = new TestBadLibraryLoader();
    builder.setLibraryLoader(loader);
    CronetEngine engine = builder.build();
    assertNotNull(engine);
    assertFalse(loader.wasCalled());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testNativeCronetEngineBuilderImplSetsCorrectVersionString() throws Exception {
    CronetEngine.Builder builder =
        new CronetEngine.Builder(new NativeCronvoyEngineBuilderImpl(getContext()));
    CronetEngine engine = builder.build();
    assertTrue(engine.getVersionString().startsWith("Cronet/"));
  }

  // Creates a CronetEngine on another thread and then one on the main thread. This shouldn't
  // crash.
  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("This times out")
  public void testThreadedStartup() throws Exception {
    final ConditionVariable otherThreadDone = new ConditionVariable();
    final ConditionVariable uiThreadDone = new ConditionVariable();
    new Handler(Looper.getMainLooper()).post(new Runnable() {
      @Override
      public void run() {
        final ExperimentalCronetEngine.Builder builder =
            new ExperimentalCronetEngine.Builder(getContext());
        new Thread() {
          @Override
          public void run() {
            CronetEngine cronetEngine = builder.build();
            otherThreadDone.open();
            cronetEngine.shutdown();
          }
        }.start();
        otherThreadDone.block();
        builder.build().shutdown();
        uiThreadDone.open();
      }
    });
    assertTrue(uiThreadDone.block(1000));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Experimental options not implemented yet")
  public void testHostResolverRules() throws Exception {
    String resolverTestHostname = "some-weird-hostname";
    URL testUrl = new URL(mUrl);
    ExperimentalCronetEngine.Builder cronetEngineBuilder =
        new ExperimentalCronetEngine.Builder(getContext());
    JSONObject hostResolverRules = new JSONObject().put(
        "host_resolver_rules", "MAP " + resolverTestHostname + " " + testUrl.getHost());
    JSONObject experimentalOptions = new JSONObject().put("HostResolverRules", hostResolverRules);
    cronetEngineBuilder.setExperimentalOptions(experimentalOptions.toString());

    final CronetEngine cronetEngine = cronetEngineBuilder.build();
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    URL requestUrl = new URL("http", resolverTestHostname, testUrl.getPort(), testUrl.getFile());
    UrlRequest.Builder urlRequestBuilder =
        cronetEngine.newUrlRequestBuilder(requestUrl.toString(), callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
  }

  /**
   * Runs {@code r} on {@code engine}'s network thread.
   */
  private static void postToNetworkThread(final CronetEngine engine, final Runnable r) {
    // Works by requesting an invalid URL which results in onFailed() being called, which is
    // done through a direct executor which causes onFailed to be run on the network thread.
    Executor directExecutor = new Executor() {
      @Override
      public void execute(Runnable runnable) {
        runnable.run();
      }
    };
    UrlRequest.Callback callback = new UrlRequest.Callback() {
      @Override
      public void onRedirectReceived(UrlRequest request, UrlResponseInfo responseInfo,
                                     String newLocationUrl) {}
      @Override
      public void onResponseStarted(UrlRequest request, UrlResponseInfo responseInfo) {}
      @Override
      public void onReadCompleted(UrlRequest request, UrlResponseInfo responseInfo,
                                  ByteBuffer byteBuffer) {}
      @Override
      public void onSucceeded(UrlRequest request, UrlResponseInfo responseInfo) {}

      @Override
      public void onFailed(UrlRequest request, UrlResponseInfo responseInfo,
                           CronetException error) {
        r.run();
      }
    };
    engine.newUrlRequestBuilder("http://invalid", callback, directExecutor).build().start();
  }

  /**
   * @return the thread priority of {@code engine}'s network thread.
   */
  private int getThreadPriority(CronetEngine engine) throws Exception {
    FutureTask<Integer> task = new FutureTask<>(new Callable<Integer>() {
      @Override
      public Integer call() {
        return Process.getThreadPriority(Process.myTid());
      }
    });
    postToNetworkThread(engine, task);
    return task.get();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @RequiresMinApi(6) // setThreadPriority added in API 6: crrev.com/472449
  public void testCronetEngineThreadPriority() throws Exception {
    ExperimentalCronetEngine.Builder builder = new ExperimentalCronetEngine.Builder(getContext());
    // Try out of bounds thread priorities.
    try {
      builder.setThreadPriority(-21);
      fail();
    } catch (IllegalArgumentException e) {
      assertEquals("Thread priority invalid", e.getMessage());
    }
    try {
      builder.setThreadPriority(20);
      fail();
    } catch (IllegalArgumentException e) {
      assertEquals("Thread priority invalid", e.getMessage());
    }
    // Test that valid thread priority range (-20..19) is working.
    for (int threadPriority = -20; threadPriority < 20; threadPriority++) {
      builder.setThreadPriority(threadPriority);
      CronetEngine engine = builder.build();
      assertEquals(threadPriority, getThreadPriority(engine));
      engine.shutdown();
    }
  }
}
package org.chromium.net;

import static org.chromium.net.testing.CronetTestRule.SERVER_CERT_PEM;
import static org.chromium.net.testing.CronetTestRule.SERVER_KEY_PKCS8_PEM;
import static org.chromium.net.testing.CronetTestRule.getContext;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import androidx.test.filters.SmallTest;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.CronetTestUtil;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.Http2TestServer;
import org.chromium.net.testing.TestFilesInstaller;
import org.chromium.net.testing.TestUrlRequestCallback;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

/**
 * Simple test for Brotli support.
 */
@RunWith(RobolectricTestRunner.class)
public class BrotliTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  private CronetEngine mCronetEngine;

  @Before
  public void setUp() throws Exception {
    TestFilesInstaller.installIfNeeded(getContext());
    assertTrue(
        Http2TestServer.startHttp2TestServer(getContext(), SERVER_CERT_PEM, SERVER_KEY_PKCS8_PEM));
  }

  @After
  public void tearDown() throws Exception {
    assertTrue(Http2TestServer.shutdownHttp2TestServer());
    if (mCronetEngine != null) {
      mCronetEngine.shutdown();
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBrotliAdvertised() throws Exception {
    ExperimentalCronetEngine.Builder builder = new ExperimentalCronetEngine.Builder(getContext());
    builder.enableBrotli(true);
    CronetTestUtil.setMockCertVerifierForTesting(builder);
    mCronetEngine = builder.build();
    String url = Http2TestServer.getEchoAllHeadersUrl();
    TestUrlRequestCallback callback = startAndWaitForComplete(url);
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    // TODO(carloseltuerto): also support "deflate" decompressor - Cronet does.
    assertTrue(callback.mResponseAsString.contains("accept-encoding: gzip,br"));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBrotliNotAdvertised() throws Exception {
    ExperimentalCronetEngine.Builder builder = new ExperimentalCronetEngine.Builder(getContext());
    CronetTestUtil.setMockCertVerifierForTesting(builder);
    mCronetEngine = builder.build();
    String url = Http2TestServer.getEchoAllHeadersUrl();
    TestUrlRequestCallback callback = startAndWaitForComplete(url);
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertFalse(callback.mResponseAsString.contains("br"));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBrotliDecoded() throws Exception {
    ExperimentalCronetEngine.Builder builder = new ExperimentalCronetEngine.Builder(getContext());
    builder.enableBrotli(true);
    CronetTestUtil.setMockCertVerifierForTesting(builder);
    mCronetEngine = builder.build();
    String url = Http2TestServer.getServeSimpleBrotliResponse();
    TestUrlRequestCallback callback = startAndWaitForComplete(url);
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    String expectedResponse = "The quick brown fox jumps over the lazy dog";
    assertEquals(expectedResponse, callback.mResponseAsString);
    // TODO(https://github.com/envoyproxy/envoy-mobile/issues/2086): uncomment this line.
    // assertEquals(callback.mResponseInfo.getAllHeaders().get("content-encoding").get(0),"br");
  }

  private TestUrlRequestCallback startAndWaitForComplete(String url) {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder =
        mCronetEngine.newUrlRequestBuilder(url, callback, callback.getExecutor());
    builder.build().start();
    callback.blockForDone();
    return callback;
  }
}
package org.chromium.net;

import static org.chromium.net.testing.CronetTestRule.assertContains;
import static org.chromium.net.testing.CronetTestRule.getContext;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.robolectric.Shadows.shadowOf;

import android.content.Context;
import android.content.Intent;
import android.Manifest;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Build;
import android.os.ConditionVariable;
import android.os.StrictMode;
import android.util.Log;
import androidx.test.filters.SmallTest;
import androidx.test.rule.GrantPermissionRule;
import java.io.IOException;
import java.net.ConnectException;
import java.nio.ByteBuffer;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import io.envoyproxy.envoymobile.engine.AndroidNetworkMonitor;
import org.chromium.net.impl.CronvoyUrlRequest;
import org.chromium.net.impl.Errors.EnvoyMobileError;
import org.chromium.net.impl.Errors.NetError;
import org.chromium.net.impl.CronvoyUrlResponseInfoImpl;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.CronetTestRule.CronetTestFramework;
import org.chromium.net.testing.CronetTestRule.RequiresMinApi;
import org.chromium.net.testing.FailurePhase;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.MockUrlRequestJobFactory;
import org.chromium.net.testing.NativeTestServer;
import org.chromium.net.testing.TestUploadDataProvider;
import org.chromium.net.testing.TestUrlRequestCallback;
import org.chromium.net.testing.TestUrlRequestCallback.FailureType;
import org.chromium.net.testing.TestUrlRequestCallback.ResponseStep;
import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.shadows.ShadowConnectivityManager;

/**
 * Test functionality of CronetUrlRequest.
 */
@RunWith(RobolectricTestRunner.class)
public class CronetUrlRequestTest {

  // URL used for base tests.
  private static final String TEST_URL = "http://127.0.0.1:8000";

  private static final String REFER_STRING = "refer";
  private static final String REFERRER_HEADER_NAME = REFER_STRING + "er";

  private final CronetTestRule mTestRule = new CronetTestRule();
  private final GrantPermissionRule mRuntimePermissionRule =
      GrantPermissionRule.grant(Manifest.permission.ACCESS_NETWORK_STATE);
  @Rule
  public final RuleChain chain = RuleChain.outerRule(mTestRule).around(mRuntimePermissionRule);

  private CronetTestFramework mTestFramework;
  private MockUrlRequestJobFactory mMockUrlRequestJobFactory;

  @Before
  public void setUp() {
    mMockUrlRequestJobFactory =
        new MockUrlRequestJobFactory(mTestRule.buildCronetTestFramework().mBuilder);
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
  }

  @After
  public void tearDown() {
    mMockUrlRequestJobFactory.shutdown();
    NativeTestServer.shutdownNativeTestServer();
  }

  private TestUrlRequestCallback startAndWaitForComplete(CronetEngine engine, String url)
      throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    // Create request.
    UrlRequest.Builder builder = engine.newUrlRequestBuilder(url, callback, callback.getExecutor());
    UrlRequest urlRequest = builder.build();
    urlRequest.start();
    callback.blockForDone();
    // Wait for all posted tasks to be executed to ensure there is no unhandled exception.
    callback.shutdownExecutorAndWait();
    assertTrue(urlRequest.isDone());
    return callback;
  }

  private void checkResponseInfo(UrlResponseInfo responseInfo, String expectedUrl,
                                 int expectedHttpStatusCode, String expectedHttpStatusText) {
    assertEquals(expectedUrl, responseInfo.getUrl());
    assertEquals(expectedUrl,
                 responseInfo.getUrlChain().get(responseInfo.getUrlChain().size() - 1));
    assertEquals(expectedHttpStatusCode, responseInfo.getHttpStatusCode());
    assertEquals(expectedHttpStatusText, responseInfo.getHttpStatusText());
    assertFalse(responseInfo.wasCached());
    assertTrue(responseInfo.toString().length() > 0);
  }

  private void checkResponseInfoHeader(UrlResponseInfo responseInfo, String headerName,
                                       String headerValue) {
    Map<String, List<String>> responseHeaders = responseInfo.getAllHeaders();
    List<String> header = responseHeaders.get(headerName);
    assertNotNull(header);
    assertTrue(header.contains(headerValue));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBuilderChecks() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    try {
      mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(null, callback,
                                                                       callback.getExecutor());
      fail("URL not null-checked");
    } catch (NullPointerException e) {
      assertEquals("URL is required.", e.getMessage());
    }
    try {
      mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
          NativeTestServer.getRedirectURL(), null, callback.getExecutor());
      fail("Callback not null-checked");
    } catch (NullPointerException e) {
      assertEquals("Callback is required.", e.getMessage());
    }
    try {
      mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
          NativeTestServer.getRedirectURL(), callback, null);
      fail("Executor not null-checked");
    } catch (NullPointerException e) {
      assertEquals("Executor is required.", e.getMessage());
    }
    // Verify successful creation doesn't throw.
    mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getRedirectURL(), callback, callback.getExecutor());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testSimpleGet() throws Exception {
    String url = NativeTestServer.getEchoMethodURL();
    TestUrlRequestCallback callback =
        startAndWaitForComplete(mMockUrlRequestJobFactory.getCronetEngine(), url);
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    // Default method is 'GET'.
    assertEquals("GET", callback.mResponseAsString);
    assertEquals(0, callback.mRedirectCount);
    assertEquals(callback.mResponseStep, ResponseStep.ON_SUCCEEDED);
    UrlResponseInfo urlResponseInfo =
        createUrlResponseInfo(new String[] {url}, "OK", 200, 86, "Connection", "close",
                              "Content-Length", "3", "Content-Type", "text/plain");
    mTestRule.assertResponseEquals(urlResponseInfo, callback.mResponseInfo);
    checkResponseInfo(callback.mResponseInfo, NativeTestServer.getEchoMethodURL(), 200, "OK");
  }

  private static UrlResponseInfo createUrlResponseInfo(String[] urls, String message,
                                                       int statusCode, int receivedBytes,
                                                       String... headers) {
    ArrayList<Map.Entry<String, String>> headersList = new ArrayList<>();
    for (int i = 0; i < headers.length; i += 2) {
      headersList.add(
          new AbstractMap.SimpleImmutableEntry<String, String>(headers[i], headers[i + 1]));
    }
    CronvoyUrlResponseInfoImpl unknown =
        new CronvoyUrlResponseInfoImpl(Arrays.asList(urls), statusCode, message, headersList, false,
                                       "unknown", ":0", receivedBytes);
    return unknown;
  }

  /**
   * Tests that disabling connection migration sets the URLRequest load flag correctly.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1522")
  public void testLoadFlagsWithConnectionMigration() throws Exception {}

  /**
   * Tests a redirect by running it step-by-step. Also tests that delaying a
   * request works as expected. To make sure there are no unexpected pending
   * messages, does a GET between UrlRequest.Callback callbacks.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testRedirectAsync() throws Exception {
    // Start the request and wait to see the redirect.
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    callback.setAutoAdvance(false);
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getRedirectURL(), callback, callback.getExecutor());
    UrlRequest urlRequest = builder.build();
    urlRequest.start();
    callback.waitForNextStep();

    // Check the redirect.
    assertEquals(ResponseStep.ON_RECEIVED_REDIRECT, callback.mResponseStep);
    assertEquals(1, callback.mRedirectResponseInfoList.size());
    checkResponseInfo(callback.mRedirectResponseInfoList.get(0), NativeTestServer.getRedirectURL(),
                      302, "Found");
    assertEquals(1, callback.mRedirectResponseInfoList.get(0).getUrlChain().size());
    assertEquals(NativeTestServer.getSuccessURL(), callback.mRedirectUrlList.get(0));
    checkResponseInfoHeader(callback.mRedirectResponseInfoList.get(0), "redirect-header",
                            "header-value");

    UrlResponseInfo expected = createUrlResponseInfo(
        new String[] {NativeTestServer.getRedirectURL()}, "Found", 302, 72, "Content-Length", "92",
        "Location", "/success.txt", "redirect-header", "header-value");
    mTestRule.assertResponseEquals(expected, callback.mRedirectResponseInfoList.get(0));

    // Wait for an unrelated request to finish. The request should not
    // advance until followRedirect is invoked.
    testSimpleGet();
    assertEquals(ResponseStep.ON_RECEIVED_REDIRECT, callback.mResponseStep);
    assertEquals(1, callback.mRedirectResponseInfoList.size());

    // Follow the redirect and wait for the next set of headers.
    urlRequest.followRedirect();
    callback.waitForNextStep();

    assertEquals(ResponseStep.ON_RESPONSE_STARTED, callback.mResponseStep);
    assertEquals(1, callback.mRedirectResponseInfoList.size());
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    checkResponseInfo(callback.mResponseInfo, NativeTestServer.getSuccessURL(), 200, "OK");
    assertEquals(2, callback.mResponseInfo.getUrlChain().size());
    assertEquals(NativeTestServer.getRedirectURL(), callback.mResponseInfo.getUrlChain().get(0));
    assertEquals(NativeTestServer.getSuccessURL(), callback.mResponseInfo.getUrlChain().get(1));

    // Wait for an unrelated request to finish. The request should not
    // advance until read is invoked.
    testSimpleGet();
    assertEquals(ResponseStep.ON_RESPONSE_STARTED, callback.mResponseStep);

    // One read should get all the characters, but best not to depend on
    // how much is actually read from the socket at once.
    while (!callback.isDone()) {
      callback.startNextRead(urlRequest);
      callback.waitForNextStep();
      String response = callback.mResponseAsString;
      ResponseStep step = callback.mResponseStep;
      if (!callback.isDone()) {
        assertEquals(ResponseStep.ON_READ_COMPLETED, step);
      }
      // Should not receive any messages while waiting for another get,
      // as the next read has not been started.
      testSimpleGet();
      assertEquals(response, callback.mResponseAsString);
      assertEquals(step, callback.mResponseStep);
    }
    assertEquals(ResponseStep.ON_SUCCEEDED, callback.mResponseStep);
    assertEquals(NativeTestServer.SUCCESS_BODY, callback.mResponseAsString);

    // Original bytesReceived: 258
    UrlResponseInfo urlResponseInfo = createUrlResponseInfo(
        new String[] {NativeTestServer.getRedirectURL(), NativeTestServer.getSuccessURL()}, "OK",
        200, 284, "Content-Length", "20", "Content-Type", "text/plain",
        "Access-Control-Allow-Origin", "*", "header-name", "header-value", "multi-header-name",
        "header-value1", "multi-header-name", "header-value2");

    mTestRule.assertResponseEquals(urlResponseInfo, callback.mResponseInfo);
    // Make sure there are no other pending messages, which would trigger
    // asserts in TestUrlRequestCallback.
    testSimpleGet();
  }

  /**
   * Tests redirect without location header doesn't cause a crash.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testRedirectWithNullLocationHeader() throws Exception {
    String url = NativeTestServer.getFileURL("/redirect_broken_header.html");
    TestUrlRequestCallback callback = new TestUrlRequestCallback();

    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        url, callback, callback.getExecutor());
    final UrlRequest urlRequest = builder.build();
    urlRequest.start();
    callback.blockForDone();
    assertEquals("<!DOCTYPE html>\n<html>\n<head>\n<title>Redirect</title>\n"
                     + "<p>Redirecting...</p>\n</head>\n</html>\n",
                 callback.mResponseAsString);
    assertEquals(ResponseStep.ON_SUCCEEDED, callback.mResponseStep);
    assertEquals(302, callback.mResponseInfo.getHttpStatusCode());
    assertNull(callback.mError);
    assertFalse(callback.mOnErrorCalled);
  }

  /**
   * Tests onRedirectReceived after cancel doesn't cause a crash.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testOnRedirectReceivedAfterCancel() throws Exception {
    final AtomicBoolean failedExpectation = new AtomicBoolean();
    TestUrlRequestCallback callback = new TestUrlRequestCallback() {
      @Override
      public void onRedirectReceived(UrlRequest request, UrlResponseInfo info,
                                     String newLocationUrl) {
        assertEquals(0, mRedirectCount);
        failedExpectation.compareAndSet(false, 0 != mRedirectCount);
        super.onRedirectReceived(request, info, newLocationUrl);
        // Cancel the request, so the second redirect will not be received.
        request.cancel();
      }

      @Override
      public void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
        failedExpectation.set(true);
        fail();
      }

      @Override
      public void onReadCompleted(UrlRequest request, UrlResponseInfo info, ByteBuffer byteBuffer) {
        failedExpectation.set(true);
        fail();
      }

      @Override
      public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
        failedExpectation.set(true);
        fail();
      }

      @Override
      public void onFailed(UrlRequest request, UrlResponseInfo info, CronetException error) {
        failedExpectation.set(true);
        fail();
      }

      @Override
      public void onCanceled(UrlRequest request, UrlResponseInfo info) {
        assertEquals(1, mRedirectCount);
        failedExpectation.compareAndSet(false, 1 != mRedirectCount);
        super.onCanceled(request, info);
      }
    };

    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getMultiRedirectURL(), callback, callback.getExecutor());

    final UrlRequest urlRequest = builder.build();
    urlRequest.start();
    callback.blockForDone();
    assertFalse(failedExpectation.get());
    // Check that only one redirect is received.
    assertEquals(1, callback.mRedirectCount);
    // Check that onCanceled is called.
    assertTrue(callback.mOnCanceledCalled);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testNotFound() throws Exception {
    String url = NativeTestServer.getFileURL("/notfound.html");
    TestUrlRequestCallback callback =
        startAndWaitForComplete(mMockUrlRequestJobFactory.getCronetEngine(), url);
    checkResponseInfo(callback.mResponseInfo, url, 404, "Not Found");
    assertEquals("<!DOCTYPE html>\n<html>\n<head>\n<title>Not found</title>\n"
                     + "<p>Test page loaded.</p>\n</head>\n</html>\n",
                 callback.mResponseAsString);
    assertEquals(0, callback.mRedirectCount);
    assertEquals(callback.mResponseStep, ResponseStep.ON_SUCCEEDED);
  }

  // Checks that UrlRequest.Callback.onFailed is only called once in the case
  // of ERR_CONTENT_LENGTH_MISMATCH, which has an unusual failure path.
  // See http://crbug.com/468803.
  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1550")
  public void testContentLengthMismatchFailsOnce() throws Exception {
    String url = NativeTestServer.getFileURL("/content_length_mismatch.html");
    TestUrlRequestCallback callback =
        startAndWaitForComplete(mMockUrlRequestJobFactory.getCronetEngine(), url);
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    // The entire response body will be read before the error is returned.
    // This is because the network stack returns data as it's read from the
    // socket, and the socket close message which triggers the error will
    // only be passed along after all data has been read.
    assertEquals("Response that lies about content length.", callback.mResponseAsString);
    assertNotNull(callback.mError);
    assertContains("Exception in CronetUrlRequest: net::ERR_CONTENT_LENGTH_MISMATCH",
                   callback.mError.getMessage());
    // Wait for a couple round trips to make sure there are no pending
    // onFailed messages. This test relies on checks in
    // TestUrlRequestCallback catching a second onFailed call.
    testSimpleGet();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testSetHttpMethod() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    String methodName = "HEAD";
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoMethodURL(), callback, callback.getExecutor());
    // Try to set 'null' method.
    try {
      builder.setHttpMethod(null);
      fail("Exception not thrown");
    } catch (NullPointerException e) {
      assertEquals("Method is required.", e.getMessage());
    }

    builder.setHttpMethod(methodName);
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(0, callback.mHttpResponseDataLength);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBadMethod() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        TEST_URL, callback, callback.getExecutor());
    try {
      builder.setHttpMethod("bad:method!");
      builder.build().start();
      fail("IllegalArgumentException not thrown.");
    } catch (IllegalArgumentException e) {
      assertEquals("Invalid http method bad:method!", e.getMessage());
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBadHeaderName() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        TEST_URL, callback, callback.getExecutor());
    try {
      builder.addHeader("header:name", "headervalue");
      builder.build().start();
      fail("IllegalArgumentException not thrown.");
    } catch (IllegalArgumentException e) {
      assertEquals("Invalid header header:name=headervalue", e.getMessage());
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testAcceptEncodingIgnored() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoAllHeadersURL(), callback, callback.getExecutor());
    // This line should eventually throw an exception, once callers have migrated
    builder.addHeader("accept-encoding", "foozip");
    builder.build().start();
    callback.blockForDone();
    assertFalse(callback.mResponseAsString.contains("foozip"));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBadHeaderValue() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        TEST_URL, callback, callback.getExecutor());
    try {
      builder.addHeader("headername", "bad header\r\nvalue");
      builder.build().start();
      fail("IllegalArgumentException not thrown.");
    } catch (IllegalArgumentException e) {
      assertEquals("Invalid header headername=bad header\r\nvalue", e.getMessage());
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testAddHeader() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    String headerName = "header-name";
    String headerValue = "header-value";
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoHeaderURL(headerName), callback, callback.getExecutor());

    builder.addHeader(headerName, headerValue);
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(headerValue, callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Consider deleting - header values don't get dropped - this test seems bogus")
  public void testMultiRequestHeaders() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    String headerName = "header-name";
    String headerValue1 = "header-value1";
    String headerValue2 = "header-value2";
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoAllHeadersURL(), callback, callback.getExecutor());
    builder.addHeader(headerName, headerValue1);
    builder.addHeader(headerName, headerValue2);
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    String headers = callback.mResponseAsString;
    Pattern pattern = Pattern.compile(headerName + ":\\s(.*)\\r\\n");
    Matcher matcher = pattern.matcher(headers);
    List<String> actualValues = new ArrayList<String>();
    while (matcher.find()) {
      actualValues.add(matcher.group(1));
    }
    assertEquals(1, actualValues.size());
    assertEquals("header-value2", actualValues.get(0));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testCustomReferer_verbatim() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    String refererValue = "http://example.com/";
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoHeaderURL(REFERRER_HEADER_NAME), callback, callback.getExecutor());
    builder.addHeader(REFERRER_HEADER_NAME, refererValue);
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(refererValue, callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1551")
  public void testCustomReferer_changeToCanonical() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    String refererValueNoTrailingSlash = "http://example.com";
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoHeaderURL(REFERRER_HEADER_NAME), callback, callback.getExecutor());
    builder.addHeader(REFERRER_HEADER_NAME, refererValueNoTrailingSlash);
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(refererValueNoTrailingSlash + "/", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1551")
  public void testCustomReferer_discardInvalid() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    String invalidRefererValue = "foobar";
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoHeaderURL(REFERRER_HEADER_NAME), callback, callback.getExecutor());
    builder.addHeader(REFERRER_HEADER_NAME, invalidRefererValue);
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("Header not found. :(", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testCustomUserAgent() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    String userAgentName = "user-agent";
    String userAgentValue = "User-Agent-Value";
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoHeaderURL(userAgentName), callback, callback.getExecutor());
    builder.addHeader(userAgentName, userAgentValue);
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(userAgentValue, callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testDefaultUserAgent() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    String headerName = "user-agent";
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoHeaderURL(headerName), callback, callback.getExecutor());
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertTrue("Default User-Agent should contain Cronet/n.n.n.n but is " +
                   callback.mResponseAsString,
               Pattern.matches(".+Cronet/\\d+\\.\\d+\\.\\d+\\.\\d+.+", callback.mResponseAsString));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testMockSuccess() throws Exception {
    TestUrlRequestCallback callback = startAndWaitForComplete(
        mMockUrlRequestJobFactory.getCronetEngine(), NativeTestServer.getSuccessURL());
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(0, callback.mRedirectResponseInfoList.size());
    assertTrue(callback.mHttpResponseDataLength != 0);
    assertEquals(callback.mResponseStep, ResponseStep.ON_SUCCEEDED);
    Map<String, List<String>> responseHeaders = callback.mResponseInfo.getAllHeaders();
    assertEquals("header-value", responseHeaders.get("header-name").get(0));
    List<String> multiHeader = responseHeaders.get("multi-header-name");
    assertEquals(2, multiHeader.size());
    assertEquals("header-value1", multiHeader.get(0));
    assertEquals("header-value2", multiHeader.get(1));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testResponseHeadersList() throws Exception {
    TestUrlRequestCallback callback = startAndWaitForComplete(
        mMockUrlRequestJobFactory.getCronetEngine(), NativeTestServer.getSuccessURL());
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    List<Map.Entry<String, String>> responseHeaders = callback.mResponseInfo.getAllHeadersAsList();

    assertEquals(responseHeaders.get(0), new AbstractMap.SimpleEntry<>("Content-Length", "20"));
    assertEquals(responseHeaders.get(1),
                 new AbstractMap.SimpleEntry<>("Content-Type", "text/plain"));
    assertEquals(responseHeaders.get(2),
                 new AbstractMap.SimpleEntry<>("Access-Control-Allow-Origin", "*"));
    assertEquals(responseHeaders.get(3),
                 new AbstractMap.SimpleEntry<>("header-name", "header-value"));
    assertEquals(responseHeaders.get(4),
                 new AbstractMap.SimpleEntry<>("multi-header-name", "header-value1"));
    assertEquals(responseHeaders.get(5),
                 new AbstractMap.SimpleEntry<>("multi-header-name", "header-value2"));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testMockMultiRedirect() throws Exception {
    TestUrlRequestCallback callback = startAndWaitForComplete(
        mMockUrlRequestJobFactory.getCronetEngine(), NativeTestServer.getMultiRedirectURL());
    UrlResponseInfo mResponseInfo = callback.mResponseInfo;
    assertEquals(2, callback.mRedirectCount);
    assertEquals(200, mResponseInfo.getHttpStatusCode());
    assertEquals(2, callback.mRedirectResponseInfoList.size());

    // Check first redirect (multiredirect.html -> redirect.html)
    // Original receivedBytes: 76
    UrlResponseInfo firstExpectedResponseInfo = createUrlResponseInfo(
        new String[] {NativeTestServer.getMultiRedirectURL()}, "Found", 302, 75, "Content-Length",
        "92", "Location", "/redirect.html", "redirect-header0", "header-value");
    UrlResponseInfo firstRedirectResponseInfo = callback.mRedirectResponseInfoList.get(0);
    mTestRule.assertResponseEquals(firstExpectedResponseInfo, firstRedirectResponseInfo);

    // Check second redirect (redirect.html -> success.txt)
    // Original receivedBytes: 334
    UrlResponseInfo secondExpectedResponseInfo = createUrlResponseInfo(
        new String[] {NativeTestServer.getMultiRedirectURL(), NativeTestServer.getRedirectURL(),
                      NativeTestServer.getSuccessURL()},
        "OK", 200, 359, "Content-Length", "20", "Content-Type", "text/plain",
        "Access-Control-Allow-Origin", "*", "header-name", "header-value", "multi-header-name",
        "header-value1", "multi-header-name", "header-value2");

    mTestRule.assertResponseEquals(secondExpectedResponseInfo, mResponseInfo);
    assertTrue(callback.mHttpResponseDataLength != 0);
    assertEquals(2, callback.mRedirectCount);
    assertEquals(callback.mResponseStep, ResponseStep.ON_SUCCEEDED);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testMockNotFound() throws Exception {
    TestUrlRequestCallback callback = startAndWaitForComplete(
        mMockUrlRequestJobFactory.getCronetEngine(), NativeTestServer.getNotFoundURL());
    UrlResponseInfo expected =
        createUrlResponseInfo(new String[] {NativeTestServer.getNotFoundURL()}, "Not Found", 404,
                              142, "Content-Length", "96");
    mTestRule.assertResponseEquals(expected, callback.mResponseInfo);
    assertTrue(callback.mHttpResponseDataLength != 0);
    assertEquals(0, callback.mRedirectCount);
    assertFalse(callback.mOnErrorCalled);
    assertEquals(callback.mResponseStep, ResponseStep.ON_SUCCEEDED);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1549")
  public void testMockStartAsyncError() throws Exception {
    final int arbitraryNetError = -3;
    TestUrlRequestCallback callback = startAndWaitForComplete(
        mMockUrlRequestJobFactory.getCronetEngine(),
        MockUrlRequestJobFactory.getMockUrlWithFailure(FailurePhase.START, arbitraryNetError));
    assertNull(callback.mResponseInfo);
    assertNotNull(callback.mError);
    assertEquals(arbitraryNetError,
                 ((NetworkException)callback.mError).getCronetInternalErrorCode());
    assertEquals(0, callback.mRedirectCount);
    assertTrue(callback.mOnErrorCalled);
    assertEquals(ResponseStep.ON_FAILED, callback.mResponseStep);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1549")
  public void testMockReadDataSyncError() throws Exception {
    final int arbitraryNetError = -4;
    TestUrlRequestCallback callback = startAndWaitForComplete(
        mMockUrlRequestJobFactory.getCronetEngine(),
        MockUrlRequestJobFactory.getMockUrlWithFailure(FailurePhase.READ_SYNC, arbitraryNetError));
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(15, callback.mResponseInfo.getReceivedByteCount());
    assertNotNull(callback.mError);
    assertEquals(arbitraryNetError,
                 ((NetworkException)callback.mError).getCronetInternalErrorCode());
    assertEquals(0, callback.mRedirectCount);
    assertTrue(callback.mOnErrorCalled);
    assertEquals(ResponseStep.ON_FAILED, callback.mResponseStep);
  }

  /**
   * Tests that request continues when client certificate is requested.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1549")
  public void testMockClientCertificateRequested() throws Exception {
    TestUrlRequestCallback callback =
        startAndWaitForComplete(mMockUrlRequestJobFactory.getCronetEngine(),
                                MockUrlRequestJobFactory.getMockUrlForClientCertificateRequest());
    assertNotNull(callback.mResponseInfo);
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("data", callback.mResponseAsString);
    assertEquals(0, callback.mRedirectCount);
    assertNull(callback.mError);
    assertFalse(callback.mOnErrorCalled);
  }

  /**
   * Tests that an SSL cert error will be reported via {@link UrlRequest.Callback#onFailed}.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1549")
  public void testMockSSLCertificateError() throws Exception {
    TestUrlRequestCallback callback =
        startAndWaitForComplete(mMockUrlRequestJobFactory.getCronetEngine(),
                                MockUrlRequestJobFactory.getMockUrlForSSLCertificateError());
    assertNull(callback.mResponseInfo);
    assertNotNull(callback.mError);
    assertTrue(callback.mOnErrorCalled);
    assertEquals(-201, ((NetworkException)callback.mError).getCronetInternalErrorCode());
    assertContains("Exception in CronetUrlRequest: net::ERR_CERT_DATE_INVALID",
                   callback.mError.getMessage());
    assertEquals(ResponseStep.ON_FAILED, callback.mResponseStep);
  }

  /**
   * Tests that an SSL cert error with upload will be reported via {@link
   * UrlRequest.Callback#onFailed}.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1549")
  public void testSSLCertificateError() throws Exception {}

  /**
   * Checks that the buffer is updated correctly, when starting at an offset.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testSimpleGetBufferUpdates() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    callback.setAutoAdvance(false);
    // Since the default method is "GET", the expected response body is also
    // "GET".
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoMethodURL(), callback, callback.getExecutor());
    UrlRequest urlRequest = builder.build();
    urlRequest.start();
    callback.waitForNextStep();

    ByteBuffer readBuffer = ByteBuffer.allocateDirect(5);
    readBuffer.put("FOR".getBytes());
    assertEquals(3, readBuffer.position());

    // Read first two characters of the response ("GE"). It's theoretically
    // possible to need one read per character, though in practice,
    // shouldn't happen.
    while (callback.mResponseAsString.length() < 2) {
      assertFalse(callback.isDone());
      callback.startNextRead(urlRequest, readBuffer);
      callback.waitForNextStep();
    }

    // Make sure the two characters were read.
    assertEquals("GE", callback.mResponseAsString);

    // Check the contents of the entire buffer. The first 3 characters
    // should not have been changed, and the last two should be the first
    // two characters from the response.
    assertEquals("FORGE", bufferContentsToString(readBuffer, 0, 5));
    // The limit and position should be 5.
    assertEquals(5, readBuffer.limit());
    assertEquals(5, readBuffer.position());

    assertEquals(ResponseStep.ON_READ_COMPLETED, callback.mResponseStep);

    // Start reading from position 3. Since the only remaining character
    // from the response is a "T", when the read completes, the buffer
    // should contain "FORTE", with a position() of 4 and a limit() of 5.
    readBuffer.position(3);
    callback.startNextRead(urlRequest, readBuffer);
    callback.waitForNextStep();

    // Make sure all three characters of the response have now been read.
    assertEquals("GET", callback.mResponseAsString);

    // Check the entire contents of the buffer. Only the third character
    // should have been modified.
    assertEquals("FORTE", bufferContentsToString(readBuffer, 0, 5));

    // Make sure position and limit were updated correctly.
    assertEquals(4, readBuffer.position());
    assertEquals(5, readBuffer.limit());

    assertEquals(ResponseStep.ON_READ_COMPLETED, callback.mResponseStep);

    // One more read attempt. The request should complete.
    readBuffer.position(1);
    readBuffer.limit(5);
    callback.startNextRead(urlRequest, readBuffer);
    callback.waitForNextStep();

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("GET", callback.mResponseAsString);
    checkResponseInfo(callback.mResponseInfo, NativeTestServer.getEchoMethodURL(), 200, "OK");

    // Check that buffer contents were not modified.
    assertEquals("FORTE", bufferContentsToString(readBuffer, 0, 5));

    // Position should not have been modified, since nothing was read.
    assertEquals(1, readBuffer.position());
    // Limit should be unchanged as always.
    assertEquals(5, readBuffer.limit());

    assertEquals(ResponseStep.ON_SUCCEEDED, callback.mResponseStep);

    // Make sure there are no other pending messages, which would trigger
    // asserts in TestUrlRequestCallback.
    testSimpleGet();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBadBuffers() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    callback.setAutoAdvance(false);
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoMethodURL(), callback, callback.getExecutor());
    UrlRequest urlRequest = builder.build();
    urlRequest.start();
    callback.waitForNextStep();

    // Try to read using a full buffer.
    try {
      ByteBuffer readBuffer = ByteBuffer.allocateDirect(4);
      readBuffer.put("full".getBytes());
      urlRequest.read(readBuffer);
      fail("Exception not thrown");
    } catch (IllegalArgumentException e) {
      assertEquals("ByteBuffer is already full.", e.getMessage());
    }

    // Try to read using a non-direct buffer.
    try {
      ByteBuffer readBuffer = ByteBuffer.allocate(5);
      urlRequest.read(readBuffer);
      fail("Exception not thrown");
    } catch (IllegalArgumentException e) {
      assertEquals("byteBuffer must be a direct ByteBuffer.", e.getMessage());
    }

    // Finish the request with a direct ByteBuffer.
    callback.setAutoAdvance(true);
    ByteBuffer readBuffer = ByteBuffer.allocateDirect(5);
    urlRequest.read(readBuffer);
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("GET", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testNoIoInCancel() throws Exception {
    final TestUrlRequestCallback callback = new TestUrlRequestCallback();
    callback.setAutoAdvance(false);
    final UrlRequest urlRequest =
        mMockUrlRequestJobFactory.getCronetEngine()
            .newUrlRequestBuilder(NativeTestServer.getEchoHeaderURL("blah-header"), callback,
                                  callback.getExecutor())
            .addHeader("blah-header", "blahblahblah")
            .build();
    urlRequest.start();
    callback.waitForNextStep();
    callback.startNextRead(urlRequest, ByteBuffer.allocateDirect(4));
    callback.waitForNextStep();
    StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
    StrictMode.setThreadPolicy(
        new StrictMode.ThreadPolicy.Builder().detectAll().penaltyDeath().penaltyLog().build());
    try {
      urlRequest.cancel();
    } finally {
      StrictMode.setThreadPolicy(oldPolicy);
    }
    callback.blockForDone();
    assertEquals(true, callback.mOnCanceledCalled);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUnexpectedReads() throws Exception {
    final TestUrlRequestCallback callback = new TestUrlRequestCallback();
    callback.setAutoAdvance(false);
    final UrlRequest urlRequest = mMockUrlRequestJobFactory.getCronetEngine()
                                      .newUrlRequestBuilder(NativeTestServer.getRedirectURL(),
                                                            callback, callback.getExecutor())
                                      .build();

    // Try to read before starting request.
    try {
      callback.startNextRead(urlRequest);
      fail("Exception not thrown");
    } catch (IllegalStateException e) {
    }

    // Verify reading right after start throws an assertion. Both must be
    // invoked on the Executor thread, to prevent receiving data until after
    // startNextRead has been invoked.
    Runnable startAndRead = new Runnable() {
      @Override
      public void run() {
        urlRequest.start();
        try {
          callback.startNextRead(urlRequest);
          fail("Exception not thrown");
        } catch (IllegalStateException e) {
        }
      }
    };
    callback.getExecutor().submit(startAndRead).get();
    callback.waitForNextStep();

    assertEquals(callback.mResponseStep, ResponseStep.ON_RECEIVED_REDIRECT);
    // Try to read after the redirect.
    try {
      callback.startNextRead(urlRequest);
      fail("Exception not thrown");
    } catch (IllegalStateException e) {
    }
    urlRequest.followRedirect();
    callback.waitForNextStep();

    assertEquals(callback.mResponseStep, ResponseStep.ON_RESPONSE_STARTED);
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());

    while (!callback.isDone()) {
      Runnable readTwice = new Runnable() {
        @Override
        public void run() {
          callback.startNextRead(urlRequest);
          // Try to read again before the last read completes.
          try {
            callback.startNextRead(urlRequest);
            fail("Exception not thrown");
          } catch (IllegalStateException e) {
          }
        }
      };
      callback.getExecutor().submit(readTwice).get();
      callback.waitForNextStep();
    }

    assertEquals(callback.mResponseStep, ResponseStep.ON_SUCCEEDED);
    assertEquals(NativeTestServer.SUCCESS_BODY, callback.mResponseAsString);

    // Try to read after request is complete.
    try {
      callback.startNextRead(urlRequest);
      fail("Exception not thrown");
    } catch (IllegalStateException e) {
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUnexpectedFollowRedirects() throws Exception {
    final TestUrlRequestCallback callback = new TestUrlRequestCallback();
    callback.setAutoAdvance(false);
    final UrlRequest urlRequest = mMockUrlRequestJobFactory.getCronetEngine()
                                      .newUrlRequestBuilder(NativeTestServer.getRedirectURL(),
                                                            callback, callback.getExecutor())
                                      .build();

    // Try to follow a redirect before starting the request.
    try {
      urlRequest.followRedirect();
      fail("Exception not thrown");
    } catch (IllegalStateException e) {
    }

    // Try to follow a redirect just after starting the request. Has to be
    // done on the executor thread to avoid a race.
    Runnable startAndRead = new Runnable() {
      @Override
      public void run() {
        urlRequest.start();
        try {
          urlRequest.followRedirect();
          fail("Exception not thrown");
        } catch (IllegalStateException e) {
        }
      }
    };
    callback.getExecutor().execute(startAndRead);
    callback.waitForNextStep();

    assertEquals(callback.mResponseStep, ResponseStep.ON_RECEIVED_REDIRECT);
    // Try to follow the redirect twice. Second attempt should fail.
    Runnable followRedirectTwice = new Runnable() {
      @Override
      public void run() {
        urlRequest.followRedirect();
        try {
          urlRequest.followRedirect();
          fail("Exception not thrown");
        } catch (IllegalStateException e) {
        }
      }
    };
    callback.getExecutor().execute(followRedirectTwice);
    callback.waitForNextStep();

    assertEquals(callback.mResponseStep, ResponseStep.ON_RESPONSE_STARTED);
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());

    while (!callback.isDone()) {
      try {
        urlRequest.followRedirect();
        fail("Exception not thrown");
      } catch (IllegalStateException e) {
      }
      callback.startNextRead(urlRequest);
      callback.waitForNextStep();
    }

    assertEquals(callback.mResponseStep, ResponseStep.ON_SUCCEEDED);
    assertEquals(NativeTestServer.SUCCESS_BODY, callback.mResponseAsString);

    // Try to follow redirect after request is complete.
    try {
      urlRequest.followRedirect();
      fail("Exception not thrown");
    } catch (IllegalStateException e) {
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadSetDataProvider() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    try {
      builder.setUploadDataProvider(null, callback.getExecutor());
      fail("Exception not thrown");
    } catch (NullPointerException e) {
      assertEquals("Invalid UploadDataProvider.", e.getMessage());
    }

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    try {
      builder.build().start();
      fail("Exception not thrown");
    } catch (IllegalArgumentException e) {
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadEmptyBodySync() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();

    assertEquals(0, dataProvider.getUploadedLength());
    assertEquals(0, dataProvider.getNumReadCalls());
    assertEquals(0, dataProvider.getNumRewindCalls());

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("", callback.mResponseAsString);
    dataProvider.assertClosed();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadSync() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(4, dataProvider.getUploadedLength());
    assertEquals(1, dataProvider.getNumReadCalls());
    assertEquals(0, dataProvider.getNumRewindCalls());

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("test", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadMultiplePiecesSync() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.addRead("Y".getBytes());
    dataProvider.addRead("et ".getBytes());
    dataProvider.addRead("another ".getBytes());
    dataProvider.addRead("test".getBytes());

    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(16, dataProvider.getUploadedLength());
    assertEquals(4, dataProvider.getNumReadCalls());
    assertEquals(0, dataProvider.getNumRewindCalls());

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("Yet another test", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadMultiplePiecesAsync() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.ASYNC, callback.getExecutor());
    dataProvider.addRead("Y".getBytes());
    dataProvider.addRead("et ".getBytes());
    dataProvider.addRead("another ".getBytes());
    dataProvider.addRead("test".getBytes());

    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(16, dataProvider.getUploadedLength());
    assertEquals(4, dataProvider.getNumReadCalls());
    assertEquals(0, dataProvider.getNumRewindCalls());

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("Yet another test", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadChangesDefaultMethod() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoMethodURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("POST", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadWithSetMethod() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoMethodURL(), callback, callback.getExecutor());

    final String method = "PUT";
    builder.setHttpMethod(method);

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("PUT", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadRedirectSync() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getRedirectToEchoBody(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    // 1 read call before the rewind, 1 after.
    assertEquals(2, dataProvider.getNumReadCalls());
    assertEquals(1, dataProvider.getNumRewindCalls());

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("test", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadRedirectAsync() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getRedirectToEchoBody(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.ASYNC, callback.getExecutor());
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    dataProvider.assertClosed();
    callback.blockForDone();

    // 1 read call before the rewind, 1 after.
    assertEquals(2, dataProvider.getNumReadCalls());
    assertEquals(1, dataProvider.getNumRewindCalls());

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("test", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadWithBadLength() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor()) {
      @Override
      public long getLength() throws IOException {
        return 1;
      }

      @Override
      public void read(UploadDataSink uploadDataSink, ByteBuffer byteBuffer) throws IOException {
        byteBuffer.put("12".getBytes());
        uploadDataSink.onReadSucceeded(false);
      }
    };
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertContains("Exception received from UploadDataProvider", callback.mError.getMessage());
    assertContains("Read upload data length 2 exceeds expected length 1",
                   callback.mError.getCause().getMessage());
    assertEquals(null, callback.mResponseInfo);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadWithBadLengthBufferAligned() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor()) {
      @Override
      public long getLength() throws IOException {
        return 8191;
      }

      @Override
      public void read(UploadDataSink uploadDataSink, ByteBuffer byteBuffer) throws IOException {
        byteBuffer.put("0123456789abcdef".getBytes());
        uploadDataSink.onReadSucceeded(false);
      }
    };
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();
    assertContains("Exception received from UploadDataProvider", callback.mError.getMessage());
    assertContains("Read upload data length 8192 exceeds expected length 8191",
                   callback.mError.getCause().getMessage());
    assertEquals(null, callback.mResponseInfo);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadReadFailSync() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.setReadFailure(0, TestUploadDataProvider.FailMode.CALLBACK_SYNC);
    // This will never be read, but if the length is 0, read may never be
    // called.
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(1, dataProvider.getNumReadCalls());
    assertEquals(0, dataProvider.getNumRewindCalls());

    assertContains("Exception received from UploadDataProvider", callback.mError.getMessage());
    assertContains("Sync read failure", callback.mError.getCause().getMessage());
    assertEquals(null, callback.mResponseInfo);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadLengthFailSync() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.setLengthFailure();
    // This will never be read, but if the length is 0, read may never be
    // called.
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(0, dataProvider.getNumReadCalls());
    assertEquals(0, dataProvider.getNumRewindCalls());

    assertContains("Exception received from UploadDataProvider", callback.mError.getMessage());
    assertContains("Sync length failure", callback.mError.getCause().getMessage());
    assertEquals(null, callback.mResponseInfo);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadReadFailAsync() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.setReadFailure(0, TestUploadDataProvider.FailMode.CALLBACK_ASYNC);
    // This will never be read, but if the length is 0, read may never be
    // called.
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(1, dataProvider.getNumReadCalls());
    assertEquals(0, dataProvider.getNumRewindCalls());

    assertContains("Exception received from UploadDataProvider", callback.mError.getMessage());
    assertContains("Async read failure", callback.mError.getCause().getMessage());
    assertEquals(null, callback.mResponseInfo);
  }

  /** This test uses a direct executor for upload, and non direct for callbacks */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testDirectExecutorUploadProhibitedByDefault() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    Executor myExecutor = new Executor() {
      @Override
      public void execute(Runnable command) {
        command.run();
      }
    };
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider =
        new TestUploadDataProvider(TestUploadDataProvider.SuccessCallbackMode.SYNC, myExecutor);
    // This will never be read, but if the length is 0, read may never be
    // called.
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, myExecutor);
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();

    assertEquals(0, dataProvider.getNumReadCalls());
    assertEquals(0, dataProvider.getNumRewindCalls());

    assertContains("Exception received from UploadDataProvider", callback.mError.getMessage());
    assertContains("Inline execution is prohibited for this request",
                   callback.mError.getCause().getMessage());
    assertEquals(null, callback.mResponseInfo);
  }

  /** This test uses a direct executor for callbacks, and non direct for upload */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testDirectExecutorProhibitedByDefault() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    Executor myExecutor = new Executor() {
      @Override
      public void execute(Runnable command) {
        command.run();
      }
    };
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, myExecutor);

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    // This will never be read, but if the length is 0, read may never be
    // called.
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();

    assertEquals(1, dataProvider.getNumReadCalls());
    assertEquals(0, dataProvider.getNumRewindCalls());

    assertContains("Exception posting task to executor", callback.mError.getMessage());
    assertContains("Inline execution is prohibited for this request",
                   callback.mError.getCause().getMessage());
    assertEquals(null, callback.mResponseInfo);
    dataProvider.assertClosed();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testDirectExecutorAllowed() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    callback.setAllowDirectExecutor(true);
    Executor myExecutor = new Executor() {
      @Override
      public void execute(Runnable command) {
        command.run();
      }
    };
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, myExecutor);
    UploadDataProvider dataProvider = UploadDataProviders.create("test".getBytes());
    builder.setUploadDataProvider(dataProvider, myExecutor);
    builder.addHeader("content-type", "useless/string");
    builder.allowDirectExecutor();
    builder.build().start();
    callback.blockForDone();

    if (callback.mOnErrorCalled) {
      throw callback.mError;
    }

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("test", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadReadFailThrown() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.setReadFailure(0, TestUploadDataProvider.FailMode.THROWN);
    // This will never be read, but if the length is 0, read may never be
    // called.
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(1, dataProvider.getNumReadCalls());
    assertEquals(0, dataProvider.getNumRewindCalls());

    assertContains("Exception received from UploadDataProvider", callback.mError.getMessage());
    assertContains("Thrown read failure", callback.mError.getCause().getMessage());
    assertEquals(null, callback.mResponseInfo);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadRewindFailSync() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getRedirectToEchoBody(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.setRewindFailure(TestUploadDataProvider.FailMode.CALLBACK_SYNC);
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(1, dataProvider.getNumReadCalls());
    assertEquals(1, dataProvider.getNumRewindCalls());

    assertContains("Exception received from UploadDataProvider", callback.mError.getMessage());
    assertContains("Sync rewind failure", callback.mError.getCause().getMessage());
    assertEquals(null, callback.mResponseInfo);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadRewindFailAsync() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getRedirectToEchoBody(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.ASYNC, callback.getExecutor());
    dataProvider.setRewindFailure(TestUploadDataProvider.FailMode.CALLBACK_ASYNC);
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(1, dataProvider.getNumReadCalls());
    assertEquals(1, dataProvider.getNumRewindCalls());

    assertContains("Exception received from UploadDataProvider", callback.mError.getMessage());
    assertContains("Async rewind failure", callback.mError.getCause().getMessage());
    assertEquals(null, callback.mResponseInfo);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadRewindFailThrown() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getRedirectToEchoBody(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.setRewindFailure(TestUploadDataProvider.FailMode.THROWN);
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(1, dataProvider.getNumReadCalls());
    assertEquals(1, dataProvider.getNumRewindCalls());

    assertContains("Exception received from UploadDataProvider", callback.mError.getMessage());
    assertContains("Thrown rewind failure", callback.mError.getCause().getMessage());
    assertEquals(null, callback.mResponseInfo);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadChunked() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.addRead("test hello".getBytes());
    dataProvider.setChunked(true);
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");

    assertEquals(-1, dataProvider.getUploadedLength());

    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    // 1 read call for one data chunk.
    assertEquals(1, dataProvider.getNumReadCalls());
    assertEquals("test hello", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadChunkedLastReadZeroLengthBody() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    // Add 3 reads. The last read has a 0-length body.
    dataProvider.addRead("hello there".getBytes());
    dataProvider.addRead("!".getBytes());
    dataProvider.addRead("".getBytes());
    dataProvider.setChunked(true);
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");

    assertEquals(-1, dataProvider.getUploadedLength());

    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    // 2 read call for the first two data chunks, and 1 for final chunk.
    assertEquals(3, dataProvider.getNumReadCalls());
    assertEquals("hello there!", callback.mResponseAsString);
  }

  // Test where an upload fails without ever initializing the
  // UploadDataStream, because it can't connect to the server.
  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1550")
  public void testUploadFailsWithoutInitializingStream() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    // The port for PTP will always refuse a TCP connection
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        "http://127.0.0.1:319", callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertNull(callback.mResponseInfo);
    assertContains("Exception in CronetUrlRequest: net::ERR_CONNECTION_REFUSED",
                   callback.mError.getMessage());
  }

  private TestUrlRequestCallback throwOrCancel(FailureType failureType, ResponseStep failureStep,
                                               boolean expectError) {
    if (Log.isLoggable("TESTING", Log.VERBOSE)) {
      Log.v("TESTING", "Testing " + failureType + " during " + failureStep);
    }
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    callback.setFailure(failureType, failureStep);
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getRedirectURL(), callback, callback.getExecutor());
    UrlRequest urlRequest = builder.build();
    urlRequest.start();
    callback.blockForDone();
    // Wait for all posted tasks to be executed to ensure there is no unhandled exception.
    callback.shutdownExecutorAndWait();
    assertEquals(1, callback.mRedirectCount);
    if (failureType == FailureType.CANCEL_SYNC || failureType == FailureType.CANCEL_ASYNC) {
      assertResponseStepCanceled(callback);
    } else if (failureType == FailureType.THROW_SYNC) {
      assertEquals(ResponseStep.ON_FAILED, callback.mResponseStep);
    }
    assertTrue(urlRequest.isDone());
    assertEquals(expectError, callback.mError != null);
    assertEquals(expectError, callback.mOnErrorCalled);
    // When failureType is FailureType.CANCEL_ASYNC_WITHOUT_PAUSE and failureStep is
    // ResponseStep.ON_READ_COMPLETED, there might be an onSucceeded() task already posted. If
    // that's the case, onCanceled() will not be invoked. See crbug.com/657415.
    if (!(failureType == FailureType.CANCEL_ASYNC_WITHOUT_PAUSE &&
          failureStep == ResponseStep.ON_READ_COMPLETED)) {
      assertEquals(failureType == FailureType.CANCEL_SYNC ||
                       failureType == FailureType.CANCEL_ASYNC ||
                       failureType == FailureType.CANCEL_ASYNC_WITHOUT_PAUSE,
                   callback.mOnCanceledCalled);
    }
    return callback;
  }

  private void throwOrCancel(FailureType failureType, ResponseStep failureStep,
                             boolean expectResponseInfo, boolean expectError) {
    TestUrlRequestCallback callback = throwOrCancel(failureType, failureStep, expectError);
    assertEquals(expectResponseInfo, callback.mResponseInfo != null);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testFailures() throws Exception {
    throwOrCancel(FailureType.CANCEL_SYNC, ResponseStep.ON_RECEIVED_REDIRECT, false, false);
    throwOrCancel(FailureType.CANCEL_ASYNC, ResponseStep.ON_RECEIVED_REDIRECT, false, false);
    throwOrCancel(FailureType.CANCEL_ASYNC_WITHOUT_PAUSE, ResponseStep.ON_RECEIVED_REDIRECT, false);
    throwOrCancel(FailureType.THROW_SYNC, ResponseStep.ON_RECEIVED_REDIRECT, false, true);

    throwOrCancel(FailureType.CANCEL_SYNC, ResponseStep.ON_RESPONSE_STARTED, true, false);
    throwOrCancel(FailureType.CANCEL_ASYNC, ResponseStep.ON_RESPONSE_STARTED, true, false);
    throwOrCancel(FailureType.CANCEL_ASYNC_WITHOUT_PAUSE, ResponseStep.ON_RESPONSE_STARTED, false);
    throwOrCancel(FailureType.THROW_SYNC, ResponseStep.ON_RESPONSE_STARTED, true, true);

    throwOrCancel(FailureType.CANCEL_SYNC, ResponseStep.ON_READ_COMPLETED, true, false);
    throwOrCancel(FailureType.CANCEL_ASYNC, ResponseStep.ON_READ_COMPLETED, true, false);
    throwOrCancel(FailureType.CANCEL_ASYNC_WITHOUT_PAUSE, ResponseStep.ON_READ_COMPLETED, false);
    throwOrCancel(FailureType.THROW_SYNC, ResponseStep.ON_READ_COMPLETED, true, true);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testThrowOrCancelInOnSucceeded() {
    FailureType[] testTypes = new FailureType[] {FailureType.THROW_SYNC, FailureType.CANCEL_SYNC,
                                                 FailureType.CANCEL_ASYNC};
    for (FailureType type : testTypes) {
      TestUrlRequestCallback callback = new TestUrlRequestCallback();
      callback.setFailure(type, ResponseStep.ON_SUCCEEDED);
      UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
          NativeTestServer.getEchoMethodURL(), callback, callback.getExecutor());
      UrlRequest urlRequest = builder.build();
      urlRequest.start();
      callback.blockForDone();
      // Wait for all posted tasks to be executed to ensure there is no unhandled exception.
      callback.shutdownExecutorAndWait();
      assertNull(callback.mError);
      assertEquals(ResponseStep.ON_SUCCEEDED, callback.mResponseStep);
      assertTrue(urlRequest.isDone());
      assertNotNull(callback.mResponseInfo);
      assertFalse(callback.mOnErrorCalled);
      assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
      assertEquals("GET", callback.mResponseAsString);
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testThrowOrCancelInOnFailed() {
    FailureType[] testTypes = new FailureType[] {FailureType.THROW_SYNC, FailureType.CANCEL_SYNC,
                                                 FailureType.CANCEL_ASYNC};
    for (FailureType type : testTypes) {
      String url = NativeTestServer.getEchoBodyURL();
      // Shut down NativeTestServer so request will fail.
      NativeTestServer.shutdownNativeTestServer();
      TestUrlRequestCallback callback = new TestUrlRequestCallback();
      callback.setFailure(type, ResponseStep.ON_FAILED);
      UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
          url, callback, callback.getExecutor());
      UrlRequest urlRequest = builder.build();
      urlRequest.start();
      callback.blockForDone();
      // Wait for all posted tasks to be executed to ensure there is no unhandled exception.
      callback.shutdownExecutorAndWait();
      assertEquals(ResponseStep.ON_FAILED, callback.mResponseStep);
      assertTrue(callback.mOnErrorCalled);
      assertNotNull(callback.mError);
      assertTrue(urlRequest.isDone());
      // Start NativeTestServer again to run the test for a second time.
      assertTrue(NativeTestServer.startNativeTestServer(getContext()));
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testThrowOrCancelInOnCanceled() {
    FailureType[] testTypes = new FailureType[] {FailureType.THROW_SYNC, FailureType.CANCEL_SYNC,
                                                 FailureType.CANCEL_ASYNC};
    for (FailureType type : testTypes) {
      TestUrlRequestCallback callback = new TestUrlRequestCallback() {
        @Override
        public void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
          super.onResponseStarted(request, info);
          request.cancel();
        }
      };
      callback.setFailure(type, ResponseStep.ON_CANCELED);
      UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
          NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());
      UrlRequest urlRequest = builder.build();
      urlRequest.start();
      callback.blockForDone();
      // Wait for all posted tasks to be executed to ensure there is no unhandled exception.
      callback.shutdownExecutorAndWait();
      assertResponseStepCanceled(callback);
      assertTrue(urlRequest.isDone());
      assertNotNull(callback.mResponseInfo);
      assertNull(callback.mError);
      assertTrue(callback.mOnCanceledCalled);
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Not yet implemented")
  public void testExecutorShutdown() {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();

    callback.setAutoAdvance(false);
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());
    CronvoyUrlRequest urlRequest = (CronvoyUrlRequest)builder.build();
    urlRequest.start();
    callback.waitForNextStep();
    assertFalse(callback.isDone());
    assertFalse(urlRequest.isDone());

    final ConditionVariable requestDestroyed = new ConditionVariable(false);
    // urlRequest.setOnDestroyedCallbackForTesting(new Runnable() {
    //     @Override
    //     public void run() {
    //         requestDestroyed.open();
    //     }
    // });

    // Shutdown the executor, so posting the task will throw an exception.
    callback.shutdownExecutor();
    ByteBuffer readBuffer = ByteBuffer.allocateDirect(5);
    urlRequest.read(readBuffer);
    // Callback will never be called again because executor is shutdown,
    // but request will be destroyed from network thread.
    requestDestroyed.block();

    assertFalse(callback.isDone());
    assertTrue(urlRequest.isDone());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testUploadExecutorShutdown() throws Exception {
    class HangingUploadDataProvider extends UploadDataProvider {
      UploadDataSink mUploadDataSink;
      ByteBuffer mByteBuffer;
      ConditionVariable mReadCalled = new ConditionVariable(false);

      @Override
      public long getLength() {
        return 69;
      }

      @Override
      public void read(final UploadDataSink uploadDataSink, final ByteBuffer byteBuffer) {
        mUploadDataSink = uploadDataSink;
        mByteBuffer = byteBuffer;
        mReadCalled.open();
      }

      @Override
      public void rewind(final UploadDataSink uploadDataSink) {}
    }

    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    ExecutorService uploadExecutor = Executors.newSingleThreadExecutor();
    HangingUploadDataProvider dataProvider = new HangingUploadDataProvider();
    builder.setUploadDataProvider(dataProvider, uploadExecutor);
    builder.addHeader("content-type", "useless/string");
    UrlRequest urlRequest = builder.build();
    urlRequest.start();
    // Wait for read to be called on executor.
    dataProvider.mReadCalled.block();
    // Shutdown the executor, so posting next task will throw an exception.
    uploadExecutor.shutdown();
    // Continue the upload.
    dataProvider.mByteBuffer.putInt(42);
    dataProvider.mUploadDataSink.onReadSucceeded(false);
    // Callback.onFailed will be called on request executor even though upload
    // executor is shutdown.
    callback.blockForDone();
    assertTrue(callback.isDone());
    assertTrue(callback.mOnErrorCalled);
    assertContains("Exception received from UploadDataProvider", callback.mError.getMessage());
    assertTrue(urlRequest.isDone());
  }

  /**
   * A TestUrlRequestCallback that shuts down executor upon receiving onSucceeded callback.
   */
  private static class QuitOnSuccessCallback extends TestUrlRequestCallback {
    @Override
    public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
      // Stop accepting new tasks.
      shutdownExecutor();
      super.onSucceeded(request, info);
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Not yet implemented")
  public void testDestroyUploadDataStreamAdapterOnSucceededCallback() throws Exception {
    TestUrlRequestCallback callback = new QuitOnSuccessCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    CronvoyUrlRequest request = (CronvoyUrlRequest)builder.build();
    final ConditionVariable uploadDataStreamAdapterDestroyed = new ConditionVariable();
    // request.setOnDestroyedUploadCallbackForTesting(new Runnable() {
    //     @Override
    //     public void run() {
    //         uploadDataStreamAdapterDestroyed.open();
    //     }
    // });

    request.start();
    uploadDataStreamAdapterDestroyed.block();
    callback.blockForDone();

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("", callback.mResponseAsString);
  }

  /*
   * Verifies error codes are passed through correctly.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testErrorCodes() throws Exception {
    checkSpecificErrorCode(EnvoyMobileError.DNS_RESOLUTION_FAILED, NetError.ERR_NAME_NOT_RESOLVED,
                           NetworkException.ERROR_HOSTNAME_NOT_RESOLVED, "NAME_NOT_RESOLVED",
                           false);
    checkSpecificErrorCode(EnvoyMobileError.UPSTREAM_CONNECTION_TERMINATION,
                           NetError.ERR_CONNECTION_CLOSED, NetworkException.ERROR_CONNECTION_CLOSED,
                           "CONNECTION_CLOSED", true);
    checkSpecificErrorCode(EnvoyMobileError.UPSTREAM_CONNECTION_FAILURE,
                           NetError.ERR_CONNECTION_REFUSED,
                           NetworkException.ERROR_CONNECTION_REFUSED, "CONNECTION_REFUSED", false);
    checkSpecificErrorCode(EnvoyMobileError.UPSTREAM_REMOTE_RESET, NetError.ERR_CONNECTION_RESET,
                           NetworkException.ERROR_CONNECTION_RESET, "CONNECTION_RESET", true);
    checkSpecificErrorCode(EnvoyMobileError.STREAM_IDLE_TIMEOUT, NetError.ERR_TIMED_OUT,
                           NetworkException.ERROR_TIMED_OUT, "TIMED_OUT", true);
    checkSpecificErrorCode(0x2000, NetError.ERR_OTHER, NetworkException.ERROR_OTHER, "OTHER",
                           false);
  }

  /*
   * Verifies INTERNET_DISCONNECTED error is thrown when no network
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testInternetDisconnectedError() throws Exception {
    AndroidNetworkMonitor androidNetworkMonitor = AndroidNetworkMonitor.getInstance();
    Intent intent = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
    // save old networkInfo before overriding
    NetworkInfo networkInfo = androidNetworkMonitor.getConnectivityManager().getActiveNetworkInfo();

    // simulate no network
    ShadowConnectivityManager connectivityManager =
        shadowOf(androidNetworkMonitor.getConnectivityManager());
    connectivityManager.setActiveNetworkInfo(null);
    androidNetworkMonitor.onReceive(getContext(), intent);

    // send request and confirm errorcode
    checkSpecificErrorCode(
        EnvoyMobileError.DNS_RESOLUTION_FAILED, NetError.ERR_INTERNET_DISCONNECTED,
        NetworkException.ERROR_INTERNET_DISCONNECTED, "INTERNET_DISCONNECTED", false);

    // bring back online since the AndroidNetworkMonitor class is a singleton
    connectivityManager.setActiveNetworkInfo(networkInfo);
    androidNetworkMonitor.onReceive(getContext(), intent);
  }

  /*
   * Verifies no cookies are saved or sent by default.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testCookiesArentSavedOrSent() throws Exception {
    // Make a request to a url that sets the cookie
    String url = NativeTestServer.getFileURL("/set_cookie.html");
    TestUrlRequestCallback callback =
        startAndWaitForComplete(mMockUrlRequestJobFactory.getCronetEngine(), url);
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("A=B", callback.mResponseInfo.getAllHeaders().get("Set-Cookie").get(0));

    // Make a request that check that cookie header isn't sent.
    String headerName = "Cookie";
    String url2 = NativeTestServer.getEchoHeaderURL(headerName);
    TestUrlRequestCallback callback2 =
        startAndWaitForComplete(mMockUrlRequestJobFactory.getCronetEngine(), url2);
    assertEquals(200, callback2.mResponseInfo.getHttpStatusCode());
    assertEquals("Header not found. :(", callback2.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testQuicErrorCode() throws Exception {
    long envoyMobileError = 0x2000;
    TestUrlRequestCallback callback = startAndWaitForComplete(
        mMockUrlRequestJobFactory.getCronetEngine(),
        MockUrlRequestJobFactory.getMockQuicUrlWithFailure(envoyMobileError));
    assertNull(callback.mResponseInfo);
    assertNotNull(callback.mError);
    assertEquals(NetworkException.ERROR_QUIC_PROTOCOL_FAILED,
                 ((NetworkException)callback.mError).getErrorCode());
    assertTrue(callback.mError instanceof QuicException);
    QuicException quicException = (QuicException)callback.mError;
    // 1 is QUIC_INTERNAL_ERROR
    assertEquals(1, quicException.getQuicDetailedErrorCode());
  }

  /**
   * Tests that legacy onFailed callback is invoked with UrlRequestException if there
   * is no onFailed callback implementation that takes CronetException.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testLegacyOnFailedCallback() throws Exception {
    final long envoyMobileError = 0x2000;
    final int netError = NetError.ERR_OTHER.getErrorCode();
    final AtomicBoolean failedExpectation = new AtomicBoolean();
    final ConditionVariable done = new ConditionVariable();
    UrlRequest.Callback callback = new UrlRequest.Callback() {
      @Override
      public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
        failedExpectation.set(true);
        fail();
      }

      @Override
      public void onRedirectReceived(UrlRequest request, UrlResponseInfo info,
                                     String newLocationUrl) {
        failedExpectation.set(true);
        fail();
      }

      @Override
      public void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
        failedExpectation.set(true);
        fail();
      }

      @Override
      public void onReadCompleted(UrlRequest request, UrlResponseInfo info, ByteBuffer byteBuffer) {
        failedExpectation.set(true);
        fail();
      }

      @Override
      public void onFailed(UrlRequest request, UrlResponseInfo info, CronetException error) {
        assertTrue(error instanceof NetworkException);
        assertEquals(netError, ((NetworkException)error).getCronetInternalErrorCode());
        failedExpectation.set(((NetworkException)error).getCronetInternalErrorCode() != netError);
        done.open();
      }

      @Override
      public void onCanceled(UrlRequest request, UrlResponseInfo info) {
        failedExpectation.set(true);
        fail();
      }
    };

    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        MockUrlRequestJobFactory.getMockUrlWithFailure(envoyMobileError), callback,
        Executors.newSingleThreadExecutor());
    final UrlRequest urlRequest = builder.build();
    urlRequest.start();
    done.block();
    // Check that onFailed is called.
    assertFalse(failedExpectation.get());
  }

  private void checkSpecificErrorCode(@EnvoyMobileError long envoyMobileError, NetError netError,
                                      int errorCode, String name, boolean immediatelyRetryable)
      throws Exception {
    TestUrlRequestCallback callback =
        startAndWaitForComplete(mMockUrlRequestJobFactory.getCronetEngine(),
                                MockUrlRequestJobFactory.getMockUrlWithFailure(envoyMobileError));
    assertNull(callback.mResponseInfo);
    assertNotNull(callback.mError);
    assertEquals(netError.getErrorCode(),
                 ((NetworkException)callback.mError).getCronetInternalErrorCode());
    assertEquals(errorCode, ((NetworkException)callback.mError).getErrorCode());
    assertEquals(immediatelyRetryable, ((NetworkException)callback.mError).immediatelyRetryable());
    assertContains("Exception in CronvoyUrlRequest: net::ERR_" + name,
                   callback.mError.getMessage());
    assertEquals(0, callback.mRedirectCount);
    assertTrue(callback.mOnErrorCalled);
    assertEquals(ResponseStep.ON_FAILED, callback.mResponseStep);
  }

  // Returns the contents of byteBuffer, from its position() to its limit(),
  // as a String. Does not modify byteBuffer's position().
  private String bufferContentsToString(ByteBuffer byteBuffer, int start, int end) {
    // Use a duplicate to avoid modifying byteBuffer.
    ByteBuffer duplicate = byteBuffer.duplicate();
    duplicate.position(start);
    duplicate.limit(end);
    byte[] contents = new byte[duplicate.remaining()];
    duplicate.get(contents);
    return new String(contents);
  }

  private void assertResponseStepCanceled(TestUrlRequestCallback callback) {
    if (callback.mResponseStep == ResponseStep.ON_FAILED && callback.mError != null) {
      throw new Error("Unexpected response state: " + ResponseStep.ON_FAILED, callback.mError);
    }
    assertEquals(ResponseStep.ON_CANCELED, callback.mResponseStep);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1550")
  public void testCleartextTrafficBlocked() throws Exception {
    // This feature only works starting from N.
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
      final int cleartextNotPermitted = -29;
      // This hostname needs to match the one in network_security_config.xml and the one used
      // by QuicTestServer.
      // https requests to it are tested in QuicTest, so this checks that we're only blocking
      // cleartext.
      final String url = "http://example.com/simple.txt";
      TestUrlRequestCallback callback =
          startAndWaitForComplete(mMockUrlRequestJobFactory.getCronetEngine(), url);
      assertNull(callback.mResponseInfo);
      assertNotNull(callback.mError);
      assertEquals(cleartextNotPermitted,
                   ((NetworkException)callback.mError).getCronetInternalErrorCode());
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  /**
   * Open many connections and cancel them right away. This test verifies all internal
   * sockets and other Closeables are properly closed. See crbug.com/726193.
   */
  public void testGzipCancel() throws Exception {
    String url = NativeTestServer.getFileURL("/gzipped.html");
    for (int i = 0; i < 100; i++) {
      TestUrlRequestCallback callback = new TestUrlRequestCallback();
      callback.setAutoAdvance(false);
      UrlRequest urlRequest = mMockUrlRequestJobFactory.getCronetEngine()
                                  .newUrlRequestBuilder(url, callback, callback.getExecutor())
                                  .build();
      urlRequest.start();
      urlRequest.cancel();
      // If the test blocks until each UrlRequest finishes before starting the next UrlRequest
      // then it never catches the leak. If it starts all UrlRequests and then blocks until
      // all UrlRequests finish, it only catches the leak ~10% of the time. In its current
      // form it appears to catch the leak ~70% of the time.
      // Catching the leak may require a lot of busy threads so that the cancel() happens
      // before the UrlRequest has made much progress (and set mCurrentUrlConnection and
      // mResponseChannel). This may be why blocking until each UrlRequest finishes doesn't
      // catch the leak.
      // The other quirk of this is that from teardown(), JavaCronetEngine.shutdown() is
      // called which calls ExecutorService.shutdown() which doesn't wait for the thread to
      // finish running tasks, and then teardown() calls GC looking for leaks. One possible
      // modification would be to expose the ExecutorService and then have tests call
      // awaitTermination() but this would complicate things, and adding a 1s sleep() to
      // allow the ExecutorService to terminate did not increase the chances of catching the
      // leak.
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @RequiresMinApi(8) // JavaUrlRequest fixed in API level 8: crrev.com/499303
  /** Do a HEAD request and get back a 404. */
  public void test404Head() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
        NativeTestServer.getFileURL("/notfound.html"), callback, callback.getExecutor());
    builder.setHttpMethod("HEAD").build().start();
    callback.blockForDone();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @RequiresMinApi(9) // Tagging support added in API level 9: crrev.com/c/chromium/src/+/930086
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1521")
  public void testTagging() throws Exception {}

  @Test
  @SmallTest
  @Feature({"Cronet"})
  /**
   * Initiate many requests concurrently to make sure neither Cronet implementation crashes.
   */
  public void testManyRequests() throws Exception {
    String url = NativeTestServer.getMultiRedirectURL();
    final int numRequests = 1000;
    TestUrlRequestCallback callbacks[] = new TestUrlRequestCallback[numRequests];
    UrlRequest requests[] = new UrlRequest[numRequests];
    for (int i = 0; i < numRequests; i++) {
      // Share the first callback's executor to avoid creating too many single-threaded
      // executors and hence too many threads.
      if (i == 0) {
        callbacks[i] = new TestUrlRequestCallback();
      } else {
        callbacks[i] = new TestUrlRequestCallback(callbacks[0].getExecutor());
      }
      UrlRequest.Builder builder = mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
          url, callbacks[i], callbacks[i].getExecutor());
      requests[i] = builder.build();
    }
    for (UrlRequest request : requests) {
      request.start();
    }
    for (UrlRequest request : requests) {
      request.cancel();
    }
    for (TestUrlRequestCallback callback : callbacks) {
      callback.blockForDone();
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testSetIdempotency() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    ExperimentalUrlRequest.Builder builder =
        mMockUrlRequestJobFactory.getCronetEngine().newUrlRequestBuilder(
            NativeTestServer.getEchoMethodURL(), callback, callback.getExecutor());
    assertEquals(builder.setIdempotency(ExperimentalUrlRequest.Builder.IDEMPOTENT), builder);

    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, callback.getExecutor());
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("content-type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("POST", callback.mResponseAsString);
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:kotlin_test.bzl", "envoy_mobile_android_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_android_test(
    name = "net_tests",
    srcs = [
        "BrotliTest.java",
        "CronetEngineBuilderTest.java",
        "CronetStressTest.java",
        "DiskStorageTest.java",
        "GetStatusTest.java",
        "RequestFinishedInfoTest.java",
        "UploadDataProvidersTest.java",
        "UrlResponseInfoTest.java",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/utilities",
        "//library/java/org/chromium/net",
        "//library/java/org/chromium/net/impl:cronvoy",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/org/chromium/net/testing",
    ],
)

envoy_mobile_android_test(
    name = "cronet_url_request_context_test",
    srcs = [
        "CronetUrlRequestContextTest.java",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_engine_lib",
        "//library/java/org/chromium/net",
        "//library/java/org/chromium/net/impl:cronvoy",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/org/chromium/net/testing",
    ],
)

envoy_mobile_android_test(
    name = "cronet_url_request_test",
    srcs = [
        "CronetUrlRequestTest.java",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_engine_lib",
        "//library/java/org/chromium/net",
        "//library/java/org/chromium/net/impl:cronvoy",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/org/chromium/net/testing",
    ],
)

envoy_mobile_android_test(
    name = "bidirectional_stream_test",
    srcs = [
        "BidirectionalStreamTest.java",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_engine_lib",
        "//library/java/org/chromium/net",
        "//library/java/org/chromium/net/impl:cronvoy",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/org/chromium/net/testing",
    ],
)
package org.chromium.net;

import static org.chromium.net.testing.CronetTestRule.getContext;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.os.ConditionVariable;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import java.io.IOException;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import org.chromium.net.UrlRequest.Status;
import org.chromium.net.UrlRequest.StatusListener;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.CronetTestRule.CronetTestFramework;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.NativeTestServer;
import org.chromium.net.testing.TestUploadDataProvider;
import org.chromium.net.testing.TestUrlRequestCallback;
import org.chromium.net.testing.TestUrlRequestCallback.ResponseStep;
import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;

/**
 * Tests that {@link org.chromium.net.impl.CronetUrlRequest#getStatus(StatusListener)} works as
 * expected.
 */
@RunWith(AndroidJUnit4.class)
public class GetStatusTest {

  @Rule public final CronetTestRule mTestRule = new CronetTestRule();
  @Rule public final ExpectedException thrown = ExpectedException.none();

  private CronetTestFramework mTestFramework;

  private static class TestStatusListener extends StatusListener {
    boolean mOnStatusCalled;
    int mStatus = Integer.MAX_VALUE;
    private final ConditionVariable mBlock = new ConditionVariable();

    @Override
    public void onStatus(int status) {
      mOnStatusCalled = true;
      mStatus = status;
      mBlock.open();
    }

    public void waitUntilOnStatusCalled() {
      mBlock.block();
      mBlock.close();
    }
  }
  @Before
  public void setUp() throws Exception {
    mTestFramework = mTestRule.startCronetTestFramework();
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
  }

  @After
  public void tearDown() throws Exception {
    NativeTestServer.shutdownNativeTestServer();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testSimpleGet() throws Exception {
    String url = NativeTestServer.getEchoMethodURL();
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    callback.setAutoAdvance(false);
    UrlRequest.Builder builder =
        mTestFramework.mCronetEngine.newUrlRequestBuilder(url, callback, callback.getExecutor());
    UrlRequest urlRequest = builder.build();
    // Calling before request is started should give Status.INVALID,
    // since the native adapter is not created.
    TestStatusListener statusListener0 = new TestStatusListener();
    urlRequest.getStatus(statusListener0);
    statusListener0.waitUntilOnStatusCalled();
    assertTrue(statusListener0.mOnStatusCalled);
    assertEquals(Status.INVALID, statusListener0.mStatus);

    urlRequest.start();

    // Should receive a valid status.
    TestStatusListener statusListener1 = new TestStatusListener();
    urlRequest.getStatus(statusListener1);
    statusListener1.waitUntilOnStatusCalled();
    assertTrue(statusListener1.mOnStatusCalled);
    assertTrue("Status is :" + statusListener1.mStatus, statusListener1.mStatus >= Status.IDLE);
    assertTrue("Status is :" + statusListener1.mStatus,
               statusListener1.mStatus <= Status.READING_RESPONSE);

    callback.waitForNextStep();
    assertEquals(ResponseStep.ON_RESPONSE_STARTED, callback.mResponseStep);
    callback.startNextRead(urlRequest);

    // Should receive a valid status.
    TestStatusListener statusListener2 = new TestStatusListener();
    urlRequest.getStatus(statusListener2);
    statusListener2.waitUntilOnStatusCalled();
    assertTrue(statusListener2.mOnStatusCalled);
    assertTrue(statusListener1.mStatus >= Status.IDLE);
    assertTrue(statusListener1.mStatus <= Status.READING_RESPONSE);

    callback.waitForNextStep();
    assertEquals(ResponseStep.ON_READ_COMPLETED, callback.mResponseStep);

    callback.startNextRead(urlRequest);
    callback.blockForDone();

    // Calling after request done should give Status.INVALID, since
    // the native adapter is destroyed.
    TestStatusListener statusListener3 = new TestStatusListener();
    urlRequest.getStatus(statusListener3);
    statusListener3.waitUntilOnStatusCalled();
    assertTrue(statusListener3.mOnStatusCalled);
    assertEquals(Status.INVALID, statusListener3.mStatus);

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("GET", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Not used in Cronvoy")
  public void testInvalidLoadState() throws Exception {
    try {
      // UrlRequestBase.convertLoadState(LoadState.WAITING_FOR_APPCACHE);
      fail();
    } catch (IllegalArgumentException e) {
      // Expected because LoadState.WAITING_FOR_APPCACHE is not mapped.
    }

    thrown.expect(Throwable.class);
    // UrlRequestBase.convertLoadState(-1);
    // UrlRequestBase.convertLoadState(16);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Regression test for crbug.com/606872.
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1519")
  public void testGetStatusForUpload() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mTestFramework.mCronetEngine.newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());

    final ConditionVariable block = new ConditionVariable();
    // Use a separate executor for UploadDataProvider so the upload can be
    // stalled while getStatus gets processed.
    Executor uploadProviderExecutor = Executors.newSingleThreadExecutor();
    TestUploadDataProvider dataProvider = new TestUploadDataProvider(
        TestUploadDataProvider.SuccessCallbackMode.SYNC, uploadProviderExecutor) {
      @Override
      public long getLength() throws IOException {
        // Pause the data provider.
        block.block();
        block.close();
        return super.getLength();
      }
    };
    dataProvider.addRead("test".getBytes());
    builder.setUploadDataProvider(dataProvider, uploadProviderExecutor);
    builder.addHeader("Content-Type", "useless/string");
    UrlRequest urlRequest = builder.build();
    TestStatusListener statusListener = new TestStatusListener();
    urlRequest.start();
    // Call getStatus() immediately after start(), which will post
    // startInternal() to the upload provider's executor because there is an
    // upload. When CronetUrlRequestAdapter::GetStatusOnNetworkThread is
    // executed, the |url_request_| is null.
    urlRequest.getStatus(statusListener);
    statusListener.waitUntilOnStatusCalled();
    assertTrue(statusListener.mOnStatusCalled);
    // The request should be in IDLE state because GetStatusOnNetworkThread
    // is called before |url_request_| is initialized and started.
    assertEquals(Status.IDLE, statusListener.mStatus);
    // Resume the UploadDataProvider.
    block.open();

    // Make sure the request is successful and there is no crash.
    callback.blockForDone();
    dataProvider.assertClosed();

    assertEquals(4, dataProvider.getUploadedLength());
    assertEquals(1, dataProvider.getNumReadCalls());
    assertEquals(0, dataProvider.getNumRewindCalls());

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("test", callback.mResponseAsString);
  }
}
package test.kotlin.integration;

import static org.assertj.core.api.Assertions.assertThat;

import android.content.Context;
import androidx.test.core.app.ApplicationProvider;
import io.envoyproxy.envoymobile.AndroidEngineBuilder;
import io.envoyproxy.envoymobile.Engine;
import io.envoyproxy.envoymobile.EnvoyError;
import io.envoyproxy.envoymobile.FinalStreamIntel;
import io.envoyproxy.envoymobile.LogLevel;
import io.envoyproxy.envoymobile.RequestHeaders;
import io.envoyproxy.envoymobile.RequestHeadersBuilder;
import io.envoyproxy.envoymobile.RequestMethod;
import io.envoyproxy.envoymobile.ResponseHeaders;
import io.envoyproxy.envoymobile.ResponseTrailers;
import io.envoyproxy.envoymobile.Stream;
import io.envoyproxy.envoymobile.StreamIntel;
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary;
import io.envoyproxy.envoymobile.engine.testing.RequestScenario;
import io.envoyproxy.envoymobile.engine.testing.Response;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.AbstractMap.SimpleImmutableEntry;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import okhttp3.mockwebserver.Dispatcher;
import okhttp3.mockwebserver.MockResponse;
import okhttp3.mockwebserver.MockWebServer;
import okhttp3.mockwebserver.RecordedRequest;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

@RunWith(RobolectricTestRunner.class)
public class AndroidEngineSocketTagTest {

  private final MockWebServer mockWebServer = new MockWebServer();
  private Engine engine;

  @BeforeClass
  public static void loadJniLibrary() {
    AndroidJniLibrary.loadTestLibrary();
  }

  @Before
  public void setUpEngine() throws Exception {
    CountDownLatch latch = new CountDownLatch(1);
    Context appContext = ApplicationProvider.getApplicationContext();
    engine = new AndroidEngineBuilder(appContext)
                 .addLogLevel(LogLevel.OFF)
                 .enableSocketTagging(true)
                 .setOnEngineRunning(() -> {
                   latch.countDown();
                   return null;
                 })
                 .build();
    latch.await(); // Don't launch a request before initialization has completed.
  }

  @After
  public void shutdownEngine() throws Exception {
    engine.terminate();
    mockWebServer.shutdown();
  }

  @Test
  public void socket_tag() throws Exception {
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        assertThat(recordedRequest.getMethod()).isEqualTo(RequestMethod.GET.name());
        assertThat(recordedRequest.getHeader("x-envoy-mobile-socket-tag")).isEqualTo(null);
        return new MockResponse().setBody("This is my response Body");
      }
    });
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.GET)
                                          .setUrl(mockWebServer.url("post/flowers").toString())
                                          .addSocketTag(1, 2);

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("This is my response Body");
    assertThat(response.getEnvoyError()).isNull();
  }

  private Response sendRequest(RequestScenario requestScenario) throws Exception {
    final CountDownLatch latch = new CountDownLatch(1);
    final AtomicReference<Response> response = new AtomicReference<>(new Response());
    final AtomicReference<Stream> streamRef = new AtomicReference<>();

    Stream stream =
        engine.streamClient()
            .newStreamPrototype()
            .setOnResponseHeaders((responseHeaders, endStream, streamIntel) -> {
              response.get().setHeaders(responseHeaders);
              if (requestScenario.cancelOnResponseHeaders) {
                streamRef.get().cancel(); // Should be a noop when endStream == true
              } else {
                if (requestScenario.waitOnReadData) {
                  try {
                    Thread.sleep(100 + (int)(Math.random() * 50));
                  } catch (InterruptedException e) {
                    // Don't care
                  }
                }
                streamRef.get().readData(requestScenario.responseBufferSize);
              }
              return null;
            })
            .setOnResponseData((data, endStream, streamIntel) -> {
              response.get().addBody(data);
              if (!endStream) {
                if (requestScenario.waitOnReadData) {
                  try {
                    Thread.sleep(100 + (int)(Math.random() * 50));
                  } catch (InterruptedException e) {
                    // Don't care
                  }
                }
                streamRef.get().readData(requestScenario.responseBufferSize);
              }
              return null;
            })
            .setOnError((error, finalStreamIntel) -> {
              response.get().setEnvoyError(error);
              latch.countDown();
              return null;
            })
            .setOnCancel((finalStreamIntel) -> {
              response.get().setCancelled();
              latch.countDown();
              return null;
            })
            .setOnComplete((finalStreamIntel) -> {
              latch.countDown();
              return null;
            })
            .setExplicitFlowControl(true)
            .start(requestScenario.useDirectExecutor ? Runnable::run
                                                     : Executors.newSingleThreadExecutor());
    streamRef.set(stream); // Set before sending headers to avoid race conditions.
    stream.sendHeaders(requestScenario.getHeaders(), !requestScenario.hasBody());
    latch.await();
    response.get().throwAssertionErrorIfAny();
    return response.get();
  }
}
package test.kotlin.integration;

import android.content.Context;
import androidx.test.core.app.ApplicationProvider;
import io.envoyproxy.envoymobile.AndroidEngineBuilder;
import io.envoyproxy.envoymobile.Engine;
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

import static org.assertj.core.api.Assertions.assertThat;

// NOLINT(namespace-envoy)

@RunWith(RobolectricTestRunner.class)
public class AndroidEnvoyEngineStartUpTest {
  static { AndroidJniLibrary.loadTestLibrary(); }

  private final Context appContext = ApplicationProvider.getApplicationContext();

  @Test
  public void ensure_engine_starts_and_terminates() throws InterruptedException {
    Engine engine = new AndroidEngineBuilder(appContext).build();
    Thread.sleep(1000);
    engine.terminate();
    assertThat(true).isTrue();
  }
}
package test.kotlin.integration;

import static org.assertj.core.api.Assertions.assertThat;

import android.content.Context;
import androidx.test.core.app.ApplicationProvider;
import io.envoyproxy.envoymobile.AndroidEngineBuilder;
import io.envoyproxy.envoymobile.Engine;
import io.envoyproxy.envoymobile.EnvoyError;
import io.envoyproxy.envoymobile.FinalStreamIntel;
import io.envoyproxy.envoymobile.LogLevel;
import io.envoyproxy.envoymobile.RequestHeaders;
import io.envoyproxy.envoymobile.RequestHeadersBuilder;
import io.envoyproxy.envoymobile.RequestMethod;
import io.envoyproxy.envoymobile.ResponseHeaders;
import io.envoyproxy.envoymobile.ResponseTrailers;
import io.envoyproxy.envoymobile.Stream;
import io.envoyproxy.envoymobile.StreamIntel;
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary;
import io.envoyproxy.envoymobile.engine.testing.RequestScenario;
import io.envoyproxy.envoymobile.engine.testing.Response;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.AbstractMap.SimpleImmutableEntry;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import okhttp3.mockwebserver.Dispatcher;
import okhttp3.mockwebserver.MockResponse;
import okhttp3.mockwebserver.MockWebServer;
import okhttp3.mockwebserver.RecordedRequest;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

@RunWith(RobolectricTestRunner.class)
public class AndroidEnvoyExplicitFlowTest {

  private final MockWebServer mockWebServer = new MockWebServer();
  private Engine engine;

  @BeforeClass
  public static void loadJniLibrary() {
    AndroidJniLibrary.loadTestLibrary();
  }

  @Before
  public void setUpEngine() throws Exception {
    CountDownLatch latch = new CountDownLatch(1);
    Context appContext = ApplicationProvider.getApplicationContext();
    engine = new AndroidEngineBuilder(appContext)
                 .addLogLevel(LogLevel.OFF)
                 .setOnEngineRunning(() -> {
                   latch.countDown();
                   return null;
                 })
                 .build();
    latch.await(); // Don't launch a request before initialization has completed.
  }

  @After
  public void shutdownEngine() throws Exception {
    engine.terminate();
    mockWebServer.shutdown();
  }

  @Test
  public void get_simple() throws Exception {
    mockWebServer.enqueue(new MockResponse().setBody("hello, world"));
    mockWebServer.start();
    RequestScenario requestScenario =
        new RequestScenario()
            .setHttpMethod(RequestMethod.GET)
            .setUrl(mockWebServer.url("get/flowers").toString())
            .setResponseBufferSize(20); // Larger than the response body size

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("hello, world");
    assertThat(response.getEnvoyError()).isNull();
    assertThat(response.getNbResponseChunks()).isEqualTo(1);
    assertThat(response.getStreamIntels().size()).isEqualTo(3);
    assertThat(response.getStreamIntels().get(2).getAttemptCount()).isEqualTo(1);
    assertThat(response.getFinalStreamIntel().getSentByteCount()).isEqualTo(75);
  }

  @Test
  public void get_waitOnReadData() throws Exception {
    mockWebServer.enqueue(new MockResponse().setBody("hello, world"));
    mockWebServer.start();
    RequestScenario requestScenario =
        new RequestScenario()
            .setHttpMethod(RequestMethod.GET)
            .setUrl(mockWebServer.url("get/flowers").toString())
            .waitOnReadData()
            .setResponseBufferSize(20); // Larger than the response body size

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("hello, world");
    assertThat(response.getEnvoyError()).isNull();
    assertThat(response.getNbResponseChunks()).isEqualTo(1);
    assertThat(response.getStreamIntels().size()).isEqualTo(3);
    assertThat(response.getStreamIntels().get(2).getAttemptCount()).isEqualTo(1);
    assertThat(response.getFinalStreamIntel().getSentByteCount()).isEqualTo(75);
  }

  @Test
  public void get_multipleRequests_randomBehavior() throws Exception {
    ExecutorService executorService = Executors.newFixedThreadPool(3);
    List<Throwable> errors = new ArrayList<>();
    mockWebServer.start();
    for (int i = 0; i < 100; i++) {
      executorService.submit(() -> {
        try {
          mockWebServer.enqueue(new MockResponse().setBody("hello, world"));
          RequestScenario requestScenario =
              new RequestScenario()
                  .setHttpMethod(RequestMethod.GET)
                  .setUrl(mockWebServer.url("get/flowers").toString())
                  .setResponseBufferSize(20); // Larger than the response body size
          if (Math.random() > 0.5d) {
            requestScenario.cancelOnResponseHeaders();
          }
          if (Math.random() > 0.5d) {
            requestScenario.waitOnReadData();
          } else if (Math.random() > 0.5d) {
            requestScenario.useDirectExecutor();
          }
          sendRequest(requestScenario);
        } catch (Throwable t) {
          errors.add(t);
        }
      });
    }
    executorService.shutdown();
    executorService.awaitTermination(20, TimeUnit.SECONDS);
    assertThat(errors).isEmpty();
  }

  @Test
  public void get_bufferSmallerThanResponseBody() throws Exception {
    mockWebServer.enqueue(new MockResponse().setBody("hello, world"));
    mockWebServer.start();
    RequestScenario requestScenario =
        new RequestScenario()
            .setHttpMethod(RequestMethod.GET)
            .setUrl(mockWebServer.url("get/flowers").toString())
            .setResponseBufferSize(4); // Smaller than the response body size

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("hello, world");
    assertThat(response.getEnvoyError()).isNull();
    assertThat(response.getNbResponseChunks()).isEqualTo(3); // response size: 12, buffer size: 4
  }

  @Test
  public void get_withDirectExecutor() throws Exception {
    mockWebServer.start();
    for (int i = 0; i < 100; i++) {
      mockWebServer.enqueue(new MockResponse().setBody("hello, world"));
      RequestScenario requestScenario =
          new RequestScenario()
              .useDirectExecutor()
              .setHttpMethod(RequestMethod.GET)
              .setUrl(mockWebServer.url("get/flowers").toString())
              .setResponseBufferSize(20); // Larger than the response body size

      Response response = sendRequest(requestScenario);

      assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
      assertThat(response.getBodyAsString()).isEqualTo("hello, world");
      assertThat(response.getEnvoyError()).isNull();
    }
  }

  @Test
  public void get_noBody() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(200));
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.GET)
                                          .setUrl(mockWebServer.url("get/flowers").toString());

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEmpty();
    assertThat(response.getEnvoyError()).isNull();
    assertThat(response.getNbResponseChunks()).isZero();
  }

  @Test
  public void get_cancelOnResponseHeaders() throws Exception {
    mockWebServer.enqueue(new MockResponse().setBody("hello, world"));
    mockWebServer.start();
    RequestScenario requestScenario =
        new RequestScenario()
            .setHttpMethod(RequestMethod.GET)
            .setUrl(mockWebServer.url("get/flowers").toString())
            .setResponseBufferSize(20) // Larger than the response body size
            .cancelOnResponseHeaders();

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEmpty();
    assertThat(response.getEnvoyError()).isNull();
    assertThat(response.isCancelled()).isTrue();
  }

  @Test
  public void get_noBody_cancelOnResponseHeaders() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(200));
    mockWebServer.start();
    RequestScenario requestScenario =
        new RequestScenario()
            .setHttpMethod(RequestMethod.GET)
            .setUrl(mockWebServer.url("get/flowers").toString())
            .cancelOnResponseHeaders(); // no body ==> endStream is true for OnResponseHeaders

    Response response = sendRequest(requestScenario);
    Thread.sleep(100); // If the Stream processes a spurious onCancel callback, we will notice.

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEmpty();
    assertThat(response.getEnvoyError()).isNull();
    assertThat(response.isCancelled()).isFalse(); // EndStream was already reached - no callback.
  }

  @Test
  public void get_withThrottledBodyResponse_bufferLargerThanResponseBody() throws Exception {
    // Note: throttle must be long enough to trickle the chunking. Chunk size is 5 bytes.
    mockWebServer.enqueue(
        new MockResponse().throttleBody(5, 1, TimeUnit.SECONDS).setBody("hello, world"));
    mockWebServer.start();
    RequestScenario requestScenario =
        new RequestScenario()
            .setHttpMethod(RequestMethod.GET)
            .setUrl(mockWebServer.url("get/flowers").toString())
            .setResponseBufferSize(6); // Larger than one chunk of the response body size

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("hello, world");
    assertThat(response.getEnvoyError()).isNull();
    // A "terminating" empty buffer is systematically sent through the setOnResponseData callback.
    // See: https://github.com/envoyproxy/envoy-mobile/issues/1393
    assertThat(response.getNbResponseChunks()).isEqualTo(4); // 5 bytes, 5 bytes, 2, and 0 bytes
  }

  @Test
  public void get_withThrottledBodyResponse_bufferSmallerThanResponseBody() throws Exception {
    // Note: throttle must be long enough to trickle the chunking.
    mockWebServer.enqueue(
        new MockResponse().throttleBody(5, 1, TimeUnit.SECONDS).setBody("hello, world"));
    mockWebServer.start();
    RequestScenario requestScenario =
        new RequestScenario()
            .setHttpMethod(RequestMethod.GET)
            .setUrl(mockWebServer.url("get/flowers").toString())
            .setResponseBufferSize(3); // Smaller than some chunk of the response body size

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("hello, world");
    assertThat(response.getEnvoyError()).isNull();
    // A "terminating" empty buffer is systematically sent through the setOnResponseData callback.
    // See: https://github.com/envoyproxy/envoy-mobile/issues/1393
    assertThat(response.getNbResponseChunks()).isEqualTo(6); // 3&2 bytes, 3&2 bytes, 2, and 0 bytes
  }

  @Test
  public void get_veryLargeResponse() throws Exception {
    byte[] responseBytes = new byte[100_000_000];
    Arrays.fill(responseBytes, (byte)'A');
    String responseBody = new String(responseBytes);
    mockWebServer.enqueue(new MockResponse().setBody(responseBody));
    mockWebServer.start();

    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.GET)
                                          .setUrl(mockWebServer.url("get/flowers").toString())
                                          .setResponseBufferSize(1_000_001);

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo(responseBody);
    assertThat(response.getEnvoyError()).isNull();
  }

  // This was supposed to be a simple post, but because the stream is not properly closed, it
  // actually ends up testing sending a post, getting a response, and Envoy resetting the
  // "incomplete" request stream.
  @Test
  public void post_simple() throws Exception {
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        assertThat(recordedRequest.getMethod()).isEqualTo(RequestMethod.POST.name());
        assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("This is my request body");
        return new MockResponse().setBody("This is my response Body");
      }
    });
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.POST)
                                          .setUrl(mockWebServer.url("post/flowers").toString())
                                          .addHeader("content-length", "23")
                                          .addBody("This is my request body");

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("This is my response Body");
    assertThat(response.getEnvoyError()).isNull();
  }

  @Test
  public void post_chunkedBody() throws Exception {
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        assertThat(recordedRequest.getMethod()).isEqualTo(RequestMethod.POST.name());
        assertThat(recordedRequest.getBody().readUtf8())
            .isEqualTo("This is the first part of by body. This is the second part of by body.");
        return new MockResponse().setBody("This is my response Body");
      }
    });
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .closeBodyStream()
                                          .setHttpMethod(RequestMethod.POST)
                                          .setUrl(mockWebServer.url("post/flowers").toString())
                                          .addBody("This is the first part of by body. ")
                                          .addBody("This is the second part of by body.");

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("This is my response Body");
    assertThat(response.getEnvoyError()).isNull();
  }

  @Test
  public void put_bigBody() throws Exception {
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        assertThat(recordedRequest.getMethod()).isEqualTo(RequestMethod.PUT.name());
        assertThat(recordedRequest.getBody().size()).isEqualTo(100_000_000);
        return new MockResponse().setBody("This is my response Body");
      }
    });
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .closeBodyStream()
                                          .setHttpMethod(RequestMethod.PUT)
                                          .setUrl(mockWebServer.url("put/flowers").toString());
    byte[] buf = new byte[10_000];
    for (int chunckNo = 0; chunckNo < 10000; chunckNo++) { // total = 100MB
      requestScenario.addBody(buf);
    }

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("This is my response Body");
    assertThat(response.getEnvoyError()).isNull();
  }

  @Test
  public void post_cancelUploadOnChunkZero() throws Exception {
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.POST)
                                          .setUrl(mockWebServer.url("post/flowers").toString())
                                          .addBody("Chunk0")
                                          .cancelUploadOnChunk(0);

    Response response = sendRequest(requestScenario);

    assertThat(response.isCancelled()).isTrue();
    assertThat(response.getRequestChunkSent()).isZero();
    assertThat(response.getEnvoyError()).isNull();
  }

  @Test
  public void post_cancelUploadOnChunkOne() throws Exception {
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.POST)
                                          .setUrl(mockWebServer.url("post/flowers").toString())
                                          .addBody("Chunk0")
                                          .addBody("Chunk1")
                                          .cancelUploadOnChunk(1);

    Response response = sendRequest(requestScenario);

    assertThat(response.isCancelled()).isTrue();
    assertThat(response.getRequestChunkSent()).isOne();
    assertThat(response.getEnvoyError()).isNull();
  }

  @Test
  public void post_multipleRequests_randomBehavior() throws Exception {
    ExecutorService executorService = Executors.newFixedThreadPool(3);
    List<Throwable> errors = new ArrayList<>();
    mockWebServer.start();
    for (int i = 0; i < 100; i++) {
      executorService.submit(() -> {
        try {
          mockWebServer.enqueue(new MockResponse().setBody("hello, world"));
          RequestScenario requestScenario =
              new RequestScenario()
                  .setHttpMethod(RequestMethod.GET)
                  .setUrl(mockWebServer.url("get/flowers").toString())
                  .addBody("This is my body part 1")
                  .addBody("This is my body part 2")
                  .setResponseBufferSize(20); // Larger than the response body size
          if (Math.random() > 0.5d) {
            requestScenario.cancelUploadOnChunk(1);
          }
          if (Math.random() > 0.5d) {
            requestScenario.waitOnReadData();
          } else if (Math.random() > 0.5d) {
            requestScenario.useDirectExecutor();
          }
          sendRequest(requestScenario);
        } catch (Throwable t) {
          errors.add(t);
        }
      });
    }
    executorService.shutdown();
    executorService.awaitTermination(20, TimeUnit.SECONDS);
    assertThat(errors).isEmpty();
  }

  private Response sendRequest(RequestScenario requestScenario) throws Exception {
    final CountDownLatch latch = new CountDownLatch(1);
    final AtomicReference<Response> response = new AtomicReference<>(new Response());
    final AtomicReference<Stream> streamRef = new AtomicReference<>();
    final Iterator<ByteBuffer> chunkIterator = requestScenario.getBodyChunks().iterator();

    Stream stream =
        engine.streamClient()
            .newStreamPrototype()
            .setOnSendWindowAvailable(ignored -> {
              onSendWindowAvailable(requestScenario, streamRef.get(), chunkIterator,
                                    response.get());
              return null;
            })
            .setOnResponseHeaders((responseHeaders, endStream, streamIntel) -> {
              response.get().setHeaders(responseHeaders);
              response.get().addStreamIntel(streamIntel);
              if (requestScenario.cancelOnResponseHeaders) {
                streamRef.get().cancel(); // Should be a noop when endStream == true
              } else {
                if (requestScenario.waitOnReadData) {
                  try {
                    Thread.sleep(100 + (int)(Math.random() * 50));
                  } catch (InterruptedException e) {
                    // Don't care
                  }
                }
                streamRef.get().readData(requestScenario.responseBufferSize);
              }
              return null;
            })
            .setOnResponseData((data, endStream, streamIntel) -> {
              response.get().addBody(data);
              response.get().addStreamIntel(streamIntel);
              if (!endStream) {
                if (requestScenario.waitOnReadData) {
                  try {
                    Thread.sleep(100 + (int)(Math.random() * 50));
                  } catch (InterruptedException e) {
                    // Don't care
                  }
                }
                streamRef.get().readData(requestScenario.responseBufferSize);
              }
              return null;
            })
            .setOnResponseTrailers((trailers, streamIntel) -> {
              response.get().setTrailers(trailers);
              response.get().addStreamIntel(streamIntel);
              return null;
            })
            .setOnError((error, finalStreamIntel) -> {
              response.get().setEnvoyError(error);
              response.get().addStreamIntel(finalStreamIntel);
              response.get().setFinalStreamIntel(finalStreamIntel);
              latch.countDown();
              return null;
            })
            .setOnCancel((finalStreamIntel) -> {
              response.get().setCancelled();
              response.get().addStreamIntel(finalStreamIntel);
              response.get().setFinalStreamIntel(finalStreamIntel);
              latch.countDown();
              return null;
            })
            .setOnComplete((finalStreamIntel) -> {
              response.get().addStreamIntel(finalStreamIntel);
              response.get().setFinalStreamIntel(finalStreamIntel);
              latch.countDown();
              return null;
            })
            .setExplicitFlowControl(true)
            .start(requestScenario.useDirectExecutor ? Runnable::run
                                                     : Executors.newSingleThreadExecutor());
    streamRef.set(stream); // Set before sending headers to avoid race conditions.
    stream.sendHeaders(requestScenario.getHeaders(), !requestScenario.hasBody());
    if (requestScenario.hasBody()) {
      // The first "send" is assumes that the window is available - API contract.
      onSendWindowAvailable(requestScenario, streamRef.get(), chunkIterator, response.get());
    }
    latch.await();
    response.get().throwAssertionErrorIfAny();
    return response.get();
  }

  private static void onSendWindowAvailable(RequestScenario requestScenario, Stream stream,
                                            Iterator<ByteBuffer> chunkIterator, Response response) {
    if (requestScenario.cancelUploadOnChunk == response.requestChunkSent) {
      stream.cancel();
      return;
    }
    response.requestChunkSent++;
    if (chunkIterator.hasNext()) {
      stream.sendData(chunkIterator.next());
    } else {
      requestScenario.getClosingBodyChunk().ifPresent(stream::close);
    }
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:kotlin_test.bzl", "envoy_mobile_android_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_android_test(
    name = "android_engine_start_test",
    srcs = [
        "AndroidEnvoyEngineStartUpTest.java",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
    ],
)

envoy_mobile_android_test(
    name = "android_engine_flow_test",
    srcs = [
        "AndroidEnvoyFlowTest.java",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/io/envoyproxy/envoymobile/engine/testing",
    ],
)

envoy_mobile_android_test(
    name = "android_engine_explicit_flow_test",
    srcs = [
        "AndroidEnvoyExplicitFlowTest.java",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/io/envoyproxy/envoymobile/engine/testing",
    ],
)

envoy_mobile_android_test(
    name = "android_engine_socket_tag_test",
    srcs = [
        "AndroidEngineSocketTagTest.java",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/io/envoyproxy/envoymobile/engine/testing",
    ],
)
package test.kotlin.integration;

import static org.assertj.core.api.Assertions.assertThat;

import android.content.Context;
import androidx.test.core.app.ApplicationProvider;
import io.envoyproxy.envoymobile.AndroidEngineBuilder;
import io.envoyproxy.envoymobile.Engine;
import io.envoyproxy.envoymobile.EnvoyError;
import io.envoyproxy.envoymobile.RequestHeaders;
import io.envoyproxy.envoymobile.RequestHeadersBuilder;
import io.envoyproxy.envoymobile.RequestMethod;
import io.envoyproxy.envoymobile.ResponseHeaders;
import io.envoyproxy.envoymobile.ResponseTrailers;
import io.envoyproxy.envoymobile.Stream;
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary;
import io.envoyproxy.envoymobile.engine.testing.RequestScenario;
import io.envoyproxy.envoymobile.engine.testing.Response;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.AbstractMap.SimpleImmutableEntry;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import okhttp3.mockwebserver.Dispatcher;
import okhttp3.mockwebserver.MockResponse;
import okhttp3.mockwebserver.MockWebServer;
import okhttp3.mockwebserver.RecordedRequest;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

@RunWith(RobolectricTestRunner.class)
public class AndroidEnvoyFlowTest {

  private final MockWebServer mockWebServer = new MockWebServer();
  private Engine engine;

  @BeforeClass
  public static void loadJniLibrary() {
    AndroidJniLibrary.loadTestLibrary();
  }

  @Before
  public void setUpEngine() throws Exception {
    CountDownLatch latch = new CountDownLatch(1);
    Context appContext = ApplicationProvider.getApplicationContext();
    engine = new AndroidEngineBuilder(appContext)
                 .setOnEngineRunning(() -> {
                   latch.countDown();
                   return null;
                 })
                 .build();
    latch.await(); // Don't launch a request before initialization has completed.
  }

  @After
  public void shutdown() throws IOException {
    engine.terminate();
    mockWebServer.shutdown();
  }

  @Test
  public void get_simple() throws Exception {
    mockWebServer.enqueue(new MockResponse().setBody("hello, world"));
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.GET)
                                          .setUrl(mockWebServer.url("get/flowers").toString());

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("hello, world");
    assertThat(response.getEnvoyError()).isNull();
  }

  @Test
  public void get_noBody() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(200));
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.GET)
                                          .setUrl(mockWebServer.url("get/flowers").toString());

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEmpty();
    assertThat(response.getEnvoyError()).isNull();
    assertThat(response.getNbResponseChunks()).isZero();
  }

  @Test
  public void get_withThrottledBodyResponse() throws Exception {
    // Note: throttle must be long enough to trickle the chunking.
    mockWebServer.enqueue(
        new MockResponse().throttleBody(5, 1, TimeUnit.SECONDS).setBody("hello, world"));
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.GET)
                                          .setUrl(mockWebServer.url("get/flowers").toString());

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("hello, world");
    assertThat(response.getEnvoyError()).isNull();
    // A "terminating" empty buffer is systematically sent through the setOnResponseData callback.
    // See: https://github.com/envoyproxy/envoy-mobile/issues/1393
    assertThat(response.getNbResponseChunks()).isEqualTo(4); // 5 bytes, 5 bytes, 2, and 0 bytes
  }

  @Test
  public void post_simple() throws Exception {
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        assertThat(recordedRequest.getMethod()).isEqualTo(RequestMethod.POST.name());
        assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("This is my request body");
        return new MockResponse().setBody("This is my response Body");
      }
    });
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.POST)
                                          .setUrl(mockWebServer.url("get/flowers").toString())
                                          .addHeader("content-length", "23")
                                          .addBody("This is my request body");

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("This is my response Body");
    assertThat(response.getEnvoyError()).isNull();
  }

  @Test
  public void post_simple_withoutByteBufferPosition() throws Exception {
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        assertThat(recordedRequest.getMethod()).isEqualTo(RequestMethod.POST.name());
        assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("55555");
        return new MockResponse().setBody("This is my response Body");
      }
    });
    ByteBuffer requestBody = ByteBuffer.allocateDirect(5);
    requestBody.put("55555".getBytes());
    requestBody.position(3); // The position should be ignored - only capacity matters.
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.POST)
                                          .setUrl(mockWebServer.url("get/flowers").toString())
                                          .addBody(requestBody)
                                          .closeBodyStream();

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("This is my response Body");
    assertThat(response.getEnvoyError()).isNull();
  }

  @Test
  public void post_simple_withByteBufferPosition() throws Exception {
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        assertThat(recordedRequest.getMethod()).isEqualTo(RequestMethod.POST.name());
        assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("This is my request body");
        return new MockResponse().setBody("This is my response Body");
      }
    });
    ByteBuffer requestBody = ByteBuffer.allocateDirect(100);
    requestBody.put("This is my request body with spurious data".getBytes());
    requestBody.position(23); // Only the first 23 bytes should be sent - the String size is 42.
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .useByteBufferPosition()
                                          .setHttpMethod(RequestMethod.POST)
                                          .setUrl(mockWebServer.url("get/flowers").toString())
                                          .addBody(requestBody)
                                          .closeBodyStream();

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("This is my response Body");
    assertThat(response.getEnvoyError()).isNull();
  }

  @Test
  public void post_chunkedBody() throws Exception {
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        assertThat(recordedRequest.getMethod()).isEqualTo(RequestMethod.POST.name());
        assertThat(recordedRequest.getBody().readUtf8())
            .isEqualTo("This is the first part of my body. This is the second part of my body.");
        return new MockResponse().setBody("This is my response Body");
      }
    });
    mockWebServer.start();
    RequestScenario requestScenario =
        new RequestScenario()
            .setHttpMethod(RequestMethod.POST)
            .setUrl(mockWebServer.url("get/flowers").toString())
            .addBody("This is the first part of my body. ")
            .addBody("This is the second part of my body.")
            .closeBodyStream(); // Content-Length is not provided; must be closed explicitly.

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("This is my response Body");
    assertThat(response.getEnvoyError()).isNull();
  }

  @Test
  public void post_chunkedBody_withBufferPosition() throws Exception {
    String firstChunk = "This is the first chunk of my request body. ";
    String secondChunk = "This is the second chunk.";
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        assertThat(recordedRequest.getBody().readUtf8()).isEqualTo(firstChunk + secondChunk);
        return new MockResponse().setBody("This is my response Body");
      }
    });
    mockWebServer.start();
    ByteBuffer requestBodyFirstChunk = ByteBuffer.allocateDirect(1024);
    requestBodyFirstChunk.put((firstChunk + "spurious data that should be ignored").getBytes());
    requestBodyFirstChunk.position(firstChunk.length());
    ByteBuffer requestBodySecondChunk = ByteBuffer.allocateDirect(100);
    requestBodySecondChunk.put((secondChunk + "data beyond ByteBuffer.position()").getBytes());
    requestBodySecondChunk.position(secondChunk.length());
    RequestScenario requestScenario =
        new RequestScenario()
            .useByteBufferPosition()
            .setHttpMethod(RequestMethod.POST)
            .setUrl(mockWebServer.url("get/flowers").toString())
            .addBody(requestBodyFirstChunk)
            .addBody(requestBodySecondChunk)
            .closeBodyStream(); // Content-Length is not provided; must be closed explicitly.

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).isEqualTo("This is my response Body");
    assertThat(response.getEnvoyError()).isNull();
  }

  @Test
  public void post_cancelBeforeSendingRequestBody() throws Exception {
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.POST)
                                          .setUrl(mockWebServer.url("get/flowers").toString())
                                          .addBody("Request body")
                                          .cancelBeforeSendingRequestBody();

    Response response = sendRequest(requestScenario);

    assertThat(response.isCancelled()).isTrue();
  }

  private Response sendRequest(RequestScenario requestScenario) throws Exception {
    final CountDownLatch latch = new CountDownLatch(1);
    final AtomicReference<Response> response = new AtomicReference<>(new Response());

    Stream stream = engine.streamClient()
                        .newStreamPrototype()
                        .setUseByteBufferPosition(requestScenario.useByteBufferPosition)
                        .setOnResponseHeaders((responseHeaders, endStream, ignored) -> {
                          response.get().setHeaders(responseHeaders);
                          if (endStream) {
                            latch.countDown();
                          }
                          return null;
                        })
                        .setOnResponseData((data, endStream, ignored) -> {
                          response.get().addBody(data);
                          if (endStream) {
                            latch.countDown();
                          }
                          return null;
                        })
                        .setOnResponseTrailers((trailers, ignored) -> {
                          response.get().setTrailers(trailers);
                          latch.countDown();
                          return null;
                        })
                        .setOnError((error, ignored) -> {
                          response.get().setEnvoyError(error);
                          latch.countDown();
                          return null;
                        })
                        .setOnCancel((ignored) -> {
                          response.get().setCancelled();
                          latch.countDown();
                          return null;
                        })
                        .start(Executors.newSingleThreadExecutor())
                        .sendHeaders(requestScenario.getHeaders(), !requestScenario.hasBody());
    if (requestScenario.cancelBeforeSendingRequestBody) {
      stream.cancel();
    } else {
      requestScenario.getBodyChunks().forEach(stream::sendData);
      requestScenario.getClosingBodyChunk().ifPresent(stream::close);
    }

    latch.await();
    response.get().throwAssertionErrorIfAny();
    return response.get();
  }
}
package io.envoyproxy.envoymobile.utilities;

import static org.junit.Assert.assertEquals;

import android.content.Context;
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary;
import io.envoyproxy.envoymobile.engine.JniLibrary;
import io.envoyproxy.envoymobile.utilities.ContextUtils;
import androidx.test.platform.app.InstrumentationRegistry;
import java.nio.charset.StandardCharsets;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

/**
 * Simple test for Certificate verification JNI layer.
 * The objective is not to test the certificate verification logic (which is faked) but instead to
 * confirm that all JNI calls go through (confirmed by checking for the fake implementation side
 * effects).
 */
@RunWith(RobolectricTestRunner.class)
public final class CertificateVerificationTest {
  static {
    AndroidJniLibrary.loadTestLibrary();
    Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
    if (ContextUtils.getApplicationContext() == null) {
      ContextUtils.initApplicationContext(context.getApplicationContext());
    }
    AndroidJniLibrary.load(context.getApplicationContext());
  }

  private static final byte[] host =
      FakeX509Util.getExpectedHost().getBytes(StandardCharsets.UTF_8);
  private static final byte[] authType =
      FakeX509Util.expectedAuthType.getBytes(StandardCharsets.UTF_8);

  @Before
  public void setUp() throws Exception {
    AndroidNetworkLibrary.setFakeCertificateVerificationForTesting(true);
  }

  @After
  public void tearDown() throws Exception {
    JniLibrary.callClearTestRootCertificateFromNative();
    AndroidNetworkLibrary.setFakeCertificateVerificationForTesting(true);
  }

  @Test
  public void testChainWithNonRootCertificate() throws Exception {
    final String[] fakeCertChain = new String[] {"fake cert"};
    final byte[][] certChain = new byte[][] {fakeCertChain[0].getBytes()};

    AndroidCertVerifyResult result =
        (AndroidCertVerifyResult)JniLibrary.callCertificateVerificationFromNative(certChain, host,
                                                                                  authType);
    assertEquals(result.getStatus(), CertVerifyStatusAndroid.NO_TRUSTED_ROOT);
  }

  @Test
  public void testChainWithRootCertificate() throws Exception {
    final String[] fakeCertChain = new String[] {"fake cert"};
    final byte[][] certChain = new byte[][] {fakeCertChain[0].getBytes()};

    JniLibrary.callAddTestRootCertificateFromNative(certChain[0]);
    AndroidCertVerifyResult result =
        (AndroidCertVerifyResult)JniLibrary.callCertificateVerificationFromNative(certChain,
                                                                                  authType, host);
    assertEquals(result.getStatus(), CertVerifyStatusAndroid.OK);
  }

  @Test
  public void testChainWithRootCertificateWrongHostname() throws Exception {
    final String[] fakeCertChain = new String[] {"fake cert"};
    final byte[][] certChain = new byte[][] {fakeCertChain[0].getBytes()};
    final String host = "wrong host";
    final byte[] hostBytes = host.getBytes(StandardCharsets.UTF_8);

    JniLibrary.callAddTestRootCertificateFromNative(certChain[0]);
    AndroidCertVerifyResult result =
        (AndroidCertVerifyResult)JniLibrary.callCertificateVerificationFromNative(
            certChain, authType, hostBytes);
    assertEquals(result.getStatus(), CertVerifyStatusAndroid.FAILED);
  }

  @Test
  public void testChainWithRootCertificateWrongAuthType() throws Exception {
    final String[] fakeCertChain = new String[] {"fake cert"};
    final byte[][] certChain = new byte[][] {fakeCertChain[0].getBytes()};
    final String authType = "wrong auth type";
    final byte[] authTypeBytes = authType.getBytes(StandardCharsets.UTF_8);

    JniLibrary.callAddTestRootCertificateFromNative(certChain[0]);
    AndroidCertVerifyResult result =
        (AndroidCertVerifyResult)JniLibrary.callCertificateVerificationFromNative(
            certChain, authTypeBytes, host);
    assertEquals(result.getStatus(), CertVerifyStatusAndroid.FAILED);
  }

  @Test
  public void testClearTestRootCertificate() throws Exception {
    final String[] fakeCertChain = new String[] {"fake cert"};
    final byte[][] certChain = new byte[][] {fakeCertChain[0].getBytes()};

    JniLibrary.callAddTestRootCertificateFromNative(certChain[0]);
    JniLibrary.callClearTestRootCertificateFromNative();
    AndroidCertVerifyResult result =
        (AndroidCertVerifyResult)JniLibrary.callCertificateVerificationFromNative(certChain,
                                                                                  authType, host);
    assertEquals(result.getStatus(), CertVerifyStatusAndroid.NO_TRUSTED_ROOT);
  }

  @Test
  public void testChainWithMultipleNonRootCertificates() throws Exception {
    final String[] fakeCertChain = new String[] {"fake cert", "another fake cert"};
    final byte[][] certChain =
        new byte[][] {fakeCertChain[0].getBytes(), fakeCertChain[1].getBytes()};

    AndroidCertVerifyResult result =
        (AndroidCertVerifyResult)JniLibrary.callCertificateVerificationFromNative(certChain,
                                                                                  authType, host);
    assertEquals(result.getStatus(), CertVerifyStatusAndroid.NO_TRUSTED_ROOT);
  }

  @Test
  public void testChainWithMixedCertificates() throws Exception {
    final String[] fakeCertChain = new String[] {"fake cert", "another fake cert"};
    final byte[][] certChain =
        new byte[][] {fakeCertChain[0].getBytes(), fakeCertChain[1].getBytes()};

    JniLibrary.callAddTestRootCertificateFromNative(certChain[0]);
    AndroidCertVerifyResult result =
        (AndroidCertVerifyResult)JniLibrary.callCertificateVerificationFromNative(certChain,
                                                                                  authType, host);
    assertEquals(result.getStatus(), CertVerifyStatusAndroid.NO_TRUSTED_ROOT);
  }

  @Test
  public void testChainWithMultipleRootCertificates() throws Exception {
    final String[] fakeCertChain = new String[] {"fake cert", "another fake cert"};
    final byte[][] certChain =
        new byte[][] {fakeCertChain[0].getBytes(), fakeCertChain[1].getBytes()};

    JniLibrary.callAddTestRootCertificateFromNative(certChain[0]);
    JniLibrary.callAddTestRootCertificateFromNative(certChain[1]);
    AndroidCertVerifyResult result =
        (AndroidCertVerifyResult)JniLibrary.callCertificateVerificationFromNative(certChain,
                                                                                  authType, host);
    assertEquals(result.getStatus(), CertVerifyStatusAndroid.OK);
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:kotlin_test.bzl", "envoy_mobile_android_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_android_test(
    name = "certificate_verification_tests",
    srcs = [
        "CertificateVerificationTest.java",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/utilities",
        "//library/java/org/chromium/net",
    ],
)
package io.envoyproxy.envoymobile.jni;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

@RunWith(RobolectricTestRunner.class)
public class JniHelperTest {
  public JniHelperTest() { System.loadLibrary("envoy_jni_helper_test"); }

  //================================================================================
  // Native methods for testing.
  //================================================================================
  public static native void getMethodId(Class<?> clazz, String name, String signature);
  public static native void getStaticMethodId(Class<?> clazz, String name, String signature);
  public static native Class<?> findClass(String className);
  public static native Class<?> getObjectClass(Object object);
  public static native Object newObject(Class<?> clazz, String name, String signature);
  public static native void throwNew(String className, String message);
  public static native int getArrayLength(int[] array);
  public static native byte[] newByteArray(int length);
  public static native char[] newCharArray(int length);
  public static native short[] newShortArray(int length);
  public static native int[] newIntArray(int length);
  public static native long[] newLongArray(int length);
  public static native float[] newFloatArray(int length);
  public static native double[] newDoubleArray(int length);
  public static native boolean[] newBooleanArray(int length);
  public static native Object[] newObjectArray(int length, Class<?> elementClass,
                                               Object initialElement);
  public static native byte[] getByteArrayElements(byte[] array);
  public static native char[] getCharArrayElements(char[] array);
  public static native short[] getShortArrayElements(short[] array);
  public static native int[] getIntArrayElements(int[] array);
  public static native long[] getLongArrayElements(long[] array);
  public static native float[] getFloatArrayElements(float[] array);
  public static native double[] getDoubleArrayElements(double[] array);
  public static native boolean[] getBooleanArrayElements(boolean[] array);
  public static native Object getObjectArrayElement(Object[] array, int index);
  public static native void setObjectArrayElement(Object[] array, int index, Object value);
  public static native void setByteArrayRegion(byte[] array, int start, int index, byte[] buffer);
  public static native void setCharArrayRegion(char[] array, int start, int index, char[] buffer);
  public static native void setShortArrayRegion(short[] array, int start, int index,
                                                short[] buffer);
  public static native void setIntArrayRegion(int[] array, int start, int index, int[] buffer);
  public static native void setLongArrayRegion(long[] array, int start, int index, long[] buffer);
  public static native void setFloatArrayRegion(float[] array, int start, int index,
                                                float[] buffer);
  public static native void setDoubleArrayRegion(double[] array, int start, int index,
                                                 double[] buffer);
  public static native void setBooleanArrayRegion(boolean[] array, int start, int index,
                                                  boolean[] buffer);
  public static native byte callByteMethod(Class<?> clazz, Object instance, String name,
                                           String signature);
  public static native char callCharMethod(Class<?> clazz, Object instance, String name,
                                           String signature);
  public static native short callShortMethod(Class<?> clazz, Object instance, String name,
                                             String signature);
  public static native int callIntMethod(Class<?> clazz, Object instance, String name,
                                         String signature);
  public static native long callLongMethod(Class<?> clazz, Object instance, String name,
                                           String signature);
  public static native float callFloatMethod(Class<?> clazz, Object instance, String name,
                                             String signature);
  public static native double callDoubleMethod(Class<?> clazz, Object instance, String name,
                                               String signature);
  public static native boolean callBooleanMethod(Class<?> clazz, Object instance, String name,
                                                 String signature);
  public static native void callVoidMethod(Class<?> clazz, Object instance, String name,
                                           String signature);
  public static native Object callObjectMethod(Class<?> clazz, Object instance, String name,
                                               String signature);
  public static native byte callStaticByteMethod(Class<?> clazz, String name, String signature);
  public static native char callStaticCharMethod(Class<?> clazz, String name, String signature);
  public static native short callStaticShortMethod(Class<?> clazz, String name, String signature);
  public static native int callStaticIntMethod(Class<?> clazz, String name, String signature);
  public static native long callStaticLongMethod(Class<?> clazz, String name, String signature);
  public static native float callStaticFloatMethod(Class<?> clazz, String name, String signature);
  public static native double callStaticDoubleMethod(Class<?> clazz, String name, String signature);
  public static native boolean callStaticBooleanMethod(Class<?> clazz, String name,
                                                       String signature);
  public static native void callStaticVoidMethod(Class<?> clazz, String name, String signature);
  public static native Object callStaticObjectMethod(Class<?> clazz, String name, String signature);

  //================================================================================
  // Object methods used for Call<Type>Method tests.
  //================================================================================
  public byte byteMethod() { return 1; }
  public char charMethod() { return 'a'; }
  public short shortMethod() { return 1; }
  public int intMethod() { return 1; }
  public long longMethod() { return 1; }
  public float floatMethod() { return 3.14f; }
  public double doubleMethod() { return 3.14; }
  public boolean booleanMethod() { return true; }
  public void voidMethod() {}
  public String objectMethod() { return "Hello"; }

  //================================================================================
  // Static methods used for CallStatic<Type>Method tests.
  //================================================================================
  public static byte staticByteMethod() { return 1; }
  public static char staticCharMethod() { return 'a'; }
  public static short staticShortMethod() { return 1; }
  public static int staticIntMethod() { return 1; }
  public static long staticLongMethod() { return 1; }
  public static float staticFloatMethod() { return 3.14f; }
  public static double staticDoubleMethod() { return 3.14; }
  public static boolean staticBooleanMethod() { return true; }
  public static void staticVoidMethod() {}
  public static String staticObjectMethod() { return "Hello"; }

  static class Foo {}

  @Test
  public void testMethodId() {
    getMethodId(Foo.class, "<init>", "()V");
  }

  @Test
  public void testStaticMethodId() {
    getStaticMethodId(JniHelperTest.class, "staticVoidMethod", "()V");
  }

  @Test
  public void testFindClass() {
    assertThat(findClass("java/lang/Exception")).isEqualTo(Exception.class);
  }

  @Test
  public void testGetObjectClass() {
    String s = "Hello";
    assertThat(getObjectClass(s)).isEqualTo(String.class);
  }

  @Test
  public void testNewObject() {
    assertThat(newObject(Foo.class, "<init>", "()V")).isInstanceOf(Foo.class);
  }

  @Test
  public void testThrowNew() {
    assertThatThrownBy(() -> throwNew("java/lang/RuntimeException", "Test"))
        .isInstanceOf(RuntimeException.class)
        .hasMessageContaining("Test");
  }

  @Test
  public void testGetArrayLength() {
    assertThat(getArrayLength(new int[] {1, 2, 3})).isEqualTo(3);
  }

  @Test
  public void testNewCharArray() {
    assertThat(newCharArray(3)).isEqualTo(new char[] {0, 0, 0});
  }

  @Test
  public void testNewShortArray() {
    assertThat(newShortArray(3)).isEqualTo(new short[] {0, 0, 0});
  }

  @Test
  public void testNewIntArray() {
    assertThat(newIntArray(3)).isEqualTo(new int[] {0, 0, 0});
  }

  @Test
  public void testNewLongArray() {
    assertThat(newLongArray(3)).isEqualTo(new long[] {0, 0, 0});
  }

  @Test
  public void testNewFloatArray() {
    assertThat(newFloatArray(3)).isEqualTo(new float[] {0, 0, 0});
  }

  @Test
  public void testNewDoubleArray() {
    assertThat(newDoubleArray(3)).isEqualTo(new double[] {0, 0, 0});
  }

  @Test
  public void testNewBooleanArray() {
    assertThat(newBooleanArray(3)).isEqualTo(new boolean[] {false, false, false});
  }

  @Test
  public void testNewObjectArray() {
    assertThat(newObjectArray(3, String.class, "foo"))
        .isEqualTo(new String[] {"foo", "foo", "foo"});
  }

  @Test
  public void testGetByteArrayElements() {
    assertThat(getByteArrayElements(new byte[] {0, 0, 0})).isEqualTo(new byte[] {123, 123, 123});
  }

  @Test
  public void testGetCharArrayElements() {
    assertThat(getCharArrayElements(new char[] {' ', ' ', ' '}))
        .isEqualTo(new char[] {'a', 'a', 'a'});
  }

  @Test
  public void testGetShortArrayElements() {
    assertThat(getShortArrayElements(new short[] {0, 0, 0})).isEqualTo(new short[] {123, 123, 123});
  }

  @Test
  public void testGetIntArrayElements() {
    assertThat(getIntArrayElements(new int[] {0, 0, 0})).isEqualTo(new int[] {123, 123, 123});
  }

  @Test
  public void testGetLongArrayElements() {
    assertThat(getLongArrayElements(new long[] {0, 0, 0})).isEqualTo(new long[] {123, 123, 123});
  }

  @Test
  public void testGetFloatArrayElements() {
    assertThat(getFloatArrayElements(new float[] {0, 0, 0}))
        .isEqualTo(new float[] {3.14f, 3.14f, 3.14f});
  }

  @Test
  public void testGetDoubleArrayElements() {
    assertThat(getDoubleArrayElements(new double[] {0, 0, 0}))
        .isEqualTo(new double[] {3.14, 3.14, 3.14});
  }

  @Test
  public void testGetBooleanArrayElements() {
    assertThat(getBooleanArrayElements(new boolean[] {false, false, false}))
        .isEqualTo(new boolean[] {true, true, true});
  }

  @Test
  public void testGetObjectArrayElement() {
    Object[] array = new Object[] {1, 2, 3};
    assertThat(getObjectArrayElement(array, 1)).isEqualTo(2);
  }

  @Test
  public void testSetObjectArrayElement() {
    Object[] array = new Object[] {1, 2, 3};
    setObjectArrayElement(array, 1, 200);
    assertThat(array).isEqualTo(new Object[] {1, 200, 3});
  }

  @Test
  public void testSetByteArrayRegion() {
    byte[] array = new byte[] {1, 0, 0, 0, 5};
    byte[] buffer = new byte[] {2, 3, 4};
    setByteArrayRegion(array, 1, 3, buffer);
    assertThat(array).isEqualTo(new byte[] {1, 2, 3, 4, 5});
  }

  @Test
  public void testSetCharArrayRegion() {
    char[] array = new char[] {'a', ' ', ' ', ' ', 'e'};
    char[] buffer = new char[] {'b', 'c', 'd'};
    setCharArrayRegion(array, 1, 3, buffer);
    assertThat(array).isEqualTo(new char[] {'a', 'b', 'c', 'd', 'e'});
  }

  @Test
  public void testSetShortArrayRegion() {
    short[] array = new short[] {1, 0, 0, 0, 5};
    short[] buffer = new short[] {2, 3, 4};
    setShortArrayRegion(array, 1, 3, buffer);
    assertThat(array).isEqualTo(new short[] {1, 2, 3, 4, 5});
  }

  @Test
  public void testSetIntArrayRegion() {
    int[] array = new int[] {1, 0, 0, 0, 5};
    int[] buffer = new int[] {2, 3, 4};
    setIntArrayRegion(array, 1, 3, buffer);
    assertThat(array).isEqualTo(new int[] {1, 2, 3, 4, 5});
  }

  @Test
  public void testSetLongArrayRegion() {
    long[] array = new long[] {1, 0, 0, 0, 5};
    long[] buffer = new long[] {2, 3, 4};
    setLongArrayRegion(array, 1, 3, buffer);
    assertThat(array).isEqualTo(new long[] {1, 2, 3, 4, 5});
  }

  @Test
  public void testSetFloatArrayRegion() {
    float[] array = new float[] {1, 0, 0, 0, 5};
    float[] buffer = new float[] {2, 3, 4};
    setFloatArrayRegion(array, 1, 3, buffer);
    assertThat(array).isEqualTo(new float[] {1, 2, 3, 4, 5});
  }

  @Test
  public void testSetDoubleArrayRegion() {
    double[] array = new double[] {1, 0, 0, 0, 5};
    double[] buffer = new double[] {2, 3, 4};
    setDoubleArrayRegion(array, 1, 3, buffer);
    assertThat(array).isEqualTo(new double[] {1, 2, 3, 4, 5});
  }

  @Test
  public void testSetBooleanArrayRegion() {
    boolean[] array = new boolean[] {true, false, false, false, true};
    boolean[] buffer = new boolean[] {true, true, true};
    setBooleanArrayRegion(array, 1, 3, buffer);
    assertThat(array).isEqualTo(new boolean[] {true, true, true, true, true});
  }

  @Test
  public void testCallByteMethod() {
    assertThat(callByteMethod(JniHelperTest.class, this, "byteMethod", "()B")).isEqualTo((byte)1);
  }

  @Test
  public void testCallCharMethod() {
    assertThat(callCharMethod(JniHelperTest.class, this, "charMethod", "()C")).isEqualTo('a');
  }

  @Test
  public void testCallShortMethod() {
    assertThat(callShortMethod(JniHelperTest.class, this, "shortMethod", "()S"))
        .isEqualTo((short)1);
  }

  @Test
  public void testCallIntMethod() {
    assertThat(callIntMethod(JniHelperTest.class, this, "intMethod", "()I")).isEqualTo(1);
  }

  @Test
  public void testCallLongMethod() {
    assertThat(callLongMethod(JniHelperTest.class, this, "longMethod", "()J")).isEqualTo(1L);
  }

  @Test
  public void testCallFloatMethod() {
    assertThat(callFloatMethod(JniHelperTest.class, this, "floatMethod", "()F")).isEqualTo(3.14f);
  }

  @Test
  public void testCallDoubleMethod() {
    assertThat(callDoubleMethod(JniHelperTest.class, this, "doubleMethod", "()D")).isEqualTo(3.14);
  }

  @Test
  public void testCallBooleanMethod() {
    assertThat(callBooleanMethod(JniHelperTest.class, this, "booleanMethod", "()Z"))
        .isEqualTo(true);
  }

  @Test
  public void testCallVoidMethod() {
    callVoidMethod(JniHelperTest.class, this, "voidMethod", "()V");
  }

  @Test
  public void testCallObjectMethod() {
    assertThat(callObjectMethod(JniHelperTest.class, this, "objectMethod", "()Ljava/lang/String;"))
        .isEqualTo("Hello");
  }

  @Test
  public void testCallStaticByteMethod() {
    assertThat(callStaticByteMethod(JniHelperTest.class, "staticByteMethod", "()B"))
        .isEqualTo((byte)1);
  }

  @Test
  public void testCallStaticCharMethod() {
    assertThat(callStaticCharMethod(JniHelperTest.class, "staticCharMethod", "()C")).isEqualTo('a');
  }

  @Test
  public void testCallStaticShortMethod() {
    assertThat(callStaticShortMethod(JniHelperTest.class, "staticShortMethod", "()S"))
        .isEqualTo((short)1);
  }

  @Test
  public void testCallStaticIntMethod() {
    assertThat(callStaticIntMethod(JniHelperTest.class, "staticIntMethod", "()I")).isEqualTo(1);
  }

  @Test
  public void testCallStaticLongMethod() {
    assertThat(callStaticLongMethod(JniHelperTest.class, "staticLongMethod", "()J")).isEqualTo(1L);
  }

  @Test
  public void testCallStaticFloatMethod() {
    assertThat(callStaticFloatMethod(JniHelperTest.class, "staticFloatMethod", "()F"))
        .isEqualTo(3.14f);
  }

  @Test
  public void testCallStaticDoubleMethod() {
    assertThat(callStaticDoubleMethod(JniHelperTest.class, "staticDoubleMethod", "()D"))
        .isEqualTo(3.14);
  }

  @Test
  public void testCallStaticBooleanMethod() {
    assertThat(callStaticBooleanMethod(JniHelperTest.class, "staticBooleanMethod", "()Z"))
        .isEqualTo(true);
  }

  @Test
  public void testCallStaticVoidMethod() {
    callStaticVoidMethod(JniHelperTest.class, "staticVoidMethod", "()V");
  }

  @Test
  public void testCallStaticObjectMethod() {
    assertThat(
        callStaticObjectMethod(JniHelperTest.class, "staticObjectMethod", "()Ljava/lang/String;"))
        .isEqualTo("Hello");
  }
}
package io.envoyproxy.envoymobile.jni;

import static org.assertj.core.api.Assertions.assertThat;

import com.google.protobuf.Struct;
import com.google.protobuf.Value;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

@RunWith(RobolectricTestRunner.class)
public class JniUtilityTest {
  public JniUtilityTest() { System.loadLibrary("envoy_jni_utility_test"); }

  //================================================================================
  // Native methods for testing.
  //================================================================================
  public static native byte[] protoJavaByteArrayConversion(byte[] source);

  @Test
  public void testProtoJavaByteArrayConversion() throws Exception {
    Struct source =
        Struct.newBuilder()
            .putFields("string_key", Value.newBuilder().setStringValue("string_value").build())
            .putFields("num_key", Value.newBuilder().setNumberValue(123).build())
            .putFields("bool_key", Value.newBuilder().setBoolValue(true).build())
            .build();
    Struct dest = Struct.parseFrom(protoJavaByteArrayConversion(source.toByteArray()));
    assertThat(source).isEqualTo(dest);
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:kotlin_test.bzl", "envoy_mobile_android_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_android_test(
    name = "jni_helper_test",
    srcs = [
        "JniHelperTest.java",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_helper_test.so",
    ],
    native_lib_name = "envoy_jni_helper_test",
)

envoy_mobile_android_test(
    name = "jni_utility_test",
    srcs = [
        "JniUtilityTest.java",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_utility_test.so",
    ],
    native_lib_name = "envoy_jni_utility_test",
    deps = [
        "@maven//:com_google_protobuf_protobuf_javalite",
    ],
)
package io.envoyproxy.envoymobile.engine

import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class JvmBridgeUtilityTest {

  @Test
  fun `retrieveHeaders produces a Map with all headers provided via passHeaders`() {
    val utility = JvmBridgeUtility()
    utility.passHeader("test-0".toByteArray(), "value-0".toByteArray(), true)
    utility.passHeader("test-1".toByteArray(), "value-1".toByteArray(), false)
    utility.passHeader("test-1".toByteArray(), "value-2".toByteArray(), false)

    val headers = utility.retrieveHeaders()
    val expectedHeaders = mapOf(
      "test-0" to listOf("value-0"),
      "test-1" to listOf("value-1", "value-2")
    )

    assertThat(headers)
      .hasSize(2) // Two keys / header name
      .usingRecursiveComparison().isEqualTo(expectedHeaders)
  }

  @Test
  fun `validateCount checks if the expected number of header values in the map matches the actual`() {
    val utility = JvmBridgeUtility()
    assertThat(utility.validateCount(1)).isFalse()

    utility.passHeader("test-0".toByteArray(), "value-0".toByteArray(), true)
    assertThat(utility.validateCount(1)).isTrue()

    utility.passHeader("test-1".toByteArray(), "value-1".toByteArray(), false)
    assertThat(utility.validateCount(2)).isTrue()

    utility.passHeader("test-1".toByteArray(), "value-2".toByteArray(), false)
    assertThat(utility.validateCount(3)).isTrue()

    assertThat(utility.validateCount(4)).isFalse()
  }

  @Test
  fun `retrieveHeaders resets internal state`() {
    val utility = JvmBridgeUtility()
    utility.passHeader("test-0".toByteArray(), "value-0".toByteArray(), true)
    utility.passHeader("test-1".toByteArray(), "value-1".toByteArray(), false)
    utility.passHeader("test-1".toByteArray(), "value-2".toByteArray(), false)
    assertThat(utility.validateCount(3)).isTrue()

    utility.retrieveHeaders()
    assertThat(utility.validateCount(0)).isTrue()

    utility.passHeader("test-2".toByteArray(), "value-3".toByteArray(), true)

    val nextHeaders = utility.retrieveHeaders()
    val expectedHeaders = mapOf(
      "test-2" to listOf("value-3")
    )

    assertThat(nextHeaders)
      .hasSize(1) // One key / header name
      .usingRecursiveComparison().isEqualTo(expectedHeaders)
  }

  @Test(expected = AssertionError::class)
  fun `starting a new header block before a previous one is finished is an error`() {
    val utility = JvmBridgeUtility()

    utility.passHeader("test-0".toByteArray(), "value-0".toByteArray(), true)
    utility.passHeader("test-1".toByteArray(), "value-1".toByteArray(), true)
  }

  @Test(expected = AssertionError::class)
  fun `not starting a new header block is an error`() {
    val utility = JvmBridgeUtility()

    utility.passHeader("test-0".toByteArray(), "value-0".toByteArray(), false)
  }
}
package io.envoyproxy.envoymobile.engine.testing;

import io.envoyproxy.envoymobile.AndroidEngineBuilder;
import io.envoyproxy.envoymobile.Engine;
import io.envoyproxy.envoymobile.EnvoyError;
import io.envoyproxy.envoymobile.FinalStreamIntel;
import io.envoyproxy.envoymobile.LogLevel;
import io.envoyproxy.envoymobile.RequestHeaders;
import io.envoyproxy.envoymobile.RequestHeadersBuilder;
import io.envoyproxy.envoymobile.RequestMethod;
import io.envoyproxy.envoymobile.ResponseHeaders;
import io.envoyproxy.envoymobile.ResponseTrailers;
import io.envoyproxy.envoymobile.Stream;
import io.envoyproxy.envoymobile.StreamIntel;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

public class Response {

  private final AtomicReference<ResponseHeaders> headers = new AtomicReference<>();
  private final AtomicReference<ResponseTrailers> trailers = new AtomicReference<>();
  private final AtomicReference<EnvoyError> envoyError = new AtomicReference<>();
  private final List<StreamIntel> streamIntels = new ArrayList<>();
  private final AtomicReference<FinalStreamIntel> finalStreamIntel = new AtomicReference<>();
  private final List<ByteBuffer> bodies = new ArrayList<>();
  private final AtomicBoolean cancelled = new AtomicBoolean(false);
  private final AtomicReference<AssertionError> assertionError = new AtomicReference<>();
  public int requestChunkSent = 0;

  public void setHeaders(ResponseHeaders headers) {
    if (!this.headers.compareAndSet(null, headers)) {
      assertionError.compareAndSet(
          null, new AssertionError("setOnResponseHeaders called more than once."));
    }
  }

  public void addBody(ByteBuffer body) { bodies.add(body); }

  public void setTrailers(ResponseTrailers trailers) {
    if (!this.trailers.compareAndSet(null, trailers)) {
      assertionError.compareAndSet(
          null, new AssertionError("setOnResponseTrailers called more than once."));
    }
  }

  public void addStreamIntel(StreamIntel streamIntel) { streamIntels.add(streamIntel); }

  public void setEnvoyError(EnvoyError envoyError) {
    if (!this.envoyError.compareAndSet(null, envoyError)) {
      assertionError.compareAndSet(null, new AssertionError("setOnError called more than once."));
    }
  }

  public void setFinalStreamIntel(FinalStreamIntel finalStreamIntel) {
    if (!this.finalStreamIntel.compareAndSet(null, finalStreamIntel)) {
      assertionError.compareAndSet(
          null, new AssertionError("setFinalStreamIntel called more than once."));
    }
  }

  public void setCancelled() {
    if (!cancelled.compareAndSet(false, true)) {
      assertionError.compareAndSet(null, new AssertionError("setOnCancel called more than once."));
    }
  }

  public List<StreamIntel> getStreamIntels() { return streamIntels; }

  public FinalStreamIntel getFinalStreamIntel() { return finalStreamIntel.get(); }

  public EnvoyError getEnvoyError() { return envoyError.get(); }

  public ResponseHeaders getHeaders() { return headers.get(); }

  public boolean isCancelled() { return cancelled.get(); }

  public int getRequestChunkSent() { return requestChunkSent; }

  public String getBodyAsString() {
    int totalSize = bodies.stream().mapToInt(ByteBuffer::limit).sum();
    byte[] body = new byte[totalSize];
    int pos = 0;
    for (ByteBuffer buffer : bodies) {
      int bytesToRead = buffer.limit();
      buffer.get(body, pos, bytesToRead);
      pos += bytesToRead;
    }
    return new String(body);
  }

  public int getNbResponseChunks() { return bodies.size(); }

  public void throwAssertionErrorIfAny() {
    if (assertionError.get() != null) {
      throw assertionError.get();
    }
  }
}
package io.envoyproxy.envoymobile.engine.testing;

import io.envoyproxy.envoymobile.AndroidEngineBuilder;
import io.envoyproxy.envoymobile.Engine;
import io.envoyproxy.envoymobile.EnvoyError;
import io.envoyproxy.envoymobile.FinalStreamIntel;
import io.envoyproxy.envoymobile.LogLevel;
import io.envoyproxy.envoymobile.RequestHeaders;
import io.envoyproxy.envoymobile.RequestHeadersBuilder;
import io.envoyproxy.envoymobile.RequestMethod;
import io.envoyproxy.envoymobile.ResponseHeaders;
import io.envoyproxy.envoymobile.ResponseTrailers;
import io.envoyproxy.envoymobile.Stream;
import io.envoyproxy.envoymobile.StreamIntel;
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.AbstractMap.SimpleImmutableEntry;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

public final class RequestScenario {
  public int responseBufferSize = 1000;
  public boolean cancelOnResponseHeaders = false;
  public int cancelUploadOnChunk = -1;
  public boolean useDirectExecutor = false;
  public boolean waitOnReadData = false;
  public boolean useByteBufferPosition = false;
  public boolean closeBodyStream = false;
  public boolean cancelBeforeSendingRequestBody = false;

  private URL url;
  private RequestMethod method = null;
  private final List<ByteBuffer> bodyChunks = new ArrayList<>();
  private final List<Map.Entry<String, String>> headers = new ArrayList<>();
  private int trafficStatsUid = 0;
  private int trafficStatsTag = 0;

  public RequestHeaders getHeaders() {
    RequestHeadersBuilder requestHeadersBuilder =
        new RequestHeadersBuilder(method, url.getProtocol(), url.getAuthority(), url.getPath());
    headers.forEach(entry -> requestHeadersBuilder.add(entry.getKey(), entry.getValue()));
    if (trafficStatsUid != 0) {
      requestHeadersBuilder.addSocketTag(trafficStatsUid, trafficStatsTag);
    }
    return requestHeadersBuilder.build();
  }

  public List<ByteBuffer> getBodyChunks() {
    return closeBodyStream
        ? Collections.unmodifiableList(bodyChunks.subList(0, bodyChunks.size() - 1))
        : Collections.unmodifiableList(bodyChunks);
  }

  public Optional<ByteBuffer> getClosingBodyChunk() {
    return closeBodyStream ? Optional.of(bodyChunks.get(bodyChunks.size() - 1)) : Optional.empty();
  }

  public boolean hasBody() { return !bodyChunks.isEmpty(); }

  public RequestScenario setHttpMethod(RequestMethod requestMethod) {
    this.method = requestMethod;
    return this;
  }

  public RequestScenario setUrl(String url) throws MalformedURLException {
    this.url = new URL(url);
    return this;
  }

  public RequestScenario addBody(byte[] requestBodyChunk) {
    ByteBuffer byteBuffer = ByteBuffer.wrap(requestBodyChunk);
    bodyChunks.add(byteBuffer);
    return this;
  }

  public RequestScenario addBody(String requestBodyChunk) {
    return addBody(requestBodyChunk.getBytes());
  }

  public RequestScenario addBody(ByteBuffer requestBodyChunk) {
    bodyChunks.add(requestBodyChunk);
    return this;
  }

  public RequestScenario addHeader(String key, String value) {
    headers.add(new SimpleImmutableEntry<>(key, value));
    return this;
  }

  public RequestScenario setResponseBufferSize(int responseBufferSize) {
    this.responseBufferSize = responseBufferSize;
    return this;
  }

  public RequestScenario cancelOnResponseHeaders() {
    this.cancelOnResponseHeaders = true;
    return this;
  }

  public RequestScenario cancelUploadOnChunk(int chunkNo) {
    this.cancelUploadOnChunk = chunkNo;
    return this;
  }

  public RequestScenario useDirectExecutor() {
    this.useDirectExecutor = true;
    return this;
  }

  public RequestScenario waitOnReadData() {
    this.waitOnReadData = true;
    return this;
  }

  public RequestScenario closeBodyStream() {
    closeBodyStream = true;
    return this;
  }

  public RequestScenario cancelBeforeSendingRequestBody() {
    cancelBeforeSendingRequestBody = true;
    return this;
  }

  public RequestScenario useByteBufferPosition() {
    useByteBufferPosition = true;
    return this;
  }

  public RequestScenario addSocketTag(int uid, int tag) {
    trafficStatsUid = uid;
    trafficStatsTag = tag;
    return this;
  }
}
package io.envoyproxy.envoymobile.engine.testing;

import java.util.concurrent.atomic.AtomicBoolean;
import io.envoyproxy.envoymobile.engine.EnvoyConfiguration;

/**
 * Wrapper class for test JNI functions
 */
public final class TestJni {

  private static final AtomicBoolean sServerRunning = new AtomicBoolean();
  private static final AtomicBoolean xdsServerRunning = new AtomicBoolean();

  /**
   * Initializes an envoy server which will terminate cleartext CONNECT requests.
   *
   * @throws IllegalStateException if it's already started.
   */
  public static void startHttpProxyTestServer() {
    if (!sServerRunning.compareAndSet(false, true)) {
      throw new IllegalStateException("Server is already running");
    }
    nativeStartHttpProxyTestServer();
  }

  /**
   * Initializes an envoy server which will terminate encrypted CONNECT requests.
   *
   * @throws IllegalStateException if it's already started.
   */
  public static void startHttpsProxyTestServer() {
    if (!sServerRunning.compareAndSet(false, true)) {
      throw new IllegalStateException("Server is already running");
    }
    nativeStartHttpsProxyTestServer();
  }

  /**
   * Initializes the xDS test server.
   *
   * @throws IllegalStateException if it's already started.
   */
  public static void initXdsTestServer() {
    if (xdsServerRunning.get()) {
      throw new IllegalStateException("xDS server is already running");
    }
    nativeInitXdsTestServer();
  }

  /*
   * Starts the server. Throws an {@link IllegalStateException} if already started.
   */
  public static void startHttp3TestServer() {
    if (!sServerRunning.compareAndSet(false, true)) {
      throw new IllegalStateException("Server is already running");
    }
    nativeStartHttp3TestServer();
  }

  /*
   * Starts the server. Throws an {@link IllegalStateException} if already started.
   */
  public static void startHttp2TestServer() {
    if (!sServerRunning.compareAndSet(false, true)) {
      throw new IllegalStateException("Server is already running");
    }
    nativeStartHttp2TestServer();
  }

  /**
   * Starts the xDS test server.
   *
   * @throws IllegalStateException if it's already started.
   */
  public static void startXdsTestServer() {
    if (!xdsServerRunning.compareAndSet(false, true)) {
      throw new IllegalStateException("xDS server is already running");
    }
    nativeStartXdsTestServer();
  }

  /**
   * Sends the `DiscoveryResponse` message in the YAML format.
   */
  public static void sendDiscoveryResponse(String yaml) {
    if (!xdsServerRunning.get()) {
      throw new IllegalStateException("xDS server is not running");
    }
    nativeSendDiscoveryResponse(yaml);
  }

  /**
   * Shutdowns the server. No-op if the server is already shutdown.
   */
  public static void shutdownTestServer() {
    if (!sServerRunning.compareAndSet(true, false)) {
      return;
    }
    nativeShutdownTestServer();
  }

  /**
   * Shutdowns the xDS test server. No-op if the server is already shutdown.
   */
  public static void shutdownXdsTestServer() {
    if (!xdsServerRunning.compareAndSet(true, false)) {
      return;
    }
    nativeShutdownXdsTestServer();
  }

  public static String getServerURL() {
    return "https://" + getServerHost() + ":" + getServerPort();
  }

  public static String getServerHost() { return "test.example.com"; }

  /**
   * Gets the xDS test server host.
   */
  public static String getXdsTestServerHost() { return nativeGetXdsTestServerHost(); }

  /**
   * Gets the xDS test server port.
   */
  public static int getXdsTestServerPort() { return nativeGetXdsTestServerPort(); }

  /**
   * Returns the server attributed port. Throws an {@link IllegalStateException} if not started.
   */
  public static int getServerPort() {
    if (!sServerRunning.get()) {
      throw new IllegalStateException("Server not started.");
    }
    return nativeGetServerPort();
  }

  public static String createYaml(EnvoyConfiguration envoyConfiguration) {
    return nativeCreateYaml(envoyConfiguration.createBootstrap());
  }

  private static native void nativeStartHttp3TestServer();

  private static native void nativeStartHttp2TestServer();

  private static native void nativeShutdownTestServer();

  private static native int nativeGetServerPort();

  private static native void nativeStartHttpProxyTestServer();

  private static native void nativeStartHttpsProxyTestServer();

  private static native void nativeInitXdsTestServer();

  private static native String nativeGetXdsTestServerHost();

  private static native int nativeGetXdsTestServerPort();

  private static native void nativeStartXdsTestServer();

  private static native void nativeSendDiscoveryResponse(String yaml);

  private static native int nativeShutdownXdsTestServer();

  private static native String nativeCreateYaml(long bootstrap);

  private TestJni() {}
}
load("@build_bazel_rules_android//android:rules.bzl", "android_library")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:kotlin_test.bzl", "envoy_mobile_android_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

android_library(
    name = "testing",
    testonly = True,
    srcs = [
        "RequestScenario.java",
        "Response.java",
        "TestJni.java",
    ],
    visibility = ["//test:__subpackages__"],
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
    ],
)

envoy_mobile_android_test(
    name = "quic_test_server_test",
    srcs = [
        "QuicTestServerTest.java",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        ":testing",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
    ],
)
package io.envoyproxy.envoymobile.engine.testing;

import static org.assertj.core.api.Assertions.assertThat;

import android.content.Context;
import androidx.test.core.app.ApplicationProvider;
import io.envoyproxy.envoymobile.AndroidEngineBuilder;
import io.envoyproxy.envoymobile.Custom;
import io.envoyproxy.envoymobile.Engine;
import io.envoyproxy.envoymobile.EnvoyError;
import io.envoyproxy.envoymobile.LogLevel;
import io.envoyproxy.envoymobile.RequestHeaders;
import io.envoyproxy.envoymobile.RequestHeadersBuilder;
import io.envoyproxy.envoymobile.RequestMethod;
import io.envoyproxy.envoymobile.ResponseHeaders;
import io.envoyproxy.envoymobile.ResponseTrailers;
import io.envoyproxy.envoymobile.Stream;
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary;
import io.envoyproxy.envoymobile.engine.JniLibrary;
import io.envoyproxy.envoymobile.engine.testing.RequestScenario;
import io.envoyproxy.envoymobile.engine.testing.Response;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

@RunWith(RobolectricTestRunner.class)
public class QuicTestServerTest {

  private static final String HCM_TYPE =
      "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager";

  private static final String QUIC_UPSTREAM_TYPE =
      "type.googleapis.com/envoy.extensions.transport_sockets.quic.v3.QuicUpstreamTransport";

  private static final String CONFIG =
      "static_resources:\n"
      + " listeners:\n"
      + " - name: base_api_listener\n"
      + "   address:\n"
      + "     socket_address: { protocol: TCP, address: 0.0.0.0, port_value: 10000 }\n"
      + "   api_listener:\n"
      + "     api_listener:\n"
      + "       \"@type\": " + HCM_TYPE + "\n"
      + "       stat_prefix: api_hcm\n"
      + "       route_config:\n"
      + "         name: api_router\n"
      + "         virtual_hosts:\n"
      + "         - name: api\n"
      + "           domains: [\"*\"]\n"
      + "           routes:\n"
      + "           - match: { prefix: \"/\" }\n"
      + "             route: { cluster: h3_remote }\n"
      + "       http_filters:\n"
      + "       - name: envoy.router\n"
      + "         typed_config:\n"
      + "           \"@type\": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\n"
      + " clusters:\n"
      + " - name: h3_remote\n"
      + "   connect_timeout: 10s\n"
      + "   type: STATIC\n"
      + "   dns_lookup_family: V4_ONLY\n"
      + "   lb_policy: ROUND_ROBIN\n"
      + "   load_assignment:\n"
      + "     cluster_name: h3_remote\n"
      + "     endpoints:\n"
      + "     - lb_endpoints:\n"
      + "       - endpoint:\n"
      + "           address:\n"
      + "             socket_address: { address: 127.0.0.1, port_value: %s }\n"
      + "   typed_extension_protocol_options:\n"
      + "     envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n"
      +
      "       \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n"
      + "       explicit_http_config:\n"
      + "         http3_protocol_options: {}\n"
      + "       common_http_protocol_options:\n"
      + "         idle_timeout: 1s\n"
      + "   transport_socket:\n"
      + "     name: envoy.transport_sockets.quic\n"
      + "     typed_config:\n"
      + "       \"@type\": " + QUIC_UPSTREAM_TYPE + "\n"
      + "       upstream_tls_context:\n"
      + "         sni: www.lyft.com\n"
      + "listener_manager:\n"
      + "  name: envoy.listener_manager_impl.api\n"
      + "  typed_config:\n"
      + "    \"@type\": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager\n";

  private final Context appContext = ApplicationProvider.getApplicationContext();
  private Engine engine;

  @BeforeClass
  public static void loadJniLibrary() {
    AndroidJniLibrary.loadTestLibrary();
    JniLibrary.load();
  }

  @Before
  public void setUpEngine() throws Exception {
    TestJni.startHttp3TestServer();
    CountDownLatch latch = new CountDownLatch(1);
    engine = new AndroidEngineBuilder(appContext,
                                      new Custom(String.format(CONFIG, TestJni.getServerPort())))
                 .addLogLevel(LogLevel.WARN)
                 .setOnEngineRunning(() -> {
                   latch.countDown();
                   return null;
                 })
                 .build();
    latch.await(); // Don't launch a request before initialization has completed.
  }

  @After
  public void shutdownEngine() {
    engine.terminate();
    TestJni.shutdownTestServer();
  }

  @Test
  public void get_simpleTxt() throws Exception {
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.GET)
                                          .addHeader("no_trailers", "true")
                                          .setUrl(TestJni.getServerURL() + "/simple.txt");

    Response response = sendRequest(requestScenario);

    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString())
        .isEqualTo("This is a simple text file served by QUIC.\n");
    assertThat(response.getEnvoyError()).isNull();
  }

  private Response sendRequest(RequestScenario requestScenario) throws Exception {
    final CountDownLatch latch = new CountDownLatch(1);
    final AtomicReference<Response> response = new AtomicReference<>(new Response());

    Stream stream = engine.streamClient()
                        .newStreamPrototype()
                        .setOnResponseHeaders((responseHeaders, endStream, ignored) -> {
                          response.get().setHeaders(responseHeaders);
                          return null;
                        })
                        .setOnResponseData((data, endStream, ignored) -> {
                          response.get().addBody(data);
                          return null;
                        })
                        .setOnResponseTrailers((trailers, ignored) -> {
                          response.get().setTrailers(trailers);
                          return null;
                        })
                        .setOnError((error, ignored) -> {
                          response.get().setEnvoyError(error);
                          latch.countDown();
                          return null;
                        })
                        .setOnCancel((ignored) -> {
                          response.get().setCancelled();
                          latch.countDown();
                          return null;
                        })
                        .setOnComplete((ignored) -> {
                          latch.countDown();
                          return null;
                        })
                        .start(Executors.newSingleThreadExecutor())
                        .sendHeaders(requestScenario.getHeaders(), !requestScenario.hasBody());
    requestScenario.getBodyChunks().forEach(stream::sendData);
    requestScenario.getClosingBodyChunk().ifPresent(stream::close);
    latch.await();
    response.get().throwAssertionErrorIfAny();
    return response.get();
  }
}
package io.envoyproxy.envoymobile.engine

import com.google.protobuf.Struct
import com.google.protobuf.Value
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilter
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilterFactory
import io.envoyproxy.envoymobile.engine.EnvoyConfiguration.TrustChainVerification
import io.envoyproxy.envoymobile.engine.types.EnvoyStreamIntel
import io.envoyproxy.envoymobile.engine.types.EnvoyFinalStreamIntel
import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPFilterCallbacks
import io.envoyproxy.envoymobile.engine.testing.TestJni
import java.nio.ByteBuffer
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
import java.util.regex.Pattern

class TestFilter : EnvoyHTTPFilter {

override fun onRequestHeaders(headers: MutableMap<String, MutableList<String>>, endStream: Boolean, streamIntel: EnvoyStreamIntel): Array<Any> {
  return emptyArray()
}
override fun onRequestData(data: ByteBuffer, endStream: Boolean, streamIntel: EnvoyStreamIntel): Array<Any> {
  return emptyArray()
}
override fun onRequestTrailers(trailers: MutableMap<String, MutableList<String>>, streamIntel: EnvoyStreamIntel): Array<Any> {
  return emptyArray()
}
override fun onResponseHeaders(headers: MutableMap<String, MutableList<String>>, endStream: Boolean, streamIntel: EnvoyStreamIntel): Array<Any> {
  return emptyArray()
}
override fun onResponseData(data: ByteBuffer, endStream: Boolean, streamIntel: EnvoyStreamIntel): Array<Any> {
  return emptyArray()
}
override fun onResponseTrailers(trailers: MutableMap<String, MutableList<String>>, streamIntel: EnvoyStreamIntel): Array<Any> {
  return emptyArray()
}
override fun setRequestFilterCallbacks(callbacks: EnvoyHTTPFilterCallbacks) {
}
override fun setResponseFilterCallbacks(callbacks: EnvoyHTTPFilterCallbacks) {
}
override fun onCancel( streamIntel: EnvoyStreamIntel, finalStreamIntel: EnvoyFinalStreamIntel) {
}
override fun onComplete( streamIntel: EnvoyStreamIntel, finalStreamIntel: EnvoyFinalStreamIntel) {
}
override fun onError(errorCode: Int, message: String, attemptCount: Int, streamIntel: EnvoyStreamIntel, finalStreamIntel: EnvoyFinalStreamIntel) {
}
override fun onResumeRequest(headers: MutableMap<String, MutableList<String>>, data: ByteBuffer, trailers: MutableMap<String, MutableList<String>>, endStream: Boolean, streamIntel: EnvoyStreamIntel): Array<Any> {
  return emptyArray()
}
override fun onResumeResponse(headers: MutableMap<String, MutableList<String>>, data: ByteBuffer, trailers: MutableMap<String, MutableList<String>>, endStream: Boolean, streamIntel: EnvoyStreamIntel): Array<Any> {
  return emptyArray()
}
}

class TestEnvoyHTTPFilterFactory(name : String) : EnvoyHTTPFilterFactory {
 private var filterName = name
 override fun getFilterName(): String {
   return filterName
 }

 override fun create(): EnvoyHTTPFilter {
   return TestFilter()
 }
}

class EnvoyConfigurationTest {

  fun buildTestEnvoyConfiguration(
    connectTimeoutSeconds: Int = 123,
    dnsRefreshSeconds: Int = 234,
    dnsFailureRefreshSecondsBase: Int = 345,
    dnsFailureRefreshSecondsMax: Int = 456,
    dnsQueryTimeoutSeconds: Int = 321,
    dnsMinRefreshSeconds: Int = 12,
    dnsPreresolveHostnames: MutableList<String> = mutableListOf("hostname1", "hostname2"),
    enableDNSCache: Boolean = false,
    dnsCacheSaveIntervalSeconds: Int = 101,
    enableDrainPostDnsRefresh: Boolean = false,
    enableHttp3: Boolean = true,
    http3ConnectionOptions: String = "5RTO",
    http3ClientConnectionOptions: String = "MPQC",
    quicHints: Map<String, Int> = mapOf("www.abc.com" to 443, "www.def.com" to 443),
    quicCanonicalSuffixes: MutableList<String> = mutableListOf(".opq.com", ".xyz.com"),
    enableGzipDecompression: Boolean = true,
    enableBrotliDecompression: Boolean = false,
    enableSocketTagging: Boolean = false,
    enableInterfaceBinding: Boolean = false,
    h2ConnectionKeepaliveIdleIntervalMilliseconds: Int = 222,
    h2ConnectionKeepaliveTimeoutSeconds: Int = 333,
    maxConnectionsPerHost: Int = 543,
    streamIdleTimeoutSeconds: Int = 678,
    perTryIdleTimeoutSeconds: Int = 910,
    appVersion: String = "v1.2.3",
    appId: String = "com.example.myapp",
    trustChainVerification: TrustChainVerification = TrustChainVerification.VERIFY_TRUST_CHAIN,
    filterChain: MutableList<EnvoyNativeFilterConfig> = mutableListOf(EnvoyNativeFilterConfig("buffer_filter_1", "{'@type': 'type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer'}"), EnvoyNativeFilterConfig("buffer_filter_2", "{'@type': 'type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer'}")),
    platformFilterFactories: MutableList<EnvoyHTTPFilterFactory> = mutableListOf(TestEnvoyHTTPFilterFactory("name1"), TestEnvoyHTTPFilterFactory("name2")),
    runtimeGuards: Map<String,Boolean> = emptyMap(),
    enablePlatformCertificatesValidation: Boolean = false,
    rtdsResourceName: String = "",
    rtdsTimeoutSeconds: Int = 0,
    xdsAddress: String = "",
    xdsPort: Int = 0,
    xdsGrpcInitialMetadata: Map<String, String> = emptyMap(),
    xdsSslRootCerts: String = "",
    nodeId: String = "",
    nodeRegion: String = "",
    nodeZone: String = "",
    nodeSubZone: String = "",
    nodeMetadata: Struct = Struct.getDefaultInstance(),
    cdsResourcesLocator: String = "",
    cdsTimeoutSeconds: Int = 0,
    enableCds: Boolean = false,

  ): EnvoyConfiguration {
    return EnvoyConfiguration(
      connectTimeoutSeconds,
      dnsRefreshSeconds,
      dnsFailureRefreshSecondsBase,
      dnsFailureRefreshSecondsMax,
      dnsQueryTimeoutSeconds,
      dnsMinRefreshSeconds,
      dnsPreresolveHostnames,
      enableDNSCache,
      dnsCacheSaveIntervalSeconds,
      enableDrainPostDnsRefresh,
      enableHttp3,
      http3ConnectionOptions,
      http3ClientConnectionOptions,
      quicHints,
      quicCanonicalSuffixes,
      enableGzipDecompression,
      enableBrotliDecompression,
      enableSocketTagging,
      enableInterfaceBinding,
      h2ConnectionKeepaliveIdleIntervalMilliseconds,
      h2ConnectionKeepaliveTimeoutSeconds,
      maxConnectionsPerHost,
      streamIdleTimeoutSeconds,
      perTryIdleTimeoutSeconds,
      appVersion,
      appId,
      trustChainVerification,
      filterChain,
      platformFilterFactories,
      emptyMap(),
      emptyMap(),
      runtimeGuards,
      enablePlatformCertificatesValidation,
      rtdsResourceName,
      rtdsTimeoutSeconds,
      xdsAddress,
      xdsPort,
      xdsGrpcInitialMetadata,
      xdsSslRootCerts,
      nodeId,
      nodeRegion,
      nodeZone,
      nodeSubZone,
      nodeMetadata,
      cdsResourcesLocator,
      cdsTimeoutSeconds,
      enableCds
    )
  }

  fun isEnvoyMobileXdsDisabled(): Boolean {
    return System.getProperty("envoy_jni_envoy_mobile_xds_disabled") != null;
  }

  @Test
  fun `configuration default values`() {
    JniLibrary.loadTestLibrary()
    val envoyConfiguration = buildTestEnvoyConfiguration()

    val resolvedTemplate = TestJni.createYaml(envoyConfiguration)
    assertThat(resolvedTemplate).contains("connect_timeout: 123s")

    // DNS
    assertThat(resolvedTemplate).contains("dns_refresh_rate: 234s")
    assertThat(resolvedTemplate).contains("base_interval: 345s")
    assertThat(resolvedTemplate).contains("max_interval: 456s")
    assertThat(resolvedTemplate).contains("dns_query_timeout: 321s")
    assertThat(resolvedTemplate).contains("dns_lookup_family: ALL")
    assertThat(resolvedTemplate).contains("dns_min_refresh_rate: 12s")
    assertThat(resolvedTemplate).contains("preresolve_hostnames:")
    assertThat(resolvedTemplate).contains("hostname1")
    assertThat(resolvedTemplate).contains("hostname1")

    // Forcing IPv6
    assertThat(resolvedTemplate).contains("always_use_v6: true")

    // H2 Ping
    assertThat(resolvedTemplate).contains("connection_idle_interval: 0.222s")
    assertThat(resolvedTemplate).contains("timeout: 333s")

    // H3
    assertThat(resolvedTemplate).contains("http3_protocol_options:");
    assertThat(resolvedTemplate).contains("name: alternate_protocols_cache");
    assertThat(resolvedTemplate).contains("hostname: www.abc.com");
    assertThat(resolvedTemplate).contains("hostname: www.def.com");
    assertThat(resolvedTemplate).contains("port: 443");
    assertThat(resolvedTemplate).contains("canonical_suffixes:");
    assertThat(resolvedTemplate).contains(".opq.com");
    assertThat(resolvedTemplate).contains(".xyz.com");
    assertThat(resolvedTemplate).contains("connection_options: 5RTO");
    assertThat(resolvedTemplate).contains("client_connection_options: MPQC");

    // Per Host Limits
    assertThat(resolvedTemplate).contains("max_connections: 543")

    // Metadata
    assertThat(resolvedTemplate).contains("os: Android")
    assertThat(resolvedTemplate).contains("app_version: v1.2.3")
    assertThat(resolvedTemplate).contains("app_id: com.example.myapp")

    // Idle timeouts
    assertThat(resolvedTemplate).contains("stream_idle_timeout: 678s")
    assertThat(resolvedTemplate).contains("per_try_idle_timeout: 910s")

    // Filters
    assertThat(resolvedTemplate).contains("buffer_filter_1")
    assertThat(resolvedTemplate).contains("type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer")

    // Cert Validation
    assertThat(resolvedTemplate).contains("trusted_ca:")

    // Validate ordering between filters and platform filters
    assertThat(resolvedTemplate).matches(Pattern.compile(".*name1.*name2.*buffer_filter_1.*buffer_filter_2.*", Pattern.DOTALL));
    // Validate that createYaml doesn't change filter order.
    val resolvedTemplate2 = TestJni.createYaml(envoyConfiguration)
    assertThat(resolvedTemplate2).matches(Pattern.compile(".*name1.*name2.*buffer_filter_1.*buffer_filter_2.*", Pattern.DOTALL));
    // Validate that createBootstrap also doesn't change filter order.
    // This may leak memory as the boostrap isn't used.
    envoyConfiguration.createBootstrap()
    val resolvedTemplate3 = TestJni.createYaml(envoyConfiguration)
    assertThat(resolvedTemplate3).matches(Pattern.compile(".*name1.*name2.*buffer_filter_1.*buffer_filter_2.*", Pattern.DOTALL));
  }

  @Test
  fun `configuration resolves with alternate values`() {
    JniLibrary.loadTestLibrary()
    val envoyConfiguration = buildTestEnvoyConfiguration(
      enableDrainPostDnsRefresh = true,
      enableDNSCache = true,
      dnsCacheSaveIntervalSeconds = 101,
      enableHttp3 = false,
      enableGzipDecompression = false,
      enableBrotliDecompression = true,
      enableSocketTagging = true,
      enableInterfaceBinding = true,
      enablePlatformCertificatesValidation = true,
      dnsPreresolveHostnames = mutableListOf(),
      filterChain = mutableListOf(),
      runtimeGuards = mapOf("test_feature_false" to true),
      trustChainVerification = TrustChainVerification.ACCEPT_UNTRUSTED
    )

    val resolvedTemplate = TestJni.createYaml(envoyConfiguration)

    // TlS Verification
    assertThat(resolvedTemplate).contains("trust_chain_verification: ACCEPT_UNTRUSTED")

    // enableDrainPostDnsRefresh = true
    assertThat(resolvedTemplate).contains("enable_drain_post_dns_refresh: true")

    // enableDNSCache = true
    assertThat(resolvedTemplate).contains("key: dns_persistent_cache")
    // dnsCacheSaveIntervalSeconds = 101
    assertThat(resolvedTemplate).contains("save_interval: 101")

    // enableHttp3 = false
    assertThat(resolvedTemplate).doesNotContain("name: alternate_protocols_cache");

    // enableGzipDecompression = false
    assertThat(resolvedTemplate).doesNotContain("type.googleapis.com/envoy.extensions.compression.gzip.decompressor.v3.Gzip");

    // enableBrotliDecompression = true
    assertThat(resolvedTemplate).contains("type.googleapis.com/envoy.extensions.compression.brotli.decompressor.v3.Brotli");

    // enableInterfaceBinding = true
    assertThat(resolvedTemplate).contains("enable_interface_binding: true")

    // enablePlatformCertificatesValidation = true
    assertThat(resolvedTemplate).doesNotContain("trusted_ca:")

    // ADS and RTDS not included by default
    assertThat(resolvedTemplate).doesNotContain("rtds_layer:");
    assertThat(resolvedTemplate).doesNotContain("ads_config:");
    assertThat(resolvedTemplate).doesNotContain("cds_config:");
  }

  @Test
  fun `test YAML loads with multiple entries`() {
    JniLibrary.loadTestLibrary()
    val envoyConfiguration = buildTestEnvoyConfiguration(
      runtimeGuards = mapOf("test_feature_false" to true, "test_feature_true" to false),
    )

    val resolvedTemplate = TestJni.createYaml(envoyConfiguration)

    assertThat(resolvedTemplate).contains("test_feature_false");
    assertThat(resolvedTemplate).contains("test_feature_true");
  }

  @Test
  fun `test adding RTDS`() {
    if (isEnvoyMobileXdsDisabled()) {
      return;
    }

    JniLibrary.loadTestLibrary()
    val envoyConfiguration = buildTestEnvoyConfiguration(
      rtdsResourceName = "fake_rtds_layer", rtdsTimeoutSeconds = 5432, xdsAddress = "FAKE_ADDRESS", xdsPort = 0
    )

    val resolvedTemplate = TestJni.createYaml(envoyConfiguration)
    assertThat(resolvedTemplate).contains("fake_rtds_layer");
    assertThat(resolvedTemplate).contains("FAKE_ADDRESS");
    assertThat(resolvedTemplate).contains("initial_fetch_timeout: 5432s");
  }

  @Test
  fun `test adding RTDS and CDS`() {
    if (isEnvoyMobileXdsDisabled()) {
      return;
    }

    JniLibrary.loadTestLibrary()
    val envoyConfiguration = buildTestEnvoyConfiguration(
      cdsResourcesLocator = "FAKE_CDS_LOCATOR", cdsTimeoutSeconds = 356, xdsAddress = "FAKE_ADDRESS", xdsPort = 0, enableCds = true
    )

    val resolvedTemplate = TestJni.createYaml(envoyConfiguration)

    assertThat(resolvedTemplate).contains("FAKE_CDS_LOCATOR");
    assertThat(resolvedTemplate).contains("FAKE_ADDRESS");
    assertThat(resolvedTemplate).contains("initial_fetch_timeout: 356s");
  }

  @Test
  fun `test not using enableCds`() {
    JniLibrary.loadTestLibrary()
    val envoyConfiguration = buildTestEnvoyConfiguration(
      cdsResourcesLocator = "FAKE_CDS_LOCATOR", cdsTimeoutSeconds = 356, xdsAddress = "FAKE_ADDRESS", xdsPort = 0
    )

    val resolvedTemplate = TestJni.createYaml(envoyConfiguration)

    assertThat(resolvedTemplate).doesNotContain("FAKE_CDS_LOCATOR");
    assertThat(resolvedTemplate).doesNotContain("initial_fetch_timeout: 356s");
  }

  @Test
  fun `test enableCds with default string`() {
    if (isEnvoyMobileXdsDisabled()) {
      return;
    }

    JniLibrary.loadTestLibrary()
    val envoyConfiguration = buildTestEnvoyConfiguration(
      enableCds = true, xdsAddress = "FAKE_ADDRESS", xdsPort = 0
    )

    val resolvedTemplate = TestJni.createYaml(envoyConfiguration)

    assertThat(resolvedTemplate).contains("cds_config:");
    assertThat(resolvedTemplate).contains("initial_fetch_timeout: 5s");
  }

  @Test
  fun `test RTDS default timeout`() {
    if (isEnvoyMobileXdsDisabled()) {
      return;
    }

    JniLibrary.loadTestLibrary()
    val envoyConfiguration = buildTestEnvoyConfiguration(
      rtdsResourceName = "fake_rtds_layer", xdsAddress = "FAKE_ADDRESS", xdsPort = 0
    )

    val resolvedTemplate = TestJni.createYaml(envoyConfiguration)

    assertThat(resolvedTemplate).contains("initial_fetch_timeout: 5s")
  }

  @Test
  fun `test node metadata`() {
    JniLibrary.loadTestLibrary()
    val envoyConfiguration = buildTestEnvoyConfiguration(
      nodeMetadata = Struct.newBuilder()
        .putFields("metadata_field", Value.newBuilder().setStringValue("metadata_value").build())
        .build()
    )

    val resolvedTemplate = TestJni.createYaml(envoyConfiguration)

    assertThat(resolvedTemplate).contains("metadata_field")
    assertThat(resolvedTemplate).contains("metadata_value")
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:kotlin_test.bzl", "envoy_mobile_android_test", "envoy_mobile_jni_kt_test", "envoy_mobile_kt_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_jni_kt_test(
    name = "envoy_configuration_test",
    srcs = [
        "EnvoyConfigurationTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//test/java/io/envoyproxy/envoymobile/engine/testing",
        "@maven//:com_google_protobuf_protobuf_javalite",
    ],
)

envoy_mobile_kt_test(
    name = "envoy_native_resource_registry_test",
    srcs = [
        "EnvoyNativeResourceRegistryTest.kt",
    ],
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
    ],
)

envoy_mobile_kt_test(
    name = "jvm_bridge_utility_test",
    srcs = [
        "JvmBridgeUtilityTest.kt",
    ],
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
    ],
)

envoy_mobile_android_test(
    name = "android_network_monitor_tests",
    srcs = [
        "AndroidNetworkMonitorTest.java",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_engine_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)
package io.envoyproxy.envoymobile.engine

import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class EnvoyNativeResourceRegistryTest {

  @Test
  fun `release callbacks are invoked when EnvoyNativeResourceWrappers are flagged as unreachable`() {
    val latch = CountDownLatch(1)
    val testHandle: Long = 77
    // Force Wrapper out of scope so the GC picks it up. ¯\_(ツ)_/¯
    for (i in 0..1 step 2) {
      var testResourceWrapper: EnvoyNativeResourceWrapper? = object : EnvoyNativeResourceWrapper {}
      val testResourceReleaser = object : EnvoyNativeResourceReleaser {
        override fun release(nativeHandle: Long) {
          assertThat(nativeHandle).isEqualTo(testHandle)
          latch.countDown()
        }
      }
      EnvoyNativeResourceRegistry.globalRegister(testResourceWrapper, testHandle, testResourceReleaser)
    }

    System.runFinalization()
    System.gc()
    assertThat(latch.await(2000, TimeUnit.MILLISECONDS)).isTrue()
  }

  @Test
  fun `release callbacks are not invoked when EnvoyNativeResourceWrappers remain reachable`() {
    val latch = CountDownLatch(1)
    val testHandle: Long = 77
    // Wrapper will remain reachable.
    val testResourceWrapper = object : EnvoyNativeResourceWrapper {}
    for (i in 0..1 step 2) {
      val testResourceReleaser = object : EnvoyNativeResourceReleaser {
        override fun release(nativeHandle: Long) {
          // Should be not called.
          latch.countDown()
        }
      }
      EnvoyNativeResourceRegistry.globalRegister(testResourceWrapper, testHandle, testResourceReleaser)
    }

    System.runFinalization()
    System.gc()
    assertThat(latch.await(2000, TimeUnit.MILLISECONDS)).isFalse()
  }
}
package io.envoyproxy.envoymobile.engine;

import static org.robolectric.Shadows.shadowOf;

import android.content.Context;
import android.content.Intent;
import android.Manifest;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import androidx.test.filters.MediumTest;
import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.rule.GrantPermissionRule;
import androidx.test.annotation.UiThreadTest;
import io.envoyproxy.envoymobile.MockEnvoyEngine;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.shadows.ShadowConnectivityManager;

/**
 * Tests functionality of AndroidNetworkMonitor
 */
@RunWith(RobolectricTestRunner.class)
public class AndroidNetworkMonitorTest {

  @Rule
  public GrantPermissionRule mRuntimePermissionRule =
      GrantPermissionRule.grant(Manifest.permission.ACCESS_NETWORK_STATE);

  private AndroidNetworkMonitor androidNetworkMonitor;
  private ShadowConnectivityManager connectivityManager;
  private Context context;

  @Before
  public void setUp() {
    context = InstrumentationRegistry.getInstrumentation().getTargetContext();
    AndroidNetworkMonitor.load(context, new MockEnvoyEngine());
    androidNetworkMonitor = AndroidNetworkMonitor.getInstance();
    connectivityManager = shadowOf(androidNetworkMonitor.getConnectivityManager());
  }

  /**
   * Tests that isOnline() returns the correct result.
   */
  @Test
  @MediumTest
  @UiThreadTest
  public void testAndroidNetworkMonitorIsOnline() {
    Intent intent = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
    // Set up network change
    androidNetworkMonitor.onReceive(context, intent);
    Assert.assertTrue(androidNetworkMonitor.isOnline());

    // Save old networkInfo and simulate a no network scenerio
    NetworkInfo networkInfo = androidNetworkMonitor.getConnectivityManager().getActiveNetworkInfo();
    connectivityManager.setActiveNetworkInfo(null);
    androidNetworkMonitor.onReceive(context, intent);
    Assert.assertFalse(androidNetworkMonitor.isOnline());

    // Bring back online since the AndroidNetworkMonitor class is a singleton
    connectivityManager.setActiveNetworkInfo(networkInfo);
    androidNetworkMonitor.onReceive(context, intent);
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.Engine
import java.time.Instant
import java.util.concurrent.TimeUnit
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds
import kotlin.time.DurationUnit
import org.junit.Assert.fail

/** Gets the stats in the form of `Map<String, String>`. */
fun Engine.getStats(): Map<String, String> {
  // `dumpStats()` produces the following format:
  // key1: value1
  // key2: value2
  // key3: value3
  // ...
  val lines = dumpStats().split("\n")
  return lines
    .mapNotNull {
      val keyValue = it.split(": ")
      if (keyValue.size == 2) {
        Pair(keyValue[0], keyValue[1])
      } else {
        null
      }
    }
    .toMap()
}

/**
 * Waits for 5 seconds (default) until the stat of the given [name] is greater than equal the
 * specified [expectedValue].
 *
 * @throws java.lang.AssertionError throw when the the operation timed out waiting for the stat
 *   value to be greater than the [expectedValue].
 */
fun Engine.waitForStatGe(
  name: String,
  expectedValue: Long,
  timeout: Duration = 5.seconds,
) {
  val waitTime = Instant.now().plusMillis(timeout.toLong(DurationUnit.MILLISECONDS))
  var currentValue = getStats()[name]
  while (currentValue == null || currentValue.toLong() < expectedValue) {
    if (Instant.now() > waitTime) {
      fail("Timed out waiting for $name to be greater than equal $expectedValue")
    }
    TimeUnit.MILLISECONDS.sleep(10)
    currentValue = getStats()[name]
  }
}
package test.kotlin.integration

import java.io.IOException
import java.net.DatagramPacket
import java.net.DatagramSocket
import java.net.SocketTimeoutException
import java.util.concurrent.CountDownLatch
import java.util.concurrent.atomic.AtomicReference

class TestStatsdServer {
  private val shutdownLatch: CountDownLatch = CountDownLatch(1)
  private val awaitNextStat: AtomicReference<CountDownLatch> = AtomicReference(CountDownLatch(0))
  private val matchCriteria: AtomicReference<(String) -> Boolean> = AtomicReference()

  private var thread: Thread? = null
  private var latch: CountDownLatch? = null

  @Throws(IOException::class)
  fun runAsync(port: Int) {
    val socket = DatagramSocket(port)
    socket.setSoTimeout(1000) // 1 second

    thread =
      Thread(
        fun() {
          val buffer = ByteArray(256)
          while (shutdownLatch.getCount() != 0L) {
            val packet = DatagramPacket(buffer, buffer.size)
            try {
              socket.receive(packet)
            } catch (e: SocketTimeoutException) {
              // continue to next loop
              continue
            } catch (e: Exception) {
              // TODO(snowp): Bubble up this error somehow.
              return
            }

            // TODO(snowp): Parse (or use a parser) so we can extract out individual metric names
            // better.
            val received = String(packet.getData(), packet.getOffset(), packet.getLength())
            val maybeMatch = matchCriteria.get()
            if (maybeMatch != null && maybeMatch.invoke(received)) {
              matchCriteria.set(null)
              awaitNextStat.get().countDown()
            }
          }
        }
      )
    thread!!.start()
  }

  // Creates the notification condition based on the input predicate.
  // Callers of this method must call awaitStatMatching() to wait for the condition to be met on
  // the server.
  fun setStatMatching(predicate: (String) -> Boolean) {
    latch = CountDownLatch(1)
    awaitNextStat.set(latch)
    matchCriteria.set(predicate)
  }

  // setStatMatching() must be called before calling this method.
  fun awaitStatMatching() {
    latch?.await()
  }

  @Throws(InterruptedException::class)
  fun shutdown() {
    shutdownLatch.countDown()
    thread?.join()
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.EnvoyError
import io.envoyproxy.envoymobile.FilterDataStatus
import io.envoyproxy.envoymobile.FilterHeadersStatus
import io.envoyproxy.envoymobile.FilterTrailersStatus
import io.envoyproxy.envoymobile.FinalStreamIntel
import io.envoyproxy.envoymobile.GRPCClient
import io.envoyproxy.envoymobile.GRPCRequestHeadersBuilder
import io.envoyproxy.envoymobile.ResponseFilter
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.ResponseTrailers
import io.envoyproxy.envoymobile.Standard
import io.envoyproxy.envoymobile.StreamIntel
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.nio.ByteBuffer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.fail
import org.junit.Test

private const val PBF_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.platform_bridge.PlatformBridge"
private const val FILTER_NAME = "error_validation_filter"

class GRPCReceiveErrorTest {
  init {
    JniLibrary.loadTestLibrary()
  }

  private val callbackReceivedError = CountDownLatch(1)
  private val filterReceivedError = CountDownLatch(1)
  private val filterNotCancelled = CountDownLatch(1)

  class ErrorValidationFilter(
    private val receivedError: CountDownLatch,
    private val notCancelled: CountDownLatch
  ) : ResponseFilter {
    override fun onResponseHeaders(
      headers: ResponseHeaders,
      endStream: Boolean,
      streamIntel: StreamIntel
    ): FilterHeadersStatus<ResponseHeaders> {
      return FilterHeadersStatus.Continue(headers)
    }

    override fun onResponseData(
      body: ByteBuffer,
      endStream: Boolean,
      streamIntel: StreamIntel
    ): FilterDataStatus<ResponseHeaders> {
      return FilterDataStatus.Continue(body)
    }

    override fun onResponseTrailers(
      trailers: ResponseTrailers,
      streamIntel: StreamIntel
    ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
      return FilterTrailersStatus.Continue(trailers)
    }

    override fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel) {
      receivedError.countDown()
    }

    override fun onComplete(finalStreamIntel: FinalStreamIntel) {}

    override fun onCancel(finalStreamIntel: FinalStreamIntel) {
      notCancelled.countDown()
    }
  }

  @Test
  fun `errors on stream call onError callback`() {
    val requestHeader =
      GRPCRequestHeadersBuilder(
          scheme = "https",
          authority = "example.com",
          path = "/pb.api.v1.Foo/GetBar"
        )
        .build()

    val engine =
      EngineBuilder(Standard())
        .addPlatformFilter(
          name = FILTER_NAME,
          factory = { ErrorValidationFilter(filterReceivedError, filterNotCancelled) }
        )
        .addNativeFilter(
          "envoy.filters.http.platform_bridge",
          "{'@type': $PBF_TYPE, platform_filter_name: $FILTER_NAME}"
        )
        .build()

    GRPCClient(engine.streamClient())
      .newGRPCStreamPrototype()
      .setOnError { _, _ -> callbackReceivedError.countDown() }
      .setOnCancel { _ -> fail("Unexpected call to onCancel response callback") }
      .start()
      .sendHeaders(requestHeader, false)
      .sendMessage(ByteBuffer.wrap(ByteArray(5)))

    filterReceivedError.await(10, TimeUnit.SECONDS)
    filterNotCancelled.await(1, TimeUnit.SECONDS)
    callbackReceivedError.await(10, TimeUnit.SECONDS)
    engine.terminate()

    assertThat(filterReceivedError.count)
      .withFailMessage("Missing call to onError filter callback")
      .isEqualTo(0)

    assertThat(filterNotCancelled.count)
      .withFailMessage("Unexpected call to onCancel filter callback")
      .isEqualTo(1)

    assertThat(callbackReceivedError.count)
      .withFailMessage("Missing call to onError response callback")
      .isEqualTo(0)
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.engine.JniLibrary
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class EnvoyEngineSimpleIntegrationTest {

  init {
    JniLibrary.loadTestLibrary()
  }

  @Test
  fun `ensure engine build and termination succeeds with no errors`() {
    val engine = EngineBuilder().build()
    Thread.sleep(5000)
    engine.terminate()
    assertThat(true).isTrue()
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.nio.ByteBuffer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class SetEventTrackerTest {

  init {
    JniLibrary.loadTestLibrary()
  }

  @Test
  fun `set eventTracker`() {
    val countDownLatch = CountDownLatch(1)
    val engine =
      EngineBuilder()
        .setEventTracker { events ->
          for (entry in events) {
            assertThat(entry.key).isEqualTo("foo")
            assertThat(entry.value).isEqualTo("bar")
          }
          countDownLatch.countDown()
        }
        .addNativeFilter(
          "envoy.filters.http.test_event_tracker",
          "{\"@type\":\"type.googleapis.com/envoymobile.extensions.filters.http.test_event_tracker.TestEventTracker\",\"attributes\":{\"foo\":\"bar\"}}"
        )
        .build()

    val client = engine.streamClient()

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "example.com",
          path = "/test"
        )
        .build()

    client.newStreamPrototype().start().sendHeaders(requestHeaders, true)

    countDownLatch.await(30, TimeUnit.SECONDS)
    engine.terminate()
    assertThat(countDownLatch.count).isEqualTo(0)
  }

  @Test
  fun `engine should continue to run if no eventTracker is set and event is emitted`() {
    val countDownLatch = CountDownLatch(1)
    val engine =
      EngineBuilder()
        .addNativeFilter(
          "envoy.filters.http.test_event_tracker",
          "{\"@type\":\"type.googleapis.com/envoymobile.extensions.filters.http.test_event_tracker.TestEventTracker\",\"attributes\":{\"foo\":\"bar\"}}"
        )
        .build()

    val client = engine.streamClient()

    client
      .newStreamPrototype()
      .setOnResponseData { _, _, _ -> countDownLatch.countDown() }
      .start()
      .close(ByteBuffer.allocate(1))

    countDownLatch.await(30, TimeUnit.SECONDS)
    engine.terminate()
    assertThat(countDownLatch.count).isEqualTo(0)
  }
}
package test.kotlin.integration

import com.google.protobuf.NullValue
import com.google.protobuf.Struct
import com.google.protobuf.Value
import io.envoyproxy.envoymobile.Element
import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.LogLevel
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class EngineApiTest {
  init {
    JniLibrary.loadTestLibrary()
  }

  @Test
  fun `verify engine APIs`() {
    val countDownLatch = CountDownLatch(1)
    val engine =
      EngineBuilder()
        .addLogLevel(LogLevel.INFO)
        .setNodeId("node-id")
        .setNodeLocality("region", "zone", "subzone")
        .setNodeMetadata(
          Struct.newBuilder()
            .putFields("string_value", Value.newBuilder().setStringValue("string").build())
            .putFields("number_value", Value.newBuilder().setNumberValue(123.0).build())
            .putFields("bool_value", Value.newBuilder().setBoolValue(true).build())
            .putFields("null_value", Value.newBuilder().setNullValue(NullValue.NULL_VALUE).build())
            .putFields(
              "struct_value",
              Value.newBuilder()
                .setStructValue(
                  Struct.newBuilder()
                    .putFields(
                      "nested_value",
                      Value.newBuilder().setStringValue("nested_string").build()
                    )
                    .build()
                )
                .build()
            )
            .build()
        )
        .setOnEngineRunning { countDownLatch.countDown() }
        .build()

    assertThat(countDownLatch.await(30, TimeUnit.SECONDS)).isTrue()

    engine.pulseClient().counter(Element("foo"), Element("bar")).increment(1)

    assertThat(engine.dumpStats()).contains("pulse.foo.bar: 1")

    engine.terminate()
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.Standard
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary
import io.envoyproxy.envoymobile.engine.EnvoyConfiguration.TrustChainVerification
import io.envoyproxy.envoymobile.engine.JniLibrary
import io.envoyproxy.envoymobile.engine.testing.TestJni
import java.nio.ByteBuffer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.fail
import org.junit.Test

private const val ASSERTION_FILTER_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.assertion.Assertion"
private const val REQUEST_STRING_MATCH = "match_me"

class SendDataTest {
  init {
    AndroidJniLibrary.loadTestLibrary()
    JniLibrary.load()
  }

  @Test
  fun `successful sending data`() {
    TestJni.startHttp2TestServer()
    val port = TestJni.getServerPort()

    val expectation = CountDownLatch(1)
    val engine =
      EngineBuilder(Standard())
        .addNativeFilter(
          "envoy.filters.http.assertion",
          "{'@type': $ASSERTION_FILTER_TYPE, match_config: {http_request_generic_body_match: {patterns: [{string_match: $REQUEST_STRING_MATCH}]}}}"
        )
        .setTrustChainVerification(TrustChainVerification.ACCEPT_UNTRUSTED)
        .build()

    val client = engine.streamClient()

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "localhost:$port",
          path = "/simple.txt"
        )
        .build()

    val body = ByteBuffer.wrap(REQUEST_STRING_MATCH.toByteArray(Charsets.UTF_8))

    var responseStatus: Int? = null
    var responseEndStream = false
    client
      .newStreamPrototype()
      .setOnResponseHeaders { headers, endStream, _ ->
        responseStatus = headers.httpStatus
        responseEndStream = endStream
        expectation.countDown()
      }
      .setOnResponseData { _, endStream, _ -> responseEndStream = endStream }
      .setOnError { _, _ -> fail("Unexpected error") }
      .start()
      .sendHeaders(requestHeaders, false)
      .close(body)

    expectation.await(10, TimeUnit.SECONDS)

    engine.terminate()
    TestJni.shutdownTestServer()

    assertThat(expectation.count).isEqualTo(0)
    assertThat(responseStatus).isEqualTo(200)
    assertThat(responseEndStream).isTrue()
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.EnvoyError
import io.envoyproxy.envoymobile.FilterDataStatus
import io.envoyproxy.envoymobile.FilterHeadersStatus
import io.envoyproxy.envoymobile.FilterTrailersStatus
import io.envoyproxy.envoymobile.FinalStreamIntel
import io.envoyproxy.envoymobile.GRPCRequestHeadersBuilder
import io.envoyproxy.envoymobile.ResponseFilter
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.ResponseTrailers
import io.envoyproxy.envoymobile.Standard
import io.envoyproxy.envoymobile.StreamIntel
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.nio.ByteBuffer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.fail
import org.junit.Test

private const val PBF_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.platform_bridge.PlatformBridge"
private const val LOCAL_ERROR_FILTER_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.local_error.LocalError"
private const val FILTER_NAME = "error_validation_filter"

class ReceiveErrorTest {
  init {
    JniLibrary.loadTestLibrary()
  }

  private val callbackReceivedError = CountDownLatch(1)
  private val filterReceivedError = CountDownLatch(1)
  private val filterNotCancelled = CountDownLatch(1)

  class ErrorValidationFilter(
    private val receivedError: CountDownLatch,
    private val notCancelled: CountDownLatch
  ) : ResponseFilter {
    override fun onResponseHeaders(
      headers: ResponseHeaders,
      endStream: Boolean,
      streamIntel: StreamIntel
    ): FilterHeadersStatus<ResponseHeaders> {
      return FilterHeadersStatus.Continue(headers)
    }

    override fun onResponseData(
      body: ByteBuffer,
      endStream: Boolean,
      streamIntel: StreamIntel
    ): FilterDataStatus<ResponseHeaders> {
      return FilterDataStatus.Continue(body)
    }

    override fun onResponseTrailers(
      trailers: ResponseTrailers,
      streamIntel: StreamIntel
    ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
      return FilterTrailersStatus.Continue(trailers)
    }

    override fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel) {
      receivedError.countDown()
    }

    override fun onComplete(finalStreamIntel: FinalStreamIntel) {}

    override fun onCancel(finalStreamIntel: FinalStreamIntel) {
      notCancelled.countDown()
    }
  }

  @Test
  fun `errors on stream call onError callback`() {
    val requestHeader =
      GRPCRequestHeadersBuilder(
          scheme = "https",
          authority = "doesnotexist.example.com",
          path = "/test"
        )
        .build()

    val engine =
      EngineBuilder(Standard())
        .addPlatformFilter(
          name = FILTER_NAME,
          factory = { ErrorValidationFilter(filterReceivedError, filterNotCancelled) }
        )
        .addNativeFilter(
          "envoy.filters.http.platform_bridge",
          "{'@type': $PBF_TYPE, platform_filter_name: $FILTER_NAME}"
        )
        .addNativeFilter("envoy.filters.http.local_error", "{'@type': $LOCAL_ERROR_FILTER_TYPE}")
        .build()

    var errorCode: Int? = null

    engine
      .streamClient()
      .newStreamPrototype()
      .setOnResponseHeaders { _, _, _ -> fail("Headers received instead of expected error") }
      .setOnResponseData { _, _, _ -> fail("Data received instead of expected error") }
      // The unmatched expectation will cause a local reply which gets translated in Envoy Mobile to
      // an error.
      .setOnError { error, _ ->
        errorCode = error.errorCode
        callbackReceivedError.countDown()
      }
      .setOnCancel { _ -> fail("Unexpected call to onCancel response callback") }
      .start()
      .sendHeaders(requestHeader, true)

    filterReceivedError.await(10, TimeUnit.SECONDS)
    filterNotCancelled.await(1, TimeUnit.SECONDS)
    callbackReceivedError.await(10, TimeUnit.SECONDS)
    engine.terminate()

    assertThat(filterReceivedError.count)
      .withFailMessage("Missing call to onError filter callback")
      .isEqualTo(0)

    assertThat(filterNotCancelled.count)
      .withFailMessage("Unexpected call to onCancel filter callback")
      .isEqualTo(1)

    assertThat(callbackReceivedError.count)
      .withFailMessage("Missing call to onError response callback")
      .isEqualTo(0)

    assertThat(errorCode).isEqualTo(2) // 503/Connection Failure
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.EnvoyError
import io.envoyproxy.envoymobile.FilterDataStatus
import io.envoyproxy.envoymobile.FilterHeadersStatus
import io.envoyproxy.envoymobile.FilterTrailersStatus
import io.envoyproxy.envoymobile.FinalStreamIntel
import io.envoyproxy.envoymobile.GRPCClient
import io.envoyproxy.envoymobile.GRPCRequestHeadersBuilder
import io.envoyproxy.envoymobile.ResponseFilter
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.ResponseTrailers
import io.envoyproxy.envoymobile.Standard
import io.envoyproxy.envoymobile.StreamIntel
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.nio.ByteBuffer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

private const val FILTER_NAME = "cancel_validation_filter"
private const val PBF_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.platform_bridge.PlatformBridge"
private const val LOCAL_ERROR_FILTER_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.local_error.LocalError"

class CancelGRPCStreamTest {

  init {
    JniLibrary.loadTestLibrary()
  }

  private val filterExpectation = CountDownLatch(1)
  private val onCancelCallbackExpectation = CountDownLatch(1)

  class CancelValidationFilter(private val latch: CountDownLatch) : ResponseFilter {
    override fun onResponseHeaders(
      headers: ResponseHeaders,
      endStream: Boolean,
      streamIntel: StreamIntel
    ): FilterHeadersStatus<ResponseHeaders> {
      return FilterHeadersStatus.Continue(headers)
    }

    override fun onResponseData(
      body: ByteBuffer,
      endStream: Boolean,
      streamIntel: StreamIntel
    ): FilterDataStatus<ResponseHeaders> {
      return FilterDataStatus.Continue(body)
    }

    override fun onResponseTrailers(
      trailers: ResponseTrailers,
      streamIntel: StreamIntel
    ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
      return FilterTrailersStatus.Continue(trailers)
    }

    override fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel) {}

    override fun onComplete(finalStreamIntel: FinalStreamIntel) {}

    override fun onCancel(finalStreamIntel: FinalStreamIntel) {
      latch.countDown()
    }
  }

  @Test
  fun `cancel grpc stream calls onCancel callback`() {
    val engine =
      EngineBuilder(Standard())
        .addPlatformFilter(
          name = FILTER_NAME,
          factory = { CancelValidationFilter(filterExpectation) }
        )
        .addNativeFilter(
          "envoy.filters.http.platform_bridge",
          "{'@type': $PBF_TYPE, platform_filter_name: $FILTER_NAME}"
        )
        .addNativeFilter("envoy.filters.http.local_error", "{'@type': $LOCAL_ERROR_FILTER_TYPE}")
        .build()

    val client = GRPCClient(engine.streamClient())

    val requestHeaders =
      GRPCRequestHeadersBuilder(scheme = "https", authority = "example.com", path = "/test").build()

    client
      .newGRPCStreamPrototype()
      .setOnCancel { _ -> onCancelCallbackExpectation.countDown() }
      .start(Executors.newSingleThreadExecutor())
      .sendHeaders(requestHeaders, false)
      .cancel()

    filterExpectation.await(10, TimeUnit.SECONDS)
    onCancelCallbackExpectation.await(10, TimeUnit.SECONDS)

    engine.terminate()

    assertThat(filterExpectation.count).isEqualTo(0)
    assertThat(onCancelCallbackExpectation.count).isEqualTo(0)
  }
}
package test.kotlin.integration

import android.content.Context
import androidx.test.core.app.ApplicationProvider
import io.envoyproxy.envoymobile.AndroidEngineBuilder
import io.envoyproxy.envoymobile.Engine
import io.envoyproxy.envoymobile.LogLevel
import io.envoyproxy.envoymobile.XdsBuilder
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary
import io.envoyproxy.envoymobile.engine.JniLibrary
import io.envoyproxy.envoymobile.engine.testing.TestJni
import java.io.File
import java.util.concurrent.CountDownLatch
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class XdsTest {
  private val appContext: Context = ApplicationProvider.getApplicationContext()
  private lateinit var engine: Engine

  init {
    AndroidJniLibrary.loadTestLibrary()
    JniLibrary.load()
  }

  @Before
  fun setUp() {
    val upstreamCert: String =
      File("../envoy/test/config/integration/certs/upstreamcacert.pem").readText()
    TestJni.initXdsTestServer()
    val latch = CountDownLatch(1)
    engine =
      AndroidEngineBuilder(appContext)
        .addLogLevel(LogLevel.DEBUG)
        .setOnEngineRunning { latch.countDown() }
        .setXds(
          XdsBuilder(
              TestJni.getXdsTestServerHost(),
              TestJni.getXdsTestServerPort(),
            )
            .setSslRootCerts(upstreamCert)
            .addClusterDiscoveryService()
        )
        .build()
    latch.await()
    TestJni.startXdsTestServer()
  }

  @After
  fun tearDown() {
    engine.terminate()
    TestJni.shutdownXdsTestServer()
  }

  @Test
  fun `test xDS with CDS`() {
    // There are 2 initial clusters: base and base_clear.
    engine.waitForStatGe("cluster_manager.cluster_added", 2)
    val cdsResponse =
      """
      version_info: v1
      resources:
      - "@type": type.googleapis.com/envoy.config.cluster.v3.Cluster
        name: my_cluster
        type: STATIC
        connect_timeout: 5s
        typed_extension_protocol_options:
          envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
            "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
            explicit_http_config:
              http2_protocol_options:
                {}
      type_url: type.googleapis.com/envoy.config.cluster.v3.Cluster
      nonce: nonce1
    """
        .trimIndent()
    TestJni.sendDiscoveryResponse(cdsResponse)
    // There are now 3 clusters: base, base_cluster, and my_cluster.
    engine.waitForStatGe("cluster_manager.cluster_added", 3)
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.Standard
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.fail
import org.junit.Test

private const val TEST_RESPONSE_FILTER_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.test_remote_response.TestRemoteResponse"

// This test doesn't do what it advertises (https://github.com/envoyproxy/envoy/issues/25180)
class ResetConnectivityStateTest {

  init {
    JniLibrary.loadTestLibrary()
  }

  @Test
  fun `successful request after connection drain`() {
    val headersExpectation = CountDownLatch(2)

    val engine =
      EngineBuilder(Standard())
        .addNativeFilter("test_remote_response", "{'@type': $TEST_RESPONSE_FILTER_TYPE}")
        .build()
    val client = engine.streamClient()

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "example.com",
          path = "/test"
        )
        .build()

    var resultHeaders1: ResponseHeaders? = null
    var resultEndStream1: Boolean? = null
    client
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, endStream, _ ->
        resultHeaders1 = responseHeaders
        resultEndStream1 = endStream
        headersExpectation.countDown()
      }
      .setOnResponseData { _, endStream, _ -> resultEndStream1 = endStream }
      .setOnError { _, _ -> fail("Unexpected error") }
      .start()
      .sendHeaders(requestHeaders, true)

    headersExpectation.await(10, TimeUnit.SECONDS)

    engine.resetConnectivityState()

    var resultHeaders2: ResponseHeaders? = null
    var resultEndStream2: Boolean? = null
    client
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, endStream, _ ->
        resultHeaders2 = responseHeaders
        resultEndStream2 = endStream
        headersExpectation.countDown()
      }
      .setOnResponseData { _, endStream, _ -> resultEndStream2 = endStream }
      .setOnError { _, _ -> fail("Unexpected error") }
      .start()
      .sendHeaders(requestHeaders, true)

    headersExpectation.await(10, TimeUnit.SECONDS)

    engine.terminate()

    assertThat(headersExpectation.count).isEqualTo(0)
    assertThat(resultHeaders1!!.httpStatus).isEqualTo(200)
    assertThat(resultEndStream1).isTrue()
    assertThat(resultHeaders2!!.httpStatus).isEqualTo(200)
    assertThat(resultEndStream2).isTrue()
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.EnvoyError
import io.envoyproxy.envoymobile.FilterDataStatus
import io.envoyproxy.envoymobile.FilterHeadersStatus
import io.envoyproxy.envoymobile.FilterTrailersStatus
import io.envoyproxy.envoymobile.FinalStreamIntel
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.ResponseFilter
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.ResponseTrailers
import io.envoyproxy.envoymobile.Standard
import io.envoyproxy.envoymobile.StreamIntel
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.nio.ByteBuffer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.fail
import org.junit.Test

private const val TEST_RESPONSE_FILTER_TYPE =
  "type.googleapis.com/" +
    "envoymobile.extensions.filters.http.test_remote_response.TestRemoteResponse"

class StreamIdleTimeoutTest {

  init {
    JniLibrary.loadTestLibrary()
  }

  private val filterExpectation = CountDownLatch(1)
  private val callbackExpectation = CountDownLatch(1)

  class IdleTimeoutValidationFilter(private val latch: CountDownLatch) : ResponseFilter {
    override fun onResponseHeaders(
      headers: ResponseHeaders,
      endStream: Boolean,
      streamIntel: StreamIntel
    ): FilterHeadersStatus<ResponseHeaders> {
      return FilterHeadersStatus.StopIteration()
    }

    override fun onResponseData(
      body: ByteBuffer,
      endStream: Boolean,
      streamIntel: StreamIntel
    ): FilterDataStatus<ResponseHeaders> {
      return FilterDataStatus.StopIterationNoBuffer()
    }

    override fun onResponseTrailers(
      trailers: ResponseTrailers,
      streamIntel: StreamIntel
    ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
      return FilterTrailersStatus.StopIteration()
    }

    override fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel) {
      assertThat(error.errorCode).isEqualTo(4)
      latch.countDown()
    }

    override fun onComplete(finalStreamIntel: FinalStreamIntel) {}

    override fun onCancel(finalStreamIntel: FinalStreamIntel) {
      fail<StreamIdleTimeoutTest>("Unexpected call to onCancel filter callback")
    }
  }

  @Test
  fun `stream idle timeout triggers onError callbacks`() {
    val engine =
      EngineBuilder(Standard())
        .addPlatformFilter(
          name = "idle_timeout_validation_filter",
          factory = { IdleTimeoutValidationFilter(filterExpectation) }
        )
        .addNativeFilter("test_remote_response", "{'@type': $TEST_RESPONSE_FILTER_TYPE}")
        .addStreamIdleTimeoutSeconds(1)
        .build()

    val client = engine.streamClient()

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "example.com",
          path = "/test"
        )
        .build()

    client
      .newStreamPrototype()
      .setOnError { error, _ ->
        assertThat(error.errorCode).isEqualTo(4)
        callbackExpectation.countDown()
      }
      .start(Executors.newSingleThreadExecutor())
      .sendHeaders(requestHeaders, false)

    filterExpectation.await(10, TimeUnit.SECONDS)
    callbackExpectation.await(10, TimeUnit.SECONDS)

    engine.terminate()

    assertThat(filterExpectation.count).isEqualTo(0)
    assertThat(callbackExpectation.count).isEqualTo(0)
  }
}
package test.kotlin.integration.proxying

import android.content.Context
import android.content.Intent
import android.net.ConnectivityManager
import android.net.Proxy
import android.net.ProxyInfo
import androidx.test.core.app.ApplicationProvider
import io.envoyproxy.envoymobile.AndroidEngineBuilder
import io.envoyproxy.envoymobile.LogLevel
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.engine.JniLibrary
import io.envoyproxy.envoymobile.engine.testing.TestJni
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito
import org.robolectric.RobolectricTestRunner

//                                                ┌──────────────────┐
//                                                │   Envoy Proxy    │
//                                                │ ┌──────────────┐ │
// ┌─────────────────────────┐                  ┌─┼─►listener_proxy│ │
// │https://api.lyft.com/ping│  ┌──────────────┬┘ │ └──────┬───────┘ │ ┌────────────┐
// │         Request         ├──►Android Engine│  │        │         │ │api.lyft.com│
// └─────────────────────────┘  └──────────────┘  │ ┌──────▼──────┐  │ └──────▲─────┘
//                                                │ │cluster_proxy│  │        │
//                                                │ └─────────────┴──┼────────┘
//                                                │                  │
//                                                └──────────────────┘
@RunWith(RobolectricTestRunner::class)
class PerformHTTPSRequestUsingProxy {
  init {
    JniLibrary.loadTestLibrary()
    JniLibrary.load()
  }

  @Test
  fun `performs an HTTPs request through a proxy`() {
    TestJni.startHttpsProxyTestServer()
    val port = TestJni.getServerPort()

    val context = Mockito.spy(ApplicationProvider.getApplicationContext<Context>())
    val connectivityManager: ConnectivityManager = Mockito.mock(ConnectivityManager::class.java)
    Mockito.doReturn(connectivityManager)
      .`when`(context)
      .getSystemService(Context.CONNECTIVITY_SERVICE)
    Mockito.`when`(connectivityManager.getDefaultProxy())
      .thenReturn(ProxyInfo.buildDirectProxy("127.0.0.1", port))

    val onEngineRunningLatch = CountDownLatch(1)
    val onRespondeHeadersLatch = CountDownLatch(1)

    context.sendStickyBroadcast(Intent(Proxy.PROXY_CHANGE_ACTION))

    val builder = AndroidEngineBuilder(context)
    val engine =
      builder
        .addLogLevel(LogLevel.DEBUG)
        .enableProxying(true)
        .setOnEngineRunning { onEngineRunningLatch.countDown() }
        .build()

    onEngineRunningLatch.await(10, TimeUnit.SECONDS)
    assertThat(onEngineRunningLatch.count).isEqualTo(0)

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "api.lyft.com",
          path = "/ping"
        )
        .build()

    engine
      .streamClient()
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, _, _ ->
        val status = responseHeaders.httpStatus ?: 0L
        assertThat(status).isEqualTo(200)
        assertThat(responseHeaders.value("x-response-header-that-should-be-stripped")).isNull()
        onRespondeHeadersLatch.countDown()
      }
      .start(Executors.newSingleThreadExecutor())
      .sendHeaders(requestHeaders, true)

    onRespondeHeadersLatch.await(15, TimeUnit.SECONDS)
    assertThat(onRespondeHeadersLatch.count).isEqualTo(0)

    engine.terminate()
    TestJni.shutdownTestServer()
  }
}
package test.kotlin.integration.proxying

import android.content.Context
import android.net.ConnectivityManager
import android.net.ProxyInfo
import androidx.test.core.app.ApplicationProvider
import io.envoyproxy.envoymobile.AndroidEngineBuilder
import io.envoyproxy.envoymobile.LogLevel
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary
import io.envoyproxy.envoymobile.engine.JniLibrary
import io.envoyproxy.envoymobile.engine.testing.TestJni
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito
import org.robolectric.RobolectricTestRunner

//                                               ┌──────────────────┐
//                                               │   Envoy Proxy    │
//                                               │ ┌──────────────┐ │
// ┌────────────────────────┐                  ┌─┼─►listener_proxy│ │
// │http://api.lyft.com/ping│  ┌──────────────┬┘ │ └──────┬───────┘ │ ┌────────────┐
// │        Request         ├──►Android Engine│  │        │         │ │api.lyft.com│
// └────────────────────────┘  └──────────────┘  │ ┌──────▼──────┐  │ └──────▲─────┘
//                                               │ │cluster_proxy│  │        │
//                                               │ └─────────────┴──┼────────┘
//                                               │                  │
//                                               └──────────────────┘
@RunWith(RobolectricTestRunner::class)
class PerformHTTPRequestUsingProxy {
  init {
    AndroidJniLibrary.loadTestLibrary()
    JniLibrary.loadTestLibrary()
    JniLibrary.load()
  }

  @Test
  fun `performs an HTTP request through a proxy`() {
    TestJni.startHttpProxyTestServer()
    val port = TestJni.getServerPort()

    val context = Mockito.spy(ApplicationProvider.getApplicationContext<Context>())
    val connectivityManager: ConnectivityManager = Mockito.mock(ConnectivityManager::class.java)
    Mockito.doReturn(connectivityManager)
      .`when`(context)
      .getSystemService(Context.CONNECTIVITY_SERVICE)
    Mockito.`when`(connectivityManager.getDefaultProxy())
      .thenReturn(ProxyInfo.buildDirectProxy("127.0.0.1", port))

    val onEngineRunningLatch = CountDownLatch(1)
    val onRespondeHeadersLatch = CountDownLatch(1)

    val builder = AndroidEngineBuilder(context)
    val engine =
      builder
        .addLogLevel(LogLevel.DEBUG)
        .enableProxying(true)
        .setOnEngineRunning { onEngineRunningLatch.countDown() }
        .build()

    onEngineRunningLatch.await(10, TimeUnit.SECONDS)
    assertThat(onEngineRunningLatch.count).isEqualTo(0)

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "http",
          authority = "api.lyft.com",
          path = "/ping"
        )
        .build()

    engine
      .streamClient()
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, _, _ ->
        val status = responseHeaders.httpStatus ?: 0L
        assertThat(status).isEqualTo(301)
        assertThat(responseHeaders.value("x-proxy-response")).isEqualTo(listOf("true"))
        onRespondeHeadersLatch.countDown()
      }
      .start(Executors.newSingleThreadExecutor())
      .sendHeaders(requestHeaders, true)

    onRespondeHeadersLatch.await(15, TimeUnit.SECONDS)
    assertThat(onRespondeHeadersLatch.count).isEqualTo(0)

    engine.terminate()
    TestJni.shutdownTestServer()
  }
}
package test.kotlin.integration.proxying

import android.content.Context
import android.content.Intent
import android.net.ConnectivityManager
import android.net.Proxy
import android.net.ProxyInfo
import androidx.test.core.app.ApplicationProvider
import io.envoyproxy.envoymobile.AndroidEngineBuilder
import io.envoyproxy.envoymobile.LogLevel
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.engine.JniLibrary
import io.envoyproxy.envoymobile.engine.testing.TestJni
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito
import org.robolectric.RobolectricTestRunner

//                                                ┌──────────────────┐
//                                                │   Envoy Proxy    │
//                                                │ ┌──────────────┐ │
// ┌─────────────────────────┐                  ┌─┼─►listener_proxy│ │
// │https://api.lyft.com/ping│  ┌──────────────┬┘ │ └──────┬───────┘ │ ┌────────────┐
// │         Request         ├──►Android Engine│  │        │         │ │api.lyft.com│
// └─────────────────────────┘  └──────────────┘  │ ┌──────▼──────┐  │ └──────▲─────┘
//                                                │ │cluster_proxy│  │        │
//                                                │ └─────────────┴──┼────────┘
//                                                │                  │
//                                                └──────────────────┘
@RunWith(RobolectricTestRunner::class)
class PerformHTTPSRequestUsingAsyncProxyTest {
  init {
    JniLibrary.loadTestLibrary()
    JniLibrary.load()
  }

  @Test
  fun `performs an HTTPs request through a proxy using async DNS resolution`() {
    TestJni.startHttpsProxyTestServer()
    val port = TestJni.getServerPort()

    val context = Mockito.spy(ApplicationProvider.getApplicationContext<Context>())
    val connectivityManager: ConnectivityManager = Mockito.mock(ConnectivityManager::class.java)
    Mockito.doReturn(connectivityManager)
      .`when`(context)
      .getSystemService(Context.CONNECTIVITY_SERVICE)
    Mockito.`when`(connectivityManager.getDefaultProxy())
      .thenReturn(ProxyInfo.buildDirectProxy("localhost", port))

    val onEngineRunningLatch = CountDownLatch(1)
    val onRespondeHeadersLatch = CountDownLatch(1)

    context.sendStickyBroadcast(Intent(Proxy.PROXY_CHANGE_ACTION))

    val builder = AndroidEngineBuilder(context)
    val engine =
      builder
        .addLogLevel(LogLevel.DEBUG)
        .enableProxying(true)
        .setOnEngineRunning { onEngineRunningLatch.countDown() }
        .build()

    onEngineRunningLatch.await(10, TimeUnit.SECONDS)
    assertThat(onEngineRunningLatch.count).isEqualTo(0)

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "api.lyft.com",
          path = "/ping"
        )
        .build()

    engine
      .streamClient()
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, _, _ ->
        val status = responseHeaders.httpStatus ?: 0L
        assertThat(status).isEqualTo(200)
        assertThat(responseHeaders.value("x-response-header-that-should-be-stripped")).isNull()
        onRespondeHeadersLatch.countDown()
      }
      .start(Executors.newSingleThreadExecutor())
      .sendHeaders(requestHeaders, true)

    onRespondeHeadersLatch.await(15, TimeUnit.SECONDS)
    assertThat(onRespondeHeadersLatch.count).isEqualTo(0)

    engine.terminate()
    TestJni.shutdownTestServer()
  }
}
package test.kotlin.integration.proxying

import android.content.Context
import android.content.Intent
import android.net.ConnectivityManager
import android.net.Proxy
import android.net.ProxyInfo
import androidx.test.core.app.ApplicationProvider
import io.envoyproxy.envoymobile.AndroidEngineBuilder
import io.envoyproxy.envoymobile.LogLevel
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.engine.JniLibrary
import io.envoyproxy.envoymobile.engine.testing.TestJni
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito
import org.robolectric.RobolectricTestRunner

//                                                ┌──────────────────┐
//                                                │   Envoy Proxy    │
//                                                │ ┌──────────────┐ │
// ┌─────────────────────────┐                  ┌─┼─►listener_proxy│ │
// │https://api.lyft.com/ping│  ┌──────────────┬┘ │ └──────┬───────┘ │ ┌────────────┐
// │         Request         ├──►Android Engine│  │        │         │ │api.lyft.com│
// └─────────────────────────┘  └──────────────┘  │ ┌──────▼──────┐  │ └──────▲─────┘
//                                                │ │cluster_proxy│  │        │
//                                                │ └─────────────┴──┼────────┘
//                                                │                  │
//                                                └──────────────────┘
@RunWith(RobolectricTestRunner::class)
class PerformHTTPSRequestBadHostname {
  init {
    JniLibrary.loadTestLibrary()
    JniLibrary.load()
  }

  @Test
  fun `attempts an HTTPs request through a proxy using an async DNS resolution that fails`() {
    TestJni.startHttpsProxyTestServer()
    val port = TestJni.getServerPort()

    val context = Mockito.spy(ApplicationProvider.getApplicationContext<Context>())
    val connectivityManager: ConnectivityManager = Mockito.mock(ConnectivityManager::class.java)
    Mockito.doReturn(connectivityManager)
      .`when`(context)
      .getSystemService(Context.CONNECTIVITY_SERVICE)
    Mockito.`when`(connectivityManager.getDefaultProxy())
      .thenReturn(ProxyInfo.buildDirectProxy("loopback", port))

    val onEngineRunningLatch = CountDownLatch(1)
    val onErrorLatch = CountDownLatch(1)

    context.sendStickyBroadcast(Intent(Proxy.PROXY_CHANGE_ACTION))

    val builder = AndroidEngineBuilder(context)
    val engine =
      builder
        .addLogLevel(LogLevel.DEBUG)
        .enableProxying(true)
        .setOnEngineRunning { onEngineRunningLatch.countDown() }
        .build()

    onEngineRunningLatch.await(10, TimeUnit.SECONDS)
    assertThat(onEngineRunningLatch.count).isEqualTo(0)

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "api.lyft.com",
          path = "/ping"
        )
        .build()

    engine
      .streamClient()
      .newStreamPrototype()
      .setOnError { _, _ -> onErrorLatch.countDown() }
      .start(Executors.newSingleThreadExecutor())
      .sendHeaders(requestHeaders, true)

    onErrorLatch.await(15, TimeUnit.SECONDS)
    assertThat(onErrorLatch.count).isEqualTo(0)

    engine.terminate()
    TestJni.shutdownTestServer()
  }
}
package test.kotlin.integration.proxying

import android.content.Context
import android.content.Intent
import android.net.ConnectivityManager
import android.net.Proxy
import android.net.ProxyInfo
import androidx.test.core.app.ApplicationProvider
import io.envoyproxy.envoymobile.AndroidEngineBuilder
import io.envoyproxy.envoymobile.LogLevel
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.engine.JniLibrary
import io.envoyproxy.envoymobile.engine.testing.TestJni
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito
import org.robolectric.RobolectricTestRunner

//                                               ┌──────────────────┐
//                                               │   Envoy Proxy    │
//                                               │ ┌──────────────┐ │
// ┌────────────────────────┐                  ┌─┼─►listener_proxy│ │
// │http://api.lyft.com/ping│  ┌──────────────┬┘ │ └──────┬───────┘ │ ┌────────────┐
// │        Request         ├──►Android Engine│  │        │         │ │api.lyft.com│
// └────────────────────────┘  └──────────────┘  │ ┌──────▼──────┐  │ └──────▲─────┘
//                                               │ │cluster_proxy│  │        │
//                                               │ └─────────────┴──┼────────┘
//                                               │                  │
//                                               └──────────────────┘
@RunWith(RobolectricTestRunner::class)
class PerformHTTPRequestUsingProxy {
  init {
    JniLibrary.loadTestLibrary()
    JniLibrary.load()
  }

  @Test
  fun `performs an HTTP request through a proxy`() {
    TestJni.startHttpProxyTestServer()
    val port = TestJni.getServerPort()

    val context = Mockito.spy(ApplicationProvider.getApplicationContext<Context>())
    val connectivityManager: ConnectivityManager = Mockito.mock(ConnectivityManager::class.java)
    Mockito.doReturn(connectivityManager)
      .`when`(context)
      .getSystemService(Context.CONNECTIVITY_SERVICE)
    Mockito.`when`(connectivityManager.getDefaultProxy())
      .thenReturn(ProxyInfo.buildDirectProxy("127.0.0.1", port))

    val onEngineRunningLatch = CountDownLatch(1)
    val onRespondeHeadersLatch = CountDownLatch(1)

    context.sendStickyBroadcast(Intent(Proxy.PROXY_CHANGE_ACTION))

    val builder = AndroidEngineBuilder(context)
    val engine =
      builder
        .addLogLevel(LogLevel.DEBUG)
        .enableProxying(true)
        .setOnEngineRunning { onEngineRunningLatch.countDown() }
        .build()

    onEngineRunningLatch.await(10, TimeUnit.SECONDS)
    assertThat(onEngineRunningLatch.count).isEqualTo(0)

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "http",
          authority = "api.lyft.com",
          path = "/ping"
        )
        .build()

    engine
      .streamClient()
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, _, _ ->
        val status = responseHeaders.httpStatus ?: 0L
        assertThat(status).isEqualTo(301)
        assertThat(responseHeaders.value("x-proxy-response")).isEqualTo(listOf("true"))
        onRespondeHeadersLatch.countDown()
      }
      .start(Executors.newSingleThreadExecutor())
      .sendHeaders(requestHeaders, true)

    onRespondeHeadersLatch.await(15, TimeUnit.SECONDS)
    assertThat(onRespondeHeadersLatch.count).isEqualTo(0)

    engine.terminate()
    TestJni.shutdownTestServer()
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:kotlin_test.bzl", "envoy_mobile_android_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_android_test(
    name = "proxy_info_intent_perform_http_request_using_proxy_test",
    srcs = [
        "ProxyInfoIntentPerformHTTPRequestUsingProxyTest.kt",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
        "dockerNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_and_listener_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_and_listener_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_and_listener_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/io/envoyproxy/envoymobile/engine/testing",
    ],
)

envoy_mobile_android_test(
    name = "proxy_info_intent_perform_https_request_using_proxy_test",
    srcs = [
        "ProxyInfoIntentPerformHTTPSRequestUsingProxyTest.kt",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
        "dockerNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_and_listener_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_and_listener_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_and_listener_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/io/envoyproxy/envoymobile/engine/testing",
    ],
)

envoy_mobile_android_test(
    name = "proxy_info_intent_perform_https_request_using_async_proxy_test",
    srcs = [
        "ProxyInfoIntentPerformHTTPSRequestUsingAsyncProxyTest.kt",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
        "dockerNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_and_listener_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_and_listener_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_and_listener_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/io/envoyproxy/envoymobile/engine/testing",
    ],
)

envoy_mobile_android_test(
    name = "proxy_info_intent_perform_https_request_bad_hostname",
    srcs = [
        "ProxyInfoIntentPerformHTTPSRequestBadHostnameTest.kt",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
        "dockerNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_and_listener_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_and_listener_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_and_listener_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/io/envoyproxy/envoymobile/engine/testing",
    ],
)

envoy_mobile_android_test(
    name = "proxy_poll_perform_http_request_using_proxy",
    srcs = [
        "ProxyPollPerformHTTPRequestUsingProxyTest.kt",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
        "dockerNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_and_listener_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_and_listener_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_and_listener_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/io/envoyproxy/envoymobile/engine/testing",
    ],
)

envoy_mobile_android_test(
    name = "proxy_poll_perform_http_request_without_using_pac_proxy",
    srcs = [
        "ProxyPollPerformHTTPRequestWithoutUsingPACProxyTest.kt",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
        "dockerNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_and_listener_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_and_listener_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_and_listener_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/io/envoyproxy/envoymobile/engine/testing",
    ],
)
package test.kotlin.integration.proxying

import android.content.Context
import android.net.ConnectivityManager
import android.net.ProxyInfo
import android.net.Uri
import androidx.test.core.app.ApplicationProvider
import io.envoyproxy.envoymobile.AndroidEngineBuilder
import io.envoyproxy.envoymobile.LogLevel
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.engine.JniLibrary
import io.envoyproxy.envoymobile.engine.testing.TestJni
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito
import org.robolectric.RobolectricTestRunner

//                                                ┌──────────────────┐
//                                                │   Envoy Proxy    │
//                                                │ ┌──────────────┐ │
// ┌─────────────────────────┐                    │ │listener_proxy│ │
// │https://api.lyft.com/ping│  ┌──────────────┐  │ └──────┬───────┘ │ ┌────────────┐
// │       HTTP Request      ├──►Android Engine│  │        │         │ │api.lyft.com│
// └─────────────────────────┘  └───────┬──────┘  │ ┌──────▼──────┐  │ └──────▲─────┘
//                                      │         │ │cluster_proxy│  │        │
//                                      │         │ └─────────────┘  │        │
//                                      │         │                  │        │
//                                      │         └──────────────────┘        │
//                                      │                                     │
//                                      └─────────────────────────────────────┘
@RunWith(RobolectricTestRunner::class)
class PerformHTTPRequestUsingProxy {
  init {
    JniLibrary.loadTestLibrary()
    JniLibrary.load()
  }

  @Test
  fun `performs an HTTP request through a proxy`() {
    TestJni.startHttpProxyTestServer()

    val context = Mockito.spy(ApplicationProvider.getApplicationContext<Context>())
    val connectivityManager: ConnectivityManager = Mockito.mock(ConnectivityManager::class.java)
    Mockito.doReturn(connectivityManager)
      .`when`(context)
      .getSystemService(Context.CONNECTIVITY_SERVICE)
    Mockito.`when`(connectivityManager.getDefaultProxy())
      .thenReturn(ProxyInfo.buildPacProxy(Uri.parse("https://example.com")))

    val onEngineRunningLatch = CountDownLatch(1)
    val onRespondeHeadersLatch = CountDownLatch(1)

    val builder = AndroidEngineBuilder(context)
    val engine =
      builder
        .addLogLevel(LogLevel.DEBUG)
        .enableProxying(true)
        .setOnEngineRunning { onEngineRunningLatch.countDown() }
        .build()

    onEngineRunningLatch.await(10, TimeUnit.SECONDS)
    assertThat(onEngineRunningLatch.count).isEqualTo(0)

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "http",
          authority = "api.lyft.com",
          path = "/ping"
        )
        .build()

    engine
      .streamClient()
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, _, _ ->
        val status = responseHeaders.httpStatus ?: 0L
        assertThat(status).isEqualTo(301)
        assertThat(responseHeaders.value("x-proxy-response")).isNull()
        onRespondeHeadersLatch.countDown()
      }
      .start(Executors.newSingleThreadExecutor())
      .sendHeaders(requestHeaders, true)

    onRespondeHeadersLatch.await(15, TimeUnit.SECONDS)
    assertThat(onRespondeHeadersLatch.count).isEqualTo(0)

    engine.terminate()
    TestJni.shutdownTestServer()
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.Standard
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.nio.ByteBuffer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.fail
import org.junit.Test

private const val TEST_RESPONSE_FILTER_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.test_remote_response.TestRemoteResponse"

class ReceiveDataTest {

  init {
    JniLibrary.loadTestLibrary()
  }

  @Test
  fun `response headers and response data call onResponseHeaders and onResponseData`() {

    val engine =
      EngineBuilder(Standard())
        .addNativeFilter("test_remote_response", "{'@type': $TEST_RESPONSE_FILTER_TYPE}")
        .build()
    val client = engine.streamClient()

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "example.com",
          path = "/test"
        )
        .build()

    val headersExpectation = CountDownLatch(1)
    val dataExpectation = CountDownLatch(1)

    var status: Int? = null
    var body: ByteBuffer? = null
    client
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, _, _ ->
        status = responseHeaders.httpStatus
        headersExpectation.countDown()
      }
      .setOnResponseData { data, _, _ ->
        body = data
        dataExpectation.countDown()
      }
      .setOnError { _, _ -> fail("Unexpected error") }
      .start()
      .sendHeaders(requestHeaders, true)

    headersExpectation.await(10, TimeUnit.SECONDS)
    dataExpectation.await(10, TimeUnit.SECONDS)
    engine.terminate()

    assertThat(headersExpectation.count).isEqualTo(0)
    assertThat(dataExpectation.count).isEqualTo(0)

    assertThat(status).isEqualTo(200)
    assertThat(body!!.array().toString(Charsets.UTF_8)).isEqualTo("data")
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.Engine
import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.LogLevel
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.Standard
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class SetLoggerTest {

  init {
    JniLibrary.loadTestLibrary()
  }

  @Test
  fun `set logger`() {
    val countDownLatch = CountDownLatch(1)
    val logEventLatch = CountDownLatch(1)
    val engine =
      EngineBuilder(Standard())
        .addLogLevel(LogLevel.DEBUG)
        .addNativeFilter(
          "test_logger",
          "{\"@type\":\"type.googleapis.com/envoymobile.extensions.filters.http.test_logger.TestLogger\"}"
        )
        .setLogger { msg ->
          if (msg.contains("starting main dispatch loop")) {
            countDownLatch.countDown()
          }
        }
        .setEventTracker { event ->
          if (event["log_name"] == "event_name") {
            logEventLatch.countDown()
          }
        }
        .build()

    countDownLatch.await(30, TimeUnit.SECONDS)

    sendRequest(engine)

    logEventLatch.await(30, TimeUnit.SECONDS)

    engine.terminate()
    assertThat(countDownLatch.count).isEqualTo(0)
    assertThat(logEventLatch.count).isEqualTo(0)
  }

  @Test
  fun `engine should continue to run if no logger is set`() {
    val countDownLatch = CountDownLatch(1)
    val logEventLatch = CountDownLatch(1)
    val engine =
      EngineBuilder(Standard())
        .setEventTracker { event ->
          if (event["log_name"] == "event_name") {
            logEventLatch.countDown()
          }
        }
        .addLogLevel(LogLevel.DEBUG)
        .addNativeFilter(
          "test_logger",
          "{\"@type\":\"type.googleapis.com/envoymobile.extensions.filters.http.test_logger.TestLogger\"}"
        )
        .setOnEngineRunning { countDownLatch.countDown() }
        .build()

    countDownLatch.await(30, TimeUnit.SECONDS)

    sendRequest(engine)
    logEventLatch.await(30, TimeUnit.SECONDS)

    engine.terminate()
    assertThat(countDownLatch.count).isEqualTo(0)
    assertThat(logEventLatch.count).isEqualTo(0)
  }

  fun sendRequest(engine: Engine) {
    val client = engine.streamClient()

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "example.com",
          path = "/test"
        )
        .build()

    client.newStreamPrototype().start().sendHeaders(requestHeaders, true)
  }
}
package test.kotlin.integration

import android.content.Context
import androidx.test.core.app.ApplicationProvider
import io.envoyproxy.envoymobile.AndroidEngineBuilder
import io.envoyproxy.envoymobile.EnvoyError
import io.envoyproxy.envoymobile.FilterDataStatus
import io.envoyproxy.envoymobile.FilterHeadersStatus
import io.envoyproxy.envoymobile.FilterTrailersStatus
import io.envoyproxy.envoymobile.FinalStreamIntel
import io.envoyproxy.envoymobile.LogLevel
import io.envoyproxy.envoymobile.RequestFilter
import io.envoyproxy.envoymobile.RequestHeaders
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.RequestTrailers
import io.envoyproxy.envoymobile.ResponseFilter
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.ResponseTrailers
import io.envoyproxy.envoymobile.StreamIntel
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.nio.ByteBuffer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

class ThrowingFilter : RequestFilter, ResponseFilter {
  override fun onRequestHeaders(
    headers: RequestHeaders,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterHeadersStatus<RequestHeaders> {
    throw Exception("Simulated onRequestHeaders exception")
  }

  override fun onRequestData(
    body: ByteBuffer,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterDataStatus<RequestHeaders> {
    return FilterDataStatus.Continue(body)
  }

  override fun onRequestTrailers(
    trailers: RequestTrailers,
    streamIntel: StreamIntel
  ): FilterTrailersStatus<RequestHeaders, RequestTrailers> {
    return FilterTrailersStatus.Continue(trailers)
  }

  override fun onResponseHeaders(
    headers: ResponseHeaders,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterHeadersStatus<ResponseHeaders> {
    throw Exception("Simulated onResponseHeaders exception")
  }

  override fun onResponseData(
    body: ByteBuffer,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterDataStatus<ResponseHeaders> {
    return FilterDataStatus.Continue(body)
  }

  override fun onResponseTrailers(
    trailers: ResponseTrailers,
    streamIntel: StreamIntel
  ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
    return FilterTrailersStatus.Continue(trailers)
  }

  override fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel) {}

  override fun onCancel(finalStreamIntel: FinalStreamIntel) {}

  override fun onComplete(finalStreamIntel: FinalStreamIntel) {}
}

@RunWith(RobolectricTestRunner::class)
class FilterThrowingExceptionTest {
  init {
    JniLibrary.loadTestLibrary()
  }

  @Test
  fun `registers a filter that throws an exception and performs an HTTP request`() {
    val onEngineRunningLatch = CountDownLatch(1)
    val onRespondeHeadersLatch = CountDownLatch(1)
    val onJNIExceptionEventLatch = CountDownLatch(2)

    var expectedMessages =
      mutableListOf(
        "Simulated onRequestHeaders exception||onRequestHeaders||",
        "Simulated onResponseHeaders exception||onResponseHeaders||"
      )

    val context = ApplicationProvider.getApplicationContext<Context>()
    val builder = AndroidEngineBuilder(context)
    val engine =
      builder
        .addLogLevel(LogLevel.DEBUG)
        .setEventTracker { event ->
          if (
            event["name"] == "event_log" && event["log_name"] == "jni_cleared_pending_exception"
          ) {
            assertThat(event["message"]).contains(expectedMessages.removeFirst())
            onJNIExceptionEventLatch.countDown()
          }
        }
        .addPlatformFilter(::ThrowingFilter)
        .setOnEngineRunning { onEngineRunningLatch.countDown() }
        .build()

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "api.lyft.com",
          path = "/ping"
        )
        .build()

    engine
      .streamClient()
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, _, _ ->
        val status = responseHeaders.httpStatus ?: 0L
        assertThat(status).isEqualTo(200)
        onRespondeHeadersLatch.countDown()
      }
      .start(Executors.newSingleThreadExecutor())
      .sendHeaders(requestHeaders, true)

    onRespondeHeadersLatch.await(15, TimeUnit.SECONDS)
    assertThat(onRespondeHeadersLatch.count).isEqualTo(0)

    onJNIExceptionEventLatch.await(15, TimeUnit.SECONDS)
    assertThat(onJNIExceptionEventLatch.count).isEqualTo(0)

    engine.terminate()
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.Standard
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.fail
import org.junit.Test

private const val TEST_RESPONSE_FILTER_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.test_remote_response.TestRemoteResponse"

class SendHeadersTest {

  init {
    JniLibrary.loadTestLibrary()
  }

  @Test
  fun `successful sending of request headers`() {
    val headersExpectation = CountDownLatch(1)

    val engine =
      EngineBuilder(Standard())
        .addNativeFilter("test_remote_response", "{'@type': $TEST_RESPONSE_FILTER_TYPE}")
        .build()
    val client = engine.streamClient()

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "example.com",
          path = "/test"
        )
        .build()

    var resultHeaders: ResponseHeaders? = null
    var resultEndStream: Boolean? = null
    client
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, endStream, _ ->
        resultHeaders = responseHeaders
        resultEndStream = endStream
        headersExpectation.countDown()
      }
      .setOnResponseData { _, endStream, _ -> resultEndStream = endStream }
      .setOnError { _, _ -> fail("Unexpected error") }
      .start()
      .sendHeaders(requestHeaders, true)

    headersExpectation.await(10, TimeUnit.SECONDS)

    engine.terminate()

    assertThat(headersExpectation.count).isEqualTo(0)

    assertThat(resultHeaders!!.httpStatus).isEqualTo(200)
    assertThat(resultEndStream).isTrue()
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:kotlin_lib.bzl", "envoy_mobile_kt_library")
load("@envoy_mobile//bazel:kotlin_test.bzl", "envoy_mobile_android_test", "envoy_mobile_jni_kt_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_jni_kt_test(
    name = "engine_start_test",
    srcs = [
        "EnvoyEngineSimpleIntegrationTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_jni_kt_test(
    name = "engine_api_test",
    srcs = [
        "EngineApiTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_jni_kt_test(
    name = "key_value_store_test",
    srcs = [
        "KeyValueStoreTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_jni_kt_test(
    name = "set_event_tracker_test",
    srcs = [
        "SetEventTrackerTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_jni_kt_test(
    name = "set_logger_test",
    srcs = [
        "SetLoggerTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_jni_kt_test(
    name = "cancel_stream_test",
    srcs = [
        "CancelStreamTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_jni_kt_test(
    name = "stream_idle_timeout_test",
    srcs = [
        "StreamIdleTimeoutTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_jni_kt_test(
    name = "cancel_grpc_stream_test",
    srcs = [
        "CancelGRPCStreamTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_jni_kt_test(
    name = "reset_connectivity_state_test",
    srcs = [
        "ResetConnectivityStateTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_jni_kt_test(
    name = "grpc_receive_error_test",
    srcs = [
        "GRPCReceiveErrorTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_jni_kt_test(
    name = "receive_data_test",
    srcs = [
        "ReceiveDataTest.kt",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_jni_kt_test(
    name = "receive_error_test",
    srcs = [
        "ReceiveErrorTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_android_test(
    name = "send_data_test",
    srcs = [
        "SendDataTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//test/java/io/envoyproxy/envoymobile/engine/testing",
    ],
)

envoy_mobile_jni_kt_test(
    name = "send_headers_test",
    srcs = [
        "SendHeadersTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_jni_kt_test(
    name = "send_trailers_test",
    srcs = [
        "SendTrailersTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_jni_kt_test(
    name = "receive_trailers_test",
    srcs = [
        "ReceiveTrailersTest.kt",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_android_test(
    name = "filter_throwing_exception_test",
    srcs = [
        "FilterThrowingExceptionTest.kt",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
        "dockerNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
    ],
)

envoy_mobile_android_test(
    name = "xds_test",
    srcs = [
        "XdsTest.kt",
    ],
    native_deps = [
        "@envoy//test/config/integration/certs",
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        ":test_utilities",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//test/java/io/envoyproxy/envoymobile/engine/testing",
    ],
)

envoy_mobile_kt_library(
    name = "test_utilities",
    srcs = [
        "TestUtilities.kt",
    ],
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "@maven//:junit_junit",
    ],
)
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.KeyValueStore
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.Standard
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.fail
import org.junit.Test

private const val TEST_RESPONSE_FILTER_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.test_remote_response.TestRemoteResponse"
private const val TEST_KEY = "foo"
private const val TEST_VALUE = "bar"

class KeyValueStoreTest {

  init {
    JniLibrary.loadTestLibrary()
  }

  @Test
  fun `a registered KeyValueStore implementation handles calls from a TestKeyValueStore filter`() {

    val readExpectation = CountDownLatch(3)
    val saveExpectation = CountDownLatch(1)
    val testKeyValueStore =
      object : KeyValueStore {
        override fun read(key: String): String? {
          readExpectation.countDown()
          return null
        }

        override fun remove(key: String) {}

        override fun save(key: String, value: String) {
          saveExpectation.countDown()
        }
      }

    val engine =
      EngineBuilder(Standard())
        .addKeyValueStore("envoy.key_value.platform_test", testKeyValueStore)
        .addNativeFilter(
          "envoy.filters.http.test_kv_store",
          "{'@type': type.googleapis.com/envoymobile.extensions.filters.http.test_kv_store.TestKeyValueStore, kv_store_name: envoy.key_value.platform_test, test_key: $TEST_KEY, test_value: $TEST_VALUE}"
        )
        .addNativeFilter("test_remote_response", "{'@type': $TEST_RESPONSE_FILTER_TYPE}")
        .build()
    val client = engine.streamClient()

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "example.com",
          path = "/test"
        )
        .build()

    client
      .newStreamPrototype()
      .setOnError { _, _ -> fail("Unexpected error") }
      .start()
      .sendHeaders(requestHeaders, true)

    readExpectation.await(10, TimeUnit.SECONDS)
    saveExpectation.await(10, TimeUnit.SECONDS)
    engine.terminate()

    assertThat(readExpectation.count).isEqualTo(0)
    assertThat(saveExpectation.count).isEqualTo(0)
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.EnvoyError
import io.envoyproxy.envoymobile.FilterDataStatus
import io.envoyproxy.envoymobile.FilterHeadersStatus
import io.envoyproxy.envoymobile.FilterTrailersStatus
import io.envoyproxy.envoymobile.FinalStreamIntel
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.ResponseFilter
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.ResponseTrailers
import io.envoyproxy.envoymobile.Standard
import io.envoyproxy.envoymobile.StreamIntel
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.nio.ByteBuffer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

private const val TEST_RESPONSE_FILTER_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.test_remote_response.TestRemoteResponse"

class CancelStreamTest {

  init {
    JniLibrary.loadTestLibrary()
  }

  private val filterExpectation = CountDownLatch(1)
  private val runExpectation = CountDownLatch(1)

  class CancelValidationFilter(private val latch: CountDownLatch) : ResponseFilter {
    override fun onResponseHeaders(
      headers: ResponseHeaders,
      endStream: Boolean,
      streamIntel: StreamIntel
    ): FilterHeadersStatus<ResponseHeaders> {
      return FilterHeadersStatus.Continue(headers)
    }

    override fun onResponseData(
      body: ByteBuffer,
      endStream: Boolean,
      streamIntel: StreamIntel
    ): FilterDataStatus<ResponseHeaders> {
      return FilterDataStatus.Continue(body)
    }

    override fun onResponseTrailers(
      trailers: ResponseTrailers,
      streamIntel: StreamIntel
    ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
      return FilterTrailersStatus.Continue(trailers)
    }

    override fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel) {}

    override fun onComplete(finalStreamIntel: FinalStreamIntel) {}

    override fun onCancel(finalStreamIntel: FinalStreamIntel) {
      latch.countDown()
    }
  }

  @Test
  fun `cancel stream calls onCancel callback`() {
    val engine =
      EngineBuilder(Standard())
        .addPlatformFilter(
          name = "cancel_validation_filter",
          factory = { CancelValidationFilter(filterExpectation) }
        )
        .addNativeFilter("test_remote_response", "{'@type': $TEST_RESPONSE_FILTER_TYPE}")
        .build()

    val client = engine.streamClient()

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "example.com",
          path = "/test"
        )
        .build()

    client
      .newStreamPrototype()
      .setOnCancel { _ -> runExpectation.countDown() }
      .start(Executors.newSingleThreadExecutor())
      .sendHeaders(requestHeaders, false)
      .cancel()

    filterExpectation.await(10, TimeUnit.SECONDS)
    runExpectation.await(10, TimeUnit.SECONDS)

    engine.terminate()

    assertThat(filterExpectation.count).isEqualTo(0)
    assertThat(runExpectation.count).isEqualTo(0)
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.EnvoyError
import io.envoyproxy.envoymobile.FilterDataStatus
import io.envoyproxy.envoymobile.FilterHeadersStatus
import io.envoyproxy.envoymobile.FilterTrailersStatus
import io.envoyproxy.envoymobile.FinalStreamIntel
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.RequestTrailersBuilder
import io.envoyproxy.envoymobile.ResponseFilter
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.ResponseTrailers
import io.envoyproxy.envoymobile.Standard
import io.envoyproxy.envoymobile.StreamIntel
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.nio.ByteBuffer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.fail
import org.junit.Test

private const val TEST_RESPONSE_FILTER_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.test_remote_response.TestRemoteResponse"
private const val MATCHER_TRAILER_NAME = "test-trailer"
private const val MATCHER_TRAILER_VALUE = "test.code"

class ReceiveTrailersTest {

  init {
    JniLibrary.loadTestLibrary()
  }

  class ErrorValidationFilter(private val onTrailers: CountDownLatch) : ResponseFilter {
    override fun onResponseHeaders(
      headers: ResponseHeaders,
      endStream: Boolean,
      streamIntel: StreamIntel
    ): FilterHeadersStatus<ResponseHeaders> {
      return FilterHeadersStatus.Continue(headers)
    }

    override fun onResponseData(
      body: ByteBuffer,
      endStream: Boolean,
      streamIntel: StreamIntel
    ): FilterDataStatus<ResponseHeaders> {
      return FilterDataStatus.Continue(body)
    }

    override fun onResponseTrailers(
      trailers: ResponseTrailers,
      streamIntel: StreamIntel
    ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
      onTrailers.countDown()
      return FilterTrailersStatus.Continue(trailers)
    }

    override fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel) {}

    override fun onComplete(finalStreamIntel: FinalStreamIntel) {}

    override fun onCancel(finalStreamIntel: FinalStreamIntel) {}
  }

  @Test
  fun `successful sending of trailers`() {
    val trailersReceived = CountDownLatch(2)
    val expectation = CountDownLatch(2)
    val engine =
      EngineBuilder(Standard())
        .addPlatformFilter(
          name = "test_platform_filter",
          factory = { ErrorValidationFilter(trailersReceived) }
        )
        .addNativeFilter("test_remote_response", "{'@type': $TEST_RESPONSE_FILTER_TYPE}")
        .build()

    val client = engine.streamClient()

    val builder =
      RequestHeadersBuilder(
        method = RequestMethod.GET,
        scheme = "https",
        authority = "example.com",
        path = "/test"
      )
    builder.add("send-trailers", "true")
    val requestHeadersDefault = builder.build()

    val body = ByteBuffer.wrap("match_me".toByteArray(Charsets.UTF_8))
    val requestTrailers =
      RequestTrailersBuilder().add(MATCHER_TRAILER_NAME, MATCHER_TRAILER_VALUE).build()

    var responseStatus: Int? = null
    client
      .newStreamPrototype()
      .setOnResponseHeaders { headers, _, _ ->
        responseStatus = headers.httpStatus
        expectation.countDown()
      }
      .setOnError { _, _ -> fail("Unexpected error") }
      .start()
      .sendHeaders(requestHeadersDefault, false)
      .sendData(body)
      .close(requestTrailers)

    expectation.await(10, TimeUnit.SECONDS)

    builder.remove("send-trailers")
    builder.add("send-trailers", "empty")
    val requestHeadersEmpty = builder.build()
    client
      .newStreamPrototype()
      .setOnResponseHeaders { headers, _, _ ->
        responseStatus = headers.httpStatus
        expectation.countDown()
      }
      .setOnError { _, _ -> fail("Unexpected error") }
      .start()
      .sendHeaders(requestHeadersEmpty, false)
      .sendData(body)
      .close(requestTrailers)
    expectation.await(10, TimeUnit.SECONDS)

    builder.remove("send-trailers")
    builder.add("send-trailers", "empty-value")
    val requestHeadersEmptyValue = builder.build()
    client
      .newStreamPrototype()
      .setOnResponseHeaders { headers, _, _ ->
        responseStatus = headers.httpStatus
        expectation.countDown()
      }
      .setOnError { _, _ -> fail("Unexpected error") }
      .start()
      .sendHeaders(requestHeadersEmptyValue, false)
      .sendData(body)
      .close(requestTrailers)
    expectation.await(10, TimeUnit.SECONDS)

    engine.terminate()

    assertThat(trailersReceived.count).isEqualTo(0)
    trailersReceived.await(10, TimeUnit.SECONDS)
    assertThat(expectation.count).isEqualTo(0)
    assertThat(responseStatus).isEqualTo(200)
  }
}
package test.kotlin.integration

import io.envoyproxy.envoymobile.EngineBuilder
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.RequestTrailersBuilder
import io.envoyproxy.envoymobile.Standard
import io.envoyproxy.envoymobile.engine.JniLibrary
import java.nio.ByteBuffer
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.fail
import org.junit.Test

private const val TEST_RESPONSE_FILTER_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.test_remote_response.TestRemoteResponse"
private const val ASSERTION_FILTER_TYPE =
  "type.googleapis.com/envoymobile.extensions.filters.http.assertion.Assertion"
private const val MATCHER_TRAILER_NAME = "test-trailer"
private const val MATCHER_TRAILER_VALUE = "test.code"

class SendTrailersTest {

  init {
    JniLibrary.loadTestLibrary()
  }

  @Test
  fun `successful sending of trailers`() {

    val expectation = CountDownLatch(1)
    val engine =
      EngineBuilder(Standard())
        .addNativeFilter(
          "envoy.filters.http.assertion",
          "{'@type': $ASSERTION_FILTER_TYPE, match_config: {http_request_trailers_match: {headers: [{name: 'test-trailer', exact_match: 'test.code'}]}}}"
        )
        .addNativeFilter(
          "envoy.filters.http.buffer",
          "{\"@type\":\"type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer\",\"max_request_bytes\":65000}"
        )
        .addNativeFilter("test_remote_response", "{'@type': $TEST_RESPONSE_FILTER_TYPE}")
        .build()

    val client = engine.streamClient()

    val requestHeaders =
      RequestHeadersBuilder(
          method = RequestMethod.GET,
          scheme = "https",
          authority = "example.com",
          path = "/test"
        )
        .build()

    val body = ByteBuffer.wrap("match_me".toByteArray(Charsets.UTF_8))
    val requestTrailers =
      RequestTrailersBuilder().add(MATCHER_TRAILER_NAME, MATCHER_TRAILER_VALUE).build()

    var responseStatus: Int? = null
    client
      .newStreamPrototype()
      .setOnResponseHeaders { headers, _, _ ->
        responseStatus = headers.httpStatus
        expectation.countDown()
      }
      .setOnError { _, _ -> fail("Unexpected error") }
      .start()
      .sendHeaders(requestHeaders, false)
      .sendData(body)
      .close(requestTrailers)

    expectation.await(10, TimeUnit.SECONDS)

    engine.terminate()

    assertThat(expectation.count).isEqualTo(0)
    assertThat(responseStatus).isEqualTo(200)
  }
}
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.EnvoyEngine
import io.envoyproxy.envoymobile.engine.JniLibrary
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test
import org.mockito.Mockito.mock

class EngineBuilderTest {
  private lateinit var engineBuilder: EngineBuilder
  private var envoyEngine: EnvoyEngine = mock(EnvoyEngine::class.java)

  init {
    JniLibrary.loadTestLibrary()
  }

  @Test
  fun `adding log level builder uses log level for running Envoy`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.addLogLevel(LogLevel.DEBUG)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.logLevel).isEqualTo(LogLevel.DEBUG)
  }

  @Test
  fun `enabling interface binding overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.enableInterfaceBinding(true)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.enableInterfaceBinding).isTrue()
  }

  @Test
  fun `specifying connection timeout overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.addConnectTimeoutSeconds(1234)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.connectTimeoutSeconds).isEqualTo(1234)
  }

  @Test
  fun `specifying min DNS refresh overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.addDNSMinRefreshSeconds(1234)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.dnsMinRefreshSeconds).isEqualTo(1234)
  }

  @Test
  fun `specifying DNS refresh overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.addDNSRefreshSeconds(1234)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.dnsRefreshSeconds).isEqualTo(1234)
  }

  @Test
  fun `specifying DNS failure refresh overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.addDNSFailureRefreshSeconds(1234, 5678)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.dnsFailureRefreshSecondsBase).isEqualTo(1234)
    assertThat(engine.envoyConfiguration.dnsFailureRefreshSecondsMax).isEqualTo(5678)
  }

  @Test
  fun `specifying DNS query timeout overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.addDNSQueryTimeoutSeconds(1234)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.dnsQueryTimeoutSeconds).isEqualTo(1234)
  }

  @Test
  fun `DNS cache is disabled by default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.enableDNSCache).isFalse()
  }

  @Test
  fun `enabling DNS cache overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.enableDNSCache(true)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.enableDNSCache).isTrue()
  }

  @Test
  fun `specifying H2 Ping idle interval overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.addH2ConnectionKeepaliveIdleIntervalMilliseconds(1234)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.h2ConnectionKeepaliveIdleIntervalMilliseconds)
      .isEqualTo(1234)
  }

  @Test
  fun `specifying H2 Ping timeout overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.addH2ConnectionKeepaliveTimeoutSeconds(1234)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.h2ConnectionKeepaliveTimeoutSeconds).isEqualTo(1234)
  }

  @Test
  fun `specifying max connections per host overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.setMaxConnectionsPerHost(1234)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.maxConnectionsPerHost).isEqualTo(1234)
  }

  @Test
  fun `specifying stream idle timeout overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.addStreamIdleTimeoutSeconds(1234)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.streamIdleTimeoutSeconds).isEqualTo(1234)
  }

  @Test
  fun `specifying per try idle timeout overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.addPerTryIdleTimeoutSeconds(5678)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.perTryIdleTimeoutSeconds).isEqualTo(5678)
  }

  @Test
  fun `specifying app version overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.addAppVersion("v1.2.3")

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.appVersion).isEqualTo("v1.2.3")
  }

  @Test
  fun `specifying app id overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.addAppId("com.envoymobile.android")

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.appId).isEqualTo("com.envoymobile.android")
  }

  @Test
  fun `specifying native filters overrides default`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.addNativeFilter("name", "config")

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.nativeFilterChain.size).isEqualTo(1)
  }

  @Test
  fun `specifying xDS works`() {
    var xdsBuilder = XdsBuilder("fake_test_address", 0)
    xdsBuilder
      .addInitialStreamHeader("x-goog-api-key", "A1B2C3")
      .addInitialStreamHeader("x-android-package", "com.google.myapp")
    xdsBuilder.setSslRootCerts("my_root_certs")
    xdsBuilder.addRuntimeDiscoveryService("some_rtds_resource")
    xdsBuilder.addClusterDiscoveryService(
      "xdstp://fake_test_address/envoy.config.cluster.v3.Cluster/xyz"
    )
    engineBuilder = EngineBuilder(Standard())
    engineBuilder.addEngineType { envoyEngine }
    engineBuilder.setXds(xdsBuilder)

    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.xdsAddress).isEqualTo("fake_test_address")
    assertThat(engine.envoyConfiguration.xdsGrpcInitialMetadata)
      .isEqualTo(mapOf("x-goog-api-key" to "A1B2C3", "x-android-package" to "com.google.myapp"))
    assertThat(engine.envoyConfiguration.xdsRootCerts).isEqualTo("my_root_certs")
    assertThat(engine.envoyConfiguration.rtdsResourceName).isEqualTo("some_rtds_resource")
    assertThat(engine.envoyConfiguration.cdsResourcesLocator)
      .isEqualTo("xdstp://fake_test_address/envoy.config.cluster.v3.Cluster/xyz")
  }

  @Test
  fun `specifying runtime guards work`() {
    engineBuilder = EngineBuilder(Standard())
    engineBuilder
      .setRuntimeGuard("test_feature_false", true)
      .setRuntimeGuard("test_feature_true", false)
    val engine = engineBuilder.build() as EngineImpl
    assertThat(engine.envoyConfiguration.runtimeGuards["test_feature_false"]).isEqualTo("true")
    assertThat(engine.envoyConfiguration.runtimeGuards["test_feature_true"]).isEqualTo("false")
  }
}
package io.envoyproxy.envoymobile

import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class RetryPolicyMapperTest {
  @Test
  fun `converting to headers with per retry timeout includes all headers`() {
    val retryPolicy =
      RetryPolicy(
        maxRetryCount = 3,
        retryOn =
          listOf(
            RetryRule.STATUS_5XX,
            RetryRule.GATEWAY_ERROR,
            RetryRule.CONNECT_FAILURE,
            RetryRule.REFUSED_STREAM,
            RetryRule.RETRIABLE_4XX,
            RetryRule.RETRIABLE_HEADERS,
            RetryRule.RESET
          ),
        retryStatusCodes = listOf(400, 422, 500),
        perRetryTimeoutMS = 15000,
        totalUpstreamTimeoutMS = 60000
      )

    assertThat(retryPolicy.outboundHeaders())
      .isEqualTo(
        mapOf(
          "x-envoy-max-retries" to listOf("3"),
          "x-envoy-retriable-status-codes" to listOf("400", "422", "500"),
          "x-envoy-retry-on" to
            listOf(
              "5xx",
              "gateway-error",
              "connect-failure",
              "refused-stream",
              "retriable-4xx",
              "retriable-headers",
              "reset",
              "retriable-status-codes"
            ),
          "x-envoy-upstream-rq-per-try-timeout-ms" to listOf("15000"),
          "x-envoy-upstream-rq-timeout-ms" to listOf("60000")
        )
      )
  }

  @Test
  fun `converting from header values delimited with comma yields individual enum values`() {
    val retryPolicy =
      RetryPolicy(
        maxRetryCount = 3,
        retryOn = listOf(RetryRule.STATUS_5XX, RetryRule.GATEWAY_ERROR),
        retryStatusCodes = listOf(400, 422, 500),
        perRetryTimeoutMS = 15000,
        totalUpstreamTimeoutMS = 60000
      )

    val headers =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .add("x-envoy-max-retries", "3")
        .add("x-envoy-retriable-status-codes", "400,422,500")
        .add("x-envoy-retry-on", "5xx,gateway-error")
        .add("x-envoy-upstream-rq-per-try-timeout-ms", "15000")
        .add("x-envoy-upstream-rq-timeout-ms", "60000")
        .build()

    val retryPolicyFromHeaders = RetryPolicy.from(headers)!!

    assertThat(retryPolicy).isEqualTo(retryPolicyFromHeaders)
  }

  @Test
  fun `converting to headers without retry timeout excludes per retry timeout header`() {
    val retryPolicy =
      RetryPolicy(
        maxRetryCount = 123,
        retryOn = listOf(RetryRule.STATUS_5XX, RetryRule.GATEWAY_ERROR)
      )

    assertThat(retryPolicy.outboundHeaders())
      .doesNotContainKey("x-envoy-upstream-rq-per-try-timeout-ms")
  }

  @Test
  fun `converting to headers without upstream timeout includes zero for timeout header`() {
    val retryPolicy =
      RetryPolicy(
        maxRetryCount = 123,
        retryOn = listOf(RetryRule.STATUS_5XX),
        totalUpstreamTimeoutMS = null
      )

    assertThat(retryPolicy.outboundHeaders())
      .isEqualTo(
        mapOf(
          "x-envoy-max-retries" to listOf("123"),
          "x-envoy-retry-on" to listOf("5xx"),
          "x-envoy-upstream-rq-timeout-ms" to listOf("0")
        )
      )
  }

  @Test(expected = IllegalArgumentException::class)
  fun `throws error when per-retry timeout is larger than total timeout`() {
    RetryPolicy(
      maxRetryCount = 3,
      retryOn = listOf(RetryRule.STATUS_5XX),
      perRetryTimeoutMS = 2,
      totalUpstreamTimeoutMS = 1
    )
  }

  @Test
  fun `converting headers without retry status code does not set retriable status code headers`() {
    val retryPolicy =
      RetryPolicy(
        maxRetryCount = 123,
        retryOn =
          listOf(
            RetryRule.STATUS_5XX,
            RetryRule.GATEWAY_ERROR,
            RetryRule.CONNECT_FAILURE,
            RetryRule.REFUSED_STREAM,
            RetryRule.RETRIABLE_4XX,
            RetryRule.RETRIABLE_HEADERS,
            RetryRule.RESET
          ),
        retryStatusCodes = emptyList(),
        totalUpstreamTimeoutMS = null
      )

    val headers = retryPolicy.outboundHeaders()
    assertThat(headers["x-envoy-retriable-status-codes"]).isNull()
    assertThat(headers["x-envoy-retry-on"]).doesNotContain("retriable-status-codes")
  }
}
package io.envoyproxy.envoymobile

import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class ResponseHeadersTest {
  @Test
  fun `parsing status code from headers returns first status`() {
    val headers = ResponseHeaders(mapOf(":status" to listOf("204", "200")))
    assertThat(headers.httpStatus).isEqualTo(204)
  }

  @Test
  fun `parsing invalid status string returns null`() {
    val headers = ResponseHeaders(mapOf(":status" to listOf("invalid"), "other" to listOf("1")))
    assertThat(headers.httpStatus).isNull()
  }

  @Test
  fun `parsing negative status returns null`() {
    val headers = ResponseHeaders(mapOf(":status" to listOf("-123"), "other" to listOf("1")))
    assertThat(headers.httpStatus).isNull()
  }

  @Test
  fun `parsing missing status code returns null`() {
    val headers = ResponseHeaders(emptyMap())
    assertThat(headers.httpStatus).isNull()
  }

  @Test
  fun `adding HTTP status code sets the appropriate header`() {
    val headers = ResponseHeadersBuilder().addHttpStatus(200).build()
    assertThat(headers.value(":status")).containsExactly("200")
  }

  @Test
  fun `adding negative HTTP status code no-ops`() {
    val headers = ResponseHeadersBuilder().addHttpStatus(-123).build()
    assertThat(headers.value(":status")).isNull()
  }

  @Test
  fun `header lookup is a case-insensitive operation`() {
    val headers = ResponseHeaders(mapOf("FoO" to listOf("123")))
    assertThat(headers.value("FoO")).isEqualTo(listOf("123"))
    assertThat(headers.value("foo")).isEqualTo(listOf("123"))
  }
}
package io.envoyproxy.envoymobile

import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class HeadersBuilderTest {
  @Test
  fun `adding new header adds to list of header keys`() {
    val headers = RequestHeadersBuilder(mutableMapOf()).add("x-foo", "1").add("x-foo", "2").build()
    assertThat(headers.value("x-foo")).containsExactly("1", "2")
  }

  @Test
  fun `adding header performs a case-insensitive header name lookup`() {
    val headers = RequestHeadersBuilder(mutableMapOf()).add("fOo", "abc").add("foo", "123").build()
    assertThat(headers.caseSensitiveHeaders()).isEqualTo(mapOf("fOo" to listOf("abc", "123")))
  }

  @Test
  fun `removing specific header key removes all of its values`() {
    val headers =
      RequestHeadersBuilder(mutableMapOf())
        .add("x-foo", "1")
        .add("x-foo", "2")
        .remove("x-foo")
        .build()
    assertThat(headers.caseSensitiveHeaders()).doesNotContainKey("x-foo")
  }

  @Test
  fun `removing specific header key does not remove other keys`() {
    val headers =
      RequestHeadersBuilder(mutableMapOf()).add("x-foo", "123").add("x-bar", "abc").build()
    assertThat(headers.value("x-foo")).containsExactly("123")
    assertThat(headers.value("x-bar")).containsExactly("abc")
  }

  @Test
  fun `removing specific header key performs a case-insensitive header name lookup`() {
    val headers =
      RequestHeadersBuilder(mutableMapOf()).set("foo", mutableListOf("123")).remove("fOo").build()
    assertThat(headers.caseSensitiveHeaders()).isEmpty()
  }

  @Test
  fun `setting header replaces existing headers with matching name`() {
    val headers =
      RequestHeadersBuilder(mutableMapOf())
        .add("x-foo", "123")
        .set("x-foo", mutableListOf("abc"))
        .build()
    assertThat(headers.value("x-foo")).containsExactly("abc")
  }

  @Test
  fun `setting header replaces performs a case-insensitive header name lookup`() {
    val headers =
      RequestHeadersBuilder(mapOf())
        .set("foo", mutableListOf("123"))
        .set("fOo", mutableListOf("abc"))
        .build()
    assertThat(headers.caseSensitiveHeaders()).isEqualTo(mapOf("fOo" to listOf("abc")))
  }

  @Test
  fun `test initialization is case-insensitive, preserves casing and processes headers in alphabetical order`() {
    val headers =
      RequestHeadersBuilder(mutableMapOf("a" to mutableListOf("456"), "A" to mutableListOf("123")))
        .build()
    assertThat(headers.caseSensitiveHeaders()).isEqualTo(mapOf("A" to listOf("123", "456")))
  }

  @Test
  fun `test restricted headers are not settable`() {
    val headers =
      RequestHeadersBuilder(method = RequestMethod.GET, authority = "example.com", path = "/")
        .add("host", "example.com")
        .add("Host", "example.com")
        .add("hostWithSuffix", "foo.bar")
        .set(":scheme", mutableListOf("http"))
        .set(":path", mutableListOf("/nope"))
        .build()
        .caseSensitiveHeaders()
    val expected =
      mapOf(
        ":authority" to listOf("example.com"),
        ":path" to listOf("/"),
        ":method" to listOf("GET"),
        ":scheme" to listOf("https"),
        "hostWithSuffix" to listOf("foo.bar"),
      )
    assertThat(headers).isEqualTo(expected)
  }
}
package io.envoyproxy.envoymobile

import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class RequestHeadersBuilderTest {
  @Test
  fun `adds method to headers`() {
    val headers =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .build()

    assertThat(headers.value(":method")).containsExactly("POST")
    assertThat(headers.method).isEqualTo(RequestMethod.POST)
  }

  @Test
  fun `adds scheme to headers`() {
    val headers =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .build()

    assertThat(headers.value(":scheme")).containsExactly("https")
    assertThat(headers.scheme).isEqualTo("https")
  }

  @Test
  fun `adds authority to headers`() {
    val headers =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .build()

    assertThat(headers.value(":authority")).containsExactly("envoyproxy.io")
    assertThat(headers.authority).isEqualTo("envoyproxy.io")
  }

  @Test
  fun `adds path to headers`() {
    val headers =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .build()

    assertThat(headers.value(":path")).containsExactly("/mock")
    assertThat(headers.path).isEqualTo("/mock")
  }

  @Test
  fun `joins header values with the same key`() {
    val headers =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .add("x-foo", "1")
        .add("x-foo", "2")
        .build()

    assertThat(headers.value("x-foo")).containsExactly("1", "2")
  }

  @Test
  fun `cannot publicly add headers with restricted prefix`() {
    val headers =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .add(":x-foo", "123")
        .add("x-envoy-mobile-foo", "abc")
        .add("host", "example.com")
        .add("hostWithSuffix", "foo.bar")
        .build()

    assertThat(headers.caseSensitiveHeaders()).doesNotContainKey(":x-foo")
    assertThat(headers.caseSensitiveHeaders()).doesNotContainKey("x-envoy-mobile-foo")
    assertThat(headers.caseSensitiveHeaders()).doesNotContainKey("host")
    assertThat(headers.value("hostWithSuffix")).containsExactly("foo.bar")
  }

  @Test
  fun `cannot publicly set headers with restricted prefix`() {
    val headers =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .set(":x-foo", mutableListOf("123"))
        .set("x-envoy-mobile-foo", mutableListOf("abc"))
        .build()

    assertThat(headers.caseSensitiveHeaders()).doesNotContainKey(":x-foo")
    assertThat(headers.caseSensitiveHeaders()).doesNotContainKey("x-envoy-mobile-foo")
  }

  @Test
  fun `cannot publicly remove headers with restricted prefix`() {
    val headers =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .remove(":path")
        .build()

    assertThat(headers.value(":path")).contains("/mock")
  }

  @Test
  fun `can internally set headers with restricted prefix`() {
    val headers =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .internalSet(":x-foo", mutableListOf("123"))
        .internalSet("x-envoy-mobile-foo", mutableListOf("abc"))
        .build()

    assertThat(headers.value(":x-foo")).containsExactly("123")
    assertThat(headers.value("x-envoy-mobile-foo")).containsExactly("abc")
  }

  @Test
  fun `includes retry policy headers`() {
    val retryPolicy =
      RetryPolicy(
        maxRetryCount = 123,
        retryOn = listOf(RetryRule.STATUS_5XX, RetryRule.GATEWAY_ERROR),
        perRetryTimeoutMS = 9001
      )
    val retryPolicyHeaders = retryPolicy.outboundHeaders()

    val headers =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .addRetryPolicy(retryPolicy)
        .build()

    assertThat(headers.caseSensitiveHeaders()).containsAllEntriesOf(retryPolicyHeaders)
  }

  @Test
  fun `retry policy takes precedence over manually set retry headers`() {
    val retryPolicy =
      RetryPolicy(
        maxRetryCount = 123,
        retryOn = listOf(RetryRule.STATUS_5XX, RetryRule.GATEWAY_ERROR),
        perRetryTimeoutMS = 9001
      )

    val headers =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .add("x-envoy-max-retries", "override")
        .addRetryPolicy(retryPolicy)
        .build()

    assertThat(headers.value("x-envoy-max-retries")).containsExactly("123")
  }

  @Test
  fun `converting to request headers and back maintains equality`() {
    val headers1 =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .build()
    val headers2 = headers1.toRequestHeadersBuilder().build()

    assertThat(headers1.caseSensitiveHeaders()).isEqualTo(headers2.caseSensitiveHeaders())
  }

  @Test
  fun `converting retry policy to headers and back creates the same retry policy`() {
    val retryPolicy =
      RetryPolicy(
        maxRetryCount = 123,
        retryOn = listOf(RetryRule.STATUS_5XX, RetryRule.GATEWAY_ERROR),
        perRetryTimeoutMS = 9001
      )

    val headers =
      RequestHeadersBuilder(
          method = RequestMethod.POST,
          scheme = "https",
          authority = "envoyproxy.io",
          path = "/mock"
        )
        .addRetryPolicy(retryPolicy)
        .build()

    assertThat(retryPolicy.outboundHeaders())
      .isEqualTo(RetryPolicy.from(headers)!!.outboundHeaders())
  }

  @Test
  fun `converting request method to string and back creates the same request method`() {
    assertThat(RequestMethod.enumValue(RequestMethod.DELETE.stringValue))
      .isEqualTo(RequestMethod.DELETE)
    assertThat(RequestMethod.enumValue(RequestMethod.GET.stringValue)).isEqualTo(RequestMethod.GET)
    assertThat(RequestMethod.enumValue(RequestMethod.HEAD.stringValue))
      .isEqualTo(RequestMethod.HEAD)
    assertThat(RequestMethod.enumValue(RequestMethod.OPTIONS.stringValue))
      .isEqualTo(RequestMethod.OPTIONS)
    assertThat(RequestMethod.enumValue(RequestMethod.PATCH.stringValue))
      .isEqualTo(RequestMethod.PATCH)
    assertThat(RequestMethod.enumValue(RequestMethod.POST.stringValue))
      .isEqualTo(RequestMethod.POST)
    assertThat(RequestMethod.enumValue(RequestMethod.PUT.stringValue)).isEqualTo(RequestMethod.PUT)
    assertThat(RequestMethod.enumValue(RequestMethod.TRACE.stringValue))
      .isEqualTo(RequestMethod.TRACE)
  }
}
package io.envoyproxy.envoymobile

import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executor
import java.util.concurrent.TimeUnit
import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class GRPCStreamTest {
  private val message1 = ByteBuffer.wrap(byteArrayOf(0x0, 0x1, 0x2, 0x3, 0x4, 0x5))

  // Request tests

  @Test
  fun `data size is five bytes greater than message size`() {
    val sentData = ByteArrayOutputStream()
    val streamClient = MockStreamClient { stream ->
      stream.onRequestData = { data, _ -> sentData.write(data.array()) }
    }

    GRPCClient(streamClient).newGRPCStreamPrototype().start(Executor {}).sendMessage(message1)

    assertThat(sentData.size()).isEqualTo(5 + message1.array().count())
  }

  @Test
  fun `prefixes sent data with zero compression flag`() {
    val sentData = ByteArrayOutputStream()
    val streamClient = MockStreamClient { stream ->
      stream.onRequestData = { data, _ -> sentData.write(data.array()) }
    }

    GRPCClient(streamClient).newGRPCStreamPrototype().start(Executor {}).sendMessage(message1)

    assertThat(sentData.toByteArray()[0]).isEqualTo(0)
  }

  @Test
  fun `prefixes sent data with big endian length of message`() {
    val sentData = ByteArrayOutputStream()
    val streamClient = MockStreamClient { stream ->
      stream.onRequestData = { data, _ -> sentData.write(data.array()) }
    }

    GRPCClient(streamClient).newGRPCStreamPrototype().start(Executor {}).sendMessage(message1)

    val size =
      ByteBuffer.wrap(sentData.toByteArray().sliceArray(1 until 5)).order(ByteOrder.BIG_ENDIAN).int
    assertThat(size).isEqualTo(message1.array().count())
  }

  @Test
  fun `appends message data at the end of sent data`() {
    val sentData = ByteArrayOutputStream()
    val streamClient = MockStreamClient { stream ->
      stream.onRequestData = { data, _ -> sentData.write(data.array()) }
    }

    GRPCClient(streamClient).newGRPCStreamPrototype().start(Executor {}).sendMessage(message1)

    assertThat(sentData.toByteArray().sliceArray(5 until sentData.size()))
      .isEqualTo(message1.array())
  }

  @Test
  fun `cancel calls a stream callback`() {
    val countDownLatch = CountDownLatch(1)
    val streamClient = MockStreamClient { stream ->
      stream.onCancel = { countDownLatch.countDown() }
    }

    GRPCClient(streamClient).newGRPCStreamPrototype().start(Executor {}).cancel()

    assertThat(countDownLatch.await(2000, TimeUnit.MILLISECONDS)).isTrue()
  }

  // Response tests

  @Test(timeout = 1000L)
  fun `headers callback passes headers`() {
    val countDownLatch = CountDownLatch(1)
    val expectedHeaders =
      ResponseHeaders(mapOf("grpc-status" to listOf("1"), "x-other" to listOf("foo", "bar")))
    var stream: MockStream? = null
    val streamClient = MockStreamClient { stream = it }

    GRPCClient(streamClient)
      .newGRPCStreamPrototype()
      .setOnResponseHeaders { headers, endStream, _ ->
        assertThat(headers.caseSensitiveHeaders()).isEqualTo(expectedHeaders.caseSensitiveHeaders())
        assertThat(endStream).isTrue()
        countDownLatch.countDown()
      }
      .start(Executor {})

    stream?.receiveHeaders(expectedHeaders, true)
    countDownLatch.await()
  }

  @Test(timeout = 1000L)
  fun `trailers callback passes trailers`() {
    val countDownLatch = CountDownLatch(1)
    val expectedTrailers =
      ResponseTrailers(mapOf("x-foo" to listOf("bar"), "x-baz" to listOf("1", "2")))
    var stream: MockStream? = null
    val streamClient = MockStreamClient { stream = it }

    GRPCClient(streamClient)
      .newGRPCStreamPrototype()
      .setOnResponseTrailers { trailers, _ ->
        assertThat(trailers.caseSensitiveHeaders())
          .isEqualTo(expectedTrailers.caseSensitiveHeaders())
        countDownLatch.countDown()
      }
      .start(Executor {})

    stream?.receiveTrailers(expectedTrailers)
    countDownLatch.await()
  }

  @Test(timeout = 1000L)
  fun `message callback buffers data sent in single chunk`() {
    val countDownLatch = CountDownLatch(1)
    var stream: MockStream? = null
    val streamClient = MockStreamClient { stream = it }

    GRPCClient(streamClient)
      .newGRPCStreamPrototype()
      .setOnResponseMessage { message, _ ->
        assertThat(message.array()).isEqualTo(message1.array())
        countDownLatch.countDown()
      }
      .start(Executor {})

    val messageLength = message1.array().count()
    val data = ByteBuffer.allocate(5 + messageLength)
    data.put(0) // Compression flag
    data.order(ByteOrder.BIG_ENDIAN)
    data.putInt(messageLength) // Length bytes
    data.put(message1)
    stream?.receiveData(data, false)
    countDownLatch.await()
  }

  @Test(timeout = 1000L)
  fun `message callback buffers data sent in multiple chunks`() {
    val countDownLatch = CountDownLatch(2)
    var stream: MockStream? = null
    val streamClient = MockStreamClient { stream = it }

    val firstMessage = byteArrayOf(0x1, 0x2, 0x3, 0x4, 0x5)
    val firstMessageBuffer =
      ByteBuffer.wrap(
        byteArrayOf(
          0x0, // Compression flag
          0x0,
          0x0,
          0x0,
          0x5 // Length bytes
        ) + firstMessage
      )

    val secondMessage = byteArrayOf(0x6, 0x7, 0x8, 0x9, 0x0, 0x1)
    val secondMessageBufferPart1 =
      ByteBuffer.wrap(
        byteArrayOf(
          0x0, // Compression flag
          0x0,
          0x0,
          0x0,
          0x6 // Length bytes
        ) + secondMessage.sliceArray(0 until 2)
      )
    val secondMessageBufferPart2 =
      ByteBuffer.wrap(secondMessage.sliceArray(2 until secondMessage.count()))

    GRPCClient(streamClient)
      .newGRPCStreamPrototype()
      .setOnResponseMessage { message, _ ->
        if (countDownLatch.count == 2L) {
          assertThat(message.array()).isEqualTo(firstMessage)
        } else {
          assertThat(message.array()).isEqualTo(secondMessage)
        }
        countDownLatch.countDown()
      }
      .start(Executor {})

    stream?.receiveData(firstMessageBuffer, false)
    stream?.receiveData(secondMessageBufferPart1, false)
    stream?.receiveData(secondMessageBufferPart2, false)
    countDownLatch.await()
  }

  @Test(timeout = 1000L)
  fun `message callback can be called with zero length message`() {
    val countDownLatch = CountDownLatch(1)
    var stream: MockStream? = null
    val streamClient = MockStreamClient { stream = it }

    GRPCClient(streamClient)
      .newGRPCStreamPrototype()
      .setOnResponseMessage { message, _ ->
        assertThat(message.array()).hasSize(0)
        countDownLatch.countDown()
      }
      .start(Executor {})

    val emptyMessage =
      ByteBuffer.wrap(
        byteArrayOf(
          0x0, // Compression flag
          0x0,
          0x0,
          0x0,
          0x0 // Length bytes
        )
      )

    stream?.receiveData(emptyMessage, false)
    countDownLatch.await()
  }

  @Test(timeout = 1000L)
  fun `message callback can be called with message after zero length message`() {
    val countDownLatch = CountDownLatch(2)
    var stream: MockStream? = null
    val streamClient = MockStreamClient { stream = it }

    val emptyMessageBuffer =
      ByteBuffer.wrap(
        byteArrayOf(
          0x0, // Compression flag
          0x0,
          0x0,
          0x0,
          0x0 // Length bytes
        )
      )

    val secondMessage = byteArrayOf(0x6, 0x7, 0x8, 0x9, 0x0, 0x1)
    val secondMessageBuffer =
      ByteBuffer.wrap(
        byteArrayOf(
          0x0, // Compression flag
          0x0,
          0x0,
          0x0,
          0x6 // Length bytes
        ) + secondMessage
      )

    GRPCClient(streamClient)
      .newGRPCStreamPrototype()
      .setOnResponseMessage { message, _ ->
        if (countDownLatch.count == 2L) {
          assertThat(message.array()).hasSize(0)
        } else {
          assertThat(message.array()).isEqualTo(secondMessage)
        }
        countDownLatch.countDown()
      }
      .start(Executor {})

    stream?.receiveData(emptyMessageBuffer, false)
    stream?.receiveData(secondMessageBuffer, false)
    countDownLatch.await()
  }
}
package io.envoyproxy.envoymobile

import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class GRPCRequestHeadersBuilderTest {
  @Test
  fun `adds scheme to header`() {
    val headers =
      GRPCRequestHeadersBuilder("https", "envoyproxy.io", "/pb.api.v1.Foo/GetBar").build()
    assertThat(headers.value(":scheme")).containsExactly("https")
    assertThat(headers.scheme).isEqualTo("https")
  }

  @Test
  fun `adds authority to header`() {
    val headers =
      GRPCRequestHeadersBuilder("https", "envoyproxy.io", "/pb.api.v1.Foo/GetBar").build()
    assertThat(headers.value(":authority")).containsExactly("envoyproxy.io")
    assertThat(headers.authority).isEqualTo("envoyproxy.io")
  }

  @Test
  fun `adds path to header`() {
    val headers =
      GRPCRequestHeadersBuilder("https", "envoyproxy.io", "/pb.api.v1.Foo/GetBar").build()
    assertThat(headers.value(":path")).containsExactly("/pb.api.v1.Foo/GetBar")
    assertThat(headers.path).isEqualTo("/pb.api.v1.Foo/GetBar")
  }

  @Test
  fun `adds grpc content type header`() {
    val headers =
      GRPCRequestHeadersBuilder("https", "envoyproxy.io", "/pb.api.v1.Foo/GetBar").build()
    assertThat(headers.value("content-type")).containsExactly("application/grpc")
  }

  @Test
  fun `uses http post`() {
    val headers =
      GRPCRequestHeadersBuilder("https", "envoyproxy.io", "/pb.api.v1.Foo/GetBar").build()
    assertThat(headers.method).isEqualTo(RequestMethod.POST)
    assertThat(headers.value(":method")).containsExactly("POST")
  }

  @Test
  fun `adds timeout header when set to value`() {
    val headers =
      GRPCRequestHeadersBuilder("https", "envoyproxy.io", "/pb.api.v1.Foo/GetBar")
        .addtimeoutMs(200)
        .build()
    assertThat(headers.value("grpc-timeout")).containsExactly("200m")
  }

  @Test
  fun `removes timeout header when set to null`() {
    val headers =
      GRPCRequestHeadersBuilder("https", "envoyproxy.io", "/pb.api.v1.Foo/GetBar")
        .addtimeoutMs(200)
        .addtimeoutMs(null)
        .build()
    assertThat(headers.value("grpc-timeout")).isNull()
  }
}
package io.envoyproxy.envoymobile

import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class HeadersContainerest {
  @Test
  fun `instantiation preserves all headers from input headers map`() {
    val headers = mapOf("a" to mutableListOf<String>("456"), "b" to mutableListOf<String>("123"))
    val container = HeadersContainer(headers)
    assertThat(container.caseSensitiveHeaders()).isEqualTo(headers)
  }

  @Test
  fun `instantiation with mutable list of values is case-insensitive, preserves casing and processes in alphabetical order`() {
    val container =
      HeadersContainer(
        mapOf("a" to mutableListOf<String>("456"), "A" to mutableListOf<String>("123"))
      )
    assertThat(container.caseSensitiveHeaders()).isEqualTo(mapOf("A" to listOf("123", "456")))
  }

  @Test
  fun `creation with immutable list of values is case-insensitive, preserves casing and processes in alphabetical order`() {
    val container =
      HeadersContainer.create(mapOf("a" to listOf<String>("456"), "A" to listOf<String>("123")))
    assertThat(container.caseSensitiveHeaders()).isEqualTo(mapOf("A" to listOf("123", "456")))
  }

  @Test
  fun `adding header adds to list of headers keys`() {
    val container = HeadersContainer(mutableMapOf())
    container.add("x-foo", "1")
    container.add("x-foo", "2")
    assertThat(container.value("x-foo")).containsExactly("1", "2")
  }

  @Test
  fun `adding header performs a case-insensitive header lookup and preserves header name casing`() {
    val container = HeadersContainer(mapOf())
    container.add("x-FOO", "1")
    container.add("x-foo", "2")

    assertThat(container.value("x-foo")).isEqualTo(listOf("1", "2"))
    assertThat(container.caseSensitiveHeaders()).isEqualTo(mapOf("x-FOO" to listOf("1", "2")))
  }

  @Test
  fun `setting header adds to list of headers keys`() {
    val container = HeadersContainer(mapOf())
    container.set("x-foo", mutableListOf("abc"))

    assertThat(container.value("x-foo")).isEqualTo(listOf("abc"))
  }

  @Test
  fun `setting header overrides previous header values`() {
    val container = HeadersContainer(mapOf())
    container.add("x-FOO", "1")
    container.add("x-foo", "2")
    container.set("x-foo", mutableListOf("3"))

    assertThat(container.value("x-foo")).isEqualTo(listOf("3"))
  }

  @Test
  fun `removing header removes all of its values`() {
    val container = HeadersContainer(mapOf())
    container.add("x-foo", "1")
    container.add("x-foo", "2")
    container.remove("x-foo")

    assertThat(container.value("x-foo")).isNull()
  }

  @Test
  fun `removing header performs case-insensitive header name lookup`() {
    val container = HeadersContainer(mapOf())
    container.add("x-FOO", "1")
    container.add("x-foo", "2")
    container.remove("x-fOo")

    assertThat(container.value("x-foo")).isNull()
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:kotlin_test.bzl", "envoy_mobile_jni_kt_test", "envoy_mobile_kt_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_jni_kt_test(
    name = "engine_builder_test",
    srcs = [
        "EngineBuilderTest.kt",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the JVM paths are allow-listed in the sandbox.
        "sandboxAllowed": "False",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_kt_test(
    name = "grpc_request_headers_builder_test",
    srcs = [
        "GRPCRequestHeadersBuilderTest.kt",
    ],
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_kt_test(
    name = "grpc_stream_test",
    srcs = [
        "GRPCStreamTest.kt",
    ],
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_kt_test(
    name = "headers_builder_test",
    srcs = [
        "HeadersBuilderTest.kt",
    ],
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_kt_test(
    name = "pulse_client_impl_test",
    srcs = [
        "PulseClientImplTest.kt",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the JVM paths are allow-listed in the sandbox.
        "sandboxAllowed": "False",
    },
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_kt_test(
    name = "request_headers_builder_test",
    srcs = [
        "RequestHeadersBuilderTest.kt",
    ],
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_kt_test(
    name = "response_headers_test",
    srcs = [
        "ResponseHeadersTest.kt",
    ],
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_kt_test(
    name = "retry_policy_mapper_test",
    srcs = [
        "RetryPolicyMapperTest.kt",
    ],
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_kt_test(
    name = "headers_container_test",
    srcs = [
        "HeadersContainerTest.kt",
    ],
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)
package io.envoyproxy.envoymobile

import io.envoyproxy.envoymobile.engine.EnvoyEngine
import org.assertj.core.api.Assertions.assertThat
import org.junit.Before
import org.junit.Test
import org.mockito.ArgumentCaptor
import org.mockito.Captor
import org.mockito.Mockito.mock
import org.mockito.Mockito.times
import org.mockito.Mockito.verify
import org.mockito.MockitoAnnotations

class PulseClientImplTest {
  private var envoyEngine: EnvoyEngine = mock(EnvoyEngine::class.java)

  @Captor private lateinit var elementsCaptor: ArgumentCaptor<String>

  @Captor private lateinit var tagsCaptor: ArgumentCaptor<MutableMap<String, String>>

  @Before
  fun setup() {
    MockitoAnnotations.initMocks(this)
  }

  @Test
  fun `counter delegates to engine`() {
    val pulseClient = PulseClientImpl(envoyEngine)
    val counter = pulseClient.counter(Element("test"), Element("stat"))
    counter.increment()
    val countCaptor = ArgumentCaptor.forClass(Int::class.java)
    verify(envoyEngine)
      .recordCounterInc(elementsCaptor.capture(), tagsCaptor.capture(), countCaptor.capture())
    assertThat(elementsCaptor.getValue()).isEqualTo("test.stat")
    assertThat(countCaptor.getValue()).isEqualTo(1)
    assertThat(tagsCaptor.getValue().size).isEqualTo(0)
  }

  @Test
  fun `counter delegates to engine with tags and count`() {
    val pulseClient = PulseClientImpl(envoyEngine)
    val counter =
      pulseClient.counter(
        Element("test"),
        Element("stat"),
        tags = TagsBuilder().add("testKey1", "testValue1").add("testKey2", "testValue2").build()
      )
    counter.increment(5)
    val countCaptor = ArgumentCaptor.forClass(Int::class.java)
    verify(envoyEngine)
      .recordCounterInc(elementsCaptor.capture(), tagsCaptor.capture(), countCaptor.capture())
    assertThat(elementsCaptor.getValue()).isEqualTo("test.stat")
    assertThat(countCaptor.getValue()).isEqualTo(5)

    val tagCaptorValue = tagsCaptor.getValue()
    assertThat(tagCaptorValue.get("testKey1")).isEqualTo("testValue1")
    assertThat(tagCaptorValue.get("testKey2")).isEqualTo("testValue2")
  }
}
package io.envoyproxy.envoymobile

import org.junit.Test

class ElementTest {

  @Test
  fun `creates new element as expected`() {
    // Should just work
    Element("foo")
  }

  @Test(expected = IllegalArgumentException::class)
  fun `throw exception when element name is rejected`() {
    // Should throw exception
    Element("foo9")
  }
}
package io.envoyproxy.envoymobile

import org.assertj.core.api.Assertions.assertThat
import org.junit.Test

class TagsBuilderTest {
  @Test
  fun `adds tags to tags`() {
    val tags = TagsBuilder().add("testKey", "testValue").build()
    assertThat(tags.allTags().size).isEqualTo(1)
    assertThat(tags.allTags().get("testKey")).isEqualTo("testValue")
  }

  @Test
  fun `puts a map of tags to tags`() {
    val tagsBuilder = TagsBuilder()
    val tagMap = mutableMapOf("testKey1" to "testValue1", "testKey2" to "testValue2")
    val tags = tagsBuilder.putAll(tagMap).build()
    assertThat(tags.allTags().size).isEqualTo(2)
    assertThat(tags.allTags().get("testKey1")).isEqualTo("testValue1")
    assertThat(tags.allTags().get("testKey2")).isEqualTo("testValue2")
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:kotlin_test.bzl", "envoy_mobile_kt_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_kt_test(
    name = "element_test",
    srcs = [
        "ElementTest.kt",
    ],
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)

envoy_mobile_kt_test(
    name = "tags_builder_test",
    srcs = [
        "TagsBuilderTest.kt",
    ],
    deps = [
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
    ],
)
workspace_type: android

directories:
  -bazel-bin
  -bazel-instant-android
  -bazel-out
  -bazel-testlogs
  -buck-out
  -build
  test/kotlin/apps/experimental

import_run_configurations:
  test/kotlin/apps/experimental/tools/android-studio-run-configurations/run_configuration_example_debug_x86.xml
  test/kotlin/apps/experimental/tools/android-studio-run-configurations/run_configuration_example_debug_arm64.xml

targets:
  //test/kotlin/apps/experimental:hello_envoy_kt

additional_languages:
  kotlin
  java
  android
  c
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context=".MainActivity">

    <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/recycler_view"
            android:background="@android:color/white"
            android:layout_width="match_parent"
            android:layout_height="match_parent"/>

</LinearLayout>
<configuration name="Experimental Test App (Debug) [arm64]"
    type="BlazeCommandRunConfigurationType"
    factoryName="Bazel Command"
    nameIsGenerated="false">
    <blaze-settings kind="android_binary"
        blaze-command="mobile-install"
        handler-id="BlazeCommandGenericRunConfigurationHandlerProvider"
        blaze-native-debug="true"
        DEEP_LINK=""
        ACTIVITY_CLASS=""
        MODE="default_activity"
        launch-method="NON_BLAZE"
        use-split-apks-if-possible="false"
        use-work-profile-if-present="false"
        show-logcat-automatically="false"
        AM_START_OPTIONS="">
        <blaze-user-flag>--config=mobile-dbg-android</blaze-user-flag>
        <blaze-user-flag>--fat_apk_cpu=arm64-v8a</blaze-user-flag>
        <blaze-target>//test/kotlin/apps/experimental:hello_envoy_kt</blaze-target>
        <Profilers>
            <option name="ADVANCED_PROFILING_ENABLED"
                value="false" />
            <option name="STARTUP_PROFILING_ENABLED"
                value="false" />
            <option name="STARTUP_CPU_PROFILING_ENABLED"
                value="false" />
            <option name="STARTUP_CPU_PROFILING_CONFIGURATION_NAME"
                value="Sample Java Methods" />
            <option name="STARTUP_NATIVE_MEMORY_PROFILING_ENABLED"
                value="false" />
            <option name="NATIVE_MEMORY_SAMPLE_RATE_BYTES"
                value="2048" />
        </Profilers>
    </blaze-settings>
    <method v="2">
        <option name="Blaze.BeforeRunTask"
            enabled="true" />
    </method>
</configuration>
<configuration name="Experimental Test App (Debug) [x86]"
    type="BlazeCommandRunConfigurationType"
    factoryName="Bazel Command"
    nameIsGenerated="false">
    <blaze-settings kind="android_binary"
        blaze-command="mobile-install"
        handler-id="BlazeCommandGenericRunConfigurationHandlerProvider"
        blaze-native-debug="true"
        DEEP_LINK=""
        ACTIVITY_CLASS=""
        MODE="default_activity"
        launch-method="NON_BLAZE"
        use-split-apks-if-possible="false"
        use-work-profile-if-present="false"
        show-logcat-automatically="false"
        AM_START_OPTIONS="">
        <blaze-user-flag>--config=mobile-dbg-android</blaze-user-flag>
        <blaze-user-flag>--fat_apk_cpu=x86</blaze-user-flag>
        <blaze-target>//test/kotlin/apps/experimental:hello_envoy_kt</blaze-target>
        <Profilers>
            <option name="ADVANCED_PROFILING_ENABLED"
                value="false" />
            <option name="STARTUP_PROFILING_ENABLED"
                value="false" />
            <option name="STARTUP_CPU_PROFILING_ENABLED"
                value="false" />
            <option name="STARTUP_CPU_PROFILING_CONFIGURATION_NAME"
                value="Sample Java Methods" />
            <option name="STARTUP_NATIVE_MEMORY_PROFILING_ENABLED"
                value="false" />
            <option name="NATIVE_MEMORY_SAMPLE_RATE_BYTES"
                value="2048" />
        </Profilers>
    </blaze-settings>
    <method v="2">
        <option name="Blaze.BeforeRunTask"
            enabled="true" />
    </method>
</configuration>
package io.envoyproxy.envoymobile.helloenvoyexperimentaltest

import android.app.Activity
import android.content.Context
import android.os.Bundle
import android.os.Handler
import android.os.HandlerThread
import android.util.Log
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import io.envoyproxy.envoymobile.AndroidEngineBuilder
import io.envoyproxy.envoymobile.Element
import io.envoyproxy.envoymobile.Engine
import io.envoyproxy.envoymobile.LogLevel
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.android.SharedPreferencesStore
import io.envoyproxy.envoymobile.shared.Failure
import io.envoyproxy.envoymobile.shared.ResponseRecyclerViewAdapter
import io.envoyproxy.envoymobile.shared.Success
import java.io.IOException
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

private const val REQUEST_HANDLER_THREAD_NAME = "hello_envoy_kt"
private const val REQUEST_AUTHORITY = "api.lyft.com"
private const val REQUEST_PATH = "/ping"
private const val REQUEST_SCHEME = "https"
private const val PERSISTENCE_KEY = "EnvoyMobilePersistenceKey"
private val FILTERED_HEADERS =
  setOf(
    "server",
    "filter-demo",
    "buffer-filter-demo",
    "async-filter-demo",
    "x-envoy-upstream-service-time"
  )

class MainActivity : Activity() {
  private val thread = HandlerThread(REQUEST_HANDLER_THREAD_NAME)
  private lateinit var recyclerView: RecyclerView
  private lateinit var viewAdapter: ResponseRecyclerViewAdapter
  private lateinit var engine: Engine

  @Suppress("MaxLineLength")
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    val preferences = getSharedPreferences(PERSISTENCE_KEY, Context.MODE_PRIVATE)

    engine =
      AndroidEngineBuilder(application)
        .addLogLevel(LogLevel.DEBUG)
        .addPlatformFilter(::DemoFilter)
        .addPlatformFilter(::BufferDemoFilter)
        .addPlatformFilter(::AsyncDemoFilter)
        .enableDNSCache(true)
        // required by DNS cache
        .addKeyValueStore("reserved.platform_store", SharedPreferencesStore(preferences))
        .enableInterfaceBinding(true)
        .enableSocketTagging(true)
        .enableProxying(true)
        // TODO: uncomment once platform cert validation is fixed.
        // .enablePlatformCertificatesValidation(true)
        .addNativeFilter(
          "envoy.filters.http.buffer",
          "{\"@type\":\"type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer\",\"max_request_bytes\":5242880}"
        )
        .addStringAccessor("demo-accessor", { "PlatformString" })
        .setOnEngineRunning { Log.d("MainActivity", "Envoy async internal setup completed") }
        .setEventTracker({
          for (entry in it.entries) {
            Log.d("MainActivity", "Event emitted: ${entry.key}, ${entry.value}")
          }
        })
        .setLogger { Log.d("MainActivity", it) }
        .build()

    recyclerView = findViewById(R.id.recycler_view) as RecyclerView
    recyclerView.layoutManager = LinearLayoutManager(this)

    viewAdapter = ResponseRecyclerViewAdapter()
    recyclerView.adapter = viewAdapter
    val dividerItemDecoration =
      DividerItemDecoration(recyclerView.context, DividerItemDecoration.VERTICAL)
    recyclerView.addItemDecoration(dividerItemDecoration)
    thread.start()
    val handler = Handler(thread.looper)

    // Run a request loop and record stats until the application exits.
    handler.postDelayed(
      object : Runnable {
        override fun run() {
          try {
            makeRequest()
            recordStats()
          } catch (e: IOException) {
            Log.d("MainActivity", "exception making request or recording stats", e)
          }

          // Make a call and report stats again
          handler.postDelayed(this, TimeUnit.SECONDS.toMillis(1))
        }
      },
      TimeUnit.SECONDS.toMillis(1)
    )
  }

  override fun onDestroy() {
    super.onDestroy()
    thread.quit()
  }

  private fun makeRequest() {
    // Note: this request will use an h2 stream for the upstream request.
    // The Java example uses http/1.1. This is done on purpose to test both paths in end-to-end
    // tests in CI.
    val requestHeaders =
      RequestHeadersBuilder(RequestMethod.GET, REQUEST_SCHEME, REQUEST_AUTHORITY, REQUEST_PATH)
        .addSocketTag(1, 2)
        .build()
    engine
      .streamClient()
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, _, _ ->
        val status = responseHeaders.httpStatus ?: 0L
        val message = "received headers with status $status"

        val sb = StringBuilder()
        for ((name, value) in responseHeaders.caseSensitiveHeaders()) {
          if (name in FILTERED_HEADERS) {
            sb.append(name).append(": ").append(value.joinToString()).append("\n")
          }
        }
        val headerText = sb.toString()

        Log.d("MainActivity", message)
        responseHeaders.value("filter-demo")?.first()?.let { filterDemoValue ->
          Log.d("MainActivity", "filter-demo: $filterDemoValue")
        }

        if (status == 200) {
          recyclerView.post { viewAdapter.add(Success(message, headerText)) }
        } else {
          recyclerView.post { viewAdapter.add(Failure(message)) }
        }
      }
      .setOnError { error, _ ->
        val attemptCount = error.attemptCount ?: -1
        val message = "failed with error after $attemptCount attempts: ${error.message}"
        Log.d("MainActivity", message)
        recyclerView.post { viewAdapter.add(Failure(message)) }
      }
      .start(Executors.newSingleThreadExecutor())
      .sendHeaders(requestHeaders, true)
  }

  private fun recordStats() {
    val counter = engine.pulseClient().counter(Element("foo"), Element("bar"), Element("counter"))
    counter.increment()
    counter.increment(5)
  }
}
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="io.envoyproxy.envoymobile.helloenvoyexperimentaltest"
          android:versionCode="1"
          android:versionName="0.1">
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>

    <uses-sdk
            android:minSdkVersion="21"
            android:targetSdkVersion="27"/>

    <application
            android:label="Hello Envoy Experimental Test">
        <activity
                android:name=".MainActivity"
                android:label="Hello Envoy Experimental Test">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
    </application>
</manifest>
package io.envoyproxy.envoymobile.helloenvoyexperimentaltest

import android.util.Log
import io.envoyproxy.envoymobile.EnvoyError
import io.envoyproxy.envoymobile.FilterDataStatus
import io.envoyproxy.envoymobile.FilterHeadersStatus
import io.envoyproxy.envoymobile.FilterTrailersStatus
import io.envoyproxy.envoymobile.FinalStreamIntel
import io.envoyproxy.envoymobile.ResponseFilter
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.ResponseTrailers
import io.envoyproxy.envoymobile.StreamIntel
import java.nio.ByteBuffer

class DemoFilter : ResponseFilter {
  override fun onResponseHeaders(
    headers: ResponseHeaders,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterHeadersStatus<ResponseHeaders> {
    Log.d("DemoFilter", "On headers!")
    val builder = headers.toResponseHeadersBuilder()
    builder.add("filter-demo", "1")
    return FilterHeadersStatus.Continue(builder.build())
  }

  override fun onResponseData(
    body: ByteBuffer,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterDataStatus<ResponseHeaders> {
    Log.d("DemoFilter", "On data!")
    return FilterDataStatus.Continue(body)
  }

  override fun onResponseTrailers(
    trailers: ResponseTrailers,
    streamIntel: StreamIntel
  ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
    Log.d("DemoFilter", "On trailers!")
    return FilterTrailersStatus.Continue(trailers)
  }

  override fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel) {
    Log.d("DemoFilter", "On error!")
  }

  override fun onCancel(finalStreamIntel: FinalStreamIntel) {
    Log.d("DemoFilter", "On cancel!")
  }

  @Suppress("EmptyFunctionBlock") override fun onComplete(finalStreamIntel: FinalStreamIntel) {}
}
For instructions on how to use this demo, please head over to our [docs](https://envoymobile.io/docs/envoy-mobile/latest/start/examples/hello_world.html).
package io.envoyproxy.envoymobile.helloenvoyexperimentaltest

import io.envoyproxy.envoymobile.AsyncResponseFilter
import io.envoyproxy.envoymobile.EnvoyError
import io.envoyproxy.envoymobile.FilterDataStatus
import io.envoyproxy.envoymobile.FilterHeadersStatus
import io.envoyproxy.envoymobile.FilterResumeStatus
import io.envoyproxy.envoymobile.FilterTrailersStatus
import io.envoyproxy.envoymobile.FinalStreamIntel
import io.envoyproxy.envoymobile.ResponseFilterCallbacks
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.ResponseTrailers
import io.envoyproxy.envoymobile.StreamIntel
import java.nio.ByteBuffer
import java.util.Timer
import kotlin.concurrent.schedule

/**
 * Example of a more complex HTTP filter that pauses processing on the response filter chain,
 * buffers until the response is complete, then asynchronously triggers filter chain resumption
 * while setting a new header. Also demonstrates safety of re-entrancy in async callbacks.
 */
class AsyncDemoFilter : AsyncResponseFilter {
  private lateinit var callbacks: ResponseFilterCallbacks

  override fun onResponseHeaders(
    headers: ResponseHeaders,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterHeadersStatus<ResponseHeaders> {
    // If this is the end of the stream, asynchronously resume response processing via callback.
    if (endStream) {
      Timer("AsyncResume", false).schedule(100) { callbacks.resumeResponse() }
    }
    return FilterHeadersStatus.StopIteration()
  }

  override fun onResponseData(
    body: ByteBuffer,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterDataStatus<ResponseHeaders> {
    // If this is the end of the stream, asynchronously resume response processing via callback.
    if (endStream) {
      Timer("AsyncResume", false).schedule(100) { callbacks.resumeResponse() }
    }
    return FilterDataStatus.StopIterationAndBuffer()
  }

  override fun onResponseTrailers(
    trailers: ResponseTrailers,
    streamIntel: StreamIntel
  ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
    // Trailers imply end of stream, so asynchronously resume response processing via callbacka
    Timer("AsyncResume", false).schedule(100) { callbacks.resumeResponse() }
    return FilterTrailersStatus.StopIteration()
  }

  override fun setResponseFilterCallbacks(callbacks: ResponseFilterCallbacks) {
    this.callbacks = callbacks
  }

  override fun onResumeResponse(
    headers: ResponseHeaders?,
    data: ByteBuffer?,
    trailers: ResponseTrailers?,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterResumeStatus<ResponseHeaders, ResponseTrailers> {
    val builder = headers!!.toResponseHeadersBuilder().add("async-filter-demo", "1")
    return FilterResumeStatus.ResumeIteration(builder.build(), data, trailers)
  }

  @Suppress("EmptyFunctionBlock")
  override fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel) {}

  @Suppress("EmptyFunctionBlock") override fun onCancel(finalStreamIntel: FinalStreamIntel) {}

  @Suppress("EmptyFunctionBlock") override fun onComplete(finalStreamIntel: FinalStreamIntel) {}
}
load("@build_bazel_rules_android//android:rules.bzl", "android_binary")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@io_bazel_rules_kotlin//kotlin:android.bzl", "kt_android_library")
load("@rules_detekt//detekt:defs.bzl", "detekt")
load("@rules_jvm_external//:defs.bzl", "artifact")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

android_binary(
    name = "hello_envoy_kt",
    custom_package = "io.envoyproxy.envoymobile.helloenvoyexperimentaltest",
    manifest = "AndroidManifest.xml",
    proguard_specs = ["//library:proguard_rules"],
    deps = [
        "hello_envoy_kt_lib",
    ],
)

kt_android_library(
    name = "hello_envoy_kt_lib",
    srcs = [
        "AsyncDemoFilter.kt",
        "BufferDemoFilter.kt",
        "DemoFilter.kt",
        "MainActivity.kt",
    ],
    custom_package = "io.envoyproxy.envoymobile.helloenvoyexperimentaltest",
    manifest = "AndroidManifest.xml",
    resource_files = [
        "res/layout/activity_main.xml",
    ],
    deps = [
        "//:envoy_mobile_android",
        "//examples/kotlin/shared:hello_envoy_shared_lib",
        artifact("androidx.recyclerview:recyclerview"),
        artifact("androidx.annotation:annotation"),
        artifact("com.google.code.findbugs:jsr305"),
        artifact("com.google.protobuf:protobuf-javalite"),
    ],
)

detekt(
    name = "hello_envoy_kt_lint",
    srcs = glob(["*.kt"]),
    build_upon_default_config = True,
    cfgs = ["//:kotlin_lint_config"],
)
package io.envoyproxy.envoymobile.helloenvoyexperimentaltest

import io.envoyproxy.envoymobile.EnvoyError
import io.envoyproxy.envoymobile.FilterDataStatus
import io.envoyproxy.envoymobile.FilterHeadersStatus
import io.envoyproxy.envoymobile.FilterTrailersStatus
import io.envoyproxy.envoymobile.FinalStreamIntel
import io.envoyproxy.envoymobile.ResponseFilter
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.ResponseTrailers
import io.envoyproxy.envoymobile.StreamIntel
import java.nio.ByteBuffer

/**
 * Example of a more complex HTTP filter that pauses processing on the response filter chain,
 * buffers until the response is complete, then resumes filter iteration while setting a new header.
 */
class BufferDemoFilter : ResponseFilter {
  private lateinit var headers: ResponseHeaders
  private lateinit var body: ByteBuffer

  override fun onResponseHeaders(
    headers: ResponseHeaders,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterHeadersStatus<ResponseHeaders> {
    this.headers = headers
    return FilterHeadersStatus.StopIteration()
  }

  override fun onResponseData(
    body: ByteBuffer,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterDataStatus<ResponseHeaders> {
    // Since we request buffering, each invocation will include all data buffered so far.
    this.body = body

    // If this is the end of the stream, resume processing of the (now fully-buffered) response.
    if (endStream) {
      val builder = headers.toResponseHeadersBuilder().add("buffer-filter-demo", "1")
      return FilterDataStatus.ResumeIteration(builder.build(), body)
    }
    return FilterDataStatus.StopIterationAndBuffer()
  }

  override fun onResponseTrailers(
    trailers: ResponseTrailers,
    streamIntel: StreamIntel
  ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
    // Trailers imply end of stream; resume processing of the (now fully-buffered) response.
    val builder = headers.toResponseHeadersBuilder().add("buffer-filter-demo", "1")
    return FilterTrailersStatus.ResumeIteration(builder.build(), this.body, trailers)
  }

  @Suppress("EmptyFunctionBlock")
  override fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel) {}

  @Suppress("EmptyFunctionBlock") override fun onCancel(finalStreamIntel: FinalStreamIntel) {}

  @Suppress("EmptyFunctionBlock") override fun onComplete(finalStreamIntel: FinalStreamIntel) {}
}
workspace_type: android

bazel_binary: bazelw

directories:
  -bazel-bin
  -bazel-instant-android
  -bazel-out
  -bazel-testlogs
  -buck-out
  -build
  test/kotlin/apps/baseline/

import_run_configurations:
  test/kotlin/apps/baseline/tools/android-studio-run-configurations/run_configuration_example_debug_x86.xml
  test/kotlin/apps/baseline/tools/android-studio-run-configurations/run_configuration_example_debug_arm64.xml

targets:
  //test/kotlin/apps/baseline:hello_envoy_kt

additional_languages:
  kotlin
  java
  android
  c
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context=".MainActivity">

    <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/recycler_view"
            android:background="@android:color/white"
            android:layout_width="match_parent"
            android:layout_height="match_parent"/>

</LinearLayout>
<configuration name="Baseline Test App (Debug) [arm64]"
    type="BlazeCommandRunConfigurationType"
    factoryName="Bazel Command"
    nameIsGenerated="false">
    <blaze-settings kind="android_binary"
        blaze-command="mobile-install"
        handler-id="BlazeCommandGenericRunConfigurationHandlerProvider"
        blaze-native-debug="true"
        DEEP_LINK=""
        ACTIVITY_CLASS=""
        MODE="default_activity"
        launch-method="NON_BLAZE"
        use-split-apks-if-possible="false"
        use-work-profile-if-present="false"
        show-logcat-automatically="false"
        AM_START_OPTIONS="">
        <blaze-user-flag>--config=mobile-dbg-android</blaze-user-flag>
        <blaze-user-flag>--fat_apk_cpu=arm64-v8a</blaze-user-flag>
        <blaze-target>//test/kotlin/apps/baseline:hello_envoy_kt</blaze-target>
        <Profilers>
            <option name="ADVANCED_PROFILING_ENABLED"
                value="false" />
            <option name="STARTUP_PROFILING_ENABLED"
                value="false" />
            <option name="STARTUP_CPU_PROFILING_ENABLED"
                value="false" />
            <option name="STARTUP_CPU_PROFILING_CONFIGURATION_NAME"
                value="Sample Java Methods" />
            <option name="STARTUP_NATIVE_MEMORY_PROFILING_ENABLED"
                value="false" />
            <option name="NATIVE_MEMORY_SAMPLE_RATE_BYTES"
                value="2048" />
        </Profilers>
    </blaze-settings>
    <method v="2">
        <option name="Blaze.BeforeRunTask"
            enabled="true" />
    </method>
</configuration>
<configuration name="Baseline Test App (Debug) [x86]"
    type="BlazeCommandRunConfigurationType"
    factoryName="Bazel Command"
    nameIsGenerated="false">
    <blaze-settings kind="android_binary"
        blaze-command="mobile-install"
        handler-id="BlazeCommandGenericRunConfigurationHandlerProvider"
        blaze-native-debug="true"
        DEEP_LINK=""
        ACTIVITY_CLASS=""
        MODE="default_activity"
        launch-method="NON_BLAZE"
        use-split-apks-if-possible="false"
        use-work-profile-if-present="false"
        show-logcat-automatically="false"
        AM_START_OPTIONS="">
        <blaze-user-flag>--config=mobile-dbg-android</blaze-user-flag>
        <blaze-user-flag>--fat_apk_cpu=x86</blaze-user-flag>
        <blaze-target>//test/kotlin/apps/baseline:hello_envoy_kt</blaze-target>
        <Profilers>
            <option name="ADVANCED_PROFILING_ENABLED"
                value="false" />
            <option name="STARTUP_PROFILING_ENABLED"
                value="false" />
            <option name="STARTUP_CPU_PROFILING_ENABLED"
                value="false" />
            <option name="STARTUP_CPU_PROFILING_CONFIGURATION_NAME"
                value="Sample Java Methods" />
            <option name="STARTUP_NATIVE_MEMORY_PROFILING_ENABLED"
                value="false" />
            <option name="NATIVE_MEMORY_SAMPLE_RATE_BYTES"
                value="2048" />
        </Profilers>
    </blaze-settings>
    <method v="2">
        <option name="Blaze.BeforeRunTask"
            enabled="true" />
    </method>
</configuration>
package io.envoyproxy.envoymobile.helloenvoybaselinetest

import android.app.Activity
import android.os.Bundle
import android.os.Handler
import android.os.HandlerThread
import android.util.Log
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import io.envoyproxy.envoymobile.AndroidEngineBuilder
import io.envoyproxy.envoymobile.Element
import io.envoyproxy.envoymobile.Engine
import io.envoyproxy.envoymobile.LogLevel
import io.envoyproxy.envoymobile.RequestHeadersBuilder
import io.envoyproxy.envoymobile.RequestMethod
import io.envoyproxy.envoymobile.shared.Failure
import io.envoyproxy.envoymobile.shared.ResponseRecyclerViewAdapter
import io.envoyproxy.envoymobile.shared.Success
import java.io.IOException
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

private const val REQUEST_HANDLER_THREAD_NAME = "hello_envoy_kt"
private const val REQUEST_AUTHORITY = "api.lyft.com"
private const val REQUEST_PATH = "/ping"
private const val REQUEST_SCHEME = "http"
private val FILTERED_HEADERS =
  setOf(
    "server",
    "filter-demo",
    "buffer-filter-demo",
    "async-filter-demo",
    "x-envoy-upstream-service-time"
  )

class MainActivity : Activity() {
  private val thread = HandlerThread(REQUEST_HANDLER_THREAD_NAME)
  private lateinit var recyclerView: RecyclerView
  private lateinit var viewAdapter: ResponseRecyclerViewAdapter
  private lateinit var engine: Engine

  @Suppress("MaxLineLength")
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    engine =
      AndroidEngineBuilder(application)
        .addLogLevel(LogLevel.DEBUG)
        .addPlatformFilter(::DemoFilter)
        .addNativeFilter(
          "envoy.filters.http.buffer",
          "{\"@type\":\"type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer\",\"max_request_bytes\":5242880}"
        )
        .addStringAccessor("demo-accessor", { "PlatformString" })
        .setOnEngineRunning { Log.d("MainActivity", "Envoy async internal setup completed") }
        .setEventTracker({
          for (entry in it.entries) {
            Log.d("MainActivity", "Event emitted: ${entry.key}, ${entry.value}")
          }
        })
        .setLogger { Log.d("MainActivity", it) }
        .build()

    recyclerView = findViewById(R.id.recycler_view) as RecyclerView
    recyclerView.layoutManager = LinearLayoutManager(this)

    viewAdapter = ResponseRecyclerViewAdapter()
    recyclerView.adapter = viewAdapter
    val dividerItemDecoration =
      DividerItemDecoration(recyclerView.context, DividerItemDecoration.VERTICAL)
    recyclerView.addItemDecoration(dividerItemDecoration)
    thread.start()
    val handler = Handler(thread.looper)

    // Run a request loop and record stats until the application exits.
    handler.postDelayed(
      object : Runnable {
        override fun run() {
          try {
            makeRequest()
            recordStats()
          } catch (e: IOException) {
            Log.d("MainActivity", "exception making request or recording stats", e)
          }

          // Make a call and report stats again
          handler.postDelayed(this, TimeUnit.SECONDS.toMillis(1))
        }
      },
      TimeUnit.SECONDS.toMillis(1)
    )
  }

  override fun onDestroy() {
    super.onDestroy()
    thread.quit()
  }

  private fun makeRequest() {
    // Note: this request will use an h2 stream for the upstream request.
    // The Java example uses http/1.1. This is done on purpose to test both paths in end-to-end
    // tests in CI.
    val requestHeaders =
      RequestHeadersBuilder(RequestMethod.GET, REQUEST_SCHEME, REQUEST_AUTHORITY, REQUEST_PATH)
        .build()
    engine
      .streamClient()
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, _, _ ->
        val status = responseHeaders.httpStatus ?: 0L
        val message = "received headers with status $status"

        val sb = StringBuilder()
        for ((name, value) in responseHeaders.caseSensitiveHeaders()) {
          if (name in FILTERED_HEADERS) {
            sb.append(name).append(": ").append(value.joinToString()).append("\n")
          }
        }
        val headerText = sb.toString()

        Log.d("MainActivity", message)
        responseHeaders.value("filter-demo")?.first()?.let { filterDemoValue ->
          Log.d("MainActivity", "filter-demo: $filterDemoValue")
        }

        // The endpoint redirects http://api.lyft.com/ping to https with a 301
        // .github/workflows/android_build.yml is hard-coded to only accept 301s so if changing this
        // code update the expected status code there.
        if (status == 301) {
          recyclerView.post { viewAdapter.add(Success(message, headerText)) }
        } else {
          recyclerView.post { viewAdapter.add(Failure(message)) }
        }
      }
      .setOnError { error, _ ->
        val attemptCount = error.attemptCount ?: -1
        val message = "failed with error after $attemptCount attempts: ${error.message}"
        Log.d("MainActivity", message)
        recyclerView.post { viewAdapter.add(Failure(message)) }
      }
      .start(Executors.newSingleThreadExecutor())
      .sendHeaders(requestHeaders, true)
  }

  private fun recordStats() {
    val counter = engine.pulseClient().counter(Element("foo"), Element("bar"), Element("counter"))
    counter.increment()
    counter.increment(5)
  }
}
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="io.envoyproxy.envoymobile.helloenvoybaselinetest"
          android:versionCode="1"
          android:versionName="0.1">
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>

    <uses-sdk
            android:minSdkVersion="21"
            android:targetSdkVersion="27"/>

    <application
            android:label="Hello Envoy Baseline Test">
        <activity
                android:name=".MainActivity"
                android:label="Hello Envoy Baseline Test">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
    </application>
</manifest>
package io.envoyproxy.envoymobile.helloenvoybaselinetest

import android.util.Log
import io.envoyproxy.envoymobile.EnvoyError
import io.envoyproxy.envoymobile.FilterDataStatus
import io.envoyproxy.envoymobile.FilterHeadersStatus
import io.envoyproxy.envoymobile.FilterTrailersStatus
import io.envoyproxy.envoymobile.FinalStreamIntel
import io.envoyproxy.envoymobile.ResponseFilter
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.ResponseTrailers
import io.envoyproxy.envoymobile.StreamIntel
import java.nio.ByteBuffer

class DemoFilter : ResponseFilter {
  override fun onResponseHeaders(
    headers: ResponseHeaders,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterHeadersStatus<ResponseHeaders> {
    Log.d("DemoFilter", "On headers!")
    val builder = headers.toResponseHeadersBuilder()
    builder.add("filter-demo", "1")
    return FilterHeadersStatus.Continue(builder.build())
  }

  override fun onResponseData(
    body: ByteBuffer,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterDataStatus<ResponseHeaders> {
    Log.d("DemoFilter", "On data!")
    return FilterDataStatus.Continue(body)
  }

  override fun onResponseTrailers(
    trailers: ResponseTrailers,
    streamIntel: StreamIntel
  ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
    Log.d("DemoFilter", "On trailers!")
    return FilterTrailersStatus.Continue(trailers)
  }

  override fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel) {
    Log.d("DemoFilter", "On error!")
  }

  override fun onCancel(finalStreamIntel: FinalStreamIntel) {
    Log.d("DemoFilter", "On cancel!")
  }

  @Suppress("EmptyFunctionBlock") override fun onComplete(finalStreamIntel: FinalStreamIntel) {}
}
For instructions on how to use this demo, please head over to our [docs](https://envoymobile.io/docs/envoy-mobile/latest/start/examples/hello_world.html).
package io.envoyproxy.envoymobile.helloenvoybaselinetest

import io.envoyproxy.envoymobile.AsyncResponseFilter
import io.envoyproxy.envoymobile.EnvoyError
import io.envoyproxy.envoymobile.FilterDataStatus
import io.envoyproxy.envoymobile.FilterHeadersStatus
import io.envoyproxy.envoymobile.FilterResumeStatus
import io.envoyproxy.envoymobile.FilterTrailersStatus
import io.envoyproxy.envoymobile.FinalStreamIntel
import io.envoyproxy.envoymobile.ResponseFilterCallbacks
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.ResponseTrailers
import io.envoyproxy.envoymobile.StreamIntel
import java.nio.ByteBuffer
import java.util.Timer
import kotlin.concurrent.schedule

/**
 * Example of a more complex HTTP filter that pauses processing on the response filter chain,
 * buffers until the response is complete, then asynchronously triggers filter chain resumption
 * while setting a new header. Also demonstrates safety of re-entrancy in async callbacks.
 */
class AsyncDemoFilter : AsyncResponseFilter {
  private lateinit var callbacks: ResponseFilterCallbacks

  override fun onResponseHeaders(
    headers: ResponseHeaders,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterHeadersStatus<ResponseHeaders> {
    // If this is the end of the stream, asynchronously resume response processing via callback.
    if (endStream) {
      Timer("AsyncResume", false).schedule(100) { callbacks.resumeResponse() }
    }
    return FilterHeadersStatus.StopIteration()
  }

  override fun onResponseData(
    body: ByteBuffer,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterDataStatus<ResponseHeaders> {
    // If this is the end of the stream, asynchronously resume response processing via callback.
    if (endStream) {
      Timer("AsyncResume", false).schedule(100) { callbacks.resumeResponse() }
    }
    return FilterDataStatus.StopIterationAndBuffer()
  }

  override fun onResponseTrailers(
    trailers: ResponseTrailers,
    streamIntel: StreamIntel
  ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
    // Trailers imply end of stream, so asynchronously resume response processing via callbacka
    Timer("AsyncResume", false).schedule(100) { callbacks.resumeResponse() }
    return FilterTrailersStatus.StopIteration()
  }

  override fun setResponseFilterCallbacks(callbacks: ResponseFilterCallbacks) {
    this.callbacks = callbacks
  }

  override fun onResumeResponse(
    headers: ResponseHeaders?,
    data: ByteBuffer?,
    trailers: ResponseTrailers?,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterResumeStatus<ResponseHeaders, ResponseTrailers> {
    val builder = headers!!.toResponseHeadersBuilder().add("async-filter-demo", "1")
    return FilterResumeStatus.ResumeIteration(builder.build(), data, trailers)
  }

  @Suppress("EmptyFunctionBlock")
  override fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel) {}

  @Suppress("EmptyFunctionBlock") override fun onCancel(finalStreamIntel: FinalStreamIntel) {}

  @Suppress("EmptyFunctionBlock") override fun onComplete(finalStreamIntel: FinalStreamIntel) {}
}
load("@build_bazel_rules_android//android:rules.bzl", "android_binary")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@io_bazel_rules_kotlin//kotlin:android.bzl", "kt_android_library")
load("@rules_detekt//detekt:defs.bzl", "detekt")
load("@rules_jvm_external//:defs.bzl", "artifact")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

android_binary(
    name = "hello_envoy_kt",
    custom_package = "io.envoyproxy.envoymobile.helloenvoybaselinetest",
    manifest = "AndroidManifest.xml",
    proguard_specs = ["//library:proguard_rules"],
    deps = [
        "hello_envoy_kt_lib",
    ],
)

kt_android_library(
    name = "hello_envoy_kt_lib",
    srcs = [
        "AsyncDemoFilter.kt",
        "BufferDemoFilter.kt",
        "DemoFilter.kt",
        "MainActivity.kt",
    ],
    custom_package = "io.envoyproxy.envoymobile.helloenvoybaselinetest",
    manifest = "AndroidManifest.xml",
    resource_files = [
        "res/layout/activity_main.xml",
    ],
    deps = [
        "//:envoy_mobile_android",
        "//examples/kotlin/shared:hello_envoy_shared_lib",
        artifact("androidx.recyclerview:recyclerview"),
        artifact("androidx.annotation:annotation"),
        artifact("com.google.code.findbugs:jsr305"),
        artifact("com.google.protobuf:protobuf-javalite"),
    ],
)

detekt(
    name = "hello_envoy_kt_lint",
    srcs = glob(["*.kt"]),
    build_upon_default_config = True,
    cfgs = ["//:kotlin_lint_config"],
)
package io.envoyproxy.envoymobile.helloenvoybaselinetest

import io.envoyproxy.envoymobile.EnvoyError
import io.envoyproxy.envoymobile.FilterDataStatus
import io.envoyproxy.envoymobile.FilterHeadersStatus
import io.envoyproxy.envoymobile.FilterTrailersStatus
import io.envoyproxy.envoymobile.FinalStreamIntel
import io.envoyproxy.envoymobile.ResponseFilter
import io.envoyproxy.envoymobile.ResponseHeaders
import io.envoyproxy.envoymobile.ResponseTrailers
import io.envoyproxy.envoymobile.StreamIntel
import java.nio.ByteBuffer

/**
 * Example of a more complex HTTP filter that pauses processing on the response filter chain,
 * buffers until the response is complete, then resumes filter iteration while setting a new header.
 */
class BufferDemoFilter : ResponseFilter {
  private lateinit var headers: ResponseHeaders
  private lateinit var body: ByteBuffer

  override fun onResponseHeaders(
    headers: ResponseHeaders,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterHeadersStatus<ResponseHeaders> {
    this.headers = headers
    return FilterHeadersStatus.StopIteration()
  }

  override fun onResponseData(
    body: ByteBuffer,
    endStream: Boolean,
    streamIntel: StreamIntel
  ): FilterDataStatus<ResponseHeaders> {
    // Since we request buffering, each invocation will include all data buffered so far.
    this.body = body

    // If this is the end of the stream, resume processing of the (now fully-buffered) response.
    if (endStream) {
      val builder = headers.toResponseHeadersBuilder().add("buffer-filter-demo", "1")
      return FilterDataStatus.ResumeIteration(builder.build(), body)
    }
    return FilterDataStatus.StopIterationAndBuffer()
  }

  override fun onResponseTrailers(
    trailers: ResponseTrailers,
    streamIntel: StreamIntel
  ): FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
    // Trailers imply end of stream; resume processing of the (now fully-buffered) response.
    val builder = headers.toResponseHeadersBuilder().add("buffer-filter-demo", "1")
    return FilterTrailersStatus.ResumeIteration(builder.build(), this.body, trailers)
  }

  @Suppress("EmptyFunctionBlock")
  override fun onError(error: EnvoyError, finalStreamIntel: FinalStreamIntel) {}

  @Suppress("EmptyFunctionBlock") override fun onCancel(finalStreamIntel: FinalStreamIntel) {}

  @Suppress("EmptyFunctionBlock") override fun onComplete(finalStreamIntel: FinalStreamIntel) {}
}
#include "test/common/mocks/common/mocks.h"

namespace Envoy {
namespace test {

using testing::_;
using testing::Return;

MockSystemHelper::MockSystemHelper() {
  ON_CALL(*this, isCleartextPermitted(_)).WillByDefault(Return(true));
  envoy_cert_validation_result success;
  success.result = ENVOY_SUCCESS;
  success.tls_alert = 0;
  success.error_details = "";
  ON_CALL(*this, validateCertificateChain(_, _)).WillByDefault(Return(success));
}

} // namespace test
} // namespace Envoy
#pragma once

#include "gmock/gmock.h"
#include "library/common/common/system_helper.h"

namespace Envoy {
namespace test {

// Mock implementation of SystemHelper.
class MockSystemHelper : public SystemHelper {
public:
  MockSystemHelper();

  // SystemHelper:
  MOCK_METHOD(bool, isCleartextPermitted, (absl::string_view hostname));
  MOCK_METHOD(envoy_cert_validation_result, validateCertificateChain,
              (const std::vector<std::string>& certs, absl::string_view hostname));
  MOCK_METHOD(void, cleanupAfterCertificateValidation, ());
};

// SystemHelperPeer allows the replacement of the SystemHelper singleton
// with a MockSystemHelper.
class SystemHelperPeer {
public:
  class Handle;

  // Replaces the SystemHelper singleton with a new MockSystemHelper which is
  // wrapped in a Handle. The MockSystemHelper can be accessed via the
  // Handle's `mock_helper()` accessor.
  static std::unique_ptr<Handle> replaceSystemHelper() { return std::make_unique<Handle>(); }

  // RAII type for replacing the SystemHelper singleton with a the MockSystemHelper.
  // When this object is destroyed, it resets the SystemHelper singleton back
  // to the previous state.
  class Handle {
  public:
    Handle() {
      previous_ = std::make_unique<test::MockSystemHelper>();
      SystemHelper::instance_.swap(previous_);
    }

    ~Handle() { SystemHelper::instance_ = std::move(previous_); }

    test::MockSystemHelper& mock_helper() {
      return *static_cast<test::MockSystemHelper*>(SystemHelper::instance_.get());
    }

  private:
    std::unique_ptr<SystemHelper> previous_;
  };
};

} // namespace test
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_mock",
    "envoy_mobile_package",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_mock(
    name = "common_mocks",
    srcs = ["mocks.cc"],
    hdrs = ["mocks.h"],
    repository = "@envoy",
    deps = [
        "//library/common/common:system_helper_lib",
    ],
)
#include "mocks.h"

#include "gmock/gmock.h"
#include "gtest/gtest.h"

using testing::_;
using testing::Assign;
using testing::DoAll;
using testing::Invoke;
using testing::NiceMock;
using testing::Return;
using testing::ReturnNew;
using testing::ReturnPointee;
using testing::SaveArg;

namespace Envoy {
namespace Event {

MockProvisionalDispatcher::MockProvisionalDispatcher() {
  ON_CALL(*this, timeSource()).WillByDefault(testing::ReturnRef(time_system_));
}
} // namespace Event
} // namespace Envoy
#pragma once

#include <chrono>
#include <cstdint>
#include <functional>
#include <list>

#include "envoy/event/deferred_deletable.h"
#include "envoy/event/dispatcher.h"

#include "test/test_common/test_time.h"

#include "gmock/gmock.h"
#include "library/common/event/provisional_dispatcher.h"

namespace Envoy {
namespace Event {

class MockProvisionalDispatcher : public ProvisionalDispatcher {
public:
  MockProvisionalDispatcher();
  ~MockProvisionalDispatcher() override = default;

  // ProvisionalDispatcher
  void deferredDelete(DeferredDeletablePtr&& to_delete) override {
    deferredDelete_(to_delete.get());
    if (to_delete) {
      to_delete_.push_back(std::move(to_delete));
    }
  }

  envoy_status_t post(Event::PostCb callback) override { return post_(std::move(callback)); }

  // Event::ProvisionalDispatcher
  MOCK_METHOD(void, drain, (Event::Dispatcher & event_dispatcher));
  MOCK_METHOD(void, deferredDelete_, (DeferredDeletable * to_delete));
  MOCK_METHOD(envoy_status_t, post_, (Event::PostCb callback));
  MOCK_METHOD(Event::SchedulableCallbackPtr, createSchedulableCallback, (std::function<void()> cb));
  MOCK_METHOD(bool, isThreadSafe, (), (const));
  MOCK_METHOD(void, pushTrackedObject, (const ScopeTrackedObject* object));
  MOCK_METHOD(void, popTrackedObject, (const ScopeTrackedObject* expected_object));
  MOCK_METHOD(bool, trackedObjectStackIsEmpty, (), (const));
  MOCK_METHOD(TimeSource&, timeSource, ());

  Event::GlobalTimeSystem time_system_;
  std::list<DeferredDeletablePtr> to_delete_;
};

} // namespace Event
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_mock",
    "envoy_mobile_package",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_mock(
    name = "event_mocks",
    srcs = ["mocks.cc"],
    hdrs = ["mocks.h"],
    repository = "@envoy",
    deps = [
        "//library/common/event:provisional_dispatcher_lib",
        "@envoy//envoy/event:deferred_deletable",
        "@envoy//envoy/event:dispatcher_interface",
        "@envoy//test/test_common:test_time_lib",
    ],
)
#include "source/common/stream_info/stream_info_impl.h"

#include "test/test_common/simulated_time_system.h"

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "library/common/stream_info/extra_stream_info.h"

namespace Envoy {
namespace StreamInfo {

static constexpr uint64_t SYSTEM_TIME_START_MS = 10000;
static constexpr uint64_t MONOTONIC_TIME_START_MS = 1000;

class StalledTimeSource : public TimeSource {
public:
  StalledTimeSource(uint64_t system_time_ms, uint64_t monotonic_time_ms) {
    stalled_system_time_ = SystemTime(std::chrono::milliseconds(system_time_ms));
    stalled_monotonic_time_ = MonotonicTime(std::chrono::milliseconds(monotonic_time_ms));
  }
  SystemTime systemTime() override { return stalled_system_time_; }
  MonotonicTime monotonicTime() override { return stalled_monotonic_time_; }

private:
  SystemTime stalled_system_time_;
  MonotonicTime stalled_monotonic_time_;
};

class FinalIntelTest : public testing::Test {
public:
  void checkEquality(envoy_final_stream_intel& a, envoy_final_stream_intel& b) {
    EXPECT_EQ(a.sending_start_ms, b.sending_start_ms);
    EXPECT_EQ(a.sending_end_ms, b.sending_end_ms);
    EXPECT_EQ(a.connect_start_ms, b.connect_start_ms);
    EXPECT_EQ(a.connect_end_ms, b.connect_end_ms);
    EXPECT_EQ(a.ssl_start_ms, b.ssl_start_ms);
    EXPECT_EQ(a.ssl_end_ms, b.ssl_end_ms);
    EXPECT_EQ(a.socket_reused, b.socket_reused);
    EXPECT_EQ(a.stream_start_ms, b.stream_start_ms);
    EXPECT_EQ(a.stream_end_ms, b.stream_end_ms);
    EXPECT_EQ(a.dns_start_ms, b.dns_start_ms);
    EXPECT_EQ(a.dns_end_ms, b.dns_end_ms);
    EXPECT_EQ(a.sent_byte_count, b.sent_byte_count);
    EXPECT_EQ(a.received_byte_count, b.received_byte_count);
  }
  StalledTimeSource start_time_source_{SYSTEM_TIME_START_MS, MONOTONIC_TIME_START_MS};
  envoy_final_stream_intel final_intel_{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, -1};
  envoy_final_stream_intel expected_intel_{-1, -1, -1, -1, -1, -1, -1, -1,
                                           -1, -1, -1, 0,  0,  0,  0,  -1};
};

TEST_F(FinalIntelTest, Unset) {
  StreamInfoImpl stream_info{Http::Protocol::Http2, start_time_source_, nullptr};
  // By convention the "StreamInfoImpl instantiation" is when the request starts.
  expected_intel_.stream_start_ms = SYSTEM_TIME_START_MS;
  // The SystemTime (11111) is irrelevant for the fake_current_time.
  StalledTimeSource fake_current_time(11111, MONOTONIC_TIME_START_MS + 500);
  expected_intel_.stream_end_ms = SYSTEM_TIME_START_MS + 500;

  setFinalStreamIntel(stream_info, fake_current_time, final_intel_);

  checkEquality(final_intel_, expected_intel_);
}

TEST_F(FinalIntelTest, SetWithSsl) {
  StreamInfoImpl stream_info{Http::Protocol::Http2, start_time_source_, nullptr};
  stream_info.setUpstreamInfo(std::make_shared<UpstreamInfoImpl>());
  auto upstream_info = stream_info.upstreamInfo();
  auto& timing = upstream_info->upstreamTiming();

  upstream_info->setUpstreamProtocol(Http::Protocol::Http2);
  expected_intel_.upstream_protocol = 2;

  expected_intel_.stream_start_ms = SYSTEM_TIME_START_MS;
  timing.first_upstream_tx_byte_sent_ =
      MonotonicTime(std::chrono::milliseconds(MONOTONIC_TIME_START_MS + 100));
  expected_intel_.sending_start_ms = SYSTEM_TIME_START_MS + 100;
  timing.last_upstream_tx_byte_sent_ =
      MonotonicTime(std::chrono::milliseconds(MONOTONIC_TIME_START_MS + 200));
  expected_intel_.sending_end_ms = SYSTEM_TIME_START_MS + 200;
  timing.first_upstream_rx_byte_received_ =
      MonotonicTime(std::chrono::milliseconds(MONOTONIC_TIME_START_MS + 300));
  expected_intel_.response_start_ms = SYSTEM_TIME_START_MS + 300;
  timing.upstream_connect_start_ =
      MonotonicTime(std::chrono::milliseconds(MONOTONIC_TIME_START_MS + 400));
  expected_intel_.connect_start_ms = SYSTEM_TIME_START_MS + 400;
  timing.upstream_connect_complete_ =
      MonotonicTime(std::chrono::milliseconds(MONOTONIC_TIME_START_MS + 500));
  expected_intel_.connect_end_ms = SYSTEM_TIME_START_MS + 500;
  expected_intel_.ssl_start_ms = SYSTEM_TIME_START_MS + 500;
  timing.upstream_handshake_complete_ =
      MonotonicTime(std::chrono::milliseconds(MONOTONIC_TIME_START_MS + 600));
  expected_intel_.ssl_end_ms = SYSTEM_TIME_START_MS + 600;
  StalledTimeSource fake_current_time(11111, MONOTONIC_TIME_START_MS + 700);
  expected_intel_.stream_end_ms = SYSTEM_TIME_START_MS + 700;

  upstream_info->setUpstreamNumStreams(5);
  expected_intel_.socket_reused = 1;

  setFinalStreamIntel(stream_info, fake_current_time, final_intel_);

  checkEquality(final_intel_, expected_intel_);
}

TEST_F(FinalIntelTest, SetWithoutSsl) {
  StreamInfoImpl stream_info{Http::Protocol::Http11, start_time_source_, nullptr};
  stream_info.setUpstreamInfo(std::make_shared<UpstreamInfoImpl>());
  auto upstream_info = stream_info.upstreamInfo();
  auto& timing = upstream_info->upstreamTiming();

  expected_intel_.stream_start_ms = SYSTEM_TIME_START_MS;
  timing.first_upstream_tx_byte_sent_ =
      MonotonicTime(std::chrono::milliseconds(MONOTONIC_TIME_START_MS + 100));
  expected_intel_.sending_start_ms = SYSTEM_TIME_START_MS + 100;
  timing.last_upstream_tx_byte_sent_ =
      MonotonicTime(std::chrono::milliseconds(MONOTONIC_TIME_START_MS + 200));
  expected_intel_.sending_end_ms = SYSTEM_TIME_START_MS + 200;
  timing.first_upstream_rx_byte_received_ =
      MonotonicTime(std::chrono::milliseconds(MONOTONIC_TIME_START_MS + 300));
  expected_intel_.response_start_ms = SYSTEM_TIME_START_MS + 300;
  timing.upstream_connect_start_ =
      MonotonicTime(std::chrono::milliseconds(MONOTONIC_TIME_START_MS + 400));
  expected_intel_.connect_start_ms = SYSTEM_TIME_START_MS + 400;
  timing.upstream_connect_complete_ =
      MonotonicTime(std::chrono::milliseconds(MONOTONIC_TIME_START_MS + 500));
  expected_intel_.connect_end_ms = SYSTEM_TIME_START_MS + 500;
  expected_intel_.ssl_start_ms = -1;
  expected_intel_.ssl_end_ms = -1;
  StalledTimeSource fake_current_time(11111, MONOTONIC_TIME_START_MS + 600);
  expected_intel_.stream_end_ms = SYSTEM_TIME_START_MS + 600;

  upstream_info->setUpstreamNumStreams(5);
  expected_intel_.socket_reused = 1;

  setFinalStreamIntel(stream_info, fake_current_time, final_intel_);

  checkEquality(final_intel_, expected_intel_);
}

} // namespace StreamInfo
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_test", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_test(
    name = "extra_stream_info_test",
    srcs = ["extra_stream_info_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/common/stream_info:extra_stream_info_lib",
        "@envoy//source/common/stream_info:stream_info_lib",
        "@envoy//test/test_common:simulated_time_system_lib",
    ],
)
#include "extension_registry.h"
#include "gtest/gtest.h"
#include "library/cc/engine_builder.h"
#include "library/common/engine_common.h"

namespace Envoy {

TEST(EngineCommonTest, SignalHandlingFalse) {
  ExtensionRegistry::registerFactories();
  auto options = std::make_unique<Envoy::OptionsImplBase>();

  Platform::EngineBuilder builder;
  options->setConfigProto(builder.generateBootstrap());
  EngineCommon main_common{std::move(options)};
  ASSERT_FALSE(main_common.server()->options().signalHandlingEnabled());
}

} // namespace Envoy
#include "gtest/gtest.h"
#include "library/common/bridge/utility.h"
#include "library/common/data/utility.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Bridge {

TEST(EnvoyMapConvenientInitializerTest, FromCppToCEmpty) {
  const auto map = Utility::makeEnvoyMap({});

  EXPECT_EQ(map.length, 0);
  release_envoy_map(map);
}

TEST(EnvoyMapConvenientInitializerTest, FromCppToC) {
  const auto map = Utility::makeEnvoyMap({{"foo", "bar"}});

  EXPECT_EQ(Data::Utility::copyToString(map.entries[0].key), "foo");
  EXPECT_EQ(Data::Utility::copyToString(map.entries[0].value), "bar");
  EXPECT_EQ(map.length, 1);
  release_envoy_map(map);
}

} // namespace Bridge
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_test", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_test(
    name = "utility_test",
    srcs = ["utility_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/common/bridge:utility_lib",
    ],
)
#include "test/common/integration/xds_test_server.h"

#include <utility>

#include "envoy/extensions/transport_sockets/tls/v3/cert.pb.h"

#include "source/common/event/libevent.h"
#include "source/extensions/config_subscription/grpc/grpc_collection_subscription_factory.h"
#include "source/extensions/config_subscription/grpc/grpc_mux_impl.h"
#include "source/extensions/config_subscription/grpc/grpc_subscription_factory.h"
#include "source/extensions/config_subscription/grpc/new_grpc_mux_impl.h"
#include "source/extensions/transport_sockets/tls/context_config_impl.h"
#include "source/extensions/transport_sockets/tls/ssl_socket.h"

#include "test/integration/fake_upstream.h"
#include "test/test_common/environment.h"
#include "test/test_common/network_utility.h"
#include "test/test_common/utility.h"

namespace Envoy {

XdsTestServer::XdsTestServer()
    : api_(Api::createApiForTest(stats_store_, time_system_)),
      version_(Network::Address::IpVersion::v4),
      mock_buffer_factory_(new NiceMock<MockBufferFactory>), upstream_config_(time_system_) {
  std::string runfiles_error;
  runfiles_ = std::unique_ptr<bazel::tools::cpp::runfiles::Runfiles>{
      bazel::tools::cpp::runfiles::Runfiles::Create("", &runfiles_error)};
  RELEASE_ASSERT(TestEnvironment::getOptionalEnvVar("NORUNFILES").has_value() ||
                     runfiles_ != nullptr,
                 runfiles_error);
  TestEnvironment::setRunfiles(runfiles_.get());

  if (!Envoy::Event::Libevent::Global::initialized()) {
    // Required by the Dispatcher.
    Envoy::Event::Libevent::Global::initialize();
  }
  dispatcher_ =
      api_->allocateDispatcher("test_thread", Buffer::WatermarkFactoryPtr{mock_buffer_factory_});

  ON_CALL(*mock_buffer_factory_, createBuffer_(_, _, _))
      .WillByDefault(Invoke([](std::function<void()> below_low, std::function<void()> above_high,
                               std::function<void()> above_overflow) -> Buffer::Instance* {
        return new Buffer::WatermarkBuffer(std::move(below_low), std::move(above_high),
                                           std::move(above_overflow));
      }));
  ON_CALL(factory_context_.server_context_, api()).WillByDefault(testing::ReturnRef(*api_));
  ON_CALL(factory_context_, statsScope())
      .WillByDefault(testing::ReturnRef(*stats_store_.rootScope()));
  Logger::Context logging_state(spdlog::level::level_enum::err,
                                "[%Y-%m-%d %T.%e][%t][%l][%n] [%g:%#] %v", lock_, false, false);
  upstream_config_.upstream_protocol_ = Http::CodecType::HTTP2;
  Config::forceRegisterAdsConfigSubscriptionFactory();
  Config::forceRegisterGrpcConfigSubscriptionFactory();
  Config::forceRegisterDeltaGrpcConfigSubscriptionFactory();
  Config::forceRegisterDeltaGrpcCollectionConfigSubscriptionFactory();
  Config::forceRegisterAggregatedGrpcCollectionConfigSubscriptionFactory();
  Config::forceRegisterAdsCollectionConfigSubscriptionFactory();
  Config::forceRegisterGrpcMuxFactory();
  Config::forceRegisterNewGrpcMuxFactory();

  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;
  auto* common_tls_context = tls_context.mutable_common_tls_context();
  common_tls_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http2);
  auto* tls_cert = common_tls_context->add_tls_certificates();
  tls_cert->mutable_certificate_chain()->set_filename(
      TestEnvironment::runfilesPath("test/config/integration/certs/upstreamcert.pem"));
  tls_cert->mutable_private_key()->set_filename(
      TestEnvironment::runfilesPath("test/config/integration/certs/upstreamkey.pem"));
  auto cfg = std::make_unique<Extensions::TransportSockets::Tls::ServerContextConfigImpl>(
      tls_context, factory_context_);
  auto context = std::make_unique<Extensions::TransportSockets::Tls::ServerSslSocketFactory>(
      std::move(cfg), context_manager_, *stats_store_.rootScope(), std::vector<std::string>{});
  xds_upstream_ = std::make_unique<FakeUpstream>(std::move(context), 0, version_, upstream_config_);
}

std::string XdsTestServer::getHost() const {
  return Network::Test::getLoopbackAddressUrlString(version_);
}

int XdsTestServer::getPort() const {
  ASSERT(xds_upstream_);
  return xds_upstream_->localAddress()->ip()->port();
}

void XdsTestServer::start() {
  AssertionResult result = xds_upstream_->waitForHttpConnection(*dispatcher_, xds_connection_);
  RELEASE_ASSERT(result, result.message());
  result = xds_connection_->waitForNewStream(*dispatcher_, xds_stream_);
  RELEASE_ASSERT(result, result.message());
  xds_stream_->startGrpcStream();
}

void XdsTestServer::send(const envoy::service::discovery::v3::DiscoveryResponse& response) {
  ASSERT(xds_stream_);
  xds_stream_->sendGrpcMessage(response);
}

void XdsTestServer::shutdown() {
  if (xds_connection_ != nullptr) {
    AssertionResult result = xds_connection_->close();
    RELEASE_ASSERT(result, result.message());
    result = xds_connection_->waitForDisconnect();
    RELEASE_ASSERT(result, result.message());
    xds_connection_.reset();
  }
}

} // namespace Envoy
#pragma once

#include <string>

#include "envoy/service/discovery/v3/discovery.pb.h"

// NOLINT(namespace-envoy)

#ifdef __cplusplus
extern "C" { // functions
#endif

/** Initializes xDS server. */
void initXdsServer();

/** Gets the xDS server host. `initXdsServer` must be called prior to calling this function.
 */
const char* getXdsServerHost();

/**
 * Gets the xDS server port. `initXdsServer` must be called prior to calling this function.
 */
int getXdsServerPort();

/**
 * Starts the xDS server. `initXdsServer` must be called prior to calling this function.
 */
void startXdsServer();

/**
 * Sends the `DiscoveryResponse`. `startXdsServer` must be called prior to calling this function.
 */
void sendDiscoveryResponse(const envoy::service::discovery::v3::DiscoveryResponse& response);

/**
 * Shuts down the xDS server. `startXdsServer` must be called prior to calling this function.
 */
void shutdownXdsServer();

#ifdef __cplusplus
} // functions
#endif
#include "test/common/integration/xds_test_server_interface.h"

#include "test/common/integration/xds_test_server.h"

#include "extension_registry.h"

// NOLINT(namespace-envoy)

static std::shared_ptr<Envoy::XdsTestServer> strong_test_server_;
static std::weak_ptr<Envoy::XdsTestServer> weak_test_server_;

static std::shared_ptr<Envoy::XdsTestServer> testServer() { return weak_test_server_.lock(); }

void initXdsServer() {
  Envoy::ExtensionRegistry::registerFactories();
  strong_test_server_ = std::make_shared<Envoy::XdsTestServer>();
  weak_test_server_ = strong_test_server_;
}

const char* getXdsServerHost() {
  if (auto server = testServer()) {
    const char* host = strdup(server->getHost().c_str());
    return host;
  }
  return ""; // failure
}

int getXdsServerPort() {
  if (auto server = testServer()) {
    return server->getPort();
  }
  return -1; // failure
}

void startXdsServer() {
  if (auto server = testServer()) {
    server->start();
  }
}

void sendDiscoveryResponse(const envoy::service::discovery::v3::DiscoveryResponse& response) {
  if (auto server = testServer()) {
    ASSERT(server);
    server->send(response);
  }
}

void shutdownXdsServer() {
  // Reset the primary handle to the test_server,
  // but retain it long enough to synchronously shutdown.
  auto server = strong_test_server_;
  strong_test_server_.reset();
  server->shutdown();
}
#include "envoy/config/bootstrap/v3/bootstrap.pb.h"
#include "envoy/service/runtime/v3/rtds.pb.h"

#include "test/common/integration/xds_integration_test.h"
#include "test/test_common/environment.h"
#include "test/test_common/utility.h"

#include "gtest/gtest.h"

namespace Envoy {
namespace {

using envoy::config::cluster::v3::Cluster;

class CdsIntegrationTest : public XdsIntegrationTest {
public:
  void initialize() override {
    setUpstreamProtocol(Http::CodecType::HTTP1);

    XdsIntegrationTest::initialize();

    default_request_headers_.setScheme("http");
    initializeXdsStream();
  }

  void createEnvoy() override {
    sotw_or_delta_ = sotwOrDelta();
    const std::string target_uri = Network::Test::getLoopbackAddressUrlString(ipVersion());
    Platform::XdsBuilder xds_builder(target_uri, fake_upstreams_[1]->localAddress()->ip()->port());
    std::string cds_resources_locator;
    if (use_xdstp_) {
      cds_namespace_ = "xdstp://" + target_uri + "/envoy.config.cluster.v3.Cluster";
      cds_resources_locator = cds_namespace_ + "/*";
    }
    xds_builder.addClusterDiscoveryService(cds_resources_locator, /*timeout_in_seconds=*/1)
        .setSslRootCerts(getUpstreamCert());
    builder_.setXds(std::move(xds_builder));

    XdsIntegrationTest::createEnvoy();
  }

  void SetUp() override { initialize(); }

protected:
  Cluster createCluster() {
    const std::string cluster_name =
        use_xdstp_ ? cds_namespace_ + "/my_cluster?xds.node.cluster=envoy-mobile" : "my_cluster";
    return ConfigHelper::buildStaticCluster(cluster_name,
                                            fake_upstreams_[0]->localAddress()->ip()->port(),
                                            Network::Test::getLoopbackAddressString(ipVersion()));
  }

  std::vector<std::string> getExpectedResources() {
    std::vector<std::string> expected_resources;
    if (use_xdstp_) {
      expected_resources.push_back(cds_namespace_ + "/*");
    }
    return expected_resources;
  }

  void sendInitialCdsResponseAndVerify(const std::string& version) {
    const int cluster_count = getGaugeValue("cluster_manager.active_clusters");
    const std::vector<std::string> expected_resources = getExpectedResources();

    // Envoy sends the initial DiscoveryRequest.
    EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, "", expected_resources, {},
                                        {}, /*expect_node=*/true));

    Cluster cluster = createCluster();
    // Server sends back the initial DiscoveryResponse.
    sendDiscoveryResponse<Cluster>(Config::TypeUrl::get().Cluster, {cluster}, {cluster}, {},
                                   version);

    // Wait for cluster to be added.
    EXPECT_TRUE(waitForCounterGe("cluster_manager.cluster_added", 1));
    EXPECT_TRUE(waitForGaugeGe("cluster_manager.active_clusters", cluster_count + 1));

    // ACK of the initial version.
    EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, version, expected_resources,
                                        {}, {}, /*expect_node=*/false));

    EXPECT_TRUE(waitForGaugeGe("cluster_manager.cluster_removed", 0));
  }

  void sendUpdatedCdsResponseAndVerify(const std::string& version) {
    const int cluster_count = getGaugeValue("cluster_manager.active_clusters");
    const std::vector<std::string> expected_resources = getExpectedResources();

    // Server sends an updated DiscoveryResponse over the xDS stream.
    Cluster cluster = createCluster();
    sendDiscoveryResponse<Cluster>(Config::TypeUrl::get().Cluster, {cluster}, {cluster}, {},
                                   version);

    // ACK of the cluster update at the new version.
    EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, version, expected_resources,
                                        {}, {}, /*expect_node=*/false));

    // Cluster count should stay the same.
    EXPECT_TRUE(waitForGaugeGe("cluster_manager.active_clusters", cluster_count));
    EXPECT_TRUE(waitForGaugeGe("cluster_manager.cluster_removed", 0));
  }

  bool use_xdstp_{false};
  std::string cds_namespace_;
};

INSTANTIATE_TEST_SUITE_P(
    IpVersionsClientTypeSotw, CdsIntegrationTest,
    testing::Combine(testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
                     testing::ValuesIn(TestEnvironment::getsGrpcVersionsForTest()),
                     // Envoy Mobile's xDS APIs only support state-of-the-world, not delta.
                     testing::Values(Grpc::SotwOrDelta::Sotw, Grpc::SotwOrDelta::UnifiedSotw)));

TEST_P(CdsIntegrationTest, Basic) { sendInitialCdsResponseAndVerify(/*version=*/"55"); }

TEST_P(CdsIntegrationTest, BasicWithXdstp) {
  use_xdstp_ = true;
  sendInitialCdsResponseAndVerify(/*version=*/"55");
}

TEST_P(CdsIntegrationTest, ClusterUpdates) {
  use_xdstp_ = true;
  sendInitialCdsResponseAndVerify(/*version=*/"55");
  sendUpdatedCdsResponseAndVerify(/*version=*/"56");
}

} // namespace
} // namespace Envoy
#include "test_server.h"

#include "source/common/common/random_generator.h"
#include "source/common/listener_manager/connection_handler_impl.h"
#include "source/common/listener_manager/listener_manager_impl.h"
#include "source/common/quic/quic_server_transport_socket_factory.h"
#include "source/common/quic/server_codec_impl.h"
#include "source/common/stats/allocator_impl.h"
#include "source/common/stats/thread_local_store.h"
#include "source/common/thread_local/thread_local_impl.h"
#include "source/extensions/quic/connection_id_generator/envoy_deterministic_connection_id_generator_config.h"
#include "source/extensions/quic/crypto_stream/envoy_quic_crypto_server_stream.h"
#include "source/extensions/quic/proof_source/envoy_quic_proof_source_factory_impl.h"
#include "source/extensions/transport_sockets/raw_buffer/config.h"
#include "source/extensions/transport_sockets/tls/context_config_impl.h"
#include "source/extensions/udp_packet_writer/default/config.h"
#include "source/server/hot_restart_nop_impl.h"
#include "source/server/instance_impl.h"

#include "test/test_common/environment.h"
#include "test/test_common/network_utility.h"

namespace Envoy {

Network::DownstreamTransportSocketFactoryPtr TestServer::createQuicUpstreamTlsContext(
    testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>& factory_context) {
  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;
  Extensions::TransportSockets::Tls::ContextManagerImpl context_manager{time_system_};
  tls_context.mutable_common_tls_context()->add_alpn_protocols("h3");
  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* certs =
      tls_context.mutable_common_tls_context()->add_tls_certificates();
  certs->mutable_certificate_chain()->set_filename(
      TestEnvironment::runfilesPath("test/config/integration/certs/upstreamcert.pem"));
  certs->mutable_private_key()->set_filename(
      TestEnvironment::runfilesPath("test/config/integration/certs/upstreamkey.pem"));
  envoy::extensions::transport_sockets::quic::v3::QuicDownstreamTransport quic_config;
  quic_config.mutable_downstream_tls_context()->MergeFrom(tls_context);

  std::vector<std::string> server_names;
  auto& config_factory = Config::Utility::getAndCheckFactoryByName<
      Server::Configuration::DownstreamTransportSocketConfigFactory>(
      "envoy.transport_sockets.quic");

  return config_factory.createTransportSocketFactory(quic_config, factory_context, server_names);
}

Network::DownstreamTransportSocketFactoryPtr TestServer::createUpstreamTlsContext(
    testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>& factory_context) {
  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;
  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* certs =
      tls_context.mutable_common_tls_context()->add_tls_certificates();
  certs->mutable_certificate_chain()->set_filename(
      TestEnvironment::runfilesPath("test/config/integration/certs/upstreamcert.pem"));
  certs->mutable_private_key()->set_filename(
      TestEnvironment::runfilesPath("test/config/integration/certs/upstreamkey.pem"));
  auto* ctx = tls_context.mutable_common_tls_context()->mutable_validation_context();
  ctx->mutable_trusted_ca()->set_filename(
      TestEnvironment::runfilesPath("test/config/integration/certs/upstreamcacert.pem"));
  tls_context.mutable_common_tls_context()->add_alpn_protocols("h2");
  auto cfg = std::make_unique<Extensions::TransportSockets::Tls::ServerContextConfigImpl>(
      tls_context, factory_context);
  static auto* upstream_stats_store = new Stats::TestIsolatedStoreImpl();
  return std::make_unique<Extensions::TransportSockets::Tls::ServerSslSocketFactory>(
      std::move(cfg), context_manager_, *upstream_stats_store->rootScope(),
      std::vector<std::string>{});
}

TestServer::TestServer()
    : api_(Api::createApiForTest(stats_store_, time_system_)),
      version_(Network::Address::IpVersion::v4), upstream_config_(time_system_), port_(0) {
  std::string runfiles_error;
  runfiles_ = std::unique_ptr<bazel::tools::cpp::runfiles::Runfiles>{
      bazel::tools::cpp::runfiles::Runfiles::CreateForTest(&runfiles_error)};
  RELEASE_ASSERT(TestEnvironment::getOptionalEnvVar("NORUNFILES").has_value() ||
                     runfiles_ != nullptr,
                 runfiles_error);
  TestEnvironment::setRunfiles(runfiles_.get());
  ON_CALL(factory_context_.server_context_, api()).WillByDefault(testing::ReturnRef(*api_));
  ON_CALL(factory_context_, statsScope())
      .WillByDefault(testing::ReturnRef(*stats_store_.rootScope()));
}

void TestServer::startTestServer(TestServerType test_server_type) {
  ASSERT(!upstream_);
  // pre-setup: see https://github.com/envoyproxy/envoy/blob/main/test/test_runner.cc
  Logger::Context logging_state(spdlog::level::level_enum::err,
                                "[%Y-%m-%d %T.%e][%t][%l][%n] [%g:%#] %v", lock, false, false);
  // end pre-setup
  Network::DownstreamTransportSocketFactoryPtr factory;

  switch (test_server_type) {
  case TestServerType::HTTP3:
    // Make sure if extensions aren't statically linked QUIC will work.
    Quic::forceRegisterQuicServerTransportSocketConfigFactory();
    Network::forceRegisterUdpDefaultWriterFactoryFactory();
    Quic::forceRegisterQuicHttpServerConnectionFactoryImpl();
    Quic::forceRegisterEnvoyQuicCryptoServerStreamFactoryImpl();
    Quic::forceRegisterQuicServerTransportSocketConfigFactory();
    Quic::forceRegisterEnvoyQuicProofSourceFactoryImpl();
    Quic::forceRegisterEnvoyDeterministicConnectionIdGeneratorConfigFactory();

    // envoy.quic.crypto_stream.server.quiche
    upstream_config_.upstream_protocol_ = Http::CodecType::HTTP3;
    upstream_config_.udp_fake_upstream_ = FakeUpstreamConfig::UdpConfig();
    factory = createQuicUpstreamTlsContext(factory_context_);
    break;
  case TestServerType::HTTP2_WITH_TLS:
    upstream_config_.upstream_protocol_ = Http::CodecType::HTTP2;
    factory = createUpstreamTlsContext(factory_context_);
    break;
  case TestServerType::HTTP1_WITHOUT_TLS:
    upstream_config_.upstream_protocol_ = Http::CodecType::HTTP1;
    factory = Network::Test::createRawBufferDownstreamSocketFactory();
    break;
  case TestServerType::HTTP_PROXY: {
    Server::forceRegisterDefaultListenerManagerFactoryImpl();
    Extensions::TransportSockets::RawBuffer::forceRegisterDownstreamRawBufferSocketFactory();
    Server::forceRegisterConnectionHandlerFactoryImpl();

    std::string config_path =
        TestEnvironment::writeStringToFileForTest("config.yaml", http_proxy_config);
    test_server_ = IntegrationTestServer::create(config_path, Network::Address::IpVersion::v4,
                                                 nullptr, nullptr, {}, time_system_, *api_);
    test_server_->waitUntilListenersReady();
    ENVOY_LOG_MISC(debug, "Http proxy is now running");
    return;
  }
  case TestServerType::HTTPS_PROXY: {
    Server::forceRegisterDefaultListenerManagerFactoryImpl();
    Extensions::TransportSockets::RawBuffer::forceRegisterDownstreamRawBufferSocketFactory();
    Server::forceRegisterConnectionHandlerFactoryImpl();
    std::string config_path =
        TestEnvironment::writeStringToFileForTest("config.yaml", https_proxy_config);
    test_server_ = IntegrationTestServer::create(config_path, Network::Address::IpVersion::v4,
                                                 nullptr, nullptr, {}, time_system_, *api_);
    test_server_->waitUntilListenersReady();
    ENVOY_LOG_MISC(debug, "Https proxy is now running");
    return;
  }
  }

  upstream_ = std::make_unique<AutonomousUpstream>(std::move(factory), port_, version_,
                                                   upstream_config_, true);

  // Legacy behavior for cronet tests.
  if (test_server_type == TestServerType::HTTP3) {
    upstream_->setResponseHeaders(
        std::make_unique<Http::TestResponseHeaderMapImpl>(Http::TestResponseHeaderMapImpl(
            {{":status", "200"},
             {"Cache-Control", "max-age=0"},
             {"Content-Type", "text/plain"},
             {"X-Original-Url", "https://test.example.com:6121/simple.txt"}})));
    upstream_->setResponseBody("This is a simple text file served by QUIC.\n");
  }

  ENVOY_LOG_MISC(debug, "Upstream now listening on {}", upstream_->localAddress()->asString());
}

void TestServer::shutdownTestServer() {
  ASSERT(upstream_ || test_server_);
  upstream_.reset();
  test_server_.reset();
}

int TestServer::getServerPort() {
  ASSERT(upstream_ || test_server_);
  if (upstream_) {
    return upstream_->localAddress()->ip()->port();
  }
  std::atomic<uint32_t> port = 0;
  absl::Notification port_set;
  test_server_->server().dispatcher().post([&]() {
    auto listeners = test_server_->server().listenerManager().listeners();
    auto listener_it = listeners.cbegin();
    auto socket_factory_it = listener_it->get().listenSocketFactories().begin();
    const auto listen_addr = (*socket_factory_it)->localAddress();
    port = listen_addr->ip()->port();
    port_set.Notify();
  });
  port_set.WaitForNotification();
  return port;
}

void TestServer::setHeadersAndData(absl::string_view header_key, absl::string_view header_value,
                                   absl::string_view response_body) {
  ASSERT(upstream_);
  upstream_->setResponseHeaders(
      std::make_unique<Http::TestResponseHeaderMapImpl>(Http::TestResponseHeaderMapImpl(
          {{std::string(header_key), std::string(header_value)}, {":status", "200"}})));
  upstream_->setResponseBody(std::string(response_body));
}

const std::string TestServer::http_proxy_config = R"EOF(
static_resources:
  listeners:
  - name: listener_proxy
    address:
      socket_address: { address: 127.0.0.1, port_value: 0 }
    filter_chains:
      - filters:
        - name: envoy.filters.network.http_connection_manager
          typed_config:
            "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
            stat_prefix: remote_hcm
            route_config:
              name: remote_route
              virtual_hosts:
              - name: remote_service
                domains: ["*"]
                routes:
                - match: { prefix: "/" }
                  route: { cluster: cluster_proxy }
              response_headers_to_add:
                - append_action: OVERWRITE_IF_EXISTS_OR_ADD
                  header:
                    key: x-proxy-response
                    value: 'true'
            http_filters:
              - name: envoy.filters.http.local_error
                typed_config:
                  "@type": type.googleapis.com/envoymobile.extensions.filters.http.local_error.LocalError
              - name: envoy.filters.http.dynamic_forward_proxy
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.dynamic_forward_proxy.v3.FilterConfig
                  dns_cache_config: &dns_cache_config
                    name: base_dns_cache
                    dns_lookup_family: ALL
                    host_ttl: 86400s
                    dns_min_refresh_rate: 20s
                    dns_refresh_rate: 60s
                    dns_failure_refresh_rate:
                      base_interval: 2s
                      max_interval: 10s
                    dns_query_timeout: 25s
                    typed_dns_resolver_config:
                      name: envoy.network.dns_resolver.getaddrinfo
                      typed_config: {"@type":"type.googleapis.com/envoy.extensions.network.dns_resolver.getaddrinfo.v3.GetAddrInfoDnsResolverConfig"}
              - name: envoy.router
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
  clusters:
  - name: cluster_proxy
    connect_timeout: 30s
    lb_policy: CLUSTER_PROVIDED
    dns_lookup_family: ALL
    cluster_type:
      name: envoy.clusters.dynamic_forward_proxy
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig
        dns_cache_config: *dns_cache_config
layered_runtime:
  layers:
    - name: static_layer_0
      static_layer:
        envoy:
          # This disables envoy bug stats, which are filtered out of our stats inclusion list anyway
          # Global stats do not play well with engines with limited lifetimes
          disallow_global_stats: true
)EOF";

const std::string TestServer::https_proxy_config = R"EOF(
static_resources:
  listeners:
  - name: listener_proxy
    address:
      socket_address: { address: 127.0.0.1, port_value: 0 }
    filter_chains:
      - filters:
        - name: envoy.filters.network.http_connection_manager
          typed_config:
            "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
            stat_prefix: remote_hcm
            route_config:
              name: remote_route
              virtual_hosts:
              - name: remote_service
                domains: ["*"]
                routes:
                - match: { connect_matcher: {} }
                  route:
                    cluster: cluster_proxy
                    upgrade_configs:
                    - upgrade_type: CONNECT
                      connect_config:
              response_headers_to_add:
                - append_action: OVERWRITE_IF_EXISTS_OR_ADD
                  header:
                    key: x-response-header-that-should-be-stripped
                    value: 'true'
            http_filters:
              - name: envoy.filters.http.local_error
                typed_config:
                  "@type": type.googleapis.com/envoymobile.extensions.filters.http.local_error.LocalError
              - name: envoy.filters.http.dynamic_forward_proxy
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.dynamic_forward_proxy.v3.FilterConfig
                  dns_cache_config: &dns_cache_config
                    name: base_dns_cache
                    dns_lookup_family: ALL
                    host_ttl: 86400s
                    dns_min_refresh_rate: 20s
                    dns_refresh_rate: 60s
                    dns_failure_refresh_rate:
                      base_interval: 2s
                      max_interval: 10s
                    dns_query_timeout: 25s
                    typed_dns_resolver_config:
                      name: envoy.network.dns_resolver.getaddrinfo
                      typed_config: {"@type":"type.googleapis.com/envoy.extensions.network.dns_resolver.getaddrinfo.v3.GetAddrInfoDnsResolverConfig"}
              - name: envoy.router
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
  clusters:
  - name: cluster_proxy
    connect_timeout: 30s
    lb_policy: CLUSTER_PROVIDED
    dns_lookup_family: ALL
    cluster_type:
      name: envoy.clusters.dynamic_forward_proxy
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig
        dns_cache_config: *dns_cache_config
layered_runtime:
  layers:
    - name: static_layer_0
      static_layer:
        envoy:
          # This disables envoy bug stats, which are filtered out of our stats inclusion list anyway
          # Global stats do not play well with engines with limited lifetimes
          disallow_global_stats: true
)EOF";

} // namespace Envoy
#include "source/common/quic/quic_server_transport_socket_factory.h"
#include "source/common/quic/server_codec_impl.h"
#include "source/extensions/http/header_formatters/preserve_case/preserve_case_formatter.h"
#include "source/extensions/quic/connection_id_generator/envoy_deterministic_connection_id_generator_config.h"
#include "source/extensions/quic/crypto_stream/envoy_quic_crypto_server_stream.h"
#include "source/extensions/quic/proof_source/envoy_quic_proof_source_factory_impl.h"
#include "source/extensions/transport_sockets/tls/cert_validator/default_validator.h"
#include "source/extensions/udp_packet_writer/default/config.h"

#include "test/common/integration/base_client_integration_test.h"
#include "test/common/mocks/common/mocks.h"
#include "test/integration/autonomous_upstream.h"
#include "test/test_common/test_random_generator.h"

#include "extension_registry.h"
#include "library/common/data/utility.h"
#include "library/common/engine.h"
#include "library/common/network/proxy_settings.h"
#include "library/common/types/c_types.h"

using testing::_;
using testing::AnyNumber;
using testing::Return;
using testing::ReturnRef;

namespace Envoy {
namespace {

// The only thing this TestKeyValueStore does is return value_ when asked for
// initial loaded contents.
// In this case the TestKeyValueStore will be used for DNS and value will map
// www.lyft.com -> fake test upstream.
class TestKeyValueStore : public Envoy::Platform::KeyValueStore {
public:
  absl::optional<std::string> read(const std::string&) override {
    ASSERT(!value_.empty());
    return value_;
  }
  void save(std::string, std::string) override {}
  void remove(const std::string&) override {}
  void addOrUpdate(absl::string_view, absl::string_view, absl::optional<std::chrono::seconds>) {}
  absl::optional<absl::string_view> get(absl::string_view) { return {}; }
  void flush() {}
  void iterate(::Envoy::KeyValueStore::ConstIterateCb) const {}
  void setValue(std::string value) { value_ = value; }

protected:
  std::string value_;
};

class ClientIntegrationTest
    : public BaseClientIntegrationTest,
      public testing::TestWithParam<std::tuple<Network::Address::IpVersion, Http::CodecType>> {
public:
  static void SetUpTestCase() { test_key_value_store_ = std::make_shared<TestKeyValueStore>(); }
  static void TearDownTestCase() { test_key_value_store_.reset(); }

  Http::CodecType getCodecType() { return std::get<1>(GetParam()); }

  ClientIntegrationTest() : BaseClientIntegrationTest(/*ip_version=*/std::get<0>(GetParam())) {
    // For H3 tests.
    Network::forceRegisterUdpDefaultWriterFactoryFactory();
    Quic::forceRegisterEnvoyQuicCryptoServerStreamFactoryImpl();
    Quic::forceRegisterQuicHttpServerConnectionFactoryImpl();
    Quic::forceRegisterQuicServerTransportSocketConfigFactory();
    Quic::forceRegisterEnvoyQuicProofSourceFactoryImpl();
    Quic::forceRegisterEnvoyDeterministicConnectionIdGeneratorConfigFactory();
    // For H2 tests.
    Extensions::TransportSockets::Tls::forceRegisterDefaultCertValidatorFactory();
  }

  void initialize() override {
    if (getCodecType() == Http::CodecType::HTTP3) {
      setUpstreamProtocol(Http::CodecType::HTTP3);
      builder_.enablePlatformCertificatesValidation(true);
      // Create a k-v store for DNS lookup which createEnvoy() will use to point
      // www.lyft.com -> fake H3 backend.
      builder_.addKeyValueStore("reserved.platform_store", test_key_value_store_);
      builder_.enableDnsCache(true, /* save_interval_seconds */ 1);
      upstream_tls_ = true;
      add_quic_hints_ = true;
    } else if (getCodecType() == Http::CodecType::HTTP2) {
      setUpstreamProtocol(Http::CodecType::HTTP2);
      builder_.enablePlatformCertificatesValidation(true);
      upstream_tls_ = true;
    }

    BaseClientIntegrationTest::initialize();

    if (getCodecType() == Http::CodecType::HTTP3) {
      auto address = fake_upstreams_[0]->localAddress();
      auto upstream_port = fake_upstreams_[0]->localAddress()->ip()->port();
      default_request_headers_.setHost(fmt::format("www.lyft.com:{}", upstream_port));
      default_request_headers_.setScheme("https");
    } else if (getCodecType() == Http::CodecType::HTTP2) {
      default_request_headers_.setScheme("https");
    }
  }

  void SetUp() override {
    setUpstreamCount(config_helper_.bootstrap().static_resources().clusters_size());
    helper_handle_ = test::SystemHelperPeer::replaceSystemHelper();
    EXPECT_CALL(helper_handle_->mock_helper(), isCleartextPermitted(_))
        .WillRepeatedly(Return(true));
    EXPECT_CALL(helper_handle_->mock_helper(), validateCertificateChain(_, _)).Times(AnyNumber());
    EXPECT_CALL(helper_handle_->mock_helper(), cleanupAfterCertificateValidation())
        .Times(AnyNumber());
  }

  void createEnvoy() override {
    // Allow last minute addition of QUIC hints. This is done lazily as it must be done after
    // upstreams are created.
    if (add_quic_hints_) {
      auto address = fake_upstreams_[0]->localAddress();
      auto upstream_port = fake_upstreams_[0]->localAddress()->ip()->port();
      // With canonical suffix, having a quic hint of foo.lyft.com will make
      // www.lyft.com being recognized as QUIC ready.
      builder_.addQuicCanonicalSuffix(".lyft.com");
      builder_.addQuicHint("foo.lyft.com", upstream_port);

      // Force www.lyft.com to resolve to the fake upstream. It's the only domain
      // name the certs work for so we want that in the request, but we need to
      // fake resolution to not result in a request to the real www.lyft.com
      std::string host = fmt::format("www.lyft.com:{}", upstream_port);
      std::string cache_file_value_contents =
          absl::StrCat(Network::Test::getLoopbackAddressUrlString(version_), ":",
                       fake_upstreams_[0]->localAddress()->ip()->port(), "|1000000|0");
      test_key_value_store_->setValue(absl::StrCat(host.length(), "\n", host,
                                                   cache_file_value_contents.length(), "\n",
                                                   cache_file_value_contents));
    }
    BaseClientIntegrationTest::createEnvoy();
  }

  void TearDown() override {
    if (upstream_connection_) {
      ASSERT_TRUE(upstream_connection_->close());
      ASSERT_TRUE(upstream_connection_->waitForDisconnect());
      upstream_connection_.reset();
    }
    BaseClientIntegrationTest::TearDown();
  }

  void basicTest();
  void trickleTest();
  void explicitFlowControlWithCancels(uint32_t body_size = 1000, bool terminate_engine = false);

  static std::string protocolToString(Http::CodecType type) {
    if (type == Http::CodecType::HTTP3) {
      return "Http3Upstream";
    }
    if (type == Http::CodecType::HTTP2) {
      return "Http2Upstream";
    }
    return "Http1Upstream";
  }

  static std::string testParamsToString(
      const testing::TestParamInfo<std::tuple<Network::Address::IpVersion, Http::CodecType>>
          params) {
    return fmt::format(
        "{}_{}",
        TestUtility::ipTestParamsToString(testing::TestParamInfo<Network::Address::IpVersion>(
            std::get<0>(params.param), params.index)),
        protocolToString(std::get<1>(params.param)));
  }

protected:
  std::unique_ptr<test::SystemHelperPeer::Handle> helper_handle_;
  bool add_quic_hints_ = false;
  static std::shared_ptr<TestKeyValueStore> test_key_value_store_;
  FakeHttpConnectionPtr upstream_connection_;
  FakeStreamPtr upstream_request_;
};

std::shared_ptr<TestKeyValueStore> ClientIntegrationTest::test_key_value_store_{};

INSTANTIATE_TEST_SUITE_P(
    IpVersions, ClientIntegrationTest,
    testing::Combine(testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
                     testing::ValuesIn({Http::CodecType::HTTP1, Http::CodecType::HTTP2,
                                        Http::CodecType::HTTP3})),
    ClientIntegrationTest::testParamsToString);

void ClientIntegrationTest::basicTest() {
  if (getCodecType() != Http::CodecType::HTTP1) {
    EXPECT_CALL(helper_handle_->mock_helper(), isCleartextPermitted(_)).Times(0);
    EXPECT_CALL(helper_handle_->mock_helper(), validateCertificateChain(_, _));
    EXPECT_CALL(helper_handle_->mock_helper(), cleanupAfterCertificateValidation());
  }
  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");
  default_request_headers_.addCopy(AutonomousStream::EXPECT_REQUEST_SIZE_BYTES,
                                   std::to_string(request_data.length()));

  stream_prototype_->setOnData([this](envoy_data c_data, bool end_stream) {
    if (end_stream) {
      EXPECT_EQ(Data::Utility::copyToString(c_data), "");
    }
    cc_.on_data_calls++;
    release_envoy_data(c_data);
  });

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), false);

  envoy_data c_data = Data::Utility::toBridgeData(request_data);
  stream_->sendData(c_data);

  Platform::RequestTrailersBuilder builder;
  std::shared_ptr<Platform::RequestTrailers> trailers =
      std::make_shared<Platform::RequestTrailers>(builder.build());
  stream_->close(trailers);

  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_headers_calls, 1);
  ASSERT_EQ(cc_.status, "200");
  ASSERT_GE(cc_.on_data_calls, 1);
  ASSERT_EQ(cc_.on_complete_calls, 1);
  if (upstreamProtocol() == Http::CodecType::HTTP1) {
    ASSERT_EQ(cc_.on_header_consumed_bytes_from_response, 27);
    // HTTP/1
    ASSERT_EQ(1, last_stream_final_intel_.upstream_protocol);
  } else if (upstreamProtocol() == Http::CodecType::HTTP2) {
    ASSERT_EQ(2, last_stream_final_intel_.upstream_protocol);
  } else {
    // This verifies the H3 attempt was made due to the quic hints.
    absl::MutexLock l(&engine_lock_);
    std::string stats = engine_->dumpStats();
    EXPECT_TRUE((absl::StrContains(stats, "cluster.base.upstream_cx_http3_total: 1"))) << stats;
    // Make sure the client reported protocol was also HTTP/3.
    ASSERT_EQ(3, last_stream_final_intel_.upstream_protocol);
  }
}

TEST_P(ClientIntegrationTest, Basic) {
  initialize();
  basicTest();
  if (upstreamProtocol() == Http::CodecType::HTTP1) {
    ASSERT_EQ(cc_.on_complete_received_byte_count, 67);
  }
}

TEST_P(ClientIntegrationTest, LargeResponse) {
  initialize();
  std::string data(1024 * 32, 'a');
  reinterpret_cast<AutonomousUpstream*>(fake_upstreams_.front().get())->setResponseBody(data);
  basicTest();
  if (upstreamProtocol() == Http::CodecType::HTTP1) {
    ASSERT_EQ(cc_.on_complete_received_byte_count, 32828);
  } else {
    ASSERT_GE(cc_.on_complete_received_byte_count, 32000);
  }
}

void ClientIntegrationTest::trickleTest() {
  autonomous_upstream_ = false;

  initialize();

  stream_prototype_->setOnData([this](envoy_data c_data, bool) {
    if (explicit_flow_control_) {
      // Allow reading up to 100 bytes.
      stream_->readData(100);
    }
    cc_.on_data_calls++;
    release_envoy_data(c_data);
  });
  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), false);
  if (explicit_flow_control_) {
    // Allow reading up to 100 bytes
    stream_->readData(100);
  }
  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");
  envoy_data c_data = Data::Utility::toBridgeData(request_data);
  stream_->sendData(c_data);
  Platform::RequestTrailersBuilder builder;
  std::shared_ptr<Platform::RequestTrailers> trailers =
      std::make_shared<Platform::RequestTrailers>(builder.build());
  stream_->close(trailers);

  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*BaseIntegrationTest::dispatcher_,
                                                        upstream_connection_));
  ASSERT_TRUE(
      upstream_connection_->waitForNewStream(*BaseIntegrationTest::dispatcher_, upstream_request_));
  ASSERT_TRUE(upstream_request_->waitForEndStream(*BaseIntegrationTest::dispatcher_));

  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{":status", "200"}}, false);
  for (int i = 0; i < 10; ++i) {
    upstream_request_->encodeData(1, i == 9);
  }

  terminal_callback_.waitReady();
}

TEST_P(ClientIntegrationTest, Trickle) {
  trickleTest();
  ASSERT_LE(cc_.on_data_calls, 11);
}

TEST_P(ClientIntegrationTest, TrickleExplicitFlowControl) {
  explicit_flow_control_ = true;
  trickleTest();
  ASSERT_LE(cc_.on_data_calls, 11);
}

TEST_P(ClientIntegrationTest, ManyStreamExplicitFlowControl) {
  explicit_flow_control_ = true;
  initialize();

  default_request_headers_.addCopy(AutonomousStream::RESPONSE_SIZE_BYTES, std::to_string(1000));

  uint32_t num_requests = 100;
  std::vector<Platform::StreamPrototypeSharedPtr> prototype_streams;
  std::vector<Platform::StreamSharedPtr> streams;

  for (uint32_t i = 0; i < num_requests; ++i) {
    Platform::StreamPrototypeSharedPtr stream_prototype;
    {
      absl::MutexLock l(&engine_lock_);
      stream_prototype = engine_->streamClient()->newStreamPrototype();
    }
    Platform::StreamSharedPtr stream = (*stream_prototype).start(explicit_flow_control_);
    stream_prototype->setOnComplete(
        [this, &num_requests](envoy_stream_intel, envoy_final_stream_intel) {
          cc_.on_complete_calls++;
          if (cc_.on_complete_calls == num_requests) {
            cc_.terminal_callback->setReady();
          }
        });

    stream_prototype->setOnData([stream](envoy_data c_data, bool) {
      // Allow reading up to 10 bytes.
      stream->readData(100);
      release_envoy_data(c_data);
    });
    stream->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
    stream->readData(100);
    prototype_streams.push_back(stream_prototype);
    streams.push_back(stream);
  }
  ASSERT(streams.size() == num_requests);
  ASSERT(prototype_streams.size() == num_requests);

  terminal_callback_.waitReady();
  ASSERT_EQ(num_requests, cc_.on_complete_calls);
}

void ClientIntegrationTest::explicitFlowControlWithCancels(const uint32_t body_size,
                                                           const bool terminate_engine) {
  default_request_headers_.addCopy(AutonomousStream::RESPONSE_SIZE_BYTES,
                                   std::to_string(body_size));

  uint32_t num_requests = 100;
  std::vector<Platform::StreamPrototypeSharedPtr> prototype_streams;
  std::vector<Platform::StreamSharedPtr> streams;

  // Randomly select which request number to terminate the engine on.
  uint32_t request_for_engine_termination = 0;
  if (terminate_engine) {
    TestRandomGenerator rand;
    request_for_engine_termination = rand.random() % (num_requests / 2);
  }

  for (uint32_t i = 0; i < num_requests; ++i) {
    Platform::StreamPrototypeSharedPtr stream_prototype;
    {
      absl::MutexLock l(&engine_lock_);
      stream_prototype = engine_->streamClient()->newStreamPrototype();
    }
    Platform::StreamSharedPtr stream = (*stream_prototype).start(explicit_flow_control_);
    stream_prototype->setOnComplete(
        [this, &num_requests](envoy_stream_intel, envoy_final_stream_intel) {
          cc_.on_complete_calls++;
          if (cc_.on_complete_calls + cc_.on_cancel_calls == num_requests) {
            cc_.terminal_callback->setReady();
          }
        });
    stream_prototype->setOnCancel(
        [this, &num_requests](envoy_stream_intel, envoy_final_stream_intel) {
          cc_.on_cancel_calls++;
          if (cc_.on_complete_calls + cc_.on_cancel_calls == num_requests) {
            cc_.terminal_callback->setReady();
          }
        });
    stream_prototype->setOnData([stream](envoy_data c_data, bool) {
      // Allow reading up to 10 bytes.
      stream->readData(100);
      release_envoy_data(c_data);
    });
    stream_prototype_->setOnError(
        [](Platform::EnvoyErrorSharedPtr, envoy_stream_intel, envoy_final_stream_intel) {
          RELEASE_ASSERT(0, "unexpected");
        });

    stream->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
    prototype_streams.push_back(stream_prototype);
    streams.push_back(stream);
    if (i % 2 == 0) {
      stream->cancel();
    } else {
      stream->readData(100);
    }

    if (terminate_engine && request_for_engine_termination == i) {
      absl::MutexLock l(&engine_lock_);
      ASSERT_EQ(engine_->terminate(), ENVOY_SUCCESS);
      engine_.reset();
      break;
    }
  }

  if (terminate_engine) {
    // Only the cancel calls are guaranteed to have completed when engine->terminate() is called.
    EXPECT_GE(cc_.on_cancel_calls, request_for_engine_termination / 2);
  } else {
    ASSERT(streams.size() == num_requests);
    ASSERT(prototype_streams.size() == num_requests);
    terminal_callback_.waitReady();
    EXPECT_EQ(num_requests / 2, cc_.on_complete_calls);
    EXPECT_EQ(num_requests / 2, cc_.on_cancel_calls);
  }
}

TEST_P(ClientIntegrationTest, ManyStreamExplicitFlowWithCancels) {
  explicit_flow_control_ = true;
  initialize();
  explicitFlowControlWithCancels();
}

TEST_P(ClientIntegrationTest, ManyStreamExplicitFlowWithCancelsAfterComplete) {
  explicit_flow_control_ = true;
  initialize();
  explicitFlowControlWithCancels(/*body_size=*/100);
}

TEST_P(ClientIntegrationTest, ManyStreamExplicitFlowWithCancelsAfterCompleteEngineTermination) {
  explicit_flow_control_ = true;
  initialize();
  explicitFlowControlWithCancels(/*body_size=*/100, /*terminate_engine=*/true);
}

TEST_P(ClientIntegrationTest, ClearTextNotPermitted) {
  if (getCodecType() != Http::CodecType::HTTP1) {
    return;
  }
  EXPECT_CALL(helper_handle_->mock_helper(), isCleartextPermitted(_)).WillRepeatedly(Return(false));

  expect_data_streams_ = false;
  initialize();

  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");
  default_request_headers_.addCopy(AutonomousStream::EXPECT_REQUEST_SIZE_BYTES,
                                   std::to_string(request_data.length()));

  stream_prototype_->setOnData([this](envoy_data c_data, bool end_stream) {
    if (end_stream) {
      EXPECT_EQ(Data::Utility::copyToString(c_data), "Cleartext is not permitted");
    }
    cc_.on_data_calls++;
    release_envoy_data(c_data);
  });

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);

  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_headers_calls, 1);
  ASSERT_EQ(cc_.status, "400");
  ASSERT_EQ(cc_.on_data_calls, 1);
  ASSERT_EQ(cc_.on_complete_calls, 1);
}

TEST_P(ClientIntegrationTest, BasicHttps) {
  EXPECT_CALL(helper_handle_->mock_helper(), isCleartextPermitted(_)).Times(0);
  EXPECT_CALL(helper_handle_->mock_helper(), validateCertificateChain(_, _));
  EXPECT_CALL(helper_handle_->mock_helper(), cleanupAfterCertificateValidation());

  builder_.enablePlatformCertificatesValidation(true);

  upstream_tls_ = true;

  initialize();
  default_request_headers_.setScheme("https");

  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");
  default_request_headers_.addCopy(AutonomousStream::EXPECT_REQUEST_SIZE_BYTES,
                                   std::to_string(request_data.length()));

  stream_prototype_->setOnData([this](envoy_data c_data, bool end_stream) {
    if (end_stream) {
      EXPECT_EQ(Data::Utility::copyToString(c_data), "");
    } else {
      EXPECT_EQ(c_data.length, 10);
    }
    cc_.on_data_calls++;
    release_envoy_data(c_data);
  });

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), false);

  envoy_data c_data = Data::Utility::toBridgeData(request_data);
  stream_->sendData(c_data);

  Platform::RequestTrailersBuilder builder;
  std::shared_ptr<Platform::RequestTrailers> trailers =
      std::make_shared<Platform::RequestTrailers>(builder.build());
  stream_->close(trailers);

  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_headers_calls, 1);
  ASSERT_EQ(cc_.status, "200");
  ASSERT_GE(cc_.on_data_calls, 1);
  ASSERT_EQ(cc_.on_complete_calls, 1);
  if (upstreamProtocol() == Http::CodecType::HTTP1) {
    ASSERT_EQ(cc_.on_complete_received_byte_count, 67);
  }
}

TEST_P(ClientIntegrationTest, BasicNon2xx) {
  initialize();

  // Set response header status to be non-2xx to test that the correct stats get charged.
  reinterpret_cast<AutonomousUpstream*>(fake_upstreams_.front().get())
      ->setResponseHeaders(std::make_unique<Http::TestResponseHeaderMapImpl>(
          Http::TestResponseHeaderMapImpl({{":status", "503"}})));

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_error_calls, 0);
  ASSERT_EQ(cc_.status, "503");
  ASSERT_EQ(cc_.on_headers_calls, 1);
  ASSERT_EQ(cc_.on_complete_calls, 1);
}

TEST_P(ClientIntegrationTest, InvalidDomain) {
  initialize();

  default_request_headers_.setHost("www.doesnotexist.com");
  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_error_calls, 1);
  ASSERT_EQ(cc_.on_headers_calls, 0);
}

TEST_P(ClientIntegrationTest, BasicBeforeResponseHeaders) {
  initialize();

  default_request_headers_.addCopy(AutonomousStream::RESET_AFTER_REQUEST, "yes");

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_error_calls, 1);
  ASSERT_EQ(cc_.on_headers_calls, 0);
}

TEST_P(ClientIntegrationTest, ResetAfterResponseHeaders) {
  autonomous_allow_incomplete_streams_ = true;
  initialize();

  default_request_headers_.addCopy(AutonomousStream::RESET_AFTER_RESPONSE_HEADERS, "yes");
  default_request_headers_.addCopy(AutonomousStream::RESPONSE_DATA_BLOCKS, "1");

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_error_calls, 1);
}

TEST_P(ClientIntegrationTest, ResetAfterResponseHeadersExplicit) {
  explicit_flow_control_ = true;
  autonomous_allow_incomplete_streams_ = true;
  initialize();

  default_request_headers_.addCopy(AutonomousStream::RESET_AFTER_RESPONSE_HEADERS, "yes");
  default_request_headers_.addCopy(AutonomousStream::RESPONSE_DATA_BLOCKS, "1");

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
  // Read the body chunk. This releases the error.
  stream_->readData(100);

  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_error_calls, 1);
}

TEST_P(ClientIntegrationTest, ResetAfterHeaderOnlyResponse) {
  autonomous_allow_incomplete_streams_ = true;
  initialize();

  default_request_headers_.addCopy(AutonomousStream::RESET_AFTER_RESPONSE_HEADERS, "yes");
  default_request_headers_.addCopy(AutonomousStream::RESPONSE_DATA_BLOCKS, "0");

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), false);
  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_error_calls, 1);
}

TEST_P(ClientIntegrationTest, ResetBetweenDataChunks) {
  autonomous_allow_incomplete_streams_ = true;
  initialize();

  default_request_headers_.addCopy(AutonomousStream::RESET_AFTER_RESPONSE_DATA, "yes");
  default_request_headers_.addCopy(AutonomousStream::RESPONSE_DATA_BLOCKS, "2");

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_error_calls, 1);
}

TEST_P(ClientIntegrationTest, ResetAfterData) {
  autonomous_allow_incomplete_streams_ = true;
  initialize();

  default_request_headers_.addCopy(AutonomousStream::RESET_AFTER_RESPONSE_DATA, "yes");
  default_request_headers_.addCopy(AutonomousStream::RESPONSE_DATA_BLOCKS, "1");

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_error_calls, 1);
}

TEST_P(ClientIntegrationTest, CancelBeforeRequestHeadersSent) {
  autonomous_upstream_ = false;
  initialize();

  stream_->cancel();

  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_cancel_calls, 1);
}

TEST_P(ClientIntegrationTest, CancelAfterRequestHeadersSent) {
  initialize();

  default_request_headers_.addCopy(AutonomousStream::RESPOND_AFTER_REQUEST_HEADERS, "yes");

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), false);
  stream_->cancel();
  terminal_callback_.waitReady();
  ASSERT_EQ(cc_.on_cancel_calls, 1);
}

TEST_P(ClientIntegrationTest, CancelAfterRequestComplete) {
  autonomous_upstream_ = false;
  initialize();

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
  stream_->cancel();
  terminal_callback_.waitReady();
  ASSERT_EQ(cc_.on_cancel_calls, 1);
}

TEST_P(ClientIntegrationTest, CancelDuringResponse) {
  autonomous_upstream_ = false;
  initialize();
  ConditionalInitializer headers_callback;

  stream_prototype_->setOnHeaders(
      [this, &headers_callback](Platform::ResponseHeadersSharedPtr headers, bool,
                                envoy_stream_intel) {
        cc_.status = absl::StrCat(headers->httpStatus());
        cc_.on_headers_calls++;
        headers_callback.setReady();
        return nullptr;
      });

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);

  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*BaseIntegrationTest::dispatcher_,
                                                        upstream_connection_));
  ASSERT_TRUE(
      upstream_connection_->waitForNewStream(*BaseIntegrationTest::dispatcher_, upstream_request_));
  // Send an incomplete response.
  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{":status", "200"}}, false);

  headers_callback.waitReady();
  ASSERT_EQ(cc_.on_headers_calls, 1);
  ASSERT_EQ(cc_.status, "200");
  ASSERT_EQ(cc_.on_data_calls, 0);
  ASSERT_EQ(cc_.on_complete_calls, 0);

  // Now cancel, and make sure the cancel is received.
  stream_->cancel();
  memset(&cc_.final_intel, 0, sizeof(cc_.final_intel));
  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_headers_calls, 1);
  ASSERT_EQ(cc_.status, "200");
  ASSERT_EQ(cc_.on_data_calls, 0);
  ASSERT_EQ(cc_.on_complete_calls, 0);
  ASSERT_EQ(cc_.on_cancel_calls, 1);

  if (upstreamProtocol() != Http::CodecType::HTTP1) {
    ASSERT_TRUE(upstream_request_->waitForReset());
  }
}

TEST_P(ClientIntegrationTest, BasicCancelWithCompleteStream) {
  autonomous_upstream_ = false;

  initialize();

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);

  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*BaseIntegrationTest::dispatcher_,
                                                        upstream_connection_));
  ASSERT_TRUE(
      upstream_connection_->waitForNewStream(*BaseIntegrationTest::dispatcher_, upstream_request_));
  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{":status", "200"}}, true);

  terminal_callback_.waitReady();
  ASSERT_EQ(cc_.on_headers_calls, 1);
  ASSERT_EQ(cc_.status, "200");
  ASSERT_EQ(cc_.on_complete_calls, 1);

  // Now cancel. As on_complete has been called cancel is a no-op but is
  // non-problematic.
  stream_->cancel();
}

TEST_P(ClientIntegrationTest, CancelWithPartialStream) {
  autonomous_upstream_ = false;
  explicit_flow_control_ = true;
  initialize();
  ConditionalInitializer headers_callback;

  stream_prototype_->setOnHeaders(
      [this, &headers_callback](Platform::ResponseHeadersSharedPtr headers, bool,
                                envoy_stream_intel) {
        cc_.status = absl::StrCat(headers->httpStatus());
        cc_.on_headers_calls++;
        headers_callback.setReady();
        return nullptr;
      });

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);

  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*BaseIntegrationTest::dispatcher_,
                                                        upstream_connection_));
  ASSERT_TRUE(
      upstream_connection_->waitForNewStream(*BaseIntegrationTest::dispatcher_, upstream_request_));

  // Send a complete response with body.
  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{":status", "200"}}, false);
  upstream_request_->encodeData(1, true);

  headers_callback.waitReady();
  ASSERT_EQ(cc_.on_headers_calls, 1);
  ASSERT_EQ(cc_.status, "200");
  ASSERT_EQ(cc_.on_data_calls, 0);
  ASSERT_EQ(cc_.on_complete_calls, 0);

  // Due to explicit flow control, the upstream stream is complete, but the
  // callbacks will not be called for data and completion. Cancel the stream
  // and make sure the cancel is received.
  stream_->cancel();
  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_headers_calls, 1);
  ASSERT_EQ(cc_.status, "200");
  ASSERT_EQ(cc_.on_data_calls, 0);
  ASSERT_EQ(cc_.on_complete_calls, 0);
  ASSERT_EQ(cc_.on_cancel_calls, 1);
}

// Test header key case sensitivity.
TEST_P(ClientIntegrationTest, CaseSensitive) {
  if (getCodecType() != Http::CodecType::HTTP1) {
    return;
  }
  autonomous_upstream_ = false;
  initialize();

  default_request_headers_.header_map_->setFormatter(
      std::make_unique<
          Extensions::Http::HeaderFormatters::PreserveCase::PreserveCaseHeaderFormatter>(
          false, envoy::extensions::http::header_formatters::preserve_case::v3::
                     PreserveCaseFormatterConfig::DEFAULT));

  default_request_headers_.addCopy("FoO", "bar");
  default_request_headers_.header_map_->formatter().value().get().processKey("FoO");

  stream_prototype_->setOnHeaders(
      [this](Platform::ResponseHeadersSharedPtr headers, bool, envoy_stream_intel) {
        cc_.status = absl::StrCat(headers->httpStatus());
        cc_.on_headers_calls++;
        EXPECT_TRUE(headers->contains("My-ResponsE-Header"));
        EXPECT_TRUE((*headers)["My-ResponsE-Header"][0] == "foo");
        return nullptr;
      });
  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);

  Envoy::FakeRawConnectionPtr upstream_connection;
  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(upstream_connection));

  // Verify that the upstream request has preserved cased headers.
  std::string upstream_request;
  EXPECT_TRUE(upstream_connection->waitForData(FakeRawConnection::waitForInexactMatch("GET /"),
                                               &upstream_request));
  EXPECT_TRUE(absl::StrContains(upstream_request, "FoO: bar")) << upstream_request;

  // Send mixed case headers, and verify via setOnHeaders they are received correctly.
  auto response = "HTTP/1.1 200 OK\r\nContent-Length: 0\r\nMy-ResponsE-Header: foo\r\n\r\n";
  ASSERT_TRUE(upstream_connection->write(response));

  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_headers_calls, 1);
  ASSERT_EQ(cc_.status, "200");
  ASSERT_EQ(cc_.on_data_calls, 0);
  ASSERT_EQ(cc_.on_complete_calls, 1);
}

TEST_P(ClientIntegrationTest, TimeoutOnRequestPath) {
  builder_.setStreamIdleTimeoutSeconds(1);

  autonomous_upstream_ = false;
  initialize();

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), false);

  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*BaseIntegrationTest::dispatcher_,
                                                        upstream_connection_));
  ASSERT_TRUE(
      upstream_connection_->waitForNewStream(*BaseIntegrationTest::dispatcher_, upstream_request_));

  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_headers_calls, 0);
  ASSERT_EQ(cc_.on_data_calls, 0);
  ASSERT_EQ(cc_.on_complete_calls, 0);
  ASSERT_EQ(cc_.on_error_calls, 1);

  if (getCodecType() != Http::CodecType::HTTP1) {
    ASSERT_TRUE(upstream_request_->waitForReset());
  } else {
    ASSERT_TRUE(upstream_connection_->waitForDisconnect());
  }
}

TEST_P(ClientIntegrationTest, TimeoutOnResponsePath) {
  builder_.setStreamIdleTimeoutSeconds(1);
  autonomous_upstream_ = false;
  initialize();

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);

  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*BaseIntegrationTest::dispatcher_,
                                                        upstream_connection_));
  ASSERT_TRUE(
      upstream_connection_->waitForNewStream(*BaseIntegrationTest::dispatcher_, upstream_request_));

  // Send response headers but no body.
  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{":status", "200"}}, false);

  // Wait for timeout.
  terminal_callback_.waitReady();

  ASSERT_EQ(cc_.on_headers_calls, 1);
  ASSERT_EQ(cc_.status, "200");
  ASSERT_EQ(cc_.on_data_calls, 0);
  ASSERT_EQ(cc_.on_complete_calls, 0);
  ASSERT_EQ(cc_.on_error_calls, 1);

  if (upstreamProtocol() != Http::CodecType::HTTP1) {
    ASSERT_TRUE(upstream_request_->waitForReset());
  }
}

TEST_P(ClientIntegrationTest, ResetWithBidiTraffic) {
  autonomous_upstream_ = false;
  initialize();
  ConditionalInitializer headers_callback;

  stream_prototype_->setOnHeaders(
      [this, &headers_callback](Platform::ResponseHeadersSharedPtr headers, bool,
                                envoy_stream_intel) {
        cc_.status = absl::StrCat(headers->httpStatus());
        cc_.on_headers_calls++;
        headers_callback.setReady();
        return nullptr;
      });

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), false);

  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*BaseIntegrationTest::dispatcher_,
                                                        upstream_connection_));
  ASSERT_TRUE(
      upstream_connection_->waitForNewStream(*BaseIntegrationTest::dispatcher_, upstream_request_));

  // Send response headers but no body.
  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{":status", "200"}}, false);
  // Make sure the headers are sent up.
  headers_callback.waitReady();
  // Reset the stream.
  upstream_request_->encodeResetStream();

  // Encoding data should not be problematic.
  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");
  envoy_data c_data = Data::Utility::toBridgeData(request_data);
  stream_->sendData(c_data);
  // Make sure cancel isn't problematic.
  stream_->cancel();
}

TEST_P(ClientIntegrationTest, ResetWithBidiTrafficExplicitData) {
  explicit_flow_control_ = true;
  autonomous_upstream_ = false;
  // TODO(32024) remove trace logging.
  builder_.addLogLevel(Platform::LogLevel::trace);
  initialize();
  ConditionalInitializer headers_callback;

  stream_prototype_->setOnHeaders(
      [this, &headers_callback](Platform::ResponseHeadersSharedPtr headers, bool,
                                envoy_stream_intel) {
        cc_.status = absl::StrCat(headers->httpStatus());
        cc_.on_headers_calls++;
        headers_callback.setReady();
        return nullptr;
      });

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), false);

  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*BaseIntegrationTest::dispatcher_,
                                                        upstream_connection_));
  ASSERT_TRUE(
      upstream_connection_->waitForNewStream(*BaseIntegrationTest::dispatcher_, upstream_request_));

  // Send response headers and body but no fin.
  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{":status", "200"}}, false);
  upstream_request_->encodeData(1, false);
  upstream_request_->encodeResetStream();
  if (getCodecType() != Http::CodecType::HTTP3) {
    // Make sure the headers are sent up.
    headers_callback.waitReady();
  }

  // Encoding data should not be problematic.
  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");
  envoy_data c_data = Data::Utility::toBridgeData(request_data);
  stream_->sendData(c_data);
  // Make sure cancel isn't problematic.
  stream_->cancel();
}

TEST_P(ClientIntegrationTest, Proxying) {
  if (getCodecType() != Http::CodecType::HTTP1) {
    return;
  }
  initialize();
  {
    absl::MutexLock l(&engine_lock_);
    engine_->engine()->setProxySettings(fake_upstreams_[0]->localAddress()->asString().c_str(),
                                        fake_upstreams_[0]->localAddress()->ip()->port());
  }
  // The initial request will do the DNS lookup.
  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
  terminal_callback_.waitReady();
  ASSERT_EQ(cc_.status, "200");
  ASSERT_EQ(cc_.on_complete_calls, 1);
  stream_.reset();

  // The second request will use the cached DNS entry and should succeed as well.
  stream_ = (*stream_prototype_).start(explicit_flow_control_);
  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
  terminal_callback_.waitReady();
  ASSERT_EQ(cc_.status, "200");
  ASSERT_EQ(cc_.on_complete_calls, 2);
}

TEST_P(ClientIntegrationTest, DirectResponse) {
  initialize();

  // Override to not validate stream intel.
  stream_prototype_->setOnComplete(
      [this](envoy_stream_intel, envoy_final_stream_intel final_intel) {
        cc_.on_complete_received_byte_count = final_intel.received_byte_count;
        cc_.on_complete_calls++;
        cc_.terminal_callback->setReady();
      });

  default_request_headers_.setHost("127.0.0.1");
  default_request_headers_.setPath("/");

  stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
  terminal_callback_.waitReady();
  ASSERT_EQ(cc_.status, "404");
  ASSERT_EQ(cc_.on_headers_calls, 1);
  stream_.reset();

  // Verify the default runtime values.
  EXPECT_FALSE(Runtime::runtimeFeatureEnabled("envoy.reloadable_features.test_feature_false"));
  EXPECT_TRUE(Runtime::runtimeFeatureEnabled("envoy.reloadable_features.test_feature_true"));
}

TEST_P(ClientIntegrationTest, TestRuntimeSet) {
  builder_.setRuntimeGuard("test_feature_true", false);
  builder_.setRuntimeGuard("test_feature_false", true);
  initialize();

  // Verify that the Runtime config values are from the RTDS response.
  EXPECT_TRUE(Runtime::runtimeFeatureEnabled("envoy.reloadable_features.test_feature_false"));
  EXPECT_FALSE(Runtime::runtimeFeatureEnabled("envoy.reloadable_features.test_feature_true"));
}

TEST_P(ClientIntegrationTest, TestStats) {
  initialize();

  {
    absl::MutexLock l(&engine_lock_);
    std::string stats = engine_->dumpStats();
    EXPECT_TRUE((absl::StrContains(stats, "runtime.load_success: 1"))) << stats;
  }
}

} // namespace
} // namespace Envoy
#pragma once

#include "source/extensions/transport_sockets/tls/ssl_socket.h"

// test_runner setups
#include "source/exe/process_wide.h"
#include "source/server/listener_hooks.h"

#include "envoy/extensions/transport_sockets/quic/v3/quic_transport.pb.h"
#include "test/integration/autonomous_upstream.h"
#include "test/mocks/server/transport_socket_factory_context.h"
#include "test/integration/server.h"

#include "tools/cpp/runfiles/runfiles.h"

namespace Envoy {

enum class TestServerType {
  HTTP1_WITHOUT_TLS,
  HTTP2_WITH_TLS,
  HTTP3,
  HTTP_PROXY,
  HTTPS_PROXY,
};

class TestServer : public ListenerHooks {
private:
  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext> factory_context_;
  Stats::IsolatedStoreImpl stats_store_;
  Event::GlobalTimeSystem time_system_;
  Api::ApiPtr api_;
  Network::Address::IpVersion version_;
  FakeUpstreamConfig upstream_config_;
  int port_;
  Thread::SkipAsserts skip_asserts_;
  ProcessWide process_wide;
  Thread::MutexBasicLockable lock;
  Extensions::TransportSockets::Tls::ContextManagerImpl context_manager_{time_system_};
  std::unique_ptr<bazel::tools::cpp::runfiles::Runfiles> runfiles_;

  // Either test_server_ will be set for test_server_type is a proxy, otherwise upstream_ will be
  // used.
  std::unique_ptr<AutonomousUpstream> upstream_;
  IntegrationTestServerPtr test_server_;

  Network::DownstreamTransportSocketFactoryPtr createQuicUpstreamTlsContext(
      testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>&);

  Network::DownstreamTransportSocketFactoryPtr createUpstreamTlsContext(
      testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>&);

  static const std::string http_proxy_config;
  static const std::string https_proxy_config;

public:
  TestServer();

  /**
   * Starts the server. Can only have one server active per JVM. This is blocking until the port can
   * start accepting requests.
   * test_server_type: selects between TestServerTypes
   */
  void startTestServer(TestServerType test_server_type);

  /**
   * Shutdowns the server. Can be restarted later. This is blocking until the server has freed all
   * resources.
   */
  void shutdownTestServer();

  /**
   * Returns the port that got attributed. Can only be called once the server has been started.
   */
  int getServerPort();

  /**
   * Sets headers and data for the test server to return on all future requests.
   * Can only be called once the server has been started.
   */
  void setHeadersAndData(absl::string_view header_key, absl::string_view header_value,
                         absl::string_view response_body);

  // ListenerHooks
  void onWorkerListenerAdded() override {}
  void onWorkerListenerRemoved() override {}
  void onWorkersStarted() override {}
};

} // namespace Envoy
#include "base_client_integration_test.h"

#include <string>

#include "test/common/http/common.h"
#include "test/test_common/utility.h"

#include "absl/synchronization/notification.h"
#include "gtest/gtest.h"
#include "library/cc/bridge_utility.h"
#include "library/cc/log_level.h"
#include "library/common/engine.h"
#include "library/common/http/header_utility.h"
#include "spdlog/spdlog.h"

namespace Envoy {
namespace {

void validateStreamIntel(const envoy_final_stream_intel& final_intel, bool expect_dns,
                         bool upstream_tls, bool is_first_request) {
  if (expect_dns) {
    EXPECT_NE(-1, final_intel.dns_start_ms);
    EXPECT_NE(-1, final_intel.dns_end_ms);
  }

  if (upstream_tls) {
    EXPECT_GT(final_intel.ssl_start_ms, 0);
    EXPECT_GT(final_intel.ssl_end_ms, 0);
  } else {
    EXPECT_EQ(-1, final_intel.ssl_start_ms);
    EXPECT_EQ(-1, final_intel.ssl_end_ms);
  }

  ASSERT_NE(-1, final_intel.stream_start_ms);
  ASSERT_NE(-1, final_intel.connect_start_ms);
  ASSERT_NE(-1, final_intel.connect_end_ms);
  ASSERT_NE(-1, final_intel.sending_start_ms);
  ASSERT_NE(-1, final_intel.sending_end_ms);
  ASSERT_NE(-1, final_intel.response_start_ms);
  ASSERT_NE(-1, final_intel.stream_end_ms);

  if (is_first_request) {
    ASSERT_LE(final_intel.stream_start_ms, final_intel.connect_start_ms);
  }
  ASSERT_LE(final_intel.connect_start_ms, final_intel.connect_end_ms);
  ASSERT_LE(final_intel.connect_end_ms, final_intel.sending_start_ms);
  ASSERT_LE(final_intel.sending_start_ms, final_intel.sending_end_ms);
  ASSERT_LE(final_intel.response_start_ms, final_intel.stream_end_ms);
}

// Gets the spdlog level from the test options and converts it to the Platform::LogLevel used by
// the Envoy Mobile engine.
Platform::LogLevel getPlatformLogLevelFromOptions() {
  switch (TestEnvironment::getOptions().logLevel()) {
  case spdlog::level::level_enum::trace:
    return Platform::LogLevel::trace;
  case spdlog::level::level_enum::debug:
    return Platform::LogLevel::debug;
  case spdlog::level::level_enum::info:
    return Platform::LogLevel::info;
  case spdlog::level::level_enum::warn:
    return Platform::LogLevel::warn;
  case spdlog::level::level_enum::err:
    return Platform::LogLevel::error;
  case spdlog::level::level_enum::critical:
    return Platform::LogLevel::critical;
  case spdlog::level::level_enum::off:
    return Platform::LogLevel::off;
  default:
    ENVOY_LOG_MISC(warn, "Couldn't map spdlog level {}. Using `info` level.",
                   TestEnvironment::getOptions().logLevel());
    return Platform::LogLevel::info;
  }
}

} // namespace

// Use the Envoy mobile default config as much as possible in this test.
// There are some config modifiers below which do result in deltas.
// Note: This function is only used to build the Engine if `override_builder_config_` is true.
envoy::config::bootstrap::v3::Bootstrap defaultConfig() {
  Platform::EngineBuilder builder;
  std::unique_ptr<envoy::config::bootstrap::v3::Bootstrap> bootstrap = builder.generateBootstrap();
  envoy::config::bootstrap::v3::Bootstrap to_return = *bootstrap;
  return to_return;
}

BaseClientIntegrationTest::BaseClientIntegrationTest(Network::Address::IpVersion ip_version)
    : BaseIntegrationTest(BaseIntegrationTest::defaultAddressFunction(ip_version), ip_version,
                          defaultConfig()) {
  skip_tag_extraction_rule_check_ = true;
  full_dispatcher_ = api_->allocateDispatcher("fake_envoy_mobile");
  use_lds_ = false;
  autonomous_upstream_ = true;
  defer_listener_finalization_ = true;
  memset(&last_stream_final_intel_, 0, sizeof(envoy_final_stream_intel));

  builder_.addLogLevel(getPlatformLogLevelFromOptions());
  // The admin interface gets added by default in the ConfigHelper's constructor. Since the admin
  // interface gets compiled out by default in Envoy Mobile, remove it from the ConfigHelper's
  // bootstrap config.
  config_helper_.addConfigModifier(
      [](envoy::config::bootstrap::v3::Bootstrap& bootstrap) { bootstrap.clear_admin(); });
}

void BaseClientIntegrationTest::initialize() {
  BaseIntegrationTest::initialize();
  {
    absl::MutexLock l(&engine_lock_);
    stream_prototype_ = engine_->streamClient()->newStreamPrototype();
  }

  stream_prototype_->setOnHeaders(
      [this](Platform::ResponseHeadersSharedPtr headers, bool, envoy_stream_intel intel) {
        cc_.on_headers_calls++;
        cc_.status = absl::StrCat(headers->httpStatus());
        cc_.on_header_consumed_bytes_from_response = intel.consumed_bytes_from_response;
      });
  stream_prototype_->setOnData([this](envoy_data c_data, bool) {
    cc_.on_data_calls++;
    release_envoy_data(c_data);
  });
  stream_prototype_->setOnComplete(
      [this](envoy_stream_intel, envoy_final_stream_intel final_intel) {
        memcpy(&last_stream_final_intel_, &final_intel, sizeof(envoy_final_stream_intel));
        if (expect_data_streams_) {
          validateStreamIntel(final_intel, expect_dns_, upstream_tls_, cc_.on_complete_calls == 0);
        }
        cc_.on_complete_received_byte_count = final_intel.received_byte_count;
        cc_.on_complete_calls++;
        cc_.terminal_callback->setReady();
      });
  stream_prototype_->setOnError(
      [this](Platform::EnvoyErrorSharedPtr, envoy_stream_intel, envoy_final_stream_intel) {
        cc_.on_error_calls++;
        cc_.terminal_callback->setReady();
      });
  stream_prototype_->setOnCancel([this](envoy_stream_intel, envoy_final_stream_intel final_intel) {
    EXPECT_NE(-1, final_intel.stream_start_ms);
    cc_.on_cancel_calls++;
    cc_.terminal_callback->setReady();
  });

  stream_ = (*stream_prototype_).start(explicit_flow_control_);
  HttpTestUtility::addDefaultHeaders(default_request_headers_);
  default_request_headers_.setHost(fake_upstreams_[0]->localAddress()->asStringView());
}

std::shared_ptr<Platform::RequestHeaders> BaseClientIntegrationTest::envoyToMobileHeaders(
    const Http::TestRequestHeaderMapImpl& request_headers) {

  Platform::RequestHeadersBuilder builder(
      Platform::RequestMethod::GET,
      std::string(default_request_headers_.Scheme()->value().getStringView()),
      std::string(default_request_headers_.Host()->value().getStringView()),
      std::string(default_request_headers_.Path()->value().getStringView()));

  request_headers.iterate(
      [&request_headers, &builder](const Http::HeaderEntry& header) -> Http::HeaderMap::Iterate {
        std::string key = std::string(header.key().getStringView());
        if (request_headers.formatter().has_value()) {
          const Envoy::Http::StatefulHeaderKeyFormatter& formatter =
              request_headers.formatter().value();
          key = formatter.format(key);
        }
        auto value = std::vector<std::string>();
        value.push_back(std::string(header.value().getStringView()));
        builder.set(key, value);
        return Http::HeaderMap::Iterate::Continue;
      });

  return std::make_shared<Platform::RequestHeaders>(builder.build());
}

void BaseClientIntegrationTest::threadRoutine(absl::Notification& engine_running) {
  builder_.setOnEngineRunning([&]() { engine_running.Notify(); });
  {
    absl::MutexLock l(&engine_lock_);
    engine_ = builder_.build();
  }
  full_dispatcher_->run(Event::Dispatcher::RunType::Block);
}

void BaseClientIntegrationTest::TearDown() {
  if (xds_connection_ != nullptr) {
    cleanUpXdsConnection();
  }
  test_server_.reset();
  fake_upstreams_.clear();
  {
    absl::MutexLock l(&engine_lock_);
    if (engine_) {
      engine_->terminate();
      engine_.reset();
    }
  }
  stream_.reset();
  stream_prototype_.reset();
  full_dispatcher_->exit();
  if (envoy_thread_) {
    envoy_thread_->join();
    envoy_thread_.reset();
  }
}

void BaseClientIntegrationTest::createEnvoy() {
  std::vector<uint32_t> ports;
  for (auto& upstream : fake_upstreams_) {
    if (upstream->localAddress()->ip()) {
      ports.push_back(upstream->localAddress()->ip()->port());
    }
  }

  absl::Notification engine_running;
  envoy_thread_ = api_->threadFactory().createThread(
      [this, &engine_running]() -> void { threadRoutine(engine_running); });
  engine_running.WaitForNotification();
}

uint64_t BaseClientIntegrationTest::getCounterValue(const std::string& name) {
  uint64_t counter_value = 0UL;
  uint64_t* counter_value_ptr = &counter_value;
  absl::Notification counter_value_set;
  auto engine = reinterpret_cast<Envoy::Engine*>(rawEngine());
  engine->dispatcher().post([&] {
    Stats::CounterSharedPtr counter = TestUtility::findCounter(engine->getStatsStore(), name);
    if (counter != nullptr) {
      *counter_value_ptr = counter->value();
    }
    counter_value_set.Notify();
  });

  EXPECT_TRUE(counter_value_set.WaitForNotificationWithTimeout(absl::Seconds(5)));
  return counter_value;
}

testing::AssertionResult BaseClientIntegrationTest::waitForCounterGe(const std::string& name,
                                                                     uint64_t value) {
  constexpr std::chrono::milliseconds timeout = TestUtility::DefaultTimeout;
  Event::TestTimeSystem::RealTimeBound bound(timeout);
  while (getCounterValue(name) < value) {
    timeSystem().advanceTimeWait(std::chrono::milliseconds(10));
    if (timeout != std::chrono::milliseconds::zero() && !bound.withinBound()) {
      return testing::AssertionFailure()
             << fmt::format("timed out waiting for {} to be {}", name, value);
    }
  }
  return testing::AssertionSuccess();
}

uint64_t BaseClientIntegrationTest::getGaugeValue(const std::string& name) {
  uint64_t gauge_value = 0UL;
  uint64_t* gauge_value_ptr = &gauge_value;
  absl::Notification gauge_value_set;
  auto engine = reinterpret_cast<Envoy::Engine*>(rawEngine());
  engine->dispatcher().post([&] {
    Stats::GaugeSharedPtr gauge = TestUtility::findGauge(engine->getStatsStore(), name);
    if (gauge != nullptr) {
      *gauge_value_ptr = gauge->value();
    }
    gauge_value_set.Notify();
  });
  EXPECT_TRUE(gauge_value_set.WaitForNotificationWithTimeout(absl::Seconds(5)));
  return gauge_value;
}

testing::AssertionResult BaseClientIntegrationTest::waitForGaugeGe(const std::string& name,
                                                                   uint64_t value) {
  constexpr std::chrono::milliseconds timeout = TestUtility::DefaultTimeout;
  Event::TestTimeSystem::RealTimeBound bound(timeout);
  while (getGaugeValue(name) < value) {
    timeSystem().advanceTimeWait(std::chrono::milliseconds(10));
    if (timeout != std::chrono::milliseconds::zero() && !bound.withinBound()) {
      return testing::AssertionFailure()
             << fmt::format("timed out waiting for {} to be {}", name, value);
    }
  }
  return testing::AssertionSuccess();
}
} // namespace Envoy
#include "envoy/config/bootstrap/v3/bootstrap.pb.h"
#include "envoy/service/runtime/v3/rtds.pb.h"

#include "test/common/integration/xds_integration_test.h"
#include "test/test_common/environment.h"
#include "test/test_common/test_runtime.h"
#include "test/test_common/utility.h"

#include "gtest/gtest.h"

namespace Envoy {
namespace {

class RtdsIntegrationTest : public XdsIntegrationTest {
public:
  void initialize() override {
    // using http1 because the h1 cluster has a plaintext socket
    setUpstreamProtocol(Http::CodecType::HTTP1);

    XdsIntegrationTest::initialize();

    default_request_headers_.setScheme("http");
    initializeXdsStream();
  }

  void createEnvoy() override {
    Platform::XdsBuilder xds_builder(
        /*xds_server_address=*/Network::Test::getLoopbackAddressUrlString(ipVersion()),
        /*xds_server_port=*/fake_upstreams_[1]->localAddress()->ip()->port());
    // Add the layered runtime config, which includes the RTDS layer.
    xds_builder.addRuntimeDiscoveryService("some_rtds_resource", /*timeout_in_seconds=*/1)
        .setSslRootCerts(getUpstreamCert());
    builder_.setXds(std::move(xds_builder));
    XdsIntegrationTest::createEnvoy();
  }

  void SetUp() override { initialize(); }

  void runReloadTest() {
    // Send a request on the data plane.
    stream_->sendHeaders(envoyToMobileHeaders(default_request_headers_), true);
    terminal_callback_.waitReady();

    EXPECT_EQ(cc_.on_headers_calls, 1);
    EXPECT_EQ(cc_.status, "200");
    EXPECT_EQ(cc_.on_data_calls, 2);
    EXPECT_EQ(cc_.on_complete_calls, 1);
    EXPECT_EQ(cc_.on_cancel_calls, 0);
    EXPECT_EQ(cc_.on_error_calls, 0);
    EXPECT_EQ(cc_.on_header_consumed_bytes_from_response, 27);
    EXPECT_EQ(cc_.on_complete_received_byte_count, 67);
    // Check that the Runtime config is from the static layer.
    EXPECT_FALSE(Runtime::runtimeFeatureEnabled("envoy.reloadable_features.test_feature_false"));

    const std::string load_success_counter = "runtime.load_success";
    uint64_t load_success_value = getCounterValue(load_success_counter);
    // Send a RTDS request and get back the RTDS response.
    EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Runtime, "", {"some_rtds_resource"},
                                        {"some_rtds_resource"}, {}, true));

    envoy::service::runtime::v3::Runtime some_rtds_resource;
    some_rtds_resource.set_name("some_rtds_resource");
    auto* static_layer = some_rtds_resource.mutable_layer();
    (*static_layer->mutable_fields())["envoy.reloadable_features.test_feature_false"]
        .set_bool_value(true);

    sendDiscoveryResponse<envoy::service::runtime::v3::Runtime>(
        Config::TypeUrl::get().Runtime, {some_rtds_resource}, {some_rtds_resource}, {}, "1");
    // Wait until the RTDS updates from the DiscoveryResponse have been applied.
    ASSERT_TRUE(waitForCounterGe(load_success_counter, load_success_value + 1));

    // Verify that the Runtime config values are from the RTDS response.
    EXPECT_TRUE(Runtime::runtimeFeatureEnabled("envoy.reloadable_features.test_feature_false"));

    load_success_value = getCounterValue(load_success_counter);
    EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Runtime, "", {"some_rtds_resource"},
                                        {"some_rtds_resource"}, {}));
    (*static_layer->mutable_fields())["envoy.reloadable_features.test_feature_false"]
        .set_bool_value(false);

    // Send another response with Resource wrapper.
    sendDiscoveryResponse<envoy::service::runtime::v3::Runtime>(
        Config::TypeUrl::get().Runtime, {some_rtds_resource}, {some_rtds_resource}, {}, "2",
        {{"test", ProtobufWkt::Any()}});
    // Wait until the RTDS updates from the DiscoveryResponse have been applied.
    ASSERT_TRUE(waitForCounterGe(load_success_counter, load_success_value + 1));

    // Verify that the Runtime config values are from the RTDS response.
    EXPECT_FALSE(Runtime::runtimeFeatureEnabled("envoy.reloadable_features.test_feature_false"));
  }
};

INSTANTIATE_TEST_SUITE_P(
    IpVersionsClientTypeDelta, RtdsIntegrationTest,
    testing::Combine(testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
                     testing::ValuesIn(TestEnvironment::getsGrpcVersionsForTest()),
                     // Envoy Mobile's xDS APIs only support state-of-the-world, not delta.
                     testing::Values(Grpc::SotwOrDelta::Sotw, Grpc::SotwOrDelta::UnifiedSotw)));

TEST_P(RtdsIntegrationTest, RtdsReloadWithDfpMixedScheme) {
  TestScopedStaticReloadableFeaturesRuntime scoped_runtime({{"dfp_mixed_scheme", true}});
  runReloadTest();
}

TEST_P(RtdsIntegrationTest, RtdsReloadWithoutDfpMixedScheme) {
  TestScopedStaticReloadableFeaturesRuntime scoped_runtime({{"dfp_mixed_scheme", false}});
  runReloadTest();
}

} // namespace
} // namespace Envoy
#pragma once

#include "envoy/config/bootstrap/v3/bootstrap.pb.h"
#include "envoy/config/cluster/v3/cluster.pb.h"

#include "test/common/grpc/grpc_client_integration.h"
#include "test/common/integration/base_client_integration_test.h"

#include "absl/strings/string_view.h"
#include "gtest/gtest.h"

namespace Envoy {

static constexpr absl::string_view XDS_CLUSTER = "xds_cluster.lyft.com";

// A base class for xDS integration tests. It provides common functionality for integration tests
// derived from BaseClientIntegrationTest that needs to communicate with upstream xDS servers.
class XdsIntegrationTest : public BaseClientIntegrationTest,
                           public Grpc::DeltaSotwIntegrationParamTest {
public:
  XdsIntegrationTest();
  virtual ~XdsIntegrationTest() = default;
  void initialize() override;
  void TearDown() override { BaseClientIntegrationTest::TearDown(); }

protected:
  void SetUp() override;

  void createEnvoy() override;

  // Initializes the xDS connection and creates a gRPC bi-directional stream for receiving
  // DiscoveryRequests and sending DiscoveryResponses.
  void initializeXdsStream();

  // Returns the IP version that the test is running with (IPv4 or IPv6).
  Network::Address::IpVersion ipVersion() const override;
  // Returns the gRPC client type that the test is running with (Envoy gRPC or Google gRPC).
  Grpc::ClientType clientType() const override;
  // Returns whether the test is using the state-of-the-world or Delta xDS protocol.
  Grpc::SotwOrDelta sotwOrDelta() const;

  // Creates a cluster config with a single static endpoint, where the endpoint is intended to be of
  // a fake upstream on the loopback address.
  envoy::config::cluster::v3::Cluster
  createSingleEndpointClusterConfig(const std::string& cluster_name);

  // Gets the upstream cert for the xDS cluster's TLS over the `base` cluster.
  std::string getUpstreamCert();
};

} // namespace Envoy
#include "xds_integration_test.h"

#include "envoy/config/bootstrap/v3/bootstrap.pb.h"
#include "envoy/config/cluster/v3/cluster.pb.h"

#include "test/common/grpc/grpc_client_integration.h"
#include "test/common/integration/base_client_integration_test.h"
#include "test/test_common/environment.h"
#include "test/test_common/utility.h"

#include "extension_registry.h"
#include "gtest/gtest.h"

namespace Envoy {

using ::testing::AssertionFailure;
using ::testing::AssertionResult;
using ::testing::AssertionSuccess;

XdsIntegrationTest::XdsIntegrationTest() : BaseClientIntegrationTest(ipVersion()) {}

void XdsIntegrationTest::initialize() {
  create_xds_upstream_ = true;
  tls_xds_upstream_ = true;
  sotw_or_delta_ = sotwOrDelta();

  // Register the extensions required for Envoy Mobile.
  ExtensionRegistry::registerFactories();

  if (sotw_or_delta_ == Grpc::SotwOrDelta::UnifiedSotw ||
      sotw_or_delta_ == Grpc::SotwOrDelta::UnifiedDelta) {
    config_helper_.addRuntimeOverride("envoy.reloadable_features.unified_mux", "true");
  }

  // xDS upstream is created separately in the test infra, and there's only one non-xDS cluster.
  setUpstreamCount(1);

  BaseClientIntegrationTest::initialize();

  default_request_headers_.setScheme("https");
}

Network::Address::IpVersion XdsIntegrationTest::ipVersion() const {
  return std::get<0>(GetParam());
}

Grpc::ClientType XdsIntegrationTest::clientType() const { return std::get<1>(GetParam()); }

Grpc::SotwOrDelta XdsIntegrationTest::sotwOrDelta() const { return std::get<2>(GetParam()); }

void XdsIntegrationTest::SetUp() {
  // TODO(abeyad): Add paramaterized tests for HTTP1, HTTP2, and HTTP3.
  setUpstreamProtocol(Http::CodecType::HTTP2);
}

void XdsIntegrationTest::createEnvoy() {
  BaseClientIntegrationTest::createEnvoy();
  if (on_server_init_function_) {
    on_server_init_function_();
  }
}

void XdsIntegrationTest::initializeXdsStream() {
  createXdsConnection();
  AssertionResult result =
      xds_connection_->waitForNewStream(*BaseIntegrationTest::dispatcher_, xds_stream_);
  RELEASE_ASSERT(result, result.message());
  xds_stream_->startGrpcStream();
}

envoy::config::cluster::v3::Cluster
XdsIntegrationTest::createSingleEndpointClusterConfig(const std::string& cluster_name) {
  envoy::config::cluster::v3::Cluster config;
  config.set_name(cluster_name);

  // Set the endpoint.
  auto* load_assignment = config.mutable_load_assignment();
  load_assignment->set_cluster_name(cluster_name);
  auto* endpoint = load_assignment->add_endpoints()->add_lb_endpoints()->mutable_endpoint();
  endpoint->mutable_address()->mutable_socket_address()->set_address(
      Network::Test::getLoopbackAddressString(ipVersion()));
  endpoint->mutable_address()->mutable_socket_address()->set_port_value(0);

  // Set the protocol options.
  envoy::extensions::upstreams::http::v3::HttpProtocolOptions options;
  options.mutable_explicit_http_config()->mutable_http2_protocol_options();
  (*config.mutable_typed_extension_protocol_options())
      ["envoy.extensions.upstreams.http.v3.HttpProtocolOptions"]
          .PackFrom(options);
  return config;
}

std::string XdsIntegrationTest::getUpstreamCert() {
  return TestEnvironment::readFileToStringForTest(
      TestEnvironment::runfilesPath("test/config/integration/certs/upstreamcacert.pem"));
}

} // namespace Envoy

load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_test",
    "envoy_cc_test_library",
    "envoy_mobile_package",
    "envoy_select_envoy_mobile_xds",
    "envoy_select_signal_trace",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_test(
    name = "client_integration_test",
    srcs = ["client_integration_test.cc"],
    exec_properties = {
        # TODO(willengflow): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    repository = "@envoy",
    shard_count = 6,
    deps = [
        ":base_client_integration_test_lib",
        "//test/common/mocks/common:common_mocks",
        "@envoy//source/common/quic:active_quic_listener_lib",
        "@envoy//source/common/quic:client_connection_factory_lib",
        "@envoy//source/common/quic:quic_server_factory_lib",
        "@envoy//source/common/quic:quic_server_transport_socket_factory_lib",
        "@envoy//source/common/quic:quic_transport_socket_factory_lib",
        "@envoy//source/common/quic:udp_gso_batch_writer_lib",
        "@envoy//source/extensions/udp_packet_writer/gso:config",
        "@envoy//test/test_common:test_random_generator_lib",
    ],
)

envoy_cc_test(
    name = "rtds_integration_test",
    srcs = envoy_select_envoy_mobile_xds(
        ["rtds_integration_test.cc"],
        "@envoy",
    ),
    data = [
        "@envoy//test/config/integration/certs",
    ],
    exec_properties = {
        # TODO(willengflow): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    external_deps = [
        "abseil_strings",
    ],
    repository = "@envoy",
    deps = [
        ":xds_integration_test_lib",
        "@envoy//test/test_common:environment_lib",
        "@envoy//test/test_common:test_runtime_lib",
        "@envoy//test/test_common:utility_lib",
        "@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto",
        "@envoy_api//envoy/service/runtime/v3:pkg_cc_proto",
    ],
)

envoy_cc_test(
    name = "cds_integration_test",
    srcs = envoy_select_envoy_mobile_xds(
        ["cds_integration_test.cc"],
        "@envoy",
    ),
    data = [
        "@envoy//test/config/integration/certs",
    ],
    exec_properties = {
        # TODO(willengflow): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    external_deps = [
        "abseil_strings",
    ],
    repository = "@envoy",
    deps = [
        ":xds_integration_test_lib",
        "@envoy//test/test_common:environment_lib",
        "@envoy//test/test_common:utility_lib",
        "@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto",
        "@envoy_api//envoy/service/runtime/v3:pkg_cc_proto",
    ],
)

envoy_cc_test(
    name = "sds_integration_test",
    srcs = envoy_select_envoy_mobile_xds(
        ["sds_integration_test.cc"],
        "@envoy",
    ),
    data = [
        "@envoy//test/config/integration/certs",
    ],
    exec_properties = {
        # TODO(willengflow): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    repository = "@envoy",
    deps = [
        ":xds_integration_test_lib",
        "@envoy//source/common/config:protobuf_link_hacks",
        "@envoy//source/extensions/transport_sockets/tls:config",
        "@envoy//source/extensions/transport_sockets/tls:context_config_lib",
        "@envoy//source/extensions/transport_sockets/tls:context_lib",
        "@envoy//test/test_common:environment_lib",
        "@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/cluster/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
        "@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto",
        "@envoy_api//envoy/service/secret/v3:pkg_cc_proto",
    ],
)

envoy_cc_test_library(
    name = "base_client_integration_test_lib",
    srcs = [
        "base_client_integration_test.cc",
    ],
    hdrs = [
        "base_client_integration_test.h",
    ],
    repository = "@envoy",
    deps = [
        "//library/cc:engine_builder_lib",
        "//library/common/http:client_lib",
        "//library/common/http:header_utility_lib",
        "//library/common/types:c_types_lib",
        "@envoy//test/common/http:common_lib",
        "@envoy//test/integration:http_integration_lib",
        "@envoy//test/test_common:utility_lib",
    ],
)

envoy_cc_test_library(
    name = "xds_integration_test_lib",
    srcs = [
        "xds_integration_test.cc",
    ],
    hdrs = [
        "xds_integration_test.h",
    ],
    repository = "@envoy",
    deps = [
        ":base_client_integration_test_lib",
        "@envoy//source/common/config:api_version_lib",
        "@envoy//test/test_common:environment_lib",
        "@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto",
        "@envoy_api//envoy/config/cluster/v3:pkg_cc_proto",
        "@envoy_build_config//:extension_registry",
        "@envoy_build_config//:test_extensions",
    ],
)

# interface libs for test servers` jni implementations
envoy_cc_test_library(
    name = "test_server_interface_lib",
    srcs = [
        "test_server.cc",
        "test_server_interface.cc",
    ],
    hdrs = [
        "test_server.h",
        "test_server_interface.h",
    ],
    data = [
        "@envoy//test/config/integration/certs",
    ],
    repository = "@envoy",
    deps = [
        "@envoy//source/common/listener_manager:listener_manager_lib",
        "@envoy//source/exe:process_wide_lib",
        "@envoy//test/integration:autonomous_upstream_lib",
        "@envoy//test/integration:utility_lib",
        "@envoy//test/mocks/server:transport_socket_factory_context_mocks",
        "@envoy//test/test_common:environment_lib",
        "@envoy_build_config//:extension_registry",
    ] + envoy_select_signal_trace(
        ["@envoy//source/common/signal:sigaction_lib"],
        "@envoy",
    ),
)

envoy_cc_test_library(
    name = "xds_test_server_interface_lib",
    srcs = [
        "xds_test_server.cc",
        "xds_test_server_interface.cc",
    ],
    hdrs = [
        "xds_test_server.h",
        "xds_test_server_interface.h",
    ],
    repository = "@envoy",
    deps = [
        ":base_client_integration_test_lib",
        "@envoy//source/common/event:libevent_lib",
        "@envoy//source/exe:process_wide_lib",
        "@envoy//source/extensions/transport_sockets/tls:context_config_lib",
        "@envoy//source/extensions/transport_sockets/tls:context_lib",
        "@envoy//source/extensions/transport_sockets/tls:ssl_socket_lib",
        "@envoy//test/integration:autonomous_upstream_lib",
        "@envoy//test/integration:utility_lib",
        "@envoy//test/mocks/server:transport_socket_factory_context_mocks",
        "@envoy//test/test_common:environment_lib",
        "@envoy_api//envoy/extensions/transport_sockets/tls/v3:pkg_cc_proto",
        "@envoy_build_config//:extension_registry",
    ] + envoy_select_signal_trace(
        ["@envoy//source/common/signal:sigaction_lib"],
        "@envoy",
    ),
)
#include "test/common/integration/test_server_interface.h"

#include "extension_registry.h"

// NOLINT(namespace-envoy)

static std::shared_ptr<Envoy::TestServer> strong_test_server_;
static std::weak_ptr<Envoy::TestServer> weak_test_server_;

static std::shared_ptr<Envoy::TestServer> test_server() { return weak_test_server_.lock(); }

void start_server(Envoy::TestServerType test_server_type) {
  Envoy::ExtensionRegistry::registerFactories();
  strong_test_server_ = std::make_shared<Envoy::TestServer>();
  weak_test_server_ = strong_test_server_;

  if (auto server = test_server()) {
    server->startTestServer(test_server_type);
  }
}

void shutdown_server() {
  // Reset the primary handle to the test_server,
  // but retain it long enough to synchronously shutdown.
  auto server = strong_test_server_;
  strong_test_server_.reset();
  server->shutdownTestServer();
}

int get_server_port() {
  if (auto server = test_server()) {
    return server->getServerPort();
  }
  return -1; // failure
}

void set_headers_and_data(absl::string_view header_key, absl::string_view header_value,
                          absl::string_view response_body) {
  if (auto server = test_server()) {
    // start_server() must be called before headers and data can be added.
    ASSERT(server);
    server->setHeadersAndData(header_key, header_value, response_body);
  }
}
#include "envoy/config/cluster/v3/cluster.pb.h"
#include "envoy/config/core/v3/config_source.pb.h"
#include "envoy/extensions/transport_sockets/tls/v3/cert.pb.h"
#include "envoy/service/secret/v3/sds.pb.h"

#include "test/common/integration/xds_integration_test.h"
#include "test/integration/ssl_utility.h"
#include "test/test_common/environment.h"

#include "gtest/gtest.h"

namespace Envoy {
namespace {

// Hack to force linking of the service: https://github.com/google/protobuf/issues/4221.
const envoy::service::secret::v3::SdsDummy _sds_dummy;
constexpr absl::string_view XDS_CLUSTER_NAME = "test_cluster";
constexpr absl::string_view SECRET_NAME = "client_cert";

class SdsIntegrationTest : public XdsIntegrationTest {
public:
  void initialize() override {
    XdsIntegrationTest::initialize();
    initializeXdsStream();
  }

  void createEnvoy() override {
    const std::string target_uri = Network::Test::getLoopbackAddressUrlString(ipVersion());
    Platform::XdsBuilder xds_builder(target_uri,
                                     fake_upstreams_.back()->localAddress()->ip()->port());
    xds_builder.addClusterDiscoveryService().setSslRootCerts(getUpstreamCert());
    builder_.setXds(std::move(xds_builder));
    XdsIntegrationTest::createEnvoy();
  }

  void SetUp() override { initialize(); }

protected:
  void sendCdsResponse() {
    auto cds_cluster = createSingleEndpointClusterConfig(std::string(XDS_CLUSTER_NAME));
    // Update the cluster to use SSL.
    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;
    tls_context.set_sni("lyft.com");
    auto* secret_config =
        tls_context.mutable_common_tls_context()->add_tls_certificate_sds_secret_configs();
    setUpSdsConfig(secret_config, SECRET_NAME);
    auto* transport_socket = cds_cluster.mutable_transport_socket();
    transport_socket->set_name("envoy.transport_sockets.tls");
    transport_socket->mutable_typed_config()->PackFrom(tls_context);
    sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(
        Config::TypeUrl::get().Cluster, {cds_cluster}, {cds_cluster}, {}, "55");
  }

  void sendSdsResponse(const envoy::extensions::transport_sockets::tls::v3::Secret& secret) {
    envoy::service::discovery::v3::DiscoveryResponse discovery_response;
    discovery_response.set_version_info("1");
    discovery_response.set_type_url(Config::TypeUrl::get().Secret);
    discovery_response.add_resources()->PackFrom(secret);
    xds_stream_->sendGrpcMessage(discovery_response);
  }

  void setUpSdsConfig(envoy::extensions::transport_sockets::tls::v3::SdsSecretConfig* secret_config,
                      absl::string_view secret_name) {
    secret_config->set_name(secret_name);
    auto* config_source = secret_config->mutable_sds_config();
    config_source->set_resource_api_version(envoy::config::core::v3::ApiVersion::V3);
    // Envoy Mobile only supports SDS with ADS.
    config_source->mutable_ads();
    config_source->mutable_initial_fetch_timeout()->set_seconds(5);
  }

  static envoy::extensions::transport_sockets::tls::v3::Secret getClientSecret() {
    envoy::extensions::transport_sockets::tls::v3::Secret secret;
    secret.set_name(SECRET_NAME);
    auto* tls_certificate = secret.mutable_tls_certificate();
    tls_certificate->mutable_certificate_chain()->set_filename(
        TestEnvironment::runfilesPath("test/config/integration/certs/clientcert.pem"));
    tls_certificate->mutable_private_key()->set_filename(
        TestEnvironment::runfilesPath("test/config/integration/certs/clientkey.pem"));
    return secret;
  }
};

INSTANTIATE_TEST_SUITE_P(
    IpVersionsClientTypeSotw, SdsIntegrationTest,
    testing::Combine(testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
                     testing::ValuesIn(TestEnvironment::getsGrpcVersionsForTest()),
                     // Envoy Mobile's xDS APIs only support state-of-the-world, not delta.
                     testing::Values(Grpc::SotwOrDelta::Sotw, Grpc::SotwOrDelta::UnifiedSotw)));

// Note: Envoy Mobile does not have listener sockets, so we aren't including a downstream test.
TEST_P(SdsIntegrationTest, SdsForUpstreamCluster) {
  // Wait until the new cluster from CDS is added before sending the SDS response.
  sendCdsResponse();
  ASSERT_TRUE(waitForCounterGe("cluster_manager.cluster_added", 1));

  // Wait until the Envoy instance has obtained an updated secret from the SDS cluster. This
  // verifies that the SDS API is working from the Envoy client and allows us to know we can start
  // sending HTTP requests to the upstream cluster using the secret.
  sendSdsResponse(getClientSecret());
  ASSERT_TRUE(waitForCounterGe(fmt::format("sds.{}.update_success", SECRET_NAME), 1));
  ASSERT_TRUE(
      waitForCounterGe(fmt::format("cluster.{}.client_ssl_socket_factory.ssl_context_update_by_sds",
                                   XDS_CLUSTER_NAME),
                       1));
}

} // namespace
} // namespace Envoy
#pragma once

#include "envoy/api/api.h"

#include "source/common/stats/isolated_store_impl.h"
#include "source/extensions/transport_sockets/tls/context_manager_impl.h"

#include "test/integration/fake_upstream.h"
#include "test/integration/server.h"
#include "test/mocks/server/transport_socket_factory_context.h"
#include "test/test_common/test_time.h"

#include "tools/cpp/runfiles/runfiles.h"

namespace Envoy {

/** An xDS test server. */
class XdsTestServer {
public:
  XdsTestServer();

  /** Starts the xDS server and returns the port number of the server. */
  void start();

  /** Gets the xDS host. */
  std::string getHost() const;

  /** Gets the xDS port. */
  int getPort() const;

  /** Sends a `DiscoveryResponse` from the xDS server. */
  void send(const envoy::service::discovery::v3::DiscoveryResponse& response);

  /** Shuts down the xDS server. */
  void shutdown();

private:
  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext> factory_context_;
  Stats::IsolatedStoreImpl stats_store_;
  Event::GlobalTimeSystem time_system_;
  Api::ApiPtr api_;
  Network::Address::IpVersion version_;
  MockBufferFactory* mock_buffer_factory_;
  Event::DispatcherPtr dispatcher_;
  FakeUpstreamConfig upstream_config_;
  Thread::MutexBasicLockable lock_;
  Extensions::TransportSockets::Tls::ContextManagerImpl context_manager_{time_system_};
  std::unique_ptr<bazel::tools::cpp::runfiles::Runfiles> runfiles_;
  std::unique_ptr<FakeUpstream> xds_upstream_;
  FakeHttpConnectionPtr xds_connection_;
  FakeStreamPtr xds_stream_;
};

} // namespace Envoy
#pragma once

#include "test/common/integration/test_server.h"

// NOLINT(namespace-envoy)

#ifdef __cplusplus
extern "C" { // functions
#endif

/**
 * Starts the server. Can only have one server active per JVM. This is blocking until the port can
 * start accepting requests.
 */
void start_server(Envoy::TestServerType test_server_type);

/**
 * Shutdowns the server. Can be restarted later. This is blocking until the server has freed all
 * resources.
 */
void shutdown_server();

/**
 * Returns the port that got attributed. Can only be called once the server has been started.
 */
int get_server_port();

/**
 * Set response data for server to return for any URL. Can only be called once the server has been
 * started.
 */
void set_headers_and_data(absl::string_view header_key, absl::string_view header_value,
                          absl::string_view response_body);

#ifdef __cplusplus
} // functions
#endif
#pragma once

#include "test/integration/integration.h"

#include "library/cc/engine_builder.h"
#include "library/cc/stream.h"
#include "library/cc/stream_prototype.h"
#include "library/common/http/client.h"
#include "library/common/types/c_types.h"

namespace Envoy {

// Maintains statistics and status data obtained from the Http::Client callbacks.
typedef struct {
  uint32_t on_headers_calls;
  uint32_t on_data_calls;
  uint32_t on_complete_calls;
  uint32_t on_error_calls;
  uint32_t on_cancel_calls;
  uint64_t on_header_consumed_bytes_from_response;
  uint64_t on_complete_received_byte_count;
  std::string status;
  ConditionalInitializer* terminal_callback;
  envoy_final_stream_intel final_intel;
} callbacks_called;

// Based on Http::Utility::toRequestHeaders() but only used for these tests.
Http::ResponseHeaderMapPtr toResponseHeaders(envoy_headers headers);

// Creates a default bootstrap config from the EngineBuilder.
// Only used to build the Engine if `override_builder_config_` is set to true.
envoy::config::bootstrap::v3::Bootstrap defaultConfig();

// A base class for Envoy Mobile client integration tests which interact with Envoy through the
// Http::Client class.
//
// TODO(junr03): move this to derive from the ApiListenerIntegrationTest after moving that class
// into a test lib.
class BaseClientIntegrationTest : public BaseIntegrationTest {
public:
  BaseClientIntegrationTest(Network::Address::IpVersion ip_version);
  virtual ~BaseClientIntegrationTest() = default;
  // Note: This class does not inherit from testing::Test and so this TearDown() method
  // does not override testing::Test::TearDown(). As a result, it will not be called
  // automatically by gtest during shutdown and must be called manually.
  void TearDown();

protected:
  envoy_engine_t rawEngine() {
    absl::MutexLock l(&engine_lock_);
    return reinterpret_cast<envoy_engine_t>(engine_->engine_);
  }
  virtual void initialize() override;
  void createEnvoy() override;
  void threadRoutine(absl::Notification& engine_running);

  // Converts TestRequestHeaderMapImpl to Envoy::Platform::RequestHeadersSharedPtr
  Envoy::Platform::RequestHeadersSharedPtr
  envoyToMobileHeaders(const Http::TestRequestHeaderMapImpl& request_headers);

  // Get the value of a Counter in the Envoy instance.
  uint64_t getCounterValue(const std::string& name);
  // Wait until the Counter specified by `name` is >= `value`.
  ABSL_MUST_USE_RESULT testing::AssertionResult waitForCounterGe(const std::string& name,
                                                                 uint64_t value);
  uint64_t getGaugeValue(const std::string& name);
  ABSL_MUST_USE_RESULT testing::AssertionResult waitForGaugeGe(const std::string& name,
                                                               uint64_t value);

  Event::ProvisionalDispatcherPtr dispatcher_ = std::make_unique<Event::ProvisionalDispatcher>();
  envoy_http_callbacks bridge_callbacks_;
  ConditionalInitializer terminal_callback_;
  callbacks_called cc_{0, 0, 0, 0, 0, 0, 0, "", &terminal_callback_, {}};
  Http::TestRequestHeaderMapImpl default_request_headers_;
  Event::DispatcherPtr full_dispatcher_;
  Platform::StreamPrototypeSharedPtr stream_prototype_;
  Platform::StreamSharedPtr stream_;
  absl::Mutex engine_lock_;
  Platform::EngineSharedPtr engine_ ABSL_GUARDED_BY(engine_lock_);
  Thread::ThreadPtr envoy_thread_;
  bool explicit_flow_control_ = false;
  bool expect_dns_ = true;
  // True if data plane requests are expected in the test; false otherwise.
  bool expect_data_streams_ = true;
  Platform::EngineBuilder builder_;
  envoy_final_stream_intel last_stream_final_intel_;
};

} // namespace Envoy
#include "gtest/gtest.h"
#include "library/common/network/proxy_settings.h"

namespace Envoy {
namespace Network {

class ProxySettingsTest : public testing::Test {
public:
  ProxySettingsTest() {}
};

TEST_F(ProxySettingsTest, SameIPv4AddressesAndPortsAreEqual) {
  EXPECT_EQ(ProxySettings("127.0.0.1", 2222), ProxySettings("127.0.0.1", 2222));
}

TEST_F(ProxySettingsTest, DifferentPortsAreNotEqual) {
  EXPECT_NE(ProxySettings("127.0.0.1", 1111), ProxySettings("127.0.0.1", 2222));
}

TEST_F(ProxySettingsTest, HostnamesAreEqual) {
  EXPECT_EQ(ProxySettings("foo.com", 2222), ProxySettings("foo.com", 2222));
}

TEST_F(ProxySettingsTest, MixUpAddressesAndHostnames) {
  EXPECT_NE(ProxySettings("127.0.0.1", 2222), ProxySettings("", 0));
  EXPECT_NE(ProxySettings("127.0.0.1", 2222), ProxySettings("", 2222));
  EXPECT_NE(ProxySettings("127.0.0.1", 2222), ProxySettings("foo.com", 2222));
}

TEST_F(ProxySettingsTest, HostnamesWithDifferentPortsAreNotEqual) {
  EXPECT_NE(ProxySettings("foo.com", 2), ProxySettings("foo.com", 2222));
}

TEST_F(ProxySettingsTest, DifferentHostnamesAreNotEqual) {
  EXPECT_NE(ProxySettings("bar.com", 2222), ProxySettings("foo.com", 2222));
}

TEST_F(ProxySettingsTest, DifferentAddressesAreNotEqual) {
  EXPECT_NE(ProxySettings("127.0.0.2", 1111), ProxySettings("127.0.0.1", 1111));
}

TEST_F(ProxySettingsTest, EmptyAddressStringResultsInNullAddress) {
  EXPECT_EQ(ProxySettings("", 0).address(), nullptr);
  EXPECT_EQ(ProxySettings("", 0).asString(), "no_proxy_configured");
}

TEST_F(ProxySettingsTest, Hostname) {
  EXPECT_EQ(ProxySettings("foo.com", 0).address(), nullptr);
  EXPECT_EQ(ProxySettings("foo.com", 80).asString(), "foo.com:80");
}

} // namespace Network
} // namespace Envoy
#include <net/if.h>

#include "test/extensions/common/dynamic_forward_proxy/mocks.h"
#include "test/mocks/upstream/cluster_manager.h"

#include "gtest/gtest.h"
#include "library/common/network/connectivity_manager.h"

using testing::_;
using testing::Ref;
using testing::Return;

namespace Envoy {
namespace Network {

class ConnectivityManagerTest : public testing::Test {
public:
  ConnectivityManagerTest()
      : dns_cache_manager_(
            new NiceMock<Extensions::Common::DynamicForwardProxy::MockDnsCacheManager>()),
        dns_cache_(dns_cache_manager_->dns_cache_),
        connectivity_manager_(std::make_shared<ConnectivityManagerImpl>(cm_, dns_cache_manager_)) {
    ON_CALL(*dns_cache_manager_, lookUpCacheByName(_)).WillByDefault(Return(dns_cache_));
    // Toggle network to reset network state.
    ConnectivityManagerImpl::setPreferredNetwork(ENVOY_NET_GENERIC);
    ConnectivityManagerImpl::setPreferredNetwork(ENVOY_NET_WLAN);
  }

  std::shared_ptr<NiceMock<Extensions::Common::DynamicForwardProxy::MockDnsCacheManager>>
      dns_cache_manager_;
  std::shared_ptr<Extensions::Common::DynamicForwardProxy::MockDnsCache> dns_cache_;
  NiceMock<Upstream::MockClusterManager> cm_{};
  ConnectivityManagerSharedPtr connectivity_manager_;
};

TEST_F(ConnectivityManagerTest, SetPreferredNetworkWithNewNetworkChangesConfigurationKey) {
  envoy_netconf_t original_key = connectivity_manager_->getConfigurationKey();
  envoy_netconf_t new_key = ConnectivityManagerImpl::setPreferredNetwork(ENVOY_NET_WWAN);
  EXPECT_NE(original_key, new_key);
  EXPECT_EQ(new_key, connectivity_manager_->getConfigurationKey());
}

TEST_F(ConnectivityManagerTest,
       DISABLED_SetPreferredNetworkWithUnchangedNetworkReturnsStaleConfigurationKey) {
  envoy_netconf_t original_key = connectivity_manager_->getConfigurationKey();
  envoy_netconf_t stale_key = ConnectivityManagerImpl::setPreferredNetwork(ENVOY_NET_WLAN);
  EXPECT_NE(original_key, stale_key);
  EXPECT_EQ(original_key, connectivity_manager_->getConfigurationKey());
}

TEST_F(ConnectivityManagerTest, RefreshDnsForCurrentConfigurationTriggersDnsRefresh) {
  EXPECT_CALL(*dns_cache_, forceRefreshHosts());
  envoy_netconf_t configuration_key = connectivity_manager_->getConfigurationKey();
  connectivity_manager_->refreshDns(configuration_key, false);
}

TEST_F(ConnectivityManagerTest, RefreshDnsForStaleConfigurationDoesntTriggerDnsRefresh) {
  EXPECT_CALL(*dns_cache_, forceRefreshHosts()).Times(0);
  envoy_netconf_t configuration_key = connectivity_manager_->getConfigurationKey();
  connectivity_manager_->refreshDns(configuration_key - 1, false);
}

TEST_F(ConnectivityManagerTest, WhenDrainPostDnsRefreshEnabledDrainsPostDnsRefresh) {
  EXPECT_CALL(*dns_cache_, addUpdateCallbacks_(Ref(*connectivity_manager_)));
  connectivity_manager_->setDrainPostDnsRefreshEnabled(true);

  auto host_info = std::make_shared<Extensions::Common::DynamicForwardProxy::MockDnsHostInfo>();
  EXPECT_CALL(*dns_cache_, iterateHostMap(_))
      .WillOnce(
          Invoke([&](Extensions::Common::DynamicForwardProxy::DnsCache::IterateHostMapCb callback) {
            callback("cached.example.com", host_info);
            callback("cached2.example.com", host_info);
            callback("cached3.example.com", host_info);
          }));

  EXPECT_CALL(*dns_cache_, forceRefreshHosts());
  envoy_netconf_t configuration_key = connectivity_manager_->getConfigurationKey();
  connectivity_manager_->refreshDns(configuration_key, true);

  EXPECT_CALL(cm_, drainConnections(_));
  connectivity_manager_->onDnsResolutionComplete(
      "cached.example.com",
      std::make_shared<Extensions::Common::DynamicForwardProxy::MockDnsHostInfo>(),
      Network::DnsResolver::ResolutionStatus::Success);
  connectivity_manager_->onDnsResolutionComplete(
      "not-cached.example.com",
      std::make_shared<Extensions::Common::DynamicForwardProxy::MockDnsHostInfo>(),
      Network::DnsResolver::ResolutionStatus::Success);
  connectivity_manager_->onDnsResolutionComplete(
      "not-cached2.example.com",
      std::make_shared<Extensions::Common::DynamicForwardProxy::MockDnsHostInfo>(),
      Network::DnsResolver::ResolutionStatus::Success);
}

TEST_F(ConnectivityManagerTest, WhenDrainPostDnsNotEnabledDoesntDrainPostDnsRefresh) {
  connectivity_manager_->setDrainPostDnsRefreshEnabled(false);

  EXPECT_CALL(*dns_cache_, forceRefreshHosts());
  envoy_netconf_t configuration_key = connectivity_manager_->getConfigurationKey();
  connectivity_manager_->refreshDns(configuration_key, true);

  EXPECT_CALL(cm_, drainConnections(_)).Times(0);
  connectivity_manager_->onDnsResolutionComplete(
      "example.com", std::make_shared<Extensions::Common::DynamicForwardProxy::MockDnsHostInfo>(),
      Network::DnsResolver::ResolutionStatus::Success);
}

TEST_F(ConnectivityManagerTest,
       ReportNetworkUsageDoesntAlterNetworkConfigurationWhenBoundInterfacesAreDisabled) {
  envoy_netconf_t configuration_key = connectivity_manager_->getConfigurationKey();
  connectivity_manager_->setInterfaceBindingEnabled(false);
  EXPECT_EQ(DefaultPreferredNetworkMode, connectivity_manager_->getSocketMode());

  connectivity_manager_->reportNetworkUsage(configuration_key, true /* network_fault */);
  connectivity_manager_->reportNetworkUsage(configuration_key, true /* network_fault */);
  connectivity_manager_->reportNetworkUsage(configuration_key, true /* network_fault */);

  EXPECT_EQ(configuration_key, connectivity_manager_->getConfigurationKey());
  EXPECT_EQ(DefaultPreferredNetworkMode, connectivity_manager_->getSocketMode());
}

TEST_F(ConnectivityManagerTest,
       ReportNetworkUsageTriggersOverrideAfterFirstFaultAfterNetworkUpdate) {
  envoy_netconf_t configuration_key = connectivity_manager_->getConfigurationKey();
  connectivity_manager_->setInterfaceBindingEnabled(true);
  EXPECT_EQ(DefaultPreferredNetworkMode, connectivity_manager_->getSocketMode());

  connectivity_manager_->reportNetworkUsage(configuration_key, true /* network_fault */);

  EXPECT_NE(configuration_key, connectivity_manager_->getConfigurationKey());
  EXPECT_EQ(AlternateBoundInterfaceMode, connectivity_manager_->getSocketMode());
}

TEST_F(ConnectivityManagerTest, ReportNetworkUsageDisablesOverrideAfterFirstFaultAfterOverride) {
  envoy_netconf_t configuration_key = connectivity_manager_->getConfigurationKey();
  connectivity_manager_->setInterfaceBindingEnabled(true);
  EXPECT_EQ(DefaultPreferredNetworkMode, connectivity_manager_->getSocketMode());

  connectivity_manager_->reportNetworkUsage(configuration_key, true /* network_fault */);

  EXPECT_NE(configuration_key, connectivity_manager_->getConfigurationKey());
  configuration_key = connectivity_manager_->getConfigurationKey();
  EXPECT_EQ(AlternateBoundInterfaceMode, connectivity_manager_->getSocketMode());

  connectivity_manager_->reportNetworkUsage(configuration_key, true /* network_fault */);

  EXPECT_NE(configuration_key, connectivity_manager_->getConfigurationKey());
  EXPECT_EQ(DefaultPreferredNetworkMode, connectivity_manager_->getSocketMode());
}

TEST_F(ConnectivityManagerTest, ReportNetworkUsageDisablesOverrideAfterThirdFaultAfterSuccess) {
  envoy_netconf_t configuration_key = connectivity_manager_->getConfigurationKey();
  connectivity_manager_->setInterfaceBindingEnabled(true);
  EXPECT_EQ(DefaultPreferredNetworkMode, connectivity_manager_->getSocketMode());

  connectivity_manager_->reportNetworkUsage(configuration_key, false /* network_fault */);
  connectivity_manager_->reportNetworkUsage(configuration_key, true /* network_fault */);

  EXPECT_EQ(configuration_key, connectivity_manager_->getConfigurationKey());
  EXPECT_EQ(DefaultPreferredNetworkMode, connectivity_manager_->getSocketMode());

  connectivity_manager_->reportNetworkUsage(configuration_key, true /* network_fault */);
  connectivity_manager_->reportNetworkUsage(configuration_key, true /* network_fault */);

  EXPECT_NE(configuration_key, connectivity_manager_->getConfigurationKey());
  EXPECT_EQ(AlternateBoundInterfaceMode, connectivity_manager_->getSocketMode());
}

TEST_F(ConnectivityManagerTest, ReportNetworkUsageDisregardsCallsWithStaleConfigurationKey) {
  envoy_netconf_t stale_key = connectivity_manager_->getConfigurationKey();
  envoy_netconf_t current_key = ConnectivityManagerImpl::setPreferredNetwork(ENVOY_NET_WWAN);
  EXPECT_NE(stale_key, current_key);

  connectivity_manager_->setInterfaceBindingEnabled(true);
  EXPECT_EQ(DefaultPreferredNetworkMode, connectivity_manager_->getSocketMode());

  connectivity_manager_->reportNetworkUsage(stale_key, true /* network_fault */);
  connectivity_manager_->reportNetworkUsage(stale_key, true /* network_fault */);
  connectivity_manager_->reportNetworkUsage(stale_key, true /* network_fault */);

  EXPECT_EQ(current_key, connectivity_manager_->getConfigurationKey());
  EXPECT_EQ(DefaultPreferredNetworkMode, connectivity_manager_->getSocketMode());

  connectivity_manager_->reportNetworkUsage(stale_key, false /* network_fault */);
  connectivity_manager_->reportNetworkUsage(current_key, true /* network_fault */);

  EXPECT_NE(current_key, connectivity_manager_->getConfigurationKey());
  EXPECT_EQ(AlternateBoundInterfaceMode, connectivity_manager_->getSocketMode());
}

TEST_F(ConnectivityManagerTest, EnumerateInterfacesFiltersByFlags) {
  // Select loopback.
  auto loopbacks = connectivity_manager_->enumerateInterfaces(AF_INET, IFF_LOOPBACK, 0);
  EXPECT_EQ(loopbacks.size(), 1);
  EXPECT_EQ(std::get<const std::string>(loopbacks[0]).rfind("lo", 0), 0);

  // Reject loopback.
  auto nonloopbacks = connectivity_manager_->enumerateInterfaces(AF_INET, 0, IFF_LOOPBACK);
  for (const auto& interface : nonloopbacks) {
    EXPECT_NE(std::get<const std::string>(interface).rfind("lo", 0), 0);
  }

  // Select AND reject loopback.
  auto empty = connectivity_manager_->enumerateInterfaces(AF_INET, IFF_LOOPBACK, IFF_LOOPBACK);
  EXPECT_EQ(empty.size(), 0);
}

TEST_F(ConnectivityManagerTest, OverridesNoProxySettingsWithNewProxySettings) {
  EXPECT_EQ(nullptr, connectivity_manager_->getProxySettings());

  const auto proxy_settings = ProxySettings::parseHostAndPort("127.0.0.1", 9999);
  connectivity_manager_->setProxySettings(proxy_settings);
  EXPECT_EQ("127.0.0.1:9999", connectivity_manager_->getProxySettings()->asString());
}

TEST_F(ConnectivityManagerTest, OverridesCurrentProxySettingsWithNoProxySettings) {
  const auto proxy_settings = ProxySettings::parseHostAndPort("127.0.0.1", 9999);
  connectivity_manager_->setProxySettings(proxy_settings);
  EXPECT_EQ("127.0.0.1:9999", connectivity_manager_->getProxySettings()->asString());

  connectivity_manager_->setProxySettings(nullptr);
  EXPECT_EQ(nullptr, connectivity_manager_->getProxySettings());
}

TEST_F(ConnectivityManagerTest, OverridesCurrentProxySettingsWithNewProxySettings) {
  const auto proxy_settings1 = ProxySettings::parseHostAndPort("127.0.0.1", 9999);
  connectivity_manager_->setProxySettings(proxy_settings1);
  EXPECT_EQ("127.0.0.1:9999", connectivity_manager_->getProxySettings()->asString());

  const auto proxy_settings2 = ProxySettings::parseHostAndPort("127.0.0.1", 8888);
  connectivity_manager_->setProxySettings(proxy_settings2);
  EXPECT_EQ(proxy_settings2, connectivity_manager_->getProxySettings());
}

TEST_F(ConnectivityManagerTest, IgnoresDuplicatedProxySettingsUpdates) {
  const auto proxy_settings1 = ProxySettings::parseHostAndPort("127.0.0.1", 9999);
  connectivity_manager_->setProxySettings(proxy_settings1);
  EXPECT_EQ("127.0.0.1:9999", connectivity_manager_->getProxySettings()->asString());

  const auto proxy_settings2 = ProxySettings::parseHostAndPort("127.0.0.1", 9999);
  connectivity_manager_->setProxySettings(proxy_settings2);
  EXPECT_EQ(proxy_settings1, connectivity_manager_->getProxySettings());
}

} // namespace Network
} // namespace Envoy
#include "gtest/gtest.h"
#include "library/common/network/synthetic_address_impl.h"

namespace Envoy {
namespace Network {
namespace Address {

TEST(SyntheticAddressImplTest, AllAddressesAreNotEqual) {
  SyntheticAddressImpl address1;
  SyntheticAddressImpl address2;
  ASSERT_NE(address1, address2);
}

TEST(SyntheticAddressImplTest, Names) {
  SyntheticAddressImpl address;
  ASSERT_EQ(address.asString(), "synthetic");
  ASSERT_EQ(address.asStringView(), "synthetic");
  ASSERT_EQ(address.logicalName(), "synthetic");
}

TEST(SyntheticAddressImplTest, Accessors) {
  SyntheticAddressImpl address;
  ASSERT_EQ(address.ip(), nullptr);
  ASSERT_EQ(address.pipe(), nullptr);
  ASSERT_EQ(address.envoyInternalAddress(), nullptr);
  ASSERT_EQ(address.sockAddr(), nullptr);
  ASSERT_EQ(address.sockAddrLen(), 0);
  ASSERT_TRUE(&address.socketInterface() == &SocketInterfaceSingleton::get());
}

TEST(SyntheticAddressImplTest, Type) {
  SyntheticAddressImpl address;
  ASSERT_EQ(address.type(), Type::Ip);
}

} // namespace Address
} // namespace Network
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_test", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_test(
    name = "connectivity_manager_test",
    srcs = ["connectivity_manager_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/common/network:connectivity_manager_lib",
        "@envoy//test/extensions/common/dynamic_forward_proxy:mocks",
        "@envoy//test/mocks/upstream:cluster_manager_mocks",
    ],
)

envoy_cc_test(
    name = "proxy_settings_test",
    srcs = ["proxy_settings_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/common/network:connectivity_manager_lib",
    ],
)

envoy_cc_test(
    name = "src_addr_socket_option_impl_test",
    srcs = ["src_addr_socket_option_impl_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/common/network:src_addr_socket_option_lib",
        "@envoy//test/mocks/network:network_mocks",
        "@envoy_api//envoy/config/core/v3:pkg_cc_proto",
    ],
)

envoy_cc_test(
    name = "synthetic_address_impl_test",
    srcs = ["synthetic_address_impl_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/common/network:synthetic_address_lib",
    ],
)
#include "envoy/config/core/v3/base.pb.h"
#include "envoy/network/address.h"

#include "source/common/network/utility.h"

#include "test/mocks/common.h"
#include "test/mocks/network/mocks.h"
#include "test/test_common/printers.h"

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "library/common/network/src_addr_socket_option_impl.h"

using testing::_;

namespace Envoy {
namespace Network {
namespace {

class SrcAddrSocketOptionImplTest : public testing::Test {
public:
  std::unique_ptr<SrcAddrSocketOptionImpl>
  makeOptionByAddress(const Network::Address::InstanceConstSharedPtr& address) {
    return std::make_unique<SrcAddrSocketOptionImpl>(address);
  }

protected:
  NiceMock<Network::MockConnectionSocket> socket_;
  std::vector<uint8_t> key_;
};

TEST_F(SrcAddrSocketOptionImplTest, TestSetOptionPreBindSetsAddress) {
  const auto address = Network::Utility::parseInternetAddress("127.0.0.2");
  auto option = makeOptionByAddress(address);
  EXPECT_TRUE(option->setOption(socket_, envoy::config::core::v3::SocketOption::STATE_PREBIND));
  EXPECT_EQ(*socket_.connection_info_provider_->localAddress(), *address);
}

TEST_F(SrcAddrSocketOptionImplTest, TestSetOptionPreBindSetsAddressSecond) {
  const auto address = Network::Utility::parseInternetAddress("1.2.3.4");
  auto option = makeOptionByAddress(address);
  EXPECT_TRUE(option->setOption(socket_, envoy::config::core::v3::SocketOption::STATE_PREBIND));
  EXPECT_EQ(*socket_.connection_info_provider_->localAddress(), *address);
}

TEST_F(SrcAddrSocketOptionImplTest, TestSetOptionNotPrebindDoesNotSetAddress) {
  const auto address = Network::Utility::parseInternetAddress("1.2.3.4");
  auto option = makeOptionByAddress(address);
  EXPECT_TRUE(option->setOption(socket_, envoy::config::core::v3::SocketOption::STATE_LISTENING));
  EXPECT_NE(*socket_.connection_info_provider_->localAddress(), *address);
}

TEST_F(SrcAddrSocketOptionImplTest, TestSetOptionSafeWithNullAddress) {
  const auto address = Network::Utility::parseInternetAddress("4.3.2.1");
  socket_.connection_info_provider_->setLocalAddress(address);
  auto option = std::make_unique<SrcAddrSocketOptionImpl>(nullptr);
  EXPECT_TRUE(option->setOption(socket_, envoy::config::core::v3::SocketOption::STATE_PREBIND));
  EXPECT_EQ(*socket_.connection_info_provider_->localAddress(), *address);
}

TEST_F(SrcAddrSocketOptionImplTest, TestIpv4HashKey) {
  const auto address = Network::Utility::parseInternetAddress("1.2.3.4");
  auto option = makeOptionByAddress(address);
  option->hashKey(key_);

  // The ip address broken into big-endian octets.
  std::vector<uint8_t> expected_key = {1, 2, 3, 4};
  EXPECT_EQ(key_, expected_key);
}

TEST_F(SrcAddrSocketOptionImplTest, TestIpv4HashKeyOther) {
  const auto address = Network::Utility::parseInternetAddress("255.254.253.0");
  auto option = makeOptionByAddress(address);
  option->hashKey(key_);

  // The ip address broken into big-endian octets.
  std::vector<uint8_t> expected_key = {255, 254, 253, 0};
  EXPECT_EQ(key_, expected_key);
}

TEST_F(SrcAddrSocketOptionImplTest, TestIpv6HashKey) {
  const auto address = Network::Utility::parseInternetAddress("102:304:506:708:90a:b0c:d0e:f00");
  auto option = makeOptionByAddress(address);
  option->hashKey(key_);

  std::vector<uint8_t> expected_key = {0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8,
                                       0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0};
  EXPECT_EQ(key_, expected_key);
}

TEST_F(SrcAddrSocketOptionImplTest, TestIpv6HashKeyOther) {
  const auto address = Network::Utility::parseInternetAddress("F02:304:519:708:90a:b0e:FFFF:0000");
  auto option = makeOptionByAddress(address);
  option->hashKey(key_);

  std::vector<uint8_t> expected_key = {0xF, 0x2, 0x3, 0x4, 0x5,  0x19, 0x7, 0x8,
                                       0x9, 0xa, 0xb, 0xe, 0xff, 0xff, 0x0, 0x0};
  EXPECT_EQ(key_, expected_key);
}

TEST_F(SrcAddrSocketOptionImplTest, TestOptionDetailsNotSupported) {
  const auto address = Network::Utility::parseInternetAddress("255.254.253.0");
  auto option = makeOptionByAddress(address);

  auto details =
      option->getOptionDetails(socket_, envoy::config::core::v3::SocketOption::STATE_PREBIND);

  EXPECT_FALSE(details.has_value());
}

} // namespace
} // namespace Network
} // namespace Envoy
#include "source/common/network/address_impl.h"

#include "test/extensions/common/dynamic_forward_proxy/mocks.h"
#include "test/mocks/event/mocks.h"
#include "test/mocks/http/mocks.h"
#include "test/mocks/server/factory_context.h"
#include "test/test_common/utility.h"

#include "gtest/gtest.h"
#include "library/common/api/external.h"
#include "library/common/data/utility.h"
#include "library/common/extensions/filters/http/network_configuration/filter.h"
#include "library/common/extensions/filters/http/network_configuration/filter.pb.h"
#include "library/common/network/proxy_settings.h"

using Envoy::Extensions::Common::DynamicForwardProxy::DnsCache;
using Envoy::Extensions::Common::DynamicForwardProxy::MockDnsCache;
using testing::_;
using testing::Eq;
using testing::Return;

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace NetworkConfiguration {
namespace {

class MockConnectivityManager : public Network::ConnectivityManager {
public:
  MOCK_METHOD(std::vector<Network::InterfacePair>, enumerateV4Interfaces, ());
  MOCK_METHOD(std::vector<Network::InterfacePair>, enumerateV6Interfaces, ());
  MOCK_METHOD(std::vector<Network::InterfacePair>, enumerateInterfaces,
              (unsigned short family, unsigned int select_flags, unsigned int reject_flags));
  MOCK_METHOD(envoy_network_t, getPreferredNetwork, ());
  MOCK_METHOD(envoy_socket_mode_t, getSocketMode, ());
  MOCK_METHOD(envoy_netconf_t, getConfigurationKey, ());
  MOCK_METHOD(Envoy::Network::ProxySettingsConstSharedPtr, getProxySettings, ());
  MOCK_METHOD(void, reportNetworkUsage, (envoy_netconf_t configuration_key, bool network_fault));
  MOCK_METHOD(void, setProxySettings, (Envoy::Network::ProxySettingsConstSharedPtr proxy_settings));
  MOCK_METHOD(void, setDrainPostDnsRefreshEnabled, (bool enabled));
  MOCK_METHOD(void, setInterfaceBindingEnabled, (bool enabled));
  MOCK_METHOD(void, refreshDns, (envoy_netconf_t configuration_key, bool drain_connections));
  MOCK_METHOD(void, resetConnectivityState, ());
  MOCK_METHOD(Network::Socket::OptionsSharedPtr, getUpstreamSocketOptions,
              (envoy_network_t network, envoy_socket_mode_t socket_mode));
  MOCK_METHOD(envoy_netconf_t, addUpstreamSocketOptions,
              (Network::Socket::OptionsSharedPtr options));

  MOCK_METHOD(void, onDnsHostAddOrUpdate,
              (const std::string& /*host*/,
               const Extensions::Common::DynamicForwardProxy::DnsHostInfoSharedPtr&));
  MOCK_METHOD(void, onDnsHostRemove, (const std::string& /*host*/));
  MOCK_METHOD(void, onDnsResolutionComplete,
              (const std::string& /*host*/,
               const Extensions::Common::DynamicForwardProxy::DnsHostInfoSharedPtr&,
               Network::DnsResolver::ResolutionStatus));
  MOCK_METHOD(Extensions::Common::DynamicForwardProxy::DnsCacheSharedPtr, dnsCache, ());
};

class NetworkConfigurationFilterTest : public testing::Test {
public:
  NetworkConfigurationFilterTest()
      : connectivity_manager_(new NiceMock<MockConnectivityManager>),
        proxy_settings_(new Network::ProxySettings("127.0.0.1", 82)),
        filter_(connectivity_manager_, false, false) {
    filter_.setDecoderFilterCallbacks(decoder_callbacks_);
    ON_CALL(decoder_callbacks_.stream_info_, getRequestHeaders())
        .WillByDefault(Return(&default_request_headers_));
  }

  void createCache() {
    dns_cache_ =
        std::make_shared<NiceMock<Envoy::Extensions::Common::DynamicForwardProxy::MockDnsCache>>();
    ON_CALL(*connectivity_manager_, dnsCache()).WillByDefault(Return(dns_cache_));
    host_info_ = std::make_shared<
        NiceMock<Envoy::Extensions::Common::DynamicForwardProxy::MockDnsHostInfo>>();
    address_ = std::make_shared<Network::Address::Ipv4Instance>("224.0.0.1", 0);
    ON_CALL(*host_info_, address()).WillByDefault(Return(address_));
  }

  Network::Address::InstanceConstSharedPtr address_;
  std::shared_ptr<Envoy::Extensions::Common::DynamicForwardProxy::MockDnsCache> dns_cache_;
  std::shared_ptr<Envoy::Extensions::Common::DynamicForwardProxy::MockDnsHostInfo> host_info_;
  std::shared_ptr<MockConnectivityManager> connectivity_manager_;
  NiceMock<Http::MockStreamDecoderFilterCallbacks> decoder_callbacks_;
  Envoy::Network::ProxySettingsConstSharedPtr proxy_settings_;
  NetworkConfigurationFilter filter_;
  Http::TestRequestHeaderMapImpl default_request_headers_{{":method", "GET"},
                                                          {":path", "/test/long/url"},
                                                          {":scheme", "http"},
                                                          {":authority", "sni.lyft.com"}};
};

TEST_F(NetworkConfigurationFilterTest, NoProxyConfig) {
  // With no proxy config, no proxy info will be added to the stream info.
  EXPECT_CALL(decoder_callbacks_.stream_info_, filterState()).Times(0);
  EXPECT_EQ(Http::FilterHeadersStatus::Continue,
            filter_.decodeHeaders(default_request_headers_, false));
}

TEST_F(NetworkConfigurationFilterTest, IPProxyConfig) {
  // With an IP based config, expect the proxy information to get added to stream info.
  EXPECT_CALL(*connectivity_manager_, getProxySettings()).WillOnce(Return(proxy_settings_));
  EXPECT_CALL(decoder_callbacks_.stream_info_, filterState());
  EXPECT_EQ(Http::FilterHeadersStatus::Continue,
            filter_.decodeHeaders(default_request_headers_, false));
}

TEST_F(NetworkConfigurationFilterTest, IPProxyConfigNoAuthority) {
  Http::TestRequestHeaderMapImpl bad_request_headers{{":method", "GET"}};

  // With no authority header, don't even check for proxy settings.
  EXPECT_CALL(*connectivity_manager_, getProxySettings()).Times(0);
  EXPECT_CALL(decoder_callbacks_.stream_info_, filterState()).Times(0);
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_.decodeHeaders(bad_request_headers, false));
}

TEST_F(NetworkConfigurationFilterTest, HostnameProxyConfigNoCache) {
  proxy_settings_ = std::make_shared<Network::ProxySettings>("localhost", 82),

  // With an hostname based config, and no dns cache, expect a local reply.
      EXPECT_CALL(*connectivity_manager_, getProxySettings()).WillOnce(Return(proxy_settings_));
  EXPECT_CALL(decoder_callbacks_.stream_info_, filterState()).Times(0);
  EXPECT_CALL(decoder_callbacks_, sendLocalReply(_, _, _, _, _));
  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_.decodeHeaders(default_request_headers_, false));
}

TEST_F(NetworkConfigurationFilterTest, HostnameProxyConfig) {
  proxy_settings_ = std::make_shared<Network::ProxySettings>("localhost", 82);
  createCache();

  // With an hostname based config, and a cached address, expect the proxy info to be set.
  EXPECT_CALL(*connectivity_manager_, getProxySettings()).WillOnce(Return(proxy_settings_));
  EXPECT_CALL(decoder_callbacks_.stream_info_, filterState());
  EXPECT_CALL(*dns_cache_, loadDnsCacheEntry_(Eq("localhost"), 82, false, _))
      .WillOnce(
          Invoke([&](absl::string_view, uint16_t, bool, DnsCache::LoadDnsCacheEntryCallbacks&) {
            return MockDnsCache::MockLoadDnsCacheEntryResult{
                DnsCache::LoadDnsCacheEntryStatus::InCache, nullptr, host_info_};
          }));
  EXPECT_EQ(Http::FilterHeadersStatus::Continue,
            filter_.decodeHeaders(default_request_headers_, false));
}

TEST_F(NetworkConfigurationFilterTest, HostnameDnsLookupFail) {
  proxy_settings_ = std::make_shared<Network::ProxySettings>("localhost", 82);
  createCache();

  // With a DNS lookup failure, send a local reply.
  EXPECT_CALL(*connectivity_manager_, getProxySettings()).WillOnce(Return(proxy_settings_));
  EXPECT_CALL(decoder_callbacks_.stream_info_, filterState()).Times(0);
  EXPECT_CALL(*dns_cache_, loadDnsCacheEntry_(Eq("localhost"), 82, false, _))
      .WillOnce(Return(MockDnsCache::MockLoadDnsCacheEntryResult{
          DnsCache::LoadDnsCacheEntryStatus::Overflow, nullptr, absl::nullopt}));
  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_.decodeHeaders(default_request_headers_, false));
}

TEST_F(NetworkConfigurationFilterTest, AsyncDnsLookupSuccess) {
  proxy_settings_ = std::make_shared<Network::ProxySettings>("localhost", 82);
  createCache();

  // With an hostname based config, and a cached address, expect iteration to stop.
  EXPECT_CALL(*connectivity_manager_, getProxySettings()).WillOnce(Return(proxy_settings_));
  EXPECT_CALL(decoder_callbacks_.stream_info_, filterState()).Times(0);
  Extensions::Common::DynamicForwardProxy::MockLoadDnsCacheEntryHandle* handle =
      new NiceMock<Extensions::Common::DynamicForwardProxy::MockLoadDnsCacheEntryHandle>();
  EXPECT_CALL(*handle, onDestroy());
  EXPECT_CALL(*dns_cache_, loadDnsCacheEntry_(Eq("localhost"), 82, false, _))
      .WillOnce(
          Invoke([&](absl::string_view, uint16_t, bool, DnsCache::LoadDnsCacheEntryCallbacks&) {
            return MockDnsCache::MockLoadDnsCacheEntryResult{
                DnsCache::LoadDnsCacheEntryStatus::Loading, handle, absl::nullopt};
          }));
  EXPECT_EQ(Http::FilterHeadersStatus::StopAllIterationAndWatermark,
            filter_.decodeHeaders(default_request_headers_, false));

  // Now complete the resolution. The info should be added to the filter state,
  // and the filter chain should schedule the callback to continue.
  new NiceMock<Event::MockSchedulableCallback>(&decoder_callbacks_.dispatcher_);
  EXPECT_CALL(decoder_callbacks_.stream_info_, filterState());
  EXPECT_CALL(decoder_callbacks_, sendLocalReply(_, _, _, _, _)).Times(0);
  filter_.onLoadDnsCacheComplete(host_info_);
}

} // namespace
} // namespace NetworkConfiguration
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load(
    "@envoy//test/extensions:extensions_build_system.bzl",
    "envoy_extension_cc_test",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_extension_cc_test(
    name = "network_configuration_filter_test",
    srcs = ["network_configuration_filter_test.cc"],
    extension_names = ["envoy.filters.http.network_configuration"],
    repository = "@envoy",
    deps = [
        "//library/common/api:external_api_lib",
        "//library/common/data:utility_lib",
        "//library/common/extensions/filters/http/network_configuration:config",
        "//library/common/extensions/filters/http/network_configuration:filter_cc_proto",
        "@envoy//test/extensions/common/dynamic_forward_proxy:mocks",
        "@envoy//test/mocks/event:event_mocks",
        "@envoy//test/mocks/http:http_mocks",
        "@envoy//test/mocks/server:factory_context_mocks",
        "@envoy//test/test_common:utility_lib",
    ],
)
#include "test/mocks/event/mocks.h"
#include "test/mocks/http/mocks.h"
#include "test/mocks/server/factory_context.h"
#include "test/test_common/utility.h"

#include "gtest/gtest.h"
#include "library/common/api/external.h"
#include "library/common/data/utility.h"
#include "library/common/extensions/filters/http/platform_bridge/filter.h"
#include "library/common/extensions/filters/http/platform_bridge/filter.pb.h"

using testing::ByMove;
using testing::Return;
using testing::ReturnRef;
using testing::SaveArg;

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace PlatformBridge {
namespace {

envoy_headers make_envoy_headers(std::vector<std::pair<std::string, std::string>> pairs) {
  envoy_map_entry* headers =
      static_cast<envoy_map_entry*>(safe_malloc(sizeof(envoy_map_entry) * pairs.size()));
  envoy_headers new_headers;
  new_headers.length = 0;
  new_headers.entries = headers;

  for (const auto& pair : pairs) {
    envoy_data key = Data::Utility::copyToBridgeData(pair.first);
    envoy_data value = Data::Utility::copyToBridgeData(pair.second);

    new_headers.entries[new_headers.length] = {key, value};
    new_headers.length++;
  }

  return new_headers;
}

class PlatformBridgeFilterTest : public testing::Test {
public:
  void setUpFilter(std::string name, envoy_http_filter* platform_filter) {
    envoymobile::extensions::filters::http::platform_bridge::PlatformBridge config;
    config.set_platform_filter_name(name);
    Api::External::registerApi(config.platform_filter_name(), platform_filter);

    config_ = std::make_shared<PlatformBridgeFilterConfig>(context_, config);
    filter_ = std::make_shared<PlatformBridgeFilter>(config_, dispatcher_);
    filter_->setDecoderFilterCallbacks(decoder_callbacks_);
    filter_->setEncoderFilterCallbacks(encoder_callbacks_);
  }

  struct CheckFilterState {
    std::string iteration_state, on_headers_called, headers_forwarded, on_data_called,
        data_forwarded, on_trailers_called, trailers_forwarded, on_resume_called, pending_headers,
        buffer, pending_trailers, stream_complete;
  };

  void checkFilterState(std::string name, std::string error_response, CheckFilterState request,
                        CheckFilterState response) {
    std::stringstream ss;
    filter_->dumpState(ss, 0);

    std::string expected_state_template =
        R"EOF(PlatformBridgeFilter, filter_name_: {}, error_response_: {}
  Request Filter, state_.iteration_state_: {}, state_.on_headers_called_: {}, state_.headers_forwarded_: {}, state_.on_data_called_: {}, state_.data_forwarded_: {}, state_.on_trailers_called_: {}, state_.trailers_forwarded_: {}, state_.on_resume_called_: {}, pending_headers_: {}, buffer: {}, pending_trailers_: {}, state_.stream_complete_: {}
  Response Filter, state_.iteration_state_: {}, state_.on_headers_called_: {}, state_.headers_forwarded_: {}, state_.on_data_called_: {}, state_.data_forwarded_: {}, state_.on_trailers_called_: {}, state_.trailers_forwarded_: {}, state_.on_resume_called_: {}, pending_headers_: {}, buffer: {}, pending_trailers_: {}, state_.stream_complete_: {}
)EOF";

    std::string expected_state = fmt::format(
        expected_state_template, name, error_response, request.iteration_state,
        request.on_headers_called, request.headers_forwarded, request.on_data_called,
        request.data_forwarded, request.on_trailers_called, request.trailers_forwarded,
        request.on_resume_called, request.pending_headers, request.buffer, request.pending_trailers,
        request.stream_complete, response.iteration_state, response.on_headers_called,
        response.headers_forwarded, response.on_data_called, response.data_forwarded,
        response.on_trailers_called, response.trailers_forwarded, response.on_resume_called,
        response.pending_headers, response.buffer, response.pending_trailers,
        response.stream_complete);

    EXPECT_EQ(ss.str(), expected_state);
  }

  typedef struct {
    unsigned int init_filter_calls;
    unsigned int on_request_headers_calls;
    unsigned int on_request_data_calls;
    unsigned int on_request_trailers_calls;
    unsigned int on_response_headers_calls;
    unsigned int on_response_data_calls;
    unsigned int on_response_trailers_calls;
    unsigned int set_request_callbacks_calls;
    unsigned int on_resume_request_calls;
    unsigned int set_response_callbacks_calls;
    unsigned int on_resume_response_calls;
    unsigned int on_cancel_calls;
    unsigned int on_error_calls;
    unsigned int release_filter_calls;
  } filter_invocations;

  NiceMock<Server::Configuration::MockFactoryContext> context_;
  PlatformBridgeFilterConfigSharedPtr config_;
  PlatformBridgeFilterSharedPtr filter_;
  NiceMock<Event::MockDispatcher> dispatcher_;
  NiceMock<Http::MockStreamDecoderFilterCallbacks> decoder_callbacks_;
  NiceMock<Http::MockStreamEncoderFilterCallbacks> encoder_callbacks_;
};

TEST_F(PlatformBridgeFilterTest, NullImplementation) {
  envoy_http_filter* null_filter =
      static_cast<envoy_http_filter*>(safe_calloc(1, sizeof(envoy_http_filter)));
  setUpFilter("NullImplementation", null_filter);

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, false));

  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(request_data, false));

  Http::TestRequestTrailerMapImpl request_trailers{{"x-test-trailer", "test trailer"}};
  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->decodeTrailers(request_trailers));

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(response_headers, false));

  Buffer::OwnedImpl response_data = Buffer::OwnedImpl("response body");
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(response_data, false));

  Http::TestResponseTrailerMapImpl response_trailers{{"x-test-trailer", "test trailer"}};
  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->encodeTrailers(response_trailers));

  checkFilterState("NullImplementation", "0",
                   {"ongoing", "0", "1", "0", "1", "0", "1", "0", "null", "null", "null", "1"},
                   {"ongoing", "0", "1", "0", "1", "0", "1", "0", "null", "null", "null", "1"});

  filter_->onDestroy();

  free(null_filter);
}

TEST_F(PlatformBridgeFilterTest, PartialNullImplementation) {
  envoy_http_filter* noop_filter =
      static_cast<envoy_http_filter*>(safe_calloc(1, sizeof(envoy_http_filter)));
  filter_invocations invocations{};
  noop_filter->static_context = &invocations;
  noop_filter->init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  noop_filter->release_filter = [](const void* context) -> void {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    invocations->release_filter_calls++;
  };
  setUpFilter("PartialNullImplementation", noop_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, false));

  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(request_data, false));

  Http::TestRequestTrailerMapImpl request_trailers{{"x-test-trailer", "test trailer"}};
  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->decodeTrailers(request_trailers));

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(response_headers, false));

  Buffer::OwnedImpl response_data = Buffer::OwnedImpl("response body");
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(response_data, false));

  Http::TestResponseTrailerMapImpl response_trailers{{"x-test-trailer", "test trailer"}};
  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->encodeTrailers(response_trailers));

  filter_->onDestroy();
  EXPECT_EQ(invocations.release_filter_calls, 1);

  free(noop_filter);
}

TEST_F(PlatformBridgeFilterTest, BasicContinueOnRequestHeaders) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_headers = [](envoy_headers c_headers, bool end_stream,
                                          envoy_stream_intel,
                                          const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_TRUE(end_stream);
    invocations->on_request_headers_calls++;
    return {kEnvoyFilterHeadersStatusContinue, c_headers};
  };

  setUpFilter("BasicContinueOnRequestHeaders", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, true));
  EXPECT_EQ(invocations.on_request_headers_calls, 1);
}

TEST_F(PlatformBridgeFilterTest, StopOnRequestHeadersThenResumeOnData) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_headers = [](envoy_headers c_headers, bool end_stream,
                                          envoy_stream_intel,
                                          const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_request_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_request_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                       const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(Data::Utility::copyToString(c_data), "request body");
    EXPECT_TRUE(end_stream);
    invocations->on_request_data_calls++;
    envoy_headers* modified_headers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_headers = make_envoy_headers({{":authority", "test.code"}, {"content-length", "12"}});
    return {kEnvoyFilterDataStatusResumeIteration, c_data, modified_headers};
  };

  setUpFilter("StopOnRequestHeadersThenResumeOnData", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, false));
  EXPECT_EQ(invocations.on_request_headers_calls, 1);

  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");

  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(request_data, true));
  EXPECT_EQ(invocations.on_request_data_calls, 1);

  EXPECT_FALSE(request_headers.get(Http::LowerCaseString("content-length")).empty());
  EXPECT_EQ(
      request_headers.get(Http::LowerCaseString("content-length"))[0]->value().getStringView(),
      "12");
}

TEST_F(PlatformBridgeFilterTest, StopOnRequestHeadersThenResumeOnResumeDecoding) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_headers = [](envoy_headers c_headers, bool end_stream,
                                          envoy_stream_intel,
                                          const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_request_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_resume_request =
      [](envoy_headers* pending_headers, envoy_data* pending_data, envoy_headers* pending_trailers,
         bool end_stream, envoy_stream_intel, const void* context) -> envoy_filter_resume_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(pending_headers->length, 1);
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].value), "test.code");
    EXPECT_EQ(pending_data, nullptr);
    EXPECT_EQ(pending_trailers, nullptr);
    EXPECT_FALSE(end_stream);
    invocations->on_resume_request_calls++;
    envoy_headers* modified_headers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_headers =
        make_envoy_headers({{":authority", "test.code"}, {"x-async-resumed", "Very Yes"}});
    release_envoy_headers(*pending_headers);
    return {kEnvoyFilterResumeStatusResumeIteration, modified_headers, nullptr, nullptr};
  };

  setUpFilter("StopOnRequestHeadersThenResumeOnResumeDecoding", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, false));
  EXPECT_EQ(invocations.on_request_headers_calls, 1);

  Event::PostCb resume_post_cb;
  EXPECT_CALL(dispatcher_, post(_)).WillOnce([&resume_post_cb](Event::PostCb cb) {
    resume_post_cb = std::move(cb);
  });
  EXPECT_CALL(decoder_callbacks_, continueDecoding());
  filter_->resumeDecoding();
  resume_post_cb();
  EXPECT_EQ(invocations.on_resume_request_calls, 1);

  EXPECT_FALSE(request_headers.get(Http::LowerCaseString("x-async-resumed")).empty());
  EXPECT_EQ(
      request_headers.get(Http::LowerCaseString("x-async-resumed"))[0]->value().getStringView(),
      "Very Yes");
}

TEST_F(PlatformBridgeFilterTest, StopOnRequestHeadersThenResumeOnResumeDecodingWithData) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_headers = [](envoy_headers c_headers, bool end_stream,
                                          envoy_stream_intel,
                                          const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_request_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_resume_request =
      [](envoy_headers* pending_headers, envoy_data* pending_data, envoy_headers* pending_trailers,
         bool end_stream, envoy_stream_intel, const void* context) -> envoy_filter_resume_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(pending_headers->length, 1);
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].value), "test.code");
    EXPECT_EQ(pending_data, nullptr);
    EXPECT_EQ(pending_trailers, nullptr);
    EXPECT_FALSE(end_stream);
    invocations->on_resume_request_calls++;
    envoy_headers* modified_headers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_headers =
        make_envoy_headers({{":authority", "test.code"}, {"x-async-resumed", "Very Yes"}});
    release_envoy_headers(*pending_headers);

    Buffer::OwnedImpl final_buffer = Buffer::OwnedImpl("C");
    envoy_data* modified_data = static_cast<envoy_data*>(safe_malloc(sizeof(envoy_data)));
    *modified_data = Data::Utility::toBridgeData(final_buffer);
    return {kEnvoyFilterResumeStatusResumeIteration, modified_headers, modified_data, nullptr};
  };

  setUpFilter("StopOnRequestHeadersThenResumeOnResumeDecoding", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, false));
  EXPECT_EQ(invocations.on_request_headers_calls, 1);

  Event::PostCb resume_post_cb;
  EXPECT_CALL(dispatcher_, post(_)).WillOnce([&resume_post_cb](Event::PostCb cb) {
    resume_post_cb = std::move(cb);
  });
  EXPECT_CALL(decoder_callbacks_, continueDecoding());
  filter_->resumeDecoding();
  resume_post_cb();
  EXPECT_EQ(invocations.on_resume_request_calls, 1);

  EXPECT_FALSE(request_headers.get(Http::LowerCaseString("x-async-resumed")).empty());
  EXPECT_EQ(
      request_headers.get(Http::LowerCaseString("x-async-resumed"))[0]->value().getStringView(),
      "Very Yes");
}

TEST_F(PlatformBridgeFilterTest, StopOnRequestHeadersThenResumeOnResumeDecodingWithTrailers) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_headers = [](envoy_headers c_headers, bool end_stream,
                                          envoy_stream_intel,
                                          const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_request_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_resume_request =
      [](envoy_headers* pending_headers, envoy_data* pending_data, envoy_headers* pending_trailers,
         bool end_stream, envoy_stream_intel, const void* context) -> envoy_filter_resume_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(pending_headers->length, 1);
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].value), "test.code");
    EXPECT_EQ(pending_data, nullptr);
    EXPECT_EQ(pending_trailers, nullptr);
    EXPECT_FALSE(end_stream);
    invocations->on_resume_request_calls++;
    envoy_headers* modified_headers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_headers =
        make_envoy_headers({{":authority", "test.code"}, {"x-async-resumed", "Very Yes"}});
    release_envoy_headers(*pending_headers);

    envoy_headers* modified_trailers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_trailers = make_envoy_headers({{"trailer", "test.trailer.async"}});

    return {kEnvoyFilterResumeStatusResumeIteration, modified_headers, nullptr, modified_trailers};
  };

  setUpFilter("StopOnRequestHeadersThenResumeOnResumeDecoding", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, false));
  EXPECT_EQ(invocations.on_request_headers_calls, 1);

  Event::PostCb resume_post_cb;
  EXPECT_CALL(dispatcher_, post(_)).WillOnce([&resume_post_cb](Event::PostCb cb) {
    resume_post_cb = std::move(cb);
  });
  Http::TestRequestTrailerMapImpl trailers;
  EXPECT_CALL(decoder_callbacks_, addDecodedTrailers()).WillOnce(ReturnRef(trailers));
  EXPECT_CALL(decoder_callbacks_, continueDecoding());
  filter_->resumeDecoding();
  resume_post_cb();
  EXPECT_EQ(invocations.on_resume_request_calls, 1);

  EXPECT_FALSE(request_headers.get(Http::LowerCaseString("x-async-resumed")).empty());
  EXPECT_EQ(
      request_headers.get(Http::LowerCaseString("x-async-resumed"))[0]->value().getStringView(),
      "Very Yes");

  EXPECT_FALSE(trailers.get(Http::LowerCaseString("trailer")).empty());
  EXPECT_EQ(trailers.get(Http::LowerCaseString("trailer"))[0]->value().getStringView(),
            "test.trailer.async");
}

TEST_F(PlatformBridgeFilterTest, AsyncResumeDecodingIsNoopAfterPreviousResume) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_headers = [](envoy_headers c_headers, bool end_stream,
                                          envoy_stream_intel,
                                          const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_request_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_request_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                       const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(Data::Utility::copyToString(c_data), "request body");
    EXPECT_TRUE(end_stream);
    invocations->on_request_data_calls++;
    envoy_headers* modified_headers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_headers = make_envoy_headers({{":authority", "test.code"}, {"content-length", "12"}});
    return {kEnvoyFilterDataStatusResumeIteration, c_data, modified_headers};
  };
  platform_filter.on_resume_request = [](envoy_headers*, envoy_data*, envoy_headers*, bool,
                                         envoy_stream_intel,
                                         const void*) -> envoy_filter_resume_status {
    ADD_FAILURE() << "on_resume_request should not get called when iteration is already ongoing.";
    return {kEnvoyFilterResumeStatusResumeIteration, nullptr, nullptr, nullptr};
  };

  setUpFilter("AsyncResumeDecodingIsNoopAfterPreviousResume", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, false));
  EXPECT_EQ(invocations.on_request_headers_calls, 1);

  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");

  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(request_data, true));
  EXPECT_EQ(invocations.on_request_data_calls, 1);

  EXPECT_FALSE(request_headers.get(Http::LowerCaseString("content-length")).empty());
  EXPECT_EQ(
      request_headers.get(Http::LowerCaseString("content-length"))[0]->value().getStringView(),
      "12");

  Event::PostCb resume_post_cb;
  EXPECT_CALL(dispatcher_, post(_)).WillOnce([&resume_post_cb](Event::PostCb cb) {
    resume_post_cb = std::move(cb);
  });
  EXPECT_CALL(decoder_callbacks_, continueDecoding()).Times(0);
  filter_->resumeDecoding();
  resume_post_cb();
  EXPECT_EQ(invocations.on_resume_request_calls, 0);
}

TEST_F(PlatformBridgeFilterTest, BasicContinueOnRequestData) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                       const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(Data::Utility::copyToString(c_data), "request body");
    EXPECT_TRUE(end_stream);
    invocations->on_request_data_calls++;
    return {kEnvoyFilterDataStatusContinue, c_data, nullptr};
  };

  setUpFilter("BasicContinueOnRequestData", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");

  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(request_data, true));
  EXPECT_EQ(invocations.on_request_data_calls, 1);
}

TEST_F(PlatformBridgeFilterTest, StopAndBufferOnRequestData) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                       const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    std::string expected_data[3] = {"A", "AB", "ABC"};
    EXPECT_EQ(Data::Utility::copyToString(c_data),
              expected_data[invocations->on_request_data_calls++]);
    EXPECT_FALSE(end_stream);
    release_envoy_data(c_data);
    return {kEnvoyFilterDataStatusStopIterationAndBuffer, envoy_nodata, nullptr};
  };

  Buffer::OwnedImpl decoding_buffer;
  EXPECT_CALL(decoder_callbacks_, decodingBuffer())
      .Times(2)
      .WillRepeatedly(Return(&decoding_buffer));
  EXPECT_CALL(decoder_callbacks_, modifyDecodingBuffer(_))
      .Times(2)
      .WillRepeatedly(Invoke([&](std::function<void(Buffer::Instance&)> callback) -> void {
        callback(decoding_buffer);
      }));

  setUpFilter("StopAndBufferOnRequestData", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Buffer::OwnedImpl first_chunk = Buffer::OwnedImpl("A");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationAndBuffer,
            filter_->decodeData(first_chunk, false));
  // Since the return code can't be handled in a unit test, manually update the buffer here.
  decoding_buffer.move(first_chunk);
  EXPECT_EQ(invocations.on_request_data_calls, 1);

  Buffer::OwnedImpl second_chunk = Buffer::OwnedImpl("B");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer,
            filter_->decodeData(second_chunk, false));
  // Manual update not required, because once iteration is stopped, data is added directly.
  EXPECT_EQ(invocations.on_request_data_calls, 2);

  Buffer::OwnedImpl third_chunk = Buffer::OwnedImpl("C");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->decodeData(third_chunk, false));
  // Manual update not required, because once iteration is stopped, data is added directly.
  EXPECT_EQ(invocations.on_request_data_calls, 3);
}

TEST_F(PlatformBridgeFilterTest, BasicError) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_headers = [](envoy_headers c_headers, bool, envoy_stream_intel,
                                           const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    invocations->on_response_headers_calls++;
    ADD_FAILURE() << "on_headers should not get called for an error response.";
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_response_data = [](envoy_data c_data, bool, envoy_stream_intel,
                                        const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    invocations->on_response_data_calls++;
    ADD_FAILURE() << "on_data should not get called for an error response.";
    release_envoy_data(c_data);
    return {kEnvoyFilterDataStatusStopIterationNoBuffer, envoy_nodata, nullptr};
  };
  platform_filter.on_error = [](envoy_error c_error, envoy_stream_intel, envoy_final_stream_intel,
                                const void* context) -> void {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    invocations->on_error_calls++;
    EXPECT_EQ(c_error.error_code, ENVOY_UNDEFINED_ERROR);
    EXPECT_EQ(Data::Utility::copyToString(c_error.message), "busted");
    EXPECT_EQ(c_error.attempt_count, 1);
    release_envoy_error(c_error);
  };

  setUpFilter("BasicError", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestResponseHeaderMapImpl response_headers{
      {"x-internal-error-code", "0"},
      {"x-internal-error-message", "busted"},
  };
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(response_headers, false));

  Buffer::OwnedImpl response_data = Buffer::OwnedImpl("busted");

  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(response_data, true));

  EXPECT_EQ(invocations.on_response_headers_calls, 0);
  EXPECT_EQ(invocations.on_response_data_calls, 0);
  EXPECT_EQ(invocations.on_error_calls, 1);
}

TEST_F(PlatformBridgeFilterTest, StopAndBufferThenResumeOnRequestData) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                       const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    envoy_filter_data_status return_status;

    if (invocations->on_request_data_calls == 0) {
      EXPECT_EQ(Data::Utility::copyToString(c_data), "A");
      EXPECT_FALSE(end_stream);

      return_status.status = kEnvoyFilterDataStatusStopIterationAndBuffer;
      return_status.data = envoy_nodata;
      return_status.pending_headers = nullptr;
    } else {
      EXPECT_EQ(Data::Utility::copyToString(c_data), "AB");
      EXPECT_FALSE(end_stream);
      Buffer::OwnedImpl final_buffer = Buffer::OwnedImpl("C");
      envoy_data final_data = Data::Utility::toBridgeData(final_buffer);

      return_status.status = kEnvoyFilterDataStatusResumeIteration;
      return_status.data = final_data;
      return_status.pending_headers = nullptr;
    }

    invocations->on_request_data_calls++;
    release_envoy_data(c_data);
    return return_status;
  };

  Buffer::OwnedImpl decoding_buffer;
  EXPECT_CALL(decoder_callbacks_, decodingBuffer())
      .Times(1)
      .WillRepeatedly(Return(&decoding_buffer));
  EXPECT_CALL(decoder_callbacks_, modifyDecodingBuffer(_))
      .Times(1)
      .WillRepeatedly(Invoke([&](std::function<void(Buffer::Instance&)> callback) -> void {
        callback(decoding_buffer);
      }));

  setUpFilter("StopAndBufferThenResumeOnRequestData", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Buffer::OwnedImpl first_chunk = Buffer::OwnedImpl("A");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationAndBuffer,
            filter_->decodeData(first_chunk, false));
  // Since the return code can't be handled in a unit test, manually update the buffer here.
  decoding_buffer.move(first_chunk);
  EXPECT_EQ(invocations.on_request_data_calls, 1);

  Buffer::OwnedImpl second_chunk = Buffer::OwnedImpl("B");
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(second_chunk, false));
  // Manual update not required, because once iteration is stopped, data is added directly.
  EXPECT_EQ(invocations.on_request_data_calls, 2);
  // Buffer has been updated with value from ResumeIteration.
  EXPECT_EQ(decoding_buffer.toString(), "C");
}

TEST_F(PlatformBridgeFilterTest, StopOnRequestHeadersThenBufferThenResumeOnData) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_headers = [](envoy_headers c_headers, bool end_stream,
                                          envoy_stream_intel,
                                          const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_request_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_request_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                       const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    envoy_filter_data_status return_status;

    if (invocations->on_request_data_calls == 0) {
      EXPECT_EQ(Data::Utility::copyToString(c_data), "A");
      EXPECT_FALSE(end_stream);

      return_status.status = kEnvoyFilterDataStatusStopIterationAndBuffer;
      return_status.data = envoy_nodata;
      return_status.pending_headers = nullptr;
    } else {
      EXPECT_EQ(Data::Utility::copyToString(c_data), "AB");
      EXPECT_TRUE(end_stream);
      Buffer::OwnedImpl final_buffer = Buffer::OwnedImpl("C");
      envoy_data final_data = Data::Utility::toBridgeData(final_buffer);
      envoy_headers* modified_headers =
          static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
      *modified_headers =
          make_envoy_headers({{":authority", "test.code"}, {"content-length", "1"}});

      return_status.status = kEnvoyFilterDataStatusResumeIteration;
      return_status.data = final_data;
      return_status.pending_headers = modified_headers;
    }

    invocations->on_request_data_calls++;
    release_envoy_data(c_data);
    return return_status;
  };

  Buffer::OwnedImpl decoding_buffer;
  EXPECT_CALL(decoder_callbacks_, decodingBuffer())
      .Times(2)
      .WillRepeatedly(Return(&decoding_buffer));
  EXPECT_CALL(decoder_callbacks_, modifyDecodingBuffer(_))
      .Times(2)
      .WillRepeatedly(Invoke([&](std::function<void(Buffer::Instance&)> callback) -> void {
        callback(decoding_buffer);
      }));

  setUpFilter("StopOnRequestHeadersThenBufferThenResumeOnData", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, false));
  EXPECT_EQ(invocations.on_request_headers_calls, 1);

  Buffer::OwnedImpl first_chunk = Buffer::OwnedImpl("A");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationAndBuffer,
            filter_->decodeData(first_chunk, false));
  // Since the return code can't be handled in a unit test, manually update the buffer here.
  decoding_buffer.move(first_chunk);
  EXPECT_EQ(invocations.on_request_data_calls, 1);

  Buffer::OwnedImpl second_chunk = Buffer::OwnedImpl("B");
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(second_chunk, true));
  // Manual update not required, because once iteration is stopped, data is added directly.
  EXPECT_EQ(invocations.on_request_data_calls, 2);
  // Buffer has been updated with value from ResumeIteration.
  EXPECT_EQ(decoding_buffer.toString(), "C");

  // Pending headers have been updated with value from ResumeIteration.
  EXPECT_FALSE(request_headers.get(Http::LowerCaseString("content-length")).empty());
  EXPECT_EQ(
      request_headers.get(Http::LowerCaseString("content-length"))[0]->value().getStringView(),
      "1");
}

TEST_F(PlatformBridgeFilterTest, StopNoBufferOnRequestData) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                       const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    std::string expected_data[3] = {"A", "B", "C"};
    EXPECT_EQ(Data::Utility::copyToString(c_data),
              expected_data[invocations->on_request_data_calls++]);
    EXPECT_FALSE(end_stream);
    release_envoy_data(c_data);
    return {kEnvoyFilterDataStatusStopIterationNoBuffer, envoy_nodata, nullptr};
  };

  setUpFilter("StopNoBufferOnRequestData", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Buffer::OwnedImpl first_chunk = Buffer::OwnedImpl("A");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->decodeData(first_chunk, false));
  EXPECT_EQ(invocations.on_request_data_calls, 1);

  Buffer::OwnedImpl second_chunk = Buffer::OwnedImpl("B");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer,
            filter_->decodeData(second_chunk, false));
  EXPECT_EQ(invocations.on_request_data_calls, 2);

  Buffer::OwnedImpl third_chunk = Buffer::OwnedImpl("C");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->decodeData(third_chunk, false));
  EXPECT_EQ(invocations.on_request_data_calls, 3);
}

TEST_F(PlatformBridgeFilterTest, BasicContinueOnRequestTrailers) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_trailers = [](envoy_headers c_trailers, envoy_stream_intel,
                                           const void* context) -> envoy_filter_trailers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_trailers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].key), "x-test-trailer");
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].value), "test trailer");
    invocations->on_request_trailers_calls++;
    return {kEnvoyFilterTrailersStatusContinue, c_trailers, nullptr, nullptr};
  };

  setUpFilter("BasicContinueOnRequestTrailers", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestRequestTrailerMapImpl request_trailers{{"x-test-trailer", "test trailer"}};

  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->decodeTrailers(request_trailers));
  EXPECT_EQ(invocations.on_request_trailers_calls, 1);
}

TEST_F(PlatformBridgeFilterTest, StopOnRequestHeadersThenBufferThenResumeOnTrailers) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_headers = [](envoy_headers c_headers, bool end_stream,
                                          envoy_stream_intel,
                                          const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_request_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_request_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                       const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    std::string expected_data[2] = {"A", "AB"};
    EXPECT_EQ(Data::Utility::copyToString(c_data),
              expected_data[invocations->on_request_data_calls]);
    EXPECT_FALSE(end_stream);
    release_envoy_data(c_data);
    invocations->on_request_data_calls++;
    return {kEnvoyFilterDataStatusStopIterationAndBuffer, envoy_nodata, nullptr};
  };
  platform_filter.on_request_trailers = [](envoy_headers c_trailers, envoy_stream_intel,
                                           const void* context) -> envoy_filter_trailers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_trailers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].key), "x-test-trailer");
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].value), "test trailer");

    Buffer::OwnedImpl final_buffer = Buffer::OwnedImpl("C");
    envoy_data* modified_data = static_cast<envoy_data*>(safe_malloc(sizeof(envoy_data)));
    *modified_data = Data::Utility::toBridgeData(final_buffer);
    envoy_headers* modified_headers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_headers = make_envoy_headers({{":authority", "test.code"}, {"content-length", "1"}});

    invocations->on_request_trailers_calls++;
    return {kEnvoyFilterTrailersStatusResumeIteration, c_trailers, modified_headers, modified_data};
  };

  Buffer::OwnedImpl decoding_buffer;
  EXPECT_CALL(decoder_callbacks_, decodingBuffer())
      .Times(3)
      .WillRepeatedly(Return(&decoding_buffer));
  EXPECT_CALL(decoder_callbacks_, modifyDecodingBuffer(_))
      .Times(3)
      .WillRepeatedly(Invoke([&](std::function<void(Buffer::Instance&)> callback) -> void {
        callback(decoding_buffer);
      }));

  setUpFilter("StopOnRequestHeadersThenBufferThenResumeOnTrailers", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, false));
  EXPECT_EQ(invocations.on_request_headers_calls, 1);

  Buffer::OwnedImpl first_chunk = Buffer::OwnedImpl("A");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationAndBuffer,
            filter_->decodeData(first_chunk, false));
  // Since the return code can't be handled in a unit test, manually update the buffer here.
  decoding_buffer.move(first_chunk);
  EXPECT_EQ(invocations.on_request_data_calls, 1);

  Buffer::OwnedImpl second_chunk = Buffer::OwnedImpl("B");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer,
            filter_->decodeData(second_chunk, false));
  // Manual update not required, because once iteration is stopped, data is added directly.
  EXPECT_EQ(invocations.on_request_data_calls, 2);
  EXPECT_EQ(decoding_buffer.toString(), "AB");

  Http::TestRequestTrailerMapImpl request_trailers{{"x-test-trailer", "test trailer"}};

  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->decodeTrailers(request_trailers));
  EXPECT_EQ(invocations.on_request_trailers_calls, 1);

  // Buffer has been updated with value from ResumeIteration.
  EXPECT_EQ(decoding_buffer.toString(), "C");

  // Pending headers have been updated with value from ResumeIteration.
  EXPECT_FALSE(request_headers.get(Http::LowerCaseString("content-length")).empty());
  EXPECT_EQ(
      request_headers.get(Http::LowerCaseString("content-length"))[0]->value().getStringView(),
      "1");
}

TEST_F(PlatformBridgeFilterTest, StopOnRequestHeadersThenBufferThenResumeOnResumeDecoding) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_headers = [](envoy_headers c_headers, bool end_stream,
                                          envoy_stream_intel,
                                          const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_request_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_request_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                       const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    std::string expected_data[2] = {"A", "AB"};
    EXPECT_EQ(Data::Utility::copyToString(c_data),
              expected_data[invocations->on_request_data_calls]);
    EXPECT_FALSE(end_stream);
    release_envoy_data(c_data);
    invocations->on_request_data_calls++;
    return {kEnvoyFilterDataStatusStopIterationAndBuffer, envoy_nodata, nullptr};
  };
  platform_filter.on_request_trailers = [](envoy_headers c_trailers, envoy_stream_intel,
                                           const void* context) -> envoy_filter_trailers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_trailers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].key), "x-test-trailer");
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].value), "test trailer");
    release_envoy_headers(c_trailers);
    invocations->on_request_trailers_calls++;
    return {kEnvoyFilterTrailersStatusStopIteration, envoy_noheaders, nullptr, nullptr};
  };
  platform_filter.on_resume_request =
      [](envoy_headers* pending_headers, envoy_data* pending_data, envoy_headers* pending_trailers,
         bool end_stream, envoy_stream_intel, const void* context) -> envoy_filter_resume_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(pending_headers->length, 1);
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].value), "test.code");
    EXPECT_EQ(Data::Utility::copyToString(*pending_data), "AB");
    EXPECT_EQ(pending_trailers->length, 1);
    EXPECT_EQ(Data::Utility::copyToString(pending_trailers->entries[0].key), "x-test-trailer");
    EXPECT_EQ(Data::Utility::copyToString(pending_trailers->entries[0].value), "test trailer");
    EXPECT_TRUE(end_stream);

    envoy_headers* modified_headers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_headers =
        make_envoy_headers({{":authority", "test.code"}, {"x-async-resumed", "Very Yes"}});
    release_envoy_headers(*pending_headers);
    Buffer::OwnedImpl final_buffer = Buffer::OwnedImpl("C");
    envoy_data* modified_data = static_cast<envoy_data*>(safe_malloc(sizeof(envoy_data)));
    *modified_data = Data::Utility::toBridgeData(final_buffer);
    release_envoy_data(*pending_data);
    envoy_headers* modified_trailers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_trailers =
        make_envoy_headers({{"x-test-trailer", "test trailer"}, {"x-async-resumed", "yes"}});
    release_envoy_headers(*pending_trailers);

    invocations->on_resume_request_calls++;
    return {kEnvoyFilterResumeStatusResumeIteration, modified_headers, modified_data,
            modified_trailers};
  };

  Buffer::OwnedImpl decoding_buffer;
  EXPECT_CALL(decoder_callbacks_, decodingBuffer())
      .Times(4)
      .WillRepeatedly(Return(&decoding_buffer));
  EXPECT_CALL(decoder_callbacks_, modifyDecodingBuffer(_))
      .Times(4)
      .WillRepeatedly(Invoke([&](std::function<void(Buffer::Instance&)> callback) -> void {
        callback(decoding_buffer);
      }));

  setUpFilter("StopOnRequestHeadersThenBufferThenResumeOnResumeDecoding", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, false));
  EXPECT_EQ(invocations.on_request_headers_calls, 1);

  Buffer::OwnedImpl first_chunk = Buffer::OwnedImpl("A");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationAndBuffer,
            filter_->decodeData(first_chunk, false));
  // Since the return code can't be handled in a unit test, manually update the buffer here.
  decoding_buffer.move(first_chunk);
  EXPECT_EQ(invocations.on_request_data_calls, 1);

  Buffer::OwnedImpl second_chunk = Buffer::OwnedImpl("B");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer,
            filter_->decodeData(second_chunk, false));
  // Manual update not required, because once iteration is stopped, data is added directly.
  EXPECT_EQ(invocations.on_request_data_calls, 2);
  EXPECT_EQ(decoding_buffer.toString(), "AB");

  Http::TestRequestTrailerMapImpl request_trailers{{"x-test-trailer", "test trailer"}};

  EXPECT_EQ(Http::FilterTrailersStatus::StopIteration, filter_->decodeTrailers(request_trailers));
  EXPECT_EQ(invocations.on_request_trailers_calls, 1);

  Event::PostCb resume_post_cb;
  EXPECT_CALL(dispatcher_, post(_)).WillOnce([&resume_post_cb](Event::PostCb cb) {
    resume_post_cb = std::move(cb);
  });
  EXPECT_CALL(decoder_callbacks_, continueDecoding());
  filter_->resumeDecoding();
  resume_post_cb();
  EXPECT_EQ(invocations.on_resume_request_calls, 1);

  // Pending headers have been updated with the value from ResumeIteration.
  EXPECT_FALSE(request_headers.get(Http::LowerCaseString("x-async-resumed")).empty());
  EXPECT_EQ(
      request_headers.get(Http::LowerCaseString("x-async-resumed"))[0]->value().getStringView(),
      "Very Yes");

  // Buffer has been updated with value from ResumeIteration.
  EXPECT_EQ(decoding_buffer.toString(), "C");

  // Pending trailers have been updated with value from ResumeIteration.
  EXPECT_FALSE(request_trailers.get(Http::LowerCaseString("x-async-resumed")).empty());
  EXPECT_EQ(
      request_trailers.get(Http::LowerCaseString("x-async-resumed"))[0]->value().getStringView(),
      "yes");
}

TEST_F(PlatformBridgeFilterTest, StopOnRequestHeadersThenBufferThenDontResumeOnResumeDecoding) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_headers = [](envoy_headers c_headers, bool end_stream,
                                          envoy_stream_intel,
                                          const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_request_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_request_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                       const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    std::string expected_data[2] = {"A", "AB"};
    EXPECT_EQ(Data::Utility::copyToString(c_data),
              expected_data[invocations->on_request_data_calls]);
    EXPECT_FALSE(end_stream);
    release_envoy_data(c_data);
    invocations->on_request_data_calls++;
    return {kEnvoyFilterDataStatusStopIterationAndBuffer, envoy_nodata, nullptr};
  };
  platform_filter.on_request_trailers = [](envoy_headers c_trailers, envoy_stream_intel,
                                           const void* context) -> envoy_filter_trailers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_trailers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].key), "x-test-trailer");
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].value), "test trailer");
    release_envoy_headers(c_trailers);
    invocations->on_request_trailers_calls++;
    return {kEnvoyFilterTrailersStatusStopIteration, envoy_noheaders, nullptr, nullptr};
  };
  platform_filter.on_resume_request =
      [](envoy_headers* pending_headers, envoy_data* pending_data, envoy_headers* pending_trailers,
         bool end_stream, envoy_stream_intel, const void* context) -> envoy_filter_resume_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(pending_headers->length, 1);
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].value), "test.code");
    EXPECT_EQ(Data::Utility::copyToString(*pending_data), "AB");
    EXPECT_EQ(pending_trailers->length, 1);
    EXPECT_EQ(Data::Utility::copyToString(pending_trailers->entries[0].key), "x-test-trailer");
    EXPECT_EQ(Data::Utility::copyToString(pending_trailers->entries[0].value), "test trailer");
    EXPECT_TRUE(end_stream);

    release_envoy_headers(*pending_headers);
    release_envoy_data(*pending_data);
    release_envoy_headers(*pending_trailers);

    invocations->on_resume_request_calls++;
    return {kEnvoyFilterResumeStatusStopIteration, nullptr, nullptr, nullptr};
  };

  Buffer::OwnedImpl decoding_buffer;
  EXPECT_CALL(decoder_callbacks_, decodingBuffer())
      .Times(4)
      .WillRepeatedly(Return(&decoding_buffer));
  EXPECT_CALL(decoder_callbacks_, modifyDecodingBuffer(_))
      .Times(4)
      .WillRepeatedly(Invoke([&](std::function<void(Buffer::Instance&)> callback) -> void {
        callback(decoding_buffer);
      }));

  setUpFilter("StopOnRequestHeadersThenBufferThenResumeOnResumeDecoding", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, false));
  EXPECT_EQ(invocations.on_request_headers_calls, 1);

  Buffer::OwnedImpl first_chunk = Buffer::OwnedImpl("A");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationAndBuffer,
            filter_->decodeData(first_chunk, false));
  // Since the return code can't be handled in a unit test, manually update the buffer here.
  decoding_buffer.move(first_chunk);
  EXPECT_EQ(invocations.on_request_data_calls, 1);

  Buffer::OwnedImpl second_chunk = Buffer::OwnedImpl("B");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer,
            filter_->decodeData(second_chunk, false));
  // Manual update not required, because once iteration is stopped, data is added directly.
  EXPECT_EQ(invocations.on_request_data_calls, 2);
  EXPECT_EQ(decoding_buffer.toString(), "AB");

  Http::TestRequestTrailerMapImpl request_trailers{{"x-test-trailer", "test trailer"}};

  EXPECT_EQ(Http::FilterTrailersStatus::StopIteration, filter_->decodeTrailers(request_trailers));
  EXPECT_EQ(invocations.on_request_trailers_calls, 1);

  Event::PostCb resume_post_cb;
  EXPECT_CALL(dispatcher_, post(_)).WillOnce([&resume_post_cb](Event::PostCb cb) {
    resume_post_cb = std::move(cb);
  });
  filter_->resumeDecoding();
  resume_post_cb();
  EXPECT_EQ(invocations.on_resume_request_calls, 1);
}

// DIVIDE

TEST_F(PlatformBridgeFilterTest, BasicContinueOnResponseHeaders) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_headers = [](envoy_headers c_headers, bool end_stream,
                                           envoy_stream_intel,
                                           const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":status");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_TRUE(end_stream);
    invocations->on_response_headers_calls++;
    return {kEnvoyFilterHeadersStatusContinue, c_headers};
  };

  setUpFilter("BasicContinueOnResponseHeaders", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(response_headers, true));
  EXPECT_EQ(invocations.on_response_headers_calls, 1);
}

TEST_F(PlatformBridgeFilterTest, StopOnResponseHeadersThenResumeOnData) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_headers = [](envoy_headers c_headers, bool end_stream,
                                           envoy_stream_intel,
                                           const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":status");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_response_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_response_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                        const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(Data::Utility::copyToString(c_data), "response body");
    EXPECT_TRUE(end_stream);
    invocations->on_response_data_calls++;
    envoy_headers* modified_headers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_headers = make_envoy_headers({{":status", "test.code"}, {"content-length", "13"}});
    return {kEnvoyFilterDataStatusResumeIteration, c_data, modified_headers};
  };

  setUpFilter("StopOnResponseHeadersThenResumeOnData", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->encodeHeaders(response_headers, false));
  EXPECT_EQ(invocations.on_response_headers_calls, 1);

  Buffer::OwnedImpl response_data = Buffer::OwnedImpl("response body");

  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(response_data, true));
  EXPECT_EQ(invocations.on_response_data_calls, 1);

  EXPECT_FALSE(response_headers.get(Http::LowerCaseString("content-length")).empty());
  EXPECT_EQ(
      response_headers.get(Http::LowerCaseString("content-length"))[0]->value().getStringView(),
      "13");
}

TEST_F(PlatformBridgeFilterTest, StopOnResponseHeadersThenResumeOnResumeEncoding) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_headers = [](envoy_headers c_headers, bool end_stream,
                                           envoy_stream_intel,
                                           const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":status");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_response_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_resume_response =
      [](envoy_headers* pending_headers, envoy_data* pending_data, envoy_headers* pending_trailers,
         bool end_stream, envoy_stream_intel, const void* context) -> envoy_filter_resume_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(pending_headers->length, 1);
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].key), ":status");
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].value), "test.code");
    EXPECT_EQ(pending_data, nullptr);
    EXPECT_EQ(pending_trailers, nullptr);
    EXPECT_FALSE(end_stream);
    invocations->on_resume_response_calls++;
    envoy_headers* modified_headers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_headers =
        make_envoy_headers({{":status", "test.code"}, {"x-async-resumed", "Very Yes"}});
    release_envoy_headers(*pending_headers);
    return {kEnvoyFilterResumeStatusResumeIteration, modified_headers, nullptr, nullptr};
  };

  setUpFilter("StopOnResponseHeadersThenResumeOnResumeEncoding", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->encodeHeaders(response_headers, false));
  EXPECT_EQ(invocations.on_response_headers_calls, 1);

  Event::PostCb resume_post_cb;
  EXPECT_CALL(dispatcher_, post(_)).WillOnce([&resume_post_cb](Event::PostCb cb) {
    resume_post_cb = std::move(cb);
  });
  EXPECT_CALL(encoder_callbacks_, continueEncoding());
  filter_->resumeEncoding();
  resume_post_cb();
  EXPECT_EQ(invocations.on_resume_response_calls, 1);

  EXPECT_FALSE(response_headers.get(Http::LowerCaseString("x-async-resumed")).empty());
  EXPECT_EQ(
      response_headers.get(Http::LowerCaseString("x-async-resumed"))[0]->value().getStringView(),
      "Very Yes");
}

TEST_F(PlatformBridgeFilterTest, AsyncResumeEncodingIsNoopAfterPreviousResume) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_headers = [](envoy_headers c_headers, bool end_stream,
                                           envoy_stream_intel,
                                           const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":status");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_response_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_response_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                        const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(Data::Utility::copyToString(c_data), "response body");
    EXPECT_TRUE(end_stream);
    invocations->on_response_data_calls++;
    envoy_headers* modified_headers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_headers = make_envoy_headers({{":status", "test.code"}, {"content-length", "13"}});
    return {kEnvoyFilterDataStatusResumeIteration, c_data, modified_headers};
  };
  platform_filter.on_resume_response = [](envoy_headers*, envoy_data*, envoy_headers*, bool,
                                          envoy_stream_intel,
                                          const void*) -> envoy_filter_resume_status {
    ADD_FAILURE() << "on_resume_response should not get called when iteration is already ongoing.";
    return {kEnvoyFilterResumeStatusResumeIteration, nullptr, nullptr, nullptr};
  };

  setUpFilter("AsyncResumeEncodingIsNoopAfterPreviousResume", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->encodeHeaders(response_headers, false));
  EXPECT_EQ(invocations.on_response_headers_calls, 1);

  Buffer::OwnedImpl response_data = Buffer::OwnedImpl("response body");

  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(response_data, true));
  EXPECT_EQ(invocations.on_response_data_calls, 1);

  EXPECT_FALSE(response_headers.get(Http::LowerCaseString("content-length")).empty());
  EXPECT_EQ(
      response_headers.get(Http::LowerCaseString("content-length"))[0]->value().getStringView(),
      "13");

  Event::PostCb resume_post_cb;
  EXPECT_CALL(dispatcher_, post(_)).WillOnce([&resume_post_cb](Event::PostCb cb) {
    resume_post_cb = std::move(cb);
  });
  EXPECT_CALL(encoder_callbacks_, continueEncoding()).Times(0);
  filter_->resumeEncoding();
  resume_post_cb();
  EXPECT_EQ(invocations.on_resume_response_calls, 0);
}

TEST_F(PlatformBridgeFilterTest, AsyncResumeEncodingIsNoopAfterFilterIsPendingDestruction) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_headers = [](envoy_headers c_headers, bool end_stream,
                                           envoy_stream_intel,
                                           const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":status");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_response_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_resume_response = [](envoy_headers*, envoy_data*, envoy_headers*, bool,
                                          envoy_stream_intel,
                                          const void*) -> envoy_filter_resume_status {
    ADD_FAILURE() << "on_resume_response should not get called when filter is pending destruction.";
    return {kEnvoyFilterResumeStatusResumeIteration, nullptr, nullptr, nullptr};
  };
  platform_filter.release_filter = [](const void* context) -> void {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    invocations->release_filter_calls++;
  };

  setUpFilter("AsyncResumeEncodingIsNoopAfterFilterIsPendingDestruction", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->encodeHeaders(response_headers, false));
  EXPECT_EQ(invocations.on_response_headers_calls, 1);

  Buffer::OwnedImpl response_data = Buffer::OwnedImpl("response body");

  // Simulate posted resume call.
  Event::PostCb resume_post_cb;
  EXPECT_CALL(dispatcher_, post(_)).WillOnce([&resume_post_cb](Event::PostCb cb) {
    resume_post_cb = std::move(cb);
  });
  EXPECT_CALL(encoder_callbacks_, continueEncoding()).Times(0);
  filter_->resumeEncoding();

  // Simulate pending destruction.
  filter_->onDestroy();
  EXPECT_EQ(invocations.release_filter_calls, 1);

  // Execute late resume callback.
  resume_post_cb();

  // Assert late resume attempt was a no-op.
  EXPECT_EQ(invocations.on_resume_response_calls, 0);
}

TEST_F(PlatformBridgeFilterTest, BasicContinueOnResponseData) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                        const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(Data::Utility::copyToString(c_data), "response body");
    EXPECT_TRUE(end_stream);
    invocations->on_response_data_calls++;
    return {kEnvoyFilterDataStatusContinue, c_data, nullptr};
  };

  setUpFilter("BasicContinueOnResponseData", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Buffer::OwnedImpl response_data = Buffer::OwnedImpl("response body");

  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(response_data, true));
  EXPECT_EQ(invocations.on_response_data_calls, 1);
}

TEST_F(PlatformBridgeFilterTest, StopAndBufferOnResponseData) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                        const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    std::string expected_data[3] = {"A", "AB", "ABC"};
    EXPECT_EQ(Data::Utility::copyToString(c_data),
              expected_data[invocations->on_response_data_calls++]);
    EXPECT_FALSE(end_stream);
    release_envoy_data(c_data);
    return {kEnvoyFilterDataStatusStopIterationAndBuffer, envoy_nodata, nullptr};
  };

  Buffer::OwnedImpl encoding_buffer;
  EXPECT_CALL(encoder_callbacks_, encodingBuffer())
      .Times(2)
      .WillRepeatedly(Return(&encoding_buffer));
  EXPECT_CALL(encoder_callbacks_, modifyEncodingBuffer(_))
      .Times(2)
      .WillRepeatedly(Invoke([&](std::function<void(Buffer::Instance&)> callback) -> void {
        callback(encoding_buffer);
      }));

  setUpFilter("StopAndBufferOnResponseData", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Buffer::OwnedImpl first_chunk = Buffer::OwnedImpl("A");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationAndBuffer,
            filter_->encodeData(first_chunk, false));
  // Since the return code can't be handled in a unit test, manually update the buffer here.
  encoding_buffer.move(first_chunk);
  EXPECT_EQ(invocations.on_response_data_calls, 1);

  Buffer::OwnedImpl second_chunk = Buffer::OwnedImpl("B");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer,
            filter_->encodeData(second_chunk, false));
  // Manual update not required, because once iteration is stopped, data is added directly.
  EXPECT_EQ(invocations.on_response_data_calls, 2);

  Buffer::OwnedImpl third_chunk = Buffer::OwnedImpl("C");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->encodeData(third_chunk, false));
  // Manual update not required, because once iteration is stopped, data is added directly.
  EXPECT_EQ(invocations.on_response_data_calls, 3);
}

TEST_F(PlatformBridgeFilterTest, StopAndBufferThenResumeOnResponseData) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                        const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    envoy_filter_data_status return_status;

    if (invocations->on_response_data_calls == 0) {
      EXPECT_EQ(Data::Utility::copyToString(c_data), "A");
      EXPECT_FALSE(end_stream);

      return_status.status = kEnvoyFilterDataStatusStopIterationAndBuffer;
      return_status.data = envoy_nodata;
      return_status.pending_headers = nullptr;
    } else {
      EXPECT_EQ(Data::Utility::copyToString(c_data), "AB");
      EXPECT_FALSE(end_stream);
      Buffer::OwnedImpl final_buffer = Buffer::OwnedImpl("C");
      envoy_data final_data = Data::Utility::toBridgeData(final_buffer);

      return_status.status = kEnvoyFilterDataStatusResumeIteration;
      return_status.data = final_data;
      return_status.pending_headers = nullptr;
    }

    invocations->on_response_data_calls++;
    release_envoy_data(c_data);
    return return_status;
  };

  Buffer::OwnedImpl encoding_buffer;
  EXPECT_CALL(encoder_callbacks_, encodingBuffer())
      .Times(1)
      .WillRepeatedly(Return(&encoding_buffer));
  EXPECT_CALL(encoder_callbacks_, modifyEncodingBuffer(_))
      .Times(1)
      .WillRepeatedly(Invoke([&](std::function<void(Buffer::Instance&)> callback) -> void {
        callback(encoding_buffer);
      }));

  setUpFilter("StopAndBufferThenResumeOnResponseData", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Buffer::OwnedImpl first_chunk = Buffer::OwnedImpl("A");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationAndBuffer,
            filter_->encodeData(first_chunk, false));
  // Since the return code can't be handled in a unit test, manually update the buffer here.
  encoding_buffer.move(first_chunk);
  EXPECT_EQ(invocations.on_response_data_calls, 1);

  Buffer::OwnedImpl second_chunk = Buffer::OwnedImpl("B");
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(second_chunk, false));
  // Manual update not required, because once iteration is stopped, data is added directly.
  EXPECT_EQ(invocations.on_response_data_calls, 2);
  // Buffer has been updated with value from ResumeIteration.
  EXPECT_EQ(encoding_buffer.toString(), "C");
}

TEST_F(PlatformBridgeFilterTest, StopOnResponseHeadersThenBufferThenResumeOnData) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_headers = [](envoy_headers c_headers, bool end_stream,
                                           envoy_stream_intel,
                                           const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":status");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_response_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_response_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                        const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    envoy_filter_data_status return_status;

    if (invocations->on_response_data_calls == 0) {
      EXPECT_EQ(Data::Utility::copyToString(c_data), "A");
      EXPECT_FALSE(end_stream);

      return_status.status = kEnvoyFilterDataStatusStopIterationAndBuffer;
      return_status.data = envoy_nodata;
      return_status.pending_headers = nullptr;
    } else {
      EXPECT_EQ(Data::Utility::copyToString(c_data), "AB");
      EXPECT_TRUE(end_stream);
      Buffer::OwnedImpl final_buffer = Buffer::OwnedImpl("C");
      envoy_data final_data = Data::Utility::toBridgeData(final_buffer);
      envoy_headers* modified_headers =
          static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
      *modified_headers = make_envoy_headers({{":status", "test.code"}, {"content-length", "1"}});

      return_status.status = kEnvoyFilterDataStatusResumeIteration;
      return_status.data = final_data;
      return_status.pending_headers = modified_headers;
    }

    invocations->on_response_data_calls++;
    release_envoy_data(c_data);
    return return_status;
  };

  Buffer::OwnedImpl encoding_buffer;
  EXPECT_CALL(encoder_callbacks_, encodingBuffer())
      .Times(2)
      .WillRepeatedly(Return(&encoding_buffer));
  EXPECT_CALL(encoder_callbacks_, modifyEncodingBuffer(_))
      .Times(2)
      .WillRepeatedly(Invoke([&](std::function<void(Buffer::Instance&)> callback) -> void {
        callback(encoding_buffer);
      }));

  setUpFilter("StopOnResponseHeadersThenBufferThenResumeOnData", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->encodeHeaders(response_headers, false));
  EXPECT_EQ(invocations.on_response_headers_calls, 1);

  Buffer::OwnedImpl first_chunk = Buffer::OwnedImpl("A");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationAndBuffer,
            filter_->encodeData(first_chunk, false));
  // Since the return code can't be handled in a unit test, manually update the buffer here.
  encoding_buffer.move(first_chunk);
  EXPECT_EQ(invocations.on_response_data_calls, 1);

  Buffer::OwnedImpl second_chunk = Buffer::OwnedImpl("B");
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(second_chunk, true));
  // Manual update not required, because once iteration is stopped, data is added directly.
  EXPECT_EQ(invocations.on_response_data_calls, 2);
  // Buffer has been updated with value from ResumeIteration.
  EXPECT_EQ(encoding_buffer.toString(), "C");

  // Pending headers have been updated with value from ResumeIteration.
  EXPECT_FALSE(response_headers.get(Http::LowerCaseString("content-length")).empty());
  EXPECT_EQ(
      response_headers.get(Http::LowerCaseString("content-length"))[0]->value().getStringView(),
      "1");
}

TEST_F(PlatformBridgeFilterTest, StopNoBufferOnResponseData) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                        const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    std::string expected_data[3] = {"A", "B", "C"};
    EXPECT_EQ(Data::Utility::copyToString(c_data),
              expected_data[invocations->on_response_data_calls++]);
    EXPECT_FALSE(end_stream);
    release_envoy_data(c_data);
    return {kEnvoyFilterDataStatusStopIterationNoBuffer, envoy_nodata, nullptr};
  };

  setUpFilter("StopNoBufferOnResponseData", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Buffer::OwnedImpl first_chunk = Buffer::OwnedImpl("A");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->encodeData(first_chunk, false));
  EXPECT_EQ(invocations.on_response_data_calls, 1);

  Buffer::OwnedImpl second_chunk = Buffer::OwnedImpl("B");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer,
            filter_->encodeData(second_chunk, false));
  EXPECT_EQ(invocations.on_response_data_calls, 2);

  Buffer::OwnedImpl third_chunk = Buffer::OwnedImpl("C");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->encodeData(third_chunk, false));
  EXPECT_EQ(invocations.on_response_data_calls, 3);
}

TEST_F(PlatformBridgeFilterTest, BasicContinueOnResponseTrailers) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_trailers = [](envoy_headers c_trailers, envoy_stream_intel,
                                            const void* context) -> envoy_filter_trailers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_trailers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].key), "x-test-trailer");
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].value), "test trailer");
    invocations->on_response_trailers_calls++;
    return {kEnvoyFilterTrailersStatusContinue, c_trailers, nullptr, nullptr};
  };

  setUpFilter("BasicContinueOnResponseTrailers", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestResponseTrailerMapImpl response_trailers{{"x-test-trailer", "test trailer"}};

  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->encodeTrailers(response_trailers));
  EXPECT_EQ(invocations.on_response_trailers_calls, 1);
}

TEST_F(PlatformBridgeFilterTest, StopOnResponseHeadersThenBufferThenResumeOnTrailers) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_headers = [](envoy_headers c_headers, bool end_stream,
                                           envoy_stream_intel,
                                           const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":status");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_response_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_response_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                        const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    std::string expected_data[2] = {"A", "AB"};
    EXPECT_EQ(Data::Utility::copyToString(c_data),
              expected_data[invocations->on_response_data_calls]);
    EXPECT_FALSE(end_stream);
    release_envoy_data(c_data);
    invocations->on_response_data_calls++;
    return {kEnvoyFilterDataStatusStopIterationAndBuffer, envoy_nodata, nullptr};
  };
  platform_filter.on_response_trailers = [](envoy_headers c_trailers, envoy_stream_intel,
                                            const void* context) -> envoy_filter_trailers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_trailers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].key), "x-test-trailer");
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].value), "test trailer");

    Buffer::OwnedImpl final_buffer = Buffer::OwnedImpl("C");
    envoy_data* modified_data = static_cast<envoy_data*>(safe_malloc(sizeof(envoy_data)));
    *modified_data = Data::Utility::toBridgeData(final_buffer);
    envoy_headers* modified_headers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_headers = make_envoy_headers({{":status", "test.code"}, {"content-length", "1"}});

    invocations->on_response_trailers_calls++;
    return {kEnvoyFilterTrailersStatusResumeIteration, c_trailers, modified_headers, modified_data};
  };

  Buffer::OwnedImpl encoding_buffer;
  EXPECT_CALL(encoder_callbacks_, encodingBuffer())
      .Times(3)
      .WillRepeatedly(Return(&encoding_buffer));
  EXPECT_CALL(encoder_callbacks_, modifyEncodingBuffer(_))
      .Times(3)
      .WillRepeatedly(Invoke([&](std::function<void(Buffer::Instance&)> callback) -> void {
        callback(encoding_buffer);
      }));

  setUpFilter("StopOnResponseHeadersThenBufferThenResumeOnTrailers", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->encodeHeaders(response_headers, false));
  EXPECT_EQ(invocations.on_response_headers_calls, 1);

  Buffer::OwnedImpl first_chunk = Buffer::OwnedImpl("A");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationAndBuffer,
            filter_->encodeData(first_chunk, false));
  // Since the return code can't be handled in a unit test, manually update the buffer here.
  encoding_buffer.move(first_chunk);
  EXPECT_EQ(invocations.on_response_data_calls, 1);

  Buffer::OwnedImpl second_chunk = Buffer::OwnedImpl("B");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer,
            filter_->encodeData(second_chunk, false));
  // Manual update not required, because once iteration is stopped, data is added directly.
  EXPECT_EQ(invocations.on_response_data_calls, 2);
  EXPECT_EQ(encoding_buffer.toString(), "AB");

  Http::TestResponseTrailerMapImpl response_trailers{{"x-test-trailer", "test trailer"}};

  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->encodeTrailers(response_trailers));
  EXPECT_EQ(invocations.on_response_trailers_calls, 1);

  // Buffer has been updated with value from ResumeIteration.
  EXPECT_EQ(encoding_buffer.toString(), "C");

  // Pending headers have been updated with value from ResumeIteration.
  EXPECT_FALSE(response_headers.get(Http::LowerCaseString("content-length")).empty());
  EXPECT_EQ(
      response_headers.get(Http::LowerCaseString("content-length"))[0]->value().getStringView(),
      "1");
}

TEST_F(PlatformBridgeFilterTest, StopOnResponseHeadersThenBufferThenResumeOnResumeEncoding) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_response_headers = [](envoy_headers c_headers, bool end_stream,
                                           envoy_stream_intel,
                                           const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":status");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_response_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_response_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                        const void* context) -> envoy_filter_data_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    std::string expected_data[2] = {"A", "AB"};
    EXPECT_EQ(Data::Utility::copyToString(c_data),
              expected_data[invocations->on_response_data_calls]);
    EXPECT_FALSE(end_stream);
    release_envoy_data(c_data);
    invocations->on_response_data_calls++;
    return {kEnvoyFilterDataStatusStopIterationAndBuffer, envoy_nodata, nullptr};
  };
  platform_filter.on_response_trailers = [](envoy_headers c_trailers, envoy_stream_intel,
                                            const void* context) -> envoy_filter_trailers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_trailers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].key), "x-test-trailer");
    EXPECT_EQ(Data::Utility::copyToString(c_trailers.entries[0].value), "test trailer");
    release_envoy_headers(c_trailers);
    invocations->on_response_trailers_calls++;
    return {kEnvoyFilterTrailersStatusStopIteration, envoy_noheaders, nullptr, nullptr};
  };
  platform_filter.on_resume_response =
      [](envoy_headers* pending_headers, envoy_data* pending_data, envoy_headers* pending_trailers,
         bool end_stream, envoy_stream_intel, const void* context) -> envoy_filter_resume_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(pending_headers->length, 1);
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].key), ":status");
    EXPECT_EQ(Data::Utility::copyToString(pending_headers->entries[0].value), "test.code");
    EXPECT_EQ(Data::Utility::copyToString(*pending_data), "AB");
    EXPECT_EQ(pending_trailers->length, 1);
    EXPECT_EQ(Data::Utility::copyToString(pending_trailers->entries[0].key), "x-test-trailer");
    EXPECT_EQ(Data::Utility::copyToString(pending_trailers->entries[0].value), "test trailer");
    EXPECT_TRUE(end_stream);

    envoy_headers* modified_headers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_headers =
        make_envoy_headers({{":status", "test.code"}, {"x-async-resumed", "Very Yes"}});
    release_envoy_headers(*pending_headers);
    Buffer::OwnedImpl final_buffer = Buffer::OwnedImpl("C");
    envoy_data* modified_data = static_cast<envoy_data*>(safe_malloc(sizeof(envoy_data)));
    *modified_data = Data::Utility::toBridgeData(final_buffer);
    release_envoy_data(*pending_data);
    envoy_headers* modified_trailers =
        static_cast<envoy_headers*>(safe_malloc(sizeof(envoy_headers)));
    *modified_trailers =
        make_envoy_headers({{"x-test-trailer", "test trailer"}, {"x-async-resumed", "yes"}});
    release_envoy_headers(*pending_trailers);

    invocations->on_resume_response_calls++;
    return {kEnvoyFilterResumeStatusResumeIteration, modified_headers, modified_data,
            modified_trailers};
  };

  Buffer::OwnedImpl encoding_buffer;
  EXPECT_CALL(encoder_callbacks_, encodingBuffer())
      .Times(4)
      .WillRepeatedly(Return(&encoding_buffer));
  EXPECT_CALL(encoder_callbacks_, modifyEncodingBuffer(_))
      .Times(4)
      .WillRepeatedly(Invoke([&](std::function<void(Buffer::Instance&)> callback) -> void {
        callback(encoding_buffer);
      }));

  setUpFilter("StopOnResponseHeadersThenBufferThenResumeOnResumeEncoding", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->encodeHeaders(response_headers, false));
  EXPECT_EQ(invocations.on_response_headers_calls, 1);

  Buffer::OwnedImpl first_chunk = Buffer::OwnedImpl("A");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationAndBuffer,
            filter_->encodeData(first_chunk, false));
  // Since the return code can't be handled in a unit test, manually update the buffer here.
  encoding_buffer.move(first_chunk);
  EXPECT_EQ(invocations.on_response_data_calls, 1);

  Buffer::OwnedImpl second_chunk = Buffer::OwnedImpl("B");
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer,
            filter_->encodeData(second_chunk, false));
  // Manual update not required, because once iteration is stopped, data is added directly.
  EXPECT_EQ(invocations.on_response_data_calls, 2);
  EXPECT_EQ(encoding_buffer.toString(), "AB");

  Http::TestResponseTrailerMapImpl response_trailers{{"x-test-trailer", "test trailer"}};

  EXPECT_EQ(Http::FilterTrailersStatus::StopIteration, filter_->encodeTrailers(response_trailers));
  EXPECT_EQ(invocations.on_response_trailers_calls, 1);

  Event::PostCb resume_post_cb;
  EXPECT_CALL(dispatcher_, post(_)).WillOnce([&resume_post_cb](Event::PostCb cb) {
    resume_post_cb = std::move(cb);
  });
  EXPECT_CALL(encoder_callbacks_, continueEncoding());
  filter_->resumeEncoding();
  resume_post_cb();
  EXPECT_EQ(invocations.on_resume_response_calls, 1);

  // Pending headers have been updated with the value from ResumeIteration.
  EXPECT_FALSE(response_headers.get(Http::LowerCaseString("x-async-resumed")).empty());
  EXPECT_EQ(
      response_headers.get(Http::LowerCaseString("x-async-resumed"))[0]->value().getStringView(),
      "Very Yes");

  // Buffer has been updated with value from ResumeIteration.
  EXPECT_EQ(encoding_buffer.toString(), "C");

  // Pending trailers have been updated with value from ResumeIteration.
  EXPECT_FALSE(response_trailers.get(Http::LowerCaseString("x-async-resumed")).empty());
  EXPECT_EQ(
      response_trailers.get(Http::LowerCaseString("x-async-resumed"))[0]->value().getStringView(),
      "yes");
}

TEST_F(PlatformBridgeFilterTest, StopOnRequestHeadersThenResumeOnResumeDecodingPassthrough) {
  envoy_http_filter platform_filter{};
  filter_invocations invocations{};
  platform_filter.static_context = &invocations;
  platform_filter.init_filter = [](const void* context) -> const void* {
    envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
    filter_invocations* invocations =
        static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
    invocations->init_filter_calls++;
    return invocations;
  };
  platform_filter.on_request_headers = [](envoy_headers c_headers, bool end_stream,
                                          envoy_stream_intel,
                                          const void* context) -> envoy_filter_headers_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    EXPECT_EQ(c_headers.length, 1);
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].key), ":authority");
    EXPECT_EQ(Data::Utility::copyToString(c_headers.entries[0].value), "test.code");
    EXPECT_FALSE(end_stream);
    invocations->on_request_headers_calls++;
    release_envoy_headers(c_headers);
    return {kEnvoyFilterHeadersStatusStopIteration, envoy_noheaders};
  };
  platform_filter.on_resume_request = [](envoy_headers* pending_headers, envoy_data*,
                                         envoy_headers*, bool, envoy_stream_intel,
                                         const void* context) -> envoy_filter_resume_status {
    filter_invocations* invocations = static_cast<filter_invocations*>(const_cast<void*>(context));
    invocations->on_resume_request_calls++;
    return {kEnvoyFilterResumeStatusResumeIteration, pending_headers, nullptr, nullptr};
  };

  setUpFilter("StopOnRequestHeadersThenResumeOnResumeDecoding", &platform_filter);
  EXPECT_EQ(invocations.init_filter_calls, 1);

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, false));
  EXPECT_EQ(invocations.on_request_headers_calls, 1);

  Event::PostCb resume_post_cb;
  EXPECT_CALL(dispatcher_, post(_)).WillOnce([&resume_post_cb](Event::PostCb cb) {
    resume_post_cb = std::move(cb);
  });
  EXPECT_CALL(decoder_callbacks_, continueDecoding());
  filter_->resumeDecoding();
  resume_post_cb();
  EXPECT_EQ(invocations.on_resume_request_calls, 1);
}

} // namespace
} // namespace PlatformBridge
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "source/common/http/header_map_impl.h"

#include "test/integration/http_integration.h"
#include "test/test_common/utility.h"

#include "gtest/gtest.h"
#include "library/common/api/external.h"
#include "library/common/extensions/filters/http/platform_bridge/filter.h"

namespace Envoy {

class PlatformBridgeIntegrationTest : public testing::TestWithParam<Network::Address::IpVersion>,
                                      public HttpIntegrationTest {
public:
  PlatformBridgeIntegrationTest()
      : HttpIntegrationTest(Http::CodecClient::Type::HTTP2, GetParam()) {}

  const std::string filter_config_1{R"EOF(
      name: envoy.filters.http.platform_bridge
      typed_config:
        "@type": type.googleapis.com/envoymobile.extensions.filters.http.platform_bridge.PlatformBridge
        platform_filter_name: filter_1
    )EOF"};

  const std::string filter_config_2{R"EOF(
      name: envoy.filters.http.platform_bridge
      typed_config:
        "@type": type.googleapis.com/envoymobile.extensions.filters.http.platform_bridge.PlatformBridge
        platform_filter_name: filter_2
    )EOF"};

  void customInit(envoy_http_filter* filter_1, envoy_http_filter* filter_2) {
    setDownstreamProtocol(Http::CodecClient::Type::HTTP2);
    setUpstreamProtocol(FakeHttpConnection::Type::HTTP2);

    Api::External::registerApi("filter_1", filter_1);
    Api::External::registerApi("filter_2", filter_2);

    config_helper_.addFilter(filter_config_1);
    config_helper_.addFilter(filter_config_2);

    HttpIntegrationTest::initialize();
    codec_client_ = makeHttpConnection(lookupPort("http"));
  }

  void TearDown() override {
    HttpIntegrationTest::cleanupUpstreamAndDownstream();
    codec_client_->close();
    codec_client_.reset();
  }

  typedef struct {
    unsigned int init_filter_calls;
    unsigned int on_request_headers_calls;
    unsigned int on_request_data_calls;
    unsigned int on_request_trailers_calls;
    unsigned int on_response_headers_calls;
    unsigned int on_response_data_calls;
    unsigned int on_response_trailers_calls;
    unsigned int set_request_callbacks_calls;
    unsigned int on_resume_request_calls;
    unsigned int set_response_callbacks_calls;
    unsigned int on_resume_response_calls;
    unsigned int release_filter_calls;
  } filter_invocations;
};

// INSTANTIATE_TEST_SUITE_P(IpVersions, PlatformBridgeIntegrationTest,
//                          testing::ValuesIn(TestEnvironment::getIpVersionsForTest()));

// TEST_P(PlatformBridgeIntegrationTest, MultipleFilters) {
//   envoy_http_filter platform_filter_1{};
//   filter_invocations invocations_1{};
//   platform_filter_1.static_context = &invocations_1;
//   platform_filter_1.init_filter = [](const void* context) -> const void* {
//     envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
//     filter_invocations* invocations =
//         static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
//     invocations->init_filter_calls++;
//     return invocations;
//   };
//   platform_filter_1.on_response_data = [](envoy_data c_data, bool,
//                                           const void* context) -> envoy_filter_data_status {
//     filter_invocations* invocations =
//     static_cast<filter_invocations*>(const_cast<void*>(context));
//     invocations->on_response_data_calls++;
//     return {kEnvoyFilterDataStatusContinue, c_data, nullptr};
//   };
//   platform_filter_1.release_filter = [](const void*) {};

//   envoy_http_filter platform_filter_2{};
//   filter_invocations invocations_2{};
//   platform_filter_2.static_context = &invocations_2;
//   platform_filter_2.init_filter = [](const void* context) -> const void* {
//     envoy_http_filter* c_filter = static_cast<envoy_http_filter*>(const_cast<void*>(context));
//     filter_invocations* invocations =
//         static_cast<filter_invocations*>(const_cast<void*>(c_filter->static_context));
//     invocations->init_filter_calls++;
//     return invocations;
//   };
//   platform_filter_2.on_response_data = [](envoy_data c_data, bool end_stream,
//                                           const void* context) -> envoy_filter_data_status {
//     filter_invocations* invocations =
//     static_cast<filter_invocations*>(const_cast<void*>(context));
//     invocations->on_response_data_calls++;
//     if (!end_stream) {
//       release_envoy_data(c_data);
//       return {kEnvoyFilterDataStatusStopIterationAndBuffer, envoy_nodata, nullptr};
//     } else {
//       return {kEnvoyFilterDataStatusResumeIteration, c_data, nullptr};
//     }
//   };
//   platform_filter_2.release_filter = [](const void*) {};

//   customInit(&platform_filter_1, &platform_filter_2);

//   auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);

//   // Wait for frames to arrive upstream.
//   ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_,
//   fake_upstream_connection_));
//   ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));
//   ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));

//   upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{":status", "200"}}, false);

//   upstream_request_->encodeData(100, false);
//   upstream_request_->encodeData(100, true);

//   // Wait for frames to arrive downstream.
//   ASSERT_TRUE(response->waitForEndStream());

//   EXPECT_TRUE(response->complete());
//   EXPECT_EQ("200", response->headers().Status()->value().getStringView());
// }

} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load(
    "@envoy//test/extensions:extensions_build_system.bzl",
    "envoy_extension_cc_test",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_extension_cc_test(
    name = "platform_bridge_filter_test",
    srcs = ["platform_bridge_filter_test.cc"],
    extension_names = ["envoy.filters.http.platform_bridge"],
    repository = "@envoy",
    deps = [
        "//library/common/api:external_api_lib",
        "//library/common/data:utility_lib",
        "//library/common/extensions/filters/http/platform_bridge:config",
        "//library/common/extensions/filters/http/platform_bridge:filter_cc_proto",
        "@envoy//test/mocks/event:event_mocks",
        "@envoy//test/mocks/http:http_mocks",
        "@envoy//test/mocks/server:factory_context_mocks",
        "@envoy//test/test_common:utility_lib",
    ],
)

envoy_extension_cc_test(
    name = "platform_bridge_filter_integration_test",
    srcs = [
        "platform_bridge_filter_integration_test.cc",
    ],
    extension_names = ["envoy.filters.http.platform_bridge"],
    repository = "@envoy",
    deps = [
        "//library/common/api:external_api_lib",
        "//library/common/extensions/filters/http/platform_bridge:config",
        "//library/common/extensions/filters/http/platform_bridge:filter_cc_proto",
        "@envoy//test/integration:http_integration_lib",
        "@envoy//test/mocks/server:factory_context_mocks",
        "@envoy//test/test_common:simulated_time_system_lib",
        "@envoy//test/test_common:utility_lib",
    ],
)
#include "envoy/registry/registry.h"
#include "envoy/upstream/retry.h"

#include "source/common/upstream/retry_factory.h"

#include "test/mocks/server/factory_context.h"
#include "test/mocks/stream_info/mocks.h"

#include "extension_registry.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "library/common/extensions/retry/options/network_configuration/config.h"
#include "library/common/network/connectivity_manager.h"

using namespace testing;

namespace Envoy {
namespace Extensions {
namespace Retry {
namespace Options {
namespace {

TEST(NetworkConfigurationRetryOptionsPredicateTest, PredicateTest) {
  ExtensionRegistry::registerFactories();
  NiceMock<Server::Configuration::MockFactoryContext> mock_factory_context;
  NiceMock<Envoy::StreamInfo::MockStreamInfo> mock_stream_info;
  Upstream::RetryExtensionFactoryContextImpl retry_extension_factory_context{
      *mock_factory_context.server_factory_context_.singleton_manager_};

  auto connectivity_manager = Network::ConnectivityManagerFactory(mock_factory_context).get();
  ASSERT_NE(nullptr, connectivity_manager);

  auto factory = Registry::FactoryRegistry<Upstream::RetryOptionsPredicateFactory>::getFactory(
      "envoy.retry_options_predicates.network_configuration");
  ASSERT_NE(nullptr, factory);

  auto proto_config = factory->createEmptyConfigProto();
  auto predicate = factory->createOptionsPredicate(*proto_config, retry_extension_factory_context);

  ASSERT_EQ(absl::nullopt,
            predicate->updateOptions({mock_stream_info, nullptr}).new_upstream_socket_options_);
}

TEST(NetworkConfigurationRetryOptionsPredicateTest, PredicateTestWithoutConnectivityManager) {
  ExtensionRegistry::registerFactories();
  NiceMock<Server::Configuration::MockFactoryContext> mock_factory_context;
  Upstream::RetryExtensionFactoryContextImpl retry_extension_factory_context{
      *mock_factory_context.server_factory_context_.singleton_manager_};

  auto factory = Registry::FactoryRegistry<Upstream::RetryOptionsPredicateFactory>::getFactory(
      "envoy.retry_options_predicates.network_configuration");
  ASSERT_NE(nullptr, factory);

  auto proto_config = factory->createEmptyConfigProto();
  EXPECT_DEATH(factory->createOptionsPredicate(*proto_config, retry_extension_factory_context),
               "unexpected nullptr network connectivity_manager");
}

} // namespace
} // namespace Options
} // namespace Retry
} // namespace Extensions
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load(
    "@envoy//test/extensions:extensions_build_system.bzl",
    "envoy_extension_cc_test",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_extension_cc_test(
    name = "network_configuration_retry_options_test",
    srcs = ["predicate_test.cc"],
    extension_names = ["envoy.retry.options.network_configuration"],
    repository = "@envoy",
    deps = [
        "//library/common/extensions/retry/options/network_configuration:config",
        "//library/common/network:connectivity_manager_lib",
        "@envoy//source/common/upstream:retry_factory_lib",
        "@envoy//test/mocks/server:factory_context_mocks",
        "@envoy//test/mocks/stream_info:stream_info_mocks",
        "@envoy_build_config//:extension_registry",
    ],
)
#include <memory>
#include <string>

#include "source/common/buffer/buffer_impl.h"
#include "source/common/crypto/crypto_impl.h"
#include "source/common/crypto/utility.h"
#include "source/common/network/transport_socket_options_impl.h"
#include "source/extensions/transport_sockets/tls/cert_validator/default_validator.h"
#include "source/extensions/transport_sockets/tls/cert_validator/san_matcher.h"
#include "source/extensions/transport_sockets/tls/stats.h"

#include "test/common/mocks/common/mocks.h"
#include "test/common/stats/stat_test_utility.h"
#include "test/extensions/transport_sockets/tls/cert_validator/test_common.h"
#include "test/extensions/transport_sockets/tls/ssl_test_utility.h"
#include "test/extensions/transport_sockets/tls/test_data/san_dns2_cert_info.h"
#include "test/mocks/event/mocks.h"
#include "test/mocks/ssl/mocks.h"
#include "test/test_common/environment.h"
#include "test/test_common/test_runtime.h"
#include "test/test_common/utility.h"

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "library/common/data/utility.h"
#include "library/common/extensions/cert_validator/platform_bridge/config.h"
#include "openssl/ssl.h"
#include "openssl/x509v3.h"

using SSLContextPtr = Envoy::CSmartPtr<SSL_CTX, SSL_CTX_free>;

using envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext;

using testing::_;
using testing::NiceMock;
using testing::Return;
using testing::ReturnRef;
using testing::StrEq;
using testing::WithArgs;

namespace Envoy {
namespace Extensions {
namespace TransportSockets {
namespace Tls {

class MockValidateResultCallback : public Ssl::ValidateResultCallback {
public:
  ~MockValidateResultCallback() override = default;

  MOCK_METHOD(Event::Dispatcher&, dispatcher, ());
  MOCK_METHOD(void, onCertValidationResult,
              (bool, Envoy::Ssl::ClientValidationStatus, const std::string&, uint8_t));
};

class MockValidator {
public:
  MOCK_METHOD(void, cleanup, ());
  MOCK_METHOD(envoy_cert_validation_result, validate,
              (const std::vector<std::string>& certs, absl::string_view hostname));
};

class PlatformBridgeCertValidatorTest
    : public testing::TestWithParam<CertificateValidationContext::TrustChainVerification> {
protected:
  PlatformBridgeCertValidatorTest()
      : api_(Api::createApiForTest()), dispatcher_(api_->allocateDispatcher("test_thread")),
        stats_(generateSslStats(*test_store_.rootScope())), ssl_ctx_(SSL_CTX_new(TLS_method())),
        callback_(std::make_unique<MockValidateResultCallback>()), is_server_(false),
        mock_validator_(std::make_unique<MockValidator>()),
        main_thread_id_(std::this_thread::get_id()),
        helper_handle_(test::SystemHelperPeer::replaceSystemHelper()) {
    ON_CALL(helper_handle_->mock_helper(), validateCertificateChain(_, _))
        .WillByDefault(WithArgs<0, 1>(Invoke(this, &PlatformBridgeCertValidatorTest::validate)));
    ON_CALL(helper_handle_->mock_helper(), cleanupAfterCertificateValidation())
        .WillByDefault(Invoke(this, &PlatformBridgeCertValidatorTest::cleanup));

    EXPECT_CALL(helper_handle_->mock_helper(), isCleartextPermitted(_))
        .WillRepeatedly(Return(true));
  }

  void initializeConfig() {
    EXPECT_CALL(config_, caCert()).WillOnce(ReturnRef(empty_string_));
    EXPECT_CALL(config_, certificateRevocationList()).WillOnce(ReturnRef(empty_string_));
    EXPECT_CALL(config_, trustChainVerification()).WillOnce(Return(GetParam()));
  }

  ~PlatformBridgeCertValidatorTest() {
    mock_validator_.reset();
    main_thread_id_ = std::thread::id();
    Envoy::Assert::resetEnvoyBugCountersForTest();
  }

  ABSL_MUST_USE_RESULT bool waitForDispatcherToExit() {
    Event::TimerPtr timer(dispatcher_->createTimer([this]() -> void { dispatcher_->exit(); }));
    timer->enableTimer(std::chrono::milliseconds(100));
    dispatcher_->run(Event::Dispatcher::RunType::RunUntilExit);
    return !timer->enabled();
  }

  bool acceptInvalidCertificates() {
    return GetParam() == CertificateValidationContext::ACCEPT_UNTRUSTED;
  }

  envoy_cert_validation_result validate(const std::vector<std::string>& certs,
                                        absl::string_view hostname) {
    // Validate must be called on the worker thread, not the main thread.
    EXPECT_NE(main_thread_id_, std::this_thread::get_id());

    // Make sure the cert was converted correctly.
    const Buffer::InstancePtr buffer(new Buffer::OwnedImpl(certs[0]));
    const auto digest = Common::Crypto::UtilitySingleton::get().getSha256Digest(*buffer);
    EXPECT_EQ(TEST_SAN_DNS2_CERT_256_HASH, Hex::encode(digest));
    return mock_validator_->validate(certs, hostname);
  }

  void cleanup() {
    // Validate must be called on the worker thread, not the main thread.
    EXPECT_NE(main_thread_id_, std::this_thread::get_id());
    mock_validator_->cleanup();
  }

  Api::ApiPtr api_;
  Event::DispatcherPtr dispatcher_;
  Stats::TestUtil::TestStore test_store_;
  SslStats stats_;
  Ssl::MockCertificateValidationContextConfig config_;
  std::string empty_string_;
  SSLContextPtr ssl_ctx_;
  CertValidator::ExtraValidationContext validation_context_;
  Network::TransportSocketOptionsConstSharedPtr transport_socket_options_;
  std::unique_ptr<MockValidateResultCallback> callback_;
  bool is_server_;
  std::unique_ptr<MockValidator> mock_validator_;
  std::thread::id main_thread_id_;
  std::unique_ptr<test::SystemHelperPeer::Handle> helper_handle_;
};

INSTANTIATE_TEST_SUITE_P(TrustMode, PlatformBridgeCertValidatorTest,
                         testing::ValuesIn({CertificateValidationContext::VERIFY_TRUST_CHAIN,
                                            CertificateValidationContext::ACCEPT_UNTRUSTED}));

TEST_P(PlatformBridgeCertValidatorTest, NoConfig) {
  EXPECT_ENVOY_BUG({ PlatformBridgeCertValidator validator(nullptr, stats_); },
                   "Invalid certificate validation context config.");
}

TEST_P(PlatformBridgeCertValidatorTest, NonEmptyCaCert) {
  std::string ca_cert = "xyz";
  EXPECT_CALL(config_, caCert()).WillRepeatedly(ReturnRef(ca_cert));
  EXPECT_CALL(config_, certificateRevocationList()).WillRepeatedly(ReturnRef(empty_string_));
  EXPECT_CALL(config_, trustChainVerification()).WillRepeatedly(Return(GetParam()));

  EXPECT_ENVOY_BUG({ PlatformBridgeCertValidator validator(&config_, stats_); },
                   "Invalid certificate validation context config.");
}

TEST_P(PlatformBridgeCertValidatorTest, NonEmptyRevocationList) {
  std::string revocation_list = "xyz";
  EXPECT_CALL(config_, caCert()).WillRepeatedly(ReturnRef(empty_string_));
  EXPECT_CALL(config_, certificateRevocationList()).WillRepeatedly(ReturnRef(revocation_list));
  EXPECT_CALL(config_, trustChainVerification()).WillRepeatedly(Return(GetParam()));

  EXPECT_ENVOY_BUG({ PlatformBridgeCertValidator validator(&config_, stats_); },
                   "Invalid certificate validation context config.");
}

TEST_P(PlatformBridgeCertValidatorTest, NoCallback) {
  initializeConfig();
  PlatformBridgeCertValidator validator(&config_, stats_);

  bssl::UniquePtr<STACK_OF(X509)> cert_chain = readCertChainFromFile(TestEnvironment::substitute(
      "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_cert.pem"));
  std::string hostname = "www.example.com";

  EXPECT_ENVOY_BUG(
      {
        validator.doVerifyCertChain(*cert_chain, Ssl::ValidateResultCallbackPtr(),
                                    transport_socket_options_, *ssl_ctx_, validation_context_,
                                    is_server_, hostname);
      },
      "No callback specified");
}

TEST_P(PlatformBridgeCertValidatorTest, EmptyCertChain) {
  initializeConfig();
  PlatformBridgeCertValidator validator(&config_, stats_);

  bssl::UniquePtr<STACK_OF(X509)> cert_chain(sk_X509_new_null());
  std::string hostname = "www.example.com";

  ValidationResults results =
      validator.doVerifyCertChain(*cert_chain, std::move(callback_), transport_socket_options_,
                                  *ssl_ctx_, validation_context_, is_server_, hostname);
  EXPECT_EQ(ValidationResults::ValidationStatus::Failed, results.status);
  EXPECT_FALSE(results.tls_alert.has_value());
  ASSERT_TRUE(results.error_details.has_value());
  EXPECT_EQ("verify cert chain failed: empty cert chain.", results.error_details.value());
  EXPECT_EQ(Envoy::Ssl::ClientValidationStatus::NotValidated, results.detailed_status);
}

TEST_P(PlatformBridgeCertValidatorTest, ValidCertificate) {
  EXPECT_CALL(helper_handle_->mock_helper(), cleanupAfterCertificateValidation());
  EXPECT_CALL(helper_handle_->mock_helper(), validateCertificateChain(_, _));

  initializeConfig();
  PlatformBridgeCertValidator validator(&config_, stats_);

  std::string hostname = "server1.example.com";
  bssl::UniquePtr<STACK_OF(X509)> cert_chain = readCertChainFromFile(TestEnvironment::substitute(
      "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_cert.pem"));
  envoy_cert_validation_result result = {ENVOY_SUCCESS, 0, NULL};
  EXPECT_CALL(*mock_validator_, validate(_, _)).WillOnce(Return(result));
  EXPECT_CALL(*mock_validator_, cleanup());
  auto& callback_ref = *callback_;
  EXPECT_CALL(callback_ref, dispatcher()).WillRepeatedly(ReturnRef(*dispatcher_));

  ValidationResults results =
      validator.doVerifyCertChain(*cert_chain, std::move(callback_), transport_socket_options_,
                                  *ssl_ctx_, validation_context_, is_server_, hostname);
  EXPECT_EQ(ValidationResults::ValidationStatus::Pending, results.status);

  EXPECT_CALL(callback_ref,
              onCertValidationResult(true, Envoy::Ssl::ClientValidationStatus::Validated, "", 46))
      .WillOnce(Invoke([this]() {
        EXPECT_EQ(main_thread_id_, std::this_thread::get_id());
        dispatcher_->exit();
      }));
  EXPECT_FALSE(waitForDispatcherToExit());
}

TEST_P(PlatformBridgeCertValidatorTest, ValidCertificateEmptySanOverrides) {
  EXPECT_CALL(helper_handle_->mock_helper(), cleanupAfterCertificateValidation());
  EXPECT_CALL(helper_handle_->mock_helper(), validateCertificateChain(_, _));

  initializeConfig();
  PlatformBridgeCertValidator validator(&config_, stats_);

  std::string hostname = "server1.example.com";
  bssl::UniquePtr<STACK_OF(X509)> cert_chain = readCertChainFromFile(TestEnvironment::substitute(
      "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_cert.pem"));
  envoy_cert_validation_result result = {ENVOY_SUCCESS, 0, NULL};
  EXPECT_CALL(*mock_validator_, validate(_, _)).WillOnce(Return(result));
  EXPECT_CALL(*mock_validator_, cleanup());
  auto& callback_ref = *callback_;
  EXPECT_CALL(callback_ref, dispatcher()).WillRepeatedly(ReturnRef(*dispatcher_));

  // Set up transport socket options with an empty SAN list.
  std::vector<std::string> subject_alt_names;
  transport_socket_options_ =
      std::make_shared<Network::TransportSocketOptionsImpl>("", std::move(subject_alt_names));

  ValidationResults results =
      validator.doVerifyCertChain(*cert_chain, std::move(callback_), transport_socket_options_,
                                  *ssl_ctx_, validation_context_, is_server_, hostname);
  EXPECT_EQ(ValidationResults::ValidationStatus::Pending, results.status);

  EXPECT_CALL(callback_ref,
              onCertValidationResult(true, Envoy::Ssl::ClientValidationStatus::Validated, "", 46))
      .WillOnce(Invoke([this]() {
        EXPECT_EQ(main_thread_id_, std::this_thread::get_id());
        dispatcher_->exit();
      }));
  EXPECT_FALSE(waitForDispatcherToExit());
}

TEST_P(PlatformBridgeCertValidatorTest, ValidCertificateEmptyHostNoOverrides) {
  EXPECT_CALL(helper_handle_->mock_helper(), cleanupAfterCertificateValidation());
  EXPECT_CALL(helper_handle_->mock_helper(), validateCertificateChain(_, _));

  initializeConfig();
  PlatformBridgeCertValidator validator(&config_, stats_);

  std::string hostname = "";
  bssl::UniquePtr<STACK_OF(X509)> cert_chain = readCertChainFromFile(TestEnvironment::substitute(
      "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_cert.pem"));
  envoy_cert_validation_result result = {ENVOY_SUCCESS, 0, NULL};
  EXPECT_CALL(*mock_validator_, validate(_, _)).WillOnce(Return(result));
  EXPECT_CALL(*mock_validator_, cleanup());
  auto& callback_ref = *callback_;
  EXPECT_CALL(callback_ref, dispatcher()).WillRepeatedly(ReturnRef(*dispatcher_));

  // Set up transport socket options with an empty SAN list.
  std::vector<std::string> subject_alt_names;
  transport_socket_options_ =
      std::make_shared<Network::TransportSocketOptionsImpl>("", std::move(subject_alt_names));

  ValidationResults results =
      validator.doVerifyCertChain(*cert_chain, std::move(callback_), transport_socket_options_,
                                  *ssl_ctx_, validation_context_, is_server_, hostname);
  EXPECT_EQ(ValidationResults::ValidationStatus::Pending, results.status);

  EXPECT_CALL(callback_ref,
              onCertValidationResult(true, Envoy::Ssl::ClientValidationStatus::Validated, "", 46))
      .WillOnce(Invoke([this]() {
        EXPECT_EQ(main_thread_id_, std::this_thread::get_id());
        dispatcher_->exit();
      }));
  EXPECT_FALSE(waitForDispatcherToExit());
}

TEST_P(PlatformBridgeCertValidatorTest, ValidCertificateButInvalidSni) {
  EXPECT_CALL(helper_handle_->mock_helper(), cleanupAfterCertificateValidation());
  EXPECT_CALL(helper_handle_->mock_helper(), validateCertificateChain(_, _));

  initializeConfig();
  PlatformBridgeCertValidator validator(&config_, stats_);

  std::string hostname = "server2.example.com";
  bssl::UniquePtr<STACK_OF(X509)> cert_chain = readCertChainFromFile(TestEnvironment::substitute(
      "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_cert.pem"));
  envoy_cert_validation_result result = {ENVOY_SUCCESS, 0, NULL};
  EXPECT_CALL(*mock_validator_, validate(_, _)).WillOnce(Return(result));
  EXPECT_CALL(*mock_validator_, cleanup());
  auto& callback_ref = *callback_;
  EXPECT_CALL(callback_ref, dispatcher()).WillRepeatedly(ReturnRef(*dispatcher_));

  ValidationResults results =
      validator.doVerifyCertChain(*cert_chain, std::move(callback_), transport_socket_options_,
                                  *ssl_ctx_, validation_context_, is_server_, hostname);
  EXPECT_EQ(ValidationResults::ValidationStatus::Pending, results.status);

  EXPECT_CALL(callback_ref,
              onCertValidationResult(
                  acceptInvalidCertificates(), Envoy::Ssl::ClientValidationStatus::Failed,
                  "PlatformBridgeCertValidator_verifySubjectAltName failed: SNI mismatch.",
                  SSL_AD_BAD_CERTIFICATE))
      .WillOnce(Invoke([this]() { dispatcher_->exit(); }));
  EXPECT_FALSE(waitForDispatcherToExit());
}

TEST_P(PlatformBridgeCertValidatorTest, ValidCertificateSniOverride) {
  EXPECT_CALL(helper_handle_->mock_helper(), cleanupAfterCertificateValidation());
  EXPECT_CALL(helper_handle_->mock_helper(), validateCertificateChain(_, _));

  initializeConfig();
  PlatformBridgeCertValidator validator(&config_, stats_);

  std::vector<std::string> subject_alt_names = {"server1.example.com"};

  std::string hostname = "server2.example.com";
  bssl::UniquePtr<STACK_OF(X509)> cert_chain = readCertChainFromFile(TestEnvironment::substitute(
      "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_cert.pem"));
  envoy_cert_validation_result result = {ENVOY_SUCCESS, 0, NULL};
  EXPECT_CALL(*mock_validator_, validate(_, StrEq(subject_alt_names[0].c_str())))
      .WillOnce(Return(result));
  EXPECT_CALL(*mock_validator_, cleanup());
  auto& callback_ref = *callback_;
  EXPECT_CALL(callback_ref, dispatcher()).WillRepeatedly(ReturnRef(*dispatcher_));
  transport_socket_options_ =
      std::make_shared<Network::TransportSocketOptionsImpl>("", std::move(subject_alt_names));

  ValidationResults results =
      validator.doVerifyCertChain(*cert_chain, std::move(callback_), transport_socket_options_,
                                  *ssl_ctx_, validation_context_, is_server_, hostname);
  EXPECT_EQ(ValidationResults::ValidationStatus::Pending, results.status);

  // The cert will be validated against the overridden name not the invalid name "server2".
  EXPECT_CALL(callback_ref,
              onCertValidationResult(true, Envoy::Ssl::ClientValidationStatus::Validated, "", 46))
      .WillOnce(Invoke([this]() { dispatcher_->exit(); }));
  EXPECT_FALSE(waitForDispatcherToExit());
}

TEST_P(PlatformBridgeCertValidatorTest, DeletedWithValidationPending) {
  EXPECT_CALL(helper_handle_->mock_helper(), cleanupAfterCertificateValidation());
  EXPECT_CALL(helper_handle_->mock_helper(), validateCertificateChain(_, _));

  initializeConfig();
  auto validator = std::make_unique<PlatformBridgeCertValidator>(&config_, stats_);

  std::string hostname = "server1.example.com";
  bssl::UniquePtr<STACK_OF(X509)> cert_chain = readCertChainFromFile(TestEnvironment::substitute(
      "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_cert.pem"));
  envoy_cert_validation_result result = {ENVOY_SUCCESS, 0, NULL};
  EXPECT_CALL(*mock_validator_, validate(_, _)).WillOnce(Return(result));
  EXPECT_CALL(*mock_validator_, cleanup());
  auto& callback_ref = *callback_;
  EXPECT_CALL(callback_ref, dispatcher()).WillRepeatedly(ReturnRef(*dispatcher_));

  ValidationResults results =
      validator->doVerifyCertChain(*cert_chain, std::move(callback_), transport_socket_options_,
                                   *ssl_ctx_, validation_context_, is_server_, hostname);
  EXPECT_EQ(ValidationResults::ValidationStatus::Pending, results.status);

  validator.reset();

  // Since the validator was deleted, the callback should not be invoked and
  // so the dispatcher will not exit until the alarm fires.
  EXPECT_TRUE(waitForDispatcherToExit());
}

} // namespace Tls
} // namespace TransportSockets
} // namespace Extensions
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load(
    "@envoy//test/extensions:extensions_build_system.bzl",
    "envoy_extension_cc_test",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_extension_cc_test(
    name = "platform_bridge_cert_validator_test",
    srcs = ["platform_bridge_cert_validator_test.cc"],
    data = [
        "@envoy//test/extensions/transport_sockets/tls/test_data:certs",
    ],
    extension_names = ["envoy_mobile.cert_validator.platform_bridge_cert_validator"],
    repository = "@envoy",
    deps = [
        "//library/common/extensions/cert_validator/platform_bridge:config",
        "//test/common/mocks/common:common_mocks",
        "@envoy//source/extensions/transport_sockets/tls/cert_validator:cert_validator_lib",
        "@envoy//test/extensions/transport_sockets/tls:ssl_test_utils",
        "@envoy//test/extensions/transport_sockets/tls/cert_validator:test_common",
        "@envoy//test/extensions/transport_sockets/tls/test_data:cert_infos",
        "@envoy//test/mocks/event:event_mocks",
        "@envoy//test/mocks/ssl:ssl_mocks",
        "@envoy//test/test_common:environment_lib",
        "@envoy//test/test_common:file_system_for_test_lib",
        "@envoy//test/test_common:test_runtime_lib",
    ],
)
#include "envoy/config/bootstrap/v3/bootstrap.pb.h"

#include "source/common/grpc/codec.h"
#include "source/common/grpc/common.h"
#include "source/common/stats/histogram_impl.h"

#include "test/integration/http_integration.h"

#include "gtest/gtest.h"
#include "library/common/extensions/stat_sinks/metrics_service/config.pb.h"
#include "library/common/extensions/stat_sinks/metrics_service/service.pb.h"

using testing::AssertionResult;

namespace Envoy {
namespace {

class EnvoyMobileMetricsServiceIntegrationTest
    : public Grpc::VersionedGrpcClientIntegrationParamTest,
      public HttpIntegrationTest {
public:
  EnvoyMobileMetricsServiceIntegrationTest()
      : HttpIntegrationTest(Http::CodecClient::Type::HTTP1, ipVersion()) {}

  void createUpstreams() override {
    HttpIntegrationTest::createUpstreams();
    addFakeUpstream(FakeHttpConnection::Type::HTTP2);
  }

  void initialize() override {
    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
      // metrics_service cluster for Envoy gRPC.
      auto* metrics_service_cluster = bootstrap.mutable_static_resources()->add_clusters();
      metrics_service_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);
      metrics_service_cluster->set_name("metrics_service");
      metrics_service_cluster->mutable_http2_protocol_options();
      // metrics_service gRPC service definition.
      auto* metrics_sink = bootstrap.add_stats_sinks();
      metrics_sink->set_name("envoy.stat_sinks.metrics_service.mobile");
      envoymobile::extensions::stat_sinks::metrics_service::EnvoyMobileMetricsServiceConfig config;
      setGrpcService(*config.mutable_grpc_service(), "metrics_service",
                     fake_upstreams_.back()->localAddress());
      metrics_sink->mutable_typed_config()->PackFrom(config);
      // Shrink reporting period down to 1s to make test not take forever.
      bootstrap.mutable_stats_flush_interval()->CopyFrom(
          Protobuf::util::TimeUtil::MillisecondsToDuration(100));
    });

    HttpIntegrationTest::initialize();
  }

  ABSL_MUST_USE_RESULT
  AssertionResult waitForMetricsServiceConnection() {
    return fake_upstreams_[1]->waitForHttpConnection(*dispatcher_,
                                                     fake_metrics_service_connection_);
  }

  ABSL_MUST_USE_RESULT
  AssertionResult waitForMetricsStream() {
    return fake_metrics_service_connection_->waitForNewStream(*dispatcher_,
                                                              metrics_service_request_);
  }

  ABSL_MUST_USE_RESULT
  AssertionResult waitForMetricsRequest() {
    bool known_summary_exists = false;
    bool known_histogram_exists = false;
    bool known_counter_exists = false;
    bool known_gauge_exists = false;

    // Sometimes stats do not come in the first flush cycle, this loop ensures that we wait till
    // required stats are flushed.
    // TODO(ramaraochavali): Figure out a more robust way to find out all required stats have been
    // flushed.
    while (!(known_counter_exists && known_gauge_exists && known_histogram_exists)) {
      envoymobile::extensions::stat_sinks::metrics_service::EnvoyMobileStreamMetricsMessage
          request_msg;
      VERIFY_ASSERTION(metrics_service_request_->waitForGrpcMessage(*dispatcher_, request_msg));
      EXPECT_EQ("POST", metrics_service_request_->headers().getMethodValue());
      EXPECT_EQ("/envoymobile.extensions.stat_sinks.metrics_service.EnvoyMobileMetricsService/"
                "EnvoyMobileStreamMetrics",
                metrics_service_request_->headers().getPathValue());
      EXPECT_EQ("application/grpc", metrics_service_request_->headers().getContentTypeValue());
      EXPECT_TRUE(request_msg.envoy_metrics_size() > 0);

      // batch_id should be set, and it's random, therefore verifying the size.
      EXPECT_TRUE(request_msg.batch_id().size() > 0);

      const Protobuf::RepeatedPtrField<::io::prometheus::client::MetricFamily>& envoy_metrics =
          request_msg.envoy_metrics();

      int64_t previous_time_stamp = 0;
      for (const ::io::prometheus::client::MetricFamily& metrics_family : envoy_metrics) {
        if (metrics_family.name() == "cluster.cluster_0.membership_change" &&
            metrics_family.type() == ::io::prometheus::client::MetricType::COUNTER) {
          known_counter_exists = true;
          EXPECT_EQ(1, metrics_family.metric(0).counter().value());
        }
        if (metrics_family.name() == "cluster.cluster_0.membership_total" &&
            metrics_family.type() == ::io::prometheus::client::MetricType::GAUGE) {
          known_gauge_exists = true;
          EXPECT_EQ(1, metrics_family.metric(0).gauge().value());
        }
        if (metrics_family.name() == "cluster.cluster_0.upstream_rq_time" &&
            metrics_family.type() == ::io::prometheus::client::MetricType::SUMMARY) {
          known_summary_exists = true;
          Stats::HistogramStatisticsImpl empty_statistics;
          EXPECT_EQ(metrics_family.metric(0).summary().quantile_size(),
                    empty_statistics.supportedQuantiles().size());
        }
        if (metrics_family.name() == "cluster.cluster_0.upstream_rq_time" &&
            metrics_family.type() == ::io::prometheus::client::MetricType::HISTOGRAM) {
          known_histogram_exists = true;
          EXPECT_EQ(metrics_family.metric(0).histogram().bucket_size(),
                    Stats::HistogramSettingsImpl::defaultBuckets().size());
        }
        ASSERT(metrics_family.metric(0).has_timestamp_ms());
        // Validate that all metrics have the same timestamp.
        if (previous_time_stamp > 0) {
          EXPECT_EQ(previous_time_stamp, metrics_family.metric(0).timestamp_ms());
        }
        previous_time_stamp = metrics_family.metric(0).timestamp_ms();
        if (known_counter_exists && known_gauge_exists && known_histogram_exists) {
          break;
        }
      }
    }
    EXPECT_TRUE(known_counter_exists);
    EXPECT_TRUE(known_gauge_exists);
    EXPECT_TRUE(known_summary_exists);
    EXPECT_TRUE(known_histogram_exists);

    return AssertionSuccess();
  }

  void cleanup() {
    if (fake_metrics_service_connection_ != nullptr) {
      AssertionResult result = fake_metrics_service_connection_->close();
      RELEASE_ASSERT(result, result.message());
      result = fake_metrics_service_connection_->waitForDisconnect();
      RELEASE_ASSERT(result, result.message());
    }
  }

  FakeHttpConnectionPtr fake_metrics_service_connection_;
  FakeStreamPtr metrics_service_request_;
};

INSTANTIATE_TEST_SUITE_P(IpVersionsClientType, EnvoyMobileMetricsServiceIntegrationTest,
                         VERSIONED_GRPC_CLIENT_INTEGRATION_PARAMS);

// Test a basic metric service flow.
TEST_P(EnvoyMobileMetricsServiceIntegrationTest, BasicFlow) {
  initialize();
  // Send an empty request so that histogram values merged for cluster_0.
  codec_client_ = makeHttpConnection(makeClientConnection(lookupPort("http")));
  Http::TestRequestHeaderMapImpl request_headers{{":method", "GET"},
                                                 {":path", "/test/long/url"},
                                                 {":scheme", "http"},
                                                 {":authority", "host"},
                                                 {"x-lyft-user-id", "123"}};
  sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);

  ASSERT_TRUE(waitForMetricsServiceConnection());
  ASSERT_TRUE(waitForMetricsStream());
  ASSERT_TRUE(waitForMetricsRequest());

  // Send a response with bath_id set and then end the stream.
  // This should never happen but make sure nothing breaks and we make a new stream on a follow up
  // request.
  metrics_service_request_->startGrpcStream();
  envoymobile::extensions::stat_sinks::metrics_service::EnvoyMobileStreamMetricsResponse
      response_msg;
  response_msg.set_batch_id("mock-batch-id");
  metrics_service_request_->sendGrpcMessage(response_msg);
  metrics_service_request_->finishGrpcStream(Grpc::Status::Ok);

  // response_msg arrived with the set batch_id.
  EXPECT_EQ("mock-batch-id", response_msg.batch_id());

  switch (clientType()) {
  case Grpc::ClientType::EnvoyGrpc:
    test_server_->waitForGaugeEq("cluster.metrics_service.upstream_rq_active", 0);
    break;
  case Grpc::ClientType::GoogleGrpc:
    test_server_->waitForCounterGe("grpc.metrics_service.streams_closed_0", 1);
    break;
  default:
    PANIC("not implemented");
  }
  cleanup();
}

} // namespace
} // namespace Envoy
#include "source/extensions/stat_sinks/metrics_service/grpc_metrics_service_impl.h"

#include "test/mocks/common.h"
#include "test/mocks/grpc/mocks.h"
#include "test/mocks/local_info/mocks.h"
#include "test/mocks/stats/mocks.h"
#include "test/mocks/thread_local/mocks.h"
#include "test/test_common/logging.h"
#include "test/test_common/simulated_time_system.h"

#include "library/common/extensions/stat_sinks/metrics_service/mobile_grpc_streamer.h"
#include "library/common/extensions/stat_sinks/metrics_service/service.pb.h"

using testing::_;
using testing::InSequence;
using testing::Invoke;
using testing::NiceMock;

namespace Envoy {
namespace Extensions {
namespace StatSinks {
namespace EnvoyMobileMetricsService {
namespace {

class EnvoyMobileGrpcMetricsStreamerImplTest : public testing::Test {
public:
  using MockMetricsStream = Grpc::MockAsyncStream;
  using MetricsServiceCallbacks = Grpc::AsyncStreamCallbacks<
      envoymobile::extensions::stat_sinks::metrics_service::EnvoyMobileStreamMetricsResponse>;

  EnvoyMobileGrpcMetricsStreamerImplTest() {
    EXPECT_CALL(*factory_, create()).WillOnce(Invoke([this] {
      return Grpc::RawAsyncClientPtr{async_client_};
    }));

    streamer_ = std::make_unique<EnvoyMobileGrpcMetricsStreamerImpl>(
        Grpc::AsyncClientFactoryPtr{factory_}, local_info_, random_generator);
  }

  void expectStreamStart(MockMetricsStream& stream, MetricsServiceCallbacks** callbacks_to_set) {
    EXPECT_CALL(*async_client_, startRaw(_, _, _, _))
        .WillOnce(Invoke([&stream, callbacks_to_set](absl::string_view, absl::string_view,
                                                     Grpc::RawAsyncStreamCallbacks& callbacks,
                                                     const Http::AsyncClient::StreamOptions&) {
          *callbacks_to_set = dynamic_cast<MetricsServiceCallbacks*>(&callbacks);
          return &stream;
        }));
  }

  NiceMock<Random::MockRandomGenerator> random_generator;
  LocalInfo::MockLocalInfo local_info_;
  Grpc::MockAsyncClient* async_client_{new NiceMock<Grpc::MockAsyncClient>};
  Grpc::MockAsyncClientFactory* factory_{new Grpc::MockAsyncClientFactory};
  EnvoyMobileGrpcMetricsStreamerImplPtr streamer_;
};

// Test basic metrics streaming flow.
TEST_F(EnvoyMobileGrpcMetricsStreamerImplTest, BasicFlow) {
  InSequence s;

  // Start a stream and send first message.

  MockMetricsStream stream1;
  MetricsServiceCallbacks* callbacks1;
  expectStreamStart(stream1, &callbacks1);
  EXPECT_CALL(local_info_, node());
  EXPECT_CALL(stream1, sendMessageRaw_(_, false));

  auto metrics =
      std::make_unique<Envoy::Protobuf::RepeatedPtrField<io::prometheus::client::MetricFamily>>();

  streamer_->send(std::move(metrics));
  // Verify that sending an empty response message doesn't do anything bad.
  callbacks1->onReceiveMessage(
      std::make_unique<envoymobile::extensions::stat_sinks::metrics_service::
                           EnvoyMobileStreamMetricsResponse>());
}

// Test response is received.
TEST_F(EnvoyMobileGrpcMetricsStreamerImplTest, WithResponse) {
  InSequence s;

  // Start a stream and send first message.
  MockMetricsStream stream1;
  MetricsServiceCallbacks* callbacks1;
  expectStreamStart(stream1, &callbacks1);
  EXPECT_CALL(local_info_, node());
  EXPECT_CALL(stream1, sendMessageRaw_(_, false));

  auto metrics =
      std::make_unique<Envoy::Protobuf::RepeatedPtrField<io::prometheus::client::MetricFamily>>();

  streamer_->send(std::move(metrics));

  auto response = std::make_unique<
      envoymobile::extensions::stat_sinks::metrics_service::EnvoyMobileStreamMetricsResponse>();
  response->set_batch_id("mock-batch-id");

  // Verify that batch_id of the response message is logged.
  EXPECT_LOG_CONTAINS("debug", "EnvoyMobile streamer received batch_id: mock-batch-id",
                      callbacks1->onReceiveMessage(std::move(response)));
}

// Test that stream failure is handled correctly.
TEST_F(EnvoyMobileGrpcMetricsStreamerImplTest, StreamFailure) {
  InSequence s;

  EXPECT_CALL(*async_client_, startRaw(_, _, _, _))
      .WillOnce(
          Invoke([](absl::string_view, absl::string_view, Grpc::RawAsyncStreamCallbacks& callbacks,
                    const Http::AsyncClient::StreamOptions&) {
            callbacks.onRemoteClose(Grpc::Status::Internal, "bad");
            return nullptr;
          }));
  EXPECT_CALL(local_info_, node());
  auto metrics =
      std::make_unique<Envoy::Protobuf::RepeatedPtrField<io::prometheus::client::MetricFamily>>();
  streamer_->send(std::move(metrics));
}

class MockGrpcMetricsStreamer
    : MetricsService::GrpcMetricsStreamer<
          envoymobile::extensions::stat_sinks::metrics_service::EnvoyMobileStreamMetricsMessage,
          envoymobile::extensions::stat_sinks::metrics_service::EnvoyMobileStreamMetricsResponse> {
public:
  // GrpcMetricsStreamer
  MOCK_METHOD(void, send, (MetricsService::MetricsPtr && metrics));
  MOCK_METHOD(void, onReceiveMessage,
              (std::unique_ptr<envoymobile::extensions::stat_sinks::metrics_service::
                                   EnvoyMobileStreamMetricsResponse> &&
               response));
};

} // namespace
} // namespace EnvoyMobileMetricsService
} // namespace StatSinks
} // namespace Extensions
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load(
    "@envoy//test/extensions:extensions_build_system.bzl",
    "envoy_extension_cc_test",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_extension_cc_test(
    name = "mobile_grpc_streamer_test",
    srcs = ["mobile_grpc_streamer_test.cc"],
    extension_names = ["envoy.stat_sinks.metrics_service.mobile"],
    repository = "@envoy",
    deps = [
        "//library/common/extensions/stat_sinks/metrics_service:config",
        "//library/common/extensions/stat_sinks/metrics_service:service_cc_proto",
        "@envoy//test/mocks/grpc:grpc_mocks",
        "@envoy//test/mocks/local_info:local_info_mocks",
        "@envoy//test/mocks/thread_local:thread_local_mocks",
        "@envoy//test/test_common:logging_lib",
    ],
)

envoy_extension_cc_test(
    name = "mobile_grpc_streamer_integration_test",
    srcs = ["mobile_grpc_streamer_integration_test.cc"],
    extension_names = ["envoy.stat_sinks.metrics_service.mobile"],
    repository = "@envoy",
    deps = [
        "//library/common/extensions/stat_sinks/metrics_service:config",
        "//library/common/extensions/stat_sinks/metrics_service:config_proto_cc_proto",
        "//library/common/extensions/stat_sinks/metrics_service:service_cc_proto",
        "@envoy//test/integration:http_integration_lib",
        "@envoy//test/mocks/grpc:grpc_mocks",
        "@envoy//test/mocks/local_info:local_info_mocks",
        "@envoy//test/mocks/thread_local:thread_local_mocks",
        "@envoy//test/test_common:utility_lib",
        "@envoy_api//envoy/config/bootstrap/v3:pkg_cc_proto",
    ],
)
#include <memory>
#include <string>

#include "test/mocks/event/mocks.h"

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "library/common/extensions/key_value/platform/config.h"
#include "library/common/extensions/key_value/platform/platform.pb.h"

using testing::NiceMock;

namespace Envoy {
namespace Extensions {
namespace KeyValue {
namespace {

class TestPlatformInterface : public PlatformInterface {
public:
  virtual void save(const std::string& key, const std::string& contents) override {
    store_.erase(key);
    store_.emplace(key, contents);
  }

  virtual std::string read(const std::string& key) const override {
    auto it = store_.find(key);
    if (it == store_.end()) {
      return "";
    }
    return it->second;
  }

private:
  absl::flat_hash_map<std::string, std::string> store_;
};

class PlatformStoreTest : public testing::Test {
protected:
  PlatformStoreTest() { createStore(); }

  void createStore() {
    // Note that timer assignment (to ttl vs flush) is determined by their ordering here
    ttl_timer_ = new NiceMock<Event::MockTimer>(&dispatcher_);
    flush_timer_ = new NiceMock<Event::MockTimer>(&dispatcher_);
    store_ = std::make_unique<PlatformKeyValueStore>(dispatcher_, save_interval_, mock_platform_,
                                                     std::numeric_limits<uint64_t>::max(), key_);
  }
  NiceMock<Event::MockDispatcher> dispatcher_;
  std::string key_{"key"};
  std::unique_ptr<PlatformKeyValueStore> store_{};
  std::chrono::seconds save_interval_{5};
  Event::MockTimer* flush_timer_ = nullptr;
  Event::MockTimer* ttl_timer_ = nullptr;
  TestPlatformInterface mock_platform_;
};

TEST_F(PlatformStoreTest, Basic) {
  EXPECT_EQ(absl::nullopt, store_->get("foo"));
  store_->addOrUpdate("foo", "bar", absl::nullopt);
  EXPECT_EQ("bar", store_->get("foo").value());
  store_->addOrUpdate("foo", "eep", absl::nullopt);
  EXPECT_EQ("eep", store_->get("foo").value());
  store_->remove("foo");
  EXPECT_EQ(absl::nullopt, store_->get("foo"));
}

TEST_F(PlatformStoreTest, Persist) {
  store_->addOrUpdate("foo", "bar", absl::nullopt);
  store_->addOrUpdate("by\nz", "ee\np", absl::nullopt);
  ASSERT_TRUE(flush_timer_->enabled_);
  flush_timer_->invokeCallback(); // flush
  EXPECT_TRUE(flush_timer_->enabled_);
  // Not flushed as 5ms didn't pass.
  store_->addOrUpdate("baz", "eep", absl::nullopt);

  save_interval_ = std::chrono::seconds(0);
  createStore();
  KeyValueStore::ConstIterateCb validate = [](const std::string& key, const std::string&) {
    EXPECT_TRUE(key == "foo" || key == "by\nz");
    return KeyValueStore::Iterate::Continue;
  };

  EXPECT_EQ("bar", store_->get("foo").value());
  EXPECT_EQ("ee\np", store_->get("by\nz").value());
  EXPECT_FALSE(store_->get("baz").has_value());
  store_->iterate(validate);

  // This will flush due to 0ms flush interval
  store_->addOrUpdate("baz", "eep", absl::nullopt);
  createStore();
  EXPECT_TRUE(store_->get("baz").has_value());

  // This will flush due to 0ms flush interval
  store_->remove("bar");
  createStore();
  EXPECT_FALSE(store_->get("bar").has_value());
}

TEST_F(PlatformStoreTest, Iterate) {
  store_->addOrUpdate("foo", "bar", absl::nullopt);
  store_->addOrUpdate("baz", "eep", absl::nullopt);

  int full_counter = 0;
  KeyValueStore::ConstIterateCb validate = [&full_counter](const std::string& key,
                                                           const std::string&) {
    ++full_counter;
    EXPECT_TRUE(key == "foo" || key == "baz");
    return KeyValueStore::Iterate::Continue;
  };
  store_->iterate(validate);
  EXPECT_EQ(2, full_counter);

  int stop_early_counter = 0;
  KeyValueStore::ConstIterateCb stop_early = [&stop_early_counter](const std::string&,
                                                                   const std::string&) {
    ++stop_early_counter;
    return KeyValueStore::Iterate::Break;
  };
  store_->iterate(stop_early);
  EXPECT_EQ(1, stop_early_counter);
}

} // namespace
} // namespace KeyValue
} // namespace Extensions
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load(
    "@envoy//test/extensions:extensions_build_system.bzl",
    "envoy_extension_cc_test",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_extension_cc_test(
    name = "platform_store_test",
    srcs = ["platform_store_test.cc"],
    extension_names = ["envoy.key_value.platform"],
    repository = "@envoy",
    deps = [
        "//library/common/extensions/key_value/platform:config",
        "@envoy//source/common/common:key_value_store_lib",
        "@envoy//test/mocks/event:event_mocks",
        "@envoy//test/test_common:file_system_for_test_lib",
    ],
)
#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "library/common/api/external.h"
#include "library/common/common/lambda_logger_delegate.h"
#include "library/common/data/utility.h"

using testing::_;
using testing::HasSubstr;
using testing::Not;

namespace Envoy {
namespace Logger {

class LambdaDelegateTest : public testing::Test {
public:
  static envoy_event_tracker tracker;

  static void SetUpTestSuite() {
    Api::External::registerApi(envoy_event_tracker_api_name, &tracker);
  }
};

envoy_event_tracker LambdaDelegateTest::tracker{};

TEST_F(LambdaDelegateTest, LogCb) {
  std::string expected_msg = "Hello LambdaDelegate";
  std::string actual_msg;

  LambdaDelegate delegate({[](envoy_data data, const void* context) -> void {
                             auto* actual_msg =
                                 static_cast<std::string*>(const_cast<void*>(context));
                             *actual_msg = Data::Utility::copyToString(data);
                             release_envoy_data(data);
                           },
                           [](const void*) -> void {}, &actual_msg},
                          Registry::getSink());

  ENVOY_LOG_MISC(error, expected_msg);
  EXPECT_THAT(actual_msg, HasSubstr(expected_msg));
}

TEST_F(LambdaDelegateTest, LogCbWithLevels) {
  std::string unexpected_msg = "Hello NoLambdaDelegate";
  std::string expected_msg = "Hello LambdaDelegate";
  std::string actual_msg;

  LambdaDelegate delegate({[](envoy_data data, const void* context) -> void {
                             auto* actual_msg =
                                 static_cast<std::string*>(const_cast<void*>(context));
                             *actual_msg = Data::Utility::copyToString(data);
                             release_envoy_data(data);
                           },
                           [](const void*) -> void {}, &actual_msg},
                          Registry::getSink());

  // Set the log to critical. The message should not be logged.
  Context::changeAllLogLevels(spdlog::level::critical);
  ENVOY_LOG_MISC(error, unexpected_msg);
  EXPECT_THAT(actual_msg, Not(HasSubstr(unexpected_msg)));

  // Change to error. The message should be logged.
  Context::changeAllLogLevels(spdlog::level::err);
  ENVOY_LOG_MISC(error, expected_msg);
  EXPECT_THAT(actual_msg, HasSubstr(expected_msg));

  // Change back to critical and test one more time.
  Context::changeAllLogLevels(spdlog::level::critical);
  ENVOY_LOG_MISC(error, expected_msg);
  EXPECT_THAT(actual_msg, Not(HasSubstr(unexpected_msg)));
}

TEST_F(LambdaDelegateTest, ReleaseCb) {
  bool released = false;

  {
    LambdaDelegate({[](envoy_data data, const void*) -> void { release_envoy_data(data); },
                    [](const void* context) -> void {
                      bool* released = static_cast<bool*>(const_cast<void*>(context));
                      *released = true;
                    },
                    &released},
                   Registry::getSink());
  }

  EXPECT_TRUE(released);
}

} // namespace Logger
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_test", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_test(
    name = "lambda_logger_delegate_test",
    srcs = ["lambda_logger_delegate_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/common/api:external_api_lib",
        "//library/common/common:lambda_logger_delegate_lib",
        "//library/common/data:utility_lib",
        "//library/common/types:c_types_lib",
    ],
)
#include "source/common/common/assert.h"

#include "test/common/http/common.h"
#include "test/common/mocks/common/mocks.h"

#include "absl/synchronization/notification.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "library/common/api/external.h"
#include "library/common/bridge/utility.h"
#include "library/common/data/utility.h"
#include "library/common/engine.h"
#include "library/common/http/header_utility.h"

using testing::_;
using testing::HasSubstr;
using testing::Return;
using testing::ReturnRef;

namespace Envoy {

typedef struct {
  absl::Notification on_engine_running;
  absl::Notification on_exit;
  absl::Notification on_log;
  absl::Notification on_logger_release;
  absl::Notification on_event;
} engine_test_context;

// This config is the minimal envoy mobile config that allows for running the engine.
const std::string MINIMAL_TEST_CONFIG = R"(
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: base_api_listener
    address:
      socket_address: { protocol: TCP, address: 0.0.0.0, port_value: 10000 }
    api_listener:
      api_listener:
        "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager
        config:
          stat_prefix: hcm
          route_config:
            name: api_router
            virtual_hosts:
            - name: api
              include_attempt_count_in_response: true
              domains: ["*"]
              routes:
              - match: { prefix: "/" }
                route:
                  cluster_header: x-envoy-mobile-cluster
                  retry_policy:
                    retry_back_off: { base_interval: 0.25s, max_interval: 60s }
          http_filters:
          - name: envoy.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
layered_runtime:
  layers:
  - name: static_layer_0
    static_layer:
      overload: { global_downstream_max_connections: 50000 }
)";

const std::string BUFFERED_TEST_CONFIG = R"(
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: base_api_listener
    address:
      socket_address: { protocol: TCP, address: 0.0.0.0, port_value: 10000 }
    api_listener:
       api_listener:
        "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager
        config:
          stat_prefix: hcm
          route_config:
            name: api_router
            virtual_hosts:
            - name: api
              include_attempt_count_in_response: true
              domains: ["*"]
              routes:
              - match: { prefix: "/" }
                direct_response: { status: 200 }
          http_filters:
          - name: buffer
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer
              max_request_bytes: 65000
          - name: envoy.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
layered_runtime:
  layers:
  - name: static_layer_0
    static_layer:
      overload: { global_downstream_max_connections: 50000 }
)";

const std::string LEVEL_DEBUG = "debug";

// Transform C map to C++ map.
[[maybe_unused]] static inline std::map<std::string, std::string> toMap(envoy_map map) {
  std::map<std::string, std::string> new_map;
  for (envoy_map_size_t i = 0; i < map.length; i++) {
    envoy_map_entry header = map.entries[i];
    const auto key = Data::Utility::copyToString(header.key);
    const auto value = Data::Utility::copyToString(header.value);
    new_map.insert({std::move(key), std::move(value)});
  }

  release_envoy_map(map);
  return new_map;
}

// Based on Http::Utility::toRequestHeaders() but only used for these tests.
Http::ResponseHeaderMapPtr toResponseHeaders(envoy_headers headers) {
  Http::ResponseHeaderMapPtr transformed_headers = Http::ResponseHeaderMapImpl::create();
  for (envoy_map_size_t i = 0; i < headers.length; i++) {
    transformed_headers->addCopy(
        Http::LowerCaseString(Data::Utility::copyToString(headers.entries[i].key)),
        Data::Utility::copyToString(headers.entries[i].value));
  }
  // The C envoy_headers struct can be released now because the headers have been copied.
  release_envoy_headers(headers);
  return transformed_headers;
}

class MainInterfaceTest : public testing::Test {
public:
  void SetUp() override {
    helper_handle_ = test::SystemHelperPeer::replaceSystemHelper();
    EXPECT_CALL(helper_handle_->mock_helper(), isCleartextPermitted(_))
        .WillRepeatedly(Return(true));
  }

protected:
  std::unique_ptr<test::SystemHelperPeer::Handle> helper_handle_;
};

TEST_F(MainInterfaceTest, BasicStream) {
  const std::string level = "debug";
  engine_test_context engine_cbs_context{};
  envoy_engine_callbacks engine_cbs{[](void* context) -> void {
                                      auto* engine_running =
                                          static_cast<engine_test_context*>(context);
                                      engine_running->on_engine_running.Notify();
                                    } /*on_engine_running*/,
                                    [](void* context) -> void {
                                      auto* exit = static_cast<engine_test_context*>(context);
                                      exit->on_exit.Notify();
                                    } /*on_exit*/,
                                    &engine_cbs_context /*context*/};
  std::unique_ptr<Envoy::Engine> engine(new Envoy::Engine(engine_cbs, {}, {}));
  engine->run(BUFFERED_TEST_CONFIG.c_str(), level.c_str());

  ASSERT_TRUE(
      engine_cbs_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(10)));

  absl::Notification on_complete_notification;
  envoy_http_callbacks stream_cbs{
      [](envoy_headers c_headers, bool end_stream, envoy_stream_intel, void*) -> void* {
        auto response_headers = toResponseHeaders(c_headers);
        EXPECT_EQ(response_headers->Status()->value().getStringView(), "200");
        EXPECT_TRUE(end_stream);
        return nullptr;
      } /* on_headers */,
      nullptr /* on_data */,
      nullptr /* on_metadata */,
      nullptr /* on_trailers */,
      nullptr /* on_error */,
      [](envoy_stream_intel, envoy_final_stream_intel, void* context) -> void* {
        auto* on_complete_notification = static_cast<absl::Notification*>(context);
        on_complete_notification->Notify();
        return nullptr;
      } /* on_complete */,
      nullptr /* on_cancel */,
      nullptr /* on_send_window_available*/,
      &on_complete_notification /* context */};
  Http::TestRequestHeaderMapImpl headers;
  HttpTestUtility::addDefaultHeaders(headers);
  envoy_headers c_headers = Http::Utility::toBridgeHeaders(headers);

  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");
  envoy_data c_data = Data::Utility::toBridgeData(request_data);

  Http::TestRequestTrailerMapImpl trailers;
  envoy_headers c_trailers = Http::Utility::toBridgeHeaders(trailers);

  envoy_stream_t stream = engine->initStream();

  engine->startStream(stream, stream_cbs, false);

  engine->sendHeaders(stream, c_headers, false);
  engine->sendData(stream, c_data, false);
  engine->sendTrailers(stream, c_trailers);

  ASSERT_TRUE(on_complete_notification.WaitForNotificationWithTimeout(absl::Seconds(10)));

  engine->terminate();

  ASSERT_TRUE(engine_cbs_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(10)));
}

TEST_F(MainInterfaceTest, ResetStream) {
  engine_test_context engine_cbs_context{};
  envoy_engine_callbacks engine_cbs{[](void* context) -> void {
                                      auto* engine_running =
                                          static_cast<engine_test_context*>(context);
                                      engine_running->on_engine_running.Notify();
                                    } /*on_engine_running*/,
                                    [](void* context) -> void {
                                      auto* exit = static_cast<engine_test_context*>(context);
                                      exit->on_exit.Notify();
                                    } /*on_exit*/,
                                    &engine_cbs_context /*context*/};

  // There is nothing functional about the config used to run the engine, as the created stream is
  // immediately reset.
  std::unique_ptr<Envoy::Engine> engine(new Envoy::Engine(engine_cbs, {}, {}));
  engine->run(MINIMAL_TEST_CONFIG.c_str(), LEVEL_DEBUG.c_str());

  ASSERT_TRUE(
      engine_cbs_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(10)));

  absl::Notification on_cancel_notification;
  envoy_http_callbacks stream_cbs{
      nullptr /* on_headers */,
      nullptr /* on_data */,
      nullptr /* on_metadata */,
      nullptr /* on_trailers */,
      nullptr /* on_error */,
      nullptr /* on_complete */,
      [](envoy_stream_intel, envoy_final_stream_intel, void* context) -> void* {
        auto* on_cancel_notification = static_cast<absl::Notification*>(context);
        on_cancel_notification->Notify();
        return nullptr;
      } /* on_cancel */,
      nullptr /* on_send_window_available */,
      &on_cancel_notification /* context */};

  envoy_stream_t stream = engine->initStream();

  engine->startStream(stream, stream_cbs, false);

  engine->cancelStream(stream);

  ASSERT_TRUE(on_cancel_notification.WaitForNotificationWithTimeout(absl::Seconds(10)));

  engine->terminate();

  ASSERT_TRUE(engine_cbs_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(10)));
}

TEST_F(MainInterfaceTest, RegisterPlatformApi) {
  engine_test_context engine_cbs_context{};
  envoy_engine_callbacks engine_cbs{[](void* context) -> void {
                                      auto* engine_running =
                                          static_cast<engine_test_context*>(context);
                                      engine_running->on_engine_running.Notify();
                                    } /*on_engine_running*/,
                                    [](void* context) -> void {
                                      auto* exit = static_cast<engine_test_context*>(context);
                                      exit->on_exit.Notify();
                                    } /*on_exit*/,
                                    &engine_cbs_context /*context*/};

  // Using the minimal envoy mobile config that allows for running the engine.
  std::unique_ptr<Envoy::Engine> engine(new Envoy::Engine(engine_cbs, {}, {}));
  engine->run(MINIMAL_TEST_CONFIG.c_str(), LEVEL_DEBUG.c_str());

  ASSERT_TRUE(
      engine_cbs_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(10)));

  uint64_t fake_api;
  Envoy::Api::External::registerApi("api", &fake_api);

  engine->terminate();

  ASSERT_TRUE(engine_cbs_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(10)));
}

TEST(EngineTest, RecordCounter) {
  engine_test_context test_context{};
  envoy_engine_callbacks engine_cbs{[](void* context) -> void {
                                      auto* engine_running =
                                          static_cast<engine_test_context*>(context);
                                      engine_running->on_engine_running.Notify();
                                    } /*on_engine_running*/,
                                    [](void* context) -> void {
                                      auto* exit = static_cast<engine_test_context*>(context);
                                      exit->on_exit.Notify();
                                    } /*on_exit*/,
                                    &test_context /*context*/};
  std::unique_ptr<Envoy::Engine> engine(new Envoy::Engine(engine_cbs, {}, {}));

  engine->run(MINIMAL_TEST_CONFIG.c_str(), LEVEL_DEBUG.c_str());
  ASSERT_TRUE(test_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(3)));
  EXPECT_EQ(ENVOY_SUCCESS, engine->recordCounterInc("counter", envoy_stats_notags, 1));

  engine->terminate();
  ASSERT_TRUE(test_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(3)));
}

TEST(EngineTest, Logger) {
  engine_test_context test_context{};
  envoy_engine_callbacks engine_cbs{[](void* context) -> void {
                                      auto* test_context =
                                          static_cast<engine_test_context*>(context);
                                      test_context->on_engine_running.Notify();
                                    } /*on_engine_running*/,
                                    [](void* context) -> void {
                                      auto* test_context =
                                          static_cast<engine_test_context*>(context);
                                      test_context->on_exit.Notify();
                                    } /*on_exit*/,
                                    &test_context /*context*/};

  envoy_logger logger{[](envoy_data data, const void* context) -> void {
                        auto* test_context =
                            static_cast<engine_test_context*>(const_cast<void*>(context));
                        release_envoy_data(data);
                        if (!test_context->on_log.HasBeenNotified()) {
                          test_context->on_log.Notify();
                        }
                      } /* log */,
                      [](const void* context) -> void {
                        auto* test_context =
                            static_cast<engine_test_context*>(const_cast<void*>(context));
                        test_context->on_logger_release.Notify();
                      } /* release */,
                      &test_context};
  std::unique_ptr<Envoy::Engine> engine(new Envoy::Engine(engine_cbs, logger, {}));
  engine->run(MINIMAL_TEST_CONFIG.c_str(), LEVEL_DEBUG.c_str());
  ASSERT_TRUE(test_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(3)));

  ASSERT_TRUE(test_context.on_log.WaitForNotificationWithTimeout(absl::Seconds(3)));

  engine->terminate();
  engine.reset();
  ASSERT_TRUE(test_context.on_logger_release.WaitForNotificationWithTimeout(absl::Seconds(3)));
  ASSERT_TRUE(test_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(3)));
}

TEST(EngineTest, EventTrackerRegistersDefaultAPI) {
  engine_test_context test_context{};
  envoy_engine_callbacks engine_cbs{[](void* context) -> void {
                                      auto* test_context =
                                          static_cast<engine_test_context*>(context);
                                      test_context->on_engine_running.Notify();
                                    } /*on_engine_running*/,
                                    [](void* context) -> void {
                                      auto* test_context =
                                          static_cast<engine_test_context*>(context);
                                      test_context->on_exit.Notify();
                                    } /*on_exit*/,
                                    &test_context /*context*/};

  std::unique_ptr<Envoy::Engine> engine(new Envoy::Engine(engine_cbs, {}, {}));
  engine->run(MINIMAL_TEST_CONFIG.c_str(), LEVEL_DEBUG.c_str());

  // A default event tracker is registered in external API registry.
  const auto registered_event_tracker =
      static_cast<envoy_event_tracker*>(Api::External::retrieveApi(envoy_event_tracker_api_name));
  EXPECT_TRUE(registered_event_tracker != nullptr);
  EXPECT_TRUE(registered_event_tracker->track == nullptr);
  EXPECT_TRUE(registered_event_tracker->context == nullptr);

  ASSERT_TRUE(test_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(3)));
  // Simulate a failed assertion by invoking a debug assertion failure
  // record action.
  // Verify that no crash if the assertion fails when no real event
  // tracker is passed at engine's initialization time.
  Assert::invokeDebugAssertionFailureRecordActionForAssertMacroUseOnly("foo_location");

  engine->terminate();
  ASSERT_TRUE(test_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(3)));
}

TEST(EngineTest, EventTrackerRegistersAPI) {
  engine_test_context test_context{};
  envoy_engine_callbacks engine_cbs{[](void* context) -> void {
                                      auto* test_context =
                                          static_cast<engine_test_context*>(context);
                                      test_context->on_engine_running.Notify();
                                    } /*on_engine_running*/,
                                    [](void* context) -> void {
                                      auto* test_context =
                                          static_cast<engine_test_context*>(context);
                                      test_context->on_exit.Notify();
                                    } /*on_exit*/,
                                    &test_context /*context*/};
  envoy_event_tracker event_tracker{[](envoy_map map, const void* context) -> void {
                                      const auto new_map = toMap(map);
                                      if (new_map.count("foo") && new_map.at("foo") == "bar") {
                                        auto* test_context = static_cast<engine_test_context*>(
                                            const_cast<void*>(context));
                                        test_context->on_event.Notify();
                                      }
                                    } /*track*/,
                                    &test_context /*context*/};

  std::unique_ptr<Envoy::Engine> engine(new Envoy::Engine(engine_cbs, {}, event_tracker));
  engine->run(MINIMAL_TEST_CONFIG.c_str(), LEVEL_DEBUG.c_str());

  ASSERT_TRUE(test_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(3)));
  const auto registered_event_tracker =
      static_cast<envoy_event_tracker*>(Api::External::retrieveApi(envoy_event_tracker_api_name));
  EXPECT_TRUE(registered_event_tracker != nullptr);
  EXPECT_EQ(event_tracker.track, registered_event_tracker->track);
  EXPECT_EQ(event_tracker.context, registered_event_tracker->context);

  event_tracker.track(Bridge::Utility::makeEnvoyMap({{"foo", "bar"}}),
                      registered_event_tracker->context);

  ASSERT_TRUE(test_context.on_event.WaitForNotificationWithTimeout(absl::Seconds(3)));
  engine->terminate();
  ASSERT_TRUE(test_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(3)));
}

TEST(EngineTest, EventTrackerRegistersAssertionFailureRecordAction) {
  engine_test_context test_context{};
  envoy_engine_callbacks engine_cbs{[](void* context) -> void {
                                      auto* test_context =
                                          static_cast<engine_test_context*>(context);
                                      test_context->on_engine_running.Notify();
                                    } /*on_engine_running*/,
                                    [](void* context) -> void {
                                      auto* test_context =
                                          static_cast<engine_test_context*>(context);
                                      test_context->on_exit.Notify();
                                    } /*on_exit*/,
                                    &test_context /*context*/};

  envoy_event_tracker event_tracker{
      [](envoy_map map, const void* context) -> void {
        const auto new_map = toMap(map);
        if (new_map.count("name") && new_map.at("name") == "assertion") {
          EXPECT_EQ(new_map.at("location"), "foo_location");
          auto* test_context = static_cast<engine_test_context*>(const_cast<void*>(context));
          test_context->on_event.Notify();
        }
      } /*track*/,
      &test_context /*context*/};

  std::unique_ptr<Envoy::Engine> engine(new Envoy::Engine(engine_cbs, {}, event_tracker));
  engine->run(MINIMAL_TEST_CONFIG.c_str(), LEVEL_DEBUG.c_str());

  ASSERT_TRUE(test_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(3)));
  // Simulate a failed assertion by invoking a debug assertion failure
  // record action.
  // Verify that an envoy event is emitted when an event tracker is passed
  // at engine's initialization time.
  Assert::invokeDebugAssertionFailureRecordActionForAssertMacroUseOnly("foo_location");

  ASSERT_TRUE(test_context.on_event.WaitForNotificationWithTimeout(absl::Seconds(3)));
  engine->terminate();
  ASSERT_TRUE(test_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(3)));
}

TEST(EngineTest, EventTrackerRegistersEnvoyBugRecordAction) {
  engine_test_context test_context{};
  envoy_engine_callbacks engine_cbs{[](void* context) -> void {
                                      auto* test_context =
                                          static_cast<engine_test_context*>(context);
                                      test_context->on_engine_running.Notify();
                                    } /*on_engine_running*/,
                                    [](void* context) -> void {
                                      auto* test_context =
                                          static_cast<engine_test_context*>(context);
                                      test_context->on_exit.Notify();
                                    } /*on_exit*/,
                                    &test_context /*context*/};

  envoy_event_tracker event_tracker{[](envoy_map map, const void* context) -> void {
                                      const auto new_map = toMap(map);
                                      if (new_map.count("name") && new_map.at("name") == "bug") {
                                        EXPECT_EQ(new_map.at("location"), "foo_location");
                                        auto* test_context = static_cast<engine_test_context*>(
                                            const_cast<void*>(context));
                                        test_context->on_event.Notify();
                                      }
                                    } /*track*/,
                                    &test_context /*context*/};

  std::unique_ptr<Envoy::Engine> engine(new Envoy::Engine(engine_cbs, {}, event_tracker));
  engine->run(MINIMAL_TEST_CONFIG.c_str(), LEVEL_DEBUG.c_str());

  ASSERT_TRUE(test_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(3)));
  // Simulate an envoy bug by invoking an Envoy bug failure
  // record action.
  // Verify that an envoy event is emitted when an event tracker is passed
  // at engine's initialization time.
  Assert::invokeEnvoyBugFailureRecordActionForEnvoyBugMacroUseOnly("foo_location");

  ASSERT_TRUE(test_context.on_event.WaitForNotificationWithTimeout(absl::Seconds(3)));
  engine->terminate();
  ASSERT_TRUE(test_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(3)));
}

TEST_F(MainInterfaceTest, ResetConnectivityState) {
  engine_test_context test_context{};
  envoy_engine_callbacks engine_cbs{[](void* context) -> void {
                                      auto* engine_running =
                                          static_cast<engine_test_context*>(context);
                                      engine_running->on_engine_running.Notify();
                                    } /*on_engine_running*/,
                                    [](void* context) -> void {
                                      auto* exit = static_cast<engine_test_context*>(context);
                                      exit->on_exit.Notify();
                                    } /*on_exit*/,
                                    &test_context /*context*/};
  std::unique_ptr<Envoy::Engine> engine(new Envoy::Engine(engine_cbs, {}, {}));
  engine->run(MINIMAL_TEST_CONFIG.c_str(), LEVEL_DEBUG.c_str());
  ASSERT_TRUE(test_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(3)));

  ASSERT_EQ(ENVOY_SUCCESS, engine->resetConnectivityState());

  engine->terminate();
  ASSERT_TRUE(test_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(3)));
}

} // namespace Envoy
syntax = "proto3";

package envoymobile.extensions.filters.http.route_cache_reset;

message RouteCacheReset {
}
#pragma once

#include <string>

#include "source/extensions/filters/http/common/factory_base.h"

#include "test/common/http/filters/route_cache_reset/filter.pb.h"
#include "test/common/http/filters/route_cache_reset/filter.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace RouteCacheReset {

/**
 * Config registration for the route_cache_reset filter. @see NamedHttpFilterConfigFactory.
 */
class RouteCacheResetFilterFactory
    : public Common::FactoryBase<
          envoymobile::extensions::filters::http::route_cache_reset::RouteCacheReset> {
public:
  RouteCacheResetFilterFactory() : FactoryBase("route_cache_reset") {}

private:
  ::Envoy::Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoymobile::extensions::filters::http::route_cache_reset::RouteCacheReset& config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

DECLARE_FACTORY(RouteCacheResetFilterFactory);

} // namespace RouteCacheReset
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/route_cache_reset/filter.h"

#include "envoy/server/filter_config.h"

#include "source/common/http/header_map_impl.h"
#include "source/common/http/utility.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace RouteCacheReset {

RouteCacheResetFilter::RouteCacheResetFilter() {}

void RouteCacheResetFilter::onDestroy() {}

Http::FilterHeadersStatus RouteCacheResetFilter::decodeHeaders(Http::RequestHeaderMap&, bool) {
  callbacks_->downstreamCallbacks()->clearRouteCache();
  ENVOY_LOG(debug, "cleared route cache after decoding headers");
  return Http::FilterHeadersStatus::Continue;
}

void RouteCacheResetFilter::setDecoderFilterCallbacks(
    Http::StreamDecoderFilterCallbacks& callbacks) {
  callbacks_ = &callbacks;
}

Http::FilterDataStatus RouteCacheResetFilter::decodeData(Buffer::Instance&, bool) {
  return Http::FilterDataStatus::Continue;
}

Http::FilterTrailersStatus RouteCacheResetFilter::decodeTrailers(Http::RequestTrailerMap&) {
  return Http::FilterTrailersStatus::Continue;
}

} // namespace RouteCacheReset
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_mobile_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_proto_library(
    name = "filter",
    srcs = ["filter.proto"],
)

envoy_cc_library(
    name = "route_cache_reset_filter_lib",
    srcs = ["filter.cc"],
    hdrs = ["filter.h"],
    repository = "@envoy",
    deps = [
        ":filter_cc_proto",
        "@envoy//envoy/http:filter_interface",
        "@envoy//source/common/http:header_map_lib",
        "@envoy//source/common/http:headers_lib",
        "@envoy//source/common/http:utility_lib",
    ],
)

envoy_cc_library(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    repository = "@envoy",
    deps = [
        ":route_cache_reset_filter_lib",
        "@envoy//source/extensions/filters/http/common:factory_base_lib",
    ],
)
#pragma once

#include "envoy/http/filter.h"

#include "source/common/common/logger.h"

#include "test/common/http/filters/route_cache_reset/filter.pb.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace RouteCacheReset {

/**
 * Filter that has the sole purpose of clearing the route cache for a given
 * stream on the request path. This forces the router filter to recompute
 * routes for outbound requests using information that was potentially
 * mutated by other filters (such as headers).
 */
class RouteCacheResetFilter final : public Http::StreamDecoderFilter,
                                    public Logger::Loggable<Logger::Id::filter> {
public:
  RouteCacheResetFilter();

  // Http::StreamFilterBase
  void onDestroy() override;

  // Http::StreamDecoderFilter
  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& headers,
                                          bool end_stream) override;
  Http::FilterDataStatus decodeData(Buffer::Instance& data, bool end_stream) override;
  Http::FilterTrailersStatus decodeTrailers(Http::RequestTrailerMap& trailers) override;
  void setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) override;

private:
  Http::StreamDecoderFilterCallbacks* callbacks_{};
};

} // namespace RouteCacheReset
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/route_cache_reset/config.h"

#include "test/common/http/filters/route_cache_reset/filter.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace RouteCacheReset {

Http::FilterFactoryCb RouteCacheResetFilterFactory::createFilterFactoryFromProtoTyped(
    const envoymobile::extensions::filters::http::route_cache_reset::RouteCacheReset&,
    const std::string&, Server::Configuration::FactoryContext&) {

  return [](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamDecoderFilter(std::make_shared<RouteCacheResetFilter>());
  };
}

/**
 * Static registration for the RouteCacheReset filter. @see NamedHttpFilterConfigFactory.
 */
REGISTER_FACTORY(RouteCacheResetFilterFactory, Server::Configuration::NamedHttpFilterConfigFactory);

} // namespace RouteCacheReset
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";

package envoymobile.extensions.filters.http.test_remote_response;

message TestRemoteResponse {
}
#pragma once

#include <string>

#include "source/extensions/filters/http/common/factory_base.h"

#include "test/common/http/filters/test_remote_response/filter.pb.h"
#include "test/common/http/filters/test_remote_response/filter.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestRemoteResponse {

/**
 * Config registration for the test_remote_response filter. @see NamedHttpFilterConfigFactory.
 */
class TestRemoteResponseFilterFactory
    : public Common::FactoryBase<
          envoymobile::extensions::filters::http::test_remote_response::TestRemoteResponse> {
public:
  TestRemoteResponseFilterFactory() : FactoryBase("test_remote_response") {}

private:
  ::Envoy::Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoymobile::extensions::filters::http::test_remote_response::TestRemoteResponse&
          config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

DECLARE_FACTORY(TestRemoteResponseFilterFactory);

} // namespace TestRemoteResponse
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/test_remote_response/filter.h"

#include "envoy/http/header_map.h"
#include "envoy/server/filter_config.h"

#include "source/common/buffer/buffer_impl.h"
#include "source/common/http/header_map_impl.h"

#include "library/common/http/header_utility.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestRemoteResponse {

Http::FilterHeadersStatus TestRemoteResponseFilter::decodeHeaders(Http::RequestHeaderMap& headers,
                                                                  bool end_stream) {
  headers_ = &headers;
  if (end_stream) {
    sendResponse();
  }
  return Http::FilterHeadersStatus::StopIteration;
}
Http::FilterDataStatus TestRemoteResponseFilter::decodeData(Buffer::Instance&, bool end_stream) {
  if (end_stream) {
    sendResponse();
  }
  return Http::FilterDataStatus::StopIterationAndBuffer;
}
Http::FilterTrailersStatus TestRemoteResponseFilter::decodeTrailers(Http::RequestTrailerMap&) {
  sendResponse();
  return Http::FilterTrailersStatus::StopIteration;
}

void TestRemoteResponseFilter::sendResponse() {
  std::cerr << *headers_;
  bool send_trailers = !headers_->get(Http::LowerCaseString("send-trailers")).empty();

  Http::ResponseHeaderMapPtr headers{
      Http::createHeaderMap<Http::ResponseHeaderMapImpl>({{Http::Headers::get().Status, "200"}})};
  decoder_callbacks_->encodeHeaders(std::move(headers), false,
                                    StreamInfo::ResponseCodeDetails::get().ViaUpstream);
  Buffer::OwnedImpl body("data");
  decoder_callbacks_->encodeData(body, !send_trailers);
  if (send_trailers) {
    std::string trailers_value(
        headers_->get(Http::LowerCaseString("send-trailers"))[0]->value().getStringView());
    Http::ResponseTrailerMapPtr trailers;
    if (trailers_value == "empty") {
      trailers = Http::createHeaderMap<Http::ResponseTrailerMapImpl>({});
    } else if (trailers_value == "empty-value") {
      trailers =
          Http::createHeaderMap<Http::ResponseTrailerMapImpl>({{Http::LowerCaseString("foo"), ""}});
    } else {
      trailers = Http::createHeaderMap<Http::ResponseTrailerMapImpl>(
          {{Http::LowerCaseString("foo"), "bar"}});
    }
    decoder_callbacks_->encodeTrailers(std::move(trailers));
  }
}

} // namespace TestRemoteResponse
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_mobile_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_proto_library(
    name = "filter",
    srcs = ["filter.proto"],
)

envoy_cc_library(
    name = "test_remote_response_filter_lib",
    srcs = ["filter.cc"],
    hdrs = ["filter.h"],
    repository = "@envoy",
    deps = [
        ":filter_cc_proto",
        "//library/common/http:header_utility_lib",
        "//library/common/http:internal_headers_lib",
        "//library/common/types:c_types_lib",
        "@envoy//envoy/http:codes_interface",
        "@envoy//envoy/http:filter_interface",
        "@envoy//source/common/grpc:common_lib",
        "@envoy//source/common/grpc:status_lib",
        "@envoy//source/common/http:codes_lib",
        "@envoy//source/common/http:header_map_lib",
        "@envoy//source/common/http:headers_lib",
        "@envoy//source/common/http:utility_lib",
        "@envoy//source/extensions/filters/http/common:pass_through_filter_lib",
    ],
)

envoy_cc_library(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    repository = "@envoy",
    deps = [
        ":test_remote_response_filter_lib",
        "@envoy//source/extensions/filters/http/common:factory_base_lib",
    ],
)
#pragma once

#include "envoy/http/filter.h"

#include "source/common/common/logger.h"
#include "source/extensions/filters/http/common/pass_through_filter.h"

#include "test/common/http/filters/test_remote_response/filter.pb.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestRemoteResponse {

/**
 * Filter to test data sent from upstream. This fakes sending a response similar
 * to how the router does but is hermetic as no network connection is created.
 */
class TestRemoteResponseFilter final : public Http::PassThroughFilter,
                                       public Logger::Loggable<Logger::Id::filter> {
public:
  // StreamFilterBase
  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap&, bool end_stream) override;
  Http::FilterDataStatus decodeData(Buffer::Instance&, bool end_stream) override;
  Http::FilterTrailersStatus decodeTrailers(Http::RequestTrailerMap&) override;

  void sendResponse();

private:
  Http::RequestHeaderMap* headers_{};
};

} // namespace TestRemoteResponse
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/test_remote_response/config.h"

#include "test/common/http/filters/test_remote_response/filter.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestRemoteResponse {

Http::FilterFactoryCb TestRemoteResponseFilterFactory::createFilterFactoryFromProtoTyped(
    const envoymobile::extensions::filters::http::test_remote_response::TestRemoteResponse&,
    const std::string&, Server::Configuration::FactoryContext&) {

  return [](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamFilter(std::make_shared<TestRemoteResponseFilter>());
  };
}

/**
 * Static registration for the TestRemoteResponse filter. @see NamedHttpFilterConfigFactory.
 */
REGISTER_FACTORY(TestRemoteResponseFilterFactory,
                 Server::Configuration::NamedHttpFilterConfigFactory);

} // namespace TestRemoteResponse
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";

package envoymobile.extensions.filters.http.test_logger;

message TestLogger {
}
#pragma once

#include <string>

#include "source/extensions/filters/http/common/factory_base.h"

#include "test/common/http/filters/test_logger/filter.h"
#include "test/common/http/filters/test_logger/filter.pb.h"
#include "test/common/http/filters/test_logger/filter.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestLogger {

/**
 * Config registration for the TestLogger filter. @see NamedHttpFilterConfigFactory.
 */
class Factory
    : public Common::FactoryBase<envoymobile::extensions::filters::http::test_logger::TestLogger> {
public:
  Factory() : FactoryBase("test_logger") {}

private:
  Envoy::Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoymobile::extensions::filters::http::test_logger::TestLogger& config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

DECLARE_FACTORY(Factory);

} // namespace TestLogger
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_mobile_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_proto_library(
    name = "filter",
    srcs = ["filter.proto"],
    deps = [
        "@envoy_api//envoy/config/common/matcher/v3:pkg",
    ],
)

envoy_cc_library(
    name = "test_event_tracker_filter_lib",
    hdrs = ["filter.h"],
    repository = "@envoy",
    deps = [
        "filter_cc_proto",
        "@envoy//source/common/common:assert_lib",
        "@envoy//source/extensions/filters/http/common:pass_through_filter_lib",
    ],
)

envoy_cc_library(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    repository = "@envoy",
    deps = [
        ":test_event_tracker_filter_lib",
        "@envoy//source/extensions/filters/http/common:factory_base_lib",
    ],
)
#pragma once

#include "envoy/http/filter.h"

#include "source/extensions/filters/http/common/pass_through_filter.h"

#include "test/common/http/filters/test_logger/filter.pb.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestLogger {

// A filter that emits an ENVOY_EVENT log, used for testing event tracker integration.
class Filter : public Envoy::Http::PassThroughFilter, public Logger::Loggable<Logger::Id::filter> {
public:
  Filter() { ENVOY_LOG_EVENT(debug, "event_name", "test log"); }
};

} // namespace TestLogger
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/test_logger/config.h"

#include "test/common/http/filters/test_logger/filter.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestLogger {

Http::FilterFactoryCb Factory::createFilterFactoryFromProtoTyped(
    const envoymobile::extensions::filters::http::test_logger::TestLogger&, const std::string&,
    Server::Configuration::FactoryContext&) {

  return [](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamFilter(std::make_shared<Filter>());
  };
}

/**
 * Static registration for the TestEventTracker filter. @see NamedHttpFilterConfigFactory.
 */
REGISTER_FACTORY(Factory, Server::Configuration::NamedHttpFilterConfigFactory);

} // namespace TestLogger
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";

package envoymobile.extensions.filters.http.assertion;

import "envoy/config/common/matcher/v3/matcher.proto";

import "validate/validate.proto";

message Assertion {
  // The match configuration. If the configuration matches the request frames the filter will send
  // a local reply with Http::Code::OK on the last frame of the request stream (continuing on
  // intervening frames). Otherwise, it will send a local reply with Http::Code::BadRequest.
  // TODO: update upstream MatchPredicate proto to require at least one matcher.
  envoy.config.common.matcher.v3.MatchPredicate match_config = 1
      [(validate.rules).message = {required: true}];
}
#pragma once

#include <string>

#include "source/extensions/filters/http/common/factory_base.h"

#include "test/common/http/filters/assertion/filter.pb.h"
#include "test/common/http/filters/assertion/filter.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace Assertion {

/**
 * Config registration for the assertion filter. @see NamedHttpFilterConfigFactory.
 */
class AssertionFilterFactory
    : public Common::FactoryBase<envoymobile::extensions::filters::http::assertion::Assertion> {
public:
  AssertionFilterFactory() : FactoryBase("assertion") {}

private:
  ::Envoy::Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoymobile::extensions::filters::http::assertion::Assertion& config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

DECLARE_FACTORY(AssertionFilterFactory);

} // namespace Assertion
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/assertion/filter.h"

#include "envoy/http/codes.h"
#include "envoy/server/filter_config.h"

#include "source/common/http/header_map_impl.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace Assertion {

AssertionFilterConfig::AssertionFilterConfig(
    const envoymobile::extensions::filters::http::assertion::Assertion& proto_config) {
  Common::Matcher::buildMatcher(proto_config.match_config(), matchers_);
}

Extensions::Common::Matcher::Matcher& AssertionFilterConfig::rootMatcher() const {
  ASSERT(!matchers_.empty());
  return *matchers_[0];
}

// Implementation of this filter is complicated by the fact that the streaming matchers have no
// explicit mechanism to handle end_stream. This means that we must infer that matching has failed
// if the stream ends with still-unsatisfied matches. We do this by potentially passing empty
// body data and empty trailers to the matchers in the event the stream ends without including
// these entities.
AssertionFilter::AssertionFilter(AssertionFilterConfigSharedPtr config) : config_(config) {
  statuses_ = Extensions::Common::Matcher::Matcher::MatchStatusVector(config_->matchersSize());
  config_->rootMatcher().onNewStream(statuses_);
}

Http::FilterHeadersStatus AssertionFilter::decodeHeaders(Http::RequestHeaderMap& headers,
                                                         bool end_stream) {
  config_->rootMatcher().onHttpRequestHeaders(headers, statuses_);
  auto& match_status = config_->rootMatcher().matchStatus(statuses_);
  if (!match_status.matches_ && !match_status.might_change_status_) {
    decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,
                                       "Request Headers do not match configured expectations",
                                       nullptr, absl::nullopt, "");
    return Http::FilterHeadersStatus::StopIteration;
  }

  if (end_stream) {
    // Check if there are unsatisfied assertions about stream trailers.
    auto empty_trailers = Http::RequestTrailerMapImpl::create();
    config_->rootMatcher().onHttpRequestTrailers(*empty_trailers, statuses_);
    auto& final_match_status = config_->rootMatcher().matchStatus(statuses_);
    if (!final_match_status.matches_ && !final_match_status.might_change_status_) {
      decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,
                                         "Request Trailers do not match configured expectations",
                                         nullptr, absl::nullopt, "");
      return Http::FilterHeadersStatus::StopIteration;
    }

    // Because a stream only contains a single set of headers or trailers, if either fail to
    // satisfy assertions, might_change_status_ will be false. Therefore if matches_ is still
    // unsatisfied here, it must be because of body data.
    if (!final_match_status.matches_) {
      decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,
                                         "Request Body does not match configured expectations",
                                         nullptr, absl::nullopt, "");
      return Http::FilterHeadersStatus::StopIteration;
    }
  }

  return Http::FilterHeadersStatus::Continue;
}

Http::FilterDataStatus AssertionFilter::decodeData(Buffer::Instance& data, bool end_stream) {
  config_->rootMatcher().onRequestBody(data, statuses_);
  auto& match_status = config_->rootMatcher().matchStatus(statuses_);
  if (!match_status.matches_ && !match_status.might_change_status_) {
    decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,
                                       "Request Body does not match configured expectations",
                                       nullptr, absl::nullopt, "");
    return Http::FilterDataStatus::StopIterationNoBuffer;
  }

  if (end_stream) {
    // Check if there are unsatisfied assertions about stream trailers.
    auto empty_trailers = Http::RequestTrailerMapImpl::create();
    config_->rootMatcher().onHttpRequestTrailers(*empty_trailers, statuses_);
    auto& match_status = config_->rootMatcher().matchStatus(statuses_);
    if (!match_status.matches_ && !match_status.might_change_status_) {
      decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,
                                         "Request Trailers do not match configured expectations",
                                         nullptr, absl::nullopt, "");
      return Http::FilterDataStatus::StopIterationNoBuffer;
    }

    // Because a stream only contains a single set of headers or trailers, if either fail to
    // satisfy assertions, might_change_status_ will be false. Therefore if matches_ is still
    // unsatisfied here, it must be because of body data.
    if (!match_status.matches_) {
      decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,
                                         "Request Body does not match configured expectations",
                                         nullptr, absl::nullopt, "");
      return Http::FilterDataStatus::StopIterationNoBuffer;
    }
  }
  return Http::FilterDataStatus::Continue;
}

Http::FilterTrailersStatus AssertionFilter::decodeTrailers(Http::RequestTrailerMap& trailers) {
  config_->rootMatcher().onHttpRequestTrailers(trailers, statuses_);
  auto& match_status = config_->rootMatcher().matchStatus(statuses_);
  if (!match_status.matches_ && !match_status.might_change_status_) {
    decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,
                                       "Request Trailers do not match configured expectations",
                                       nullptr, absl::nullopt, "");
    return Http::FilterTrailersStatus::StopIteration;
  }

  // Because a stream only contains a single set of headers or trailers, if either fail to
  // satisfy assertions, might_change_status_ will be false. Therefore if matches_ is still
  // unsatisfied here, it must be because of body data.
  if (!match_status.matches_) {
    decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,
                                       "Request Body does not match configured expectations",
                                       nullptr, absl::nullopt, "");
    return Http::FilterTrailersStatus::StopIteration;
  }
  return Http::FilterTrailersStatus::Continue;
}

Http::FilterHeadersStatus AssertionFilter::encodeHeaders(Http::ResponseHeaderMap& headers,
                                                         bool end_stream) {
  config_->rootMatcher().onHttpResponseHeaders(headers, statuses_);
  auto& match_status = config_->rootMatcher().matchStatus(statuses_);
  if (!match_status.matches_ && !match_status.might_change_status_) {
    decoder_callbacks_->sendLocalReply(Http::Code::InternalServerError,
                                       "Response Headers do not match configured expectations",
                                       nullptr, absl::nullopt, "");
    return Http::FilterHeadersStatus::StopIteration;
  }

  if (end_stream) {
    // Check if there are unsatisfied assertions about stream trailers.
    auto empty_trailers = Http::ResponseTrailerMapImpl::create();
    config_->rootMatcher().onHttpResponseTrailers(*empty_trailers, statuses_);
    auto& final_match_status = config_->rootMatcher().matchStatus(statuses_);
    if (!final_match_status.matches_ && !final_match_status.might_change_status_) {
      decoder_callbacks_->sendLocalReply(Http::Code::InternalServerError,
                                         "Response Trailers do not match configured expectations",
                                         nullptr, absl::nullopt, "");
      return Http::FilterHeadersStatus::StopIteration;
    }

    // Because a stream only contains a single set of headers or trailers, if either fail to
    // satisfy assertions, might_change_status_ will be false. Therefore if matches_ is still
    // unsatisfied here, it must be because of body data.
    if (!final_match_status.matches_) {
      decoder_callbacks_->sendLocalReply(Http::Code::InternalServerError,
                                         "Response Body does not match configured expectations",
                                         nullptr, absl::nullopt, "");
      return Http::FilterHeadersStatus::StopIteration;
    }
  }

  return Http::FilterHeadersStatus::Continue;
}

Http::FilterDataStatus AssertionFilter::encodeData(Buffer::Instance& data, bool end_stream) {
  config_->rootMatcher().onResponseBody(data, statuses_);
  auto& match_status = config_->rootMatcher().matchStatus(statuses_);
  if (!match_status.matches_ && !match_status.might_change_status_) {
    decoder_callbacks_->sendLocalReply(Http::Code::InternalServerError,
                                       "Response Body does not match configured expectations",
                                       nullptr, absl::nullopt, "");
    return Http::FilterDataStatus::StopIterationNoBuffer;
  }

  if (end_stream) {
    // Check if there are unsatisfied assertions about stream trailers.
    auto empty_trailers = Http::ResponseTrailerMapImpl::create();
    config_->rootMatcher().onHttpResponseTrailers(*empty_trailers, statuses_);
    auto& match_status = config_->rootMatcher().matchStatus(statuses_);
    if (!match_status.matches_ && !match_status.might_change_status_) {
      decoder_callbacks_->sendLocalReply(Http::Code::InternalServerError,
                                         "Response Trailers do not match configured expectations",
                                         nullptr, absl::nullopt, "");
      return Http::FilterDataStatus::StopIterationNoBuffer;
    }

    // Because a stream only contains a single set of headers or trailers, if either fail to
    // satisfy assertions, might_change_status_ will be false. Therefore if matches_ is still
    // unsatisfied here, it must be because of body data.
    if (!match_status.matches_) {
      decoder_callbacks_->sendLocalReply(Http::Code::InternalServerError,
                                         "Response Body does not match configured expectations",
                                         nullptr, absl::nullopt, "");
      return Http::FilterDataStatus::StopIterationNoBuffer;
    }
  }
  return Http::FilterDataStatus::Continue;
}

Http::FilterTrailersStatus AssertionFilter::encodeTrailers(Http::ResponseTrailerMap& trailers) {
  config_->rootMatcher().onHttpResponseTrailers(trailers, statuses_);
  auto& match_status = config_->rootMatcher().matchStatus(statuses_);
  if (!match_status.matches_ && !match_status.might_change_status_) {
    decoder_callbacks_->sendLocalReply(Http::Code::InternalServerError,
                                       "Response Trailers do not match configured expectations",
                                       nullptr, absl::nullopt, "");
    return Http::FilterTrailersStatus::StopIteration;
  }

  // Because a stream only contains a single set of headers or trailers, if either fail to
  // satisfy assertions, might_change_status_ will be false. Therefore if matches_ is still
  // unsatisfied here, it must be because of body data.
  if (!match_status.matches_) {
    decoder_callbacks_->sendLocalReply(Http::Code::InternalServerError,
                                       "Response Body does not match configured expectations",
                                       nullptr, absl::nullopt, "");
    return Http::FilterTrailersStatus::StopIteration;
  }
  return Http::FilterTrailersStatus::Continue;
}

} // namespace Assertion
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/assertion/config.h"
#include "test/common/http/filters/assertion/filter.h"
#include "test/common/http/filters/assertion/filter.pb.h"
#include "test/mocks/http/mocks.h"
#include "test/mocks/server/factory_context.h"
#include "test/test_common/utility.h"

#include "gtest/gtest.h"

using testing::ByMove;
using testing::Return;

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace Assertion {
namespace {

class AssertionFilterTest : public testing::Test {
public:
  void setUpFilter(std::string&& proto_str) {
    envoymobile::extensions::filters::http::assertion::Assertion config;
    Protobuf::TextFormat::ParseFromString(proto_str, &config);
    config_ = std::make_shared<AssertionFilterConfig>(config);
    filter_ = std::make_unique<AssertionFilter>(config_);
    filter_->setDecoderFilterCallbacks(decoder_callbacks_);
    filter_->setEncoderFilterCallbacks(encoder_callbacks_);
  }

  AssertionFilterConfigSharedPtr config_{};
  std::unique_ptr<AssertionFilter> filter_{};
  NiceMock<Http::MockStreamDecoderFilterCallbacks> decoder_callbacks_;
  NiceMock<Http::MockStreamEncoderFilterCallbacks> encoder_callbacks_;
};

TEST_F(AssertionFilterTest, RequestHeadersMatchWithEndStream) {
  setUpFilter(R"EOF(
match_config {
  http_request_headers_match {
    headers {
      name: ":authority"
      exact_match: "test.code"
    }
  }
}
)EOF");

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, true));
}

TEST_F(AssertionFilterTest, RequestHeadersMatch) {
  setUpFilter(R"EOF(
  match_config {
  http_request_headers_match {
    headers {
      name: ":authority"
      exact_match: "test.code"
    }
  }
  }
)EOF");

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, false));
}

TEST_F(AssertionFilterTest, RequestHeadersNoMatchWithEndStream) {
  setUpFilter(R"EOF(
  match_config {
  http_request_headers_match {
    headers {
      name: ":authority"
      exact_match: "test.code"
    }
  }
  }
)EOF");

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "no.match"}};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::BadRequest,
                             "Request Headers do not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, true));
}

TEST_F(AssertionFilterTest, RequestHeadersNoMatch) {
  setUpFilter(R"EOF(
  match_config {
  http_request_headers_match {
    headers {
      name: ":authority"
      exact_match: "test.code"
    }
  }
  }
)EOF");

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "no.match"}};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::BadRequest,
                             "Request Headers do not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, false));
}

TEST_F(AssertionFilterTest, RequestHeadersMatchWithEndstreamAndDataMissing) {
  setUpFilter(R"EOF(
match_config {
  and_match {
    rules {
      http_request_headers_match {
        headers {
          name: ":authority"
          exact_match: "test.code"
        }
      }
    }
    rules {
      http_request_generic_body_match {
        patterns {
          string_match: "match_me"
        }
      }
    }
  }
}
)EOF");

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::BadRequest,
                             "Request Body does not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, true));
}

TEST_F(AssertionFilterTest, RequestHeadersMatchWithEndstreamAndTrailersMissing) {
  setUpFilter(R"EOF(
match_config {
  and_match {
    rules {
      http_request_headers_match {
        headers {
          name: ":authority"
          exact_match: "test.code"
        }
      }
    }
    rules {
      http_request_trailers_match {
        headers {
          name: "test-trailer"
          exact_match: "test.code"
        }
      }
    }
  }
}
)EOF");

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::BadRequest,
                             "Request Trailers do not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->decodeHeaders(request_headers, true));
}

TEST_F(AssertionFilterTest, RequestDataMatchWithEndStream) {
  setUpFilter(R"EOF(
match_config {
  http_request_generic_body_match {
    patterns {
      string_match: "match_me"
    }
  }
}
)EOF");

  Buffer::InstancePtr body{new Buffer::OwnedImpl("match_me")};

  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(*body, true));
}

TEST_F(AssertionFilterTest, RequestDataMatch) {
  setUpFilter(R"EOF(
match_config {
  http_request_generic_body_match {
    patterns {
      string_match: "match_me"
    }
  }
}
)EOF");

  Buffer::InstancePtr body{new Buffer::OwnedImpl("match_me")};

  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(*body, false));
}

TEST_F(AssertionFilterTest, RequestDataNoMatchFastPath) {
  setUpFilter(R"EOF(
match_config {
  http_request_generic_body_match {
    bytes_limit: 1
    patterns {
      string_match: "match_me"
    }
  }
}
)EOF");

  Buffer::InstancePtr body{new Buffer::OwnedImpl("garbage")};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::BadRequest,
                             "Request Body does not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->decodeData(*body, false));
}

TEST_F(AssertionFilterTest, RequestDataNoMatchWithEndStream) {
  setUpFilter(R"EOF(
match_config {
  http_request_generic_body_match {
    patterns {
      string_match: "match_me"
    }
  }
}
)EOF");

  Buffer::InstancePtr body{new Buffer::OwnedImpl("garbage")};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::BadRequest,
                             "Request Body does not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->decodeData(*body, true));
}

TEST_F(AssertionFilterTest, RequestDataMatchWithEndStreamAndTrailersMissing) {
  setUpFilter(R"EOF(
match_config {
  and_match {
    rules {
      http_request_generic_body_match {
        patterns {
          string_match: "match_me"
        }
      }
    }
    rules {
      http_request_trailers_match {
        headers {
          name: "test-trailer"
          exact_match: "test.code"
        }
      }
    }
  }
}
)EOF");

  Buffer::InstancePtr body{new Buffer::OwnedImpl("match_me")};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::BadRequest,
                             "Request Trailers do not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->decodeData(*body, true));
}

TEST_F(AssertionFilterTest, RequestDataNoMatchAfterTrailers) {
  setUpFilter(R"EOF(
match_config {
  and_match {
    rules {
      http_request_headers_match {
        headers {
          name: ":authority"
          exact_match: "test.code"
        }
      }
    }
    rules {
      http_request_generic_body_match {
        patterns {
          string_match: "match_me"
        }
      }
    }
  }
}
)EOF");

  Http::TestRequestHeaderMapImpl request_headers{{":authority", "test.code"}};
  Buffer::InstancePtr body{new Buffer::OwnedImpl("garbage")};
  Http::TestRequestTrailerMapImpl request_trailers{{"test-trailer", "test.code"}};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::BadRequest,
                             "Request Body does not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, false));
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(*body, false));
  EXPECT_EQ(Http::FilterTrailersStatus::StopIteration, filter_->decodeTrailers(request_trailers));
}

TEST_F(AssertionFilterTest, RequestTrailersMatch) {
  setUpFilter(R"EOF(
  match_config {
  http_request_trailers_match {
    headers {
      name: "test-trailer"
      exact_match: "test.code"
    }
  }
}
)EOF");

  Http::TestRequestTrailerMapImpl request_trailers{{"test-trailer", "test.code"}};

  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->decodeTrailers(request_trailers));
}

TEST_F(AssertionFilterTest, RequestTrailersNoMatch) {
  setUpFilter(R"EOF(
match_config {
  http_request_trailers_match {
    headers {
      name: "test-trailer"
      exact_match: "test.code"
    }
  }
}
)EOF");

  Http::TestRequestTrailerMapImpl request_trailers{{"test-trailer", "no.match"}};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::BadRequest,
                             "Request Trailers do not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterTrailersStatus::StopIteration, filter_->decodeTrailers(request_trailers));
}

TEST_F(AssertionFilterTest, ResponseHeadersMatchWithEndStream) {
  setUpFilter(R"EOF(
match_config {
  http_response_headers_match {
    headers {
      name: ":status"
      exact_match: "test.code"
    }
  }
}
)EOF");

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(response_headers, true));
}

TEST_F(AssertionFilterTest, ResponseHeadersMatch) {
  setUpFilter(R"EOF(
  match_config {
  http_response_headers_match {
    headers {
      name: ":status"
      exact_match: "test.code"
    }
  }
}
)EOF");

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};

  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(response_headers, false));
}

TEST_F(AssertionFilterTest, ResponseHeadersNoMatchWithEndStream) {
  setUpFilter(R"EOF(
match_config {
  http_response_headers_match {
    headers {
      name: ":status"
      exact_match: "test.code"
    }
  }
}
)EOF");

  Http::TestResponseHeaderMapImpl response_headers{{":status", "no.match"}};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::InternalServerError,
                             "Response Headers do not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->encodeHeaders(response_headers, true));
}

TEST_F(AssertionFilterTest, ResponseHeadersNoMatch) {
  setUpFilter(R"EOF(
  match_config {
  http_response_headers_match {
    headers {
      name: ":status"
      exact_match: "test.code"
    }
  }
}
)EOF");

  Http::TestResponseHeaderMapImpl response_headers{{":status", "no.match"}};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::InternalServerError,
                             "Response Headers do not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->encodeHeaders(response_headers, false));
}

TEST_F(AssertionFilterTest, ResponseHeadersMatchWithEndstreamAndDataMissing) {
  setUpFilter(R"EOF(
match_config {
  and_match {
    rules {
      http_response_headers_match {
        headers {
          name: ":status"
          exact_match: "test.code"
        }
      }
    }
    rules {
      http_response_generic_body_match {
        patterns {
          string_match: "match_me"
        }
      }
    }
  }
}
)EOF");

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::InternalServerError,
                             "Response Body does not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->encodeHeaders(response_headers, true));
}

TEST_F(AssertionFilterTest, ResponseHeadersMatchWithEndstreamAndTrailersMissing) {
  setUpFilter(R"EOF(
match_config {
  and_match {
    rules {
      http_response_headers_match {
        headers {
          name: ":status"
          exact_match: "test.code"
        }
      }
    }
    rules {
      http_response_trailers_match {
        headers {
          name: "test-trailer"
          exact_match: "test.code"
        }
      }
    }
  }
}
)EOF");

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::InternalServerError,
                             "Response Trailers do not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,
            filter_->encodeHeaders(response_headers, true));
}

TEST_F(AssertionFilterTest, ResponseDataMatchWithEndStream) {
  setUpFilter(R"EOF(
match_config {
  http_response_generic_body_match {
    patterns {
      string_match: "match_me"
    }
  }
}
)EOF");

  Buffer::InstancePtr body{new Buffer::OwnedImpl("match_me")};

  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(*body, true));
}

TEST_F(AssertionFilterTest, ResponseDataMatch) {
  setUpFilter(R"EOF(
match_config {
  http_response_generic_body_match {
    patterns {
      string_match: "match_me"
    }
  }
}
)EOF");

  Buffer::InstancePtr body{new Buffer::OwnedImpl("match_me")};

  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(*body, false));
}

TEST_F(AssertionFilterTest, ResponseDataNoMatchFastPath) {
  setUpFilter(R"EOF(
match_config {
  http_response_generic_body_match {
    bytes_limit: 1
    patterns {
      string_match: "match_me"
    }
  }
}
)EOF");

  Buffer::InstancePtr body{new Buffer::OwnedImpl("garbage")};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::InternalServerError,
                             "Response Body does not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->encodeData(*body, false));
}

TEST_F(AssertionFilterTest, ResponseDataNoMatchWithEndStream) {
  setUpFilter(R"EOF(
match_config {
  http_response_generic_body_match {
    patterns {
      string_match: "match_me"
    }
  }
}
)EOF");

  Buffer::InstancePtr body{new Buffer::OwnedImpl("garbage")};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::InternalServerError,
                             "Response Body does not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->encodeData(*body, true));
}

TEST_F(AssertionFilterTest, ResponseDataMatchWithEndStreamAndTrailersMissing) {
  setUpFilter(R"EOF(
match_config {
  and_match {
    rules {
      http_response_generic_body_match {
        patterns {
          string_match: "match_me"
        }
      }
    }
    rules {
      http_response_trailers_match {
        headers {
          name: "test-trailer"
          exact_match: "test.code"
        }
      }
    }
  }
}
)EOF");

  Buffer::InstancePtr body{new Buffer::OwnedImpl("match_me")};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::InternalServerError,
                             "Response Trailers do not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->encodeData(*body, true));
}

TEST_F(AssertionFilterTest, ResponseDataNoMatchAfterTrailers) {
  setUpFilter(R"EOF(
match_config {
  and_match {
    rules {
      http_response_headers_match {
        headers {
          name: ":status"
          exact_match: "test.code"
        }
      }
    }
    rules {
      http_response_generic_body_match {
        patterns {
          string_match: "match_me"
        }
      }
    }
  }
}
)EOF");

  Http::TestResponseHeaderMapImpl response_headers{{":status", "test.code"}};
  Buffer::InstancePtr body{new Buffer::OwnedImpl("garbage")};
  Http::TestResponseTrailerMapImpl response_trailers{{"test-trailer", "test.code"}};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::InternalServerError,
                             "Response Body does not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(response_headers, false));
  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(*body, false));
  EXPECT_EQ(Http::FilterTrailersStatus::StopIteration, filter_->encodeTrailers(response_trailers));
}

TEST_F(AssertionFilterTest, ResponseTrailersMatch) {
  setUpFilter(R"EOF(
match_config {
  http_response_trailers_match {
    headers {
      name: "test-trailer"
      exact_match: "test.code"
    }
  }
}
)EOF");

  Http::TestResponseTrailerMapImpl response_trailers{{"test-trailer", "test.code"}};

  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->encodeTrailers(response_trailers));
}

TEST_F(AssertionFilterTest, ResponseTrailersNoMatch) {
  setUpFilter(R"EOF(
match_config {
  http_response_trailers_match {
    headers {
      name: "test-trailer"
      exact_match: "test.code"
    }
  }
}
)EOF");

  Http::TestResponseTrailerMapImpl response_trailers{{"test-trailer", "no.match"}};

  EXPECT_CALL(decoder_callbacks_,
              sendLocalReply(Http::Code::InternalServerError,
                             "Response Trailers do not match configured expectations", _, _, ""));
  EXPECT_EQ(Http::FilterTrailersStatus::StopIteration, filter_->encodeTrailers(response_trailers));
}

TEST(AssertionFilterFactoryTest, Config) {
  AssertionFilterFactory factory;
  NiceMock<Server::Configuration::MockFactoryContext> context;

  envoymobile::extensions::filters::http::assertion::Assertion proto_config =
      *dynamic_cast<envoymobile::extensions::filters::http::assertion::Assertion*>(
          factory.createEmptyConfigProto().get());

  std::string config_str = R"EOF(
match_config {
  http_response_trailers_match {
    headers {
      name: "test-trailer"
      exact_match: "test.code"
    }
  }
}
)EOF";

  Protobuf::TextFormat::ParseFromString(config_str, &proto_config);

  Http::FilterFactoryCb cb =
      factory.createFilterFactoryFromProto(proto_config, "test", context).value();
  Http::MockFilterChainFactoryCallbacks filter_callbacks;
  EXPECT_CALL(filter_callbacks, addStreamFilter(_));
  cb(filter_callbacks);
}

} // namespace
} // namespace Assertion
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_cc_test",
    "envoy_mobile_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_proto_library(
    name = "filter",
    srcs = ["filter.proto"],
    deps = [
        "@envoy_api//envoy/config/common/matcher/v3:pkg",
    ],
)

envoy_cc_library(
    name = "assertion_filter_lib",
    srcs = ["filter.cc"],
    hdrs = ["filter.h"],
    repository = "@envoy",
    deps = [
        "filter_cc_proto",
        "@envoy//envoy/http:codes_interface",
        "@envoy//envoy/http:filter_interface",
        "@envoy//source/common/http:header_map_lib",
        "@envoy//source/extensions/common/matcher:matcher_lib",
        "@envoy//source/extensions/filters/http/common:pass_through_filter_lib",
    ],
)

envoy_cc_library(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    repository = "@envoy",
    deps = [
        ":assertion_filter_lib",
        "@envoy//source/extensions/filters/http/common:factory_base_lib",
    ],
)

envoy_cc_test(
    name = "assertion_filter_test",
    srcs = ["assertion_filter_test.cc"],
    repository = "@envoy",
    deps = [
        ":config",
        ":filter_cc_proto",
        "@envoy//test/mocks/http:http_mocks",
        "@envoy//test/mocks/server:factory_context_mocks",
        "@envoy//test/test_common:utility_lib",
    ],
)
#pragma once

#include "envoy/http/filter.h"

#include "source/extensions/common/matcher/matcher.h"
#include "source/extensions/filters/http/common/pass_through_filter.h"

#include "test/common/http/filters/assertion/filter.pb.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace Assertion {

class AssertionFilterConfig {
public:
  AssertionFilterConfig(
      const envoymobile::extensions::filters::http::assertion::Assertion& proto_config);

  Extensions::Common::Matcher::Matcher& rootMatcher() const;
  size_t matchersSize() const { return matchers_.size(); }

private:
  std::vector<Extensions::Common::Matcher::MatcherPtr> matchers_;
};

using AssertionFilterConfigSharedPtr = std::shared_ptr<AssertionFilterConfig>;

/**
 * Filter to assert expectations on HTTP requests.
 */
class AssertionFilter final : public Http::PassThroughFilter {
public:
  AssertionFilter(AssertionFilterConfigSharedPtr config);

  // StreamDecoderFilter
  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& headers,
                                          bool end_stream) override;
  Http::FilterDataStatus decodeData(Buffer::Instance& data, bool end_stream) override;
  Http::FilterTrailersStatus decodeTrailers(Http::RequestTrailerMap& trailers) override;

  // StreamEncoderFilter
  Http::FilterHeadersStatus encodeHeaders(Http::ResponseHeaderMap& headers,
                                          bool end_stream) override;
  Http::FilterDataStatus encodeData(Buffer::Instance& data, bool end_stream) override;
  Http::FilterTrailersStatus encodeTrailers(Http::ResponseTrailerMap& trailers) override;

private:
  const AssertionFilterConfigSharedPtr config_;
  Extensions::Common::Matcher::Matcher::MatchStatusVector statuses_;
};

} // namespace Assertion
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/assertion/config.h"

#include "test/common/http/filters/assertion/filter.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace Assertion {

Http::FilterFactoryCb AssertionFilterFactory::createFilterFactoryFromProtoTyped(
    const envoymobile::extensions::filters::http::assertion::Assertion& proto_config,
    const std::string&, Server::Configuration::FactoryContext&) {

  AssertionFilterConfigSharedPtr filter_config =
      std::make_shared<AssertionFilterConfig>(proto_config);
  return [filter_config](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamFilter(std::make_shared<AssertionFilter>(filter_config));
  };
}

/**
 * Static registration for the Assertion filter. @see NamedHttpFilterConfigFactory.
 */
REGISTER_FACTORY(AssertionFilterFactory, Server::Configuration::NamedHttpFilterConfigFactory);

} // namespace Assertion
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";

package envoymobile.extensions.filters.http.test_event_tracker;

message TestEventTracker {
  // The attributes to report as part of envoy event emitted by `TestEventTrackerFilter` filter.
  map<string, string> attributes = 1;
}
#pragma once

#include <string>

#include "source/extensions/filters/http/common/factory_base.h"

#include "test/common/http/filters/test_event_tracker/filter.h"
#include "test/common/http/filters/test_event_tracker/filter.pb.h"
#include "test/common/http/filters/test_event_tracker/filter.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestEventTracker {

/**
 * Config registration for the TestEventTracker filter. @see NamedHttpFilterConfigFactory.
 */
class TestEventTrackerFilterFactory
    : public Common::FactoryBase<
          envoymobile::extensions::filters::http::test_event_tracker::TestEventTracker> {
public:
  TestEventTrackerFilterFactory() : FactoryBase("test_event_tracker") {}

private:
  ::Envoy::Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoymobile::extensions::filters::http::test_event_tracker::TestEventTracker& config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

DECLARE_FACTORY(TestEventTrackerFilterFactory);

} // namespace TestEventTracker
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/test_event_tracker/filter.h"

#include "library/common/api/external.h"
#include "library/common/bridge/utility.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestEventTracker {

TestEventTrackerFilterConfig::TestEventTrackerFilterConfig(
    const envoymobile::extensions::filters::http::test_event_tracker::TestEventTracker&
        proto_config)
    : event_tracker_(static_cast<envoy_event_tracker*>(
          Api::External::retrieveApi(envoy_event_tracker_api_name))) {
  auto attributes = std::vector<std::pair<std::string, std::string>>();
  for (auto& pair : proto_config.attributes()) {
    attributes.push_back({std::string(pair.first), std::string(pair.second)});
  }
  attributes_ = attributes;
}

Http::FilterHeadersStatus TestEventTrackerFilter::decodeHeaders(Http::RequestHeaderMap&, bool) {
  config_->track(Bridge::Utility::makeEnvoyMap(config_->attributes()));
  return Http::FilterHeadersStatus::Continue;
}

} // namespace TestEventTracker
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_mobile_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_proto_library(
    name = "filter",
    srcs = ["filter.proto"],
    deps = [
        "@envoy_api//envoy/config/common/matcher/v3:pkg",
    ],
)

envoy_cc_library(
    name = "test_event_tracker_filter_lib",
    srcs = ["filter.cc"],
    hdrs = ["filter.h"],
    repository = "@envoy",
    deps = [
        "filter_cc_proto",
        "//library/common/api:c_types",
        "//library/common/api:external_api_lib",
        "//library/common/bridge:utility_lib",
        "//library/common/data:utility_lib",
        "@envoy//source/common/common:assert_lib",
        "@envoy//source/extensions/filters/http/common:pass_through_filter_lib",
    ],
)

envoy_cc_library(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    repository = "@envoy",
    deps = [
        ":test_event_tracker_filter_lib",
        "@envoy//source/extensions/filters/http/common:factory_base_lib",
    ],
)
#pragma once

#include "envoy/http/filter.h"

#include "source/extensions/filters/http/common/pass_through_filter.h"

#include "test/common/http/filters/test_event_tracker/filter.pb.h"

#include "library/common/api/c_types.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestEventTracker {

class TestEventTrackerFilterConfig {
public:
  TestEventTrackerFilterConfig(
      const envoymobile::extensions::filters::http::test_event_tracker::TestEventTracker&
          proto_config);

  std::vector<std::pair<std::string, std::string>> attributes() { return attributes_; };
  void track(envoy_map event) {
    if (event_tracker_->track != nullptr) {
      event_tracker_->track(event, event_tracker_->context);
    }
  };

private:
  std::vector<std::pair<std::string, std::string>> attributes_;
  const envoy_event_tracker* event_tracker_;
};

using TestEventTrackerFilterConfigSharedPtr = std::shared_ptr<TestEventTrackerFilterConfig>;

// The filter that emits preconfigured events. It's supposed to be used for
// testing of the event tracking functionality only.
class TestEventTrackerFilter final : public ::Envoy::Http::PassThroughFilter {
public:
  TestEventTrackerFilter(TestEventTrackerFilterConfigSharedPtr config) : config_(config) {}

  // StreamDecoderFilter
  ::Envoy::Http::FilterHeadersStatus decodeHeaders(::Envoy::Http::RequestHeaderMap& headers,
                                                   bool end_stream) override;

private:
  const TestEventTrackerFilterConfigSharedPtr config_;
};

} // namespace TestEventTracker
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/test_event_tracker/config.h"

#include "test/common/http/filters/test_event_tracker/filter.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestEventTracker {

Http::FilterFactoryCb TestEventTrackerFilterFactory::createFilterFactoryFromProtoTyped(
    const envoymobile::extensions::filters::http::test_event_tracker::TestEventTracker&
        proto_config,
    const std::string&, Server::Configuration::FactoryContext&) {

  auto config = std::make_shared<TestEventTrackerFilterConfig>(proto_config);
  return [config](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamFilter(std::make_shared<TestEventTrackerFilter>(config));
  };
}

/**
 * Static registration for the TestEventTracker filter. @see NamedHttpFilterConfigFactory.
 */
REGISTER_FACTORY(TestEventTrackerFilterFactory,
                 Server::Configuration::NamedHttpFilterConfigFactory);

} // namespace TestEventTracker
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";

package envoymobile.extensions.filters.http.test_accessor;

import "validate/validate.proto";

message TestAccessor {
  string accessor_name = 1 [(validate.rules).string.min_len = 1];
  string expected_string = 2 [(validate.rules).string.min_len = 1];
}
#pragma once

#include <string>

#include "source/extensions/filters/http/common/factory_base.h"

#include "test/common/http/filters/test_accessor/filter.h"
#include "test/common/http/filters/test_accessor/filter.pb.h"
#include "test/common/http/filters/test_accessor/filter.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestAccessor {

/**
 * Config registration for the TestAccessor filter. @see NamedHttpFilterConfigFactory.
 */
class TestAccessorFilterFactory
    : public Common::FactoryBase<
          envoymobile::extensions::filters::http::test_accessor::TestAccessor> {
public:
  TestAccessorFilterFactory() : FactoryBase("test_accessor") {}

private:
  ::Envoy::Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoymobile::extensions::filters::http::test_accessor::TestAccessor& config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

DECLARE_FACTORY(TestAccessorFilterFactory);

} // namespace TestAccessor
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/test_accessor/filter.h"

#include "envoy/server/filter_config.h"

#include "source/common/common/assert.h"

#include "library/common/data/utility.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestAccessor {

TestAccessorFilterConfig::TestAccessorFilterConfig(
    const envoymobile::extensions::filters::http::test_accessor::TestAccessor& proto_config)
    : accessor_(static_cast<envoy_string_accessor*>(
          Api::External::retrieveApi(proto_config.accessor_name()))),
      expected_string_(proto_config.expected_string()) {}

Http::FilterHeadersStatus TestAccessorFilter::decodeHeaders(Http::RequestHeaderMap&, bool) {
  RELEASE_ASSERT(config_->expectedString() ==
                     Data::Utility::copyToString(
                         config_->accessor()->get_string(config_->accessor()->context)),
                 "accessed string is not equal to expected string");
  return Http::FilterHeadersStatus::Continue;
}

} // namespace TestAccessor
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_mobile_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_proto_library(
    name = "filter",
    srcs = ["filter.proto"],
    deps = [
        "@envoy_api//envoy/config/common/matcher/v3:pkg",
    ],
)

envoy_cc_library(
    name = "test_accessor_filter_lib",
    srcs = ["filter.cc"],
    hdrs = ["filter.h"],
    repository = "@envoy",
    deps = [
        "filter_cc_proto",
        "//library/common/api:c_types",
        "//library/common/api:external_api_lib",
        "//library/common/data:utility_lib",
        "@envoy//source/common/common:assert_lib",
        "@envoy//source/extensions/filters/http/common:pass_through_filter_lib",
    ],
)

envoy_cc_library(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    repository = "@envoy",
    deps = [
        ":test_accessor_filter_lib",
        "@envoy//source/extensions/filters/http/common:factory_base_lib",
    ],
)
#pragma once

#include "envoy/http/filter.h"

#include "source/extensions/filters/http/common/pass_through_filter.h"

#include "test/common/http/filters/test_accessor/filter.pb.h"

#include "library/common/api/c_types.h"
#include "library/common/api/external.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestAccessor {

class TestAccessorFilterConfig {
public:
  TestAccessorFilterConfig(
      const envoymobile::extensions::filters::http::test_accessor::TestAccessor& proto_config);

  const envoy_string_accessor* accessor() const { return accessor_; }
  const std::string& expectedString() const { return expected_string_; }

private:
  const envoy_string_accessor* accessor_;
  const std::string expected_string_;
};

using TestAccessorFilterConfigSharedPtr = std::shared_ptr<TestAccessorFilterConfig>;

class TestAccessorFilter final : public ::Envoy::Http::PassThroughFilter {
public:
  TestAccessorFilter(TestAccessorFilterConfigSharedPtr config) : config_(config) {}

  // StreamDecoderFilter
  ::Envoy::Http::FilterHeadersStatus decodeHeaders(::Envoy::Http::RequestHeaderMap& headers,
                                                   bool end_stream) override;

private:
  const TestAccessorFilterConfigSharedPtr config_;
};

} // namespace TestAccessor
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/test_accessor/config.h"

#include "test/common/http/filters/test_accessor/filter.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestAccessor {

Http::FilterFactoryCb TestAccessorFilterFactory::createFilterFactoryFromProtoTyped(
    const envoymobile::extensions::filters::http::test_accessor::TestAccessor& proto_config,
    const std::string&, Server::Configuration::FactoryContext&) {

  auto config = std::make_shared<TestAccessorFilterConfig>(proto_config);
  return [config](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamFilter(std::make_shared<TestAccessorFilter>(config));
  };
}

/**
 * Static registration for the TestAccessor filter. @see NamedHttpFilterConfigFactory.
 */
REGISTER_FACTORY(TestAccessorFilterFactory, Server::Configuration::NamedHttpFilterConfigFactory);

} // namespace TestAccessor
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";

package envoymobile.extensions.filters.http.test_kv_store;

import "validate/validate.proto";

message TestKeyValueStore {
  string kv_store_name = 1 [(validate.rules).string.min_len = 1];
  string test_key = 2 [(validate.rules).string.min_len = 1];
  string test_value = 3 [(validate.rules).string.min_len = 1];
}
#pragma once

#include <string>

#include "source/extensions/filters/http/common/factory_base.h"

#include "test/common/http/filters/test_kv_store/filter.h"
#include "test/common/http/filters/test_kv_store/filter.pb.h"
#include "test/common/http/filters/test_kv_store/filter.pb.validate.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestKeyValueStore {

/**
 * Config registration for the TestKeyValueStore filter. @see NamedHttpFilterConfigFactory.
 */
class TestKeyValueStoreFilterFactory
    : public Common::FactoryBase<
          envoymobile::extensions::filters::http::test_kv_store::TestKeyValueStore> {
public:
  TestKeyValueStoreFilterFactory() : FactoryBase("test_kv_store") {}

private:
  ::Envoy::Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoymobile::extensions::filters::http::test_kv_store::TestKeyValueStore& config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

DECLARE_FACTORY(TestKeyValueStoreFilterFactory);

} // namespace TestKeyValueStore
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/test_kv_store/filter.h"

#include "envoy/server/filter_config.h"

#include "source/common/common/assert.h"

#include "library/common/data/utility.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestKeyValueStore {

TestKeyValueStoreFilterConfig::TestKeyValueStoreFilterConfig(
    const envoymobile::extensions::filters::http::test_kv_store::TestKeyValueStore& proto_config)
    : kv_store_(
          static_cast<envoy_kv_store*>(Api::External::retrieveApi(proto_config.kv_store_name()))) {}

Http::FilterHeadersStatus TestKeyValueStoreFilter::decodeHeaders(Http::RequestHeaderMap&, bool) {
  const auto store = config_->keyValueStore();
  auto key = Data::Utility::copyToBridgeData(config_->testKey());
  RELEASE_ASSERT(Data::Utility::copyToString(store->read(key, store->context)).empty(),
                 "store should be empty");

  envoy_data value = Data::Utility::copyToBridgeData(config_->testValue());
  store->save(key, value, store->context);
  return Http::FilterHeadersStatus::Continue;
}

Http::FilterHeadersStatus TestKeyValueStoreFilter::encodeHeaders(Http::ResponseHeaderMap&, bool) {
  const auto store = config_->keyValueStore();
  auto key = Data::Utility::copyToBridgeData(config_->testKey());
  RELEASE_ASSERT(Data::Utility::copyToString(store->read(key, store->context)) ==
                     config_->testValue(),
                 "store did not contain expected value");

  store->remove(key, store->context);
  RELEASE_ASSERT(Data::Utility::copyToString(store->read(key, store->context)).empty(),
                 "store should be empty");

  return Http::FilterHeadersStatus::Continue;
}
} // namespace TestKeyValueStore
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_mobile_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_proto_library(
    name = "filter",
    srcs = ["filter.proto"],
    deps = [
        "@envoy_api//envoy/config/common/matcher/v3:pkg",
    ],
)

envoy_cc_library(
    name = "test_kv_store_filter_lib",
    srcs = ["filter.cc"],
    hdrs = ["filter.h"],
    repository = "@envoy",
    deps = [
        "filter_cc_proto",
        "//library/common/api:c_types",
        "//library/common/api:external_api_lib",
        "//library/common/data:utility_lib",
        "//library/common/extensions/key_value/platform:config",
        "@envoy//source/common/common:assert_lib",
        "@envoy//source/extensions/filters/http/common:pass_through_filter_lib",
    ],
)

envoy_cc_library(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    repository = "@envoy",
    deps = [
        ":test_kv_store_filter_lib",
        "@envoy//source/extensions/filters/http/common:factory_base_lib",
    ],
)
#pragma once

#include "envoy/http/filter.h"

#include "source/extensions/filters/http/common/pass_through_filter.h"

#include "test/common/http/filters/test_kv_store/filter.pb.h"

#include "library/common/api/c_types.h"
#include "library/common/api/external.h"
#include "library/common/extensions/key_value/platform/c_types.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestKeyValueStore {

/**
 * This is a test-only filter used for validating PlatformKeyValueStore integrations. It retrieves
 * a known key-value store implementation and issues a series of fixed calls to it, allowing for
 * validation to be performed from platform code.
 *
 * TODO(goaway): Move to a location for test components outside of the main source tree.
 */
class TestKeyValueStoreFilterConfig {
public:
  TestKeyValueStoreFilterConfig(
      const envoymobile::extensions::filters::http::test_kv_store::TestKeyValueStore& proto_config);

  const envoy_kv_store* keyValueStore() const { return kv_store_; }
  const std::string& testKey() const { return test_key_; }
  const std::string& testValue() const { return test_value_; }

private:
  const envoy_kv_store* kv_store_;
  const std::string test_key_;
  const std::string test_value_;
};

using TestKeyValueStoreFilterConfigSharedPtr = std::shared_ptr<TestKeyValueStoreFilterConfig>;

class TestKeyValueStoreFilter final : public ::Envoy::Http::PassThroughFilter {
public:
  TestKeyValueStoreFilter(TestKeyValueStoreFilterConfigSharedPtr config) : config_(config) {}

  // StreamDecoderFilter
  ::Envoy::Http::FilterHeadersStatus decodeHeaders(::Envoy::Http::RequestHeaderMap& headers,
                                                   bool end_stream) override;
  // StreamEncoderFilter
  ::Envoy::Http::FilterHeadersStatus encodeHeaders(::Envoy::Http::ResponseHeaderMap& headers,
                                                   bool end_stream) override;

private:
  const TestKeyValueStoreFilterConfigSharedPtr config_;
};

} // namespace TestKeyValueStore
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
#include "test/common/http/filters/test_kv_store/config.h"

#include "test/common/http/filters/test_kv_store/filter.h"

namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace TestKeyValueStore {

Http::FilterFactoryCb TestKeyValueStoreFilterFactory::createFilterFactoryFromProtoTyped(
    const envoymobile::extensions::filters::http::test_kv_store::TestKeyValueStore& proto_config,
    const std::string&, Server::Configuration::FactoryContext&) {

  auto config = std::make_shared<TestKeyValueStoreFilterConfig>(proto_config);
  return [config](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamFilter(std::make_shared<TestKeyValueStoreFilter>(config));
  };
}

/**
 * Static registration for the TestKeyValueStore filter. @see NamedHttpFilterConfigFactory.
 */
REGISTER_FACTORY(TestKeyValueStoreFilterFactory,
                 Server::Configuration::NamedHttpFilterConfigFactory);

} // namespace TestKeyValueStore
} // namespace HttpFilters
} // namespace Extensions
} // namespace Envoy
syntax = "proto3";

package envoymobile.test.integration.filters.http.test_read;

message TestRead {
}
#pragma once

#include <string>

#include "source/extensions/filters/http/common/factory_base.h"

#include "test/common/http/filters/test_read/filter.pb.h"
#include "test/common/http/filters/test_read/filter.pb.validate.h"

namespace Envoy {
namespace HttpFilters {
namespace TestRead {

/**
 * Config registration for the TestRead filter. @see NamedHttpFilterConfigFactory.
 */
class TestReadFilterFactory
    : public Envoy::Extensions::HttpFilters::Common::FactoryBase<
          envoymobile::test::integration::filters::http::test_read::TestRead> {
public:
  TestReadFilterFactory() : FactoryBase("test_read") {}

private:
  ::Envoy::Http::FilterFactoryCb createFilterFactoryFromProtoTyped(
      const envoymobile::test::integration::filters::http::test_read::TestRead& config,
      const std::string& stats_prefix, Server::Configuration::FactoryContext& context) override;
};

DECLARE_FACTORY(TestReadFilterFactory);

} // namespace TestRead
} // namespace HttpFilters
} // namespace Envoy
#include "test/common/http/filters/test_read/filter.h"

#include "envoy/server/filter_config.h"

namespace Envoy {
namespace HttpFilters {
namespace TestRead {

Http::FilterHeadersStatus TestReadFilter::decodeHeaders(Http::RequestHeaderMap& request_headers,
                                                        bool) {
  // sample path is /failed?error=0x10000
  auto query_parameters = Http::Utility::QueryParamsMulti::parseQueryString(
      request_headers.Path()->value().getStringView());
  auto error = query_parameters.getFirstValue("error");
  uint64_t response_flag;
  if (error.has_value() && absl::SimpleAtoi(error.value(), &response_flag)) {
    // set response error code
    StreamInfo::StreamInfo& stream_info = decoder_callbacks_->streamInfo();
    stream_info.setResponseFlag(TestReadFilter::mapErrorToResponseFlag(response_flag));

    // check if we want a quic server error: sample path is /failed?quic=1&error=0x10000
    if (query_parameters.getFirstValue("quic").has_value()) {
      stream_info.setUpstreamInfo(std::make_shared<StreamInfo::UpstreamInfoImpl>());
      stream_info.upstreamInfo()->setUpstreamProtocol(Http::Protocol::Http3);
    }

    // trigger the error and stop iteration to other filters
    decoder_callbacks_->sendLocalReply(Http::Code::BadRequest, "test_read filter threw: ", nullptr,
                                       absl::nullopt, "");
    return Http::FilterHeadersStatus::StopIteration;
  }

  // continue to other filters since the provided query string is invalid for error simulation
  return Http::FilterHeadersStatus::Continue;
}

StreamInfo::ResponseFlag TestReadFilter::mapErrorToResponseFlag(uint64_t errorCode) {
  switch (errorCode) {
  case 0x4000000:
    return StreamInfo::DnsResolutionFailed;
  case 0x40:
    return StreamInfo::UpstreamConnectionTermination;
  case 0x20:
    return StreamInfo::UpstreamConnectionFailure;
  case 0x10:
    return StreamInfo::UpstreamRemoteReset;
  case 0x10000:
    return StreamInfo::StreamIdleTimeout;
  default:
    // Any other error that we aren't interested in. I picked a random error.
    return StreamInfo::RateLimitServiceError;
  }
}

} // namespace TestRead
} // namespace HttpFilters
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_mobile_package",
    "envoy_proto_library",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_proto_library(
    name = "filter",
    srcs = ["filter.proto"],
    deps = [
        "@envoy_api//envoy/config/common/matcher/v3:pkg",
    ],
)

envoy_cc_library(
    name = "test_read_filter_lib",
    srcs = ["filter.cc"],
    hdrs = ["filter.h"],
    repository = "@envoy",
    deps = [
        "filter_cc_proto",
        "@envoy//source/common/http:utility_lib",
        "@envoy//source/common/stream_info:stream_info_lib",
        "@envoy//source/extensions/filters/http/common:pass_through_filter_lib",
    ],
)

envoy_cc_library(
    name = "config",
    srcs = ["config.cc"],
    hdrs = ["config.h"],
    repository = "@envoy",
    deps = [
        ":test_read_filter_lib",
        "@envoy//source/extensions/filters/http/common:factory_base_lib",
    ],
)
#pragma once

#include "envoy/http/filter.h"

#include "source/common/common/logger.h"
#include "source/common/http/utility.h"
#include "source/common/stream_info/stream_info_impl.h"
#include "source/extensions/filters/http/common/pass_through_filter.h"

#include "test/common/http/filters/test_read/filter.pb.h"

namespace Envoy {
namespace HttpFilters {
namespace TestRead {

/**
 * This is a test-only filter to return specified error code based on a request url query string.
 * It either simulates the requested error if the url query matches the error patterns
 * or does nothing
 */
class TestReadFilter final : public Http::PassThroughFilter,
                             public Logger::Loggable<Logger::Id::filter> {
public:
  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& request_headers, bool) override;

private:
  /* A mapping of the envoymobile errors we care about for testing
   * From https://github.com/envoyproxy/envoy/blob/main/envoy/stream_info/stream_info.h
   */
  StreamInfo::ResponseFlag mapErrorToResponseFlag(uint64_t errorCode);
};

} // namespace TestRead
} // namespace HttpFilters
} // namespace Envoy
#include "test/common/http/filters/test_read/config.h"

#include "test/common/http/filters/test_read/filter.h"

namespace Envoy {
namespace HttpFilters {
namespace TestRead {

Http::FilterFactoryCb TestReadFilterFactory::createFilterFactoryFromProtoTyped(
    const envoymobile::test::integration::filters::http::test_read::TestRead& /*config*/,
    const std::string&, Server::Configuration::FactoryContext& /*context*/) {
  return [](Http::FilterChainFactoryCallbacks& callbacks) -> void {
    callbacks.addStreamDecoderFilter(std::make_shared<TestReadFilter>());
  };
}

/**
 * Static registration for the TestRead filter. @see NamedHttpFilterConfigFactory.
 */
REGISTER_FACTORY(TestReadFilterFactory, Server::Configuration::NamedHttpFilterConfigFactory);

} // namespace TestRead
} // namespace HttpFilters
} // namespace Envoy
#include <atomic>

#include "source/common/buffer/buffer_impl.h"
#include "source/common/http/context_impl.h"
#include "source/common/stats/isolated_store_impl.h"

#include "test/common/http/common.h"
#include "test/common/mocks/common/mocks.h"
#include "test/common/mocks/event/mocks.h"
#include "test/mocks/buffer/mocks.h"
#include "test/mocks/event/mocks.h"
#include "test/mocks/http/api_listener.h"
#include "test/mocks/http/mocks.h"
#include "test/mocks/local_info/mocks.h"
#include "test/mocks/upstream/mocks.h"

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "library/common/data/utility.h"
#include "library/common/http/client.h"
#include "library/common/http/header_utility.h"
#include "library/common/types/c_types.h"

using testing::_;
using testing::AnyNumber;
using testing::NiceMock;
using testing::Return;
using testing::ReturnPointee;
using testing::ReturnRef;
using testing::SaveArg;
using testing::WithArg;

namespace Envoy {
namespace Http {

// Based on Http::Utility::toRequestHeaders() but only used for these tests.
ResponseHeaderMapPtr toResponseHeaders(envoy_headers headers) {
  ResponseHeaderMapPtr transformed_headers = ResponseHeaderMapImpl::create();
  for (envoy_map_size_t i = 0; i < headers.length; i++) {
    transformed_headers->addCopy(
        LowerCaseString(Data::Utility::copyToString(headers.entries[i].key)),
        Data::Utility::copyToString(headers.entries[i].value));
  }
  // The C envoy_headers struct can be released now because the headers have been copied.
  release_envoy_headers(headers);
  return transformed_headers;
}

class TestHandle : public RequestDecoderHandle {
public:
  explicit TestHandle(MockRequestDecoder& decoder) : decoder_(decoder) {}

  ~TestHandle() override = default;

  OptRef<RequestDecoder> get() override { return {decoder_}; }

private:
  MockRequestDecoder& decoder_;
};

class ClientTest : public testing::TestWithParam<bool> {
public:
  typedef struct {
    uint32_t on_headers_calls;
    uint32_t on_data_calls;
    uint32_t on_trailers_calls;
    uint32_t on_complete_calls;
    uint32_t on_error_calls;
    uint32_t on_cancel_calls;
    uint32_t on_send_window_available_calls;
    std::string expected_status_;
    bool end_stream_with_headers_;
    std::string body_data_;
  } callbacks_called;

  ClientTest() {
    bridge_callbacks_.context = &cc_;

    // Set up default bridge callbacks. Indivividual tests can override.
    bridge_callbacks_.on_complete = [](envoy_stream_intel, envoy_final_stream_intel,
                                       void* context) -> void* {
      callbacks_called* cc = static_cast<callbacks_called*>(context);
      cc->on_complete_calls++;
      return nullptr;
    };
    bridge_callbacks_.on_headers = [](envoy_headers c_headers, bool end_stream, envoy_stream_intel,
                                      void* context) -> void* {
      ResponseHeaderMapPtr response_headers = toResponseHeaders(c_headers);
      callbacks_called* cc = static_cast<callbacks_called*>(context);
      EXPECT_EQ(end_stream, cc->end_stream_with_headers_);
      EXPECT_EQ(response_headers->Status()->value().getStringView(), cc->expected_status_);
      cc->on_headers_calls++;
      return nullptr;
    };
    bridge_callbacks_.on_error = [](envoy_error, envoy_stream_intel, envoy_final_stream_intel,
                                    void* context) -> void* {
      callbacks_called* cc = static_cast<callbacks_called*>(context);
      cc->on_error_calls++;
      return nullptr;
    };
    bridge_callbacks_.on_data = [](envoy_data c_data, bool, envoy_stream_intel,
                                   void* context) -> void* {
      callbacks_called* cc = static_cast<callbacks_called*>(context);
      cc->on_data_calls++;
      cc->body_data_ += Data::Utility::copyToString(c_data);
      release_envoy_data(c_data);
      return nullptr;
    };
    bridge_callbacks_.on_cancel = [](envoy_stream_intel, envoy_final_stream_intel,
                                     void* context) -> void* {
      callbacks_called* cc = static_cast<callbacks_called*>(context);
      cc->on_cancel_calls++;
      return nullptr;
    };
    bridge_callbacks_.on_send_window_available = [](envoy_stream_intel, void* context) -> void* {
      callbacks_called* cc = static_cast<callbacks_called*>(context);
      cc->on_send_window_available_calls++;
      return nullptr;
    };
    bridge_callbacks_.on_trailers = [](envoy_headers c_trailers, envoy_stream_intel,
                                       void* context) -> void* {
      ResponseHeaderMapPtr response_trailers = toResponseHeaders(c_trailers);
      EXPECT_TRUE(response_trailers.get() != nullptr);
      callbacks_called* cc = static_cast<callbacks_called*>(context);
      cc->on_trailers_calls++;
      return nullptr;
    };
    helper_handle_ = test::SystemHelperPeer::replaceSystemHelper();
    EXPECT_CALL(helper_handle_->mock_helper(), isCleartextPermitted(_))
        .WillRepeatedly(Return(true));
    EXPECT_CALL(dispatcher_, post_(_)).Times(AnyNumber()).WillRepeatedly([](Event::PostCb cb) {
      cb();
      return ENVOY_SUCCESS;
    });
  }

  envoy_headers defaultRequestHeaders() {
    // Build a set of request headers.
    TestRequestHeaderMapImpl headers;
    HttpTestUtility::addDefaultHeaders(headers);
    return Utility::toBridgeHeaders(headers);
  }

  void createStream() {
    ON_CALL(dispatcher_, isThreadSafe()).WillByDefault(Return(true));
    ON_CALL(*request_decoder_, streamInfo()).WillByDefault(ReturnRef(stream_info_));

    // Grab the response encoder in order to dispatch responses on the stream.
    // Return the request decoder to make sure calls are dispatched to the decoder via the
    // dispatcher API.
    EXPECT_CALL(*api_listener_, newStreamHandle(_, _))
        .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoderHandlePtr {
          response_encoder_ = &encoder;
          return std::make_unique<TestHandle>(*request_decoder_);
        }));
    http_client_.startStream(stream_, bridge_callbacks_, explicit_flow_control_);
  }

  void resumeDataIfExplicitFlowControl(int32_t bytes) {
    if (explicit_flow_control_) {
      auto callbacks = dynamic_cast<Client::DirectStreamCallbacks*>(response_encoder_);
      callbacks->resumeData(bytes);
    }
  }

  std::unique_ptr<MockApiListener> owned_api_listener_ = std::make_unique<MockApiListener>();
  MockApiListener* api_listener_ = owned_api_listener_.get();
  std::unique_ptr<NiceMock<MockRequestDecoder>> request_decoder_{
      std::make_unique<NiceMock<MockRequestDecoder>>()};
  NiceMock<StreamInfo::MockStreamInfo> stream_info_;
  ResponseEncoder* response_encoder_{};
  NiceMock<Event::MockProvisionalDispatcher> dispatcher_;
  envoy_http_callbacks bridge_callbacks_;
  callbacks_called cc_ = {0, 0, 0, 0, 0, 0, 0, "200", true, ""};
  NiceMock<Random::MockRandomGenerator> random_;
  Stats::IsolatedStoreImpl stats_store_;
  bool explicit_flow_control_{GetParam()};
  Client http_client_{std::move(owned_api_listener_), dispatcher_, *stats_store_.rootScope(),
                      random_};
  envoy_stream_t stream_ = 1;

protected:
  std::unique_ptr<test::SystemHelperPeer::Handle> helper_handle_;
};

INSTANTIATE_TEST_SUITE_P(TestModes, ClientTest, ::testing::Bool());

TEST_P(ClientTest, BasicStreamHeaders) {
  envoy_headers c_headers = defaultRequestHeaders();

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();

  // Send request headers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream_, c_headers, true);

  // Encode response headers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, true);
  ASSERT_EQ(cc_.on_headers_calls, 1);
  // Ensure that the callbacks on the bridge_callbacks_ were called.
  ASSERT_EQ(cc_.on_complete_calls, 1);
}

TEST_P(ClientTest, BasicStreamData) {
  cc_.end_stream_with_headers_ = false;

  bridge_callbacks_.on_data = [](envoy_data c_data, bool end_stream, envoy_stream_intel,
                                 void* context) -> void* {
    EXPECT_TRUE(end_stream);
    EXPECT_EQ(Data::Utility::copyToString(c_data), "response body");
    callbacks_called* cc = static_cast<callbacks_called*>(context);
    cc->on_data_calls++;
    release_envoy_data(c_data);
    return nullptr;
  };

  // Build body data
  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");
  envoy_data c_data = Data::Utility::toBridgeData(request_data);

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();

  // Send request data. Although HTTP would need headers before data this unit test only wants to
  // test data functionality.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(*request_decoder_, decodeData(BufferStringEqual("request body"), true));
  http_client_.sendData(stream_, c_data, true);
  resumeDataIfExplicitFlowControl(20);

  // Encode response data.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  Buffer::OwnedImpl response_data("response body");
  response_encoder_->encodeData(response_data, true);
  ASSERT_EQ(cc_.on_data_calls, 1);
  // Ensure that the callbacks on the bridge_callbacks_ were called.
  ASSERT_EQ(cc_.on_complete_calls, 1);
}

TEST_P(ClientTest, BasicStreamTrailers) {
  bridge_callbacks_.on_trailers = [](envoy_headers c_trailers, envoy_stream_intel,
                                     void* context) -> void* {
    ResponseHeaderMapPtr response_trailers = toResponseHeaders(c_trailers);
    EXPECT_EQ(response_trailers->get(LowerCaseString("x-test-trailer"))[0]->value().getStringView(),
              "test_trailer");
    callbacks_called* cc = static_cast<callbacks_called*>(context);
    cc->on_trailers_calls++;
    return nullptr;
  };

  // Build a set of request trailers.
  TestRequestTrailerMapImpl trailers;
  envoy_headers c_trailers = Utility::toBridgeHeaders(trailers);

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();

  // Send request trailers. Although HTTP would need headers before trailers this unit test only
  // wants to test trailers functionality.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(*request_decoder_, decodeTrailers_(_));
  http_client_.sendTrailers(stream_, c_trailers);
  resumeDataIfExplicitFlowControl(20);

  // Encode response trailers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  TestResponseTrailerMapImpl response_trailers{{"x-test-trailer", "test_trailer"}};
  response_encoder_->encodeTrailers(response_trailers);
  ASSERT_EQ(cc_.on_trailers_calls, 1);
  // Ensure that the callbacks on the bridge_callbacks_ were called.
  ASSERT_EQ(cc_.on_complete_calls, 1);
}

TEST_P(ClientTest, MultipleDataStream) {
  Event::MockDispatcher dispatcher;
  ON_CALL(dispatcher_, drain).WillByDefault([&](Event::Dispatcher& event_dispatcher) {
    dispatcher_.Event::ProvisionalDispatcher::drain(event_dispatcher);
  });
  dispatcher_.drain(dispatcher);
  Event::MockSchedulableCallback* process_buffered_data_callback = nullptr;
  if (explicit_flow_control_) {
    process_buffered_data_callback = new Event::MockSchedulableCallback(&dispatcher);
    EXPECT_CALL(*process_buffered_data_callback, scheduleCallbackNextIteration());
    ON_CALL(dispatcher_, createSchedulableCallback).WillByDefault([&](std::function<void()> cb) {
      return dispatcher_.Event::ProvisionalDispatcher::createSchedulableCallback(cb);
    });
  }

  cc_.end_stream_with_headers_ = false;

  envoy_headers c_headers = defaultRequestHeaders();

  // Build first body data
  Buffer::OwnedImpl request_data = Buffer::OwnedImpl("request body");
  envoy_data c_data = Data::Utility::toBridgeData(request_data);

  // Build second body data
  Buffer::OwnedImpl request_data2 = Buffer::OwnedImpl("request body2");
  envoy_data c_data2 = Data::Utility::toBridgeData(request_data2);

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();

  // Send request headers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, false));
  http_client_.sendHeaders(stream_, c_headers, false);

  // Send request data.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(*request_decoder_, decodeData(BufferStringEqual("request body"), false));
  http_client_.sendData(stream_, c_data, false);
  EXPECT_EQ(cc_.on_send_window_available_calls, 0);
  if (explicit_flow_control_) {
    EXPECT_TRUE(process_buffered_data_callback->enabled_);
    process_buffered_data_callback->invokeCallback();
    // The buffer is not full: expect an on_send_window_available call.
    EXPECT_EQ(cc_.on_send_window_available_calls, 1);
  }

  // Send second request data.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(*request_decoder_, decodeData(BufferStringEqual("request body2"), true));
  http_client_.sendData(stream_, c_data2, true);
  // The stream is done: no further on_send_window_available calls should happen.
  EXPECT_EQ(cc_.on_send_window_available_calls, explicit_flow_control_ ? 1 : 0);

  // Encode response headers and data.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_)).Times(3);
  EXPECT_CALL(dispatcher_, popTrackedObject(_)).Times(3);
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, false);
  ASSERT_EQ(cc_.on_headers_calls, 1);
  Buffer::OwnedImpl response_data("response body");
  response_encoder_->encodeData(response_data, false);
  resumeDataIfExplicitFlowControl(20);
  ASSERT_EQ(cc_.on_data_calls, 1);
  EXPECT_EQ("response body", cc_.body_data_);

  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  Buffer::OwnedImpl response_data2("response body2");
  response_encoder_->encodeData(response_data2, true);
  resumeDataIfExplicitFlowControl(20);
  ASSERT_EQ(cc_.on_data_calls, 2);
  EXPECT_EQ("response bodyresponse body2", cc_.body_data_);
  // Ensure that the callbacks on the bridge_callbacks_ were called.
  ASSERT_EQ(cc_.on_complete_calls, 1);
}

TEST_P(ClientTest, EmptyDataWithEndStream) {
  cc_.end_stream_with_headers_ = false;

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();
  // Send request headers.
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream_, defaultRequestHeaders(), true);

  // Encode response headers and data.
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, false);
  ASSERT_EQ(cc_.on_headers_calls, 1);
  Buffer::OwnedImpl response_data("response body");
  response_encoder_->encodeData(response_data, false);
  resumeDataIfExplicitFlowControl(20);
  ASSERT_EQ(cc_.on_data_calls, 1);
  EXPECT_EQ("response body", cc_.body_data_);

  // Make sure end of stream as communicated by an empty data with fin is
  // processed correctly.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  Buffer::OwnedImpl response_data2("");
  response_encoder_->encodeData(response_data2, true);
  resumeDataIfExplicitFlowControl(20);
  ASSERT_EQ(cc_.on_data_calls, 2);
  EXPECT_EQ("response body", cc_.body_data_);
  // Ensure that the callbacks on the bridge_callbacks_ were called.
  ASSERT_EQ(cc_.on_complete_calls, 1);
}

TEST_P(ClientTest, MultipleStreams) {
  envoy_stream_t stream1 = 1;
  envoy_stream_t stream2 = 2;

  envoy_headers c_headers = defaultRequestHeaders();
  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();

  // Send request headers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream1, c_headers, true);

  // Start stream2.
  // Setup bridge_callbacks_ to handle the response headers.
  NiceMock<MockRequestDecoder> request_decoder2;
  ON_CALL(request_decoder2, streamInfo()).WillByDefault(ReturnRef(stream_info_));
  ResponseEncoder* response_encoder2{};
  envoy_http_callbacks bridge_callbacks_2;
  callbacks_called cc2 = {0, 0, 0, 0, 0, 0, 0, "200", true, ""};
  bridge_callbacks_2.context = &cc2;
  bridge_callbacks_2.on_headers = [](envoy_headers c_headers, bool end_stream, envoy_stream_intel,
                                     void* context) -> void* {
    EXPECT_TRUE(end_stream);
    ResponseHeaderMapPtr response_headers = toResponseHeaders(c_headers);
    EXPECT_EQ(response_headers->Status()->value().getStringView(), "200");
    bool* on_headers_called2 = static_cast<bool*>(context);
    *on_headers_called2 = true;
    return nullptr;
  };
  bridge_callbacks_2.on_complete = [](envoy_stream_intel, envoy_final_stream_intel,
                                      void* context) -> void* {
    callbacks_called* cc = static_cast<callbacks_called*>(context);
    cc->on_complete_calls++;
    return nullptr;
  };

  envoy_headers c_headers2 = defaultRequestHeaders();

  // Create a stream.
  ON_CALL(dispatcher_, isThreadSafe()).WillByDefault(Return(true));

  // Grab the response encoder in order to dispatch responses on the stream.
  // Return the request decoder to make sure calls are dispatched to the decoder via the dispatcher
  // API.
  EXPECT_CALL(*api_listener_, newStreamHandle(_, _))
      .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoderHandlePtr {
        response_encoder2 = &encoder;
        return std::make_unique<TestHandle>(request_decoder2);
      }));
  http_client_.startStream(stream2, bridge_callbacks_2, explicit_flow_control_);

  // Send request headers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(request_decoder2, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream2, c_headers2, true);

  // Finish stream 2.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  TestResponseHeaderMapImpl response_headers2{{":status", "200"}};
  response_encoder2->encodeHeaders(response_headers2, true);
  ASSERT_EQ(cc2.on_headers_calls, 1);
  // Ensure that the on_headers on the bridge_callbacks_ was called.
  ASSERT_EQ(cc2.on_complete_calls, 1);

  // Finish stream 1.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, true);
  ASSERT_EQ(cc_.on_headers_calls, 1);
  ASSERT_EQ(cc_.on_complete_calls, 1);
}

TEST_P(ClientTest, EnvoyLocalError) {
  // Override the on_error default with some custom checks.
  bridge_callbacks_.on_error = [](envoy_error error, envoy_stream_intel, envoy_final_stream_intel,
                                  void* context) -> void* {
    EXPECT_EQ(error.error_code, ENVOY_CONNECTION_FAILURE);
    EXPECT_EQ(error.attempt_count, 123);
    callbacks_called* cc = static_cast<callbacks_called*>(context);
    cc->on_error_calls++;
    release_envoy_error(error);
    return nullptr;
  };

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();

  // Send request headers.
  envoy_headers c_headers = defaultRequestHeaders();
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream_, c_headers, true);

  // Encode response headers. A non-200 code triggers an on_error callback chain. In particular, a
  // 503 should have an ENVOY_CONNECTION_FAILURE error code.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  stream_info_.setResponseCode(503);
  stream_info_.setResponseCodeDetails("nope");
  stream_info_.setAttemptCount(123);
  response_encoder_->getStream().resetStream(Http::StreamResetReason::LocalConnectionFailure);
  ASSERT_EQ(cc_.on_headers_calls, 0);
  // Ensure that the callbacks on the bridge_callbacks_ were called.
  ASSERT_EQ(cc_.on_complete_calls, 0);
  ASSERT_EQ(cc_.on_error_calls, 1);
}

TEST_P(ClientTest, ResetStreamLocal) {
  // Create a stream.
  ON_CALL(dispatcher_, isThreadSafe()).WillByDefault(Return(true));

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();

  EXPECT_CALL(dispatcher_, pushTrackedObject(_)).Times(2);
  EXPECT_CALL(dispatcher_, popTrackedObject(_)).Times(2);
  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  http_client_.cancelStream(stream_);
  ASSERT_EQ(cc_.on_cancel_calls, 1);
  ASSERT_EQ(cc_.on_error_calls, 0);
  ASSERT_EQ(cc_.on_complete_calls, 0);
}

TEST_P(ClientTest, DoubleResetStreamLocal) {
  // Create a stream.
  ON_CALL(dispatcher_, isThreadSafe()).WillByDefault(Return(true));

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();

  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  EXPECT_CALL(dispatcher_, pushTrackedObject(_)).Times(2);
  EXPECT_CALL(dispatcher_, popTrackedObject(_)).Times(2);
  http_client_.cancelStream(stream_);

  // Second cancel call has no effect because stream is already cancelled.
  http_client_.cancelStream(stream_);

  ASSERT_EQ(cc_.on_cancel_calls, 1);
  ASSERT_EQ(cc_.on_error_calls, 0);
  ASSERT_EQ(cc_.on_complete_calls, 0);
}

TEST_P(ClientTest, RemoteResetAfterStreamStart) {
  cc_.end_stream_with_headers_ = false;

  bridge_callbacks_.on_error = [](envoy_error error, envoy_stream_intel, envoy_final_stream_intel,
                                  void* context) -> void* {
    EXPECT_EQ(error.error_code, ENVOY_STREAM_RESET);
    EXPECT_EQ(error.message.length, 0);
    EXPECT_EQ(error.attempt_count, 0);
    // This will use envoy_noop_release.
    release_envoy_error(error);
    callbacks_called* cc = static_cast<callbacks_called*>(context);
    cc->on_error_calls++;
    return nullptr;
  };

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();

  // Used to verify that when a reset is received, the Http::Client::DirectStream fires
  // runResetCallbacks. The Http::ConnectionManager depends on the Http::Client::DirectStream
  // firing this tight loop to let the Http::ConnectionManager clean up its stream state.
  Http::MockStreamCallbacks callbacks;
  response_encoder_->getStream().addCallbacks(callbacks);

  // Send request headers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  envoy_headers c_headers = defaultRequestHeaders();
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream_, c_headers, true);

  // Encode response headers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, false);
  ASSERT_EQ(cc_.on_headers_calls, 1);

  // Expect that when a reset is received, the Http::Client::DirectStream fires
  // runResetCallbacks. The Http::ConnectionManager depends on the Http::Client::DirectStream
  // firing this tight loop to let the Http::ConnectionManager clean up its stream state.
  resumeDataIfExplicitFlowControl(3);
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(callbacks, onResetStream(StreamResetReason::RemoteReset, _));
  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  response_encoder_->getStream().resetStream(StreamResetReason::RemoteReset);
  // Ensure that the on_error on the bridge_callbacks_ was called.
  ASSERT_EQ(cc_.on_error_calls, 1);
  ASSERT_EQ(cc_.on_complete_calls, 0);
}

TEST_P(ClientTest, StreamResetAfterOnComplete) {
  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();

  // Send request headers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  envoy_headers c_headers = defaultRequestHeaders();
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream_, c_headers, true);

  // Encode response headers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, true);
  ASSERT_EQ(cc_.on_headers_calls, 1);
  // Ensure that the callbacks on the bridge_callbacks_ were called.
  ASSERT_EQ(cc_.on_complete_calls, 1);

  // Cancellation should have no effect as the stream should have already been cleaned up.
  http_client_.cancelStream(stream_);
  ASSERT_EQ(cc_.on_cancel_calls, 0);
}

TEST_P(ClientTest, ResetWhenRemoteClosesBeforeLocal) {
  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();

  // Encode response headers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, true);
  ASSERT_EQ(cc_.on_headers_calls, 1);
  ASSERT_EQ(cc_.on_complete_calls, 1);

  // Fire stream reset because Envoy does not allow half-open streams on the local side.
  response_encoder_->getStream().resetStream(StreamResetReason::RemoteReset);
  ASSERT_EQ(cc_.on_error_calls, 0);
}

TEST_P(ClientTest, Encode100Continue) {
  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();

  // Send request headers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  envoy_headers c_headers = defaultRequestHeaders();
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream_, c_headers, true);

  // Encode 100 continue should blow up.
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
// Death tests are not supported on iOS.
#ifndef TARGET_OS_IOS
  EXPECT_DEATH(response_encoder_->encode1xxHeaders(response_headers), "panic: not implemented");
#endif
}

TEST_P(ClientTest, EncodeMetadata) {
  cc_.end_stream_with_headers_ = false;

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();

  // Send request headers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  envoy_headers c_headers = defaultRequestHeaders();
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream_, c_headers, true);

  // Encode response headers.
  EXPECT_CALL(dispatcher_, pushTrackedObject(_));
  EXPECT_CALL(dispatcher_, popTrackedObject(_));
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, false);
  ASSERT_EQ(cc_.on_headers_calls, 1);

  MetadataMap metadata_map = {{"key", "value"}};
  MetadataMapPtr metadata_map_ptr = std::make_unique<MetadataMap>(metadata_map);
  MetadataMapVector metadata_map_vector;
  metadata_map_vector.push_back(std::move(metadata_map_ptr));
// Death tests are not supported on iOS.
#ifndef TARGET_OS_IOS
  EXPECT_DEATH(response_encoder_->encodeMetadata(metadata_map_vector), "panic: not implemented");
#endif
}

TEST_P(ClientTest, NullAccessors) {
  envoy_stream_t stream = 1;
  envoy_http_callbacks bridge_callbacks;

  // Create a stream.
  ON_CALL(dispatcher_, isThreadSafe()).WillByDefault(Return(true));

  // Grab the response encoder in order to dispatch responses on the stream.
  // Return the request decoder to make sure calls are dispatched to the decoder via the dispatcher
  // API.
  EXPECT_CALL(*api_listener_, newStreamHandle(_, _))
      .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoderHandlePtr {
        response_encoder_ = &encoder;
        return std::make_unique<TestHandle>(*request_decoder_);
      }));
  http_client_.startStream(stream, bridge_callbacks, explicit_flow_control_);

  EXPECT_FALSE(response_encoder_->http1StreamEncoderOptions().has_value());
  EXPECT_FALSE(response_encoder_->streamErrorOnInvalidHttpMessage());
}

using ExplicitFlowControlTest = ClientTest;
INSTANTIATE_TEST_SUITE_P(TestExplicitFlowControl, ExplicitFlowControlTest, testing::Values(true));

TEST_P(ExplicitFlowControlTest, ShortRead) {
  cc_.end_stream_with_headers_ = false;

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream_, defaultRequestHeaders(), true);

  // Encode response headers and data.
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, false);

  // Test partial reads. Get 5 bytes but only pass 3 up.
  Buffer::OwnedImpl response_data("12345");
  response_encoder_->encodeData(response_data, true);

  // The stream is closed from Envoy's perspective. Make sure sanitizers will catch
  // any access to the decoder.
  request_decoder_.reset();

  resumeDataIfExplicitFlowControl(3);
  EXPECT_EQ("123", cc_.body_data_);
  ASSERT_EQ(cc_.on_complete_calls, 0);

  // Kick off more data, and the other two and the FIN should arrive.
  resumeDataIfExplicitFlowControl(3);
  EXPECT_EQ("12345", cc_.body_data_);
  ASSERT_EQ(cc_.on_complete_calls, 1);
}

TEST_P(ExplicitFlowControlTest, DataArrivedWhileBufferNonempty) {
  cc_.end_stream_with_headers_ = false;

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream_, defaultRequestHeaders(), true);

  // Encode response headers and data.
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, false);

  // Test partial reads. Get 5 bytes but only pass 3 up.
  Buffer::OwnedImpl response_data("12345");
  response_encoder_->encodeData(response_data, false);
  resumeDataIfExplicitFlowControl(3);
  EXPECT_EQ("123", cc_.body_data_);
  ASSERT_EQ(cc_.on_complete_calls, 0);

  Buffer::OwnedImpl response_data2("678910");
  response_encoder_->encodeData(response_data2, true);
  // The stream is closed from Envoy's perspective. Make sure sanitizers will catch
  // any access to the decoder.
  request_decoder_.reset();

  resumeDataIfExplicitFlowControl(20);
  EXPECT_EQ("12345678910", cc_.body_data_);
  ASSERT_EQ(cc_.on_complete_calls, 1);
}

TEST_P(ExplicitFlowControlTest, ResumeBeforeDataArrives) {
  cc_.end_stream_with_headers_ = false;

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream_, defaultRequestHeaders(), true);

  // Encode response headers and data.
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, false);

  // Ask for data before it arrives
  resumeDataIfExplicitFlowControl(5);

  // When data arrives it should be immediately passed up
  Buffer::OwnedImpl response_data("12345");
  response_encoder_->encodeData(response_data, true);
  // The stream is closed from Envoy's perspective. Make sure sanitizers will catch
  // any access to the decoder.
  request_decoder_.reset();
  EXPECT_EQ("12345", cc_.body_data_);
  ASSERT_EQ(cc_.on_complete_calls, true);
}

TEST_P(ExplicitFlowControlTest, ResumeWithFin) {
  cc_.end_stream_with_headers_ = false;

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();
  // Send request headers.
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream_, defaultRequestHeaders(), true);

  // Encode response headers and data.
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, false);
  ASSERT_EQ(cc_.on_headers_calls, 1);
  Buffer::OwnedImpl response_data("response body");
  response_encoder_->encodeData(response_data, false);
  resumeDataIfExplicitFlowControl(20);
  ASSERT_EQ(cc_.on_data_calls, 1);
  EXPECT_EQ("response body", cc_.body_data_);

  // Make sure end of stream as communicated by an empty data with end stream is
  // processed correctly if the resume is kicked off before the end stream arrives.
  resumeDataIfExplicitFlowControl(20);
  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  Buffer::OwnedImpl response_data2("");
  response_encoder_->encodeData(response_data2, true);
  // The stream is closed from Envoy's perspective. Make sure sanitizers will catch
  // any access to the decoder.
  request_decoder_.reset();
  ASSERT_EQ(cc_.on_data_calls, 2);
  EXPECT_EQ("response body", cc_.body_data_);
  // Ensure that the callbacks on the bridge_callbacks_ were called.
  ASSERT_EQ(cc_.on_complete_calls, 1);
}

TEST_P(ExplicitFlowControlTest, ResumeWithDataAndTrailers) {
  cc_.end_stream_with_headers_ = false;

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();
  // Send request headers.
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream_, defaultRequestHeaders(), true);

  // Encode response headers, data, and trailers.
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, false);
  ASSERT_EQ(cc_.on_headers_calls, 1);
  Buffer::OwnedImpl response_data("response body");
  response_encoder_->encodeData(response_data, false);
  TestResponseTrailerMapImpl response_trailers{{"x-test-trailer", "test_trailer"}};
  response_encoder_->encodeTrailers(response_trailers);
  // The stream is closed from Envoy's perspective. Make sure sanitizers will catch
  // any access to the decoder.
  request_decoder_.reset();

  // On the resume call, the data should be passed up, but not the trailers.
  resumeDataIfExplicitFlowControl(20);
  ASSERT_EQ(cc_.on_data_calls, 1);
  ASSERT_EQ(cc_.on_trailers_calls, 0);
  ASSERT_EQ(cc_.on_complete_calls, 0);
  EXPECT_EQ("response body", cc_.body_data_);

  EXPECT_TRUE(dispatcher_.to_delete_.empty());

  // On the next resume, trailers should be sent.
  resumeDataIfExplicitFlowControl(20);
  ASSERT_EQ(cc_.on_trailers_calls, 1);
  ASSERT_EQ(cc_.on_complete_calls, 1);
}

TEST_P(ExplicitFlowControlTest, CancelWithStreamComplete) {
  cc_.end_stream_with_headers_ = false;

  // Create a stream, and set up request_decoder_ and response_encoder_
  createStream();
  EXPECT_CALL(*request_decoder_, decodeHeaders_(_, true));
  http_client_.sendHeaders(stream_, defaultRequestHeaders(), true);

  // Encode response headers and data.
  TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  response_encoder_->encodeHeaders(response_headers, false);

  // When data arrives it should be buffered to send up
  Buffer::OwnedImpl response_data("12345");
  response_encoder_->encodeData(response_data, true);
  // The stream is closed from Envoy's perspective. Make sure sanitizers will catch
  // any access to the decoder.
  request_decoder_.reset();
  ASSERT_EQ(cc_.on_complete_calls, false);

  MockStreamCallbacks stream_callbacks;
  response_encoder_->getStream().addCallbacks(stream_callbacks);

  // make sure when the stream is canceled, the reset stream callbacks are
  // not called on the "closed" stream.
  EXPECT_CALL(dispatcher_, deferredDelete_(_));
  EXPECT_CALL(stream_callbacks, onResetStream(_, _)).Times(0);
  http_client_.cancelStream(stream_);
  ASSERT_EQ(cc_.on_cancel_calls, 1);
  ASSERT_EQ(cc_.on_error_calls, 0);
  ASSERT_EQ(cc_.on_complete_calls, 0);
}

} // namespace Http
} // namespace Envoy
#include "source/common/http/header_map_impl.h"

#include "gtest/gtest.h"
#include "library/common/bridge/utility.h"
#include "library/common/data/utility.h"
#include "library/common/http/header_utility.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Http {

void envoy_test_release(void* context) {
  uint32_t* counter = static_cast<uint32_t*>(context);
  *counter = *counter + 1;
}

envoy_data envoyTestString(std::string& s, uint32_t* sentinel) {
  return {s.size(), reinterpret_cast<const uint8_t*>(s.c_str()), envoy_test_release, sentinel};
}

TEST(RequestHeaderDataConstructorTest, FromCToCppEmpty) {
  std::map<std::string, std::string> empty_map;
  envoy_headers empty_headers = Bridge::Utility::makeEnvoyMap(empty_map);

  RequestHeaderMapPtr cpp_headers = Utility::toRequestHeaders(empty_headers);

  ASSERT_TRUE(cpp_headers->empty());
}

TEST(RequestTrailerDataConstructorTest, FromCToCppEmpty) {
  std::map<std::string, std::string> empty_map;
  envoy_headers empty_trailers = Bridge::Utility::makeEnvoyMap(empty_map);

  RequestTrailerMapPtr cpp_trailers = Utility::toRequestTrailers(empty_trailers);

  ASSERT_TRUE(cpp_trailers->empty());
}

TEST(RequestHeaderDataConstructorTest, FromCToCpp) {
  // Backing strings for all the envoy_datas in the c_headers.
  std::vector<std::pair<std::string, std::string>> headers = {
      {":method", "GET"}, {":scheme", "https"}, {":authority", "api.lyft.com"}, {":path", "/ping"}};

  envoy_map_entry* header_array =
      static_cast<envoy_map_entry*>(safe_malloc(sizeof(envoy_map_entry) * headers.size()));

  uint32_t* sentinel = new uint32_t;
  *sentinel = 0;
  for (size_t i = 0; i < headers.size(); i++) {
    header_array[i] = {
        envoyTestString(headers[i].first, sentinel),
        envoyTestString(headers[i].second, sentinel),
    };
  }

  envoy_headers c_headers = {static_cast<envoy_map_size_t>(headers.size()), header_array};
  // This copy is used for assertions given that envoy_headers are released when toRequestHeaders
  // is called.
  envoy_headers c_headers_copy = copy_envoy_headers(c_headers);

  RequestHeaderMapPtr cpp_headers = Utility::toRequestHeaders(c_headers);

  // Check that the sentinel was advance due to c_headers being released;
  ASSERT_EQ(*sentinel, 2 * c_headers_copy.length);

  ASSERT_EQ(cpp_headers->size(), c_headers_copy.length);

  for (envoy_map_size_t i = 0; i < c_headers_copy.length; i++) {
    auto expected_key = LowerCaseString(Data::Utility::copyToString(c_headers_copy.entries[i].key));
    auto expected_value = Data::Utility::copyToString(c_headers_copy.entries[i].value);

    // Key is present.
    EXPECT_FALSE(cpp_headers->get(expected_key).empty());
    // Value for the key is the same.
    EXPECT_EQ(cpp_headers->get(expected_key)[0]->value().getStringView(), expected_value);
  }
  release_envoy_headers(c_headers_copy);
  delete sentinel;
}

TEST(RequestTrailerDataConstructorTest, FromCToCpp) {
  // Backing strings for all the envoy_datas in the c_trailers.
  std::vector<std::pair<std::string, std::string>> trailers = {
      {"processing-duration-ms", "25"}, {"response-compression-ratio", "0.61"}};

  envoy_map_entry* header_array =
      static_cast<envoy_map_entry*>(safe_malloc(sizeof(envoy_map_entry) * trailers.size()));

  uint32_t* sentinel = new uint32_t;
  *sentinel = 0;
  for (size_t i = 0; i < trailers.size(); i++) {
    header_array[i] = {
        envoyTestString(trailers[i].first, sentinel),
        envoyTestString(trailers[i].second, sentinel),
    };
  }

  envoy_headers c_trailers = {static_cast<envoy_map_size_t>(trailers.size()), header_array};
  // This copy is used for assertions given that envoy_trailers are released when toRequestTrailers
  // is called.
  envoy_headers c_trailers_copy = copy_envoy_headers(c_trailers);

  RequestTrailerMapPtr cpp_trailers = Utility::toRequestTrailers(c_trailers);

  // Check that the sentinel was advance due to c_trailers being released;
  ASSERT_EQ(*sentinel, 2 * c_trailers_copy.length);

  ASSERT_EQ(cpp_trailers->size(), c_trailers_copy.length);

  for (envoy_map_size_t i = 0; i < c_trailers_copy.length; i++) {
    LowerCaseString expected_key(Data::Utility::copyToString(c_trailers_copy.entries[i].key));
    std::string expected_value = Data::Utility::copyToString(c_trailers_copy.entries[i].value);

    // Key is present.
    EXPECT_FALSE(cpp_trailers->get(expected_key).empty());
    // Value for the key is the same.
    EXPECT_EQ(cpp_trailers->get(expected_key)[0]->value().getStringView(), expected_value);
  }
  release_envoy_headers(c_trailers_copy);
  delete sentinel;
}

TEST(HeaderDataConstructorTest, FromCppToCEmpty) {
  RequestHeaderMapPtr empty_headers = RequestHeaderMapImpl::create();
  envoy_headers c_headers = Utility::toBridgeHeaders(*empty_headers);
  ASSERT_EQ(0, c_headers.length);
  release_envoy_headers(c_headers);
}

TEST(HeaderDataConstructorTest, FromCppToC) {
  RequestHeaderMapPtr cpp_headers = RequestHeaderMapImpl::create();
  cpp_headers->addCopy(LowerCaseString(std::string(":method")), std::string("GET"));
  cpp_headers->addCopy(LowerCaseString(std::string(":scheme")), std::string("https"));
  cpp_headers->addCopy(LowerCaseString(std::string(":authority")), std::string("api.lyft.com"));
  cpp_headers->addCopy(LowerCaseString(std::string(":path")), std::string("/ping"));

  envoy_headers c_headers = Utility::toBridgeHeaders(*cpp_headers);

  ASSERT_EQ(c_headers.length, static_cast<envoy_map_size_t>(cpp_headers->size()));

  for (envoy_map_size_t i = 0; i < c_headers.length; i++) {
    LowerCaseString actual_key(Data::Utility::copyToString(c_headers.entries[i].key));
    std::string actual_value = Data::Utility::copyToString(c_headers.entries[i].value);

    // Key is present.
    EXPECT_FALSE(cpp_headers->get(actual_key).empty());
    // Value for the key is the same.
    EXPECT_EQ(actual_value, cpp_headers->get(actual_key)[0]->value().getStringView());
  }

  release_envoy_headers(c_headers);
}

TEST(HeaderDataConstructorTest, FromCppToCWithAlpn) {
  RequestHeaderMapPtr cpp_headers = RequestHeaderMapImpl::create();
  cpp_headers->addCopy(LowerCaseString(std::string(":method")), std::string("GET"));
  cpp_headers->addCopy(LowerCaseString(std::string(":scheme")), std::string("https"));
  cpp_headers->addCopy(LowerCaseString(std::string(":authority")), std::string("api.lyft.com"));
  cpp_headers->addCopy(LowerCaseString(std::string(":path")), std::string("/ping"));

  envoy_headers c_headers = Utility::toBridgeHeaders(*cpp_headers, "h2");

  cpp_headers->addCopy(LowerCaseString(std::string("x-envoy-upstream-alpn")), std::string("h2"));
  ASSERT_EQ(c_headers.length, static_cast<envoy_map_size_t>(cpp_headers->size()));

  for (envoy_map_size_t i = 0; i < c_headers.length; i++) {
    LowerCaseString actual_key(Data::Utility::copyToString(c_headers.entries[i].key));
    std::string actual_value = Data::Utility::copyToString(c_headers.entries[i].value);

    // Key is present.
    EXPECT_FALSE(cpp_headers->get(actual_key).empty());
    // Value for the key is the same.
    EXPECT_EQ(actual_value, cpp_headers->get(actual_key)[0]->value().getStringView());
  }

  release_envoy_headers(c_headers);
}

} // namespace Http
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_test", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_test(
    name = "client_test",
    srcs = ["client_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/common/http:client_lib",
        "//library/common/http:header_utility_lib",
        "//library/common/types:c_types_lib",
        "//test/common/mocks/common:common_mocks",
        "//test/common/mocks/event:event_mocks",
        "@envoy//source/common/http:context_lib",
        "@envoy//source/common/stats:isolated_store_lib",
        "@envoy//test/common/http:common_lib",
        "@envoy//test/mocks/buffer:buffer_mocks",
        "@envoy//test/mocks/event:event_mocks",
        "@envoy//test/mocks/http:api_listener_mocks",
        "@envoy//test/mocks/local_info:local_info_mocks",
        "@envoy//test/mocks/upstream:upstream_mocks",
    ],
)

envoy_cc_test(
    name = "header_utility_test",
    srcs = ["header_utility_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/common/bridge:utility_lib",
        "//library/common/data:utility_lib",
        "//library/common/http:header_utility_lib",
        "//library/common/types:c_types_lib",
        "@envoy//source/common/buffer:buffer_lib",
        "@envoy//source/common/http:header_map_lib",
    ],
)
#include "absl/synchronization/notification.h"
#include "gtest/gtest.h"
#include "library/cc/engine_builder.h"
#include "library/common/engine.h"

namespace Envoy {

// RAII wrapper for the engine, ensuring that we properly shut down the engine. If the engine
// thread is not torn down, we end up with TSAN failures during shutdown due to a data race
// between the main thread and the engine thread both writing to the
// Envoy::Logger::current_log_context global.
struct TestEngine {
  std::unique_ptr<Engine> engine_;
  envoy_engine_t handle() { return reinterpret_cast<envoy_engine_t>(engine_.get()); }
  TestEngine(envoy_engine_callbacks callbacks, const std::string& level) {
    engine_.reset(new Envoy::Engine(callbacks, {}, {}));
    Platform::EngineBuilder builder;
    auto bootstrap = builder.generateBootstrap();
    std::string yaml = Envoy::MessageUtil::getYamlStringFromMessage(*bootstrap);
    engine_->run(yaml.c_str(), level.c_str());
  }

  envoy_status_t terminate() { return engine_->terminate(); }

  ~TestEngine() { engine_->terminate(); }
};

class EngineTest : public testing::Test {
public:
  std::unique_ptr<TestEngine> engine_;
};

typedef struct {
  absl::Notification on_engine_running;
  absl::Notification on_exit;
} engine_test_context;

TEST_F(EngineTest, EarlyExit) {
  const std::string level = "debug";

  engine_test_context test_context{};
  envoy_engine_callbacks callbacks{[](void* context) -> void {
                                     auto* engine_running =
                                         static_cast<engine_test_context*>(context);
                                     engine_running->on_engine_running.Notify();
                                   } /*on_engine_running*/,
                                   [](void* context) -> void {
                                     auto* exit = static_cast<engine_test_context*>(context);
                                     exit->on_exit.Notify();
                                   } /*on_exit*/,
                                   &test_context /*context*/};

  engine_ = std::make_unique<TestEngine>(callbacks, level);
  ASSERT_TRUE(test_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(10)));

  ASSERT_EQ(engine_->terminate(), ENVOY_SUCCESS);
  ASSERT_TRUE(test_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(10)));

  engine_->engine_->startStream(0, {}, false);

  engine_.reset();
}

TEST_F(EngineTest, AccessEngineAfterInitialization) {
  const std::string level = "debug";

  engine_test_context test_context{};
  envoy_engine_callbacks callbacks{[](void* context) -> void {
                                     auto* engine_running =
                                         static_cast<engine_test_context*>(context);
                                     engine_running->on_engine_running.Notify();
                                   } /*on_engine_running*/,
                                   [](void*) -> void {} /*on_exit*/, &test_context /*context*/};

  engine_ = std::make_unique<TestEngine>(callbacks, level);
  engine_->handle();
  ASSERT_TRUE(test_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(10)));

  absl::Notification getClusterManagerInvoked;
  envoy_data stats_data;
  // Running engine functions should work because the engine is running
  EXPECT_EQ(ENVOY_SUCCESS, engine_->engine_->dumpStats(&stats_data));
  release_envoy_data(stats_data);

  engine_->terminate();

  // Now that the engine has been shut down, we no longer expect scheduling to work.
  EXPECT_EQ(ENVOY_FAILURE, engine_->engine_->dumpStats(&stats_data));

  engine_.reset();
}

} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_test", "envoy_mobile_package")
load("@envoy//bazel:envoy_select.bzl", "envoy_select_enable_yaml")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_test(
    name = "engine_common_test",
    srcs = ["engine_common_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/cc:engine_builder_lib",
        "//library/common:engine_common_lib",
        "@envoy_build_config//:extension_registry",
    ],
)

envoy_cc_test(
    name = "engine_test",
    srcs = envoy_select_enable_yaml(
        ["engine_test.cc"],
        "@envoy",
    ),
    repository = "@envoy",
    deps = [
        "//library/cc:engine_builder_lib",
        "//library/common:engine_lib_no_stamp",
        "//library/common/types:c_types_lib",
        "@envoy//test/common/http:common_lib",
    ],
)

envoy_cc_test(
    name = "main_interface_test",
    srcs = envoy_select_enable_yaml(
        ["main_interface_test.cc"],
        "@envoy",
    ),
    repository = "@envoy",
    deps = [
        "//library/common:engine_lib_no_stamp",
        "//library/common/data:utility_lib",
        "//library/common/http:header_utility_lib",
        "//library/common/types:c_types_lib",
        "//test/common/mocks/common:common_mocks",
        "//test/common/mocks/event:event_mocks",
        "@envoy//test/common/http:common_lib",
        "@envoy_build_config//:test_extensions",
    ],
)
#include <jni.h>

#include "library/common/jni/jni_utility.h"

// NOLINT(namespace-envoy)

// This file contains JNI implementation used by
// `test/java/io/envoyproxy/envoymobile/jni/JniUtilityTest.java` unit tests.

extern "C" JNIEXPORT jbyteArray JNICALL
Java_io_envoyproxy_envoymobile_jni_JniUtilityTest_protoJavaByteArrayConversion(JNIEnv* env, jclass,
                                                                               jbyteArray source) {
  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::ProtobufWkt::Struct s;
  Envoy::JNI::javaByteArrayToProto(jni_helper, source, &s);
  return Envoy::JNI::protoToJavaByteArray(jni_helper, s).release();
}
#include <jni.h>

#include "library/common/jni/jni_helper.h"

// NOLINT(namespace-envoy)

// This file contains JNI implementation used by
// `test/java/io/envoyproxy/envoymobile/jni/JniHelperTest.java` unit tests.

extern "C" JNIEXPORT void JNICALL Java_io_envoyproxy_envoymobile_jni_JniHelperTest_getMethodId(
    JNIEnv* env, jclass, jclass clazz, jstring name, jstring signature) {
  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr name_ptr = jni_helper.getStringUtfChars(name, nullptr);
  Envoy::JNI::StringUtfUniquePtr sig_ptr = jni_helper.getStringUtfChars(signature, nullptr);
  jni_helper.getMethodId(clazz, name_ptr.get(), sig_ptr.get());
}

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_jni_JniHelperTest_getStaticMethodId(JNIEnv* env, jclass,
                                                                   jclass clazz, jstring name,
                                                                   jstring signature) {
  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr name_ptr = jni_helper.getStringUtfChars(name, nullptr);
  Envoy::JNI::StringUtfUniquePtr sig_ptr = jni_helper.getStringUtfChars(signature, nullptr);
  jni_helper.getStaticMethodId(clazz, name_ptr.get(), sig_ptr.get());
}

extern "C" JNIEXPORT jclass JNICALL Java_io_envoyproxy_envoymobile_jni_JniHelperTest_findClass(
    JNIEnv* env, jclass, jstring class_name) {
  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr class_name_ptr = jni_helper.getStringUtfChars(class_name, nullptr);
  Envoy::JNI::LocalRefUniquePtr<jclass> clazz = jni_helper.findClass(class_name_ptr.get());
  return clazz.release();
}

extern "C" JNIEXPORT jclass JNICALL Java_io_envoyproxy_envoymobile_jni_JniHelperTest_getObjectClass(
    JNIEnv* env, jclass, jobject object) {
  Envoy::JNI::JniHelper jni_helper(env);
  return jni_helper.getObjectClass(object).release();
}

extern "C" JNIEXPORT void JNICALL Java_io_envoyproxy_envoymobile_jni_JniHelperTest_throwNew(
    JNIEnv* env, jclass, jstring class_name, jstring message) {
  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr class_name_ptr = jni_helper.getStringUtfChars(class_name, nullptr);
  Envoy::JNI::StringUtfUniquePtr message_ptr = jni_helper.getStringUtfChars(message, nullptr);
  jni_helper.throwNew(class_name_ptr.get(), message_ptr.get());
}

extern "C" JNIEXPORT jobject JNICALL Java_io_envoyproxy_envoymobile_jni_JniHelperTest_newObject(
    JNIEnv* env, jclass, jclass clazz, jstring name, jstring signature) {
  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr name_ptr = jni_helper.getStringUtfChars(name, nullptr);
  Envoy::JNI::StringUtfUniquePtr sig_ptr = jni_helper.getStringUtfChars(signature, nullptr);
  jmethodID method_id = jni_helper.getMethodId(clazz, name_ptr.get(), sig_ptr.get());
  return jni_helper.newObject(clazz, method_id).release();
}

extern "C" JNIEXPORT jint JNICALL
Java_io_envoyproxy_envoymobile_jni_JniHelperTest_getArrayLength(JNIEnv* env, jclass, jarray array) {
  Envoy::JNI::JniHelper jni_helper(env);
  return jni_helper.getArrayLength(array);
}

#define DEFINE_JNI_NEW_ARRAY(JAVA_TYPE, JNI_TYPE)                                                  \
  extern "C" JNIEXPORT JNI_TYPE JNICALL                                                            \
      Java_io_envoyproxy_envoymobile_jni_JniHelperTest_new##JAVA_TYPE##Array(JNIEnv* env, jclass,  \
                                                                             jsize length) {       \
    Envoy::JNI::JniHelper jni_helper(env);                                                         \
    return jni_helper.new##JAVA_TYPE##Array(length).release();                                     \
  }

DEFINE_JNI_NEW_ARRAY(Byte, jbyteArray)
DEFINE_JNI_NEW_ARRAY(Char, jcharArray)
DEFINE_JNI_NEW_ARRAY(Short, jshortArray)
DEFINE_JNI_NEW_ARRAY(Int, jintArray)
DEFINE_JNI_NEW_ARRAY(Long, jlongArray)
DEFINE_JNI_NEW_ARRAY(Float, jfloatArray)
DEFINE_JNI_NEW_ARRAY(Double, jdoubleArray)
DEFINE_JNI_NEW_ARRAY(Boolean, jbooleanArray)

extern "C" JNIEXPORT jobjectArray JNICALL
Java_io_envoyproxy_envoymobile_jni_JniHelperTest_newObjectArray(JNIEnv* env, jclass, jsize length,
                                                                jclass element_class,
                                                                jobject initial_element) {
  Envoy::JNI::JniHelper jni_helper(env);
  return jni_helper.newObjectArray(length, element_class, initial_element).release();
}

#define DEFINE_JNI_GET_ARRAY_ELEMENTS(JAVA_TYPE, JNI_TYPE, VALUE)                                  \
  extern "C" JNIEXPORT JNI_TYPE JNICALL                                                            \
      Java_io_envoyproxy_envoymobile_jni_JniHelperTest_get##JAVA_TYPE##ArrayElements(              \
          JNIEnv* env, jclass, JNI_TYPE array) {                                                   \
    Envoy::JNI::JniHelper jni_helper(env);                                                         \
    auto array_elements = jni_helper.get##JAVA_TYPE##ArrayElements(array, nullptr);                \
    jsize length = jni_helper.getArrayLength(array);                                               \
    for (size_t i = 0; i < length; i++) {                                                          \
      array_elements.get()[i] = VALUE;                                                             \
    }                                                                                              \
    return array;                                                                                  \
  }

DEFINE_JNI_GET_ARRAY_ELEMENTS(Byte, jbyteArray, 123)
DEFINE_JNI_GET_ARRAY_ELEMENTS(Char, jcharArray, 'a')
DEFINE_JNI_GET_ARRAY_ELEMENTS(Short, jshortArray, 123)
DEFINE_JNI_GET_ARRAY_ELEMENTS(Int, jintArray, 123)
DEFINE_JNI_GET_ARRAY_ELEMENTS(Long, jlongArray, 123)
DEFINE_JNI_GET_ARRAY_ELEMENTS(Float, jfloatArray, 3.14)
DEFINE_JNI_GET_ARRAY_ELEMENTS(Double, jdoubleArray, 3.14)
DEFINE_JNI_GET_ARRAY_ELEMENTS(Boolean, jbooleanArray, true)

extern "C" JNIEXPORT jobject JNICALL
Java_io_envoyproxy_envoymobile_jni_JniHelperTest_getObjectArrayElement(JNIEnv* env, jclass,
                                                                       jobjectArray array,
                                                                       jsize index) {
  Envoy::JNI::JniHelper jni_helper(env);
  return jni_helper.getObjectArrayElement(array, index).release();
}

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_jni_JniHelperTest_setObjectArrayElement(JNIEnv* env, jclass,
                                                                       jobjectArray array,
                                                                       jsize index, jobject value) {
  Envoy::JNI::JniHelper jni_helper(env);
  jni_helper.setObjectArrayElement(array, index, value);
}

#define DEFINE_JNI_SET_ARRAY_REGION(JAVA_TYPE, JNI_TYPE)                                           \
  extern "C" JNIEXPORT void JNICALL                                                                \
      Java_io_envoyproxy_envoymobile_jni_JniHelperTest_set##JAVA_TYPE##ArrayRegion(                \
          JNIEnv* env, jclass, JNI_TYPE array, jsize start, jsize length, JNI_TYPE buffer) {       \
    Envoy::JNI::JniHelper jni_helper(env);                                                         \
    auto c_buffer = jni_helper.get##JAVA_TYPE##ArrayElements(buffer, nullptr);                     \
    env->Set##JAVA_TYPE##ArrayRegion(array, start, length, c_buffer.get());                        \
  }

DEFINE_JNI_SET_ARRAY_REGION(Byte, jbyteArray)
DEFINE_JNI_SET_ARRAY_REGION(Char, jcharArray)
DEFINE_JNI_SET_ARRAY_REGION(Short, jshortArray)
DEFINE_JNI_SET_ARRAY_REGION(Int, jintArray)
DEFINE_JNI_SET_ARRAY_REGION(Long, jlongArray)
DEFINE_JNI_SET_ARRAY_REGION(Float, jfloatArray)
DEFINE_JNI_SET_ARRAY_REGION(Double, jdoubleArray)
DEFINE_JNI_SET_ARRAY_REGION(Boolean, jbooleanArray)

#define DEFINE_JNI_CALL_METHOD(JAVA_TYPE, JNI_TYPE)                                                \
  extern "C" JNIEXPORT JNI_TYPE JNICALL                                                            \
      Java_io_envoyproxy_envoymobile_jni_JniHelperTest_call##JAVA_TYPE##Method(                    \
          JNIEnv* env, jclass, jclass clazz, jobject object, jstring name, jstring signature) {    \
    Envoy::JNI::JniHelper jni_helper(env);                                                         \
    Envoy::JNI::StringUtfUniquePtr name_ptr = jni_helper.getStringUtfChars(name, nullptr);         \
    Envoy::JNI::StringUtfUniquePtr sig_ptr = jni_helper.getStringUtfChars(signature, nullptr);     \
    jmethodID method_id = jni_helper.getMethodId(clazz, name_ptr.get(), sig_ptr.get());            \
    return jni_helper.call##JAVA_TYPE##Method(object, method_id);                                  \
  }

DEFINE_JNI_CALL_METHOD(Byte, jbyte)
DEFINE_JNI_CALL_METHOD(Char, jchar)
DEFINE_JNI_CALL_METHOD(Short, jshort)
DEFINE_JNI_CALL_METHOD(Int, jint)
DEFINE_JNI_CALL_METHOD(Long, jlong)
DEFINE_JNI_CALL_METHOD(Float, jfloat)
DEFINE_JNI_CALL_METHOD(Double, jdouble)
DEFINE_JNI_CALL_METHOD(Boolean, jboolean)

extern "C" JNIEXPORT void JNICALL Java_io_envoyproxy_envoymobile_jni_JniHelperTest_callVoidMethod(
    JNIEnv* env, jclass, jclass clazz, jobject object, jstring name, jstring signature) {
  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr name_ptr = jni_helper.getStringUtfChars(name, nullptr);
  Envoy::JNI::StringUtfUniquePtr sig_ptr = jni_helper.getStringUtfChars(signature, nullptr);
  jmethodID method_id = jni_helper.getMethodId(clazz, name_ptr.get(), sig_ptr.get());
  jni_helper.callVoidMethod(object, method_id);
}

extern "C" JNIEXPORT jobject JNICALL
Java_io_envoyproxy_envoymobile_jni_JniHelperTest_callObjectMethod(JNIEnv* env, jclass, jclass clazz,
                                                                  jobject object, jstring name,
                                                                  jstring signature) {
  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr name_ptr = jni_helper.getStringUtfChars(name, nullptr);
  Envoy::JNI::StringUtfUniquePtr sig_ptr = jni_helper.getStringUtfChars(signature, nullptr);
  jmethodID method_id = jni_helper.getMethodId(clazz, name_ptr.get(), sig_ptr.get());
  return jni_helper.callObjectMethod(object, method_id).release();
}

#define DEFINE_JNI_CALL_STATIC_METHOD(JAVA_TYPE, JNI_TYPE)                                         \
  extern "C" JNIEXPORT JNI_TYPE JNICALL                                                            \
      Java_io_envoyproxy_envoymobile_jni_JniHelperTest_callStatic##JAVA_TYPE##Method(              \
          JNIEnv* env, jclass, jclass clazz, jstring name, jstring signature) {                    \
    Envoy::JNI::JniHelper jni_helper(env);                                                         \
    Envoy::JNI::StringUtfUniquePtr name_ptr = jni_helper.getStringUtfChars(name, nullptr);         \
    Envoy::JNI::StringUtfUniquePtr sig_ptr = jni_helper.getStringUtfChars(signature, nullptr);     \
    jmethodID method_id = jni_helper.getStaticMethodId(clazz, name_ptr.get(), sig_ptr.get());      \
    return jni_helper.callStatic##JAVA_TYPE##Method(clazz, method_id);                             \
  }

DEFINE_JNI_CALL_STATIC_METHOD(Byte, jbyte)
DEFINE_JNI_CALL_STATIC_METHOD(Char, jchar)
DEFINE_JNI_CALL_STATIC_METHOD(Short, jshort)
DEFINE_JNI_CALL_STATIC_METHOD(Int, jint)
DEFINE_JNI_CALL_STATIC_METHOD(Long, jlong)
DEFINE_JNI_CALL_STATIC_METHOD(Float, jfloat)
DEFINE_JNI_CALL_STATIC_METHOD(Double, jdouble)
DEFINE_JNI_CALL_STATIC_METHOD(Boolean, jboolean)

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_jni_JniHelperTest_callStaticVoidMethod(JNIEnv* env, jclass,
                                                                      jclass clazz, jstring name,
                                                                      jstring signature) {
  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr name_ptr = jni_helper.getStringUtfChars(name, nullptr);
  Envoy::JNI::StringUtfUniquePtr sig_ptr = jni_helper.getStringUtfChars(signature, nullptr);
  jmethodID method_id = jni_helper.getStaticMethodId(clazz, name_ptr.get(), sig_ptr.get());
  jni_helper.callStaticVoidMethod(clazz, method_id);
}

extern "C" JNIEXPORT jobject JNICALL
Java_io_envoyproxy_envoymobile_jni_JniHelperTest_callStaticObjectMethod(JNIEnv* env, jclass,
                                                                        jclass clazz, jstring name,
                                                                        jstring signature) {
  Envoy::JNI::JniHelper jni_helper(env);
  Envoy::JNI::StringUtfUniquePtr name_ptr = jni_helper.getStringUtfChars(name, nullptr);
  Envoy::JNI::StringUtfUniquePtr sig_ptr = jni_helper.getStringUtfChars(signature, nullptr);
  jmethodID method_id = jni_helper.getStaticMethodId(clazz, name_ptr.get(), sig_ptr.get());
  return jni_helper.callStaticObjectMethod(clazz, method_id).release();
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("//bazel:kotlin_lib.bzl", "envoy_mobile_so_to_jni_lib")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

# Library which contains all the JNI related targets and test extensions
cc_library(
    name = "envoy_jni_with_test_extensions_lib",
    testonly = True,
    deps = [
        ":server_envoy_jni_lib",
        "//library/common/jni:envoy_jni_lib",
        "@envoy_build_config//:test_extensions",
    ],
)

# Library which contains all the JNI related targets.
cc_library(
    name = "server_envoy_jni_lib",
    testonly = True,
    srcs = [
        "test_jni_impl.cc",
    ],
    linkopts = select({
        "@envoy//bazel:dbg_build": ["-Wl,--build-id=sha1"],
        "//conditions:default": [],
    }),
    deps = [
        "//library/common/jni:envoy_jni_lib",
        "//test/common/integration:test_server_interface_lib",
        "//test/common/integration:xds_test_server_interface_lib",
    ],
    # We need this to ensure that we link this into the .so even though there are no code references.
    alwayslink = True,
)

# Base binary (.so) for testing
cc_binary(
    name = "libenvoy_jni_with_test_extensions.so",
    testonly = True,
    linkshared = True,
    deps = [
        ":envoy_jni_with_test_extensions_lib",
        "@envoy_mobile_extra_jni_deps//:extra_jni_dep",
    ],
)

## Targets for local execution
# macOS binary (.jnilib) for testing
envoy_mobile_so_to_jni_lib(
    name = "libenvoy_jni_with_test_extensions_jnilib",
    testonly = True,
    native_dep = "libenvoy_jni_with_test_extensions.so",
)

# Same as above but with listener extensions too.
# This hard-codes the listener manager lib rather than doing a select, so that the kotlin
# proxy tests can run in builds which select out the listener for E-M.
cc_library(
    name = "envoy_jni_with_test_and_listener_extensions_lib",
    testonly = True,
    deps = [
        ":server_envoy_jni_lib",
        "//library/common/jni:envoy_jni_lib",
        "@envoy//source/common/listener_manager:listener_manager_lib",
    ],
)

cc_binary(
    name = "libenvoy_jni_with_test_and_listener_extensions.so",
    testonly = True,
    linkshared = True,
    deps = [
        ":envoy_jni_with_test_and_listener_extensions_lib",
        "@envoy_mobile_extra_jni_deps//:extra_jni_dep",
    ],
)

envoy_mobile_so_to_jni_lib(
    name = "libenvoy_jni_with_test_and_listener_extensions_jnilib",
    testonly = True,
    native_dep = "libenvoy_jni_with_test_and_listener_extensions.so",
)

cc_library(
    name = "jni_helper_test_lib",
    srcs = [
        "jni_helper_test.cc",
    ],
    deps = [
        "//library/common/jni:jni_helper_lib",
    ],
    alwayslink = True,
)

cc_binary(
    name = "libenvoy_jni_helper_test.so",
    testonly = True,
    linkshared = True,
    deps = [
        ":jni_helper_test_lib",
    ],
)

cc_library(
    name = "jni_utility_test_lib",
    srcs = [
        "jni_utility_test.cc",
    ],
    deps = [
        "//library/common/jni:jni_utility_lib",
    ],
    alwayslink = True,
)

cc_binary(
    name = "libenvoy_jni_utility_test.so",
    testonly = True,
    linkshared = True,
    deps = [
        ":jni_utility_test_lib",
    ],
)
#include <jni.h>

#include "test/common/integration/test_server_interface.h"
#include "test/common/integration/xds_test_server_interface.h"
#include "test/test_common/utility.h"

#include "library/common/jni/jni_support.h"

// NOLINT(namespace-envoy)

// Quic Test ServerJniLibrary

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_testing_TestJni_nativeStartHttpProxyTestServer(JNIEnv* env,
                                                                                     jclass clazz) {
  jni_log("[QTS]", "starting server");
  start_server(Envoy::TestServerType::HTTP_PROXY);
}

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_testing_TestJni_nativeStartHttpsProxyTestServer(
    JNIEnv* env, jclass clazz) {
  jni_log("[QTS]", "starting server");
  start_server(Envoy::TestServerType::HTTPS_PROXY);
}

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_testing_TestJni_nativeStartHttp3TestServer(JNIEnv* env,
                                                                                 jclass clazz) {
  jni_log("[QTS]", "starting server");
  start_server(Envoy::TestServerType::HTTP3);
}

extern "C" JNIEXPORT jint JNICALL
Java_io_envoyproxy_envoymobile_engine_testing_TestJni_nativeGetServerPort(JNIEnv* env,
                                                                          jclass clazz) {
  jni_log("[QTS]", "getting server port");
  return get_server_port();
}

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_testing_TestJni_nativeStartHttp2TestServer(JNIEnv* env,
                                                                                 jclass clazz) {
  jni_log("[QTS]", "starting server");
  start_server(Envoy::TestServerType::HTTP2_WITH_TLS);
}

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_testing_TestJni_nativeShutdownTestServer(JNIEnv* env,
                                                                               jclass clazz) {
  jni_log("[QTS]", "shutting down server");
  shutdown_server();
}

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_testing_TestJni_nativeInitXdsTestServer(JNIEnv* env,
                                                                              jclass clazz) {
  jni_log("[XTS]", "initializing xDS server");
  initXdsServer();
}

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_testing_TestJni_nativeStartXdsTestServer(JNIEnv* env,
                                                                               jclass clazz) {
  jni_log("[XTS]", "starting xDS server");
  startXdsServer();
}

extern "C" JNIEXPORT jstring JNICALL
Java_io_envoyproxy_envoymobile_engine_testing_TestJni_nativeGetXdsTestServerHost(JNIEnv* env,
                                                                                 jclass clazz) {
  jni_log("[XTS]", "getting xDS server host");
  return env->NewStringUTF(getXdsServerHost());
}

extern "C" JNIEXPORT jint JNICALL
Java_io_envoyproxy_envoymobile_engine_testing_TestJni_nativeGetXdsTestServerPort(JNIEnv* env,
                                                                                 jclass clazz) {
  jni_log("[XTS]", "getting xDS server port");
  return getXdsServerPort();
}

#ifdef ENVOY_ENABLE_YAML
extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_testing_TestJni_nativeSendDiscoveryResponse(JNIEnv* env,
                                                                                  jclass clazz,
                                                                                  jstring yaml) {
  jni_log("[XTS]", "sending DiscoveryResponse from the xDS server");
  const char* yaml_chars = env->GetStringUTFChars(yaml, /* isCopy= */ nullptr);
  // The yaml utilities have non-relevant thread asserts.
  Envoy::Thread::SkipAsserts skip;
  envoy::service::discovery::v3::DiscoveryResponse response;
  Envoy::TestUtility::loadFromYaml(yaml_chars, response);
  sendDiscoveryResponse(response);
  env->ReleaseStringUTFChars(yaml, yaml_chars);
}
#endif

extern "C" JNIEXPORT void JNICALL
Java_io_envoyproxy_envoymobile_engine_testing_TestJni_nativeShutdownXdsTestServer(JNIEnv* env,
                                                                                  jclass clazz) {
  jni_log("[XTS]", "shutting down xDS server");
  shutdownXdsServer();
}

#ifdef ENVOY_ENABLE_YAML
extern "C" JNIEXPORT jstring JNICALL
Java_io_envoyproxy_envoymobile_engine_testing_TestJni_nativeCreateYaml(JNIEnv* env, jclass,
                                                                       jlong bootstrap_ptr) {
  Envoy::Thread::SkipAsserts skip_asserts;
  std::unique_ptr<envoy::config::bootstrap::v3::Bootstrap> bootstrap(
      reinterpret_cast<envoy::config::bootstrap::v3::Bootstrap*>(bootstrap_ptr));
  std::string yaml = Envoy::MessageUtil::getYamlStringFromMessage(*bootstrap);
  return env->NewStringUTF(yaml.c_str());
}
#endif
#include "source/common/buffer/buffer_impl.h"

#include "gtest/gtest.h"
#include "library/common/data/utility.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Data {

TEST(DataConstructorTest, FromCToCppEmpty) {
  envoy_data empty_data = {0, nullptr, free, nullptr};

  Buffer::InstancePtr cpp_data = Utility::toInternalData(empty_data);

  ASSERT_EQ(cpp_data->length(), 0);
}

TEST(DataConstructorTest, FromCToCpp) {
  std::string s = "test string";
  envoy_data c_data = {s.size(), reinterpret_cast<const uint8_t*>(s.c_str()), free, nullptr};
  ;

  Buffer::InstancePtr cpp_data = Utility::toInternalData(c_data);

  ASSERT_EQ(cpp_data->length(), c_data.length);
  ASSERT_EQ(cpp_data->toString(), s);
}

TEST(DataConstructorTest, FromCppToCEmpty) {
  Buffer::OwnedImpl empty_data;

  envoy_data c_data = Utility::toBridgeData(empty_data);

  ASSERT_EQ(c_data.length, 0);
  release_envoy_data(c_data);
}

TEST(DataConstructorTest, FromCppToC) {
  std::string s = "test string";
  Buffer::OwnedImpl cpp_data = Buffer::OwnedImpl(absl::string_view(s));

  envoy_data c_data = Utility::toBridgeData(cpp_data);

  ASSERT_EQ(c_data.length, s.size());
  ASSERT_EQ(Utility::copyToString(c_data), s);
  release_envoy_data(c_data);
}

TEST(DataConstructorTest, FromCppToCPartial) {
  std::string s = "test string";
  Buffer::OwnedImpl cpp_data = Buffer::OwnedImpl(absl::string_view(s));

  envoy_data c_data = Utility::toBridgeData(cpp_data, 4);

  ASSERT_EQ(c_data.length, 4);
  ASSERT_EQ(Utility::copyToString(c_data), "test");
  ASSERT_EQ(cpp_data.length(), 7);
  ASSERT_EQ(cpp_data.toString(), " string");
  release_envoy_data(c_data);
}

TEST(DataConstructorTest, CopyFromCppToC) {
  std::string s = "test string";
  Buffer::OwnedImpl cpp_data = Buffer::OwnedImpl(absl::string_view(s));

  envoy_data c_data = Utility::copyToBridgeData(cpp_data);

  ASSERT_EQ(c_data.length, s.size());
  ASSERT_EQ(Utility::copyToString(c_data), s);
  release_envoy_data(c_data);
}

TEST(DataConstructorTest, CopyFromCppToCPartial) {
  std::string s = "test string";
  Buffer::OwnedImpl cpp_data = Buffer::OwnedImpl(absl::string_view(s));

  envoy_data c_data = Utility::copyToBridgeData(cpp_data, 4);

  ASSERT_EQ(c_data.length, 4);
  ASSERT_EQ(Utility::copyToString(c_data), "test");
  ASSERT_EQ(cpp_data.length(), 11);
  ASSERT_EQ(cpp_data.toString(), "test string");
  release_envoy_data(c_data);
}

TEST(DataConstructorTest, CopyStringFromCppToC) {
  std::string s = "test string";

  envoy_data c_data = Utility::copyToBridgeData(s);

  ASSERT_EQ(c_data.length, s.size());
  ASSERT_EQ(Utility::copyToString(c_data), s);
  release_envoy_data(c_data);
}

} // namespace Data
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_test", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_test(
    name = "utility_test",
    srcs = ["utility_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/common/data:utility_lib",
        "//library/common/types:c_types_lib",
        "@envoy//source/common/buffer:buffer_lib",
    ],
)
#include "source/common/common/thread.h"

#include "gtest/gtest.h"
#include "library/common/thread/lock_guard.h"

namespace Envoy {
namespace Thread {

class ThreadTest : public testing::Test {
protected:
  ThreadTest() = default;
  int a_ ABSL_GUARDED_BY(a_mutex_){0};
  MutexBasicLockable a_mutex_;
  int b_{0};
};

TEST_F(ThreadTest, TestOptionalReleasableLockGuard) {
  OptionalReleasableLockGuard lock(nullptr);
  EXPECT_EQ(1, ++b_);

  OptionalReleasableLockGuard lock2(&a_mutex_);
  EXPECT_EQ(1, ++a_);
  lock2.release();
}

} // namespace Thread
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_test", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_test(
    name = "lock_guard_test",
    srcs = ["lock_guard_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/common/thread:lock_guard_lib",
        "@envoy//source/common/common:thread_lib",
    ],
)
#include "envoy/stats/scope.h"

#include "test/common/stats/stat_test_utility.h"

#include "gtest/gtest.h"
#include "library/common/data/utility.h"
#include "library/common/stats/utility.h"

namespace Envoy {
namespace Stats {
namespace Utility {

envoy_stats_tags make_envoy_stats_tags(std::vector<std::pair<std::string, std::string>> pairs) {
  envoy_map_entry* tags =
      static_cast<envoy_map_entry*>(safe_malloc(sizeof(envoy_map_entry) * pairs.size()));
  envoy_stats_tags new_tags;
  new_tags.length = 0;
  new_tags.entries = tags;

  for (const auto& pair : pairs) {
    envoy_data key = Data::Utility::copyToBridgeData(pair.first);
    envoy_data value = Data::Utility::copyToBridgeData(pair.second);
    new_tags.entries[new_tags.length] = {key, value};
    new_tags.length++;
  }
  return new_tags;
}

TEST(TransformTest, FromEnvoyStatsTagsToStatNameTagVector) {
  Stats::TestUtil::TestSymbolTable symbol_table_;
  StatNameSetPtr stat_name_set_;
  stat_name_set_ = symbol_table_->makeSet("pulse");
  envoy_stats_tags tags = make_envoy_stats_tags({{"os", "android"}, {"flavor", "dev"}});
  Stats::StatNameTagVector tags_vctr = transformToStatNameTagVector(tags, stat_name_set_);
  ASSERT_EQ(tags_vctr.size(), 2);
  ASSERT_EQ(symbol_table_->toString(tags_vctr[0].first), "os");
  ASSERT_EQ(symbol_table_->toString(tags_vctr[0].second), "android");
  ASSERT_EQ(symbol_table_->toString(tags_vctr[1].first), "flavor");
  ASSERT_EQ(symbol_table_->toString(tags_vctr[1].second), "dev");
}

TEST(TransformTest, FromEnvoyStatsTagsToStatNameTagVectorNoTags) {
  Stats::TestUtil::TestSymbolTable symbol_table_;
  StatNameSetPtr stat_name_set_;
  stat_name_set_ = symbol_table_->makeSet("pulse");
  Stats::StatNameTagVector tags_vctr =
      transformToStatNameTagVector(envoy_stats_notags, stat_name_set_);
  ASSERT_EQ(tags_vctr.size(), 0);
}

} // namespace Utility
} // namespace Stats
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_test", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_test(
    name = "utility_test",
    srcs = ["utility_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/common:engine_lib_no_stamp",
        "//library/common/data:utility_lib",
        "//library/common/types:c_types_lib",
        "@envoy//test/common/stats:stat_test_utility_lib",
    ],
)
#include "source/common/buffer/buffer_impl.h"

#include "gtest/gtest.h"
#include "library/common/buffer/bridge_fragment.h"
#include "library/common/types/c_types.h"

namespace Envoy {
namespace Buffer {

void envoy_test_release(void* context) {
  uint32_t* counter = static_cast<uint32_t*>(context);
  *counter = *counter + 1;
}

envoy_data toTestEnvoyData(std::string& s, uint32_t* sentinel) {
  return {s.size(), reinterpret_cast<const uint8_t*>(s.c_str()), envoy_test_release, sentinel};
}

TEST(BridgeFragmentTest, Basic) {
  uint32_t* sentinel = new uint32_t;
  *sentinel = 0;
  std::string s = "test string";
  envoy_data c_data = toTestEnvoyData(s, sentinel);

  BridgeFragment* fragment = BridgeFragment::createBridgeFragment(c_data);
  OwnedImpl buffer_wrapper;
  buffer_wrapper.addBufferFragment(*fragment);

  ASSERT_EQ(buffer_wrapper.length(), c_data.length);
  ASSERT_EQ(buffer_wrapper.toString(), s);

  ASSERT_EQ(*sentinel, 0);
  buffer_wrapper.drain(buffer_wrapper.length());
  ASSERT_EQ(*sentinel, 1);
  delete sentinel;
}

} // namespace Buffer
} // namespace Envoy
load("@envoy//bazel:envoy_build_system.bzl", "envoy_cc_test", "envoy_mobile_package")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_test(
    name = "bridge_fragment_test",
    srcs = ["bridge_fragment_test.cc"],
    repository = "@envoy",
    deps = [
        "//library/common/buffer:bridge_fragment_lib",
        "//library/common/types:c_types_lib",
        "@envoy//source/common/buffer:buffer_lib",
    ],
)
@testable import Envoy
import Foundation
import XCTest

private let kMessage1 = Data([1, 2, 3, 4, 5])
private let kMessage2 = Data([6, 7, 8, 9, 0, 1])

final class GRPCStreamTests: XCTestCase {
  // MARK: - Request tests

  func testDataSizeIsFiveBytesGreaterThanMessageSize() {
    var sentData = Data()
    let streamClient = MockStreamClient { stream in
      stream.onRequestData = { data, _ in sentData.append(data) }
    }

    _ = GRPCClient(streamClient: streamClient)
      .newGRPCStreamPrototype()
      .start()
      .sendMessage(kMessage1)

    XCTAssertEqual(5 + kMessage1.count, sentData.count)
  }

  func testPrefixesSentDataWithZeroCompressionFlag() {
    var sentData = Data()
    let streamClient = MockStreamClient { stream in
      stream.onRequestData = { data, _ in sentData.append(data) }
    }

    _ = GRPCClient(streamClient: streamClient)
      .newGRPCStreamPrototype()
      .start()
      .sendMessage(kMessage1)

    XCTAssertEqual(UInt8(0), sentData.integer(atIndex: 0))
  }

  func testPrefixesSentDataWithBigEndianLengthOfMessage() {
    var sentData = Data()
    let streamClient = MockStreamClient { stream in
      stream.onRequestData = { data, _ in sentData.append(data) }
    }

    _ = GRPCClient(streamClient: streamClient)
      .newGRPCStreamPrototype()
      .start()
      .sendMessage(kMessage1)

    let expectedMessageLength = UInt32(kMessage1.count).bigEndian
    let messageLength: UInt32? = sentData.integer(atIndex: 1)
    XCTAssertEqual(expectedMessageLength, messageLength)
  }

  func testAppendsMessageDataAtTheEndOfSentData() {
    var sentData = Data()
    let streamClient = MockStreamClient { stream in
      stream.onRequestData = { data, _ in sentData.append(data) }
    }

    _ = GRPCClient(streamClient: streamClient)
      .newGRPCStreamPrototype()
      .start()
      .sendMessage(kMessage1)

    XCTAssertEqual(kMessage1, sentData.subdata(in: 5..<sentData.count))
  }

  func testCancelCallsStreamCallback() {
    let expectation = self.expectation(description: "onCancel callback is called")
    let streamClient = MockStreamClient { stream in
      stream.onCancel = expectation.fulfill
    }

    GRPCClient(streamClient: streamClient)
      .newGRPCStreamPrototype()
      .start()
      .cancel()

    self.waitForExpectations(timeout: 0.1)
  }

  // MARK: - Response tests

  func testHeadersCallbackPassesHeaders() {
    let expectation = self.expectation(description: "Closure is called")
    let expectedHeaders = ResponseHeaders(
      headers: ["grpc-status": ["1"], "x-other": ["foo", "bar"]])

    var stream: MockStream!
    let streamClient = MockStreamClient { stream = $0 }

    _ = GRPCClient(streamClient: streamClient)
      .newGRPCStreamPrototype()
      .setOnResponseHeaders { headers, endStream, _ in
        XCTAssertEqual(expectedHeaders, headers)
        XCTAssertTrue(endStream)
        expectation.fulfill()
      }
      .start()

    stream.receiveHeaders(expectedHeaders, endStream: true)
    self.waitForExpectations(timeout: 0.1)
  }

  func testTrailersCallbackPassesTrailers() {
    let expectation = self.expectation(description: "Closure is called")
    let expectedTrailers = ResponseTrailers(headers: ["x-foo": ["bar"], "x-baz": ["1", "2"]])

    var stream: MockStream!
    let streamClient = MockStreamClient { stream = $0 }

    _ = GRPCClient(streamClient: streamClient)
      .newGRPCStreamPrototype()
      .setOnResponseTrailers { trailers, _ in
        XCTAssertEqual(expectedTrailers, trailers)
        expectation.fulfill()
      }
      .start()

    stream.receiveTrailers(expectedTrailers)
    self.waitForExpectations(timeout: 0.1)
  }

  func testMessageCallbackBuffersDataSentInSingleChunk() {
    let expectation = self.expectation(description: "Closure is called")
    let firstMessage = Data([
      0x0, // Compression flag
      0x0, 0x0, 0x0, 0x5, // Length bytes
    ] + kMessage1)

    var stream: MockStream!
    let streamClient = MockStreamClient { stream = $0 }

    _ = GRPCClient(streamClient: streamClient)
      .newGRPCStreamPrototype()
      .setOnResponseMessage { message, _ in
        XCTAssertEqual(kMessage1, message)
        expectation.fulfill()
      }
      .start()

    stream.receiveData(firstMessage, endStream: false)
    self.waitForExpectations(timeout: 0.1)
  }

  func testMessageCallbackBuffersDataSentInMultipleChunks() {
    let expectation = self.expectation(description: "Closure is called")
    expectation.expectedFulfillmentCount = 2

    let firstMessage = Data([
      0x0, // Compression flag
      0x0, 0x0, 0x0, 0x5, // Length bytes
    ] + kMessage1)

    let secondMessagePart1 = Data([
      0x0, // Compression flag
      0x0, 0x0, 0x0, // 3/4 length bytes
    ])

    let secondMessagePart2 = Data([
      0x6, // Last length byte
    ] + kMessage2[0..<2])

    let secondMessagePart3 = Data(kMessage2[2..<6])

    var expectedMessages = [kMessage1, kMessage2]
    var stream: MockStream!
    let streamClient = MockStreamClient { stream = $0 }

    _ = GRPCClient(streamClient: streamClient)
      .newGRPCStreamPrototype()
      .setOnResponseMessage { message, _ in
        XCTAssertEqual(expectedMessages.removeFirst(), message)
        expectation.fulfill()
      }
      .start()

    stream.receiveData(firstMessage, endStream: false)
    stream.receiveData(secondMessagePart1, endStream: false)
    stream.receiveData(secondMessagePart2, endStream: false)
    stream.receiveData(secondMessagePart3, endStream: false)
    self.waitForExpectations(timeout: 0.1)
    XCTAssertTrue(expectedMessages.isEmpty)
  }

  func testMessageCallbackCanBeCalledWithZeroLengthMessage() {
    let expectation = self.expectation(description: "Closure is called")
    let emptyMessage = Data([
      0x0, // Compression flag
      0x0, 0x0, 0x0, 0x0, // Length bytes
    ])

    var stream: MockStream!
    let streamClient = MockStreamClient { stream = $0 }

    _ = GRPCClient(streamClient: streamClient)
      .newGRPCStreamPrototype()
      .setOnResponseMessage { message, _ in
        XCTAssertTrue(message.isEmpty)
        expectation.fulfill()
      }
      .start()

    stream.receiveData(emptyMessage, endStream: false)
    self.waitForExpectations(timeout: 0.1)
  }

  func testMessageCallbackCanBeCalledWithMessageAfterZeroLengthMessage() {
    let expectation = self.expectation(description: "Closure is called")
    expectation.expectedFulfillmentCount = 2
    let emptyMessage = Data([
      0x0, // Compression flag
      0x0, 0x0, 0x0, 0x0, // Length bytes
    ])

    let secondMessage = Data([
      0x0, // Compression flag
      0x0, 0x0, 0x0, 0x6, // Length bytes
    ] + kMessage2)

    var expectedMessages = [Data(), kMessage2]
    var stream: MockStream!
    let streamClient = MockStreamClient { stream = $0 }

    _ = GRPCClient(streamClient: streamClient)
      .newGRPCStreamPrototype()
      .setOnResponseMessage { message, _ in
        XCTAssertEqual(expectedMessages.removeFirst(), message)
        expectation.fulfill()
      }
      .start()

    stream.receiveData(emptyMessage, endStream: false)
    stream.receiveData(secondMessage, endStream: false)
    self.waitForExpectations(timeout: 0.1)
    XCTAssertTrue(expectedMessages.isEmpty)
  }
}
@testable import Envoy
@testable import EnvoyEngine
import Foundation
import XCTest

final class PulseClientImplTests: XCTestCase {
  override func tearDown() {
    super.tearDown()
    MockEnvoyEngine.onRecordCounter = nil
  }

  func testCounterDelegatesToEngineWithTagsAndCount() {
    var actualSeries: String?
    var actualTags = [String: String]()
    var actualCount: UInt?
    MockEnvoyEngine.onRecordCounter = { series, tags, count in
      actualSeries = series
      actualTags = tags
      actualCount = count
    }
    let mockEngine = MockEnvoyEngine()
    let pulseClient = PulseClientImpl(engine: mockEngine)
    let counter = pulseClient.counter(
      elements: ["test", "stat"],
      tags: TagsBuilder().add(name: "testKey", value: "testValue").build()
    )
    counter.increment()
    XCTAssertEqual(actualSeries, "test.stat")
    XCTAssertEqual(actualTags, ["testKey": "testValue"])
    XCTAssertEqual(actualCount, 1)
  }

  func testCounterDelegatesToEngineWithCount() {
    var actualSeries: String?
    var actualTags = [String: String]()
    var actualCount: UInt?
    MockEnvoyEngine.onRecordCounter = { series, tags, count in
      actualSeries = series
      actualTags = tags
      actualCount = count
    }
    let mockEngine = MockEnvoyEngine()
    let pulseClient = PulseClientImpl(engine: mockEngine)

    // Also verifies that counter can be created without tags
    let counter = pulseClient.counter(elements: ["test", "stat"])
    counter.increment(count: 5)
    XCTAssertEqual(actualSeries, "test.stat")
    XCTAssertEqual(actualTags, [:])
    XCTAssertEqual(actualCount, 5)
  }

  func testCounterWeaklyHoldsEngine() {
    let mockEngine = MockEnvoyEngine()
    let pulseClient = PulseClientImpl(engine: mockEngine)
    let counter = pulseClient.counter(elements: ["test", "stat"])
    weak var weakEngine = mockEngine

    addTeardownBlock { [counter, weak weakEngine] in
      XCTAssertNotNil(counter) // Counter is captured and still exists.
      XCTAssertNil(weakEngine) // weakEngine is nil (and so Counter didn't keep it alive).
    }
  }
}
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class FilterResetIdleTests: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testFilterResetIdle() {
    let idleTimeout = "0.5s"
    let remotePort = Int.random(in: 10001...11000)
    // swiftlint:disable:next line_length
    let hcmType = "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager"
    // swiftlint:disable:next line_length
    let emhcmType = "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager"
    let pbfType =
      "type.googleapis.com/envoymobile.extensions.filters.http.platform_bridge.PlatformBridge"
    let localErrorFilterType =
      "type.googleapis.com/envoymobile.extensions.filters.http.local_error.LocalError"
    let filterName = "reset_idle_test_filter"
    let config =
"""
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: fake_remote_listener
    address:
      socket_address: { protocol: TCP, address: 127.0.0.1, port_value: \(remotePort) }
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": \(hcmType)
          stat_prefix: remote_hcm
          route_config:
            name: remote_route
            virtual_hosts:
            - name: remote_service
              domains: ["*"]
              routes:
              - match: { prefix: "/" }
                direct_response: { status: 200 }
          http_filters:
          - name: envoy.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
  - name: base_api_listener
    address:
      socket_address: { protocol: TCP, address: 0.0.0.0, port_value: 10000 }
    api_listener:
      api_listener:
        "@type": \(emhcmType)
        config:
          stat_prefix: api_hcm
          stream_idle_timeout: \(idleTimeout)
          route_config:
            name: api_router
            virtual_hosts:
            - name: api
              domains: ["*"]
              routes:
              - match: { prefix: "/" }
                route: { cluster: fake_remote }
          http_filters:
          - name: envoy.filters.http.platform_bridge
            typed_config:
              "@type": \(pbfType)
              platform_filter_name: \(filterName)
          - name: envoy.filters.http.local_error
            typed_config:
              "@type": \(localErrorFilterType)
          - name: envoy.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
  clusters:
  - name: fake_remote
    connect_timeout: 0.25s
    type: STATIC
    lb_policy: ROUND_ROBIN
    load_assignment:
      cluster_name: fake_remote
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address: { address: 127.0.0.1, port_value: \(remotePort) }
"""

    class ResetIdleTestFilter: AsyncRequestFilter, ResponseFilter {
      let queue = DispatchQueue(label: "io.envoyproxy.async")
      let resetExpectation: XCTestExpectation
      let cancelExpectation: XCTestExpectation
      var callbacks: RequestFilterCallbacks!
      var resetCount = 0

      // Trigger 3 idle timer exception, then allow timeout
      private func signalActivity() {
        if resetCount < 3 {
          self.resetCount += 1
          self.queue.asyncAfter(deadline: .now() + 0.25) { [weak self] in
            guard let strongSelf = self else {
              return
            }
            strongSelf.callbacks.resetIdleTimer()
            strongSelf.signalActivity()
          }
        } else {
          resetExpectation.fulfill()
        }
      }

      init(resetExpectation: XCTestExpectation, cancelExpectation: XCTestExpectation) {
        self.resetExpectation = resetExpectation
        self.cancelExpectation = cancelExpectation
      }

      func setRequestFilterCallbacks(_ callbacks: RequestFilterCallbacks) {
        self.callbacks = callbacks
      }

      func onResumeRequest(
        headers: RequestHeaders?,
        data: Data?,
        trailers: RequestTrailers?,
        endStream: Bool,
        streamIntel: StreamIntel
      ) -> FilterResumeStatus<RequestHeaders, RequestTrailers> {
        XCTFail("Unexpected call to onResumeRequest")
        return .resumeIteration(headers: nil, data: nil, trailers: nil)
      }

      func onRequestHeaders(_ headers: RequestHeaders, endStream: Bool, streamIntel: StreamIntel)
        -> FilterHeadersStatus<RequestHeaders>
      {
        self.signalActivity()
        return .stopIteration
      }

      func onRequestData(_ body: Data, endStream: Bool, streamIntel: StreamIntel)
        -> FilterDataStatus<RequestHeaders>
      {
        XCTFail("Unexpected call to onRequestData filter callback")
        return .stopIterationNoBuffer
      }

      func onRequestTrailers(_ trailers: RequestTrailers, streamIntel: StreamIntel)
          -> FilterTrailersStatus<RequestHeaders, RequestTrailers>
      {
        XCTFail("Unexpected call to onRequestTrailers filter callback")
        return .stopIteration
      }

      func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool, streamIntel: StreamIntel)
        -> FilterHeadersStatus<ResponseHeaders>
      {
        self.signalActivity()
        return .stopIteration
      }

      func onResponseData(_ body: Data, endStream: Bool, streamIntel: StreamIntel)
        -> FilterDataStatus<ResponseHeaders>
      {
        XCTFail("Unexpected call to onResponseData filter callback")
        return .stopIterationNoBuffer
      }

      func onResponseTrailers(_ trailers: ResponseTrailers, streamIntel: StreamIntel)
          -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers>
      {
        XCTFail("Unexpected call to onResponseTrailers filter callback")
        return .stopIteration
      }

      func onError(_ error: EnvoyError, streamIntel: FinalStreamIntel) {}

      func onCancel(streamIntel: FinalStreamIntel) {
        cancelExpectation.fulfill()
      }

      func onComplete(streamIntel: FinalStreamIntel) {}
    }

    let resetExpectation = self.expectation(description: "Stream idle timer reset 3 times")
    let timeoutExpectation = self.expectation(description: "Stream idle timeout triggered")
    let cancelExpectation = self.expectation(
      description: "Stream cancellation triggered incorrectly")
    cancelExpectation.isInverted = true

    let engine = EngineBuilder(yaml: config)
      .addLogLevel(.trace)
      .addPlatformFilter(
        name: filterName,
        factory: {
          ResetIdleTestFilter(
            resetExpectation: resetExpectation, cancelExpectation: cancelExpectation)
        }
      )
      .build()

    let client = engine.streamClient()

    let requestHeaders = RequestHeadersBuilder(
      method: .get, scheme: "https",
      authority: "example.com", path: "/test"
    )
    .build()

    client
      .newStreamPrototype()
      .setOnError { _, _ in
        timeoutExpectation.fulfill()
      }
      .start()
      .sendHeaders(requestHeaders, endStream: true)

    XCTAssertEqual(
      XCTWaiter.wait(for: [resetExpectation, timeoutExpectation], timeout: 10),
      .completed
    )

    XCTAssertEqual(
      XCTWaiter.wait(for: [cancelExpectation], timeout: 2),
      .completed
    )

    engine.terminate()
  }
}
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class ResetConnectivityStateTest: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testResetConnectivityState() {
    // swiftlint:disable:next line_length
    let emhcmType = "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager"
    // swiftlint:disable:next line_length
    let assertionFilterType = "type.googleapis.com/envoymobile.extensions.filters.http.assertion.Assertion"
    let config =
"""
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: base_api_listener
    address:
      socket_address:
        protocol: TCP
        address: 0.0.0.0
        port_value: 10000
    api_listener:
      api_listener:
        "@type": \(emhcmType)
        config:
          stat_prefix: hcm
          route_config:
            name: api_router
            virtual_hosts:
              - name: api
                domains:
                  - "*"
                routes:
                  - match:
                      prefix: "/"
                    direct_response:
                      status: 200
          http_filters:
            - name: envoy.filters.http.assertion
              typed_config:
                "@type": \(assertionFilterType)
                match_config:
                  http_request_headers_match:
                    headers:
                      - name: ":authority"
                        exact_match: example.com
            - name: envoy.router
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
"""
    let engine = EngineBuilder(yaml: config)
      .addLogLevel(.debug)
      .build()

    let client = engine.streamClient()

    let requestHeaders = RequestHeadersBuilder(method: .get, scheme: "https",
                                               authority: "example.com", path: "/test")
      .build()

    let expectation1 =
      self.expectation(description: "Run called with expected http status first request")

    client
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, endStream, _ in
         XCTAssertEqual(200, responseHeaders.httpStatus)
         XCTAssertTrue(endStream)
         expectation1.fulfill()
      }
      .setOnError { _, _ in
        XCTFail("Unexpected error")
      }
      .start()
      .sendHeaders(requestHeaders, endStream: true)

    XCTAssertEqual(XCTWaiter.wait(for: [expectation1], timeout: 10), .completed)

    engine.resetConnectivityState()

    let expectation2 =
      self.expectation(description: "Run called with expected http status first request")

    client
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, endStream, _ in
         XCTAssertEqual(200, responseHeaders.httpStatus)
         XCTAssertTrue(endStream)
         expectation2.fulfill()
      }
      .setOnError { _, _ in
        XCTFail("Unexpected error")
      }
      .start()
      .sendHeaders(requestHeaders, endStream: true)

    XCTAssertEqual(XCTWaiter.wait(for: [expectation2], timeout: 10), .completed)

    engine.terminate()
  }
}
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class SendDataTests: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testSendData() throws {
    // swiftlint:disable:next line_length
    let emhcmType = "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager"
    // swiftlint:disable:next line_length
    let assertionFilterType = "type.googleapis.com/envoymobile.extensions.filters.http.assertion.Assertion"
    let requestStringMatch = "match_me"
    let config =
"""
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: base_api_listener
    address:
      socket_address:
        protocol: TCP
        address: 0.0.0.0
        port_value: 10000
    api_listener:
      api_listener:
        "@type": \(emhcmType)
        config:
          stat_prefix: hcm
          route_config:
            name: api_router
            virtual_hosts:
              - name: api
                domains:
                  - "*"
                routes:
                  - match:
                      prefix: "/"
                    direct_response:
                      status: 200
          http_filters:
            - name: envoy.filters.http.assertion
              typed_config:
                "@type": \(assertionFilterType)
                match_config:
                  http_request_generic_body_match:
                    patterns:
                      - string_match: \(requestStringMatch)
            - name: envoy.filters.http.buffer
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer
                max_request_bytes: 65000
            - name: envoy.router
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
"""
    let expectation = self.expectation(description: "Run called with expected http status")
    let engine = EngineBuilder(yaml: config)
      .addLogLevel(.debug)
      .build()

    let client = engine.streamClient()

    let requestHeaders = RequestHeadersBuilder(method: .get, scheme: "https",
                                               authority: "example.com", path: "/test")
      .build()
    let body = try XCTUnwrap(requestStringMatch.data(using: .utf8))

    client
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, endStream, _ in
         XCTAssertEqual(200, responseHeaders.httpStatus)
         XCTAssertTrue(endStream)
         expectation.fulfill()
      }
      .setOnError { _, _ in
        XCTFail("Unexpected error")
      }
      .start()
      .sendHeaders(requestHeaders, endStream: false)
      .close(data: body)

    XCTAssertEqual(XCTWaiter.wait(for: [expectation], timeout: 10), .completed)

    engine.terminate()
  }
}
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class ReceiveErrorTests: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testReceiveError() {
    // swiftlint:disable:next line_length
    let emhcmType = "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager"
    // swiftlint:disable:next line_length
    let pbfType = "type.googleapis.com/envoymobile.extensions.filters.http.platform_bridge.PlatformBridge"
    // swiftlint:disable:next line_length
    let localErrorFilterType = "type.googleapis.com/envoymobile.extensions.filters.http.local_error.LocalError"
    let filterName = "error_validation_filter"
    let config =
"""
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: base_api_listener
    address:
      socket_address: { protocol: TCP, address: 0.0.0.0, port_value: 10000 }
    api_listener:
      api_listener:
        "@type": \(emhcmType)
        config:
          stat_prefix: hcm
          route_config:
            name: api_router
            virtual_hosts:
            - name: api
              domains: ["*"]
              routes:
              - match: { prefix: "/" }
                direct_response: { status: 503 }
          http_filters:
          - name: envoy.filters.http.platform_bridge
            typed_config:
              "@type": \(pbfType)
              platform_filter_name: \(filterName)
          - name: envoy.filters.http.local_error
            typed_config:
              "@type": \(localErrorFilterType)
          - name: envoy.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
"""

    struct ErrorValidationFilter: ResponseFilter {
      let receivedError: XCTestExpectation
      let notCancelled: XCTestExpectation

      func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool, streamIntel: StreamIntel)
        -> FilterHeadersStatus<ResponseHeaders>
      {
        return .continue(headers: headers)
      }

      func onResponseData(_ body: Data, endStream: Bool, streamIntel: StreamIntel)
        -> FilterDataStatus<ResponseHeaders>
      {
        return .continue(data: body)
      }

      func onResponseTrailers(_ trailers: ResponseTrailers, streamIntel: StreamIntel)
          -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
        return .continue(trailers: trailers)
      }

      func onError(_ error: EnvoyError, streamIntel: FinalStreamIntel) {
        XCTAssertEqual(error.errorCode, 2) // 503/Connection Failure
        self.receivedError.fulfill()
      }

      func onCancel(streamIntel: FinalStreamIntel) {
        XCTFail("Unexpected call to onCancel filter callback")
        self.notCancelled.fulfill()
      }

      func onComplete(streamIntel: FinalStreamIntel) {}
    }

    let callbackReceivedError = self.expectation(description: "Run called with expected error")
    let filterReceivedError = self.expectation(description: "Filter called with expected error")
    let filterNotCancelled =
      self.expectation(description: "Filter called with unexpected cancellation")
    filterNotCancelled.isInverted = true
    let expectations = [filterReceivedError, filterNotCancelled, callbackReceivedError]

    let engine = EngineBuilder(yaml: config)
      .addLogLevel(.trace)
      .addPlatformFilter(
        name: filterName,
        factory: {
          ErrorValidationFilter(receivedError: filterReceivedError,
                                notCancelled: filterNotCancelled)
        }
      )
      .build()

    let client = engine.streamClient()

    let requestHeaders = RequestHeadersBuilder(method: .get, scheme: "https",
                                               authority: "example.com", path: "/test")
      .build()

    client
      .newStreamPrototype()
      .setOnResponseHeaders { _, _, _ in
        XCTFail("Headers received instead of expected error")
      }
      .setOnResponseData { _, _, _ in
        XCTFail("Data received instead of expected error")
      }
      // The unmatched expectation will cause a local reply which gets translated in Envoy Mobile to
      // an error.
      .setOnError { error, _ in
         XCTAssertEqual(error.errorCode, 2) // 503/Connection Failure
         callbackReceivedError.fulfill()
      }
      .setOnCancel { _ in
        XCTFail("Unexpected call to onCancel response callback")
      }
      .start()
      .sendHeaders(requestHeaders, endStream: true)

    XCTAssertEqual(XCTWaiter.wait(for: expectations, timeout: 10), .completed)

    engine.terminate()
  }
}
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class LoggerTests: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testSetLogger() throws {
    // swiftlint:disable:next line_length
    let emhcmType = "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager"
    // swiftlint:disable:next line_length
    let assertionFilterType = "type.googleapis.com/envoymobile.extensions.filters.http.assertion.Assertion"
    // swiftlint:disable:next line_length
    let testLoggerFilterType = "type.googleapis.com/envoymobile.extensions.filters.http.test_logger.TestLogger"
    let config =
"""
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: base_api_listener
    address:
      socket_address:
        protocol: TCP
        address: 0.0.0.0
        port_value: 10000
    api_listener:
      api_listener:
        "@type": \(emhcmType)
        config:
          stat_prefix: hcm
          route_config:
            name: api_router
            virtual_hosts:
              - name: api
                domains:
                  - "*"
                routes:
                  - match:
                      prefix: "/"
                    direct_response:
                      status: 200
          http_filters:
            - name: test_logger
              typed_config:
                "@type": \(testLoggerFilterType)
            - name: envoy.filters.http.assertion
              typed_config:
                "@type": \(assertionFilterType)
                match_config:
                  http_request_headers_match:
                    headers:
                      - name: ":authority"
                        exact_match: example.com
            - name: envoy.router
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
"""

    let engineExpectation = self.expectation(description: "Run started engine")
    let loggingExpectation = self.expectation(description: "Run used platform logger")
    let logEventExpectation = self.expectation(
      description: "Run received log event via event tracker")

    let engine = EngineBuilder(yaml: config)
      .addLogLevel(.debug)
      .setLogger { msg in
        if msg.contains("starting main dispatch loop") {
          loggingExpectation.fulfill()
        }
      }
      .setOnEngineRunning {
        engineExpectation.fulfill()
      }
      .setEventTracker { event in
        if event["log_name"] == "event_name" {
          logEventExpectation.fulfill()
        }
      }
      .build()

    XCTAssertEqual(XCTWaiter.wait(for: [engineExpectation], timeout: 10), .completed)
    XCTAssertEqual(XCTWaiter.wait(for: [loggingExpectation], timeout: 10), .completed)

    // Send a request to trigger the test filter which should log an event.
    let requestHeaders = RequestHeadersBuilder(method: .get, scheme: "https",
                                               authority: "example.com", path: "/test")
      .build()
    engine.streamClient()
      .newStreamPrototype()
      .start()
      .sendHeaders(requestHeaders, endStream: true)

    XCTAssertEqual(XCTWaiter.wait(for: [logEventExpectation], timeout: 10), .completed)

    engine.terminate()
  }
}
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class GRPCReceiveErrorTests: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testReceiveError() {
    // swiftlint:disable:next line_length
    let emhcmType = "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager"
    // swiftlint:disable:next line_length
    let pbfType = "type.googleapis.com/envoymobile.extensions.filters.http.platform_bridge.PlatformBridge"
    // swiftlint:disable:next line_length
    let localErrorFilterType = "type.googleapis.com/envoymobile.extensions.filters.http.local_error.LocalError"
    let filterName = "error_validation_filter"
    let config =
"""
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: base_api_listener
    address:
      socket_address: { protocol: TCP, address: 0.0.0.0, port_value: 10000 }
    api_listener:
      api_listener:
        "@type": \(emhcmType)
        config:
          stat_prefix: hcm
          route_config:
            name: api_router
            virtual_hosts:
            - name: api
              domains: ["*"]
              routes:
              - match: { prefix: "/" }
                direct_response: { status: 503 }
          http_filters:
          - name: envoy.filters.http.platform_bridge
            typed_config:
              "@type": \(pbfType)
              platform_filter_name: \(filterName)
          - name: envoy.filters.http.local_error
            typed_config:
              "@type": \(localErrorFilterType)
          - name: envoy.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
"""

    struct ErrorValidationFilter: ResponseFilter {
      let receivedError: XCTestExpectation
      let notCancelled: XCTestExpectation

      func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool, streamIntel: StreamIntel)
        -> FilterHeadersStatus<ResponseHeaders>
      {
        return .continue(headers: headers)
      }

      func onResponseData(_ body: Data, endStream: Bool, streamIntel: StreamIntel)
        -> FilterDataStatus<ResponseHeaders>
      {
        return .continue(data: body)
      }

      func onResponseTrailers(_ trailers: ResponseTrailers, streamIntel: StreamIntel)
          -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
        return .continue(trailers: trailers)
      }

      func onError(_ error: EnvoyError, streamIntel: FinalStreamIntel) {
        XCTAssertEqual(error.errorCode, 2) // 503/Connection Failure
        self.receivedError.fulfill()
      }

      func onCancel(streamIntel: FinalStreamIntel) {
        XCTFail("Unexpected call to onCancel filter callback")
        self.notCancelled.fulfill()
      }

      func onComplete(streamIntel: FinalStreamIntel) {}
    }

    let callbackReceivedError = self.expectation(description: "Run called with expected error")
    let filterReceivedError = self.expectation(description: "Filter called with expected error")
    let filterNotCancelled =
      self.expectation(description: "Filter called with unexpected cancellation")
    filterNotCancelled.isInverted = true
    let expectations = [filterReceivedError, filterNotCancelled, callbackReceivedError]

    let engine = EngineBuilder(yaml: config)
      .addLogLevel(.trace)
      .addPlatformFilter(
        name: filterName,
        factory: {
          ErrorValidationFilter(receivedError: filterReceivedError,
                                notCancelled: filterNotCancelled)
        }
      )
      .build()

    let client = Envoy.GRPCClient(streamClient: engine.streamClient())

    let requestHeaders = GRPCRequestHeadersBuilder(scheme: "https", authority: "example.com",
                                                   path: "/pb.api.v1.Foo/GetBar").build()
    let message = Data([1, 2, 3, 4, 5])

    client
      .newGRPCStreamPrototype()
      .setOnResponseHeaders { _, _, _ in
        XCTFail("Headers received instead of expected error")
      }
      .setOnResponseMessage { _, _ in
        XCTFail("Message received instead of expected error")
      }
      // The unmatched expecation will cause a local reply which gets translated in Envoy Mobile to
      // an error.
      .setOnError { error, _ in
         XCTAssertEqual(error.errorCode, 2) // 503/Connection Failure
         callbackReceivedError.fulfill()
      }
      .setOnCancel { _ in
        XCTFail("Unexpected call to onCancel response callback")
      }
      .start()
      .sendHeaders(requestHeaders, endStream: false)
      .sendMessage(message)

    XCTAssertEqual(XCTWaiter.wait(for: expectations, timeout: 10), .completed)

    engine.terminate()
  }
}
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class SetEventTrackerTest: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testEmitEventWithoutSettingEventTracker() throws {
    let eventExpectation =
      self.expectation(description: "Passed event tracker receives an event")

    let engine = EngineBuilder()
      .setEventTracker { event in
        XCTAssertEqual("bar", event["foo"])
        eventExpectation.fulfill()
      }
      .addNativeFilter(
        name: "envoy.filters.http.test_event_tracker",
        // swiftlint:disable:next line_length
        typedConfig: "{\"@type\":\"type.googleapis.com/envoymobile.extensions.filters.http.test_event_tracker.TestEventTracker\",\"attributes\":{\"foo\":\"bar\"}}")
      .build()

    let client = engine.streamClient()

    let requestHeaders = RequestHeadersBuilder(method: .get, scheme: "https",
                                               authority: "example.com", path: "/test")
      .build()

    client
      .newStreamPrototype()
      .start()
      .sendHeaders(requestHeaders, endStream: true)

    XCTAssertEqual(XCTWaiter.wait(for: [eventExpectation], timeout: 10), .completed)

    engine.terminate()
  }
}
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class CancelStreamTests: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testCancelStream() {
    let remotePort = Int.random(in: 10001...11000)
    // swiftlint:disable:next line_length
    let emhcmType = "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager"
    let lefType = "type.googleapis.com/envoymobile.extensions.filters.http.local_error.LocalError"
    // swiftlint:disable:next line_length
    let pbfType = "type.googleapis.com/envoymobile.extensions.filters.http.platform_bridge.PlatformBridge"
    let filterName = "cancel_validation_filter"
    let config =
"""
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: base_api_listener
    address:
      socket_address: { protocol: TCP, address: 0.0.0.0, port_value: 10000 }
    api_listener:
      api_listener:
        "@type": \(emhcmType)
        config:
          stat_prefix: api_hcm
          route_config:
            name: api_router
            virtual_hosts:
            - name: api
              domains: ["*"]
              routes:
              - match: { prefix: "/" }
                route: { cluster: fake_remote }
          http_filters:
          - name: envoy.filters.http.local_error
            typed_config:
              "@type": \(lefType)
          - name: envoy.filters.http.platform_bridge
            typed_config:
              "@type": \(pbfType)
              platform_filter_name: \(filterName)
          - name: envoy.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
  clusters:
  - name: fake_remote
    connect_timeout: 0.25s
    type: STATIC
    lb_policy: ROUND_ROBIN
    load_assignment:
      cluster_name: fake_remote
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address: { address: 127.0.0.1, port_value: \(remotePort) }
"""

    struct CancelValidationFilter: ResponseFilter {
      let expectation: XCTestExpectation

      func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool, streamIntel: StreamIntel)
        -> FilterHeadersStatus<ResponseHeaders>
      {
        return .continue(headers: headers)
      }

      func onResponseData(_ body: Data, endStream: Bool, streamIntel: StreamIntel)
        -> FilterDataStatus<ResponseHeaders>
      {
        return .continue(data: body)
      }

      func onResponseTrailers(_ trailers: ResponseTrailers, streamIntel: StreamIntel)
          -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
        return .continue(trailers: trailers)
      }

      func onError(_ error: EnvoyError, streamIntel: FinalStreamIntel) {}

      func onCancel(streamIntel: FinalStreamIntel) {
        self.expectation.fulfill()
      }

      func onComplete(streamIntel: FinalStreamIntel) {}
    }

    let runExpectation = self.expectation(description: "Run called with expected cancellation")
    let filterExpectation = self.expectation(description: "Filter called with cancellation")

    let engine = EngineBuilder(yaml: config)
      .addLogLevel(.trace)
      .addPlatformFilter(
        name: filterName,
        factory: { CancelValidationFilter(expectation: filterExpectation) }
      )
      .build()

    let client = engine.streamClient()

    let requestHeaders = RequestHeadersBuilder(method: .get, scheme: "https",
                                               authority: "example.com", path: "/test")
      .build()

    client
      .newStreamPrototype()
      .setOnCancel { _ in
         runExpectation.fulfill()
      }
      .start()
      .sendHeaders(requestHeaders, endStream: false)
      .cancel()

    let expectations = [filterExpectation, runExpectation]
    XCTAssertEqual(XCTWaiter.wait(for: expectations, timeout: 10), .completed)

    engine.terminate()
  }
}
import Envoy
import EnvoyTestServer
import Foundation
import TestExtensions
import XCTest

final class EndToEndNetworkingTest: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testNetworkRequestReturnsHeadersAndData() {
    EnvoyTestServer.startHttp1PlaintextServer()
    EnvoyTestServer.setHeadersAndData(
      "x-response-foo", header_value: "aaa", response_body: "hello world")
    let headersExpectation = self.expectation(description: "Response headers received")
    let dataExpectation = self.expectation(description: "Response data received")
    let port = String(EnvoyTestServer.getEnvoyPort())
    let requestHeaders = RequestHeadersBuilder(
      method: .get, scheme: "http", authority: "localhost:" + port, path: "/"
    )
    .build()

    let engine = EngineBuilder()
      .build()

    var responseBuffer = Data()
    engine
      .streamClient()
      .newStreamPrototype()
      .setOnResponseHeaders { headers, endStream, _ in
        XCTAssertEqual(200, headers.httpStatus)
        XCTAssertEqual(["aaa"], headers.value(forName: "x-response-foo"))
        XCTAssertFalse(endStream)
        headersExpectation.fulfill()
      }
      .setOnResponseData { data, endStream, _ in
        responseBuffer.append(contentsOf: data)
        if endStream {
          XCTAssertEqual("hello world", String(data: responseBuffer, encoding: .utf8))
          dataExpectation.fulfill()
        }
      }
      .start()
      .sendHeaders(requestHeaders, endStream: true)

    let expectations = [headersExpectation, dataExpectation]
    XCTAssertEqual(.completed, XCTWaiter().wait(for: expectations, timeout: 10, enforceOrder: true))

    engine.terminate()
    EnvoyTestServer.shutdownTestServer()
  }
}
This test suite tests end-to-end integration from the platform layer to the core layer's HTTP
functionality. It tests both the request side `send{Headers|Data}`, `close`, `cancel`, as
well as the response
side via the ` setOnResponse{...}` functions.

TODO: These tests are broken apart into different suites and bazel targets in order to tear down
app state -- and thus static lifetime objects like the Envoy engine -- between tests. When
multiple engine support (https://github.com/envoyproxy/envoy-mobile/issues/332) lands, all of these
tests can be collapsed to the same suite/target.

TODO: setOnTrailers is not tested as the neither the `direct_response` pathway, nor the router
allow sending trailers programmatically. Add tests once possible.
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class KeyValueStoreTests: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testKeyValueStore() {
    // swiftlint:disable:next line_length
    let ehcmType = "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager"
    // swiftlint:disable:next line_length
    let kvStoreType = "type.googleapis.com/envoymobile.extensions.filters.http.test_kv_store.TestKeyValueStore"
    let testKey = "foo"
    let testValue = "bar"
    let config =
"""
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: base_api_listener
    address:
      socket_address:
        protocol: TCP
        address: 0.0.0.0
        port_value: 10000
    api_listener:
      api_listener:
        "@type": \(ehcmType)
        config:
          stat_prefix: hcm
          route_config:
            name: api_router
            virtual_hosts:
              - name: api
                domains:
                  - "*"
                routes:
                  - match:
                      prefix: "/"
                    direct_response:
                      status: 200
          http_filters:
            - name: envoy.filters.http.test_kv_store
              typed_config:
                "@type": \(kvStoreType)
                kv_store_name: envoy.key_value.platform_test
                test_key: \(testKey)
                test_value: \(testValue)
            - name: envoy.router
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
"""

    let readExpectation = self.expectation(description: "Read called on key-value store")
    // Called multiple times for validation in test filter.
    readExpectation.assertForOverFulfill = false
    let saveExpectation = self.expectation(description: "Save called on key-value store")

    class TestKeyValueStore: KeyValueStore {
      let readExpectation: XCTestExpectation
      let saveExpectation: XCTestExpectation

      init(readExpectation: XCTestExpectation, saveExpectation: XCTestExpectation) {
        self.readExpectation = readExpectation
        self.saveExpectation = saveExpectation
      }

      func readValue(forKey: String) -> String? { readExpectation.fulfill(); return nil }
      func saveValue(_: String, toKey: String) { saveExpectation.fulfill() }
      func removeKey(_: String) {}
    }

    let testStore = TestKeyValueStore(readExpectation: readExpectation,
                                      saveExpectation: saveExpectation)

    let engine = EngineBuilder(yaml: config)
      .addLogLevel(.trace)
      .addKeyValueStore(
        name: "envoy.key_value.platform_test",
        keyValueStore: testStore
      )
      .setRuntimeGuard("test_feature_false", true)
      .build()

    let client = engine.streamClient()

    let requestHeaders = RequestHeadersBuilder(
      method: .get, scheme: "https",
      authority: "example.com", path: "/test"
    )
    .build()

    client
      .newStreamPrototype()
      .setOnError { _, _ in
        XCTFail("Unexpected error")
      }
      .start()
      .sendHeaders(requestHeaders, endStream: true)

    XCTAssertEqual(
      XCTWaiter.wait(for: [readExpectation, saveExpectation], timeout: 10),
      .completed
    )

    engine.terminate()
  }
}
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class SetEventTrackerTestNoTracker: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  // Skipping because this test currently attempts to connect to an invalid remote (example.com)
  func skipped_testSetEventTracker() throws {
    let expectation = self.expectation(description: "Response headers received")

    let engine = EngineBuilder()
      .addLogLevel(.trace)
      .addNativeFilter(
        name: "envoy.filters.http.test_event_tracker",
        // swiftlint:disable:next line_length
        typedConfig: "{\"@type\":\"type.googleapis.com/envoymobile.extensions.filters.http.test_event_tracker.TestEventTracker\",\"attributes\":{\"foo\":\"bar\"}}")
      .build()

    let client = engine.streamClient()

    let requestHeaders = RequestHeadersBuilder(method: .get, scheme: "https",
                                               authority: "example.com", path: "/test")
      .build()

    client
      .newStreamPrototype()
      .setOnResponseHeaders { _, _, _ in
        expectation.fulfill()
      }
      .start()
      .sendHeaders(requestHeaders, endStream: true)

    XCTAssertEqual(XCTWaiter.wait(for: [expectation], timeout: 10), .completed)

    engine.terminate()
  }
}
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class SendHeadersTests: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testSendHeaders() {
    // swiftlint:disable:next line_length
    let emhcmType = "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager"
    // swiftlint:disable:next line_length
    let assertionFilterType = "type.googleapis.com/envoymobile.extensions.filters.http.assertion.Assertion"
    let config =
"""
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: base_api_listener
    address:
      socket_address:
        protocol: TCP
        address: 0.0.0.0
        port_value: 10000
    api_listener:
      api_listener:
        "@type": \(emhcmType)
        config:
          stat_prefix: hcm
          route_config:
            name: api_router
            virtual_hosts:
              - name: api
                domains:
                  - "*"
                routes:
                  - match:
                      prefix: "/"
                    direct_response:
                      status: 200
          http_filters:
            - name: envoy.filters.http.assertion
              typed_config:
                "@type": \(assertionFilterType)
                match_config:
                  http_request_headers_match:
                    headers:
                      - name: ":authority"
                        exact_match: example.com
            - name: envoy.router
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
"""
    let expectation = self.expectation(description: "Run called with expected http status")
    let engine = EngineBuilder(yaml: config)
      .addLogLevel(.debug)
      .build()

    let client = engine.streamClient()

    let requestHeaders = RequestHeadersBuilder(method: .get, scheme: "https",
                                               authority: "example.com", path: "/test")
      .build()
    client
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, endStream, _ in
         XCTAssertEqual(200, responseHeaders.httpStatus)
         XCTAssertTrue(endStream)
         expectation.fulfill()
      }
      .setOnError { _, _ in
        XCTFail("Unexpected error")
      }
      .start()
      .sendHeaders(requestHeaders, endStream: true)

    XCTAssertEqual(XCTWaiter.wait(for: [expectation], timeout: 10), .completed)

    engine.terminate()
  }
}
#pragma once

#import <Foundation/Foundation.h>

#import "external/envoy_build_config/test_extensions.h"
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class ReceiveDataTests: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testReceiveData() {
    // swiftlint:disable:next line_length
    let emhcmType = "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager"
    // swiftlint:disable:next line_length
    let assertionFilterType = "type.googleapis.com/envoymobile.extensions.filters.http.assertion.Assertion"
    let assertionResponseBody = "response_body"
    let config =
"""
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: base_api_listener
    address:
      socket_address:
        protocol: TCP
        address: 0.0.0.0
        port_value: 10000
    api_listener:
      api_listener:
        "@type": \(emhcmType)
        config:
          stat_prefix: hcm
          route_config:
            name: api_router
            virtual_hosts:
              - name: api
                domains:
                  - "*"
                routes:
                  - match:
                      prefix: "/"
                    direct_response:
                      status: 200
                      body:
                        inline_string: \(assertionResponseBody)
          http_filters:
            - name: envoy.filters.http.assertion
              typed_config:
                "@type": \(assertionFilterType)
                match_config:
                  http_request_headers_match:
                    headers:
                      - name: ":authority"
                        exact_match: example.com
            - name: envoy.router
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
"""
    let engine = EngineBuilder(yaml: config)
      .addLogLevel(.debug)
      .build()

    let client = engine.streamClient()

    let requestHeaders = RequestHeadersBuilder(method: .get, scheme: "https",
                                               authority: "example.com", path: "/test")
      .build()

    let headersExpectation = self.expectation(description: "Run called with expected headers")
    let dataExpectation = self.expectation(description: "Run called with expected data")

    client
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, _, _ in
         XCTAssertEqual(200, responseHeaders.httpStatus)
         headersExpectation.fulfill()
      }
      .setOnResponseData { data, _, _ in
        let responseBody = String(data: data, encoding: .utf8)
        XCTAssertEqual(assertionResponseBody, responseBody)
        dataExpectation.fulfill()
      }
      .setOnError { _, _ in
        XCTFail("Unexpected error")
      }
      .start()
      .sendHeaders(requestHeaders, endStream: true)

    XCTAssertEqual(XCTWaiter.wait(for: [headersExpectation, dataExpectation], timeout: 10,
                                  enforceOrder: true),
                   .completed)

    engine.terminate()
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:apple.bzl", "envoy_mobile_swift_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

# TODO(jpsim): Fix remote execution for all the tests in this file.

envoy_mobile_swift_test(
    name = "end_to_end_networking_test",
    srcs = [
        "EndToEndNetworkingTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
        "//test/objective-c:envoy_test_server",
    ],
)

envoy_mobile_swift_test(
    name = "cancel_stream_test",
    srcs = [
        "CancelStreamTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "engine_api_test",
    srcs = [
        "EngineApiTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "filter_reset_idle",
    srcs = [
        "FilterResetIdleTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "grpc_receive_error",
    srcs = [
        "GRPCReceiveErrorTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "idle_timeout_test",
    srcs = [
        "IdleTimeoutTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
        "//test/objective-c:envoy_test_server",
    ],
)

envoy_mobile_swift_test(
    name = "key_value_store_test",
    srcs = [
        "KeyValueStoreTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "receive_data_test",
    srcs = [
        "ReceiveDataTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "receive_error_test",
    srcs = [
        "ReceiveErrorTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "reset_connectivity_state_test",
    srcs = [
        "ResetConnectivityStateTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "send_data_test",
    srcs = [
        "SendDataTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "send_headers_test",
    srcs = [
        "SendHeadersTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "send_trailers_test",
    srcs = [
        "SendTrailersTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "set_event_tracker_test",
    srcs = [
        "SetEventTrackerTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "set_event_tracker_test_no_tracker",
    srcs = [
        "SetEventTrackerTestNoTracker.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "set_logger_test",
    srcs = [
        "SetLoggerTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

envoy_mobile_swift_test(
    name = "cancel_grpc_stream_test",
    srcs = [
        "CancelGRPCStreamTest.swift",
    ],
    tags = [
        "no-remote-exec",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":test_extensions",
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)

objc_library(
    name = "test_extensions",
    hdrs = [
        "TestExtensions.h",
    ],
    module_name = "TestExtensions",
    deps = [
        "@envoy_build_config//:test_extensions_no_autoregister",
    ],
)
import Envoy
import EnvoyEngine
import EnvoyTestServer
import Foundation
import TestExtensions
import XCTest

final class IdleTimeoutTests: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testIdleTimeout() {
    let filterName = "reset_idle_test_filter"

    class IdleTimeoutValidationFilter: AsyncResponseFilter, ResponseFilter {
      let timeoutExpectation: XCTestExpectation
      var callbacks: ResponseFilterCallbacks!

      init(timeoutExpectation: XCTestExpectation) {
        self.timeoutExpectation = timeoutExpectation
      }

      func setResponseFilterCallbacks(_ callbacks: ResponseFilterCallbacks) {
        self.callbacks = callbacks
      }

      func onResumeResponse(
        headers: ResponseHeaders?,
        data: Data?,
        trailers: ResponseTrailers?,
        endStream: Bool,
        streamIntel: StreamIntel
      ) -> FilterResumeStatus<ResponseHeaders, ResponseTrailers> {
        XCTFail("Unexpected call to onResumeResponse")
        return .resumeIteration(headers: nil, data: nil, trailers: nil)
      }

      func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool, streamIntel: StreamIntel)
        -> FilterHeadersStatus<ResponseHeaders>
      {
        return .stopIteration
      }

      func onResponseData(_ body: Data, endStream: Bool, streamIntel: StreamIntel)
        -> FilterDataStatus<ResponseHeaders>
      {
        XCTFail("Unexpected call to onResponseData filter callback")
        return .stopIterationNoBuffer
      }

      func onResponseTrailers(_ trailers: ResponseTrailers, streamIntel: StreamIntel)
          -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
        XCTFail("Unexpected call to onResponseTrailers filter callback")
        return .stopIteration
      }

      func onError(_ error: EnvoyError, streamIntel: FinalStreamIntel) {
        XCTAssertEqual(error.errorCode, 4)
        timeoutExpectation.fulfill()
      }

      func onCancel(streamIntel: FinalStreamIntel) {
        XCTFail("Unexpected call to onCancel filter callback")
      }

      func onComplete(streamIntel: FinalStreamIntel) {}
    }

    let filterExpectation = self.expectation(description: "Stream idle timeout received by filter")
    let callbackExpectation =
      self.expectation(description: "Stream idle timeout received by callbacks")

    EnvoyTestServer.startHttp1PlaintextServer()

    let engine = EngineBuilder()
      .addLogLevel(.trace)
      .addStreamIdleTimeoutSeconds(1)
      .addPlatformFilter(
        name: filterName,
        factory: { IdleTimeoutValidationFilter(timeoutExpectation: filterExpectation) }
      )
      .build()

    let client = engine.streamClient()

    let port = String(EnvoyTestServer.getEnvoyPort())
    let requestHeaders = RequestHeadersBuilder(
      method: .get, scheme: "http", authority: "localhost:" + port, path: "/"
    )
    .build()

    client
      .newStreamPrototype()
      .setOnError { error, _ in
        XCTAssertEqual(error.errorCode, 4)
        callbackExpectation.fulfill()
      }
      .setOnCancel { _ in
        XCTFail("Unexpected call to onCancel filter callback")
      }
      .start()
      .sendHeaders(requestHeaders, endStream: false)

    XCTAssertEqual(
      XCTWaiter.wait(for: [filterExpectation, callbackExpectation], timeout: 10),
      .completed
    )

    engine.terminate()
    EnvoyTestServer.shutdownTestServer()
  }
}
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class SendTrailersTests: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testSendTrailers() throws {
    // swiftlint:disable:next line_length
    let emhcmType = "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager"
    // swiftlint:disable:next line_length
    let assertionFilterType = "type.googleapis.com/envoymobile.extensions.filters.http.assertion.Assertion"
    let matcherTrailerName = "test-trailer"
    let matcherTrailerValue = "test.code"
    let config =
"""
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: base_api_listener
    address:
      socket_address:
        protocol: TCP
        address: 0.0.0.0
        port_value: 10000
    api_listener:
      api_listener:
        "@type": \(emhcmType)
        config:
          stat_prefix: hcm
          route_config:
            name: api_router
            virtual_hosts:
              - name: api
                domains:
                  - "*"
                routes:
                  - match:
                      prefix: "/"
                    direct_response:
                      status: 200
          http_filters:
            - name: envoy.filters.http.assertion
              typed_config:
                "@type": \(assertionFilterType)
                match_config:
                  http_request_trailers_match:
                    headers:
                      - name: \(matcherTrailerName)
                        exact_match: \(matcherTrailerValue)
            - name: envoy.filters.http.buffer
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer
                max_request_bytes: 65000
            - name: envoy.router
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
"""
    let expectation = self.expectation(description: "Run called with expected http status")
    let engine = EngineBuilder(yaml: config)
      .addLogLevel(.debug)
      .build()

    let client = engine.streamClient()

    let requestHeaders = RequestHeadersBuilder(method: .get, scheme: "https",
                                               authority: "example.com", path: "/test")
      .build()
    let body = try XCTUnwrap("match_me".data(using: .utf8))
    let requestTrailers = RequestTrailersBuilder()
      .add(name: matcherTrailerName, value: matcherTrailerValue)
      .build()

    client
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, _, _ in
         XCTAssertEqual(200, responseHeaders.httpStatus)
         expectation.fulfill()
      }
      .setOnError { _, _ in
        XCTFail("Unexpected error")
      }
      .start()
      .sendHeaders(requestHeaders, endStream: false)
      .sendData(body)
      .close(trailers: requestTrailers)

    XCTAssertEqual(XCTWaiter.wait(for: [expectation], timeout: 10), .completed)

    engine.terminate()
  }
}
import Envoy
import EnvoyEngine
import Foundation
import TestExtensions
import XCTest

final class CancelGRPCStreamTests: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testCancelGRPCStream() {
    let filterName = "cancel_validation_filter"

// swiftlint:disable line_length
    let config =
"""
listener_manager:
    name: envoy.listener_manager_impl.api
    typed_config:
      "@type": type.googleapis.com/envoy.config.listener.v3.ApiListenerManager
static_resources:
  listeners:
  - name: base_api_listener
    address:
      socket_address: { protocol: TCP, address: 0.0.0.0, port_value: 10000 }
    api_listener:
      api_listener:
        "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager
        config:
          stat_prefix: api_hcm
          route_config:
            name: api_router
            virtual_hosts:
            - name: api
              domains: ["*"]
              routes:
              - match: { prefix: "/" }
                route: { cluster: fake_remote }
          http_filters:
          - name: envoy.filters.http.local_error
            typed_config:
              "@type": type.googleapis.com/envoymobile.extensions.filters.http.local_error.LocalError
          - name: envoy.filters.http.platform_bridge
            typed_config:
              "@type": type.googleapis.com/envoymobile.extensions.filters.http.platform_bridge.PlatformBridge
              platform_filter_name: \(filterName)
          - name: envoy.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
  clusters:
  - name: fake_remote
    connect_timeout: 0.25s
    type: STATIC
    lb_policy: ROUND_ROBIN
    load_assignment:
      cluster_name: fake_remote
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address: { address: 127.0.0.1, port_value: \(Int.random(in: 10001...11000)) }
"""
// swiftlint:enable line_length

    struct CancelValidationFilter: ResponseFilter {
      let expectation: XCTestExpectation

      func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool, streamIntel: StreamIntel)
        -> FilterHeadersStatus<ResponseHeaders>
      {
        return .continue(headers: headers)
      }

      func onResponseData(_ body: Data, endStream: Bool, streamIntel: StreamIntel)
        -> FilterDataStatus<ResponseHeaders>
      {
        return .continue(data: body)
      }

      func onResponseTrailers(_ trailers: ResponseTrailers, streamIntel: StreamIntel)
          -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {
        return .continue(trailers: trailers)
      }

      func onError(_ error: EnvoyError, streamIntel: FinalStreamIntel) {}

      func onCancel(streamIntel: FinalStreamIntel) {
        self.expectation.fulfill()
      }

      func onComplete(streamIntel: FinalStreamIntel) {}
    }

    let onCancelCallbackExpectation = self.expectation(description: "onCancel callback called")
    let filterExpectation = self.expectation(description: "Filter called with cancellation")

    let engine = EngineBuilder(yaml: config)
      .addLogLevel(.trace)
      .addPlatformFilter(
        name: filterName,
        factory: { CancelValidationFilter(expectation: filterExpectation) }
      )
      .build()

    let client = GRPCClient(streamClient: engine.streamClient())

    let requestHeaders = GRPCRequestHeadersBuilder(
        scheme: "https",
        authority: "example.com", path: "/test")
      .build()

    client
      .newGRPCStreamPrototype()
      .setOnCancel { _ in
         onCancelCallbackExpectation.fulfill()
      }
      .start()
      .sendHeaders(requestHeaders, endStream: false)
      .cancel()

    let expectations = [onCancelCallbackExpectation, filterExpectation]
    XCTAssertEqual(XCTWaiter.wait(for: expectations, timeout: 10), .completed)

    engine.terminate()
  }
}
import Envoy
import Foundation
import TestExtensions
import XCTest

final class EngineApiTest: XCTestCase {
  override static func setUp() {
    super.setUp()
    register_test_extensions()
  }

  func testEngineApis() throws {
    let engineExpectation = self.expectation(description: "Engine Running")

    let engine = EngineBuilder()
      .addLogLevel(.debug)
      .setOnEngineRunning {
        engineExpectation.fulfill()
      }
      .build()

    XCTAssertEqual(XCTWaiter.wait(for: [engineExpectation], timeout: 10), .completed)

    let pulseClient = engine.pulseClient()
    pulseClient.counter(elements: ["foo", "bar"]).increment(count: 1)

    XCTAssertTrue(engine.dumpStats().contains("foo.bar: 1"))

    engine.terminate()
  }
}
import Envoy
import Foundation
import XCTest

final class GRPCRequestHeadersBuilderTests: XCTestCase {
  func testAddsSchemeToHeaders() {
    let headers = GRPCRequestHeadersBuilder(scheme: "https",
                                            authority: "envoyproxy.io",
                                            path: "/pb.api.v1.Foo/GetBar")
      .build()
    XCTAssertEqual(["https"], headers.value(forName: ":scheme"))
    XCTAssertEqual("https", headers.scheme)
  }

  func testAddsAuthorityToHeaders() {
    let headers = GRPCRequestHeadersBuilder(scheme: "https",
                                            authority: "envoyproxy.io",
                                            path: "/pb.api.v1.Foo/GetBar")
      .build()
    XCTAssertEqual(["envoyproxy.io"], headers.value(forName: ":authority"))
    XCTAssertEqual("envoyproxy.io", headers.authority)
  }

  func testAddsPathToHeaders() {
    let headers = GRPCRequestHeadersBuilder(scheme: "https",
                                            authority: "envoyproxy.io",
                                            path: "/pb.api.v1.Foo/GetBar")
      .build()
    XCTAssertEqual(["/pb.api.v1.Foo/GetBar"], headers.value(forName: ":path"))
    XCTAssertEqual("/pb.api.v1.Foo/GetBar", headers.path)
  }

  func testAddsGRPCContentTypeHeader() {
    let headers = GRPCRequestHeadersBuilder(scheme: "https",
                                            authority: "envoyproxy.io",
                                            path: "/pb.api.v1.Foo/GetBar")
      .build()
    XCTAssertEqual(["application/grpc"], headers.value(forName: "content-type"))
  }

  func testUsesHTTPPOST() {
    let headers = GRPCRequestHeadersBuilder(scheme: "https",
                                            authority: "envoyproxy.io",
                                            path: "/pb.api.v1.Foo/GetBar")
      .build()
    XCTAssertEqual(.post, headers.method)
    XCTAssertEqual(["POST"], headers.value(forName: ":method"))
  }

  func testAddsTimeoutHeaderWhenSetToValue() {
    let headers = GRPCRequestHeadersBuilder(scheme: "https",
                                            authority: "envoyproxy.io",
                                            path: "/pb.api.v1.Foo/GetBar")
      .addTimeoutMs(200)
      .build()
    XCTAssertEqual(["200m"], headers.value(forName: "grpc-timeout"))
  }

  func testRemovesTimeoutHeaderWhenSetToNil() {
    let headers = GRPCRequestHeadersBuilder(scheme: "https",
                                            authority: "envoyproxy.io",
                                            path: "/pb.api.v1.Foo/GetBar")
      .addTimeoutMs(200)
      .addTimeoutMs(nil)
      .build()
    XCTAssertNil(headers.value(forName: "grpc-timeout"))
  }
}
@testable import Envoy
import XCTest

final class LogLevelCxxTests: XCTestCase {
  func testCxxDescription() {
    XCTAssertEqual(LogLevel.trace.cxxDescription, "trace")
    XCTAssertEqual(LogLevel.debug.cxxDescription, "debug")
    XCTAssertEqual(LogLevel.info.cxxDescription, "info")
    XCTAssertEqual(LogLevel.warn.cxxDescription, "warn")
    XCTAssertEqual(LogLevel.error.cxxDescription, "error")
    XCTAssertEqual(LogLevel.critical.cxxDescription, "critical")
    XCTAssertEqual(LogLevel.off.cxxDescription, "off")
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:apple.bzl", "envoy_mobile_swift_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_swift_test(
    name = "test",
    srcs = [
        "LogLevelCxxTests.swift",
    ],
    visibility = ["//visibility:public"],
    deps = [
        "//library/swift/EnvoyCxxSwiftInterop",
    ],
)
@testable import Envoy
import XCTest

final class RequestHeadersBuilderTests: XCTestCase {
  func testAddsMethodToHeaders() {
    let headers = RequestHeadersBuilder(method: .post, scheme: "https",
                                        authority: "envoyproxy.io", path: "/mock")
      .build()
    XCTAssertEqual(["POST"], headers.value(forName: ":method"))
    XCTAssertEqual(.post, headers.method)
  }

  func testAddsSchemeToHeaders() {
    let headers = RequestHeadersBuilder(method: .post, scheme: "https",
                                        authority: "envoyproxy.io", path: "/mock")
        .build()
    XCTAssertEqual(["https"], headers.value(forName: ":scheme"))
    XCTAssertEqual("https", headers.scheme)
  }

  func testAddsAuthorityToHeaders() {
    let headers = RequestHeadersBuilder(method: .post, scheme: "https",
                                        authority: "envoyproxy.io", path: "/mock")
        .build()
    XCTAssertEqual(["envoyproxy.io"], headers.value(forName: ":authority"))
    XCTAssertEqual("envoyproxy.io", headers.authority)
  }

  func testAddsPathToHeaders() {
    let headers = RequestHeadersBuilder(method: .post, scheme: "https",
                                        authority: "envoyproxy.io", path: "/mock")
        .build()
    XCTAssertEqual(["/mock"], headers.value(forName: ":path"))
    XCTAssertEqual("/mock", headers.path)
  }

  func testHttpScheme() {
    let headers = RequestHeadersBuilder(method: .post, scheme: "http",
                                        authority: "envoyproxy.io", path: "/mock")
        .build()
    XCTAssertEqual(["http"], headers.value(forName: ":scheme"))
  }

  func testJoinsHeaderValuesWithTheSameKey() {
    let headers = RequestHeadersBuilder(method: .post, scheme: "https",
                                        authority: "envoyproxy.io", path: "/mock")
        .add(name: "x-foo", value: "1")
        .add(name: "x-foo", value: "2")
        .build()
    XCTAssertEqual(["1", "2"], headers.value(forName: "x-foo"))
  }

  func testCannotPubliclyAddHeadersWithRestrictedPrefix() {
    let headers = RequestHeadersBuilder(method: .post, scheme: "https",
                                        authority: "envoyproxy.io", path: "/mock")
      .set(name: ":x-foo", value: ["123"])
      .set(name: "x-envoy-mobile-foo", value: ["abc"])
      .build()
    XCTAssertNil(headers.value(forName: ":x-foo"))
    XCTAssertNil(headers.value(forName: "x-envoy-mobile-foo"))
  }

  func testCannotPubliclySetHeadersWithRestrictedPrefix() {
    let headers = RequestHeadersBuilder(method: .post, scheme: "https",
                                        authority: "envoyproxy.io", path: "/mock")
      .add(name: ":x-foo", value: "123")
      .add(name: "x-envoy-mobile-foo", value: "abc")
      .build()
    XCTAssertNil(headers.value(forName: ":x-foo"))
    XCTAssertNil(headers.value(forName: "x-envoy-mobile-foo"))
  }

  func testCannotPubliclyRemoveHeadersWithRestrictedPrefix() {
    let headers = RequestHeadersBuilder(method: .post, scheme: "https",
                                        authority: "envoyproxy.io", path: "/mock")
      .remove(name: ":path")
      .build()
    XCTAssertEqual(["/mock"], headers.value(forName: ":path"))
  }

  func testCanInternallySetHeadersWithRestrictedPrefix() {
    let headers = RequestHeadersBuilder(method: .post, scheme: "https",
                                        authority: "envoyproxy.io", path: "/mock")
      .internalSet(name: ":x-foo", value: ["123"])
      .internalSet(name: "x-envoy-mobile-foo", value: ["abc"])
      .build()
    XCTAssertEqual(["123"], headers.value(forName: ":x-foo"))
    XCTAssertEqual(["abc"], headers.value(forName: "x-envoy-mobile-foo"))
  }

  func testIncludesRetryPolicyHeaders() {
    let retryPolicy = RetryPolicy(maxRetryCount: 123, retryOn: RetryRule.allCases,
                                  perRetryTimeoutMS: 9001)
    let retryHeaders = retryPolicy.outboundHeaders()
    let headers = RequestHeadersBuilder(method: .post, scheme: "https",
                                        authority: "envoyproxy.io", path: "/mock")
      .addRetryPolicy(retryPolicy)
      .build()

    XCTAssertFalse(retryHeaders.isEmpty)
    XCTAssertEqual(retryPolicy, headers.retryPolicy)
    for (retryHeader, expectedValue) in retryHeaders {
      XCTAssertEqual(expectedValue, headers.value(forName: retryHeader))
    }
  }

  func testRetryPolicyTakesPrecedenceOverManuallySetRetryHeaders() {
    let retryPolicy = RetryPolicy(maxRetryCount: 123, retryOn: RetryRule.allCases,
                                  perRetryTimeoutMS: 9001)
    let headers = RequestHeadersBuilder(method: .post, scheme: "https",
                                        authority: "envoyproxy.io", path: "/mock")
      .add(name: "x-envoy-max-retries", value: "override")
      .addRetryPolicy(retryPolicy)
      .build()

    XCTAssertEqual(["123"], headers.value(forName: "x-envoy-max-retries"))
  }

  func testConvertingToRequestHeadersAndBackMaintainsEquality() {
    let headers1 = RequestHeadersBuilder(method: .post, scheme: "https",
                                         authority: "envoyproxy.io", path: "/mock")
      .build()
    let headers2 = headers1.toRequestHeadersBuilder().build()
    XCTAssertEqual(headers1, headers2)
  }

  func testConvertingRetryPolicyToHeadersAndBackCreatesTheSameRetryPolicy() {
    let retryPolicy = RetryPolicy(maxRetryCount: 123, retryOn: RetryRule.allCases,
                                  retryStatusCodes: [400, 410], perRetryTimeoutMS: 9001)
    let headers = Headers(headers: retryPolicy.outboundHeaders())
    XCTAssertEqual(retryPolicy, RetryPolicy.from(headers: headers))
  }

  func testConvertingRequestMethodToStringAndBackCreatesTheSameRequestMethod() {
    for method in RequestMethod.allCases {
      XCTAssertEqual(method, RequestMethod(stringValue: method.stringValue))
    }
  }
}
@testable import Envoy
import XCTest

final class HeadersContainerTests: XCTestCase {
  func testInitializationPreservesAllHeadersFromInputHeadersMap() {
    let container = HeadersContainer(headers: ["a": ["456"], "b": ["123"]])
    XCTAssertEqual(["a": ["456"], "b": ["123"]], container.caseSensitiveHeaders())
  }

  func testInitializationIsCaseInsensitivePreservesCasingAndProcessesInAlphabeticalOrder() {
    let container = HeadersContainer(headers: ["a": ["456"], "A": ["123"]])
    XCTAssertEqual(["A": ["123", "456"]], container.caseSensitiveHeaders())
  }

  func testAddingHeaderAddsToListOfHeaders() {
    var container = HeadersContainer()
    container.add(name: "x-foo", value: "1")
    container.add(name: "x-foo", value: "2")

    XCTAssertEqual(["1", "2"], container.value(forName: "x-foo"))
  }

  func testAddingHeaderIsCaseInsensitiveAndPreservesHeaderNameCasing() {
    var container = HeadersContainer()
    container.add(name: "x-FOO", value: "1")
    container.add(name: "x-foo", value: "2")

    XCTAssertEqual(["1", "2"], container.value(forName: "x-foo"))
    XCTAssertEqual(["x-FOO": ["1", "2"]], container.caseSensitiveHeaders())
  }

  func testSettingHeaderAddsToListOfHeaders() {
    var container = HeadersContainer()
    container.set(name: "x-foo", value: ["abc"])

    XCTAssertEqual(["abc"], container.value(forName: "x-foo"))
  }

  func testSettingHeaderOverridesPreviousHeaderValues() {
    var container = HeadersContainer()
    container.add(name: "x-FOO", value: "1")
    container.add(name: "x-foo", value: "2")
    container.set(name: "x-foo", value: ["3"])

    XCTAssertEqual(["3"], container.value(forName: "x-foo"))
  }

  func testRemovingHeaderRemovesAllOfItsValues() {
    var container = HeadersContainer()
    container.add(name: "x-foo", value: "1")
    container.add(name: "x-foo", value: "2")
    container.remove(name: "x-foo")

    XCTAssertNil(container.value(forName: "x-foo"))
  }

  func testRemovingHeaderPerformsCaseInsensitiveHeaderNameLookup() {
    var container = HeadersContainer()
    container.add(name: "x-FOO", value: "1")
    container.add(name: "x-foo", value: "2")
    container.remove(name: "x-fOo")

    XCTAssertNil(container.value(forName: "x-foo"))
  }

  func testLookupIsCaseInsensitive() {
    var container = HeadersContainer()
    container.add(name: "x-FOO", value: "1")

    XCTAssertEqual(["1"], container.value(forName: "x-foo"))
    XCTAssertEqual(["1"], container.value(forName: "x-fOo"))
    XCTAssertEqual(["1"], container.value(forName: "x-FOO"))
  }
}
@testable import Envoy
import XCTest

final class RetryPolicyMapperTests: XCTestCase {
  func testConvertingToHeadersWithPerRetryTimeoutIncludesAllHeaders() {
    let policy = RetryPolicy(maxRetryCount: 3,
                             retryOn: RetryRule.allCases,
                             retryStatusCodes: [400, 422, 500],
                             perRetryTimeoutMS: 15_000,
                             totalUpstreamTimeoutMS: 60_000)
    let expectedHeaders = [
      "x-envoy-retriable-status-codes": ["400", "422", "500"],
      "x-envoy-max-retries": ["3"],
      "x-envoy-retry-on": [
        "5xx", "gateway-error", "connect-failure", "refused-stream", "retriable-4xx",
        "retriable-headers", "reset", "retriable-status-codes",
      ],
      "x-envoy-upstream-rq-per-try-timeout-ms": ["15000"],
      "x-envoy-upstream-rq-timeout-ms": ["60000"],
    ]

    XCTAssertEqual(expectedHeaders, policy.outboundHeaders())
  }

  func testConvertingHeaderValuesDelimitedWithCommaResultsInProperEnumValues() {
    let policy = RetryPolicy(maxRetryCount: 3,
                             retryOn: [.status5xx, .gatewayError],
                             retryStatusCodes: [400, 422, 500],
                             perRetryTimeoutMS: 15_000,
                             totalUpstreamTimeoutMS: 60_000)
    let headers = [
      "x-envoy-retriable-status-codes": ["400,422,500"],
      "x-envoy-max-retries": ["3"],
      "x-envoy-retry-on": ["5xx,gateway-error"],
      "x-envoy-upstream-rq-per-try-timeout-ms": ["15000"],
      "x-envoy-upstream-rq-timeout-ms": ["60000"],
    ]

    XCTAssertEqual(RetryPolicy.from(headers: Headers(headers: headers)), policy)
  }

  func testConvertingToHeadersWithoutRetryTimeoutExcludesPerRetryTimeoutHeader() {
    let policy = RetryPolicy(maxRetryCount: 123, retryOn: RetryRule.allCases)
    XCTAssertNil(policy.outboundHeaders()["x-envoy-upstream-rq-per-try-timeout-ms"])
  }

  func testConvertingToHeadersWithoutUpstreamTimeoutIncludesZeroForTimeoutHeader() {
    let policy = RetryPolicy(maxRetryCount: 123, retryOn: RetryRule.allCases,
                             totalUpstreamTimeoutMS: nil)
    XCTAssertEqual(["0"], policy.outboundHeaders()["x-envoy-upstream-rq-timeout-ms"])
  }

  func testConvertingToHeadersWithoutRetryStatusCodesDoesNotSetRetriableStatusCodeHeaders() throws {
    let policy = RetryPolicy(maxRetryCount: 123, retryOn: RetryRule.allCases,
                             retryStatusCodes: [])
    let headers = policy.outboundHeaders()
    XCTAssertNil(headers["x-envoy-retriable-status-codes"])
    XCTAssertFalse((try XCTUnwrap(headers["x-envoy-retry-on"])).contains("retriable-status-codes"))
  }
}
@testable import Envoy
import XCTest

private let kRetryPolicy = RetryPolicy(maxRetryCount: 123,
                                       retryOn: [.connectFailure, .status5xx],
                                       perRetryTimeoutMS: 9000)

final class HeadersBuilderTests: XCTestCase {
  func testAddingNewHeaderAddsToListOfHeaderKeys() {
    let headers = HeadersBuilder(headers: [:])
      .add(name: "x-foo", value: "1")
      .add(name: "x-foo", value: "2")
      .caseSensitiveHeaders()
    XCTAssertEqual(["1", "2"], headers["x-foo"])
  }

  func testRemovingSpecificHeaderKeyRemovesAllOfItsValues() {
    let headers = HeadersBuilder(headers: [:])
      .add(name: "x-foo", value: "1")
      .add(name: "x-foo", value: "2")
      .remove(name: "x-foo")
      .caseSensitiveHeaders()
    XCTAssertNil(headers["x-foo"])
  }

  func testRemovingSpecificHeaderKeyDoesNotRemoveOtherKeys() {
    let headers = HeadersBuilder(headers: [:])
      .add(name: "x-foo", value: "123")
      .add(name: "x-bar", value: "abc")
      .remove(name: "x-foo")
      .caseSensitiveHeaders()
    XCTAssertEqual(["x-bar": ["abc"]], headers)
  }

  func testSettingHeaderReplacesExistingHeadersWithMatchingName() {
    let headers = HeadersBuilder(headers: [:])
      .add(name: "x-foo", value: "123")
      .set(name: "x-foo", value: ["abc"])
      .caseSensitiveHeaders()
    XCTAssertEqual(["x-foo": ["abc"]], headers)
  }

  func testInitializationIsCaseInsensitivePreservesCasingAndProcessesInAlphabeticalOrder() {
    let headers = HeadersBuilder(headers: ["a": ["456"], "A": ["123"]])
    XCTAssertEqual(["A": ["123", "456"]], headers.caseSensitiveHeaders())
  }

  func testAddingHeaderIsCaseInsensitiveAndHeaderCasingIsPreserved() {
    let headers = HeadersBuilder(headers: [:])
    headers.add(name: "fOo", value: "abc")
    headers.add(name: "foo", value: "123")
    XCTAssertEqual(["fOo": ["abc", "123"]], headers.caseSensitiveHeaders())
  }

  func testSettingHeaderIsCaseInsensitiveAndHeaderCasingIsPreserved() {
    let headers = HeadersBuilder(headers: [:])
    headers.set(name: "foo", value: ["123"])
    headers.set(name: "fOo", value: ["abc"])
    XCTAssertEqual(["fOo": ["abc"]], headers.caseSensitiveHeaders())
  }

  func testRemovingHeaderIsCaseInsensitive() {
    let headers = HeadersBuilder(headers: [:])
    headers.set(name: "foo", value: ["123"])
    headers.remove(name: "fOo")
    XCTAssertEqual([:], headers.caseSensitiveHeaders())
  }

  func testRestrictedHeadersAreNotSettable() {
    let headers = RequestHeadersBuilder(method: .get, authority: "example.com", path: "/")
      .add(name: "host", value: "example.com")
      .add(name: "hostWithSuffix", value: "foo.bar")
      .set(name: ":scheme", value: ["http"])
      .set(name: ":path", value: ["/nope"])
      .caseSensitiveHeaders()
    let expected = [
      ":authority": ["example.com"],
      ":path": ["/"],
      ":method": ["GET"],
      ":scheme": ["https"],
      "hostWithSuffix": ["foo.bar"],
    ]
    XCTAssertEqual(expected, headers)
  }

  func testBuildersAreEqualIfUnderlyingHeadersAreEqual() {
    let builder1 = RequestHeadersBuilder(headers: ["x-foo": ["123"], "x-bar": ["abc"]])
    let builder2 = RequestHeadersBuilder(headers: ["x-foo": ["123"], "x-bar": ["abc"]])
    XCTAssertEqual(builder1, builder2)
  }

  func testHeadersAreEqualIfUnderlyingHeadersAreEqual() {
    let headers1 = RequestHeadersBuilder(headers: ["x-foo": ["123"], "x-bar": ["abc"]]).build()
    let headers2 = RequestHeadersBuilder(headers: ["x-foo": ["123"], "x-bar": ["abc"]]).build()
    XCTAssertEqual(headers1, headers2)
  }

  func testBuilderPointersAreNotEqualWhenInstancesAreDifferent() {
    let builder1 = RequestHeadersBuilder(headers: ["x-foo": ["123"], "x-bar": ["abc"]])
    let builder2 = RequestHeadersBuilder(headers: ["x-foo": ["123"], "x-bar": ["abc"]])
    XCTAssert(builder1 !== builder2)
  }

  func testHeadersPointersAreNotEqualWhenInstancesAreDifferent() {
    let headers1 = RequestHeadersBuilder(headers: ["x-foo": ["123"], "x-bar": ["abc"]]).build()
    let headers2 = RequestHeadersBuilder(headers: ["x-foo": ["123"], "x-bar": ["abc"]]).build()
    XCTAssert(headers1 !== headers2)
  }
}
@testable import Envoy
import XCTest

final class ResponseHeadersTests: XCTestCase {
  func testParsingStatusCodeFromHeadersReturnsFirstStatus() {
    let headers = [":status": ["204", "200"], "other": ["1"]]
    XCTAssertEqual(204, ResponseHeaders(headers: headers).httpStatus)
  }

  func testParsingInvalidStatusStringReturnsNil() {
    let headers = [":status": ["invalid"], "other": ["1"]]
    XCTAssertNil(ResponseHeaders(headers: headers).httpStatus)
  }

  func testParsingNegativeStatusReturnsNil() {
    let headers = [":status": ["-123"], "other": ["1"]]
    XCTAssertNil(ResponseHeaders(headers: headers).httpStatus)
  }

  func testParsingMissingStatusCodeReturnsNil() {
    XCTAssertNil(ResponseHeaders(headers: [:]).httpStatus)
  }

  func testAddingHttpStatusCodeSetsTheAppropriateHeader() {
    let headers = ResponseHeadersBuilder()
      .addHttpStatus(200)
      .build()
    XCTAssertEqual(200, headers.httpStatus)
  }
}
@testable import Envoy
import EnvoyEngine
import Foundation
import XCTest

// swiftlint:disable type_body_length

private struct TestFilter: Filter {}

final class EngineBuilderTests: XCTestCase {
  override func tearDown() {
    super.tearDown()
    MockEnvoyEngine.onRunWithConfig = nil
    MockEnvoyEngine.onRunWithYAML = nil
  }

  func testSetRuntimeGuard() {
    let bootstrapDebugDescription = EngineBuilder()
      .setRuntimeGuard("test_feature_false", true)
      .setRuntimeGuard("test_feature_true", false)
      .bootstrapDebugDescription()
    XCTAssertTrue(
      bootstrapDebugDescription.contains(#""test_feature_false" value { bool_value: true }"#)
    )
    XCTAssertTrue(
      bootstrapDebugDescription.contains(#""test_feature_true" value { bool_value: false }"#)
    )
  }

  func testMonitoringModeDefaultsToPathMonitor() {
    let builder = EngineBuilder()
    XCTAssertEqual(builder.monitoringMode, .pathMonitor)
  }

  func testMonitoringModeSetsToValue() {
    let builder = EngineBuilder()
      .setNetworkMonitoringMode(.disabled)
    XCTAssertEqual(builder.monitoringMode, .disabled)
    builder.setNetworkMonitoringMode(.reachability)
    XCTAssertEqual(builder.monitoringMode, .reachability)
  }

  func testCustomConfigYAMLUsesSpecifiedYAMLWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithYAML = { yaml, _, _ in
      XCTAssertEqual("foobar", yaml)
      expectation.fulfill()
    }

    _ = EngineBuilder(yaml: "foobar")
      .addEngineType(MockEnvoyEngine.self)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingLogLevelAddsLogLevelWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { _, logLevel in
      XCTAssertEqual("trace", logLevel)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addLogLevel(.trace)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testEnablingInterfaceBindingAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with enabled interface binding")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertTrue(config.enableInterfaceBinding)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .enableInterfaceBinding(true)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testEnforcingTrustChainVerificationAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with enforced cert verification")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertTrue(config.enforceTrustChainVerification)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .enforceTrustChainVerification(true)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testForceIPv6AddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with force IPv6")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertTrue(config.forceIPv6)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .forceIPv6(true)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingConnectTimeoutSecondsAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual(12345, config.connectTimeoutSeconds)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addConnectTimeoutSeconds(12345)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingDNSRefreshSecondsAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual(23, config.dnsRefreshSeconds)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addDNSRefreshSeconds(23)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingDNSMinRefreshSecondsAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual(23, config.dnsMinRefreshSeconds)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addDNSMinRefreshSeconds(23)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingDNSQueryTimeoutSecondsAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual(234, config.dnsQueryTimeoutSeconds)
      expectation.fulfill()
    }

    _ = EngineBuilder()
      .addEngineType(MockEnvoyEngine.self)
      .addDNSQueryTimeoutSeconds(234)
      .build()
    self.waitForExpectations(timeout: 0.01)
  }

  func testAddingDNSFailureRefreshSecondsAddsToConfigurationWhenRunningEnvoy() {
    let expectation = self.expectation(description: "Run called with expected data")
    MockEnvoyEngine.onRunWithConfig = { config, _ in
      XCTAssertEqual(1234, config.dnsFailureRef