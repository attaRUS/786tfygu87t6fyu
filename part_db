TCP connections.
// [#next-free-field: 6]
message FaultDelay {
  enum FaultDelayType {
    // Unused and deprecated.
    FIXED = 0;
  }

  // Fault delays are controlled via an HTTP header (if applicable). See the
  // :ref:`HTTP fault filter <config_http_filters_fault_injection_http_header>` documentation for
  // more information.
  message HeaderDelay {
  }

  reserved 2;

  // Unused and deprecated. Will be removed in the next release.
  FaultDelayType type = 1 [deprecated = true, (envoy.annotations.disallowed_by_default) = true];

  oneof fault_delay_secifier {
    option (validate.required) = true;

    // Add a fixed delay before forwarding the operation upstream. See
    // https://developers.google.com/protocol-buffers/docs/proto3#json for
    // the JSON/YAML Duration mapping. For HTTP/Mongo/Redis, the specified
    // delay will be injected before a new request/operation. For TCP
    // connections, the proxying of the connection upstream will be delayed
    // for the specified period. This is required if type is FIXED.
    google.protobuf.Duration fixed_delay = 3 [(validate.rules).duration = {gt {}}];

    // Fault delays are controlled via an HTTP header (if applicable).
    HeaderDelay header_delay = 5;
  }

  // The percentage of operations/connections/requests on which the delay will be injected.
  type.FractionalPercent percentage = 4;
}

// Describes a rate limit to be applied.
message FaultRateLimit {
  // Describes a fixed/constant rate limit.
  message FixedLimit {
    // The limit supplied in KiB/s.
    uint64 limit_kbps = 1 [(validate.rules).uint64 = {gte: 1}];
  }

  // Rate limits are controlled via an HTTP header (if applicable). See the
  // :ref:`HTTP fault filter <config_http_filters_fault_injection_http_header>` documentation for
  // more information.
  message HeaderLimit {
  }

  oneof limit_type {
    option (validate.required) = true;

    // A fixed rate limit.
    FixedLimit fixed_limit = 1;

    // Rate limits are controlled via an HTTP header (if applicable).
    HeaderLimit header_limit = 3;
  }

  // The percentage of operations/connections/requests on which the rate limit will be injected.
  type.FractionalPercent percentage = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/type:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.resource_monitor.injected_resource.v2alpha;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.resource_monitor.injected_resource.v2alpha";
option java_outer_classname = "InjectedResourceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/resource_monitor/injected_resource/v2alpha";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Injected resource]
// [#extension: envoy.resource_monitors.injected_resource]

// The injected resource monitor allows injecting a synthetic resource pressure into Envoy
// via a text file, which must contain a floating-point number in the range [0..1] representing
// the resource pressure and be updated atomically by a symbolic link swap.
// This is intended primarily for integration tests to force Envoy into an overloaded state.
message InjectedResourceConfig {
  string filename = 1 [(validate.rules).string = {min_bytes: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.resource_monitor.fixed_heap.v2alpha;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.resource_monitor.fixed_heap.v2alpha";
option java_outer_classname = "FixedHeapProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/resource_monitor/fixed_heap/v2alpha";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Fixed heap]
// [#extension: envoy.resource_monitors.fixed_heap]

// The fixed heap resource monitor reports the Envoy process memory pressure, computed as a
// fraction of currently reserved heap memory divided by a statically configured maximum
// specified in the FixedHeapConfig.
message FixedHeapConfig {
  uint64 max_heap_size_bytes = 1 [(validate.rules).uint64 = {gt: 0}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.health_checker.redis.v2;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.health_checker.redis.v2";
option java_outer_classname = "RedisProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/health_checker/redis/v2;redisv2";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Redis]
// Redis health checker :ref:`configuration overview <config_health_checkers_redis>`.
// [#extension: envoy.health_checkers.redis]

message Redis {
  // If set, optionally perform ``EXISTS <key>`` instead of ``PING``. A return value
  // from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
  // than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
  // by setting the specified key to any value and waiting for traffic to drain.
  string key = 1;
}
syntax = "proto3";

package envoy.config.upstream.local_address_selector.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.config.upstream.local_address_selector.v3";
option java_outer_classname = "DefaultLocalAddressSelectorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/upstream/local_address_selector/v3;local_address_selectorv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Default Local Address Selector]
// [#extension: envoy.upstream.local_address_selector.default_local_address_selector]

// Default implementation of a local address selector. This implementation is
// used if :ref:`local_address_selector
// <envoy_v3_api_field_config.core.v3.BindConfig.local_address_selector>` is not
// specified.
// This implementation supports the specification of only one address in
// :ref:`extra_source_addresses
// <envoy_v3_api_field_config.core.v3.BindConfig.extra_source_addresses>` which
// is appended to the address specified in the
// :ref:`source_address <envoy_v3_api_field_config.core.v3.BindConfig.source_address>`
// field. The extra address should have a different IP version than the address in the
// ``source_address`` field. The address which has the same IP
// version with the target host's address IP version will be used as bind address.
// If there is no same IP version address found, the address in the ``source_address`` field will
// be returned.
message DefaultLocalAddressSelector {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.config.overload.v3;

import "envoy/type/v3/percent.proto";

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.overload.v3";
option java_outer_classname = "OverloadProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/overload/v3;overloadv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Overload Manager]

// The Overload Manager provides an extensible framework to protect Envoy instances
// from overload of various resources (memory, cpu, file descriptors, etc).
// It monitors a configurable set of resources and notifies registered listeners
// when triggers related to those resources fire.

message ResourceMonitor {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.overload.v2alpha.ResourceMonitor";

  reserved 2;

  reserved "config";

  // The name of the resource monitor to instantiate. Must match a registered
  // resource monitor type.
  // See the :ref:`extensions listed in typed_config below <extension_category_envoy.resource_monitors>` for the default list of available resource monitor.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // Configuration for the resource monitor being instantiated.
  // [#extension-category: envoy.resource_monitors]
  oneof config_type {
    google.protobuf.Any typed_config = 3;
  }
}

message ThresholdTrigger {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.overload.v2alpha.ThresholdTrigger";

  // If the resource pressure is greater than or equal to this value, the trigger
  // will enter saturation.
  double value = 1 [(validate.rules).double = {lte: 1.0 gte: 0.0}];
}

message ScaledTrigger {
  // If the resource pressure is greater than this value, the trigger will be in the
  // :ref:`scaling <arch_overview_overload_manager-triggers-state>` state with value
  // ``(pressure - scaling_threshold) / (saturation_threshold - scaling_threshold)``.
  double scaling_threshold = 1 [(validate.rules).double = {lte: 1.0 gte: 0.0}];

  // If the resource pressure is greater than this value, the trigger will enter saturation.
  double saturation_threshold = 2 [(validate.rules).double = {lte: 1.0 gte: 0.0}];
}

message Trigger {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.overload.v2alpha.Trigger";

  // The name of the resource this is a trigger for.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  oneof trigger_oneof {
    option (validate.required) = true;

    ThresholdTrigger threshold = 2;

    ScaledTrigger scaled = 3;
  }
}

// Typed configuration for the "envoy.overload_actions.reduce_timeouts" action. See
// :ref:`the docs <config_overload_manager_reducing_timeouts>` for an example of how to configure
// the action with different timeouts and minimum values.
message ScaleTimersOverloadActionConfig {
  enum TimerType {
    // Unsupported value; users must explicitly specify the timer they want scaled.
    UNSPECIFIED = 0;

    // Adjusts the idle timer for downstream HTTP connections that takes effect when there are no active streams.
    // This affects the value of :ref:`HttpConnectionManager.common_http_protocol_options.idle_timeout
    // <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.idle_timeout>`
    HTTP_DOWNSTREAM_CONNECTION_IDLE = 1;

    // Adjusts the idle timer for HTTP streams initiated by downstream clients.
    // This affects the value of :ref:`RouteAction.idle_timeout <envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout>` and
    // :ref:`HttpConnectionManager.stream_idle_timeout
    // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
    HTTP_DOWNSTREAM_STREAM_IDLE = 2;

    // Adjusts the timer for how long downstream clients have to finish transport-level negotiations
    // before the connection is closed.
    // This affects the value of
    // :ref:`FilterChain.transport_socket_connect_timeout <envoy_v3_api_field_config.listener.v3.FilterChain.transport_socket_connect_timeout>`.
    TRANSPORT_SOCKET_CONNECT = 3;
  }

  message ScaleTimer {
    // The type of timer this minimum applies to.
    TimerType timer = 1 [(validate.rules).enum = {defined_only: true not_in: 0}];

    oneof overload_adjust {
      option (validate.required) = true;

      // Sets the minimum duration as an absolute value.
      google.protobuf.Duration min_timeout = 2;

      // Sets the minimum duration as a percentage of the maximum value.
      type.v3.Percent min_scale = 3;
    }
  }

  // A set of timer scaling rules to be applied.
  repeated ScaleTimer timer_scale_factors = 1 [(validate.rules).repeated = {min_items: 1}];
}

message OverloadAction {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.overload.v2alpha.OverloadAction";

  // The name of the overload action. This is just a well-known string that listeners can
  // use for registering callbacks. Custom overload actions should be named using reverse
  // DNS to ensure uniqueness.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // A set of triggers for this action. The state of the action is the maximum
  // state of all triggers, which can be scalar values between 0 and 1 or
  // saturated. Listeners are notified when the overload action changes state.
  // An overload manager action can only have one trigger for a given resource
  // e.g. :ref:`Trigger.name
  // <envoy_v3_api_field_config.overload.v3.Trigger.name>` must be unique
  // in this list.
  repeated Trigger triggers = 2 [(validate.rules).repeated = {min_items: 1}];

  // Configuration for the action being instantiated.
  google.protobuf.Any typed_config = 3;
}

// A point within the connection or request lifecycle that provides context on
// whether to shed load at that given stage for the current entity at the
// point.
message LoadShedPoint {
  // This is just a well-known string for the LoadShedPoint.
  // Deployment specific LoadShedPoints e.g. within a custom extension should
  // be prefixed by the company / deployment name to avoid colliding with any
  // open source LoadShedPoints.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // A set of triggers for this LoadShedPoint. The LoadShedPoint will use the
  // the maximum state of all triggers, which can be scalar values between 0 and
  // 1 or saturated. A LoadShedPoint can only have one trigger for a given
  // resource e.g. :ref:`Trigger.name
  // <envoy_v3_api_field_config.overload.v3.Trigger.name>` must be unique in
  // this list.
  repeated Trigger triggers = 2 [(validate.rules).repeated = {min_items: 1}];
}

// Configuration for which accounts the WatermarkBuffer Factories should
// track.
message BufferFactoryConfig {
  // The minimum power of two at which Envoy starts tracking an account.
  //
  // Envoy has 8 power of two buckets starting with the provided exponent below.
  // Concretely the 1st bucket contains accounts for streams that use
  // [2^minimum_account_to_track_power_of_two,
  // 2^(minimum_account_to_track_power_of_two + 1)) bytes.
  // With the 8th bucket tracking accounts
  // >= 128 * 2^minimum_account_to_track_power_of_two.
  //
  // The maximum value is 56, since we're using uint64_t for bytes counting,
  // and that's the last value that would use the 8 buckets. In practice,
  // we don't expect the proxy to be holding 2^56 bytes.
  //
  // If omitted, Envoy should not do any tracking.
  uint32 minimum_account_to_track_power_of_two = 1 [(validate.rules).uint32 = {lte: 56 gte: 10}];
}

// [#next-free-field: 6]
message OverloadManager {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.overload.v2alpha.OverloadManager";

  // The interval for refreshing resource usage.
  google.protobuf.Duration refresh_interval = 1;

  // The set of resources to monitor.
  repeated ResourceMonitor resource_monitors = 2 [(validate.rules).repeated = {min_items: 1}];

  // The set of overload actions.
  repeated OverloadAction actions = 3;

  // The set of load shed points.
  repeated LoadShedPoint loadshed_points = 5;

  // Configuration for buffer factory.
  BufferFactoryConfig buffer_factory_config = 4;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.config.overload.v2alpha;

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.overload.v2alpha";
option java_outer_classname = "OverloadProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/config/overload/v2alpha";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Overload Manager]

// The Overload Manager provides an extensible framework to protect Envoy instances
// from overload of various resources (memory, cpu, file descriptors, etc).
// It monitors a configurable set of resources and notifies registered listeners
// when triggers related to those resources fire.

message ResourceMonitor {
  // The name of the resource monitor to instantiate. Must match a registered
  // resource monitor type. The built-in resource monitors are:
  //
  // * :ref:`envoy.resource_monitors.fixed_heap
  //   <envoy_api_msg_config.resource_monitor.fixed_heap.v2alpha.FixedHeapConfig>`
  // * :ref:`envoy.resource_monitors.injected_resource
  //   <envoy_api_msg_config.resource_monitor.injected_resource.v2alpha.InjectedResourceConfig>`
  string name = 1 [(validate.rules).string = {min_bytes: 1}];

  // Configuration for the resource monitor being instantiated.
  oneof config_type {
    google.protobuf.Struct config = 2 [deprecated = true];

    google.protobuf.Any typed_config = 3;
  }
}

message ThresholdTrigger {
  // If the resource pressure is greater than or equal to this value, the trigger
  // will fire.
  double value = 1 [(validate.rules).double = {lte: 1.0 gte: 0.0}];
}

message Trigger {
  // The name of the resource this is a trigger for.
  string name = 1 [(validate.rules).string = {min_bytes: 1}];

  oneof trigger_oneof {
    option (validate.required) = true;

    ThresholdTrigger threshold = 2;
  }
}

message OverloadAction {
  // The name of the overload action. This is just a well-known string that listeners can
  // use for registering callbacks. Custom overload actions should be named using reverse
  // DNS to ensure uniqueness.
  string name = 1 [(validate.rules).string = {min_bytes: 1}];

  // A set of triggers for this action. If any of these triggers fire the overload action
  // is activated. Listeners are notified when the overload action transitions from
  // inactivated to activated, or vice versa.
  repeated Trigger triggers = 2 [(validate.rules).repeated = {min_items: 1}];
}

message OverloadManager {
  // The interval for refreshing resource usage.
  google.protobuf.Duration refresh_interval = 1;

  // The set of resources to monitor.
  repeated ResourceMonitor resource_monitors = 2 [(validate.rules).repeated = {min_items: 1}];

  // The set of overload actions.
  repeated OverloadAction actions = 3;
}
syntax = "proto3";

package envoy.admin.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.admin.v3";
option java_outer_classname = "MutexStatsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v3;adminv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: MutexStats]

// Proto representation of the statistics collected upon absl::Mutex contention, if Envoy is run
// under :option:`--enable-mutex-tracing`. For more information, see the ``absl::Mutex``
// [docs](https://abseil.io/about/design/mutex#extra-features).
//
// *NB*: The wait cycles below are measured by ``absl::base_internal::CycleClock``, and may not
// correspond to core clock frequency. For more information, see the ``CycleClock``
// [docs](https://github.com/abseil/abseil-cpp/blob/master/absl/base/internal/cycleclock.h).
message MutexStats {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.MutexStats";

  // The number of individual mutex contentions which have occurred since startup.
  uint64 num_contentions = 1;

  // The length of the current contention wait cycle.
  uint64 current_wait_cycles = 2;

  // The lifetime total of all contention wait cycles.
  uint64 lifetime_wait_cycles = 3;
}
syntax = "proto3";

package envoy.admin.v3;

import "envoy/admin/v3/metrics.proto";
import "envoy/config/cluster/v3/circuit_breaker.proto";
import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/health_check.proto";
import "envoy/type/v3/percent.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.admin.v3";
option java_outer_classname = "ClustersProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v3;adminv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Clusters]

// Admin endpoint uses this wrapper for ``/clusters`` to display cluster status information.
// See :ref:`/clusters <operations_admin_interface_clusters>` for more information.
message Clusters {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.Clusters";

  // Mapping from cluster name to each cluster's status.
  repeated ClusterStatus cluster_statuses = 1;
}

// Details an individual cluster's current status.
// [#next-free-field: 9]
message ClusterStatus {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.ClusterStatus";

  // Name of the cluster.
  string name = 1;

  // Denotes whether this cluster was added via API or configured statically.
  bool added_via_api = 2;

  // The success rate threshold used in the last interval.
  // If
  // :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  // is ``false``, all errors: externally and locally generated were used to calculate the threshold.
  // If
  // :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  // is ``true``, only externally generated errors were used to calculate the threshold.
  // The threshold is used to eject hosts based on their success rate. See
  // :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for details.
  //
  // Note: this field may be omitted in any of the three following cases:
  //
  // 1. There were not enough hosts with enough request volume to proceed with success rate based
  //    outlier ejection.
  // 2. The threshold is computed to be < 0 because a negative value implies that there was no
  //    threshold for that interval.
  // 3. Outlier detection is not enabled for this cluster.
  type.v3.Percent success_rate_ejection_threshold = 3;

  // Mapping from host address to the host's current status.
  repeated HostStatus host_statuses = 4;

  // The success rate threshold used in the last interval when only locally originated failures were
  // taken into account and externally originated errors were treated as success.
  // This field should be interpreted only when
  // :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  // is ``true``. The threshold is used to eject hosts based on their success rate.
  // See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
  // details.
  //
  // Note: this field may be omitted in any of the three following cases:
  //
  // 1. There were not enough hosts with enough request volume to proceed with success rate based
  //    outlier ejection.
  // 2. The threshold is computed to be < 0 because a negative value implies that there was no
  //    threshold for that interval.
  // 3. Outlier detection is not enabled for this cluster.
  type.v3.Percent local_origin_success_rate_ejection_threshold = 5;

  // :ref:`Circuit breaking <arch_overview_circuit_break>` settings of the cluster.
  config.cluster.v3.CircuitBreakers circuit_breakers = 6;

  // Observability name of the cluster.
  string observability_name = 7;

  // The :ref:`EDS service name <envoy_v3_api_field_config.cluster.v3.Cluster.EdsClusterConfig.service_name>` if the cluster is an EDS cluster.
  string eds_service_name = 8;
}

// Current state of a particular host.
// [#next-free-field: 10]
message HostStatus {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.HostStatus";

  // Address of this host.
  config.core.v3.Address address = 1;

  // List of stats specific to this host.
  repeated SimpleMetric stats = 2;

  // The host's current health status.
  HostHealthStatus health_status = 3;

  // Request success rate for this host over the last calculated interval.
  // If
  // :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  // is ``false``, all errors: externally and locally generated were used in success rate
  // calculation. If
  // :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  // is ``true``, only externally generated errors were used in success rate calculation.
  // See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
  // details.
  //
  // Note: the message will not be present if host did not have enough request volume to calculate
  // success rate or the cluster did not have enough hosts to run through success rate outlier
  // ejection.
  type.v3.Percent success_rate = 4;

  // The host's weight. If not configured, the value defaults to 1.
  uint32 weight = 5;

  // The hostname of the host, if applicable.
  string hostname = 6;

  // The host's priority. If not configured, the value defaults to 0 (highest priority).
  uint32 priority = 7;

  // Request success rate for this host over the last calculated
  // interval when only locally originated errors are taken into account and externally originated
  // errors were treated as success.
  // This field should be interpreted only when
  // :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  // is ``true``.
  // See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
  // details.
  //
  // Note: the message will not be present if host did not have enough request volume to calculate
  // success rate or the cluster did not have enough hosts to run through success rate outlier
  // ejection.
  type.v3.Percent local_origin_success_rate = 8;

  // locality of the host.
  config.core.v3.Locality locality = 9;
}

// Health status for a host.
// [#next-free-field: 9]
message HostHealthStatus {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.admin.v2alpha.HostHealthStatus";

  // The host is currently failing active health checks.
  bool failed_active_health_check = 1;

  // The host is currently considered an outlier and has been ejected.
  bool failed_outlier_check = 2;

  // The host is currently being marked as degraded through active health checking.
  bool failed_active_degraded_check = 4;

  // The host has been removed from service discovery, but is being stabilized due to active
  // health checking.
  bool pending_dynamic_removal = 5;

  // The host has not yet been health checked.
  bool pending_active_hc = 6;

  // The host should be excluded from panic, spillover, etc. calculations because it was explicitly
  // taken out of rotation via protocol signal and is not meant to be routed to.
  bool excluded_via_immediate_hc_fail = 7;

  // The host failed active HC due to timeout.
  bool active_hc_timeout = 8;

  // Health status as reported by EDS. Note: only HEALTHY and UNHEALTHY are currently supported
  // here.
  // [#comment:TODO(mrice32): pipe through remaining EDS health status possibilities.]
  config.core.v3.HealthStatus eds_health_status = 3;
}
syntax = "proto3";

package envoy.admin.v3;

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.admin.v3";
option java_outer_classname = "ConfigDumpSharedProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v3;adminv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: ConfigDump]

// Resource status from the view of a xDS client, which tells the synchronization
// status between the xDS client and the xDS server.
enum ClientResourceStatus {
  // Resource status is not available/unknown.
  UNKNOWN = 0;

  // Client requested this resource but hasn't received any update from management
  // server. The client will not fail requests, but will queue them until update
  // arrives or the client times out waiting for the resource.
  REQUESTED = 1;

  // This resource has been requested by the client but has either not been
  // delivered by the server or was previously delivered by the server and then
  // subsequently removed from resources provided by the server. For more
  // information, please refer to the :ref:`"Knowing When a Requested Resource
  // Does Not Exist" <xds_protocol_resource_not_existed>` section.
  DOES_NOT_EXIST = 2;

  // Client received this resource and replied with ACK.
  ACKED = 3;

  // Client received this resource and replied with NACK.
  NACKED = 4;
}

message UpdateFailureState {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.admin.v2alpha.UpdateFailureState";

  // What the component configuration would have been if the update had succeeded.
  // This field may not be populated by xDS clients due to storage overhead.
  google.protobuf.Any failed_configuration = 1;

  // Time of the latest failed update attempt.
  google.protobuf.Timestamp last_update_attempt = 2;

  // Details about the last failed update attempt.
  string details = 3;

  // This is the version of the rejected resource.
  // [#not-implemented-hide:]
  string version_info = 4;
}

// Envoy's listener manager fills this message with all currently known listeners. Listener
// configuration information can be used to recreate an Envoy configuration by populating all
// listeners as static listeners or by returning them in a LDS response.
message ListenersConfigDump {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.admin.v2alpha.ListenersConfigDump";

  // Describes a statically loaded listener.
  message StaticListener {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.admin.v2alpha.ListenersConfigDump.StaticListener";

    // The listener config.
    google.protobuf.Any listener = 1;

    // The timestamp when the Listener was last successfully updated.
    google.protobuf.Timestamp last_updated = 2;
  }

  message DynamicListenerState {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState";

    // This is the per-resource version information. This version is currently taken from the
    // :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time
    // that the listener was loaded. In the future, discrete per-listener versions may be supported
    // by the API.
    string version_info = 1;

    // The listener config.
    google.protobuf.Any listener = 2;

    // The timestamp when the Listener was last successfully updated.
    google.protobuf.Timestamp last_updated = 3;
  }

  // Describes a dynamically loaded listener via the LDS API.
  // [#next-free-field: 7]
  message DynamicListener {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.admin.v2alpha.ListenersConfigDump.DynamicListener";

    // The name or unique id of this listener, pulled from the DynamicListenerState config.
    string name = 1;

    // The listener state for any active listener by this name.
    // These are listeners that are available to service data plane traffic.
    DynamicListenerState active_state = 2;

    // The listener state for any warming listener by this name.
    // These are listeners that are currently undergoing warming in preparation to service data
    // plane traffic. Note that if attempting to recreate an Envoy configuration from a
    // configuration dump, the warming listeners should generally be discarded.
    DynamicListenerState warming_state = 3;

    // The listener state for any draining listener by this name.
    // These are listeners that are currently undergoing draining in preparation to stop servicing
    // data plane traffic. Note that if attempting to recreate an Envoy configuration from a
    // configuration dump, the draining listeners should generally be discarded.
    DynamicListenerState draining_state = 4;

    // Set if the last update failed, cleared after the next successful update.
    // The ``error_state`` field contains the rejected version of this particular
    // resource along with the reason and timestamp. For successfully updated or
    // acknowledged resource, this field should be empty.
    UpdateFailureState error_state = 5;

    // The client status of this resource.
    // [#not-implemented-hide:]
    ClientResourceStatus client_status = 6;
  }

  // This is the :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` in the
  // last processed LDS discovery response. If there are only static bootstrap listeners, this field
  // will be "".
  string version_info = 1;

  // The statically loaded listener configs.
  repeated StaticListener static_listeners = 2;

  // State for any warming, active, or draining listeners.
  repeated DynamicListener dynamic_listeners = 3;
}

// Envoy's cluster manager fills this message with all currently known clusters. Cluster
// configuration information can be used to recreate an Envoy configuration by populating all
// clusters as static clusters or by returning them in a CDS response.
message ClustersConfigDump {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.admin.v2alpha.ClustersConfigDump";

  // Describes a statically loaded cluster.
  message StaticCluster {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.admin.v2alpha.ClustersConfigDump.StaticCluster";

    // The cluster config.
    google.protobuf.Any cluster = 1;

    // The timestamp when the Cluster was last updated.
    google.protobuf.Timestamp last_updated = 2;
  }

  // Describes a dynamically loaded cluster via the CDS API.
  // [#next-free-field: 6]
  message DynamicCluster {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster";

    // This is the per-resource version information. This version is currently taken from the
    // :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time
    // that the cluster was loaded. In the future, discrete per-cluster versions may be supported by
    // the API.
    string version_info = 1;

    // The cluster config.
    google.protobuf.Any cluster = 2;

    // The timestamp when the Cluster was last updated.
    google.protobuf.Timestamp last_updated = 3;

    // Set if the last update failed, cleared after the next successful update.
    // The ``error_state`` field contains the rejected version of this particular
    // resource along with the reason and timestamp. For successfully updated or
    // acknowledged resource, this field should be empty.
    // [#not-implemented-hide:]
    UpdateFailureState error_state = 4;

    // The client status of this resource.
    // [#not-implemented-hide:]
    ClientResourceStatus client_status = 5;
  }

  // This is the :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` in the
  // last processed CDS discovery response. If there are only static bootstrap clusters, this field
  // will be "".
  string version_info = 1;

  // The statically loaded cluster configs.
  repeated StaticCluster static_clusters = 2;

  // The dynamically loaded active clusters. These are clusters that are available to service
  // data plane traffic.
  repeated DynamicCluster dynamic_active_clusters = 3;

  // The dynamically loaded warming clusters. These are clusters that are currently undergoing
  // warming in preparation to service data plane traffic. Note that if attempting to recreate an
  // Envoy configuration from a configuration dump, the warming clusters should generally be
  // discarded.
  repeated DynamicCluster dynamic_warming_clusters = 4;
}

// Envoy's RDS implementation fills this message with all currently loaded routes, as described by
// their RouteConfiguration objects. Static routes that are either defined in the bootstrap configuration
// or defined inline while configuring listeners are separated from those configured dynamically via RDS.
// Route configuration information can be used to recreate an Envoy configuration by populating all routes
// as static routes or by returning them in RDS responses.
message RoutesConfigDump {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.admin.v2alpha.RoutesConfigDump";

  message StaticRouteConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.admin.v2alpha.RoutesConfigDump.StaticRouteConfig";

    // The route config.
    google.protobuf.Any route_config = 1;

    // The timestamp when the Route was last updated.
    google.protobuf.Timestamp last_updated = 2;
  }

  // [#next-free-field: 6]
  message DynamicRouteConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.admin.v2alpha.RoutesConfigDump.DynamicRouteConfig";

    // This is the per-resource version information. This version is currently taken from the
    // :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time that
    // the route configuration was loaded.
    string version_info = 1;

    // The route config.
    google.protobuf.Any route_config = 2;

    // The timestamp when the Route was last updated.
    google.protobuf.Timestamp last_updated = 3;

    // Set if the last update failed, cleared after the next successful update.
    // The ``error_state`` field contains the rejected version of this particular
    // resource along with the reason and timestamp. For successfully updated or
    // acknowledged resource, this field should be empty.
    // [#not-implemented-hide:]
    UpdateFailureState error_state = 4;

    // The client status of this resource.
    // [#not-implemented-hide:]
    ClientResourceStatus client_status = 5;
  }

  // The statically loaded route configs.
  repeated StaticRouteConfig static_route_configs = 2;

  // The dynamically loaded route configs.
  repeated DynamicRouteConfig dynamic_route_configs = 3;
}

// Envoy's scoped RDS implementation fills this message with all currently loaded route
// configuration scopes (defined via ScopedRouteConfigurationsSet protos). This message lists both
// the scopes defined inline with the higher order object (i.e., the HttpConnectionManager) and the
// dynamically obtained scopes via the SRDS API.
message ScopedRoutesConfigDump {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.admin.v2alpha.ScopedRoutesConfigDump";

  message InlineScopedRouteConfigs {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.admin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigs";

    // The name assigned to the scoped route configurations.
    string name = 1;

    // The scoped route configurations.
    repeated google.protobuf.Any scoped_route_configs = 2;

    // The timestamp when the scoped route config set was last updated.
    google.protobuf.Timestamp last_updated = 3;
  }

  // [#next-free-field: 7]
  message DynamicScopedRouteConfigs {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScopedRouteConfigs";

    // The name assigned to the scoped route configurations.
    string name = 1;

    // This is the per-resource version information. This version is currently taken from the
    // :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time that
    // the scoped routes configuration was loaded.
    string version_info = 2;

    // The scoped route configurations.
    repeated google.protobuf.Any scoped_route_configs = 3;

    // The timestamp when the scoped route config set was last updated.
    google.protobuf.Timestamp last_updated = 4;

    // Set if the last update failed, cleared after the next successful update.
    // The ``error_state`` field contains the rejected version of this particular
    // resource along with the reason and timestamp. For successfully updated or
    // acknowledged resource, this field should be empty.
    // [#not-implemented-hide:]
    UpdateFailureState error_state = 5;

    // The client status of this resource.
    // [#not-implemented-hide:]
    ClientResourceStatus client_status = 6;
  }

  // The statically loaded scoped route configs.
  repeated InlineScopedRouteConfigs inline_scoped_route_configs = 1;

  // The dynamically loaded scoped route configs.
  repeated DynamicScopedRouteConfigs dynamic_scoped_route_configs = 2;
}

// Envoy's admin fill this message with all currently known endpoints. Endpoint
// configuration information can be used to recreate an Envoy configuration by populating all
// endpoints as static endpoints or by returning them in an EDS response.
message EndpointsConfigDump {
  message StaticEndpointConfig {
    // The endpoint config.
    google.protobuf.Any endpoint_config = 1;

    // [#not-implemented-hide:] The timestamp when the Endpoint was last updated.
    google.protobuf.Timestamp last_updated = 2;
  }

  // [#next-free-field: 6]
  message DynamicEndpointConfig {
    // [#not-implemented-hide:] This is the per-resource version information. This version is currently taken from the
    // :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time that
    // the endpoint configuration was loaded.
    string version_info = 1;

    // The endpoint config.
    google.protobuf.Any endpoint_config = 2;

    // [#not-implemented-hide:] The timestamp when the Endpoint was last updated.
    google.protobuf.Timestamp last_updated = 3;

    // Set if the last update failed, cleared after the next successful update.
    // The ``error_state`` field contains the rejected version of this particular
    // resource along with the reason and timestamp. For successfully updated or
    // acknowledged resource, this field should be empty.
    // [#not-implemented-hide:]
    UpdateFailureState error_state = 4;

    // The client status of this resource.
    // [#not-implemented-hide:]
    ClientResourceStatus client_status = 5;
  }

  // The statically loaded endpoint configs.
  repeated StaticEndpointConfig static_endpoint_configs = 2;

  // The dynamically loaded endpoint configs.
  repeated DynamicEndpointConfig dynamic_endpoint_configs = 3;
}

// Envoy's ECDS service fills this message with all currently extension
// configuration. Extension configuration information can be used to recreate
// an Envoy ECDS listener and HTTP filters as static filters or by returning
// them in ECDS response.
message EcdsConfigDump {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.EcdsConfigDump";

  // [#next-free-field: 6]
  message EcdsFilterConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.admin.v2alpha.EcdsConfigDump.EcdsFilterConfig";

    // This is the per-resource version information. This version is currently
    // taken from the :ref:`version_info
    // <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>`
    // field at the time that the ECDS filter was loaded.
    string version_info = 1;

    // The ECDS filter config.
    google.protobuf.Any ecds_filter = 2;

    // The timestamp when the ECDS filter was last updated.
    google.protobuf.Timestamp last_updated = 3;

    // Set if the last update failed, cleared after the next successful update.
    // The ``error_state`` field contains the rejected version of this
    // particular resource along with the reason and timestamp. For successfully
    // updated or acknowledged resource, this field should be empty.
    // [#not-implemented-hide:]
    UpdateFailureState error_state = 4;

    // The client status of this resource.
    // [#not-implemented-hide:]
    ClientResourceStatus client_status = 5;
  }

  // The ECDS filter configs.
  repeated EcdsFilterConfig ecds_filters = 1;
}
syntax = "proto3";

package envoy.admin.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.admin.v3";
option java_outer_classname = "MemoryProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v3;adminv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Memory]

// Proto representation of the internal memory consumption of an Envoy instance. These represent
// values extracted from an internal TCMalloc instance. For more information, see the section of the
// docs entitled ["Generic Tcmalloc Status"](https://gperftools.github.io/gperftools/tcmalloc.html).
// [#next-free-field: 7]
message Memory {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.Memory";

  // The number of bytes allocated by the heap for Envoy. This is an alias for
  // ``generic.current_allocated_bytes``.
  uint64 allocated = 1;

  // The number of bytes reserved by the heap but not necessarily allocated. This is an alias for
  // ``generic.heap_size``.
  uint64 heap_size = 2;

  // The number of bytes in free, unmapped pages in the page heap. These bytes always count towards
  // virtual memory usage, and depending on the OS, typically do not count towards physical memory
  // usage. This is an alias for ``tcmalloc.pageheap_unmapped_bytes``.
  uint64 pageheap_unmapped = 3;

  // The number of bytes in free, mapped pages in the page heap. These bytes always count towards
  // virtual memory usage, and unless the underlying memory is swapped out by the OS, they also
  // count towards physical memory usage. This is an alias for ``tcmalloc.pageheap_free_bytes``.
  uint64 pageheap_free = 4;

  // The amount of memory used by the TCMalloc thread caches (for small objects). This is an alias
  // for ``tcmalloc.current_total_thread_cache_bytes``.
  uint64 total_thread_cache = 5;

  // The number of bytes of the physical memory usage by the allocator. This is an alias for
  // ``generic.total_physical_bytes``.
  uint64 total_physical_bytes = 6;
}
syntax = "proto3";

package envoy.admin.v3;

import "envoy/admin/v3/config_dump_shared.proto";
import "envoy/config/bootstrap/v3/bootstrap.proto";

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.admin.v3";
option java_outer_classname = "ConfigDumpProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v3;adminv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: ConfigDump]

// The :ref:`/config_dump <operations_admin_interface_config_dump>` admin endpoint uses this wrapper
// message to maintain and serve arbitrary configuration information from any component in Envoy.
message ConfigDump {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.ConfigDump";

  // This list is serialized and dumped in its entirety at the
  // :ref:`/config_dump <operations_admin_interface_config_dump>` endpoint.
  //
  // The following configurations are currently supported and will be dumped in the order given
  // below:
  //
  // * ``bootstrap``: :ref:`BootstrapConfigDump <envoy_v3_api_msg_admin.v3.BootstrapConfigDump>`
  // * ``clusters``: :ref:`ClustersConfigDump <envoy_v3_api_msg_admin.v3.ClustersConfigDump>`
  // * ``ecds_filter_http``: :ref:`EcdsConfigDump <envoy_v3_api_msg_admin.v3.EcdsConfigDump>`
  // * ``ecds_filter_quic_listener``: :ref:`EcdsConfigDump <envoy_v3_api_msg_admin.v3.EcdsConfigDump>`
  // * ``ecds_filter_tcp_listener``: :ref:`EcdsConfigDump <envoy_v3_api_msg_admin.v3.EcdsConfigDump>`
  // * ``endpoints``:  :ref:`EndpointsConfigDump <envoy_v3_api_msg_admin.v3.EndpointsConfigDump>`
  // * ``listeners``: :ref:`ListenersConfigDump <envoy_v3_api_msg_admin.v3.ListenersConfigDump>`
  // * ``scoped_routes``: :ref:`ScopedRoutesConfigDump <envoy_v3_api_msg_admin.v3.ScopedRoutesConfigDump>`
  // * ``routes``:  :ref:`RoutesConfigDump <envoy_v3_api_msg_admin.v3.RoutesConfigDump>`
  // * ``secrets``:  :ref:`SecretsConfigDump <envoy_v3_api_msg_admin.v3.SecretsConfigDump>`
  //
  // EDS Configuration will only be dumped by using parameter ``?include_eds``
  //
  // Currently ECDS is supported in HTTP and listener filters. Note, ECDS configuration for
  // either HTTP or listener filter will only be dumped if it is actually configured.
  //
  // You can filter output with the resource and mask query parameters.
  // See :ref:`/config_dump?resource={} <operations_admin_interface_config_dump_by_resource>`,
  // :ref:`/config_dump?mask={} <operations_admin_interface_config_dump_by_mask>`,
  // or :ref:`/config_dump?resource={},mask={}
  // <operations_admin_interface_config_dump_by_resource_and_mask>` for more information.
  repeated google.protobuf.Any configs = 1;
}

// This message describes the bootstrap configuration that Envoy was started with. This includes
// any CLI overrides that were merged. Bootstrap configuration information can be used to recreate
// the static portions of an Envoy configuration by reusing the output as the bootstrap
// configuration for another Envoy.
message BootstrapConfigDump {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.admin.v2alpha.BootstrapConfigDump";

  config.bootstrap.v3.Bootstrap bootstrap = 1;

  // The timestamp when the BootstrapConfig was last updated.
  google.protobuf.Timestamp last_updated = 2;
}

// Envoys SDS implementation fills this message with all secrets fetched dynamically via SDS.
message SecretsConfigDump {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.admin.v2alpha.SecretsConfigDump";

  // DynamicSecret contains secret information fetched via SDS.
  // [#next-free-field: 7]
  message DynamicSecret {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret";

    // The name assigned to the secret.
    string name = 1;

    // This is the per-resource version information.
    string version_info = 2;

    // The timestamp when the secret was last updated.
    google.protobuf.Timestamp last_updated = 3;

    // The actual secret information.
    // Security sensitive information is redacted (replaced with "[redacted]") for
    // private keys and passwords in TLS certificates.
    google.protobuf.Any secret = 4;

    // Set if the last update failed, cleared after the next successful update.
    // The *error_state* field contains the rejected version of this particular
    // resource along with the reason and timestamp. For successfully updated or
    // acknowledged resource, this field should be empty.
    // [#not-implemented-hide:]
    UpdateFailureState error_state = 5;

    // The client status of this resource.
    // [#not-implemented-hide:]
    ClientResourceStatus client_status = 6;
  }

  // StaticSecret specifies statically loaded secret in bootstrap.
  message StaticSecret {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.admin.v2alpha.SecretsConfigDump.StaticSecret";

    // The name assigned to the secret.
    string name = 1;

    // The timestamp when the secret was last updated.
    google.protobuf.Timestamp last_updated = 2;

    // The actual secret information.
    // Security sensitive information is redacted (replaced with "[redacted]") for
    // private keys and passwords in TLS certificates.
    google.protobuf.Any secret = 3;
  }

  // The statically loaded secrets.
  repeated StaticSecret static_secrets = 1;

  // The dynamically loaded active secrets. These are secrets that are available to service
  // clusters or listeners.
  repeated DynamicSecret dynamic_active_secrets = 2;

  // The dynamically loaded warming secrets. These are secrets that are currently undergoing
  // warming in preparation to service clusters or listeners.
  repeated DynamicSecret dynamic_warming_secrets = 3;
}
syntax = "proto3";

package envoy.admin.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.admin.v3";
option java_outer_classname = "InitDumpProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v3;adminv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: InitDump]

// Dumps of unready targets of envoy init managers. Envoy's admin fills this message with init managers,
// which provides the information of their unready targets.
// The :ref:`/init_dump <operations_admin_interface_init_dump>` will dump all unready targets information.
message UnreadyTargetsDumps {
  // Message of unready targets information of an init manager.
  message UnreadyTargetsDump {
    // Name of the init manager. Example: "init_manager_xxx".
    string name = 1;

    // Names of unready targets of the init manager. Example: "target_xxx".
    repeated string target_names = 2;
  }

  // You can choose specific component to dump unready targets with mask query parameter.
  // See :ref:`/init_dump?mask={} <operations_admin_interface_init_dump_by_mask>` for more information.
  // The dumps of unready targets of all init managers.
  repeated UnreadyTargetsDump unready_targets_dumps = 1;
}
syntax = "proto3";

package envoy.admin.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.admin.v3";
option java_outer_classname = "MetricsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v3;adminv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Metrics]

// Proto representation of an Envoy Counter or Gauge value.
message SimpleMetric {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.SimpleMetric";

  enum Type {
    COUNTER = 0;
    GAUGE = 1;
  }

  // Type of the metric represented.
  Type type = 1;

  // Current metric value.
  uint64 value = 2;

  // Name of the metric.
  string name = 3;
}
syntax = "proto3";

package envoy.admin.v3;

import "envoy/config/core/v3/base.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.admin.v3";
option java_outer_classname = "ServerInfoProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v3;adminv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Server state]

// Proto representation of the value returned by /server_info, containing
// server version/server status information.
// [#next-free-field: 8]
message ServerInfo {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.ServerInfo";

  enum State {
    // Server is live and serving traffic.
    LIVE = 0;

    // Server is draining listeners in response to external health checks failing.
    DRAINING = 1;

    // Server has not yet completed cluster manager initialization.
    PRE_INITIALIZING = 2;

    // Server is running the cluster manager initialization callbacks (e.g., RDS).
    INITIALIZING = 3;
  }

  // Server version.
  string version = 1;

  // State of the server.
  State state = 2;

  // Uptime since current epoch was started.
  google.protobuf.Duration uptime_current_epoch = 3;

  // Uptime since the start of the first epoch.
  google.protobuf.Duration uptime_all_epochs = 4;

  // Hot restart version.
  string hot_restart_version = 5;

  // Command line options the server is currently running with.
  CommandLineOptions command_line_options = 6;

  // Populated node identity of this server.
  config.core.v3.Node node = 7;
}

// [#next-free-field: 39]
message CommandLineOptions {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.admin.v2alpha.CommandLineOptions";

  enum IpVersion {
    v4 = 0;
    v6 = 1;
  }

  enum Mode {
    // Validate configs and then serve traffic normally.
    Serve = 0;

    // Validate configs and exit.
    Validate = 1;

    // Completely load and initialize the config, and then exit without running the listener loop.
    InitOnly = 2;
  }

  enum DrainStrategy {
    // Gradually discourage connections over the course of the drain period.
    Gradual = 0;

    // Discourage all connections for the duration of the drain sequence.
    Immediate = 1;
  }

  reserved 12, 20, 21, 29;

  reserved "max_stats", "max_obj_name_len", "bootstrap_version";

  // See :option:`--base-id` for details.
  uint64 base_id = 1;

  // See :option:`--use-dynamic-base-id` for details.
  bool use_dynamic_base_id = 31;

  // See :option:`--base-id-path` for details.
  string base_id_path = 32;

  // See :option:`--concurrency` for details.
  uint32 concurrency = 2;

  // See :option:`--config-path` for details.
  string config_path = 3;

  // See :option:`--config-yaml` for details.
  string config_yaml = 4;

  // See :option:`--allow-unknown-static-fields` for details.
  bool allow_unknown_static_fields = 5;

  // See :option:`--reject-unknown-dynamic-fields` for details.
  bool reject_unknown_dynamic_fields = 26;

  // See :option:`--ignore-unknown-dynamic-fields` for details.
  bool ignore_unknown_dynamic_fields = 30;

  // See :option:`--admin-address-path` for details.
  string admin_address_path = 6;

  // See :option:`--local-address-ip-version` for details.
  IpVersion local_address_ip_version = 7;

  // See :option:`--log-level` for details.
  string log_level = 8;

  // See :option:`--component-log-level` for details.
  string component_log_level = 9;

  // See :option:`--log-format` for details.
  string log_format = 10;

  // See :option:`--log-format-escaped` for details.
  bool log_format_escaped = 27;

  // See :option:`--log-path` for details.
  string log_path = 11;

  // See :option:`--service-cluster` for details.
  string service_cluster = 13;

  // See :option:`--service-node` for details.
  string service_node = 14;

  // See :option:`--service-zone` for details.
  string service_zone = 15;

  // See :option:`--file-flush-interval-msec` for details.
  google.protobuf.Duration file_flush_interval = 16;

  // See :option:`--drain-time-s` for details.
  google.protobuf.Duration drain_time = 17;

  // See :option:`--drain-strategy` for details.
  DrainStrategy drain_strategy = 33;

  // See :option:`--parent-shutdown-time-s` for details.
  google.protobuf.Duration parent_shutdown_time = 18;

  // See :option:`--mode` for details.
  Mode mode = 19;

  // See :option:`--disable-hot-restart` for details.
  bool disable_hot_restart = 22;

  // See :option:`--enable-mutex-tracing` for details.
  bool enable_mutex_tracing = 23;

  // See :option:`--restart-epoch` for details.
  uint32 restart_epoch = 24;

  // See :option:`--cpuset-threads` for details.
  bool cpuset_threads = 25;

  // See :option:`--disable-extensions` for details.
  repeated string disabled_extensions = 28;

  // See :option:`--enable-fine-grain-logging` for details.
  bool enable_fine_grain_logging = 34;

  // See :option:`--socket-path` for details.
  string socket_path = 35;

  // See :option:`--socket-mode` for details.
  uint32 socket_mode = 36;

  // See :option:`--enable-core-dump` for details.
  bool enable_core_dump = 37;

  // See :option:`--stats-tag` for details.
  repeated string stats_tag = 38;
}
syntax = "proto3";

package envoy.admin.v3;

import "envoy/config/tap/v3/common.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.admin.v3";
option java_outer_classname = "TapProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v3;adminv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Tap]

// The /tap admin request body that is used to configure an active tap session.
message TapRequest {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.TapRequest";

  // The opaque configuration ID used to match the configuration to a loaded extension.
  // A tap extension configures a similar opaque ID that is used to match.
  string config_id = 1 [(validate.rules).string = {min_len: 1}];

  // The tap configuration to load.
  config.tap.v3.TapConfig tap_config = 2 [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/bootstrap/v3:pkg",
        "//envoy/config/cluster/v3:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/config/tap/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.admin.v3;

import "envoy/config/core/v3/address.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.admin.v3";
option java_outer_classname = "ListenersProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v3;adminv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Listeners]

// Admin endpoint uses this wrapper for ``/listeners`` to display listener status information.
// See :ref:`/listeners <operations_admin_interface_listeners>` for more information.
message Listeners {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.Listeners";

  // List of listener statuses.
  repeated ListenerStatus listener_statuses = 1;
}

// Details an individual listener's current status.
message ListenerStatus {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.ListenerStatus";

  // Name of the listener
  string name = 1;

  // The actual local address that the listener is listening on. If a listener was configured
  // to listen on port 0, then this address has the port that was allocated by the OS.
  config.core.v3.Address local_address = 2;

  // The additional addresses the listener is listening on as specified via the :ref:`additional_addresses <envoy_v3_api_field_config.listener.v3.Listener.additional_addresses>`
  // configuration.
  repeated config.core.v3.Address additional_local_addresses = 3;
}
syntax = "proto3";

package envoy.admin.v3;

import "google/protobuf/timestamp.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.admin.v3";
option java_outer_classname = "CertsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v3;adminv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Certificates]

// Proto representation of certificate details. Admin endpoint uses this wrapper for ``/certs`` to
// display certificate information. See :ref:`/certs <operations_admin_interface_certs>` for more
// information.
message Certificates {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.Certificates";

  // List of certificates known to an Envoy.
  repeated Certificate certificates = 1;
}

message Certificate {
  option (udpa.annotations.versioning).previous_message_type = "envoy.admin.v2alpha.Certificate";

  // Details of CA certificate.
  repeated CertificateDetails ca_cert = 1;

  // Details of Certificate Chain
  repeated CertificateDetails cert_chain = 2;
}

// [#next-free-field: 8]
message CertificateDetails {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.admin.v2alpha.CertificateDetails";

  message OcspDetails {
    // Indicates the time from which the OCSP response is valid.
    google.protobuf.Timestamp valid_from = 1;

    // Indicates the time at which the OCSP response expires.
    google.protobuf.Timestamp expiration = 2;
  }

  // Path of the certificate.
  string path = 1;

  // Certificate Serial Number.
  string serial_number = 2;

  // List of Subject Alternate names.
  repeated SubjectAlternateName subject_alt_names = 3;

  // Minimum of days until expiration of certificate and it's chain.
  uint64 days_until_expiration = 4;

  // Indicates the time from which the certificate is valid.
  google.protobuf.Timestamp valid_from = 5;

  // Indicates the time at which the certificate expires.
  google.protobuf.Timestamp expiration_time = 6;

  // Details related to the OCSP response associated with this certificate, if any.
  OcspDetails ocsp_details = 7;
}

message SubjectAlternateName {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.admin.v2alpha.SubjectAlternateName";

  // Subject Alternate Name.
  oneof name {
    string dns = 1;

    string uri = 2;

    string ip_address = 3;
  }
}
syntax = "proto3";

package envoy.admin.v2alpha;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.admin.v2alpha";
option java_outer_classname = "MutexStatsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v2alpha";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: MutexStats]

// Proto representation of the statistics collected upon absl::Mutex contention, if Envoy is run
// under :option:`--enable-mutex-tracing`. For more information, see the `absl::Mutex`
// [docs](https://abseil.io/about/design/mutex#extra-features).
//
// *NB*: The wait cycles below are measured by `absl::base_internal::CycleClock`, and may not
// correspond to core clock frequency. For more information, see the `CycleClock`
// [docs](https://github.com/abseil/abseil-cpp/blob/master/absl/base/internal/cycleclock.h).
message MutexStats {
  // The number of individual mutex contentions which have occurred since startup.
  uint64 num_contentions = 1;

  // The length of the current contention wait cycle.
  uint64 current_wait_cycles = 2;

  // The lifetime total of all contention wait cycles.
  uint64 lifetime_wait_cycles = 3;
}
syntax = "proto3";

package envoy.admin.v2alpha;

import "envoy/admin/v2alpha/metrics.proto";
import "envoy/api/v2/core/address.proto";
import "envoy/api/v2/core/base.proto";
import "envoy/api/v2/core/health_check.proto";
import "envoy/type/percent.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.admin.v2alpha";
option java_outer_classname = "ClustersProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v2alpha";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Clusters]

// Admin endpoint uses this wrapper for `/clusters` to display cluster status information.
// See :ref:`/clusters <operations_admin_interface_clusters>` for more information.
message Clusters {
  // Mapping from cluster name to each cluster's status.
  repeated ClusterStatus cluster_statuses = 1;
}

// Details an individual cluster's current status.
// [#next-free-field: 6]
message ClusterStatus {
  // Name of the cluster.
  string name = 1;

  // Denotes whether this cluster was added via API or configured statically.
  bool added_via_api = 2;

  // The success rate threshold used in the last interval.
  // If
  // :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
  // is *false*, all errors: externally and locally generated were used to calculate the threshold.
  // If
  // :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
  // is *true*, only externally generated errors were used to calculate the threshold.
  // The threshold is used to eject hosts based on their success rate. See
  // :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for details.
  //
  // Note: this field may be omitted in any of the three following cases:
  //
  // 1. There were not enough hosts with enough request volume to proceed with success rate based
  //    outlier ejection.
  // 2. The threshold is computed to be < 0 because a negative value implies that there was no
  //    threshold for that interval.
  // 3. Outlier detection is not enabled for this cluster.
  type.Percent success_rate_ejection_threshold = 3;

  // Mapping from host address to the host's current status.
  repeated HostStatus host_statuses = 4;

  // The success rate threshold used in the last interval when only locally originated failures were
  // taken into account and externally originated errors were treated as success.
  // This field should be interpreted only when
  // :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
  // is *true*. The threshold is used to eject hosts based on their success rate.
  // See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
  // details.
  //
  // Note: this field may be omitted in any of the three following cases:
  //
  // 1. There were not enough hosts with enough request volume to proceed with success rate based
  //    outlier ejection.
  // 2. The threshold is computed to be < 0 because a negative value implies that there was no
  //    threshold for that interval.
  // 3. Outlier detection is not enabled for this cluster.
  type.Percent local_origin_success_rate_ejection_threshold = 5;
}

// Current state of a particular host.
// [#next-free-field: 10]
message HostStatus {
  // Address of this host.
  api.v2.core.Address address = 1;

  // List of stats specific to this host.
  repeated SimpleMetric stats = 2;

  // The host's current health status.
  HostHealthStatus health_status = 3;

  // Request success rate for this host over the last calculated interval.
  // If
  // :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
  // is *false*, all errors: externally and locally generated were used in success rate
  // calculation. If
  // :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
  // is *true*, only externally generated errors were used in success rate calculation.
  // See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
  // details.
  //
  // Note: the message will not be present if host did not have enough request volume to calculate
  // success rate or the cluster did not have enough hosts to run through success rate outlier
  // ejection.
  type.Percent success_rate = 4;

  // The host's weight. If not configured, the value defaults to 1.
  uint32 weight = 5;

  // The hostname of the host, if applicable.
  string hostname = 6;

  // The host's priority. If not configured, the value defaults to 0 (highest priority).
  uint32 priority = 7;

  // Request success rate for this host over the last calculated
  // interval when only locally originated errors are taken into account and externally originated
  // errors were treated as success.
  // This field should be interpreted only when
  // :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
  // is *true*.
  // See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
  // details.
  //
  // Note: the message will not be present if host did not have enough request volume to calculate
  // success rate or the cluster did not have enough hosts to run through success rate outlier
  // ejection.
  type.Percent local_origin_success_rate = 8;

  // locality of the host.
  api.v2.core.Locality locality = 9;
}

// Health status for a host.
// [#next-free-field: 7]
message HostHealthStatus {
  // The host is currently failing active health checks.
  bool failed_active_health_check = 1;

  // The host is currently considered an outlier and has been ejected.
  bool failed_outlier_check = 2;

  // The host is currently being marked as degraded through active health checking.
  bool failed_active_degraded_check = 4;

  // The host has been removed from service discovery, but is being stabilized due to active
  // health checking.
  bool pending_dynamic_removal = 5;

  // The host has not yet been health checked.
  bool pending_active_hc = 6;

  // Health status as reported by EDS. Note: only HEALTHY and UNHEALTHY are currently supported
  // here.
  // [#comment:TODO(mrice32): pipe through remaining EDS health status possibilities.]
  api.v2.core.HealthStatus eds_health_status = 3;
}
syntax = "proto3";

package envoy.admin.v2alpha;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.admin.v2alpha";
option java_outer_classname = "MemoryProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v2alpha";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Memory]

// Proto representation of the internal memory consumption of an Envoy instance. These represent
// values extracted from an internal TCMalloc instance. For more information, see the section of the
// docs entitled ["Generic Tcmalloc Status"](https://gperftools.github.io/gperftools/tcmalloc.html).
// [#next-free-field: 7]
message Memory {
  // The number of bytes allocated by the heap for Envoy. This is an alias for
  // `generic.current_allocated_bytes`.
  uint64 allocated = 1;

  // The number of bytes reserved by the heap but not necessarily allocated. This is an alias for
  // `generic.heap_size`.
  uint64 heap_size = 2;

  // The number of bytes in free, unmapped pages in the page heap. These bytes always count towards
  // virtual memory usage, and depending on the OS, typically do not count towards physical memory
  // usage. This is an alias for `tcmalloc.pageheap_unmapped_bytes`.
  uint64 pageheap_unmapped = 3;

  // The number of bytes in free, mapped pages in the page heap. These bytes always count towards
  // virtual memory usage, and unless the underlying memory is swapped out by the OS, they also
  // count towards physical memory usage. This is an alias for `tcmalloc.pageheap_free_bytes`.
  uint64 pageheap_free = 4;

  // The amount of memory used by the TCMalloc thread caches (for small objects). This is an alias
  // for `tcmalloc.current_total_thread_cache_bytes`.
  uint64 total_thread_cache = 5;

  // The number of bytes of the physical memory usage by the allocator. This is an alias for
  // `generic.total_physical_bytes`.
  uint64 total_physical_bytes = 6;
}
syntax = "proto3";

package envoy.admin.v2alpha;

import "envoy/config/bootstrap/v2/bootstrap.proto";

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.admin.v2alpha";
option java_outer_classname = "ConfigDumpProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v2alpha";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: ConfigDump]

// The :ref:`/config_dump <operations_admin_interface_config_dump>` admin endpoint uses this wrapper
// message to maintain and serve arbitrary configuration information from any component in Envoy.
message ConfigDump {
  // This list is serialized and dumped in its entirety at the
  // :ref:`/config_dump <operations_admin_interface_config_dump>` endpoint.
  //
  // The following configurations are currently supported and will be dumped in the order given
  // below:
  //
  // * *bootstrap*: :ref:`BootstrapConfigDump <envoy_api_msg_admin.v2alpha.BootstrapConfigDump>`
  // * *clusters*: :ref:`ClustersConfigDump <envoy_api_msg_admin.v2alpha.ClustersConfigDump>`
  // * *listeners*: :ref:`ListenersConfigDump <envoy_api_msg_admin.v2alpha.ListenersConfigDump>`
  // * *routes*:  :ref:`RoutesConfigDump <envoy_api_msg_admin.v2alpha.RoutesConfigDump>`
  //
  // You can filter output with the resource and mask query parameters.
  // See :ref:`/config_dump?resource={} <operations_admin_interface_config_dump_by_resource>`,
  // :ref:`/config_dump?mask={} <operations_admin_interface_config_dump_by_mask>`,
  // or :ref:`/config_dump?resource={},mask={}
  // <operations_admin_interface_config_dump_by_resource_and_mask>` for more information.
  repeated google.protobuf.Any configs = 1;
}

message UpdateFailureState {
  // What the component configuration would have been if the update had succeeded.
  google.protobuf.Any failed_configuration = 1;

  // Time of the latest failed update attempt.
  google.protobuf.Timestamp last_update_attempt = 2;

  // Details about the last failed update attempt.
  string details = 3;
}

// This message describes the bootstrap configuration that Envoy was started with. This includes
// any CLI overrides that were merged. Bootstrap configuration information can be used to recreate
// the static portions of an Envoy configuration by reusing the output as the bootstrap
// configuration for another Envoy.
message BootstrapConfigDump {
  config.bootstrap.v2.Bootstrap bootstrap = 1;

  // The timestamp when the BootstrapConfig was last updated.
  google.protobuf.Timestamp last_updated = 2;
}

// Envoy's listener manager fills this message with all currently known listeners. Listener
// configuration information can be used to recreate an Envoy configuration by populating all
// listeners as static listeners or by returning them in a LDS response.
message ListenersConfigDump {
  // Describes a statically loaded listener.
  message StaticListener {
    // The listener config.
    google.protobuf.Any listener = 1;

    // The timestamp when the Listener was last successfully updated.
    google.protobuf.Timestamp last_updated = 2;
  }

  message DynamicListenerState {
    // This is the per-resource version information. This version is currently taken from the
    // :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time
    // that the listener was loaded. In the future, discrete per-listener versions may be supported
    // by the API.
    string version_info = 1;

    // The listener config.
    google.protobuf.Any listener = 2;

    // The timestamp when the Listener was last successfully updated.
    google.protobuf.Timestamp last_updated = 3;
  }

  // Describes a dynamically loaded listener via the LDS API.
  // [#next-free-field: 6]
  message DynamicListener {
    // The name or unique id of this listener, pulled from the DynamicListenerState config.
    string name = 1;

    // The listener state for any active listener by this name.
    // These are listeners that are available to service data plane traffic.
    DynamicListenerState active_state = 2;

    // The listener state for any warming listener by this name.
    // These are listeners that are currently undergoing warming in preparation to service data
    // plane traffic. Note that if attempting to recreate an Envoy configuration from a
    // configuration dump, the warming listeners should generally be discarded.
    DynamicListenerState warming_state = 3;

    // The listener state for any draining listener by this name.
    // These are listeners that are currently undergoing draining in preparation to stop servicing
    // data plane traffic. Note that if attempting to recreate an Envoy configuration from a
    // configuration dump, the draining listeners should generally be discarded.
    DynamicListenerState draining_state = 4;

    // Set if the last update failed, cleared after the next successful update.
    UpdateFailureState error_state = 5;
  }

  // This is the :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` in the
  // last processed LDS discovery response. If there are only static bootstrap listeners, this field
  // will be "".
  string version_info = 1;

  // The statically loaded listener configs.
  repeated StaticListener static_listeners = 2;

  // State for any warming, active, or draining listeners.
  repeated DynamicListener dynamic_listeners = 3;
}

// Envoy's cluster manager fills this message with all currently known clusters. Cluster
// configuration information can be used to recreate an Envoy configuration by populating all
// clusters as static clusters or by returning them in a CDS response.
message ClustersConfigDump {
  // Describes a statically loaded cluster.
  message StaticCluster {
    // The cluster config.
    google.protobuf.Any cluster = 1;

    // The timestamp when the Cluster was last updated.
    google.protobuf.Timestamp last_updated = 2;
  }

  // Describes a dynamically loaded cluster via the CDS API.
  message DynamicCluster {
    // This is the per-resource version information. This version is currently taken from the
    // :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time
    // that the cluster was loaded. In the future, discrete per-cluster versions may be supported by
    // the API.
    string version_info = 1;

    // The cluster config.
    google.protobuf.Any cluster = 2;

    // The timestamp when the Cluster was last updated.
    google.protobuf.Timestamp last_updated = 3;
  }

  // This is the :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` in the
  // last processed CDS discovery response. If there are only static bootstrap clusters, this field
  // will be "".
  string version_info = 1;

  // The statically loaded cluster configs.
  repeated StaticCluster static_clusters = 2;

  // The dynamically loaded active clusters. These are clusters that are available to service
  // data plane traffic.
  repeated DynamicCluster dynamic_active_clusters = 3;

  // The dynamically loaded warming clusters. These are clusters that are currently undergoing
  // warming in preparation to service data plane traffic. Note that if attempting to recreate an
  // Envoy configuration from a configuration dump, the warming clusters should generally be
  // discarded.
  repeated DynamicCluster dynamic_warming_clusters = 4;
}

// Envoy's RDS implementation fills this message with all currently loaded routes, as described by
// their RouteConfiguration objects. Static routes that are either defined in the bootstrap configuration
// or defined inline while configuring listeners are separated from those configured dynamically via RDS.
// Route configuration information can be used to recreate an Envoy configuration by populating all routes
// as static routes or by returning them in RDS responses.
message RoutesConfigDump {
  message StaticRouteConfig {
    // The route config.
    google.protobuf.Any route_config = 1;

    // The timestamp when the Route was last updated.
    google.protobuf.Timestamp last_updated = 2;
  }

  message DynamicRouteConfig {
    // This is the per-resource version information. This version is currently taken from the
    // :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time that
    // the route configuration was loaded.
    string version_info = 1;

    // The route config.
    google.protobuf.Any route_config = 2;

    // The timestamp when the Route was last updated.
    google.protobuf.Timestamp last_updated = 3;
  }

  // The statically loaded route configs.
  repeated StaticRouteConfig static_route_configs = 2;

  // The dynamically loaded route configs.
  repeated DynamicRouteConfig dynamic_route_configs = 3;
}

// Envoy's scoped RDS implementation fills this message with all currently loaded route
// configuration scopes (defined via ScopedRouteConfigurationsSet protos). This message lists both
// the scopes defined inline with the higher order object (i.e., the HttpConnectionManager) and the
// dynamically obtained scopes via the SRDS API.
message ScopedRoutesConfigDump {
  message InlineScopedRouteConfigs {
    // The name assigned to the scoped route configurations.
    string name = 1;

    // The scoped route configurations.
    repeated google.protobuf.Any scoped_route_configs = 2;

    // The timestamp when the scoped route config set was last updated.
    google.protobuf.Timestamp last_updated = 3;
  }

  message DynamicScopedRouteConfigs {
    // The name assigned to the scoped route configurations.
    string name = 1;

    // This is the per-resource version information. This version is currently taken from the
    // :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time that
    // the scoped routes configuration was loaded.
    string version_info = 2;

    // The scoped route configurations.
    repeated google.protobuf.Any scoped_route_configs = 3;

    // The timestamp when the scoped route config set was last updated.
    google.protobuf.Timestamp last_updated = 4;
  }

  // The statically loaded scoped route configs.
  repeated InlineScopedRouteConfigs inline_scoped_route_configs = 1;

  // The dynamically loaded scoped route configs.
  repeated DynamicScopedRouteConfigs dynamic_scoped_route_configs = 2;
}

// Envoys SDS implementation fills this message with all secrets fetched dynamically via SDS.
message SecretsConfigDump {
  // DynamicSecret contains secret information fetched via SDS.
  message DynamicSecret {
    // The name assigned to the secret.
    string name = 1;

    // This is the per-resource version information.
    string version_info = 2;

    // The timestamp when the secret was last updated.
    google.protobuf.Timestamp last_updated = 3;

    // The actual secret information.
    // Security sensitive information is redacted (replaced with "[redacted]") for
    // private keys and passwords in TLS certificates.
    google.protobuf.Any secret = 4;
  }

  // StaticSecret specifies statically loaded secret in bootstrap.
  message StaticSecret {
    // The name assigned to the secret.
    string name = 1;

    // The timestamp when the secret was last updated.
    google.protobuf.Timestamp last_updated = 2;

    // The actual secret information.
    // Security sensitive information is redacted (replaced with "[redacted]") for
    // private keys and passwords in TLS certificates.
    google.protobuf.Any secret = 3;
  }

  // The statically loaded secrets.
  repeated StaticSecret static_secrets = 1;

  // The dynamically loaded active secrets. These are secrets that are available to service
  // clusters or listeners.
  repeated DynamicSecret dynamic_active_secrets = 2;

  // The dynamically loaded warming secrets. These are secrets that are currently undergoing
  // warming in preparation to service clusters or listeners.
  repeated DynamicSecret dynamic_warming_secrets = 3;
}
syntax = "proto3";

package envoy.admin.v2alpha;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.admin.v2alpha";
option java_outer_classname = "MetricsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v2alpha";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Metrics]

// Proto representation of an Envoy Counter or Gauge value.
message SimpleMetric {
  enum Type {
    COUNTER = 0;
    GAUGE = 1;
  }

  // Type of the metric represented.
  Type type = 1;

  // Current metric value.
  uint64 value = 2;

  // Name of the metric.
  string name = 3;
}
syntax = "proto3";

package envoy.admin.v2alpha;

import "google/protobuf/duration.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.admin.v2alpha";
option java_outer_classname = "ServerInfoProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v2alpha";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Server State]

// Proto representation of the value returned by /server_info, containing
// server version/server status information.
// [#next-free-field: 7]
message ServerInfo {
  enum State {
    // Server is live and serving traffic.
    LIVE = 0;

    // Server is draining listeners in response to external health checks failing.
    DRAINING = 1;

    // Server has not yet completed cluster manager initialization.
    PRE_INITIALIZING = 2;

    // Server is running the cluster manager initialization callbacks (e.g., RDS).
    INITIALIZING = 3;
  }

  // Server version.
  string version = 1;

  // State of the server.
  State state = 2;

  // Uptime since current epoch was started.
  google.protobuf.Duration uptime_current_epoch = 3;

  // Uptime since the start of the first epoch.
  google.protobuf.Duration uptime_all_epochs = 4;

  // Hot restart version.
  string hot_restart_version = 5;

  // Command line options the server is currently running with.
  CommandLineOptions command_line_options = 6;
}

// [#next-free-field: 29]
message CommandLineOptions {
  enum IpVersion {
    v4 = 0;
    v6 = 1;
  }

  enum Mode {
    // Validate configs and then serve traffic normally.
    Serve = 0;

    // Validate configs and exit.
    Validate = 1;

    // Completely load and initialize the config, and then exit without running the listener loop.
    InitOnly = 2;
  }

  reserved 12;

  // See :option:`--base-id` for details.
  uint64 base_id = 1;

  // See :option:`--concurrency` for details.
  uint32 concurrency = 2;

  // See :option:`--config-path` for details.
  string config_path = 3;

  // See :option:`--config-yaml` for details.
  string config_yaml = 4;

  // See :option:`--allow-unknown-static-fields` for details.
  bool allow_unknown_static_fields = 5;

  // See :option:`--reject-unknown-dynamic-fields` for details.
  bool reject_unknown_dynamic_fields = 26;

  // See :option:`--admin-address-path` for details.
  string admin_address_path = 6;

  // See :option:`--local-address-ip-version` for details.
  IpVersion local_address_ip_version = 7;

  // See :option:`--log-level` for details.
  string log_level = 8;

  // See :option:`--component-log-level` for details.
  string component_log_level = 9;

  // See :option:`--log-format` for details.
  string log_format = 10;

  // See :option:`--log-format-escaped` for details.
  bool log_format_escaped = 27;

  // See :option:`--log-path` for details.
  string log_path = 11;

  // See :option:`--service-cluster` for details.
  string service_cluster = 13;

  // See :option:`--service-node` for details.
  string service_node = 14;

  // See :option:`--service-zone` for details.
  string service_zone = 15;

  // See :option:`--file-flush-interval-msec` for details.
  google.protobuf.Duration file_flush_interval = 16;

  // See :option:`--drain-time-s` for details.
  google.protobuf.Duration drain_time = 17;

  // See :option:`--parent-shutdown-time-s` for details.
  google.protobuf.Duration parent_shutdown_time = 18;

  // See :option:`--mode` for details.
  Mode mode = 19;

  // max_stats and max_obj_name_len are now unused and have no effect.
  uint64 max_stats = 20 [deprecated = true, (envoy.annotations.disallowed_by_default) = true];

  uint64 max_obj_name_len = 21
      [deprecated = true, (envoy.annotations.disallowed_by_default) = true];

  // See :option:`--disable-hot-restart` for details.
  bool disable_hot_restart = 22;

  // See :option:`--enable-mutex-tracing` for details.
  bool enable_mutex_tracing = 23;

  // See :option:`--restart-epoch` for details.
  uint32 restart_epoch = 24;

  // See :option:`--cpuset-threads` for details.
  bool cpuset_threads = 25;

  // See :option:`--disable-extensions` for details.
  repeated string disabled_extensions = 28;
}
syntax = "proto3";

package envoy.admin.v2alpha;

import "envoy/service/tap/v2alpha/common.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.admin.v2alpha";
option java_outer_classname = "TapProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v2alpha";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Tap]

// The /tap admin request body that is used to configure an active tap session.
message TapRequest {
  // The opaque configuration ID used to match the configuration to a loaded extension.
  // A tap extension configures a similar opaque ID that is used to match.
  string config_id = 1 [(validate.rules).string = {min_bytes: 1}];

  // The tap configuration to load.
  service.tap.v2alpha.TapConfig tap_config = 2 [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/api/v2/core:pkg",
        "//envoy/config/bootstrap/v2:pkg",
        "//envoy/service/tap/v2alpha:pkg",
        "//envoy/type:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.admin.v2alpha;

import "envoy/api/v2/core/address.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.admin.v2alpha";
option java_outer_classname = "ListenersProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v2alpha";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Listeners]

// Admin endpoint uses this wrapper for `/listeners` to display listener status information.
// See :ref:`/listeners <operations_admin_interface_listeners>` for more information.
message Listeners {
  // List of listener statuses.
  repeated ListenerStatus listener_statuses = 1;
}

// Details an individual listener's current status.
message ListenerStatus {
  // Name of the listener
  string name = 1;

  // The actual local address that the listener is listening on. If a listener was configured
  // to listen on port 0, then this address has the port that was allocated by the OS.
  api.v2.core.Address local_address = 2;
}
syntax = "proto3";

package envoy.admin.v2alpha;

import "google/protobuf/timestamp.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.admin.v2alpha";
option java_outer_classname = "CertsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/admin/v2alpha";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Certificates]

// Proto representation of certificate details. Admin endpoint uses this wrapper for `/certs` to
// display certificate information. See :ref:`/certs <operations_admin_interface_certs>` for more
// information.
message Certificates {
  // List of certificates known to an Envoy.
  repeated Certificate certificates = 1;
}

message Certificate {
  // Details of CA certificate.
  repeated CertificateDetails ca_cert = 1;

  // Details of Certificate Chain
  repeated CertificateDetails cert_chain = 2;
}

// [#next-free-field: 7]
message CertificateDetails {
  // Path of the certificate.
  string path = 1;

  // Certificate Serial Number.
  string serial_number = 2;

  // List of Subject Alternate names.
  repeated SubjectAlternateName subject_alt_names = 3;

  // Minimum of days until expiration of certificate and it's chain.
  uint64 days_until_expiration = 4;

  // Indicates the time from which the certificate is valid.
  google.protobuf.Timestamp valid_from = 5;

  // Indicates the time at which the certificate expires.
  google.protobuf.Timestamp expiration_time = 6;
}

message SubjectAlternateName {
  // Subject Alternate Name.
  oneof name {
    string dns = 1;

    string uri = 2;

    string ip_address = 3;
  }
}
syntax = "proto3";

package envoy.extensions.matching.common_inputs.environment_variable.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.matching.common_inputs.environment_variable.v3";
option java_outer_classname = "InputProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/matching/common_inputs/environment_variable/v3;environment_variablev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Environment variable input]
// [#extension: envoy.matching.common_inputs.environment_variable]

// Reads an environment variable to provide an input for matching.
message Config {
  // Name of the environment variable to read from.
  string name = 1 [(validate.rules).string = {min_len: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.matching.common_inputs.ssl.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.matching.common_inputs.ssl.v3";
option java_outer_classname = "SslInputsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/matching/common_inputs/ssl/v3;sslv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common SSL matching inputs]

// List of comma-delimited URIs in the SAN field of the peer certificate for a downstream.
// [#extension: envoy.matching.inputs.uri_san]
message UriSanInput {
}

// List of comma-delimited DNS entries in the SAN field of the peer certificate for a downstream.
// [#extension: envoy.matching.inputs.dns_san]
message DnsSanInput {
}

// Input that matches the subject field of the peer certificate in RFC 2253 format for a
// downstream.
// [#extension: envoy.matching.inputs.subject]
message SubjectInput {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.matching.common_inputs.network.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.matching.common_inputs.network.v3";
option java_outer_classname = "NetworkInputsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/matching/common_inputs/network/v3;networkv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common network matching inputs]

// Specifies that matching should be performed by the destination IP address.
// [#extension: envoy.matching.inputs.destination_ip]
message DestinationIPInput {
}

// Specifies that matching should be performed by the destination port.
// [#extension: envoy.matching.inputs.destination_port]
message DestinationPortInput {
}

// Specifies that matching should be performed by the source IP address.
// [#extension: envoy.matching.inputs.source_ip]
message SourceIPInput {
}

// Specifies that matching should be performed by the source port.
// [#extension: envoy.matching.inputs.source_port]
message SourcePortInput {
}

// Input that matches by the directly connected source IP address (this
// will only be different from the source IP address when using a listener
// filter that overrides the source address, such as the :ref:`Proxy Protocol
// listener filter <config_listener_filters_proxy_protocol>`).
// [#extension: envoy.matching.inputs.direct_source_ip]
message DirectSourceIPInput {
}

// Input that matches by the source IP type.
// Specifies the source IP match type. The values include:
//
// * ``local`` - matches a connection originating from the same host,
// [#extension: envoy.matching.inputs.source_type]
message SourceTypeInput {
}

// Input that matches by the requested server name (e.g. SNI in TLS).
//
// :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides the requested server name based on SNI,
// when TLS protocol is detected.
// [#extension: envoy.matching.inputs.server_name]
message ServerNameInput {
}

// Input that matches by the transport protocol.
//
// Suggested values include:
//
// * ``raw_buffer`` - default, used when no transport protocol is detected,
// * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
//   when TLS protocol is detected.
// [#extension: envoy.matching.inputs.transport_protocol]
message TransportProtocolInput {
}

// List of quoted and comma-separated requested application protocols. The list consists of a
// single negotiated application protocol once the network stream is established.
//
// Examples:
//
// * ``'h2','http/1.1'``
// * ``'h2c'``
//
// Suggested values in the list include:
//
// * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
//   <config_listener_filters_tls_inspector>` and :ref:`envoy.filters.listener.http_inspector
//   <config_listener_filters_http_inspector>`,
// * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
// * ``h2c`` - set by :ref:`envoy.filters.listener.http_inspector <config_listener_filters_http_inspector>`
//
// .. attention::
//
//   Currently, :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides
//   application protocol detection based on the requested
//   `ALPN <https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_ values.
//
//   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
//   and matching on values other than ``h2`` is going to lead to a lot of false negatives,
//   unless all connecting clients are known to use ALPN.
// [#extension: envoy.matching.inputs.application_protocol]
message ApplicationProtocolInput {
}

// Input that matches by a specific filter state key.
// The value of the provided filter state key will be the raw string representation of the filter state object
// [#extension: envoy.matching.inputs.filter_state]
message FilterStateInput {
  string key = 1 [(validate.rules).string = {min_len: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.matching.input_matchers.consistent_hashing.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.matching.input_matchers.consistent_hashing.v3";
option java_outer_classname = "ConsistentHashingProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/matching/input_matchers/consistent_hashing/v3;consistent_hashingv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Consistent hashing matcher]
// [#extension: envoy.matching.matchers.consistent_hashing]

// The consistent hashing matchers computes a consistent hash from the input and matches if the resulting hash
// is within the configured threshold.
// More specifically, this matcher evaluates to true if hash(input, seed) % modulo >= threshold.
// Note that the consistency of the match result relies on the internal hash function (xxhash) remaining
// unchanged. While this is unlikely to happen intentionally, this could cause inconsistent match results
// between deployments.
message ConsistentHashing {
  // The threshold the resulting hash must be over in order for this matcher to evaluate to true.
  // This value must be below the configured modulo value.
  // Setting this to 0 is equivalent to this matcher always matching.
  uint32 threshold = 1;

  // The value to use for the modulus in the calculation. This effectively  bounds the hash output,
  // specifying the range of possible values.
  // This value must be above the configured threshold.
  uint32 modulo = 2 [(validate.rules).uint32 = {gt: 0}];

  // Optional seed passed through the hash function. This allows using additional information when computing
  // the hash value: by changing the seed value, a different partition of matching and non-matching inputs will
  // be created that remains consistent for that seed value.
  uint64 seed = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.matching.input_matchers.runtime_fraction.v3;

import "envoy/config/core/v3/base.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.matching.input_matchers.runtime_fraction.v3";
option java_outer_classname = "RuntimeFractionProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/matching/input_matchers/runtime_fraction/v3;runtime_fractionv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Runtime matcher]
// [#extension: envoy.matching.matchers.runtime_fraction]

// The runtime fraction matchers computes a hash from the input and matches if runtime feature is enabled
// for the the resulting hash. Every time the input is considered for a match, its hash must fall within
// the percentage of matches indicated by this field. For a fraction N/D, a number is computed as a hash
// of the input on a field in the range [0,D). If the number is less than or equal to the value of the
// numerator N, the matcher evaluates to true. A runtime_fraction input matcher can be used to gradually
// roll out matcher changes without requiring full code or configuration deployments.
// Note that distribution of matching results is only as good as one of the input.
message RuntimeFraction {
  // Match the input against the given runtime key. The specified default value is used if key is not
  // present in the runtime configuration.
  config.core.v3.RuntimeFractionalPercent runtime_fraction = 1
      [(validate.rules).message = {required: true}];

  // Optional seed passed through the hash function. This allows using additional information when computing
  // the hash value: by changing the seed value, a potentially different outcome can be achieved for the same input.
  uint64 seed = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.matching.input_matchers.ip.v3;

import "envoy/config/core/v3/address.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.matching.input_matchers.ip.v3";
option java_outer_classname = "IpProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/matching/input_matchers/ip/v3;ipv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: IP matcher]
// [#extension: envoy.matching.matchers.ip]

// This input matcher matches IPv4 or IPv6 addresses against a list of CIDR
// ranges. It returns true if and only if the input IP belongs to at least one
// of these CIDR ranges. Internally, it uses a Level-Compressed trie, as
// described in the paper `IP-address lookup using LC-tries
// <https://www.nada.kth.se/~snilsson/publications/IP-address-lookup-using-LC-tries/>`_
// by S. Nilsson and G. Karlsson. For "big" lists of IPs, this matcher is more
// efficient than multiple single IP matcher, that would have a linear cost.
message Ip {
  // Match if the IP belongs to any of these CIDR ranges.
  repeated config.core.v3.CidrRange cidr_ranges = 1 [(validate.rules).repeated = {min_items: 1}];

  // The human readable prefix to use when emitting statistics for the IP input
  // matcher. Names in the table below are concatenated to this prefix.
  //
  // .. csv-table::
  //    :header: Name, Type, Description
  //    :widths: 1, 1, 2
  //
  //    ip_parsing_failed, Counter, Total number of IP addresses the matcher was unable to parse
  string stat_prefix = 2 [(validate.rules).string = {min_len: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.listener.tls_inspector.v3;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.listener.tls_inspector.v3";
option java_outer_classname = "TlsInspectorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/listener/tls_inspector/v3;tls_inspectorv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: TLS Inspector Filter]
// Allows detecting whether the transport appears to be TLS or plaintext.
// [#extension: envoy.filters.listener.tls_inspector]

message TlsInspector {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.listener.tls_inspector.v2.TlsInspector";

  // Populate ``JA3`` fingerprint hash using data from the TLS Client Hello packet. Default is false.
  google.protobuf.BoolValue enable_ja3_fingerprinting = 1;

  // The size in bytes of the initial buffer requested by the tls_inspector.
  // If the filter needs to read additional bytes from the socket, the
  // filter will double the buffer up to it's default maximum of 64KiB.
  // If this size is not defined, defaults to maximum 64KiB that the
  // tls inspector will consume.
  google.protobuf.UInt32Value initial_read_buffer_size = 2
      [(validate.rules).uint32 = {lt: 65537 gt: 255}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.listener.local_ratelimit.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/type/v3/token_bucket.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.listener.local_ratelimit.v3";
option java_outer_classname = "LocalRatelimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/listener/local_ratelimit/v3;local_ratelimitv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Local Rate Limit Filter]
// Local rate limit :ref:`configuration overview <config_listener_filters_local_rate_limit>`.
// [#extension: envoy.filters.listener.local_ratelimit]

message LocalRateLimit {
  // The prefix to use when emitting :ref:`statistics
  // <config_listener_filters_local_rate_limit_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // The token bucket configuration to use for rate limiting all incoming sockets. If the token is available,
  // the socket will be allowed. If no tokens are available, the socket will be immediately closed.
  //
  // .. note::
  //   In the current implementation the token bucket's :ref:`fill_interval
  //   <envoy_v3_api_field_type.v3.TokenBucket.fill_interval>` must be >= 50ms to avoid too aggressive
  //   refills.
  type.v3.TokenBucket token_bucket = 2 [(validate.rules).message = {required: true}];

  // Runtime flag that controls whether the filter is enabled or not. If not specified, defaults
  // to enabled.
  config.core.v3.RuntimeFeatureFlag runtime_enabled = 3;
}
syntax = "proto3";

package envoy.extensions.filters.listener.original_src.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.listener.original_src.v3";
option java_outer_classname = "OriginalSrcProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/listener/original_src/v3;original_srcv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Original Src Filter]
// Use the Original source address on upstream connections.
// [#extension: envoy.filters.listener.original_src]

// The Original Src filter binds upstream connections to the original source address determined
// for the connection. This address could come from something like the Proxy Protocol filter, or it
// could come from trusted http headers.
message OriginalSrc {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.listener.original_src.v2alpha1.OriginalSrc";

  // Whether to bind the port to the one used in the original downstream connection.
  // [#not-implemented-hide:]
  bool bind_port = 1;

  // Sets the SO_MARK option on the upstream connection's socket to the provided value. Used to
  // ensure that non-local addresses may be routed back through envoy when binding to the original
  // source address. The option will not be applied if the mark is 0.
  uint32 mark = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.listener.http_inspector.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.listener.http_inspector.v3";
option java_outer_classname = "HttpInspectorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/listener/http_inspector/v3;http_inspectorv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP Inspector Filter]
// Detect whether the application protocol is HTTP.
// [#extension: envoy.filters.listener.http_inspector]

message HttpInspector {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.listener.http_inspector.v2.HttpInspector";
}
syntax = "proto3";

package envoy.extensions.filters.listener.original_dst.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.listener.original_dst.v3";
option java_outer_classname = "OriginalDstProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/listener/original_dst/v3;original_dstv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Original Dst Filter]
// Use the Original destination address on downstream connections.
// [#extension: envoy.filters.listener.original_dst]

message OriginalDst {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.listener.original_dst.v2.OriginalDst";
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.listener.proxy_protocol.v3;

import "envoy/config/core/v3/proxy_protocol.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.listener.proxy_protocol.v3";
option java_outer_classname = "ProxyProtocolProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/listener/proxy_protocol/v3;proxy_protocolv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Proxy Protocol Filter]
// PROXY protocol listener filter.
// [#extension: envoy.filters.listener.proxy_protocol]

message ProxyProtocol {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.listener.proxy_protocol.v2.ProxyProtocol";

  message KeyValuePair {
    // The namespace  if this is empty, the filter's namespace will be used.
    string metadata_namespace = 1;

    // The key to use within the namespace.
    string key = 2 [(validate.rules).string = {min_len: 1}];
  }

  // A Rule defines what metadata to apply when a header is present or missing.
  message Rule {
    // The type that triggers the rule - required
    // TLV type is defined as uint8_t in proxy protocol. See `the spec
    // <https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt>`_ for details.
    uint32 tlv_type = 1 [(validate.rules).uint32 = {lt: 256}];

    // If the TLV type is present, apply this metadata KeyValuePair.
    KeyValuePair on_tlv_present = 2;
  }

  // The list of rules to apply to requests.
  repeated Rule rules = 1;

  // Allow requests through that don't use proxy protocol. Defaults to false.
  //
  // .. attention::
  //
  //   This breaks conformance with the specification.
  //   Only enable if ALL traffic to the listener comes from a trusted source.
  //   For more information on the security implications of this feature, see
  //   https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt
  //
  // .. attention::
  //
  //   Requests of 12 or fewer bytes that match the proxy protocol v2 signature
  //   and requests of 6 or fewer bytes that match the proxy protocol v1
  //   signature will timeout (Envoy is unable to differentiate these requests
  //   from incomplete proxy protocol requests).
  bool allow_requests_without_proxy_protocol = 2;

  // This config controls which TLVs can be passed to filter state if it is Proxy Protocol
  // V2 header. If there is no setting for this field, no TLVs will be passed through.
  //
  // .. note::
  //
  //   If this is configured, you likely also want to set
  //   :ref:`core.v3.ProxyProtocolConfig.pass_through_tlvs <envoy_v3_api_field_config.core.v3.ProxyProtocolConfig.pass_through_tlvs>`,
  //   which controls pass-through for the upstream.
  config.core.v3.ProxyProtocolPassThroughTLVs pass_through_tlvs = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.udp.dns_filter.v3;

import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/resolver.proto";
import "envoy/data/dns/v3/dns_table.proto";

import "google/protobuf/duration.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.udp.dns_filter.v3";
option java_outer_classname = "DnsFilterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/udp/dns_filter/v3;dns_filterv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: DNS Filter]
// DNS Filter :ref:`configuration overview <config_udp_listener_filters_dns_filter>`.
// [#extension: envoy.filters.udp.dns_filter]

// Configuration for the DNS filter.
message DnsFilterConfig {
  // This message contains the configuration for the DNS Filter operating
  // in a server context. This message will contain the virtual hosts and
  // associated addresses with which Envoy will respond to queries
  message ServerContextConfig {
    oneof config_source {
      option (validate.required) = true;

      // Load the configuration specified from the control plane
      data.dns.v3.DnsTable inline_dns_table = 1;

      // Seed the filter configuration from an external path. This source
      // is a yaml formatted file that contains the DnsTable driving Envoy's
      // responses to DNS queries
      config.core.v3.DataSource external_dns_table = 2;
    }
  }

  // This message contains the configuration for the DNS Filter operating
  // in a client context. This message will contain the timeouts, retry,
  // and forwarding configuration for Envoy to make DNS requests to other
  // resolvers
  //
  // [#next-free-field: 6]
  message ClientContextConfig {
    // Sets the maximum time we will wait for the upstream query to complete
    // We allow 5s for the upstream resolution to complete, so the minimum
    // value here is 1. Note that the total latency for a failed query is the
    // number of retries multiplied by the resolver_timeout.
    google.protobuf.Duration resolver_timeout = 1 [(validate.rules).duration = {gte {seconds: 1}}];

    // This field was used for `dns_resolution_config` in Envoy 1.19.0 and
    // 1.19.1.
    // Control planes that need to set this field for Envoy 1.19.0 and
    // 1.19.1 clients should fork the protobufs and change the field type
    // to `DnsResolutionConfig`.
    // Control planes that need to simultaneously support Envoy 1.18.x and
    // Envoy 1.19.x should avoid Envoy 1.19.0 and 1.19.1.
    //
    // [#not-implemented-hide:]
    repeated config.core.v3.Address upstream_resolvers = 2
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

    // DNS resolution configuration which includes the underlying dns resolver addresses and options.
    // This field is deprecated in favor of
    // :ref:`typed_dns_resolver_config <envoy_v3_api_field_extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig.typed_dns_resolver_config>`.
    config.core.v3.DnsResolutionConfig dns_resolution_config = 5
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

    // DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
    // or any other DNS resolver types and the related parameters.
    // For example, an object of
    // :ref:`CaresDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
    // can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
    // :ref:`dns_resolution_config <envoy_v3_api_field_extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig.dns_resolution_config>`
    // configuration.
    // During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
    // when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
    // When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
    // [#extension-category: envoy.network.dns_resolver]
    config.core.v3.TypedExtensionConfig typed_dns_resolver_config = 4;

    // Controls how many outstanding external lookup contexts the filter tracks.
    // The context structure allows the filter to respond to every query even if the external
    // resolution times out or is otherwise unsuccessful
    uint64 max_pending_lookups = 3 [(validate.rules).uint64 = {gte: 1}];
  }

  // The stat prefix used when emitting DNS filter statistics
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // Server context configuration contains the data that the filter uses to respond
  // to DNS requests.
  ServerContextConfig server_config = 2;

  // Client context configuration controls Envoy's behavior when it must use external
  // resolvers to answer a query. This object is optional and if omitted instructs
  // the filter to resolve queries from the data in the server_config
  ClientContextConfig client_config = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/data/dns/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.udp.udp_proxy.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.udp.udp_proxy.v3";
option java_outer_classname = "RouteProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/udp/udp_proxy/v3;udp_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: UDP proxy route configuration]
// UDP proxy :ref:`configuration overview <config_udp_listener_filters_udp_proxy>`.

message Route {
  // Indicates the upstream cluster to which the request should be routed.
  string cluster = 1 [(validate.rules).string = {min_len: 1}];
}
syntax = "proto3";

package envoy.extensions.filters.udp.udp_proxy.v3;

import "envoy/config/accesslog/v3/accesslog.proto";
import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/udp_socket_config.proto";

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";
import "xds/type/matcher/v3/matcher.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.udp.udp_proxy.v3";
option java_outer_classname = "UdpProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/udp/udp_proxy/v3;udp_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: UDP proxy]
// UDP proxy :ref:`configuration overview <config_udp_listener_filters_udp_proxy>`.
// [#extension: envoy.filters.udp_listener.udp_proxy]

// Configuration for the UDP proxy filter.
// [#next-free-field: 14]
message UdpProxyConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.udp.udp_proxy.v2alpha.UdpProxyConfig";

  // Specifies the UDP hash policy.
  // The packets can be routed by hash policy.
  message HashPolicy {
    oneof policy_specifier {
      option (validate.required) = true;

      // The source IP will be used to compute the hash used by hash-based load balancing algorithms.
      bool source_ip = 1 [(validate.rules).bool = {const: true}];

      // A given key will be used to compute the hash used by hash-based load balancing algorithms.
      // In certain cases there is a need to direct different UDP streams jointly towards the selected set of endpoints.
      // A possible use-case is VoIP telephony, where media (RTP) and its corresponding control (RTCP) belong to the same logical session,
      // although they travel in separate streams. To ensure that these pair of streams are load-balanced on session level
      // (instead of individual stream level), dynamically created listeners can use the same hash key for each stream in the session.
      string key = 2 [(validate.rules).string = {min_len: 1}];
    }
  }

  // Configuration for UDP session filters.
  message SessionFilter {
    // The name of the filter configuration.
    string name = 1 [(validate.rules).string = {min_len: 1}];

    oneof config_type {
      // Filter specific configuration which depends on the filter being
      // instantiated. See the supported filters for further documentation.
      google.protobuf.Any typed_config = 2;
    }
  }

  // Configuration for tunneling UDP over other transports or application layers.
  // Tunneling is currently supported over HTTP/2.
  // [#next-free-field: 12]
  message UdpTunnelingConfig {
    // Configuration for UDP datagrams buffering.
    message BufferOptions {
      // If set, the filter will only buffer datagrams up to the requested limit, and will drop
      // new UDP datagrams if the buffer contains the max_buffered_datagrams value at the time
      // of a new datagram arrival. If not set, the default value is 1024 datagrams.
      google.protobuf.UInt32Value max_buffered_datagrams = 1;

      // If set, the filter will only buffer datagrams up to the requested total buffered bytes limit,
      // and will drop new UDP datagrams if the buffer contains the max_buffered_datagrams value
      // at the time of a new datagram arrival. If not set, the default value is 16,384 (16KB).
      google.protobuf.UInt64Value max_buffered_bytes = 2;
    }

    message RetryOptions {
      // The maximum number of unsuccessful connection attempts that will be made before giving up.
      // If the parameter is not specified, 1 connection attempt will be made.
      google.protobuf.UInt32Value max_connect_attempts = 1;
    }

    // The hostname to send in the synthesized CONNECT headers to the upstream proxy.
    // This field evaluates command operators if set, otherwise returns hostname as is.
    //
    // Example: dynamically set hostname using filter state
    //
    // .. code-block:: yaml
    //
    //    tunneling_config:
    //      proxy_host: "%FILTER_STATE(proxy.host.key:PLAIN)%"
    //
    string proxy_host = 1 [(validate.rules).string = {min_len: 1}];

    // Optional port value to add to the HTTP request URI.
    // This value can be overridden per-session by setting the required port value for
    // the filter state key ``udp.connect.proxy_port``.
    google.protobuf.UInt32Value proxy_port = 2;

    // The target host to send in the synthesized CONNECT headers to the upstream proxy.
    // This field evaluates command operators if set, otherwise returns hostname as is.
    //
    // Example: dynamically set target host using filter state
    //
    // .. code-block:: yaml
    //
    //    tunneling_config:
    //      target_host: "%FILTER_STATE(target.host.key:PLAIN)%"
    //
    string target_host = 3 [(validate.rules).string = {min_len: 1}];

    // The default target port to send in the CONNECT headers to the upstream proxy.
    // This value can be overridden per-session by setting the required port value for
    // the filter state key ``udp.connect.target_port``.
    uint32 default_target_port = 4 [(validate.rules).uint32 = {lte: 65535 gt: 0}];

    // Use POST method instead of CONNECT method to tunnel the UDP stream.
    //
    // .. note::
    //   If use_post is set, the upstream stream does not comply with the connect-udp RFC, and
    //   instead it will be a POST request. the path used in the headers will be set from the
    //   post_path field, and the headers will not contain the target host and target port, as
    //   required by the connect-udp protocol. This flag should be used carefully.
    //
    bool use_post = 5;

    // The path used with POST method. Default path is ``/``. If post path is specified and
    // use_post field isn't true, it will be rejected.
    string post_path = 6;

    // Optional retry options, in case connecting to the upstream failed.
    RetryOptions retry_options = 7;

    // Additional request headers to upstream proxy. Neither ``:-prefixed`` pseudo-headers
    // nor the Host: header can be overridden. Values of the added headers evaluates command
    // operators if they are set in the value template.
    //
    // Example: dynamically set a header with the local port
    //
    // .. code-block:: yaml
    //
    //    headers_to_add:
    //    - header:
    //        key: original_dst_port
    //        value: "%DOWNSTREAM_LOCAL_PORT%"
    //
    repeated config.core.v3.HeaderValueOption headers_to_add = 8
        [(validate.rules).repeated = {max_items: 1000}];

    // If configured, the filter will buffer datagrams in case that it is waiting for the upstream to be
    // ready, whether if it is during the connection process or due to upstream buffer watermarks.
    // If this field is not configured, there will be no buffering and downstream datagrams that arrive
    // while the upstream is not ready will be dropped. In case this field is set but the options
    // are not configured, the default values will be applied as described in the ``BufferOptions``.
    BufferOptions buffer_options = 9;

    // Save the response headers to the downstream info filter state for consumption
    // by the session filters. The filter state key is ``envoy.udp_proxy.propagate_response_headers``.
    bool propagate_response_headers = 10;

    // Save the response trailers to the downstream info filter state for consumption
    // by the session filters. The filter state key is ``envoy.udp_proxy.propagate_response_trailers``.
    bool propagate_response_trailers = 11;
  }

  message UdpAccessLogOptions {
    // The interval to flush access log. The UDP proxy will flush only one access log when the session
    // is ended by default. If this field is set, the UDP proxy will flush access log periodically with
    // the specified interval.
    // This field does not require on-tunnel-connected access logging enabled, and the other way around.
    // The interval must be at least 1ms.
    google.protobuf.Duration access_log_flush_interval = 1
        [(validate.rules).duration = {gte {nanos: 1000000}}];

    // If set to true and UDP tunneling is configured, access log will be flushed when the UDP proxy has successfully
    // established a connection tunnel with the upstream. If the connection failed, the access log will not be flushed.
    bool flush_access_log_on_tunnel_connected = 2;
  }

  // The stat prefix used when emitting UDP proxy filter stats.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  oneof route_specifier {
    option (validate.required) = true;

    // The upstream cluster to connect to.
    // This field is deprecated in favor of
    // :ref:`matcher <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.matcher>`.
    string cluster = 2 [
      deprecated = true,
      (validate.rules).string = {min_len: 1},
      (envoy.annotations.deprecated_at_minor_version) = "3.0"
    ];

    // The match tree to use when resolving route actions for incoming requests.
    // See :ref:`Routing <config_udp_listener_filters_udp_proxy_routing>` for more information.
    xds.type.matcher.v3.Matcher matcher = 9
        [(xds.annotations.v3.field_status).work_in_progress = true];
  }

  // The idle timeout for sessions. Idle is defined as no datagrams between received or sent by
  // the session. The default if not specified is 1 minute.
  google.protobuf.Duration idle_timeout = 3;

  // Use the remote downstream IP address as the sender IP address when sending packets to upstream hosts.
  // This option requires Envoy to be run with the ``CAP_NET_ADMIN`` capability on Linux.
  // And the IPv6 stack must be enabled on Linux kernel.
  // This option does not preserve the remote downstream port.
  // If this option is enabled, the IP address of sent datagrams will be changed to the remote downstream IP address.
  // This means that Envoy will not receive packets that are sent by upstream hosts because the upstream hosts
  // will send the packets with the remote downstream IP address as the destination. All packets will be routed
  // to the remote downstream directly if there are route rules on the upstream host side.
  // There are two options to return the packets back to the remote downstream.
  // The first one is to use DSR (Direct Server Return).
  // The other one is to configure routing rules on the upstream hosts to forward
  // all packets back to Envoy and configure iptables rules on the host running Envoy to
  // forward all packets from upstream hosts to the Envoy process so that Envoy can forward the packets to the downstream.
  // If the platform does not support this option, Envoy will raise a configuration error.
  bool use_original_src_ip = 4;

  // Optional configuration for UDP proxy hash policies. If hash_policies is not set, the hash-based
  // load balancing algorithms will select a host randomly. Currently the number of hash policies is
  // limited to 1.
  repeated HashPolicy hash_policies = 5 [(validate.rules).repeated = {max_items: 1}];

  // UDP socket configuration for upstream sockets. The default for
  // :ref:`prefer_gro <envoy_v3_api_field_config.core.v3.UdpSocketConfig.prefer_gro>` is true for upstream
  // sockets as the assumption is datagrams will be received from a single source.
  config.core.v3.UdpSocketConfig upstream_socket_config = 6;

  // Perform per packet load balancing (upstream host selection) on each received data chunk.
  // The default if not specified is false, that means each data chunk is forwarded
  // to upstream host selected on first chunk receival for that "session" (identified by source IP/port and local IP/port).
  // Only one of use_per_packet_load_balancing or session_filters can be used.
  bool use_per_packet_load_balancing = 7;

  // Configuration for session access logs emitted by the UDP proxy. Note that certain UDP specific data is emitted as :ref:`Dynamic Metadata <config_access_log_format_dynamic_metadata>`.
  repeated config.accesslog.v3.AccessLog access_log = 8;

  // Configuration for proxy access logs emitted by the UDP proxy. Note that certain UDP specific data is emitted as :ref:`Dynamic Metadata <config_access_log_format_dynamic_metadata>`.
  repeated config.accesslog.v3.AccessLog proxy_access_log = 10;

  // Optional session filters that will run for each UDP session.
  // Only one of use_per_packet_load_balancing or session_filters can be used.
  // [#extension-category: envoy.filters.udp.session]
  repeated SessionFilter session_filters = 11;

  // If set, this configures UDP tunneling. See `Proxying UDP in HTTP <https://www.rfc-editor.org/rfc/rfc9298.html>`_.
  // More information can be found in the UDP Proxy and HTTP upgrade documentation.
  UdpTunnelingConfig tunneling_config = 12;

  // Additional access log options for UDP Proxy.
  UdpAccessLogOptions access_log_options = 13;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/accesslog/v3:pkg",
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
        "@com_github_cncf_xds//xds/type/matcher/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.udp.udp_proxy.session.dynamic_forward_proxy.v3;

import "envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.udp.udp_proxy.session.dynamic_forward_proxy.v3";
option java_outer_classname = "DynamicForwardProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/udp/udp_proxy/session/dynamic_forward_proxy/v3;dynamic_forward_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Filter state dynamic forward proxy]

// Configuration for the filter state based dynamic forward proxy filter. See the
// :ref:`architecture overview <arch_overview_http_dynamic_forward_proxy>` for
// more information. Note this filter must be used in conjunction to another filter that
// sets the 'envoy.upstream.dynamic_host' and the 'envoy.upstream.dynamic_port' filter
// state keys for the required upstream UDP session.
// [#extension: envoy.filters.udp.session.dynamic_forward_proxy]
message FilterConfig {
  // Configuration for UDP datagrams buffering.
  message BufferOptions {
    // If set, the filter will only buffer datagrams up to the requested limit, and will drop
    // new UDP datagrams if the buffer contains the max_buffered_datagrams value at the time
    // of a new datagram arrival. If not set, the default value is 1024 datagrams.
    google.protobuf.UInt32Value max_buffered_datagrams = 1;

    // If set, the filter will only buffer datagrams up to the requested total buffered bytes limit,
    // and will drop new UDP datagrams if the buffer contains the max_buffered_datagrams value
    // at the time of a new datagram arrival. If not set, the default value is 16,384 (16KB).
    google.protobuf.UInt64Value max_buffered_bytes = 2;
  }

  // The prefix to use when emitting :ref:`statistics <config_udp_session_filters_dynamic_forward_proxy_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  oneof implementation_specifier {
    // The DNS cache configuration that the filter will attach to. Note this
    // configuration must match that of associated :ref:`dynamic forward proxy cluster configuration
    // <envoy_v3_api_field_extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig.dns_cache_config>`.
    common.dynamic_forward_proxy.v3.DnsCacheConfig dns_cache_config = 2
        [(validate.rules).message = {required: true}];
  }

  // If configured, the filter will buffer datagrams in case that it is waiting for a DNS response.
  // If this field is not configured, there will be no buffering and downstream datagrams that arrive
  // while the DNS resolution is in progress will be dropped. In case this field is set but the options
  // are not configured, the default values will be applied as described in the ``BufferOptions``.
  BufferOptions buffer_options = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/common/dynamic_forward_proxy/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.udp.udp_proxy.session.http_capsule.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.udp.udp_proxy.session.http_capsule.v3";
option java_outer_classname = "HttpCapsuleProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/udp/udp_proxy/session/http_capsule/v3;http_capsulev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: UDP HTTP Capsule filter]
// UDP to HTTP capsules :ref:`overview <config_udp_session_filters_http_capsule>`.
// [#extension: envoy.filters.udp.session.http_capsule]

message FilterConfig {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/rbac/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
        "@com_github_cncf_xds//xds/type/matcher/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.rbac.v3;

import "envoy/config/rbac/v3/rbac.proto";

import "xds/annotations/v3/status.proto";
import "xds/type/matcher/v3/matcher.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.rbac.v3";
option java_outer_classname = "RbacProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/rbac/v3;rbacv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: RBAC]
// Role-Based Access Control :ref:`configuration overview <config_network_filters_rbac>`.
// [#extension: envoy.filters.network.rbac]

// RBAC network filter config.
//
// Header should not be used in rules/shadow_rules in RBAC network filter as
// this information is only available in :ref:`RBAC http filter <config_http_filters_rbac>`.
// [#next-free-field: 8]
message RBAC {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.rbac.v2.RBAC";

  enum EnforcementType {
    // Apply RBAC policies when the first byte of data arrives on the connection.
    ONE_TIME_ON_FIRST_BYTE = 0;

    // Continuously apply RBAC policies as data arrives. Use this mode when
    // using RBAC with message oriented protocols such as Mongo, MySQL, Kafka,
    // etc. when the protocol decoders emit dynamic metadata such as the
    // resources being accessed and the operations on the resources.
    CONTINUOUS = 1;
  }

  // Specify the RBAC rules to be applied globally.
  // If absent, no enforcing RBAC policy will be applied.
  // If present and empty, DENY.
  // If both rules and matcher are configured, rules will be ignored.
  config.rbac.v3.RBAC rules = 1
      [(udpa.annotations.field_migrate).oneof_promotion = "rules_specifier"];

  // The match tree to use when resolving RBAC action for incoming connections. Connections do
  // not match any matcher will be denied.
  // If absent, no enforcing RBAC matcher will be applied.
  // If present and empty, deny all connections.
  xds.type.matcher.v3.Matcher matcher = 6 [
    (udpa.annotations.field_migrate).oneof_promotion = "rules_specifier",
    (xds.annotations.v3.field_status).work_in_progress = true
  ];

  // Shadow rules are not enforced by the filter but will emit stats and logs
  // and can be used for rule testing.
  // If absent, no shadow RBAC policy will be applied.
  // If both shadow rules and shadow matcher are configured, shadow rules will be ignored.
  config.rbac.v3.RBAC shadow_rules = 2
      [(udpa.annotations.field_migrate).oneof_promotion = "shadow_rules_specifier"];

  // The match tree to use for emitting stats and logs which can be used for rule testing for
  // incoming connections.
  // If absent, no shadow matcher will be applied.
  xds.type.matcher.v3.Matcher shadow_matcher = 7 [
    (udpa.annotations.field_migrate).oneof_promotion = "shadow_rules_specifier",
    (xds.annotations.v3.field_status).work_in_progress = true
  ];

  // If specified, shadow rules will emit stats with the given prefix.
  // This is useful to distinguish the stat when there are more than 1 RBAC filter configured with
  // shadow rules.
  string shadow_rules_stat_prefix = 5;

  // The prefix to use when emitting statistics.
  string stat_prefix = 3 [(validate.rules).string = {min_len: 1}];

  // RBAC enforcement strategy. By default RBAC will be enforced only once
  // when the first byte of data arrives from the downstream. When used in
  // conjunction with filters that emit dynamic metadata after decoding
  // every payload (e.g., Mongo, MySQL, Kafka) set the enforcement type to
  // CONTINUOUS to enforce RBAC policies on every message boundary.
  EnforcementType enforcement_type = 4;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.local_ratelimit.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/type/v3/token_bucket.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.local_ratelimit.v3";
option java_outer_classname = "LocalRateLimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/local_ratelimit/v3;local_ratelimitv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Local rate limit]
// Local rate limit :ref:`configuration overview <config_network_filters_local_rate_limit>`.
// [#extension: envoy.filters.network.local_ratelimit]

message LocalRateLimit {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.local_rate_limit.v2alpha.LocalRateLimit";

  // The prefix to use when emitting :ref:`statistics
  // <config_network_filters_local_rate_limit_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // The token bucket configuration to use for rate limiting connections that are processed by the
  // filter's filter chain. Each incoming connection processed by the filter consumes a single
  // token. If the token is available, the connection will be allowed. If no tokens are available,
  // the connection will be immediately closed.
  //
  // .. note::
  //   In the current implementation each filter and filter chain has an independent rate limit, unless
  //   a shared rate limit is configured via :ref:`share_key <envoy_v3_api_field_extensions.filters.network.local_ratelimit.v3.LocalRateLimit.share_key>`.
  //
  // .. note::
  //   In the current implementation the token bucket's :ref:`fill_interval
  //   <envoy_v3_api_field_type.v3.TokenBucket.fill_interval>` must be >= 50ms to avoid too aggressive
  //   refills.
  type.v3.TokenBucket token_bucket = 2 [(validate.rules).message = {required: true}];

  // Runtime flag that controls whether the filter is enabled or not. If not specified, defaults
  // to enabled.
  config.core.v3.RuntimeFeatureFlag runtime_enabled = 3;

  // Specifies that the token bucket used for rate limiting should be shared with other local_rate_limit filters
  // with a matching :ref:`token_bucket <envoy_v3_api_field_extensions.filters.network.local_ratelimit.v3.LocalRateLimit.token_bucket>`
  // and ``share_key`` configuration. All fields of ``token_bucket`` must match exactly for the token bucket to be shared. If this
  // field is empty, this filter will not share a token bucket with any other filter.
  string share_key = 4;
}
syntax = "proto3";

package envoy.extensions.filters.network.echo.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.echo.v3";
option java_outer_classname = "EchoProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/echo/v3;echov3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Echo]
// Echo :ref:`configuration overview <config_network_filters_echo>`.
// [#extension: envoy.filters.network.echo]

message Echo {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.echo.v2.Echo";
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.network.connection_limit.v3;

import "envoy/config/core/v3/base.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.connection_limit.v3";
option java_outer_classname = "ConnectionLimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/connection_limit/v3;connection_limitv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Connection limit]
// Connection limit :ref:`configuration overview <config_network_filters_connection_limit>`.
// [#extension: envoy.filters.network.connection_limit]

message ConnectionLimit {
  // The prefix to use when emitting :ref:`statistics
  // <config_network_filters_connection_limit_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // The max connections configuration to use for new incoming connections that are processed
  // by the filter's filter chain. When max_connection is reached, the incoming connection
  // will be closed after delay duration.
  google.protobuf.UInt64Value max_connections = 2 [(validate.rules).uint64 = {gte: 1}];

  // The delay configuration to use for rejecting the connection after some specified time duration
  // instead of immediately rejecting the connection. That way, a malicious user is not able to
  // retry as fast as possible which provides a better DoS protection for Envoy. If this is not present,
  // the connection will be closed immediately.
  google.protobuf.Duration delay = 3;

  // Runtime flag that controls whether the filter is enabled or not. If not specified, defaults
  // to enabled.
  config.core.v3.RuntimeFeatureFlag runtime_enabled = 4;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.tcp_proxy.v3;

import "envoy/config/accesslog/v3/accesslog.proto";
import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/config_source.proto";
import "envoy/type/v3/hash_policy.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.tcp_proxy.v3";
option java_outer_classname = "TcpProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/tcp_proxy/v3;tcp_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: TCP Proxy]
// TCP Proxy :ref:`configuration overview <config_network_filters_tcp_proxy>`.
// [#extension: envoy.filters.network.tcp_proxy]

// [#next-free-field: 18]
message TcpProxy {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.tcp_proxy.v2.TcpProxy";

  // Allows for specification of multiple upstream clusters along with weights
  // that indicate the percentage of traffic to be forwarded to each cluster.
  // The router selects an upstream cluster based on these weights.
  message WeightedCluster {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.WeightedCluster";

    message ClusterWeight {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.WeightedCluster.ClusterWeight";

      // Name of the upstream cluster.
      string name = 1 [(validate.rules).string = {min_len: 1}];

      // When a request matches the route, the choice of an upstream cluster is
      // determined by its weight. The sum of weights across all entries in the
      // clusters array determines the total weight.
      uint32 weight = 2 [(validate.rules).uint32 = {gte: 1}];

      // Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
      // in the upstream cluster with metadata matching what is set in this field will be considered
      // for load balancing. Note that this will be merged with what's provided in
      // :ref:`TcpProxy.metadata_match
      // <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.metadata_match>`, with values
      // here taking precedence. The filter name should be specified as ``envoy.lb``.
      config.core.v3.Metadata metadata_match = 3;
    }

    // Specifies one or more upstream clusters associated with the route.
    repeated ClusterWeight clusters = 1 [(validate.rules).repeated = {min_items: 1}];
  }

  // Configuration for tunneling TCP over other transports or application layers.
  // Tunneling is supported over both HTTP/1.1 and HTTP/2. Upstream protocol is
  // determined by the cluster configuration.
  // [#next-free-field: 7]
  message TunnelingConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.TunnelingConfig";

    // The hostname to send in the synthesized CONNECT headers to the upstream proxy.
    // This field evaluates command operators if set, otherwise returns hostname as is.
    //
    // Example: dynamically set hostname using downstream SNI
    //
    // .. code-block:: yaml
    //
    //    tunneling_config:
    //      hostname: "%REQUESTED_SERVER_NAME%:443"
    //
    // Example: dynamically set hostname using dynamic metadata
    //
    // .. code-block:: yaml
    //
    //    tunneling_config:
    //      hostname: "%DYNAMIC_METADATA(tunnel:address)%"
    //
    string hostname = 1 [(validate.rules).string = {min_len: 1}];

    // Use POST method instead of CONNECT method to tunnel the TCP stream.
    // The 'protocol: bytestream' header is also NOT set for HTTP/2 to comply with the spec.
    //
    // The upstream proxy is expected to convert POST payload as raw TCP.
    bool use_post = 2;

    // Additional request headers to upstream proxy. This is mainly used to
    // trigger upstream to convert POST requests back to CONNECT requests.
    //
    // Neither ``:-prefixed`` pseudo-headers nor the Host: header can be overridden.
    repeated config.core.v3.HeaderValueOption headers_to_add = 3
        [(validate.rules).repeated = {max_items: 1000}];

    // Save the response headers to the downstream info filter state for consumption
    // by the network filters. The filter state key is ``envoy.tcp_proxy.propagate_response_headers``.
    bool propagate_response_headers = 4;

    // The path used with POST method. Default path is ``/``. If post path is specified and
    // :ref:`use_post field <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.use_post>`
    // isn't true, it will be rejected.
    string post_path = 5;

    // Save the response trailers to the downstream info filter state for consumption
    // by the network filters. The filter state key is ``envoy.tcp_proxy.propagate_response_trailers``.
    bool propagate_response_trailers = 6;
  }

  message OnDemand {
    // An optional configuration for on-demand cluster discovery
    // service. If not specified, the on-demand cluster discovery will
    // be disabled. When it's specified, the filter will pause a request
    // to an unknown cluster and will begin a cluster discovery
    // process. When the discovery is finished (successfully or not),
    // the request will be resumed.
    config.core.v3.ConfigSource odcds_config = 1;

    // xdstp:// resource locator for on-demand cluster collection.
    // [#not-implemented-hide:]
    string resources_locator = 2;

    // The timeout for on demand cluster lookup. If the CDS cannot return the required cluster,
    // the downstream request will be closed with the error code detail NO_CLUSTER_FOUND.
    // [#not-implemented-hide:]
    google.protobuf.Duration timeout = 3;
  }

  message TcpAccessLogOptions {
    // The interval to flush access log. The TCP proxy will flush only one access log when the connection
    // is closed by default. If this field is set, the TCP proxy will flush access log periodically with
    // the specified interval.
    // The interval must be at least 1ms.
    google.protobuf.Duration access_log_flush_interval = 1
        [(validate.rules).duration = {gte {nanos: 1000000}}];

    // If set to true, access log will be flushed when the TCP proxy has successfully established a
    // connection with the upstream. If the connection failed, the access log will not be flushed.
    bool flush_access_log_on_connected = 2;
  }

  reserved 6;

  reserved "deprecated_v1";

  // The prefix to use when emitting :ref:`statistics
  // <config_network_filters_tcp_proxy_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  oneof cluster_specifier {
    option (validate.required) = true;

    // The upstream cluster to connect to.
    string cluster = 2;

    // Multiple upstream clusters can be specified for a given route. The
    // request is routed to one of the upstream clusters based on weights
    // assigned to each cluster.
    WeightedCluster weighted_clusters = 10;
  }

  // The on demand policy for the upstream cluster.
  // It applies to both
  // :ref:`TcpProxy.cluster <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.cluster>`
  // and
  // :ref:`TcpProxy.weighted_clusters <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.weighted_clusters>`.
  OnDemand on_demand = 14;

  // Optional endpoint metadata match criteria. Only endpoints in the upstream
  // cluster with metadata matching that set in metadata_match will be
  // considered. The filter name should be specified as ``envoy.lb``.
  config.core.v3.Metadata metadata_match = 9;

  // The idle timeout for connections managed by the TCP proxy filter. The idle timeout
  // is defined as the period in which there are no bytes sent or received on either
  // the upstream or downstream connection. If not set, the default idle timeout is 1 hour. If set
  // to 0s, the timeout will be disabled.
  //
  // .. warning::
  //   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
  //   FIN packets, etc.
  google.protobuf.Duration idle_timeout = 8;

  // [#not-implemented-hide:] The idle timeout for connections managed by the TCP proxy
  // filter. The idle timeout is defined as the period in which there is no
  // active traffic. If not set, there is no idle timeout. When the idle timeout
  // is reached the connection will be closed. The distinction between
  // downstream_idle_timeout/upstream_idle_timeout provides a means to set
  // timeout based on the last byte sent on the downstream/upstream connection.
  google.protobuf.Duration downstream_idle_timeout = 3;

  // [#not-implemented-hide:]
  google.protobuf.Duration upstream_idle_timeout = 4;

  // Configuration for :ref:`access logs <arch_overview_access_logs>`
  // emitted by the this tcp_proxy.
  repeated config.accesslog.v3.AccessLog access_log = 5;

  // The maximum number of unsuccessful connection attempts that will be made before
  // giving up. If the parameter is not specified, 1 connection attempt will be made.
  google.protobuf.UInt32Value max_connect_attempts = 7 [(validate.rules).uint32 = {gte: 1}];

  // Optional configuration for TCP proxy hash policy. If hash_policy is not set, the hash-based
  // load balancing algorithms will select a host randomly. Currently the number of hash policies is
  // limited to 1.
  repeated type.v3.HashPolicy hash_policy = 11 [(validate.rules).repeated = {max_items: 1}];

  // If set, this configures tunneling, e.g. configuration options to tunnel TCP payload over
  // HTTP CONNECT. If this message is absent, the payload will be proxied upstream as per usual.
  // It is possible to dynamically override this configuration and disable tunneling per connection,
  // by setting a per-connection filter state object for the key ``envoy.tcp_proxy.disable_tunneling``.
  TunnelingConfig tunneling_config = 12;

  // The maximum duration of a connection. The duration is defined as the period since a connection
  // was established. If not set, there is no max duration. When max_downstream_connection_duration
  // is reached the connection will be closed. Duration must be at least 1ms.
  google.protobuf.Duration max_downstream_connection_duration = 13
      [(validate.rules).duration = {gte {nanos: 1000000}}];

  // .. attention::
  // This field is deprecated in favor of
  // :ref:`access_log_flush_interval
  // <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.access_log_flush_interval>`.
  // Note that if both this field and :ref:`access_log_flush_interval
  // <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.access_log_flush_interval>`
  // are specified, the former (deprecated field) is ignored.
  google.protobuf.Duration access_log_flush_interval = 15 [
    deprecated = true,
    (validate.rules).duration = {gte {nanos: 1000000}},
    (envoy.annotations.deprecated_at_minor_version) = "3.0"
  ];

  // .. attention::
  // This field is deprecated in favor of
  // :ref:`flush_access_log_on_connected
  // <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.flush_access_log_on_connected>`.
  // Note that if both this field and :ref:`flush_access_log_on_connected
  // <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.flush_access_log_on_connected>`
  // are specified, the former (deprecated field) is ignored.
  bool flush_access_log_on_connected = 16
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Additional access log options for TCP Proxy.
  TcpAccessLogOptions access_log_options = 17;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/accesslog/v3:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/filters/common/fault/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.mongo_proxy.v3;

import "envoy/extensions/filters/common/fault/v3/fault.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.mongo_proxy.v3";
option java_outer_classname = "MongoProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/mongo_proxy/v3;mongo_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Mongo proxy]
// MongoDB :ref:`configuration overview <config_network_filters_mongo_proxy>`.
// [#extension: envoy.filters.network.mongo_proxy]

// [#next-free-field: 6]
message MongoProxy {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.mongo_proxy.v2.MongoProxy";

  // The human readable prefix to use when emitting :ref:`statistics
  // <config_network_filters_mongo_proxy_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // The optional path to use for writing Mongo access logs. If not access log
  // path is specified no access logs will be written. Note that access log is
  // also gated :ref:`runtime <config_network_filters_mongo_proxy_runtime>`.
  string access_log = 2;

  // Inject a fixed delay before proxying a Mongo operation. Delays are
  // applied to the following MongoDB operations: Query, Insert, GetMore,
  // and KillCursors. Once an active delay is in progress, all incoming
  // data up until the timer event fires will be a part of the delay.
  common.fault.v3.FaultDelay delay = 3;

  // Flag to specify whether :ref:`dynamic metadata
  // <config_network_filters_mongo_proxy_dynamic_metadata>` should be emitted. Defaults to false.
  bool emit_dynamic_metadata = 4;

  // List of commands to emit metrics for. Defaults to "delete", "insert", and "update".
  // Note that metrics will not be emitted for "find" commands, since those are considered
  // queries, and metrics for those are emitted under a dedicated "query" namespace.
  repeated string commands = 5;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/wasm/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.wasm.v3;

import "envoy/extensions/wasm/v3/wasm.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.wasm.v3";
option java_outer_classname = "WasmProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/wasm/v3;wasmv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Wasm]
// [#extension: envoy.filters.network.wasm]
// Wasm :ref:`configuration overview <config_network_filters_wasm>`.

message Wasm {
  // General Plugin configuration.
  envoy.extensions.wasm.v3.PluginConfig config = 1;
}
syntax = "proto3";

package envoy.extensions.filters.network.zookeeper_proxy.v3;

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.zookeeper_proxy.v3";
option java_outer_classname = "ZookeeperProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/zookeeper_proxy/v3;zookeeper_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: ZooKeeper proxy]
// ZooKeeper Proxy :ref:`configuration overview <config_network_filters_zookeeper_proxy>`.
// [#extension: envoy.filters.network.zookeeper_proxy]

// [#next-free-field: 10]
message ZooKeeperProxy {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.zookeeper_proxy.v1alpha1.ZooKeeperProxy";

  // The human readable prefix to use when emitting :ref:`statistics
  // <config_network_filters_zookeeper_proxy_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // [#not-implemented-hide:] The optional path to use for writing ZooKeeper access logs.
  // If the access log field is empty, access logs will not be written.
  string access_log = 2;

  // Messages  requests, responses and events  that are bigger than this value will
  // be ignored. If it is not set, the default value is 1Mb.
  //
  // The value here should match the jute.maxbuffer property in your cluster configuration:
  //
  // https://zookeeper.apache.org/doc/r3.4.10/zookeeperAdmin.html#Unsafe+Options
  //
  // if that is set. If it isn't, ZooKeeper's default is also 1Mb.
  google.protobuf.UInt32Value max_packet_bytes = 3;

  // Whether to emit latency threshold metrics. If not set, it defaults to false.
  // If false, setting ``default_latency_threshold`` and ``latency_threshold_overrides`` will not have effect.
  bool enable_latency_threshold_metrics = 4;

  // The default latency threshold to decide the fast/slow responses and emit metrics (used for error budget calculation).
  //
  // https://sre.google/workbook/implementing-slos/
  //
  // If it is not set, the default value is 100 milliseconds.
  google.protobuf.Duration default_latency_threshold = 5
      [(validate.rules).duration = {gte {nanos: 1000000}}];

  // List of latency threshold overrides for opcodes.
  // If the threshold override of one opcode is not set, it will fallback to the default latency
  // threshold.
  // Specifying latency threshold overrides multiple times for one opcode is not allowed.
  repeated LatencyThresholdOverride latency_threshold_overrides = 6;

  // Whether to emit per opcode request bytes metrics. If not set, it defaults to false.
  bool enable_per_opcode_request_bytes_metrics = 7;

  // Whether to emit per opcode response bytes metrics. If not set, it defaults to false.
  bool enable_per_opcode_response_bytes_metrics = 8;

  // Whether to emit per opcode decoder error metrics. If not set, it defaults to false.
  bool enable_per_opcode_decoder_error_metrics = 9;
}

message LatencyThresholdOverride {
  enum Opcode {
    Connect = 0;
    Create = 1;
    Delete = 2;
    Exists = 3;
    GetData = 4;
    SetData = 5;
    GetAcl = 6;
    SetAcl = 7;
    GetChildren = 8;
    Sync = 9;
    Ping = 10;
    GetChildren2 = 11;
    Check = 12;
    Multi = 13;
    Create2 = 14;
    Reconfig = 15;
    CheckWatches = 16;
    RemoveWatches = 17;
    CreateContainer = 18;
    CreateTtl = 19;
    Close = 20;
    SetAuth = 21;
    SetWatches = 22;
    GetEphemerals = 23;
    GetAllChildrenNumber = 24;
    SetWatches2 = 25;
    AddWatch = 26;
  }

  // The ZooKeeper opcodes. Can be found as part of the ZooKeeper source code:
  //
  // https://github.com/apache/zookeeper/blob/master/zookeeper-server/src/main/java/org/apache/zookeeper/ZooDefs.java
  //
  Opcode opcode = 1 [(validate.rules).enum = {defined_only: true}];

  // The latency threshold override of certain opcode.
  google.protobuf.Duration threshold = 2 [(validate.rules).duration = {
    required: true
    gte {nanos: 1000000}
  }];
}
Protocol buffer definitions for the ZooKeeper proxy.
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.network.redis_proxy.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/sensitive.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.redis_proxy.v3";
option java_outer_classname = "RedisProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/redis_proxy/v3;redis_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Redis Proxy]
// Redis Proxy :ref:`configuration overview <config_network_filters_redis_proxy>`.
// [#extension: envoy.filters.network.redis_proxy]

// [#next-free-field: 10]
message RedisProxy {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.redis_proxy.v2.RedisProxy";

  // Redis connection pool settings.
  // [#next-free-field: 11]
  message ConnPoolSettings {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings";

    // ReadPolicy controls how Envoy routes read commands to Redis nodes. This is currently
    // supported for Redis Cluster. All ReadPolicy settings except MASTER may return stale data
    // because replication is asynchronous and requires some delay. You need to ensure that your
    // application can tolerate stale data.
    enum ReadPolicy {
      // Default mode. Read from the current primary node.
      MASTER = 0 [(udpa.annotations.enum_value_migrate).rename = "PRIMARY"];

      // Read from the primary, but if it is unavailable, read from replica nodes.
      PREFER_MASTER = 1 [(udpa.annotations.enum_value_migrate).rename = "PREFER_PRIMARY"];

      // Read from replica nodes. If multiple replica nodes are present within a shard, a random
      // node is selected. Healthy nodes have precedent over unhealthy nodes.
      REPLICA = 2;

      // Read from the replica nodes (similar to REPLICA), but if all replicas are unavailable (not
      // present or unhealthy), read from the primary.
      PREFER_REPLICA = 3;

      // Read from any node of the cluster. A random node is selected among the primary and
      // replicas, healthy nodes have precedent over unhealthy nodes.
      ANY = 4;
    }

    // Per-operation timeout in milliseconds. The timer starts when the first
    // command of a pipeline is written to the backend connection. Each response received from Redis
    // resets the timer since it signifies that the next command is being processed by the backend.
    // The only exception to this behavior is when a connection to a backend is not yet established.
    // In that case, the connect timeout on the cluster will govern the timeout until the connection
    // is ready.
    google.protobuf.Duration op_timeout = 1 [(validate.rules).duration = {required: true}];

    // Use hash tagging on every redis key to guarantee that keys with the same hash tag will be
    // forwarded to the same upstream. The hash key used for determining the upstream in a
    // consistent hash ring configuration will be computed from the hash tagged key instead of the
    // whole key. The algorithm used to compute the hash tag is identical to the `redis-cluster
    // implementation <https://redis.io/topics/cluster-spec#keys-hash-tags>`_.
    //
    // Examples:
    //
    // * '{user1000}.following' and '{user1000}.followers' **will** be sent to the same upstream
    // * '{user1000}.following' and '{user1001}.following' **might** be sent to the same upstream
    bool enable_hashtagging = 2;

    // Accept `moved and ask redirection
    // <https://redis.io/topics/cluster-spec#redirection-and-resharding>`_ errors from upstream
    // redis servers, and retry commands to the specified target server. The target server does not
    // need to be known to the cluster manager. If the command cannot be redirected, then the
    // original error is passed downstream unchanged. By default, this support is not enabled.
    bool enable_redirection = 3;

    // If ``enable_redirection`` is set to true this option configures the DNS cache that the
    // connection pool will use to resolve hostnames that are returned with MOVED and ASK responses.
    // If no configuration is provided, DNS lookups will not be performed (and thus the MOVED/ASK errors
    // will be propagated verbatim to the user).
    common.dynamic_forward_proxy.v3.DnsCacheConfig dns_cache_config = 9;

    // Maximum size of encoded request buffer before flush is triggered and encoded requests
    // are sent upstream. If this is unset, the buffer flushes whenever it receives data
    // and performs no batching.
    // This feature makes it possible for multiple clients to send requests to Envoy and have
    // them batched- for example if one is running several worker processes, each with its own
    // Redis connection. There is no benefit to using this with a single downstream process.
    // Recommended size (if enabled) is 1024 bytes.
    uint32 max_buffer_size_before_flush = 4;

    // The encoded request buffer is flushed N milliseconds after the first request has been
    // encoded, unless the buffer size has already exceeded ``max_buffer_size_before_flush``.
    // If ``max_buffer_size_before_flush`` is not set, this flush timer is not used. Otherwise,
    // the timer should be set according to the number of clients, overall request rate and
    // desired maximum latency for a single command. For example, if there are many requests
    // being batched together at a high rate, the buffer will likely be filled before the timer
    // fires. Alternatively, if the request rate is lower the buffer will not be filled as often
    // before the timer fires.
    // If ``max_buffer_size_before_flush`` is set, but ``buffer_flush_timeout`` is not, the latter
    // defaults to 3ms.
    google.protobuf.Duration buffer_flush_timeout = 5;

    // ``max_upstream_unknown_connections`` controls how many upstream connections to unknown hosts
    // can be created at any given time by any given worker thread (see ``enable_redirection`` for
    // more details). If the host is unknown and a connection cannot be created due to enforcing
    // this limit, then redirection will fail and the original redirection error will be passed
    // downstream unchanged. This limit defaults to 100.
    google.protobuf.UInt32Value max_upstream_unknown_connections = 6;

    // Enable per-command statistics per upstream cluster, in addition to the filter level aggregate
    // count. These commands are measured in microseconds.
    bool enable_command_stats = 8;

    // Read policy. The default is to read from the primary.
    ReadPolicy read_policy = 7 [(validate.rules).enum = {defined_only: true}];

    // Ops or connection timeout triggers reconnection to redis server which could result in reconnection
    // storm to busy redis server. This config is a protection to rate limit reconnection rate.
    // If not set, there will be no rate limiting on the reconnection.
    ConnectionRateLimit connection_rate_limit = 10;
  }

  message PrefixRoutes {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes";

    // [#next-free-field: 7]
    message Route {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route";

      // The router is capable of shadowing traffic from one cluster to another. The current
      // implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
      // respond before returning the response from the primary cluster. All normal statistics are
      // collected for the shadow cluster making this feature useful for testing.
      message RequestMirrorPolicy {
        option (udpa.annotations.versioning).previous_message_type =
            "envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route."
            "RequestMirrorPolicy";

        // Specifies the cluster that requests will be mirrored to. The cluster must
        // exist in the cluster manager configuration.
        string cluster = 1 [(validate.rules).string = {min_len: 1}];

        // If not specified or the runtime key is not present, all requests to the target cluster
        // will be mirrored.
        //
        // If specified, Envoy will lookup the runtime key to get the percentage of requests to the
        // mirror.
        config.core.v3.RuntimeFractionalPercent runtime_fraction = 2;

        // Set this to TRUE to only mirror write commands, this is effectively replicating the
        // writes in a "fire and forget" manner.
        bool exclude_read_commands = 3;
      }

      // ReadCommandPolicy specifies that Envoy should route read commands to another cluster.
      message ReadCommandPolicy {
        string cluster = 1 [(validate.rules).string = {min_len: 1}];
      }

      // String prefix that must match the beginning of the keys. Envoy will always favor the
      // longest match.
      string prefix = 1 [(validate.rules).string = {max_bytes: 1000}];

      // Indicates if the prefix needs to be removed from the key when forwarded.
      bool remove_prefix = 2;

      // Upstream cluster to forward the command to.
      string cluster = 3 [(validate.rules).string = {min_len: 1}];

      // Indicates that the route has a request mirroring policy.
      repeated RequestMirrorPolicy request_mirror_policy = 4;

      // Indicates how redis key should be formatted. To substitute redis key into the formatting
      // expression, use %KEY% as a string replacement command.
      string key_formatter = 5;

      // Indicates that the route has a read command policy
      ReadCommandPolicy read_command_policy = 6;
    }

    reserved 3;

    reserved "catch_all_cluster";

    // List of prefix routes.
    repeated Route routes = 1;

    // Indicates that prefix matching should be case insensitive.
    bool case_insensitive = 2;

    // Optional catch-all route to forward commands that doesn't match any of the routes. The
    // catch-all route becomes required when no routes are specified.
    Route catch_all_route = 4;
  }

  // RedisFault defines faults used for fault injection.
  message RedisFault {
    enum RedisFaultType {
      // Delays requests. This is the base fault; other faults can have delays added.
      DELAY = 0;

      // Returns errors on requests.
      ERROR = 1;
    }

    // Fault type.
    RedisFaultType fault_type = 1 [(validate.rules).enum = {defined_only: true}];

    // Percentage of requests fault applies to.
    config.core.v3.RuntimeFractionalPercent fault_enabled = 2
        [(validate.rules).message = {required: true}];

    // Delay for all faults. If not set, defaults to zero
    google.protobuf.Duration delay = 3;

    // Commands fault is restricted to, if any. If not set, fault applies to all commands
    // other than auth and ping (due to special handling of those commands in Envoy).
    repeated string commands = 4;
  }

  // Configuration to limit reconnection rate to redis server to protect redis server
  // from client reconnection storm.
  message ConnectionRateLimit {
    // Reconnection rate per sec. Rate limiting is implemented with TokenBucket.
    uint32 connection_rate_limit_per_sec = 1 [(validate.rules).uint32 = {gt: 0}];
  }

  reserved 2;

  reserved "cluster";

  // The prefix to use when emitting :ref:`statistics <config_network_filters_redis_proxy_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // Network settings for the connection pool to the upstream clusters.
  ConnPoolSettings settings = 3 [(validate.rules).message = {required: true}];

  // Indicates that latency stat should be computed in microseconds. By default it is computed in
  // milliseconds. This does not apply to upstream command stats currently.
  bool latency_in_micros = 4;

  // List of **unique** prefixes used to separate keys from different workloads to different
  // clusters. Envoy will always favor the longest match first in case of overlap. A catch-all
  // cluster can be used to forward commands when there is no match. Time complexity of the
  // lookups are in O(min(longest key prefix, key length)).
  //
  // Example:
  //
  // .. code-block:: yaml
  //
  //    prefix_routes:
  //      routes:
  //        - prefix: "ab"
  //          cluster: "cluster_a"
  //        - prefix: "abc"
  //          cluster: "cluster_b"
  //
  // When using the above routes, the following prefixes would be sent to:
  //
  // * ``get abc:users`` would retrieve the key 'abc:users' from cluster_b.
  // * ``get ab:users`` would retrieve the key 'ab:users' from cluster_a.
  // * ``get z:users`` would return a NoUpstreamHost error. A :ref:`catch-all
  //   route<envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.catch_all_route>`
  //   would have retrieved the key from that cluster instead.
  //
  // See the :ref:`configuration section
  // <arch_overview_redis_configuration>` of the architecture overview for recommendations on
  // configuring the backing clusters.
  PrefixRoutes prefix_routes = 5;

  // Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
  // AUTH command <https://redis.io/commands/auth>`_ with this password before enabling any other
  // command. If an AUTH command's password matches this password, an "OK" response will be returned
  // to the client. If the AUTH command password does not match this password, then an "ERR invalid
  // password" error will be returned. If any other command is received before AUTH when this
  // password is set, then a "NOAUTH Authentication required." error response will be sent to the
  // client. If an AUTH command is received when the password is not set, then an "ERR Client sent
  // AUTH, but no password is set" error will be returned.
  //
  // .. attention::
  //   This field is deprecated. Use :ref:`downstream_auth_passwords
  //   <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.downstream_auth_passwords>`.
  config.core.v3.DataSource downstream_auth_password = 6 [
    deprecated = true,
    (udpa.annotations.sensitive) = true,
    (envoy.annotations.deprecated_at_minor_version) = "3.0"
  ];

  // Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
  // AUTH command <https://redis.io/commands/auth>`_ with one of these passwords before enabling any other
  // command. If an AUTH command's password matches one of these passwords, an "OK" response will be returned
  // to the client. If the AUTH command password does not match, then an "ERR invalid
  // password" error will be returned. If any other command is received before AUTH when the
  // password(s) are set, then a "NOAUTH Authentication required." error response will be sent to the
  // client. If an AUTH command is received when the password is not set, then an "ERR Client sent
  // AUTH, but no password is set" error will be returned.
  repeated config.core.v3.DataSource downstream_auth_passwords = 9
      [(udpa.annotations.sensitive) = true];

  // List of faults to inject. Faults currently come in two flavors:
  // - Delay, which delays a request.
  // - Error, which responds to a request with an error. Errors can also have delays attached.
  //
  // Example:
  //
  // .. code-block:: yaml
  //
  //    faults:
  //    - fault_type: ERROR
  //      fault_enabled:
  //        default_value:
  //          numerator: 10
  //          denominator: HUNDRED
  //        runtime_key: "bogus_key"
  //        commands:
  //        - GET
  //      - fault_type: DELAY
  //        fault_enabled:
  //          default_value:
  //            numerator: 10
  //            denominator: HUNDRED
  //          runtime_key: "bogus_key"
  //        delay: 2s
  //
  // See the :ref:`fault injection section
  // <config_network_filters_redis_proxy_fault_injection>` for more information on how to configure this.
  repeated RedisFault faults = 8;

  // If a username is provided an ACL style AUTH command will be required with a username and password.
  // Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
  // AUTH command <https://redis.io/commands/auth>`_ with this username and the ``downstream_auth_password``
  // before enabling any other command. If an AUTH command's username and password matches this username
  // and the ``downstream_auth_password`` , an "OK" response will be returned to the client. If the AUTH
  // command username or password does not match this username or the ``downstream_auth_password``, then an
  // "WRONGPASS invalid username-password pair" error will be returned. If any other command is received before AUTH when this
  // password is set, then a "NOAUTH Authentication required." error response will be sent to the
  // client. If an AUTH command is received when the password is not set, then an "ERR Client sent
  // AUTH, but no ACL is set" error will be returned.
  config.core.v3.DataSource downstream_auth_username = 7 [(udpa.annotations.sensitive) = true];
}

// RedisProtocolOptions specifies Redis upstream protocol options. This object is used in
// :ref:`typed_extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`,
// keyed by the name ``envoy.filters.network.redis_proxy``.
message RedisProtocolOptions {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.redis_proxy.v2.RedisProtocolOptions";

  // Upstream server password as defined by the ``requirepass`` directive
  // `<https://redis.io/topics/config>`_ in the server's configuration file.
  config.core.v3.DataSource auth_password = 1 [(udpa.annotations.sensitive) = true];

  // Upstream server username as defined by the ``user`` directive
  // `<https://redis.io/topics/acl>`_ in the server's configuration file.
  config.core.v3.DataSource auth_username = 2 [(udpa.annotations.sensitive) = true];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/extensions/common/dynamic_forward_proxy/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.http_connection_manager.v3;

import "envoy/config/accesslog/v3/accesslog.proto";
import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/config_source.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/protocol.proto";
import "envoy/config/core/v3/substitution_format_string.proto";
import "envoy/config/route/v3/route.proto";
import "envoy/config/route/v3/scoped_route.proto";
import "envoy/config/trace/v3/http_tracer.proto";
import "envoy/type/http/v3/path_transformation.proto";
import "envoy/type/tracing/v3/custom_tag.proto";
import "envoy/type/v3/percent.proto";

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/security.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3";
option java_outer_classname = "HttpConnectionManagerProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3;http_connection_managerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP connection manager]
// HTTP connection manager :ref:`configuration overview <config_http_conn_man>`.
// [#extension: envoy.filters.network.http_connection_manager]

// [#next-free-field: 57]
message HttpConnectionManager {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager";

  enum CodecType {
    // For every new connection, the connection manager will determine which
    // codec to use. This mode supports both ALPN for TLS listeners as well as
    // protocol inference for plaintext listeners. If ALPN data is available, it
    // is preferred, otherwise protocol inference is used. In almost all cases,
    // this is the right option to choose for this setting.
    AUTO = 0;

    // The connection manager will assume that the client is speaking HTTP/1.1.
    HTTP1 = 1;

    // The connection manager will assume that the client is speaking HTTP/2
    // (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
    // Prior knowledge is allowed).
    HTTP2 = 2;

    // [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
    // caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
    // to distinguish HTTP1 and HTTP2 traffic.
    HTTP3 = 3;
  }

  enum ServerHeaderTransformation {
    // Overwrite any Server header with the contents of server_name.
    OVERWRITE = 0;

    // If no Server header is present, append Server server_name
    // If a Server header is present, pass it through.
    APPEND_IF_ABSENT = 1;

    // Pass through the value of the server header, and do not append a header
    // if none is present.
    PASS_THROUGH = 2;
  }

  // How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
  // header.
  enum ForwardClientCertDetails {
    // Do not send the XFCC header to the next hop. This is the default value.
    SANITIZE = 0;

    // When the client connection is mTLS (Mutual TLS), forward the XFCC header
    // in the request.
    FORWARD_ONLY = 1;

    // When the client connection is mTLS, append the client certificate
    // information to the requests XFCC header and forward it.
    APPEND_FORWARD = 2;

    // When the client connection is mTLS, reset the XFCC header with the client
    // certificate information and send it to the next hop.
    SANITIZE_SET = 3;

    // Always forward the XFCC header in the request, regardless of whether the
    // client connection is mTLS.
    ALWAYS_FORWARD_ONLY = 4;
  }

  // Determines the action for request that contain %2F, %2f, %5C or %5c sequences in the URI path.
  // This operation occurs before URL normalization and the merge slashes transformations if they were enabled.
  enum PathWithEscapedSlashesAction {
    // Default behavior specific to implementation (i.e. Envoy) of this configuration option.
    // Envoy, by default, takes the KEEP_UNCHANGED action.
    // NOTE: the implementation may change the default behavior at-will.
    IMPLEMENTATION_SPECIFIC_DEFAULT = 0;

    // Keep escaped slashes.
    KEEP_UNCHANGED = 1;

    // Reject client request with the 400 status. gRPC requests will be rejected with the INTERNAL (13) error code.
    // The "httpN.downstream_rq_failed_path_normalization" counter is incremented for each rejected request.
    REJECT_REQUEST = 2;

    // Unescape %2F and %5C sequences and redirect request to the new path if these sequences were present.
    // Redirect occurs after path normalization and merge slashes transformations if they were configured.
    // NOTE: gRPC requests will be rejected with the INTERNAL (13) error code.
    // This option minimizes possibility of path confusion exploits by forcing request with unescaped slashes to
    // traverse all parties: downstream client, intermediate proxies, Envoy and upstream server.
    // The "httpN.downstream_rq_redirected_with_normalized_path" counter is incremented for each
    // redirected request.
    UNESCAPE_AND_REDIRECT = 3;

    // Unescape %2F and %5C sequences.
    // Note: this option should not be enabled if intermediaries perform path based access control as
    // it may lead to path confusion vulnerabilities.
    UNESCAPE_AND_FORWARD = 4;
  }

  // [#next-free-field: 11]
  message Tracing {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing";

    enum OperationName {
      // The HTTP listener is used for ingress/incoming requests.
      INGRESS = 0;

      // The HTTP listener is used for egress/outgoing requests.
      EGRESS = 1;
    }

    reserved 1, 2;

    reserved "operation_name", "request_headers_for_tags";

    // Target percentage of requests managed by this HTTP connection manager that will be force
    // traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
    // header is set. This field is a direct analog for the runtime variable
    // 'tracing.client_enabled' in the :ref:`HTTP Connection Manager
    // <config_http_conn_man_runtime>`.
    // Default: 100%
    type.v3.Percent client_sampling = 3;

    // Target percentage of requests managed by this HTTP connection manager that will be randomly
    // selected for trace generation, if not requested by the client or not forced. This field is
    // a direct analog for the runtime variable 'tracing.random_sampling' in the
    // :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
    // Default: 100%
    type.v3.Percent random_sampling = 4;

    // Target percentage of requests managed by this HTTP connection manager that will be traced
    // after all other sampling checks have been applied (client-directed, force tracing, random
    // sampling). This field functions as an upper limit on the total configured sampling rate. For
    // instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
    // of client requests with the appropriate headers to be force traced. This field is a direct
    // analog for the runtime variable 'tracing.global_enabled' in the
    // :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
    // Default: 100%
    type.v3.Percent overall_sampling = 5;

    // Whether to annotate spans with additional data. If true, spans will include logs for stream
    // events.
    bool verbose = 6;

    // Maximum length of the request path to extract and include in the HttpUrl tag. Used to
    // truncate lengthy request paths to meet the needs of a tracing backend.
    // Default: 256
    google.protobuf.UInt32Value max_path_tag_length = 7;

    // A list of custom tags with unique tag name to create tags for the active span.
    repeated type.tracing.v3.CustomTag custom_tags = 8;

    // Configuration for an external tracing provider.
    // If not specified, no tracing will be performed.
    //
    // .. attention::
    //   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
    //   in Envoy lifetime.
    //   Any attempts to reconfigure it or to use different configurations for different HCM filters
    //   will be rejected.
    //   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
    //   on OpenCensus side.
    config.trace.v3.Tracing.Http provider = 9;

    // Create separate tracing span for each upstream request if true. And if this flag is set to true,
    // the tracing provider will assume that Envoy will be independent hop in the trace chain and may
    // set span type to client or server based on this flag.
    // This will deprecate the
    // :ref:`start_child_span <envoy_v3_api_field_extensions.filters.http.router.v3.Router.start_child_span>`
    // in the router.
    //
    // Users should set appropriate value based on their tracing provider and actual scenario:
    //
    // * If Envoy is used as sidecar and users want to make the sidecar and its application as only one
    //   hop in the trace chain, this flag should be set to false. And please also make sure the
    //   :ref:`start_child_span <envoy_v3_api_field_extensions.filters.http.router.v3.Router.start_child_span>`
    //   in the router is not set to true.
    // * If Envoy is used as gateway or independent proxy, or users want to make the sidecar and its
    //   application as different hops in the trace chain, this flag should be set to true.
    // * If tracing provider that has explicit requirements on span creation (like SkyWalking),
    //   this flag should be set to true.
    //
    // The default value is false for now for backward compatibility.
    google.protobuf.BoolValue spawn_upstream_span = 10;
  }

  message InternalAddressConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager."
        "InternalAddressConfig";

    // Whether unix socket addresses should be considered internal.
    bool unix_sockets = 1;

    // List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
    // IP addresses will be considered internal.
    repeated config.core.v3.CidrRange cidr_ranges = 2;
  }

  // [#next-free-field: 7]
  message SetCurrentClientCertDetails {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager."
        "SetCurrentClientCertDetails";

    reserved 2;

    // Whether to forward the subject of the client cert. Defaults to false.
    google.protobuf.BoolValue subject = 1;

    // Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
    // XFCC header comma separated from other values with the value Cert="PEM".
    // Defaults to false.
    bool cert = 3;

    // Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
    // format. This will appear in the XFCC header comma separated from other values with the value
    // Chain="PEM".
    // Defaults to false.
    bool chain = 6;

    // Whether to forward the DNS type Subject Alternative Names of the client cert.
    // Defaults to false.
    bool dns = 4;

    // Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
    // false.
    bool uri = 5;
  }

  // The configuration for HTTP upgrades.
  // For each upgrade type desired, an UpgradeConfig must be added.
  //
  // .. warning::
  //
  //    The current implementation of upgrade headers does not handle
  //    multi-valued upgrade headers. Support for multi-valued headers may be
  //    added in the future if needed.
  //
  // .. warning::
  //    The current implementation of upgrade headers does not work with HTTP/2
  //    upstreams.
  message UpgradeConfig {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager."
        "UpgradeConfig";

    // The case-insensitive name of this upgrade, e.g. "websocket".
    // For each upgrade type present in upgrade_configs, requests with
    // Upgrade: [upgrade_type]
    // will be proxied upstream.
    string upgrade_type = 1;

    // If present, this represents the filter chain which will be created for
    // this type of upgrade. If no filters are present, the filter chain for
    // HTTP connections will be used for this upgrade type.
    repeated HttpFilter filters = 2;

    // Determines if upgrades are enabled or disabled by default. Defaults to true.
    // This can be overridden on a per-route basis with :ref:`cluster
    // <envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs>` as documented in the
    // :ref:`upgrade documentation <arch_overview_upgrades>`.
    google.protobuf.BoolValue enabled = 3;
  }

  // [#not-implemented-hide:] Transformations that apply to path headers. Transformations are applied
  // before any processing of requests by HTTP filters, routing, and matching. Only the normalized
  // path will be visible internally if a transformation is enabled. Any path rewrites that the
  // router performs (e.g. :ref:`regex_rewrite
  // <envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>` or :ref:`prefix_rewrite
  // <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`) will apply to the ``:path`` header
  // destined for the upstream.
  //
  // Note: access logging and tracing will show the original ``:path`` header.
  message PathNormalizationOptions {
    // [#not-implemented-hide:] Normalization applies internally before any processing of requests by
    // HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
    // to :ref:`NormalizePathRFC3986
    // <envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986>`. When not
    // specified, this value may be overridden by the runtime variable
    // :ref:`http_connection_manager.normalize_path<config_http_conn_man_runtime_normalize_path>`.
    // Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
    // normalization due to disallowed characters.)
    type.http.v3.PathTransformation forwarding_transformation = 1;

    // [#not-implemented-hide:] Normalization only applies internally before any processing of
    // requests by HTTP filters, routing, and matching. These will be applied after full
    // transformation is applied. The ``:path`` header before this transformation will be restored in
    // the router filter and sent upstream unless it was mutated by a filter. Defaults to no
    // transformations.
    // Multiple actions can be applied in the same Transformation, forming a sequential
    // pipeline. The transformations will be performed in the order that they appear. Envoy will
    // respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
    // normalization due to disallowed characters.)
    type.http.v3.PathTransformation http_filter_transformation = 2;
  }

  // Configures the manner in which the Proxy-Status HTTP response header is
  // populated.
  //
  // See the [Proxy-Status
  // RFC](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-proxy-status-08).
  // [#comment:TODO: Update this with the non-draft URL when finalized.]
  //
  // The Proxy-Status header is a string of the form:
  //
  //   "<server_name>; error=<error_type>; details=<details>"
  // [#next-free-field: 7]
  message ProxyStatusConfig {
    // If true, the details field of the Proxy-Status header is not populated with stream_info.response_code_details.
    // This value defaults to ``false``, i.e. the ``details`` field is populated by default.
    bool remove_details = 1;

    // If true, the details field of the Proxy-Status header will not contain
    // connection termination details. This value defaults to ``false``, i.e. the
    // ``details`` field will contain connection termination details by default.
    bool remove_connection_termination_details = 2;

    // If true, the details field of the Proxy-Status header will not contain an
    // enumeration of the Envoy ResponseFlags. This value defaults to ``false``,
    // i.e. the ``details`` field will contain a list of ResponseFlags by default.
    bool remove_response_flags = 3;

    // If true, overwrites the existing Status header with the response code
    // recommended by the Proxy-Status spec.
    // This value defaults to ``false``, i.e. the HTTP response code is not
    // overwritten.
    bool set_recommended_response_code = 4;

    // The name of the proxy as it appears at the start of the Proxy-Status
    // header.
    //
    // If neither of these values are set, this value defaults to ``server_name``,
    // which itself defaults to "envoy".
    oneof proxy_name {
      // If ``use_node_id`` is set, Proxy-Status headers will use the Envoy's node
      // ID as the name of the proxy.
      bool use_node_id = 5;

      // If ``literal_proxy_name`` is set, Proxy-Status headers will use this
      // value as the name of the proxy.
      string literal_proxy_name = 6;
    }
  }

  message HcmAccessLogOptions {
    // The interval to flush the above access logs. By default, the HCM will flush exactly one access log
    // on stream close, when the HTTP request is complete. If this field is set, the HCM will flush access
    // logs periodically at the specified interval. This is especially useful in the case of long-lived
    // requests, such as CONNECT and Websockets. Final access logs can be detected via the
    // ``requestComplete()`` method of ``StreamInfo`` in access log filters, or through the ``%DURATION%`` substitution
    // string.
    // The interval must be at least 1 millisecond.
    google.protobuf.Duration access_log_flush_interval = 1
        [(validate.rules).duration = {gte {nanos: 1000000}}];

    // If set to true, HCM will flush an access log when a new HTTP request is received, after request
    // headers have been evaluated, before iterating through the HTTP filter chain.
    // This log record, if enabled, does not depend on periodic log records or request completion log.
    // Details related to upstream cluster, such as upstream host, will not be available for this log.
    bool flush_access_log_on_new_request = 2;

    // If true, the HCM will flush an access log when a tunnel is successfully established. For example,
    // this could be when an upstream has successfully returned 101 Switching Protocols, or when the proxy
    // has returned 200 to a CONNECT request.
    bool flush_log_on_tunnel_successfully_established = 3;
  }

  reserved 27, 11;

  reserved "idle_timeout";

  // Supplies the type of codec that the connection manager should use.
  CodecType codec_type = 1 [(validate.rules).enum = {defined_only: true}];

  // The human readable prefix to use when emitting statistics for the
  // connection manager. See the :ref:`statistics documentation <config_http_conn_man_stats>` for
  // more information.
  string stat_prefix = 2 [(validate.rules).string = {min_len: 1}];

  oneof route_specifier {
    option (validate.required) = true;

    // The connection managers route table will be dynamically loaded via the RDS API.
    Rds rds = 3;

    // The route table for the connection manager is static and is specified in this property.
    config.route.v3.RouteConfiguration route_config = 4;

    // A route table will be dynamically assigned to each request based on request attributes
    // (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
    // specified in this message.
    ScopedRoutes scoped_routes = 31;
  }

  // A list of individual HTTP filters that make up the filter chain for
  // requests made to the connection manager. :ref:`Order matters <arch_overview_http_filters_ordering>`
  // as the filters are processed sequentially as request events happen.
  repeated HttpFilter http_filters = 5;

  // Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
  // and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
  // documentation for more information. Defaults to false.
  google.protobuf.BoolValue add_user_agent = 6;

  // Presence of the object defines whether the connection manager
  // emits :ref:`tracing <arch_overview_tracing>` data to the :ref:`configured tracing provider
  // <envoy_v3_api_msg_config.trace.v3.Tracing>`.
  Tracing tracing = 7;

  // Additional settings for HTTP requests handled by the connection manager. These will be
  // applicable to both HTTP1 and HTTP2 requests.
  config.core.v3.HttpProtocolOptions common_http_protocol_options = 35
      [(udpa.annotations.security).configure_for_untrusted_downstream = true];

  // Additional HTTP/1 settings that are passed to the HTTP/1 codec.
  // [#comment:TODO: The following fields are ignored when the
  // :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
  // is present:
  // 1. :ref:`allow_chunked_length <envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length>`]
  config.core.v3.Http1ProtocolOptions http_protocol_options = 8;

  // Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
  config.core.v3.Http2ProtocolOptions http2_protocol_options = 9
      [(udpa.annotations.security).configure_for_untrusted_downstream = true];

  // Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
  // [#not-implemented-hide:]
  config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;

  // An optional override that the connection manager will write to the server
  // header in responses. If not set, the default is ``envoy``.
  string server_name = 10
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];

  // Defines the action to be applied to the Server header on the response path.
  // By default, Envoy will overwrite the header with the value specified in
  // server_name.
  ServerHeaderTransformation server_header_transformation = 34
      [(validate.rules).enum = {defined_only: true}];

  // Allows for explicit transformation of the :scheme header on the request path.
  // If not set, Envoy's default :ref:`scheme  <config_http_conn_man_headers_scheme>`
  // handling applies.
  config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;

  // The maximum request headers size for incoming connections.
  // If unconfigured, the default max request headers allowed is 60 KiB.
  // Requests that exceed this limit will receive a 431 response.
  google.protobuf.UInt32Value max_request_headers_kb = 29
      [(validate.rules).uint32 = {lte: 8192 gt: 0}];

  // The stream idle timeout for connections managed by the connection manager.
  // If not specified, this defaults to 5 minutes. The default value was selected
  // so as not to interfere with any smaller configured timeouts that may have
  // existed in configurations prior to the introduction of this feature, while
  // introducing robustness to TCP connections that terminate without a FIN.
  //
  // This idle timeout applies to new streams and is overridable by the
  // :ref:`route-level idle_timeout
  // <envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout>`. Even on a stream in
  // which the override applies, prior to receipt of the initial request
  // headers, the :ref:`stream_idle_timeout
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
  // applies. Each time an encode/decode event for headers or data is processed
  // for the stream, the timer will be reset. If the timeout fires, the stream
  // is terminated with a 408 Request Timeout error code if no upstream response
  // header has been received, otherwise a stream reset occurs.
  //
  // This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
  // window to write any remaining stream data once the entirety of stream data (local end stream is
  // true) has been buffered pending available window. In other words, this timeout defends against
  // a peer that does not release enough window to completely write the stream, even though all
  // data has been proxied within available flow control windows. If the timeout is hit in this
  // case, the :ref:`tx_flush_timeout <config_http_conn_man_stats_per_codec>` counter will be
  // incremented. Note that :ref:`max_stream_duration
  // <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration>` does not apply to
  // this corner case.
  //
  // If the :ref:`overload action <config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
  // is configured, this timeout is scaled according to the value for
  // :ref:`HTTP_DOWNSTREAM_STREAM_IDLE <envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE>`.
  //
  // Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
  // to the granularity of events presented to the connection manager. For example, while receiving
  // very large request headers, it may be the case that there is traffic regularly arriving on the
  // wire while the connection manage is only able to observe the end-of-headers event, hence the
  // stream may still idle timeout.
  //
  // A value of 0 will completely disable the connection manager stream idle
  // timeout, although per-route idle timeout overrides will continue to apply.
  google.protobuf.Duration stream_idle_timeout = 24
      [(udpa.annotations.security).configure_for_untrusted_downstream = true];

  // The amount of time that Envoy will wait for the entire request to be received.
  // The timer is activated when the request is initiated, and is disarmed when the last byte of the
  // request is sent upstream (i.e. all decoding filters have processed the request), OR when the
  // response is initiated. If not specified or set to 0, this timeout is disabled.
  google.protobuf.Duration request_timeout = 28
      [(udpa.annotations.security).configure_for_untrusted_downstream = true];

  // The amount of time that Envoy will wait for the request headers to be received. The timer is
  // activated when the first byte of the headers is received, and is disarmed when the last byte of
  // the headers has been received. If not specified or set to 0, this timeout is disabled.
  google.protobuf.Duration request_headers_timeout = 41 [
    (validate.rules).duration = {gte {}},
    (udpa.annotations.security).configure_for_untrusted_downstream = true
  ];

  // The time that Envoy will wait between sending an HTTP/2 shutdown
  // notification (GOAWAY frame with max stream ID) and a final GOAWAY frame.
  // This is used so that Envoy provides a grace period for new streams that
  // race with the final GOAWAY frame. During this grace period, Envoy will
  // continue to accept new streams. After the grace period, a final GOAWAY
  // frame is sent and Envoy will start refusing new streams. Draining occurs
  // both when a connection hits the idle timeout or during general server
  // draining. The default grace period is 5000 milliseconds (5 seconds) if this
  // option is not specified.
  google.protobuf.Duration drain_timeout = 12;

  // The delayed close timeout is for downstream connections managed by the HTTP connection manager.
  // It is defined as a grace period after connection close processing has been locally initiated
  // during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
  // from the downstream connection) prior to Envoy closing the socket associated with that
  // connection.
  // NOTE: This timeout is enforced even when the socket associated with the downstream connection
  // is pending a flush of the write buffer. However, any progress made writing data to the socket
  // will restart the timer associated with this timeout. This means that the total grace period for
  // a socket in this state will be
  // <total_time_waiting_for_write_buffer_flushes>+<delayed_close_timeout>.
  //
  // Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
  // sequence mitigates a race condition that exists when downstream clients do not drain/process
  // data in a connection's receive buffer after a remote close has been detected via a socket
  // write(). This race leads to such clients failing to process the response code sent by Envoy,
  // which could result in erroneous downstream processing.
  //
  // If the timeout triggers, Envoy will close the connection's socket.
  //
  // The default timeout is 1000 ms if this option is not specified.
  //
  // .. NOTE::
  //    To be useful in avoiding the race condition described above, this timeout must be set
  //    to *at least* <max round trip time expected between clients and Envoy>+<100ms to account for
  //    a reasonable "worst" case processing time for a full iteration of Envoy's event loop>.
  //
  // .. WARNING::
  //    A value of 0 will completely disable delayed close processing. When disabled, the downstream
  //    connection's socket will be closed immediately after the write flush is completed or will
  //    never close if the write flush does not complete.
  google.protobuf.Duration delayed_close_timeout = 26;

  // Configuration for :ref:`HTTP access logs <arch_overview_access_logs>`
  // emitted by the connection manager.
  repeated config.accesslog.v3.AccessLog access_log = 13;

  // .. attention::
  // This field is deprecated in favor of
  // :ref:`access_log_flush_interval
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.access_log_flush_interval>`.
  // Note that if both this field and :ref:`access_log_flush_interval
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.access_log_flush_interval>`
  // are specified, the former (deprecated field) is ignored.
  google.protobuf.Duration access_log_flush_interval = 54 [
    deprecated = true,
    (validate.rules).duration = {gte {nanos: 1000000}},
    (envoy.annotations.deprecated_at_minor_version) = "3.0"
  ];

  // .. attention::
  // This field is deprecated in favor of
  // :ref:`flush_access_log_on_new_request
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.flush_access_log_on_new_request>`.
  // Note that if both this field and :ref:`flush_access_log_on_new_request
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.flush_access_log_on_new_request>`
  // are specified, the former (deprecated field) is ignored.
  bool flush_access_log_on_new_request = 55
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Additional access log options for HTTP connection manager.
  HcmAccessLogOptions access_log_options = 56;

  // If set to true, the connection manager will use the real remote address
  // of the client connection when determining internal versus external origin and manipulating
  // various headers. If set to false or absent, the connection manager will use the
  // :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
  // :ref:`config_http_conn_man_headers_x-forwarded-for`,
  // :ref:`config_http_conn_man_headers_x-envoy-internal`, and
  // :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
  google.protobuf.BoolValue use_remote_address = 14
      [(udpa.annotations.security).configure_for_untrusted_downstream = true];

  // The number of additional ingress proxy hops from the right side of the
  // :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
  // determining the origin client's IP address. The default is zero if this option
  // is not specified. See the documentation for
  // :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
  uint32 xff_num_trusted_hops = 19;

  // The configuration for the original IP detection extensions.
  //
  // When configured the extensions will be called along with the request headers
  // and information about the downstream connection, such as the directly connected address.
  // Each extension will then use these parameters to decide the request's effective remote address.
  // If an extension fails to detect the original IP address and isn't configured to reject
  // the request, the HCM will try the remaining extensions until one succeeds or rejects
  // the request. If the request isn't rejected nor any extension succeeds, the HCM will
  // fallback to using the remote address.
  //
  // .. WARNING::
  //    Extensions cannot be used in conjunction with :ref:`use_remote_address
  //    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
  //    nor :ref:`xff_num_trusted_hops
  //    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops>`.
  //
  // [#extension-category: envoy.http.original_ip_detection]
  repeated config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;

  // The configuration for the early header mutation extensions.
  //
  // When configured the extensions will be called before any routing, tracing, or any filter processing.
  // Each extension will be applied in the order they are configured.
  // If the same header is mutated by multiple extensions, then the last extension will win.
  //
  // [#extension-category: envoy.http.early_header_mutation]
  repeated config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;

  // Configures what network addresses are considered internal for stats and header sanitation
  // purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
  // See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
  // information about internal/external addresses.
  InternalAddressConfig internal_address_config = 25;

  // If set, Envoy will not append the remote address to the
  // :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
  // conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
  // has mutated the request headers. While :ref:`use_remote_address
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
  // will also suppress XFF addition, it has consequences for logging and other
  // Envoy uses of the remote address, so ``skip_xff_append`` should be used
  // when only an elision of XFF addition is intended.
  bool skip_xff_append = 21;

  // Via header value to append to request and response headers. If this is
  // empty, no via header will be appended.
  string via = 22 [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];

  // Whether the connection manager will generate the :ref:`x-request-id
  // <config_http_conn_man_headers_x-request-id>` header if it does not exist. This defaults to
  // true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
  // is not desired it can be disabled.
  google.protobuf.BoolValue generate_request_id = 15;

  // Whether the connection manager will keep the :ref:`x-request-id
  // <config_http_conn_man_headers_x-request-id>` header if passed for a request that is edge
  // (Edge request is the request from external clients to front Envoy) and not reset it, which
  // is the current Envoy behaviour. This defaults to false.
  bool preserve_external_request_id = 32;

  // If set, Envoy will always set :ref:`x-request-id <config_http_conn_man_headers_x-request-id>` header in response.
  // If this is false or not set, the request ID is returned in responses only if tracing is forced using
  // :ref:`x-envoy-force-trace <config_http_conn_man_headers_x-envoy-force-trace>` header.
  bool always_set_request_id_in_response = 37;

  // How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
  // header.
  ForwardClientCertDetails forward_client_cert_details = 16
      [(validate.rules).enum = {defined_only: true}];

  // This field is valid only when :ref:`forward_client_cert_details
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details>`
  // is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
  // the client certificate to be forwarded. Note that in the
  // :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
  // ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
  // value.
  SetCurrentClientCertDetails set_current_client_cert_details = 17;

  // If proxy_100_continue is true, Envoy will proxy incoming "Expect:
  // 100-continue" headers upstream, and forward "100 Continue" responses
  // downstream. If this is false or not set, Envoy will instead strip the
  // "Expect: 100-continue" header, and send a "100 Continue" response itself.
  bool proxy_100_continue = 18;

  // If
  // :ref:`use_remote_address
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
  // is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
  // an IPv4 address, the address will be mapped to IPv6 before it is appended to ``x-forwarded-for``.
  // This is useful for testing compatibility of upstream services that parse the header value. For
  // example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
  // <https://tools.ietf.org/html/rfc4291#section-2.5.5.2>`_ for details. This will also affect the
  // :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
  // :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
  // <config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6>` for runtime
  // control.
  // [#not-implemented-hide:]
  bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = 20;

  repeated UpgradeConfig upgrade_configs = 23;

  // Should paths be normalized according to RFC 3986 before any processing of
  // requests by HTTP filters or routing? This affects the upstream ``:path`` header
  // as well. For paths that fail this check, Envoy will respond with 400 to
  // paths that are malformed. This defaults to false currently but will default
  // true in the future. When not specified, this value may be overridden by the
  // runtime variable
  // :ref:`http_connection_manager.normalize_path<config_http_conn_man_runtime_normalize_path>`.
  // See `Normalization and Comparison <https://tools.ietf.org/html/rfc3986#section-6>`_
  // for details of normalization.
  // Note that Envoy does not perform
  // `case normalization <https://tools.ietf.org/html/rfc3986#section-6.2.2.1>`_
  // [#comment:TODO: This field is ignored when the
  // :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
  // is present.]
  google.protobuf.BoolValue normalize_path = 30;

  // Determines if adjacent slashes in the path are merged into one before any processing of
  // requests by HTTP filters or routing. This affects the upstream ``:path`` header as well. Without
  // setting this option, incoming requests with path ``//dir///file`` will not match against route
  // with ``prefix`` match set to ``/dir``. Defaults to ``false``. Note that slash merging is not part of
  // `HTTP spec <https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
  // [#comment:TODO: This field is ignored when the
  // :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
  // is present.]
  bool merge_slashes = 33;

  // Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
  // The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action<config_http_conn_man_runtime_path_with_escaped_slashes_action>`
  // runtime variable.
  // The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling<config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled>` runtime
  // variable can be used to apply the action to a portion of all requests.
  // [#comment:TODO: This field is ignored when the
  // :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
  // is present.]
  PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45;

  // The configuration of the request ID extension. This includes operations such as
  // generation, validation, and associated tracing operations. If empty, the
  // :ref:`UuidRequestIdConfig <envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig>`
  // default extension is used with default parameters. See the documentation for that extension
  // for details on what it does. Customizing the configuration for the default extension can be
  // achieved by configuring it explicitly here. For example, to disable trace reason packing,
  // the following configuration can be used:
  //
  // .. validated-code-block:: yaml
  //   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
  //
  //   typed_config:
  //     "@type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
  //     pack_trace_reason: false
  //
  // [#extension-category: envoy.request_id]
  RequestIDExtension request_id_extension = 36;

  // The configuration to customize local reply returned by Envoy. It can customize status code,
  // body text and response content type. If not specified, status code and text body are hard
  // coded in Envoy, the response content type is plain text.
  LocalReplyConfig local_reply_config = 38;

  // Determines if the port part should be removed from host/authority header before any processing
  // of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's<envoy_v3_api_field_config.listener.v3.Listener.address>`
  // local port. This affects the upstream host header unless the method is
  // CONNECT in which case if no filter adds a port the original port will be restored before headers are
  // sent upstream.
  // Without setting this option, incoming requests with host ``example:443`` will not match against
  // route with :ref:`domains<envoy_v3_api_field_config.route.v3.VirtualHost.domains>` match set to ``example``. Defaults to ``false``. Note that port removal is not part
  // of `HTTP spec <https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
  // Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
  bool strip_matching_host_port = 39
      [(udpa.annotations.field_migrate).oneof_promotion = "strip_port_mode"];

  oneof strip_port_mode {
    // Determines if the port part should be removed from host/authority header before any processing
    // of request by HTTP filters or routing.
    // This affects the upstream host header unless the method is CONNECT in
    // which case if no filter adds a port the original port will be restored before headers are sent upstream.
    // Without setting this option, incoming requests with host ``example:443`` will not match against
    // route with :ref:`domains<envoy_v3_api_field_config.route.v3.VirtualHost.domains>` match set to ``example``. Defaults to ``false``. Note that port removal is not part
    // of `HTTP spec <https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
    // Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
    bool strip_any_host_port = 42;
  }

  // Governs Envoy's behavior when receiving invalid HTTP from downstream.
  // If this option is false (default), Envoy will err on the conservative side handling HTTP
  // errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
  // If this option is set to true, Envoy will be more permissive, only resetting the invalid
  // stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
  // request is read for HTTP/1.1)
  // In general this should be true for deployments receiving trusted traffic (L2 Envoys,
  // company-internal mesh) and false when receiving untrusted traffic (edge deployments).
  //
  // If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
  // desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
  // <envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message>` or the new HTTP/2 option
  // :ref:`override_stream_error_on_invalid_http_message
  // <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message>`
  // ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
  // <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging>`
  google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;

  // [#not-implemented-hide:] Path normalization configuration. This includes
  // configurations for transformations (e.g. RFC 3986 normalization or merge
  // adjacent slashes) and the policy to apply them. The policy determines
  // whether transformations affect the forwarded ``:path`` header. RFC 3986 path
  // normalization is enabled by default and the default policy is that the
  // normalized header will be forwarded. See :ref:`PathNormalizationOptions
  // <envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions>`
  // for details.
  PathNormalizationOptions path_normalization_options = 43;

  // Determines if trailing dot of the host should be removed from host/authority header before any
  // processing of request by HTTP filters or routing.
  // This affects the upstream host header.
  // Without setting this option, incoming requests with host ``example.com.`` will not match against
  // route with :ref:`domains<envoy_v3_api_field_config.route.v3.VirtualHost.domains>` match set to ``example.com``. Defaults to ``false``.
  // When the incoming request contains a host/authority header that includes a port number,
  // setting this option will strip a trailing dot, if present, from the host section,
  // leaving the port as is (e.g. host value ``example.com.:443`` will be updated to ``example.com:443``).
  bool strip_trailing_host_dot = 47;

  // Proxy-Status HTTP response header configuration.
  // If this config is set, the Proxy-Status HTTP response header field is
  // populated. By default, it is not.
  ProxyStatusConfig proxy_status_config = 49;

  // Configuration options for Header Validation (UHV).
  // UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
  // normalization for request attributes, such as URI path.
  // If the typed_header_validation_config is present it overrides the following options:
  // ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
  // ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
  //
  // The default UHV checks the following:
  //
  // #. HTTP/1 header map validity according to `RFC 7230 section 3.2<https://datatracker.ietf.org/doc/html/rfc7230#section-3.2>`_
  // #. Syntax of HTTP/1 request target URI and response status
  // #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2<https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
  // #. Syntax of HTTP/2 pseudo headers
  // #. HTTP/3 header map validity according to `RFC 9114 section 4.3 <https://www.rfc-editor.org/rfc/rfc9114.html>`_
  // #. Syntax of HTTP/3 pseudo headers
  // #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
  // #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
  // #. Normalization of the URI path according to `Normalization and Comparison <https://datatracker.ietf.org/doc/html/rfc3986#section-6>`_
  //    without `case normalization <https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1>`_
  //
  // [#not-implemented-hide:]
  // [#extension-category: envoy.http.header_validators]
  config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;

  // Append the ``x-forwarded-port`` header with the port value client used to connect to Envoy. It
  // will be ignored if the ``x-forwarded-port`` header has been set by any trusted proxy in front of Envoy.
  bool append_x_forwarded_port = 51;

  // Whether the HCM will add ProxyProtocolFilterState to the Connection lifetime filter state. Defaults to ``true``.
  // This should be set to ``false`` in cases where Envoy's view of the downstream address may not correspond to the
  // actual client address, for example, if there's another proxy in front of the Envoy.
  google.protobuf.BoolValue add_proxy_protocol_connection_state = 53;
}

// The configuration to customize local reply returned by Envoy.
message LocalReplyConfig {
  // Configuration of list of mappers which allows to filter and change local response.
  // The mappers will be checked by the specified order until one is matched.
  repeated ResponseMapper mappers = 1;

  // The configuration to form response body from the :ref:`command operators <config_access_log_command_operators>`
  // and to specify response content type as one of: plain/text or application/json.
  //
  // Example one: "plain/text" ``body_format``.
  //
  // .. validated-code-block:: yaml
  //   :type-name: envoy.config.core.v3.SubstitutionFormatString
  //
  //   text_format: "%LOCAL_REPLY_BODY%:%RESPONSE_CODE%:path=%REQ(:path)%\n"
  //
  // The following response body in "plain/text" format will be generated for a request with
  // local reply body of "upstream connection error", response_code=503 and path=/foo.
  //
  // .. code-block:: text
  //
  //   upstream connect error:503:path=/foo
  //
  // Example two: "application/json" ``body_format``.
  //
  // .. validated-code-block:: yaml
  //   :type-name: envoy.config.core.v3.SubstitutionFormatString
  //
  //   json_format:
  //     status: "%RESPONSE_CODE%"
  //     message: "%LOCAL_REPLY_BODY%"
  //     path: "%REQ(:path)%"
  //
  // The following response body in "application/json" format would be generated for a request with
  // local reply body of "upstream connection error", response_code=503 and path=/foo.
  //
  // .. code-block:: json
  //
  //  {
  //    "status": 503,
  //    "message": "upstream connection error",
  //    "path": "/foo"
  //  }
  //
  config.core.v3.SubstitutionFormatString body_format = 2;
}

// The configuration to filter and change local response.
// [#next-free-field: 6]
message ResponseMapper {
  // Filter to determine if this mapper should apply.
  config.accesslog.v3.AccessLogFilter filter = 1 [(validate.rules).message = {required: true}];

  // The new response status code if specified.
  google.protobuf.UInt32Value status_code = 2 [(validate.rules).uint32 = {lt: 600 gte: 200}];

  // The new local reply body text if specified. It will be used in the ``%LOCAL_REPLY_BODY%``
  // command operator in the ``body_format``.
  config.core.v3.DataSource body = 3;

  // A per mapper ``body_format`` to override the :ref:`body_format <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.body_format>`.
  // It will be used when this mapper is matched.
  config.core.v3.SubstitutionFormatString body_format_override = 4;

  // HTTP headers to add to a local reply. This allows the response mapper to append, to add
  // or to override headers of any local reply before it is sent to a downstream client.
  repeated config.core.v3.HeaderValueOption headers_to_add = 5
      [(validate.rules).repeated = {max_items: 1000}];
}

message Rds {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.http_connection_manager.v2.Rds";

  // Configuration source specifier for RDS.
  config.core.v3.ConfigSource config_source = 1 [(validate.rules).message = {required: true}];

  // The name of the route configuration. This name will be passed to the RDS
  // API. This allows an Envoy configuration with multiple HTTP listeners (and
  // associated HTTP connection manager filters) to use different route
  // configurations.
  string route_config_name = 2;
}

// This message is used to work around the limitations with 'oneof' and repeated fields.
message ScopedRouteConfigurationsList {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.http_connection_manager.v2.ScopedRouteConfigurationsList";

  repeated config.route.v3.ScopedRouteConfiguration scoped_route_configurations = 1
      [(validate.rules).repeated = {min_items: 1}];
}

// [#next-free-field: 6]
message ScopedRoutes {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes";

  // Specifies the mechanism for constructing "scope keys" based on HTTP request attributes. These
  // keys are matched against a set of :ref:`Key<envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration.Key>`
  // objects assembled from :ref:`ScopedRouteConfiguration<envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration>`
  // messages distributed via SRDS (the Scoped Route Discovery Service) or assigned statically via
  // :ref:`scoped_route_configurations_list<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scoped_route_configurations_list>`.
  //
  // Upon receiving a request's headers, the Router will build a key using the algorithm specified
  // by this message. This key will be used to look up the routing table (i.e., the
  // :ref:`RouteConfiguration<envoy_v3_api_msg_config.route.v3.RouteConfiguration>`) to use for the request.
  message ScopeKeyBuilder {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder";

    // Specifies the mechanism for constructing key fragments which are composed into scope keys.
    message FragmentBuilder {
      option (udpa.annotations.versioning).previous_message_type =
          "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder."
          "FragmentBuilder";

      // Specifies how the value of a header should be extracted.
      // The following example maps the structure of a header to the fields in this message.
      //
      // .. code::
      //
      //              <0> <1>   <-- index
      //    X-Header: a=b;c=d
      //    |         || |
      //    |         || \----> <element_separator>
      //    |         ||
      //    |         |\----> <element.separator>
      //    |         |
      //    |         \----> <element.key>
      //    |
      //    \----> <name>
      //
      //    Each 'a=b' key-value pair constitutes an 'element' of the header field.
      message HeaderValueExtractor {
        option (udpa.annotations.versioning).previous_message_type =
            "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder."
            "FragmentBuilder.HeaderValueExtractor";

        // Specifies a header field's key value pair to match on.
        message KvElement {
          option (udpa.annotations.versioning).previous_message_type =
              "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder."
              "FragmentBuilder.HeaderValueExtractor.KvElement";

          // The separator between key and value (e.g., '=' separates 'k=v;...').
          // If an element is an empty string, the element is ignored.
          // If an element contains no separator, the whole element is parsed as key and the
          // fragment value is an empty string.
          // If there are multiple values for a matched key, the first value is returned.
          string separator = 1 [(validate.rules).string = {min_len: 1}];

          // The key to match on.
          string key = 2 [(validate.rules).string = {min_len: 1}];
        }

        // The name of the header field to extract the value from.
        //
        // .. note::
        //
        //   If the header appears multiple times only the first value is used.
        string name = 1 [
          (validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}
        ];

        // The element separator (e.g., ';' separates 'a;b;c;d').
        // Default: empty string. This causes the entirety of the header field to be extracted.
        // If this field is set to an empty string and 'index' is used in the oneof below, 'index'
        // must be set to 0.
        string element_separator = 2;

        oneof extract_type {
          // Specifies the zero based index of the element to extract.
          // Note Envoy concatenates multiple values of the same header key into a comma separated
          // string, the splitting always happens after the concatenation.
          uint32 index = 3;

          // Specifies the key value pair to extract the value from.
          KvElement element = 4;
        }
      }

      oneof type {
        option (validate.required) = true;

        // Specifies how a header field's value should be extracted.
        HeaderValueExtractor header_value_extractor = 1;
      }
    }

    // The final(built) scope key consists of the ordered union of these fragments, which are compared in order with the
    // fragments of a :ref:`ScopedRouteConfiguration<envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration>`.
    // A missing fragment during comparison will make the key invalid, i.e., the computed key doesn't match any key.
    repeated FragmentBuilder fragments = 1 [(validate.rules).repeated = {min_items: 1}];
  }

  // The name assigned to the scoped routing configuration.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // The algorithm to use for constructing a scope key for each request.
  ScopeKeyBuilder scope_key_builder = 2 [(validate.rules).message = {required: true}];

  // Configuration source specifier for RDS.
  // This config source is used to subscribe to RouteConfiguration resources specified in
  // ScopedRouteConfiguration messages.
  config.core.v3.ConfigSource rds_config_source = 3;

  oneof config_specifier {
    option (validate.required) = true;

    // The set of routing scopes corresponding to the HCM. A scope is assigned to a request by
    // matching a key constructed from the request's attributes according to the algorithm specified
    // by the
    // :ref:`ScopeKeyBuilder<envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder>`
    // in this message.
    ScopedRouteConfigurationsList scoped_route_configurations_list = 4;

    // The set of routing scopes associated with the HCM will be dynamically loaded via the SRDS
    // API. A scope is assigned to a request by matching a key constructed from the request's
    // attributes according to the algorithm specified by the
    // :ref:`ScopeKeyBuilder<envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder>`
    // in this message.
    ScopedRds scoped_rds = 5;
  }
}

message ScopedRds {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.http_connection_manager.v2.ScopedRds";

  // Configuration source specifier for scoped RDS.
  config.core.v3.ConfigSource scoped_rds_config_source = 1
      [(validate.rules).message = {required: true}];

  // xdstp:// resource locator for scoped RDS collection.
  // [#not-implemented-hide:]
  string srds_resources_locator = 2;
}

// [#next-free-field: 8]
message HttpFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.http_connection_manager.v2.HttpFilter";

  reserved 3, 2;

  reserved "config";

  // The name of the filter configuration. It also serves as a resource name in ExtensionConfigDS.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  oneof config_type {
    // Filter specific configuration which depends on the filter being instantiated. See the supported
    // filters for further documentation.
    //
    // To support configuring a :ref:`match tree <arch_overview_matching_api>`, use an
    // :ref:`ExtensionWithMatcher <envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcher>`
    // with the desired HTTP filter.
    // [#extension-category: envoy.filters.http]
    google.protobuf.Any typed_config = 4;

    // Configuration source specifier for an extension configuration discovery service.
    // In case of a failure and without the default configuration, the HTTP listener responds with code 500.
    // Extension configs delivered through this mechanism are not expected to require warming (see https://github.com/envoyproxy/envoy/issues/12061).
    //
    // To support configuring a :ref:`match tree <arch_overview_matching_api>`, use an
    // :ref:`ExtensionWithMatcher <envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcher>`
    // with the desired HTTP filter. This works for both the default filter configuration as well
    // as for filters provided via the API.
    config.core.v3.ExtensionConfigSource config_discovery = 5;
  }

  // If true, clients that do not support this filter may ignore the
  // filter but otherwise accept the config.
  // Otherwise, clients that do not support this filter must reject the config.
  bool is_optional = 6;

  // If true, the filter is disabled by default and must be explicitly enabled by setting
  // per filter configuration in the route configuration.
  // See :ref:`route based filter chain <arch_overview_http_filters_route_based_filter_chain>`
  // for more details.
  //
  // Terminal filters (e.g. ``envoy.filters.http.router``) cannot be marked as disabled.
  bool disabled = 7;
}

message RequestIDExtension {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.http_connection_manager.v2.RequestIDExtension";

  // Request ID extension specific configuration.
  google.protobuf.Any typed_config = 1;
}

// [#protodoc-title: Envoy Mobile HTTP connection manager]
// HTTP connection manager for use in Envoy mobile.
// [#extension: envoy.filters.network.envoy_mobile_http_connection_manager]
message EnvoyMobileHttpConnectionManager {
  // The configuration for the underlying HttpConnectionManager which will be
  // instantiated for Envoy mobile.
  HttpConnectionManager config = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/accesslog/v3:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/config/route/v3:pkg",
        "//envoy/config/trace/v3:pkg",
        "//envoy/type/http/v3:pkg",
        "//envoy/type/tracing/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.dubbo_proxy.v3;

import "envoy/config/core/v3/config_source.proto";
import "envoy/extensions/filters/network/dubbo_proxy/v3/route.proto";

import "google/protobuf/any.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.dubbo_proxy.v3";
option java_outer_classname = "DubboProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/dubbo_proxy/v3;dubbo_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Dubbo Proxy]
// Dubbo Proxy :ref:`configuration overview <config_network_filters_dubbo_proxy>`.
// [#extension: envoy.filters.network.dubbo_proxy]

// Dubbo Protocol types supported by Envoy.
enum ProtocolType {
  // the default protocol.
  Dubbo = 0;
}

// Dubbo Serialization types supported by Envoy.
enum SerializationType {
  // the default serialization protocol.
  Hessian2 = 0;
}

message Drds {
  // Configuration source specifier.
  // In case of ``api_config_source`` only aggregated ``api_type`` is supported.
  config.core.v3.ConfigSource config_source = 1 [(validate.rules).message = {required: true}];

  // The name of the multiple route configuration. This allows to use different multiple route
  // configurations. Tells which multiple route configuration should be fetched from the configuration
  // source. Leave unspecified is also valid and means the unnamed multiple route configuration.
  string route_config_name = 2;
}

// [#next-free-field: 8]
message DubboProxy {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.dubbo_proxy.v2alpha1.DubboProxy";

  // The human readable prefix to use when emitting statistics.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // Configure the protocol used.
  ProtocolType protocol_type = 2 [(validate.rules).enum = {defined_only: true}];

  // Configure the serialization protocol used.
  SerializationType serialization_type = 3 [(validate.rules).enum = {defined_only: true}];

  // The route table for the connection manager is static and is specified in this property.
  //
  // .. note::
  //
  //   This field is deprecated. Please use ``drds`` or ``multiple_route_config`` first.
  repeated RouteConfiguration route_config = 4
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  oneof route_specifier {
    // Use xDS to fetch the route configuration. It is invalid to define both ``route_config`` and ``drds``.
    Drds drds = 6 [(udpa.annotations.field_migrate).oneof_promotion = "route_specifier"];

    MultipleRouteConfiguration multiple_route_config = 7;
  }

  // A list of individual Dubbo filters that make up the filter chain for requests made to the
  // Dubbo proxy. Order matters as the filters are processed sequentially. For backwards
  // compatibility, if no dubbo_filters are specified, a default Dubbo router filter
  // (``envoy.filters.dubbo.router``) is used.
  repeated DubboFilter dubbo_filters = 5;
}

// DubboFilter configures a Dubbo filter.
message DubboFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.dubbo_proxy.v2alpha1.DubboFilter";

  // The name of the filter to instantiate. The name must match a supported
  // filter.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // Filter specific configuration which depends on the filter being
  // instantiated. See the supported filters for further documentation.
  google.protobuf.Any config = 2;
}
syntax = "proto3";

package envoy.extensions.filters.network.dubbo_proxy.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/route/v3/route_components.proto";
import "envoy/type/matcher/v3/string.proto";
import "envoy/type/v3/range.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.dubbo_proxy.v3";
option java_outer_classname = "RouteProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/dubbo_proxy/v3;dubbo_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Dubbo Proxy Route Configuration]
// Dubbo Proxy :ref:`configuration overview <config_network_filters_dubbo_proxy>`.

// [#next-free-field: 6]
message RouteConfiguration {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteConfiguration";

  // The name of the route configuration. Reserved for future use in asynchronous route discovery.
  string name = 1;

  // The interface name of the service. Wildcard interface are supported in the suffix or prefix form.
  // e.g. ``*.methods.add`` will match ``com.dev.methods.add``, ``com.prod.methods.add``, etc.
  // ``com.dev.methods.*`` will match ``com.dev.methods.add``, ``com.dev.methods.update``, etc.
  // Special wildcard ``*`` matching any interface.
  //
  // .. note::
  //
  //  The wildcard will not match the empty string.
  //  e.g. ``*.methods.add`` will match ``com.dev.methods.add`` but not ``.methods.add``.
  string interface = 2;

  // Which group does the interface belong to.
  string group = 3;

  // The version number of the interface.
  string version = 4;

  // The list of routes that will be matched, in order, against incoming requests. The first route
  // that matches will be used.
  repeated Route routes = 5;
}

message Route {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.dubbo_proxy.v2alpha1.Route";

  // Route matching parameters.
  RouteMatch match = 1 [(validate.rules).message = {required: true}];

  // Route request to some upstream cluster.
  RouteAction route = 2 [(validate.rules).message = {required: true}];
}

message RouteMatch {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteMatch";

  // Method level routing matching.
  MethodMatch method = 1;

  // Specifies a set of headers that the route should match on. The router will check the requests
  // headers against all the specified headers in the route config. A match will happen if all the
  // headers in the route are present in the request with the same values (or based on presence if
  // the value field is not in the config).
  repeated config.route.v3.HeaderMatcher headers = 2;
}

message RouteAction {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteAction";

  oneof cluster_specifier {
    option (validate.required) = true;

    // Indicates the upstream cluster to which the request should be routed.
    string cluster = 1;

    // Multiple upstream clusters can be specified for a given route. The
    // request is routed to one of the upstream clusters based on weights
    // assigned to each cluster.
    // Currently ClusterWeight only supports the name and weight fields.
    config.route.v3.WeightedCluster weighted_clusters = 2;
  }

  // Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
  // the upstream cluster with metadata matching what is set in this field will be considered for
  // load balancing. The filter name should be specified as ``envoy.lb``.
  config.core.v3.Metadata metadata_match = 3;
}

message MethodMatch {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch";

  // The parameter matching type.
  message ParameterMatchSpecifier {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch.ParameterMatchSpecifier";

    oneof parameter_match_specifier {
      // If specified, header match will be performed based on the value of the header.
      string exact_match = 3;

      // If specified, header match will be performed based on range.
      // The rule will match if the request header value is within this range.
      // The entire request header value must represent an integer in base 10 notation: consisting
      // of an optional plus or minus sign followed by a sequence of digits. The rule will not match
      // if the header value does not represent an integer. Match will fail for empty values,
      // floating point numbers or if only a subsequence of the header value is an integer.
      //
      // Examples:
      //
      // * For range [-10,0), route will match for header value -1, but not for 0,
      //   "somestring", 10.9, "-1somestring"
      type.v3.Int64Range range_match = 4;
    }
  }

  // The name of the method.
  type.matcher.v3.StringMatcher name = 1;

  // Method parameter definition.
  // The key is the parameter index, starting from 0.
  // The value is the parameter matching type.
  map<uint32, ParameterMatchSpecifier> params_match = 2;
}

message MultipleRouteConfiguration {
  // The name of the named route configurations. This name is used in asynchronous route discovery.
  string name = 1;

  // The route table of the dubbo connection manager.
  repeated RouteConfiguration route_config = 4;
}
Protocol buffer definitions for the Dubbo proxy.
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/config/route/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.dubbo_proxy.router.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.dubbo_proxy.router.v3";
option java_outer_classname = "RouterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/dubbo_proxy/router/v3;routerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Router]
// Dubbo router :ref:`configuration overview <config_dubbo_filters_router>`.

message Router {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.dubbo.router.v2alpha1.Router";
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.network.ext_authz.v3;

import "envoy/config/core/v3/config_source.proto";
import "envoy/config/core/v3/grpc_service.proto";
import "envoy/type/matcher/v3/metadata.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.ext_authz.v3";
option java_outer_classname = "ExtAuthzProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/ext_authz/v3;ext_authzv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Network External Authorization ]
// The network layer external authorization service configuration
// :ref:`configuration overview <config_network_filters_ext_authz>`.
// [#extension: envoy.filters.network.ext_authz]

// External Authorization filter calls out to an external service over the
// gRPC Authorization API defined by
// :ref:`CheckRequest <envoy_v3_api_msg_service.auth.v3.CheckRequest>`.
// A failed check will cause this filter to close the TCP connection.
// [#next-free-field: 8]
message ExtAuthz {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.ext_authz.v2.ExtAuthz";

  // The prefix to use when emitting statistics.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // The external authorization gRPC service configuration.
  // The default timeout is set to 200ms by this filter.
  config.core.v3.GrpcService grpc_service = 2;

  // The filter's behaviour in case the external authorization service does
  // not respond back. When it is set to true, Envoy will also allow traffic in case of
  // communication failure between authorization service and the proxy.
  // Defaults to false.
  bool failure_mode_allow = 3;

  // Specifies if the peer certificate is sent to the external service.
  //
  // When this field is true, Envoy will include the peer X.509 certificate, if available, in the
  // :ref:`certificate<envoy_v3_api_field_service.auth.v3.AttributeContext.Peer.certificate>`.
  bool include_peer_certificate = 4;

  // API version for ext_authz transport protocol. This describes the ext_authz gRPC endpoint and
  // version of Check{Request,Response} used on the wire.
  config.core.v3.ApiVersion transport_api_version = 5
      [(validate.rules).enum = {defined_only: true}];

  // Specifies if the filter is enabled with metadata matcher.
  // If this field is not specified, the filter will be enabled for all requests.
  type.matcher.v3.MetadataMatcher filter_enabled_metadata = 6;

  // Optional labels that will be passed to :ref:`labels<envoy_v3_api_field_service.auth.v3.AttributeContext.Peer.labels>` in
  // :ref:`destination<envoy_v3_api_field_service.auth.v3.AttributeContext.destination>`.
  // The labels will be read from :ref:`metadata<envoy_v3_api_msg_config.core.v3.Node>` with the specified key.
  string bootstrap_metadata_labels_key = 7;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.ratelimit.v3;

import "envoy/config/ratelimit/v3/rls.proto";
import "envoy/extensions/common/ratelimit/v3/ratelimit.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.ratelimit.v3";
option java_outer_classname = "RateLimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/ratelimit/v3;ratelimitv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Rate limit]
// Rate limit :ref:`configuration overview <config_network_filters_rate_limit>`.
// [#extension: envoy.filters.network.ratelimit]

// [#next-free-field: 7]
message RateLimit {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.rate_limit.v2.RateLimit";

  // The prefix to use when emitting :ref:`statistics <config_network_filters_rate_limit_stats>`.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // The rate limit domain to use in the rate limit service request.
  string domain = 2 [(validate.rules).string = {min_len: 1}];

  // The rate limit descriptor list to use in the rate limit service request.
  repeated common.ratelimit.v3.RateLimitDescriptor descriptors = 3
      [(validate.rules).repeated = {min_items: 1}];

  // The timeout in milliseconds for the rate limit service RPC. If not
  // set, this defaults to 20ms.
  google.protobuf.Duration timeout = 4;

  // The filter's behaviour in case the rate limiting service does
  // not respond back. When it is set to true, Envoy will not allow traffic in case of
  // communication failure between rate limiting service and the proxy.
  // Defaults to false.
  bool failure_mode_deny = 5;

  // Configuration for an external rate limit service provider. If not
  // specified, any calls to the rate limit service will immediately return
  // success.
  config.ratelimit.v3.RateLimitServiceConfig rate_limit_service = 6
      [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/ratelimit/v3:pkg",
        "//envoy/extensions/common/ratelimit/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.sni_dynamic_forward_proxy.v3;

import "envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.sni_dynamic_forward_proxy.v3";
option java_outer_classname = "SniDynamicForwardProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/sni_dynamic_forward_proxy/v3;sni_dynamic_forward_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: SNI dynamic forward proxy]

// Configuration for the SNI-based dynamic forward proxy filter. See the
// :ref:`architecture overview <arch_overview_http_dynamic_forward_proxy>` for
// more information. Note this filter must be configured along with
// :ref:`TLS inspector listener filter <config_listener_filters_tls_inspector>`
// to work.
// [#extension: envoy.filters.network.sni_dynamic_forward_proxy]
message FilterConfig {
  // The DNS cache configuration that the filter will attach to. Note this
  // configuration must match that of associated :ref:`dynamic forward proxy
  // cluster configuration
  // <envoy_v3_api_field_extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig.dns_cache_config>`.
  common.dynamic_forward_proxy.v3.DnsCacheConfig dns_cache_config = 1
      [(validate.rules).message = {required: true}];

  oneof port_specifier {
    // The port number to connect to the upstream.
    uint32 port_value = 2 [(validate.rules).uint32 = {lte: 65535 gt: 0}];
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/common/dynamic_forward_proxy/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.set_filter_state.v3;

import "envoy/extensions/filters/common/set_filter_state/v3/value.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.set_filter_state.v3";
option java_outer_classname = "SetFilterStateProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/set_filter_state/v3;set_filter_statev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Set-Filter-State Filter]
//
// This filter sets or updates the dynamic filter state. See :ref:`the filter
// documentation <config_network_filters_set_filter_state>` for more
// information on how this filter should be used.
//
// [#extension: envoy.filters.network.set_filter_state]

message Config {
  // A sequence of the filter state values to apply in the specified order
  // when a new connection is received.
  repeated common.set_filter_state.v3.FilterStateValue on_new_connection = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/filters/common/set_filter_state/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.direct_response.v3;

import "envoy/config/core/v3/base.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.direct_response.v3";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/direct_response/v3;direct_responsev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Direct response]
// Direct response :ref:`configuration overview <config_network_filters_direct_response>`.
// [#extension: envoy.filters.network.direct_response]

message Config {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.direct_response.v2.Config";

  // Response data as a data source.
  config.core.v3.DataSource response = 1;
}
syntax = "proto3";

package envoy.extensions.filters.network.sni_cluster.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.sni_cluster.v3";
option java_outer_classname = "SniClusterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/sni_cluster/v3;sni_clusterv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: SNI Cluster Filter]
// Set the upstream cluster name from the SNI field in the TLS connection.
// [#extension: envoy.filters.network.sni_cluster]

message SniCluster {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.sni_cluster.v2.SniCluster";
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.network.thrift_proxy.filters.header_to_metadata.v3;

import "envoy/type/matcher/v3/regex.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.thrift_proxy.filters.header_to_metadata.v3";
option java_outer_classname = "HeaderToMetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/thrift_proxy/filters/header_to_metadata/v3;header_to_metadatav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Header-To-Metadata Filter]
//
// The configuration for transforming headers into metadata. This is useful
// for matching load balancer subsets, logging, etc.
//
// Header to Metadata :ref:`configuration overview <config_thrift_filters_header_to_metadata>`.
// [#extension: envoy.filters.thrift.header_to_metadata]

message HeaderToMetadata {
  enum ValueType {
    STRING = 0;

    NUMBER = 1;

    // The value is a serialized `protobuf.Value
    // <https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/struct.proto#L62>`_.
    PROTOBUF_VALUE = 2;
  }

  // ValueEncode defines the encoding algorithm.
  enum ValueEncode {
    // The value is not encoded.
    NONE = 0;

    // The value is encoded in `Base64 <https://tools.ietf.org/html/rfc4648#section-4>`_.
    // Note: this is mostly used for STRING and PROTOBUF_VALUE to escape the
    // non-ASCII characters in the header.
    BASE64 = 1;
  }

  // [#next-free-field: 7]
  message KeyValuePair {
    // The namespace  if this is empty, the filter's namespace will be used.
    string metadata_namespace = 1;

    // The key to use within the namespace.
    string key = 2 [(validate.rules).string = {min_len: 1}];

    oneof value_type {
      // The value to pair with the given key.
      //
      // When used for on_present case, if value is non-empty it'll be used instead
      // of the header value. If both are empty, the header value is used as-is.
      //
      // When used for on_missing case, a non-empty value must be provided.
      string value = 3;

      // If present, the header's value will be matched and substituted with this.
      // If there is no match or substitution, the header value is used as-is.
      //
      // This is only used for on_present.
      type.matcher.v3.RegexMatchAndSubstitute regex_value_rewrite = 4;
    }

    // The value's type  defaults to string.
    ValueType type = 5 [(validate.rules).enum = {defined_only: true}];

    // How is the value encoded, default is NONE (not encoded).
    // The value will be decoded accordingly before storing to metadata.
    ValueEncode encode = 6;
  }

  // A Rule defines what metadata to apply when a header is present or missing.
  message Rule {
    // Specifies that a match will be performed on the value of a header.
    //
    // The header to be extracted.
    string header = 1
        [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

    // If the header is present, apply this metadata KeyValuePair.
    //
    // If the value in the KeyValuePair is non-empty, it'll be used instead
    // of the header value.
    KeyValuePair on_present = 2;

    // If the header is not present, apply this metadata KeyValuePair.
    //
    // The value in the KeyValuePair must be set, since it'll be used in lieu
    // of the missing header value.
    KeyValuePair on_missing = 3;

    // Whether or not to remove the header after a rule is applied.
    //
    // This prevents headers from leaking.
    bool remove = 4;
  }

  // The list of rules to apply to requests.
  repeated Rule request_rules = 1 [(validate.rules).repeated = {min_items: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.thrift_proxy.filters.ratelimit.v3;

import "envoy/config/ratelimit/v3/rls.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.thrift_proxy.filters.ratelimit.v3";
option java_outer_classname = "RateLimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/thrift_proxy/filters/ratelimit/v3;ratelimitv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Rate limit]
// Rate limit :ref:`configuration overview <config_thrift_filters_rate_limit>`.
// [#extension: envoy.filters.thrift.rate_limit]

// [#next-free-field: 6]
message RateLimit {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.thrift.rate_limit.v2alpha1.RateLimit";

  // The rate limit domain to use in the rate limit service request.
  string domain = 1 [(validate.rules).string = {min_len: 1}];

  // Specifies the rate limit configuration stage. Each configured rate limit filter performs a
  // rate limit check using descriptors configured in the
  // :ref:`envoy_v3_api_msg_extensions.filters.network.thrift_proxy.v3.RouteAction` for the request.
  // Only those entries with a matching stage number are used for a given filter. If not set, the
  // default stage number is 0.
  //
  // .. note::
  //
  //  The filter supports a range of 0 - 10 inclusively for stage numbers.
  uint32 stage = 2 [(validate.rules).uint32 = {lte: 10}];

  // The timeout in milliseconds for the rate limit service RPC. If not
  // set, this defaults to 20ms.
  google.protobuf.Duration timeout = 3;

  // The filter's behaviour in case the rate limiting service does
  // not respond back. When it is set to true, Envoy will not allow traffic in case of
  // communication failure between rate limiting service and the proxy.
  // Defaults to false.
  bool failure_mode_deny = 4;

  // Configuration for an external rate limit service provider. If not
  // specified, any calls to the rate limit service will immediately return
  // success.
  config.ratelimit.v3.RateLimitServiceConfig rate_limit_service = 5
      [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/ratelimit/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.thrift_proxy.filters.payload_to_metadata.v3;

import "envoy/type/matcher/v3/regex.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.thrift_proxy.filters.payload_to_metadata.v3";
option java_outer_classname = "PayloadToMetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/thrift_proxy/filters/payload_to_metadata/v3;payload_to_metadatav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Payload-To-Metadata Filter]
//
// The configuration for transforming payloads into metadata. This is useful
// for matching load balancer subsets, logging, etc.
//
// Payload to Metadata :ref:`configuration overview <config_thrift_filters_payload_to_metadata>`.
// [#extension: envoy.filters.thrift.payload_to_metadata]

message PayloadToMetadata {
  enum ValueType {
    STRING = 0;
    NUMBER = 1;
  }

  // [#next-free-field: 6]
  message KeyValuePair {
    // The namespace  if this is empty, the filter's namespace will be used.
    string metadata_namespace = 1;

    // The key to use within the namespace.
    string key = 2 [(validate.rules).string = {min_len: 1}];

    oneof value_type {
      // The value to pair with the given key.
      //
      // When used for on_present case, if value is non-empty it'll be used instead
      // of the field value. If both are empty, the field value is used as-is.
      //
      // When used for on_missing case, a non-empty value must be provided.
      string value = 3;

      // If present, the header's value will be matched and substituted with this.
      // If there is no match or substitution, the field value is used as-is.
      //
      // This is only used for on_present.
      type.matcher.v3.RegexMatchAndSubstitute regex_value_rewrite = 4;
    }

    // The value's type  defaults to string.
    ValueType type = 5 [(validate.rules).enum = {defined_only: true}];
  }

  // A Rule defines what metadata to apply when a field is present or missing.
  // [#next-free-field: 6]
  message Rule {
    oneof match_specifier {
      option (validate.required) = true;

      // If specified, the route must exactly match the request method name. As a special case,
      // an empty string matches any request method name.
      string method_name = 1;

      // If specified, the route must have the service name as the request method name prefix.
      // As a special case, an empty string matches any service name. Only relevant when service
      // multiplexing.
      string service_name = 2;
    }

    // Specifies that a match will be performed on the value of a field.
    FieldSelector field_selector = 3 [(validate.rules).message = {required: true}];

    // If the field is present, apply this metadata KeyValuePair.
    KeyValuePair on_present = 4;

    // If the field is missing, apply this metadata KeyValuePair.
    //
    // The value in the KeyValuePair must be set, since it'll be used in lieu
    // of the missing field value.
    KeyValuePair on_missing = 5;
  }

  message FieldSelector {
    // field name to log
    string name = 1 [(validate.rules).string = {min_len: 1}];

    // field id to match
    int32 id = 2 [(validate.rules).int32 = {lte: 32767 gte: -32768}];

    // next node of the field selector
    FieldSelector child = 3;
  }

  // The list of rules to apply to requests.
  repeated Rule request_rules = 1 [(validate.rules).repeated = {min_items: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.thrift_proxy.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/route/v3/route_components.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.thrift_proxy.v3";
option java_outer_classname = "RouteProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/thrift_proxy/v3;thrift_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Thrift Proxy Route Configuration]
// Thrift Proxy :ref:`configuration overview <config_network_filters_thrift_proxy>`.

message RouteConfiguration {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.thrift_proxy.v2alpha1.RouteConfiguration";

  // The name of the route configuration. This name is used in asynchronous route discovery.
  // For example, it might match
  // :ref:`route_config_name
  // <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.Trds.route_config_name>` in
  // :ref:`envoy_v3_api_msg_extensions.filters.network.thrift_proxy.v3.Trds`.
  string name = 1;

  // The list of routes that will be matched, in order, against incoming requests. The first route
  // that matches will be used.
  repeated Route routes = 2;

  // An optional boolean that specifies whether the clusters that the route
  // table refers to will be validated by the cluster manager. If set to true
  // and a route refers to a non-existent cluster, the route table will not
  // load. If set to false and a route refers to a non-existent cluster, the
  // route table will load and the router filter will return a INTERNAL_ERROR
  // if the route is selected at runtime. This setting defaults to true if the route table
  // is statically defined via the :ref:`route_config
  // <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.ThriftProxy.route_config>`
  // option. This setting default to false if the route table is loaded dynamically via the
  // :ref:`trds
  // <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.ThriftProxy.trds>`
  // option. Users may wish to override the default behavior in certain cases (for example when
  // using CDS with a static route table).
  google.protobuf.BoolValue validate_clusters = 3;
}

message Route {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.thrift_proxy.v2alpha1.Route";

  // Route matching parameters.
  RouteMatch match = 1 [(validate.rules).message = {required: true}];

  // Route request to some upstream cluster.
  RouteAction route = 2 [(validate.rules).message = {required: true}];
}

message RouteMatch {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.thrift_proxy.v2alpha1.RouteMatch";

  oneof match_specifier {
    option (validate.required) = true;

    // If specified, the route must exactly match the request method name. As a special case, an
    // empty string matches any request method name.
    string method_name = 1;

    // If specified, the route must have the service name as the request method name prefix. As a
    // special case, an empty string matches any service name. Only relevant when service
    // multiplexing.
    string service_name = 2;
  }

  // Inverts whatever matching is done in the :ref:`method_name
  // <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.RouteMatch.method_name>` or
  // :ref:`service_name
  // <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.RouteMatch.service_name>` fields.
  // Cannot be combined with wildcard matching as that would result in routes never being matched.
  //
  // .. note::
  //
  //   This does not invert matching done as part of the :ref:`headers field
  //   <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.RouteMatch.headers>` field. To
  //   invert header matching, see :ref:`invert_match
  //   <envoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match>`.
  bool invert = 3;

  // Specifies a set of headers that the route should match on. The router will check the requests
  // headers against all the specified headers in the route config. A match will happen if all the
  // headers in the route are present in the request with the same values (or based on presence if
  // the value field is not in the config). Note that this only applies for Thrift transports and/or
  // protocols that support headers.
  repeated config.route.v3.HeaderMatcher headers = 4;
}

// [#next-free-field: 8]
message RouteAction {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.thrift_proxy.v2alpha1.RouteAction";

  // The router is capable of shadowing traffic from one cluster to another. The current
  // implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
  // respond before returning the response from the primary cluster. All normal statistics are
  // collected for the shadow cluster making this feature useful for testing.
  //
  // .. note::
  //
  //   Shadowing will not be triggered if the primary cluster does not exist.
  message RequestMirrorPolicy {
    // Specifies the cluster that requests will be mirrored to. The cluster must
    // exist in the cluster manager configuration when the route configuration is loaded.
    // If it disappears at runtime, the shadow request will silently be ignored.
    string cluster = 1 [(validate.rules).string = {min_len: 1}];

    // If not specified, all requests to the target cluster will be mirrored.
    //
    // For some fraction N/D, a random number in the range [0,D) is selected. If the
    // number is <= the value of the numerator N, or if the key is not present, the default
    // value, the request will be mirrored.
    config.core.v3.RuntimeFractionalPercent runtime_fraction = 2;
  }

  oneof cluster_specifier {
    option (validate.required) = true;

    // Indicates a single upstream cluster to which the request should be routed
    // to.
    string cluster = 1 [(validate.rules).string = {min_len: 1}];

    // Multiple upstream clusters can be specified for a given route. The
    // request is routed to one of the upstream clusters based on weights
    // assigned to each cluster.
    WeightedCluster weighted_clusters = 2;

    // Envoy will determine the cluster to route to by reading the value of the
    // Thrift header named by cluster_header from the request headers. If the
    // header is not found or the referenced cluster does not exist Envoy will
    // respond with an unknown method exception or an internal error exception,
    // respectively.
    string cluster_header = 6
        [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_VALUE strict: false}];
  }

  // Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
  // the upstream cluster with metadata matching what is set in this field will be considered.
  // Note that this will be merged with what's provided in :ref:`WeightedCluster.metadata_match
  // <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.WeightedCluster.ClusterWeight.metadata_match>`,
  // with values there taking precedence. Keys and values should be provided under the "envoy.lb"
  // metadata key.
  config.core.v3.Metadata metadata_match = 3;

  // Specifies a set of rate limit configurations that could be applied to the route.
  // N.B. Thrift service or method name matching can be achieved by specifying a RequestHeaders
  // action with the header name ":method-name".
  repeated config.route.v3.RateLimit rate_limits = 4;

  // Strip the service prefix from the method name, if there's a prefix. For
  // example, the method call Service:method would end up being just method.
  bool strip_service_name = 5;

  // Indicates that the route has request mirroring policies.
  repeated RequestMirrorPolicy request_mirror_policies = 7;
}

// Allows for specification of multiple upstream clusters along with weights that indicate the
// percentage of traffic to be forwarded to each cluster. The router selects an upstream cluster
// based on these weights.
message WeightedCluster {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.thrift_proxy.v2alpha1.WeightedCluster";

  message ClusterWeight {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.network.thrift_proxy.v2alpha1.WeightedCluster.ClusterWeight";

    // Name of the upstream cluster.
    string name = 1 [(validate.rules).string = {min_len: 1}];

    // When a request matches the route, the choice of an upstream cluster is determined by its
    // weight. The sum of weights across all entries in the clusters array determines the total
    // weight.
    google.protobuf.UInt32Value weight = 2 [(validate.rules).uint32 = {gte: 1}];

    // Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
    // the upstream cluster with metadata matching what is set in this field, combined with what's
    // provided in :ref:`RouteAction's metadata_match
    // <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.RouteAction.metadata_match>`,
    // will be considered. Values here will take precedence. Keys and values should be provided
    // under the "envoy.lb" metadata key.
    config.core.v3.Metadata metadata_match = 3;
  }

  // Specifies one or more upstream clusters associated with the route.
  repeated ClusterWeight clusters = 1 [(validate.rules).repeated = {min_items: 1}];
}
Protocol buffer definitions for the Thrift proxy.
syntax = "proto3";

package envoy.extensions.filters.network.thrift_proxy.v3;

import "envoy/config/accesslog/v3/accesslog.proto";
import "envoy/config/core/v3/config_source.proto";
import "envoy/extensions/filters/network/thrift_proxy/v3/route.proto";

import "google/protobuf/any.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.thrift_proxy.v3";
option java_outer_classname = "ThriftProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/thrift_proxy/v3;thrift_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Thrift Proxy]
// Thrift Proxy :ref:`configuration overview <config_network_filters_thrift_proxy>`.
// [#extension: envoy.filters.network.thrift_proxy]

// Thrift transport types supported by Envoy.
enum TransportType {
  // For downstream connections, the Thrift proxy will attempt to determine which transport to use.
  // For upstream connections, the Thrift proxy will use same transport as the downstream
  // connection.
  AUTO_TRANSPORT = 0;

  // The Thrift proxy will use the Thrift framed transport.
  FRAMED = 1;

  // The Thrift proxy will use the Thrift unframed transport.
  UNFRAMED = 2;

  // The Thrift proxy will assume the client is using the Thrift header transport.
  HEADER = 3;
}

// Thrift Protocol types supported by Envoy.
enum ProtocolType {
  // For downstream connections, the Thrift proxy will attempt to determine which protocol to use.
  // Note that the older, non-strict (or lax) binary protocol is not included in automatic protocol
  // detection. For upstream connections, the Thrift proxy will use the same protocol as the
  // downstream connection.
  AUTO_PROTOCOL = 0;

  // The Thrift proxy will use the Thrift binary protocol.
  BINARY = 1;

  // The Thrift proxy will use Thrift non-strict binary protocol.
  LAX_BINARY = 2;

  // The Thrift proxy will use the Thrift compact protocol.
  COMPACT = 3;

  // The Thrift proxy will use the Thrift "Twitter" protocol implemented by the finagle library.
  TWITTER = 4 [deprecated = true, (envoy.annotations.deprecated_at_minor_version_enum) = "3.0"];
}

message Trds {
  // Configuration source specifier.
  // In case of ``api_config_source`` only aggregated ``api_type`` is supported.
  config.core.v3.ConfigSource config_source = 1 [(validate.rules).message = {required: true}];

  // The name of the route configuration. This allows to use different route
  // configurations. Tells which route configuration should be fetched from the configuration source.
  // Leave unspecified is also valid and means the unnamed route configuration.
  string route_config_name = 2;
}

// [#next-free-field: 11]
message ThriftProxy {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.thrift_proxy.v2alpha1.ThriftProxy";

  // Supplies the type of transport that the Thrift proxy should use. Defaults to
  // :ref:`AUTO_TRANSPORT<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.TransportType.AUTO_TRANSPORT>`.
  TransportType transport = 2 [(validate.rules).enum = {defined_only: true}];

  // Supplies the type of protocol that the Thrift proxy should use. Defaults to
  // :ref:`AUTO_PROTOCOL<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.ProtocolType.AUTO_PROTOCOL>`.
  ProtocolType protocol = 3 [(validate.rules).enum = {defined_only: true}];

  // The human readable prefix to use when emitting statistics.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // The route table for the connection manager is static and is specified in this property.
  // It is invalid to define both ``route_config`` and ``trds``.
  RouteConfiguration route_config = 4
      [(udpa.annotations.field_migrate).oneof_promotion = "route_specifier"];

  // Use xDS to fetch the route configuration. It is invalid to define both ``route_config`` and ``trds``.
  Trds trds = 8 [(udpa.annotations.field_migrate).oneof_promotion = "route_specifier"];

  // A list of individual Thrift filters that make up the filter chain for requests made to the
  // Thrift proxy. Order matters as the filters are processed sequentially. For backwards
  // compatibility, if no thrift_filters are specified, a default Thrift router filter
  // (``envoy.filters.thrift.router``) is used.
  // [#extension-category: envoy.thrift_proxy.filters]
  repeated ThriftFilter thrift_filters = 5;

  // If set to true, Envoy will try to skip decode data after metadata in the Thrift message.
  // This mode will only work if the upstream and downstream protocols are the same and the transports
  // are Framed or Header, and the protocol is not Twitter. Otherwise Envoy will
  // fallback to decode the data.
  bool payload_passthrough = 6;

  // Optional maximum requests for a single downstream connection. If not specified, there is no limit.
  google.protobuf.UInt32Value max_requests_per_connection = 7;

  // Configuration for :ref:`access logs <arch_overview_access_logs>`
  // emitted by Thrift proxy.
  repeated config.accesslog.v3.AccessLog access_log = 9;

  // If set to true, Envoy will preserve the case of Thrift header keys instead of serializing them to
  // lower case as per the default behavior. Note that NUL, CR and LF characters will also be preserved
  // as mandated by the Thrift spec.
  //
  // More info: https://github.com/apache/thrift/commit/e165fa3c85d00cb984f4d9635ed60909a1266ce1.
  bool header_keys_preserve_case = 10;
}

// ThriftFilter configures a Thrift filter.
message ThriftFilter {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.thrift_proxy.v2alpha1.ThriftFilter";

  reserved 2;

  reserved "config";

  // The name of the filter to instantiate. The name must match a supported
  // filter. The built-in filters are:
  //
  // [#comment:TODO(zuercher): Auto generate the following list]
  // * :ref:`envoy.filters.thrift.router <config_thrift_filters_router>`
  // * :ref:`envoy.filters.thrift.rate_limit <config_thrift_filters_rate_limit>`
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // Filter specific configuration which depends on the filter being instantiated. See the supported
  // filters for further documentation.
  oneof config_type {
    google.protobuf.Any typed_config = 3;
  }
}

// ThriftProtocolOptions specifies Thrift upstream protocol options. This object is used in
// in
// :ref:`typed_extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`,
// keyed by the name ``envoy.filters.network.thrift_proxy``.
message ThriftProtocolOptions {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.thrift_proxy.v2alpha1.ThriftProtocolOptions";

  // Supplies the type of transport that the Thrift proxy should use for upstream connections.
  // Selecting
  // :ref:`AUTO_TRANSPORT<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.TransportType.AUTO_TRANSPORT>`,
  // which is the default, causes the proxy to use the same transport as the downstream connection.
  TransportType transport = 1 [(validate.rules).enum = {defined_only: true}];

  // Supplies the type of protocol that the Thrift proxy should use for upstream connections.
  // Selecting
  // :ref:`AUTO_PROTOCOL<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.ProtocolType.AUTO_PROTOCOL>`,
  // which is the default, causes the proxy to use the same protocol as the downstream connection.
  ProtocolType protocol = 2 [(validate.rules).enum = {defined_only: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/accesslog/v3:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/config/route/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.network.thrift_proxy.router.v3;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.thrift_proxy.router.v3";
option java_outer_classname = "RouterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/thrift_proxy/router/v3;routerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Router]
// Thrift router :ref:`configuration overview <config_thrift_filters_router>`.
// [#extension: envoy.filters.thrift.router]

message Router {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.thrift.router.v2alpha1.Router";

  // Close downstream connection in case of routing or upstream connection problem. Default: true
  google.protobuf.BoolValue close_downstream_on_upstream_error = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.common.dependency.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.common.dependency.v3";
option java_outer_classname = "DependencyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/dependency/v3;dependencyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Filter dependency specification]

// Dependency specification and string identifier.
message Dependency {
  enum DependencyType {
    HEADER = 0;
    FILTER_STATE_KEY = 1;
    DYNAMIC_METADATA = 2;
  }

  // The kind of dependency.
  DependencyType type = 1;

  // The string identifier for the dependency.
  string name = 2 [(validate.rules).string = {min_len: 1}];
}

// Dependency specification for a filter. For a filter chain to be valid, any
// dependency that is required must be provided by an earlier filter.
message FilterDependencies {
  // A list of dependencies required on the decode path.
  repeated Dependency decode_required = 1;

  // A list of dependencies provided on the encode path.
  repeated Dependency decode_provided = 2;

  // A list of dependencies required on the decode path.
  repeated Dependency encode_required = 3;

  // A list of dependencies provided on the encode path.
  repeated Dependency encode_provided = 4;
}

// Matching requirements for a filter. For a match tree to be used with a filter, the match
// requirements must be satisfied.
//
// This protobuf is provided by the filter implementation as a way to communicate the matching
// requirements to the filter factories, allowing for config rejection if the requirements are
// not satisfied.
message MatchingRequirements {
  message DataInputAllowList {
    // An explicit list of data inputs that are allowed to be used with this filter.
    repeated string type_url = 1;
  }

  DataInputAllowList data_input_allow_list = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.common.matcher.action.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.common.matcher.action.v3";
option java_outer_classname = "SkipActionProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/matcher/action/v3;actionv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common match actions]

// Configuration for the SkipFilter match action. When matching results in this action, the
// associated filter will be ignored for all filter callbacks (e.g. ``encodeHeaders``, ``encodeData``,
// etc. for HTTP filters) after the matcher arrives at the match, including the callback that
// caused the match result. For example, when used with a HTTP filter and the match result was
// resolved after receiving the HTTP response headers, the HTTP filter will *not* receive the
// response header callback.
//
// As a result, if this match action is resolved before the first filter callback (e.g. HTTP request
// headers), the filter will be completely skipped.
message SkipFilter {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.common.fault.v3;

import "envoy/type/v3/percent.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.common.fault.v3";
option java_outer_classname = "FaultProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/fault/v3;faultv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common fault injection types]

// Delay specification is used to inject latency into the
// HTTP/Mongo operation.
// [#next-free-field: 6]
message FaultDelay {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.fault.v2.FaultDelay";

  enum FaultDelayType {
    // Unused and deprecated.
    FIXED = 0;
  }

  // Fault delays are controlled via an HTTP header (if applicable). See the
  // :ref:`HTTP fault filter <config_http_filters_fault_injection_http_header>` documentation for
  // more information.
  message HeaderDelay {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.fault.v2.FaultDelay.HeaderDelay";
  }

  reserved 2, 1;

  reserved "type";

  oneof fault_delay_secifier {
    option (validate.required) = true;

    // Add a fixed delay before forwarding the operation upstream. See
    // https://developers.google.com/protocol-buffers/docs/proto3#json for
    // the JSON/YAML Duration mapping. For HTTP/Mongo, the specified
    // delay will be injected before a new request/operation.
    // This is required if type is FIXED.
    google.protobuf.Duration fixed_delay = 3 [(validate.rules).duration = {gt {}}];

    // Fault delays are controlled via an HTTP header (if applicable).
    HeaderDelay header_delay = 5;
  }

  // The percentage of operations/connections/requests on which the delay will be injected.
  type.v3.FractionalPercent percentage = 4;
}

// Describes a rate limit to be applied.
message FaultRateLimit {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.fault.v2.FaultRateLimit";

  // Describes a fixed/constant rate limit.
  message FixedLimit {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.fault.v2.FaultRateLimit.FixedLimit";

    // The limit supplied in KiB/s.
    uint64 limit_kbps = 1 [(validate.rules).uint64 = {gte: 1}];
  }

  // Rate limits are controlled via an HTTP header (if applicable). See the
  // :ref:`HTTP fault filter <config_http_filters_fault_injection_http_header>` documentation for
  // more information.
  message HeaderLimit {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.fault.v2.FaultRateLimit.HeaderLimit";
  }

  oneof limit_type {
    option (validate.required) = true;

    // A fixed rate limit.
    FixedLimit fixed_limit = 1;

    // Rate limits are controlled via an HTTP header (if applicable).
    HeaderLimit header_limit = 3;
  }

  // The percentage of operations/connections/requests on which the rate limit will be injected.
  type.v3.FractionalPercent percentage = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.common.set_filter_state.v3;

import "envoy/config/core/v3/substitution_format_string.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.common.set_filter_state.v3";
option java_outer_classname = "ValueProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/common/set_filter_state/v3;set_filter_statev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Set-Filter-State filter state value]

// A filter state key and value pair.
// [#next-free-field: 7]
message FilterStateValue {
  enum SharedWithUpstream {
    // Object is not shared with the upstream internal connections.
    NONE = 0;

    // Object is shared with the upstream internal connection.
    ONCE = 1;

    // Object is shared with the upstream internal connection and any internal connection upstream from it.
    TRANSITIVE = 2;
  }

  oneof key {
    option (validate.required) = true;

    // Filter state object key. The key is used to lookup the object factory, unless :ref:`factory_key
    // <envoy_v3_api_field_extensions.filters.common.set_filter_state.v3.FilterStateValue.factory_key>` is set. See
    // :ref:`the well-known filter state keys <well_known_filter_state>` for a list of valid object keys.
    string object_key = 1 [(validate.rules).string = {min_len: 1}];
  }

  // Optional filter object factory lookup key. See :ref:`the well-known filter state keys <well_known_filter_state>`
  // for a list of valid factory keys.
  string factory_key = 6;

  oneof value {
    option (validate.required) = true;

    // Uses the :ref:`format string <config_access_log_format_strings>` to
    // instantiate the filter state object value.
    config.core.v3.SubstitutionFormatString format_string = 2;
  }

  // If marked as read-only, the filter state key value is locked, and cannot
  // be overridden by any filter, including this filter.
  bool read_only = 3;

  // Configures the object to be shared with the upstream internal connections. See :ref:`internal upstream
  // transport <config_internal_upstream_transport>` for more details on the filter state sharing with
  // the internal connections.
  SharedWithUpstream shared_with_upstream = 4;

  // Skip the update if the value evaluates to an empty string.
  // This option can be used to supply multiple alternatives for the same filter state object key.
  bool skip_if_empty = 5;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.header_to_metadata.v3;

import "envoy/type/matcher/v3/regex.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.header_to_metadata.v3";
option java_outer_classname = "HeaderToMetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/header_to_metadata/v3;header_to_metadatav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Header-To-Metadata Filter]
//
// The configuration for transforming headers into metadata. This is useful
// for matching load balancer subsets, logging, etc.
//
// Header to Metadata :ref:`configuration overview <config_http_filters_header_to_metadata>`.
// [#extension: envoy.filters.http.header_to_metadata]

message Config {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.header_to_metadata.v2.Config";

  enum ValueType {
    STRING = 0;

    NUMBER = 1;

    // The value is a serialized `protobuf.Value
    // <https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/struct.proto#L62>`_.
    PROTOBUF_VALUE = 2;
  }

  // ValueEncode defines the encoding algorithm.
  enum ValueEncode {
    // The value is not encoded.
    NONE = 0;

    // The value is encoded in `Base64 <https://tools.ietf.org/html/rfc4648#section-4>`_.
    // Note: this is mostly used for STRING and PROTOBUF_VALUE to escape the
    // non-ASCII characters in the header.
    BASE64 = 1;
  }

  // [#next-free-field: 7]
  message KeyValuePair {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.http.header_to_metadata.v2.Config.KeyValuePair";

    // The namespace  if this is empty, the filter's namespace will be used.
    string metadata_namespace = 1;

    // The key to use within the namespace.
    string key = 2 [(validate.rules).string = {min_len: 1}];

    // The value to pair with the given key.
    //
    // When used for a
    // :ref:`on_header_present <envoy_v3_api_field_extensions.filters.http.header_to_metadata.v3.Config.Rule.on_header_present>`
    // case, if value is non-empty it'll be used instead of the header value. If both are empty, no metadata is added.
    //
    // When used for a :ref:`on_header_missing <envoy_v3_api_field_extensions.filters.http.header_to_metadata.v3.Config.Rule.on_header_missing>`
    // case, a non-empty value must be provided otherwise no metadata is added.
    string value = 3 [(udpa.annotations.field_migrate).oneof_promotion = "value_type"];

    // If present, the header's value will be matched and substituted with this. If there is no match or substitution, the header value
    // is used as-is.
    //
    // This is only used for :ref:`on_header_present <envoy_v3_api_field_extensions.filters.http.header_to_metadata.v3.Config.Rule.on_header_present>`.
    //
    // Note: if the ``value`` field is non-empty this field should be empty.
    type.matcher.v3.RegexMatchAndSubstitute regex_value_rewrite = 6
        [(udpa.annotations.field_migrate).oneof_promotion = "value_type"];

    // The value's type  defaults to string.
    ValueType type = 4 [(validate.rules).enum = {defined_only: true}];

    // How is the value encoded, default is NONE (not encoded).
    // The value will be decoded accordingly before storing to metadata.
    ValueEncode encode = 5;
  }

  // A Rule defines what metadata to apply when a header is present or missing.
  // [#next-free-field: 6]
  message Rule {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.http.header_to_metadata.v2.Config.Rule";

    // Specifies that a match will be performed on the value of a header or a cookie.
    //
    // The header to be extracted.
    string header = 1 [
      (validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false},
      (udpa.annotations.field_migrate).oneof_promotion = "header_cookie_specifier"
    ];

    // The cookie to be extracted.
    string cookie = 5 [
      (validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false},
      (udpa.annotations.field_migrate).oneof_promotion = "header_cookie_specifier"
    ];

    // If the header or cookie is present, apply this metadata KeyValuePair.
    //
    // If the value in the KeyValuePair is non-empty, it'll be used instead
    // of the header or cookie value.
    KeyValuePair on_header_present = 2 [(udpa.annotations.field_migrate).rename = "on_present"];

    // If the header or cookie is not present, apply this metadata KeyValuePair.
    //
    // The value in the KeyValuePair must be set, since it'll be used in lieu
    // of the missing header or cookie value.
    KeyValuePair on_header_missing = 3 [(udpa.annotations.field_migrate).rename = "on_missing"];

    // Whether or not to remove the header after a rule is applied.
    //
    // This prevents headers from leaking.
    // This field is not supported in case of a cookie.
    bool remove = 4;
  }

  // The list of rules to apply to requests.
  repeated Rule request_rules = 1;

  // The list of rules to apply to responses.
  repeated Rule response_rules = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/rbac/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
        "@com_github_cncf_xds//xds/type/matcher/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.rbac.v3;

import "envoy/config/rbac/v3/rbac.proto";

import "xds/annotations/v3/status.proto";
import "xds/type/matcher/v3/matcher.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.rbac.v3";
option java_outer_classname = "RbacProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/rbac/v3;rbacv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: RBAC]
// Role-Based Access Control :ref:`configuration overview <config_http_filters_rbac>`.
// [#extension: envoy.filters.http.rbac]

// RBAC filter config.
// [#next-free-field: 6]
message RBAC {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.rbac.v2.RBAC";

  // Specify the RBAC rules to be applied globally.
  // If absent, no enforcing RBAC policy will be applied.
  // If present and empty, DENY.
  // If both rules and matcher are configured, rules will be ignored.
  config.rbac.v3.RBAC rules = 1
      [(udpa.annotations.field_migrate).oneof_promotion = "rules_specifier"];

  // The match tree to use when resolving RBAC action for incoming requests. Requests do not
  // match any matcher will be denied.
  // If absent, no enforcing RBAC matcher will be applied.
  // If present and empty, deny all requests.
  xds.type.matcher.v3.Matcher matcher = 4 [
    (udpa.annotations.field_migrate).oneof_promotion = "rules_specifier",
    (xds.annotations.v3.field_status).work_in_progress = true
  ];

  // Shadow rules are not enforced by the filter (i.e., returning a 403)
  // but will emit stats and logs and can be used for rule testing.
  // If absent, no shadow RBAC policy will be applied.
  // If both shadow rules and shadow matcher are configured, shadow rules will be ignored.
  config.rbac.v3.RBAC shadow_rules = 2
      [(udpa.annotations.field_migrate).oneof_promotion = "shadow_rules_specifier"];

  // The match tree to use for emitting stats and logs which can be used for rule testing for
  // incoming requests.
  // If absent, no shadow matcher will be applied.
  xds.type.matcher.v3.Matcher shadow_matcher = 5 [
    (udpa.annotations.field_migrate).oneof_promotion = "shadow_rules_specifier",
    (xds.annotations.v3.field_status).work_in_progress = true
  ];

  // If specified, shadow rules will emit stats with the given prefix.
  // This is useful to distinguish the stat when there are more than 1 RBAC filter configured with
  // shadow rules.
  string shadow_rules_stat_prefix = 3;
}

message RBACPerRoute {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.rbac.v2.RBACPerRoute";

  reserved 1;

  // Override the global configuration of the filter with this new config.
  // If absent, the global RBAC policy will be disabled for this route.
  RBAC rbac = 2;
}
syntax = "proto3";

package envoy.extensions.filters.http.grpc_json_transcoder.v3;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.grpc_json_transcoder.v3";
option java_outer_classname = "TranscoderProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_json_transcoder/v3;grpc_json_transcoderv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: gRPC-JSON transcoder]
// gRPC-JSON transcoder :ref:`configuration overview <config_http_filters_grpc_json_transcoder>`.
// [#extension: envoy.filters.http.grpc_json_transcoder]

// [#next-free-field: 17]
// GrpcJsonTranscoder filter configuration.
// The filter itself can be used per route / per virtual host or on the general level. The most
// specific one is being used for a given route. If the list of services is empty - filter
// is considered to be disabled.
// Note that if specifying the filter per route, first the route is matched, and then transcoding
// filter is applied. It matters when specifying the route configuration and paths to match the
// request - for per-route grpc transcoder configs, the original path should be matched, while
// in other cases, the grpc-like path is expected (the one AFTER the filter is applied).
message GrpcJsonTranscoder {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.transcoder.v2.GrpcJsonTranscoder";

  enum UrlUnescapeSpec {
    // URL path parameters will not decode RFC 6570 reserved characters.
    // For example, segment ``%2f%23/%20%2523`` is unescaped to ``%2f%23/ %23``.
    ALL_CHARACTERS_EXCEPT_RESERVED = 0;

    // URL path parameters will be fully URI-decoded except in
    // cases of single segment matches in reserved expansion, where ``%2F`` will be
    // left encoded.
    // For example, segment ``%2f%23/%20%2523`` is unescaped to ``%2f#/ %23``.
    ALL_CHARACTERS_EXCEPT_SLASH = 1;

    // URL path parameters will be fully URI-decoded.
    // For example, segment ``%2f%23/%20%2523`` is unescaped to ``/#/ %23``.
    ALL_CHARACTERS = 2;
  }

  // [#next-free-field: 6]
  message PrintOptions {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.http.transcoder.v2.GrpcJsonTranscoder.PrintOptions";

    // Whether to add spaces, line breaks and indentation to make the JSON
    // output easy to read. Defaults to false.
    bool add_whitespace = 1;

    // Whether to always print primitive fields. By default primitive
    // fields with default values will be omitted in JSON output. For
    // example, an int32 field set to 0 will be omitted. Setting this flag to
    // true will override the default behavior and print primitive fields
    // regardless of their values. Defaults to false.
    bool always_print_primitive_fields = 2;

    // Whether to always print enums as ints. By default they are rendered
    // as strings. Defaults to false.
    bool always_print_enums_as_ints = 3;

    // Whether to preserve proto field names. By default protobuf will
    // generate JSON field names using the ``json_name`` option, or lower camel case,
    // in that order. Setting this flag will preserve the original field names. Defaults to false.
    bool preserve_proto_field_names = 4;

    // If true, return all streams as newline-delimited JSON messages instead of as a comma-separated array
    bool stream_newline_delimited = 5;
  }

  message RequestValidationOptions {
    // By default, a request that cannot be mapped to any specified gRPC
    // :ref:`services <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.services>`
    // will pass-through this filter.
    // When set to true, the request will be rejected with a ``HTTP 404 Not Found``.
    bool reject_unknown_method = 1;

    // By default, a request with query parameters that cannot be mapped to the gRPC request message
    // will pass-through this filter.
    // When set to true, the request will be rejected with a ``HTTP 400 Bad Request``.
    //
    // The fields
    // :ref:`ignore_unknown_query_parameters <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.ignore_unknown_query_parameters>`
    // and
    // :ref:`ignored_query_parameters <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.ignored_query_parameters>`
    // have priority over this strict validation behavior.
    bool reject_unknown_query_parameters = 2;

    // By default, transcoding will default to the value in the body if there
    // are conflict values in the bindings. For example,
    //
    // post: '/resources/a?id=123'
    // body: {
    //         id: 456,
    // }

    // "id: 456" in the body will override "id=123" in the binding.
    //
    // If this field is set to true, the request will be rejected if the binding
    // value is different from the body value.
    bool reject_binding_body_field_collisions = 3;
  }

  oneof descriptor_set {
    option (validate.required) = true;

    // Supplies the filename of
    // :ref:`the proto descriptor set <config_grpc_json_generate_proto_descriptor_set>` for the gRPC
    // services.
    string proto_descriptor = 1;

    // Supplies the binary content of
    // :ref:`the proto descriptor set <config_grpc_json_generate_proto_descriptor_set>` for the gRPC
    // services.
    bytes proto_descriptor_bin = 4;
  }

  // A list of strings that
  // supplies the fully qualified service names (i.e. "package_name.service_name") that
  // the transcoder will translate. If the service name doesn't exist in ``proto_descriptor``,
  // Envoy will fail at startup. The ``proto_descriptor`` may contain more services than
  // the service names specified here, but they won't be translated.
  //
  // By default, the filter will pass through requests that do not map to any specified services.
  // If the list of services is empty, filter is considered disabled.
  // However, this behavior changes if
  // :ref:`reject_unknown_method <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.RequestValidationOptions.reject_unknown_method>`
  // is enabled.
  repeated string services = 2;

  // Control options for response JSON. These options are passed directly to
  // `JsonPrintOptions <https://developers.google.com/protocol-buffers/docs/reference/cpp/
  // google.protobuf.util.json_util#JsonPrintOptions>`_.
  PrintOptions print_options = 3;

  // Whether to keep the incoming request route after the outgoing headers have been transformed to
  // the match the upstream gRPC service. Note: This means that routes for gRPC services that are
  // not transcoded cannot be used in combination with ``match_incoming_request_route``.
  bool match_incoming_request_route = 5;

  // A list of query parameters to be ignored for transcoding method mapping.
  // By default, the transcoder filter will not transcode a request if there are any
  // unknown/invalid query parameters.
  //
  // Example :
  //
  // .. code-block:: proto
  //
  //     service Bookstore {
  //       rpc GetShelf(GetShelfRequest) returns (Shelf) {
  //         option (google.api.http) = {
  //           get: "/shelves/{shelf}"
  //         };
  //       }
  //     }
  //
  //     message GetShelfRequest {
  //       int64 shelf = 1;
  //     }
  //
  //     message Shelf {}
  //
  // The request ``/shelves/100?foo=bar`` will not be mapped to ``GetShelf``` because variable
  // binding for ``foo`` is not defined. Adding ``foo`` to ``ignored_query_parameters`` will allow
  // the same request to be mapped to ``GetShelf``.
  repeated string ignored_query_parameters = 6;

  // Whether to route methods without the ``google.api.http`` option.
  //
  // Example :
  //
  // .. code-block:: proto
  //
  //     package bookstore;
  //
  //     service Bookstore {
  //       rpc GetShelf(GetShelfRequest) returns (Shelf) {}
  //     }
  //
  //     message GetShelfRequest {
  //       int64 shelf = 1;
  //     }
  //
  //     message Shelf {}
  //
  // The client could ``post`` a json body ``{"shelf": 1234}`` with the path of
  // ``/bookstore.Bookstore/GetShelfRequest`` to call ``GetShelfRequest``.
  bool auto_mapping = 7;

  // Whether to ignore query parameters that cannot be mapped to a corresponding
  // protobuf field. Use this if you cannot control the query parameters and do
  // not know them beforehand. Otherwise use ``ignored_query_parameters``.
  // Defaults to false.
  bool ignore_unknown_query_parameters = 8;

  // Whether to convert gRPC status headers to JSON.
  // When trailer indicates a gRPC error and there was no HTTP body, take ``google.rpc.Status``
  // from the ``grpc-status-details-bin`` header and use it as JSON body.
  // If there was no such header, make ``google.rpc.Status`` out of the ``grpc-status`` and
  // ``grpc-message`` headers.
  // The error details types must be present in the ``proto_descriptor``.
  //
  // For example, if an upstream server replies with headers:
  //
  // .. code-block:: none
  //
  //     grpc-status: 5
  //     grpc-status-details-bin:
  //         CAUaMwoqdHlwZS5nb29nbGVhcGlzLmNvbS9nb29nbGUucnBjLlJlcXVlc3RJbmZvEgUKA3ItMQ
  //
  // The ``grpc-status-details-bin`` header contains a base64-encoded protobuf message
  // ``google.rpc.Status``. It will be transcoded into:
  //
  // .. code-block:: none
  //
  //     HTTP/1.1 404 Not Found
  //     content-type: application/json
  //
  //     {"code":5,"details":[{"@type":"type.googleapis.com/google.rpc.RequestInfo","requestId":"r-1"}]}
  //
  // In order to transcode the message, the ``google.rpc.RequestInfo`` type from
  // the ``google/rpc/error_details.proto`` should be included in the configured
  // :ref:`proto descriptor set <config_grpc_json_generate_proto_descriptor_set>`.
  bool convert_grpc_status = 9;

  // URL unescaping policy.
  // This spec is only applied when extracting variable with multiple segments in the URL path.
  // For example, in case of ``/foo/{x=*}/bar/{y=prefix/*}/{z=**}`` ``x`` variable is single segment and ``y`` and ``z`` are multiple segments.
  // For a path with ``/foo/first/bar/prefix/second/third/fourth``, ``x=first``, ``y=prefix/second``, ``z=third/fourth``.
  // If this setting is not specified, the value defaults to :ref:`ALL_CHARACTERS_EXCEPT_RESERVED<envoy_v3_api_enum_value_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.UrlUnescapeSpec.ALL_CHARACTERS_EXCEPT_RESERVED>`.
  UrlUnescapeSpec url_unescape_spec = 10 [(validate.rules).enum = {defined_only: true}];

  // If true, unescape '+' to space when extracting variables in query parameters.
  // This is to support `HTML 2.0 <https://tools.ietf.org/html/rfc1866#section-8.2.1>`_
  bool query_param_unescape_plus = 12;

  // If true, try to match the custom verb even if it is unregistered. By
  // default, only match when it is registered.
  //
  // According to the http template `syntax <https://github.com/googleapis/googleapis/blob/master/google/api/http.proto#L226-L231>`_,
  // the custom verb is **":" LITERAL** at the end of http template.
  //
  // For a request with ``/foo/bar:baz`` and ``:baz`` is not registered in any url_template, here is the behavior change
  // - if the field is not set, ``:baz`` will not be treated as custom verb, so it will match ``/foo/{x=*}``.
  // - if the field is set, ``:baz`` is treated as custom verb,  so it will NOT match ``/foo/{x=*}`` since the template doesn't use any custom verb.
  bool match_unregistered_custom_verb = 13;

  // Configure the behavior when handling requests that cannot be transcoded.
  //
  // By default, the transcoder will silently pass through HTTP requests that are malformed.
  // This includes requests with unknown query parameters, unregister paths, etc.
  //
  // Set these options to enable strict HTTP request validation, resulting in the transcoder rejecting
  // such requests with a ``HTTP 4xx``. See each individual option for more details on the validation.
  // gRPC requests will still silently pass through without transcoding.
  //
  // The benefit is a proper error message to the downstream.
  // If the upstream is a gRPC server, it cannot handle the passed-through HTTP requests and will reset
  // the TCP connection. The downstream will then
  // receive a ``HTTP 503 Service Unavailable`` due to the upstream connection reset.
  // This incorrect error message may conflict with other Envoy components, such as retry policies.
  RequestValidationOptions request_validation_options = 11;

  // Proto enum values are supposed to be in upper cases when used in JSON.
  // Set this to true if your JSON request uses non uppercase enum values.
  bool case_insensitive_enum_parsing = 14;

  // The maximum size of a request body to be transcoded, in bytes. A body exceeding this size will
  // provoke a ``HTTP 413 Request Entity Too Large`` response.
  //
  // Large values may cause envoy to use a lot of memory if there are many concurrent requests.
  //
  // If unset, the current stream buffer size is used.
  google.protobuf.UInt32Value max_request_body_size = 15 [(validate.rules).uint32 = {gt: 0}];

  // The maximum size of a response body to be transcoded, in bytes. A body exceeding this size will
  // provoke a ``HTTP 500 Internal Server Error`` response.
  //
  // Large values may cause envoy to use a lot of memory if there are many concurrent requests.
  //
  // If unset, the current stream buffer size is used.
  google.protobuf.UInt32Value max_response_body_size = 16 [(validate.rules).uint32 = {gt: 0}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.http.grpc_http1_bridge.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.grpc_http1_bridge.v3";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_http1_bridge/v3;grpc_http1_bridgev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: gRPC HTTP/1.1 Bridge]
// gRPC HTTP/1.1 Bridge Filter :ref:`configuration overview <config_http_filters_grpc_bridge>`.
// [#extension: envoy.filters.http.grpc_http1_bridge]

// gRPC HTTP/1.1 Bridge filter config.
message Config {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.grpc_http1_bridge.v2.Config";

  // If true then requests with content type set to ``application/x-protobuf`` will be automatically converted to gRPC.
  // This works by prepending the payload data with the gRPC header frame, as defined by the wiring format, and
  // Content-Type will be updated accordingly before sending the request.
  // For the requests that went through this upgrade the filter will also strip the frame before forwarding the
  // response to the client.
  bool upgrade_protobuf_to_grpc = 1;

  // If true then query parameters in request's URL path will be removed.
  bool ignore_query_parameters = 2;
}
syntax = "proto3";

package envoy.extensions.filters.http.on_demand.v3;

import "envoy/config/core/v3/config_source.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.on_demand.v3";
option java_outer_classname = "OnDemandProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/on_demand/v3;on_demandv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: On Demand Discovery]
// On Demand Discovery :ref:`configuration overview <config_http_filters_on_demand>`.
// [#extension: envoy.filters.http.on_demand]
//
// .. warning::
//
//    Envoy currently only supports On-demand CDS when using Incremental-xDS and not State-of-the-World.
//

// Configuration of on-demand CDS.
message OnDemandCds {
  // A configuration source for the service that will be used for
  // on-demand cluster discovery.
  config.core.v3.ConfigSource source = 1 [(validate.rules).message = {required: true}];

  // xdstp:// resource locator for on-demand cluster collection.
  string resources_locator = 2;

  // The timeout for on demand cluster lookup. If not set, defaults to 5 seconds.
  google.protobuf.Duration timeout = 3;
}

// On Demand Discovery filter config.
message OnDemand {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.on_demand.v2.OnDemand";

  // An optional configuration for on-demand cluster discovery
  // service. If not specified, the on-demand cluster discovery will
  // be disabled. When it's specified, the filter will pause the
  // request to an unknown cluster and will begin a cluster discovery
  // process. When the discovery is finished (successfully or not), the
  // request will be resumed for further processing.
  OnDemandCds odcds = 1;
}

// Per-route configuration for On Demand Discovery.
message PerRouteConfig {
  // An optional configuration for on-demand cluster discovery
  // service. If not specified, the on-demand cluster discovery will
  // be disabled. When it's specified, the filter will pause the
  // request to an unknown cluster and will begin a cluster discovery
  // process. When the discovery is finished (successfully or not), the
  // request will be resumed for further processing.
  OnDemandCds odcds = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/extensions/common/ratelimit/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.local_ratelimit.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/extensions/common/ratelimit/v3/ratelimit.proto";
import "envoy/type/v3/http_status.proto";
import "envoy/type/v3/token_bucket.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.local_ratelimit.v3";
option java_outer_classname = "LocalRateLimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/local_ratelimit/v3;local_ratelimitv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Local Rate limit]
// Local Rate limit :ref:`configuration overview <config_http_filters_local_rate_limit>`.
// [#extension: envoy.filters.http.local_ratelimit]

// [#next-free-field: 16]
message LocalRateLimit {
  // The human readable prefix to use when emitting stats.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // This field allows for a custom HTTP response status code to the downstream client when
  // the request has been rate limited.
  // Defaults to 429 (TooManyRequests).
  //
  // .. note::
  //   If this is set to < 400, 429 will be used instead.
  type.v3.HttpStatus status = 2;

  // The token bucket configuration to use for rate limiting requests that are processed by this
  // filter. Each request processed by the filter consumes a single token. If the token is available,
  // the request will be allowed. If no tokens are available, the request will receive the configured
  // rate limit status.
  //
  // .. note::
  //   It's fine for the token bucket to be unset for the global configuration since the rate limit
  //   can be applied at a the virtual host or route level. Thus, the token bucket must be set
  //   for the per route configuration otherwise the config will be rejected.
  //
  // .. note::
  //   When using per route configuration, the bucket becomes unique to that route.
  //
  // .. note::
  //   In the current implementation the token bucket's :ref:`fill_interval
  //   <envoy_v3_api_field_type.v3.TokenBucket.fill_interval>` must be >= 50ms to avoid too aggressive
  //   refills.
  type.v3.TokenBucket token_bucket = 3;

  // If set, this will enable -- but not necessarily enforce -- the rate limit for the given
  // fraction of requests.
  // Defaults to 0% of requests for safety.
  config.core.v3.RuntimeFractionalPercent filter_enabled = 4;

  // If set, this will enforce the rate limit decisions for the given fraction of requests.
  //
  // Note: this only applies to the fraction of enabled requests.
  //
  // Defaults to 0% of requests for safety.
  config.core.v3.RuntimeFractionalPercent filter_enforced = 5;

  // Specifies a list of HTTP headers that should be added to each request that
  // has been rate limited and is also forwarded upstream. This can only occur when the
  // filter is enabled but not enforced.
  repeated config.core.v3.HeaderValueOption request_headers_to_add_when_not_enforced = 10
      [(validate.rules).repeated = {max_items: 10}];

  // Specifies a list of HTTP headers that should be added to each response for requests that
  // have been rate limited. This occurs when the filter is enabled and fully enforced.
  repeated config.core.v3.HeaderValueOption response_headers_to_add = 6
      [(validate.rules).repeated = {max_items: 10}];

  // The rate limit descriptor list to use in the local rate limit to override
  // on. The rate limit descriptor is selected by the first full match from the
  // request descriptors.
  //
  // Example on how to use :ref:`this <config_http_filters_local_rate_limit_descriptors>`.
  //
  // .. note::
  //
  //   In the current implementation the descriptor's token bucket :ref:`fill_interval
  //   <envoy_v3_api_field_type.v3.TokenBucket.fill_interval>` must be a multiple
  //   global :ref:`token bucket's<envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.token_bucket>` fill interval.
  //
  //   The descriptors must match verbatim for rate limiting to apply. There is no partial
  //   match by a subset of descriptor entries in the current implementation.
  repeated common.ratelimit.v3.LocalRateLimitDescriptor descriptors = 8;

  // Specifies the rate limit configurations to be applied with the same
  // stage number. If not set, the default stage number is 0.
  //
  // .. note::
  //
  //  The filter supports a range of 0 - 10 inclusively for stage numbers.
  uint32 stage = 9 [(validate.rules).uint32 = {lte: 10}];

  // Specifies the scope of the rate limiter's token bucket.
  // If set to false, the token bucket is shared across all worker threads,
  // thus the rate limits are applied per Envoy process.
  // If set to true, a token bucket is allocated for each connection.
  // Thus the rate limits are applied per connection thereby allowing
  // one to rate limit requests on a per connection basis.
  // If unspecified, the default value is false.
  bool local_rate_limit_per_downstream_connection = 11;

  // Defines the standard version to use for X-RateLimit headers emitted by the filter.
  //
  // Disabled by default.
  common.ratelimit.v3.XRateLimitHeadersRFCVersion enable_x_ratelimit_headers = 12
      [(validate.rules).enum = {defined_only: true}];

  // Specifies if the local rate limit filter should include the virtual host rate limits.
  common.ratelimit.v3.VhRateLimitsOptions vh_rate_limits = 13
      [(validate.rules).enum = {defined_only: true}];

  // Specifies if default token bucket should be always consumed.
  // If set to false, default token bucket will only be consumed when there is
  // no matching descriptor. If set to true, default token bucket will always
  // be consumed. Default is true.
  google.protobuf.BoolValue always_consume_default_token_bucket = 14;

  // Specifies whether a ``RESOURCE_EXHAUSTED`` gRPC code must be returned instead
  // of the default ``UNAVAILABLE`` gRPC code for a rate limited gRPC call. The
  // HTTP code will be 200 for a gRPC response.
  bool rate_limited_as_resource_exhausted = 15;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
        "@com_github_cncf_xds//xds/type/matcher/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.rate_limit_quota.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/grpc_service.proto";
import "envoy/type/v3/http_status.proto";
import "envoy/type/v3/ratelimit_strategy.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";
import "google/rpc/status.proto";

import "xds/annotations/v3/status.proto";
import "xds/type/matcher/v3/matcher.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.rate_limit_quota.v3";
option java_outer_classname = "RateLimitQuotaProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/rate_limit_quota/v3;rate_limit_quotav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: Rate Limit Quota]
// Rate Limit Quota :ref:`configuration overview <config_http_filters_rate_limit_quota>`.
// [#extension: envoy.filters.http.rate_limit_quota]

// Configures the Rate Limit Quota filter.
//
// Can be overridden in the per-route and per-host configurations.
// The more specific definition completely overrides the less specific definition.
// [#next-free-field: 7]
message RateLimitQuotaFilterConfig {
  // Configures the gRPC Rate Limit Quota Service (RLQS) RateLimitQuotaService.
  config.core.v3.GrpcService rlqs_server = 1 [(validate.rules).message = {required: true}];

  // The application domain to use when calling the service. This enables sharing the quota
  // server between different applications without fear of overlap.
  // E.g., "envoy".
  string domain = 2 [(validate.rules).string = {min_len: 1}];

  // The match tree to use for grouping incoming requests into buckets.
  //
  // Example:
  //
  // .. validated-code-block:: yaml
  //   :type-name: xds.type.matcher.v3.Matcher
  //
  //   matcher_list:
  //     matchers:
  //     # Assign requests with header['env'] set to 'staging' to the bucket { name: 'staging' }
  //     - predicate:
  //         single_predicate:
  //           input:
  //             typed_config:
  //               '@type': type.googleapis.com/envoy.type.matcher.v3.HttpRequestHeaderMatchInput
  //               header_name: env
  //           value_match:
  //             exact: staging
  //       on_match:
  //         action:
  //           typed_config:
  //             '@type': type.googleapis.com/envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings
  //             bucket_id_builder:
  //               bucket_id_builder:
  //                 name:
  //                   string_value: staging
  //
  //     # Assign requests with header['user_group'] set to 'admin' to the bucket { acl: 'admin_users' }
  //     - predicate:
  //         single_predicate:
  //           input:
  //             typed_config:
  //               '@type': type.googleapis.com/xds.type.matcher.v3.HttpAttributesCelMatchInput
  //           custom_match:
  //             typed_config:
  //               '@type': type.googleapis.com/xds.type.matcher.v3.CelMatcher
  //               expr_match:
  //                 # Shortened for illustration purposes. Here should be parsed CEL expression:
  //                 # request.headers['user_group'] == 'admin'
  //                 parsed_expr: {}
  //       on_match:
  //         action:
  //           typed_config:
  //             '@type': type.googleapis.com/envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings
  //             bucket_id_builder:
  //               bucket_id_builder:
  //                 acl:
  //                   string_value: admin_users
  //
  //   # Catch-all clause for the requests not matched by any of the matchers.
  //   # In this example, deny all requests.
  //   on_no_match:
  //     action:
  //       typed_config:
  //         '@type': type.googleapis.com/envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings
  //         no_assignment_behavior:
  //           fallback_rate_limit:
  //             blanket_rule: DENY_ALL
  //
  // .. attention::
  //  The first matched group wins. Once the request is matched into a bucket, matcher
  //  evaluation ends.
  //
  // Use ``on_no_match`` field to assign the catch-all bucket. If a request is not matched
  // into any bucket, and there's no  ``on_no_match`` field configured, the request will be
  // ALLOWED by default. It will NOT be reported to the RLQS server.
  //
  // Refer to :ref:`Unified Matcher API <envoy_v3_api_msg_.xds.type.matcher.v3.Matcher>`
  // documentation for more information on the matcher trees.
  xds.type.matcher.v3.Matcher bucket_matchers = 3 [(validate.rules).message = {required: true}];

  // If set, this will enable -- but not necessarily enforce -- the rate limit for the given
  // fraction of requests.
  //
  // Defaults to 100% of requests.
  config.core.v3.RuntimeFractionalPercent filter_enabled = 4;

  // If set, this will enforce the rate limit decisions for the given fraction of requests.
  // For requests that are not enforced the filter will still obtain the quota and include it
  // in the load computation, however the request will always be allowed regardless of the outcome
  // of quota application. This allows validation or testing of the rate limiting service
  // infrastructure without disrupting existing traffic.
  //
  // Note: this only applies to the fraction of enabled requests.
  //
  // Defaults to 100% of requests.
  config.core.v3.RuntimeFractionalPercent filter_enforced = 5;

  // Specifies a list of HTTP headers that should be added to each request that
  // has been rate limited and is also forwarded upstream. This can only occur when the
  // filter is enabled but not enforced.
  repeated config.core.v3.HeaderValueOption request_headers_to_add_when_not_enforced = 6
      [(validate.rules).repeated = {max_items: 10}];
}

// Per-route and per-host configuration overrides. The more specific definition completely
// overrides the less specific definition.
message RateLimitQuotaOverride {
  // The application domain to use when calling the service. This enables sharing the quota
  // server between different applications without fear of overlap.
  // E.g., "envoy".
  //
  // If empty, inherits the value from the less specific definition.
  string domain = 1;

  // The match tree to use for grouping incoming requests into buckets.
  //
  // If set, fully overrides the bucket matchers provided on the less specific definition.
  // If not set, inherits the value from the less specific definition.
  //
  // See usage example: :ref:`RateLimitQuotaFilterConfig.bucket_matchers
  // <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaFilterConfig.bucket_matchers>`.
  xds.type.matcher.v3.Matcher bucket_matchers = 2;
}

// Rate Limit Quota Bucket Settings to apply on the successful ``bucket_matchers`` match.
//
// Specify this message in the :ref:`Matcher.OnMatch.action
// <envoy_v3_api_field_.xds.type.matcher.v3.Matcher.OnMatch.action>` field of the
// ``bucket_matchers`` matcher tree to assign the matched requests to the Quota Bucket.
// Usage example: :ref:`RateLimitQuotaFilterConfig.bucket_matchers
// <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaFilterConfig.bucket_matchers>`.
// [#next-free-field: 6]
message RateLimitQuotaBucketSettings {
  // Configures the behavior after the first request has been matched to the bucket, and before the
  // the RLQS server returns the first quota assignment.
  message NoAssignmentBehavior {
    oneof no_assignment_behavior {
      option (validate.required) = true;

      // Apply pre-configured rate limiting strategy until the server sends the first assignment.
      type.v3.RateLimitStrategy fallback_rate_limit = 1;
    }
  }

  // Specifies the behavior when the bucket's assignment has expired, and cannot be refreshed for
  // any reason.
  message ExpiredAssignmentBehavior {
    // Reuse the last known quota assignment, effectively extending it for the duration
    // specified in the :ref:`expired_assignment_behavior_timeout
    // <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.expired_assignment_behavior_timeout>`
    // field.
    message ReuseLastAssignment {
    }

    // Limit the time :ref:`ExpiredAssignmentBehavior
    // <envoy_v3_api_msg_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior>`
    // is applied. If the server doesn't respond within this duration:
    //
    // 1. Selected ``ExpiredAssignmentBehavior`` is no longer applied.
    // 2. The bucket is abandoned. The process of abandoning the bucket is described in the
    //    :ref:`AbandonAction <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
    //    message.
    // 3. If a new request is matched into the bucket that has become abandoned,
    //    the data plane restarts the subscription to the bucket. The process of restarting the
    //    subscription is described in the :ref:`AbandonAction
    //    <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
    //    message.
    //
    // If not set, defaults to zero, and the bucket is abandoned immediately.
    google.protobuf.Duration expired_assignment_behavior_timeout = 1
        [(validate.rules).duration = {gt {}}];

    oneof expired_assignment_behavior {
      option (validate.required) = true;

      // Apply the rate limiting strategy to all requests matched into the bucket until the RLQS
      // server sends a new assignment, or the :ref:`expired_assignment_behavior_timeout
      // <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.expired_assignment_behavior_timeout>`
      // runs out.
      type.v3.RateLimitStrategy fallback_rate_limit = 2;

      // Reuse the last ``active`` assignment until the RLQS server sends a new assignment, or the
      // :ref:`expired_assignment_behavior_timeout
      // <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.expired_assignment_behavior_timeout>`
      // runs out.
      ReuseLastAssignment reuse_last_assignment = 3;
    }
  }

  // Customize the deny response to the requests over the rate limit.
  message DenyResponseSettings {
    // HTTP response code to deny for HTTP requests (gRPC excluded).
    // Defaults to 429 (:ref:`StatusCode.TooManyRequests<envoy_v3_api_enum_value_type.v3.StatusCode.TooManyRequests>`).
    type.v3.HttpStatus http_status = 1;

    // HTTP response body used to deny for HTTP requests (gRPC excluded).
    // If not set, an empty body is returned.
    google.protobuf.BytesValue http_body = 2;

    // Configure the deny response for gRPC requests over the rate limit.
    // Allows to specify the `RPC status code
    // <https://cloud.google.com/natural-language/docs/reference/rpc/google.rpc#google.rpc.Code>`_,
    // and the error message.
    // Defaults to the Status with the RPC Code ``UNAVAILABLE`` and empty message.
    //
    // To identify gRPC requests, Envoy checks that the ``Content-Type`` header is
    // ``application/grpc``, or one of the various ``application/grpc+`` values.
    //
    // .. note::
    //   The HTTP code for a gRPC response is always 200.
    google.rpc.Status grpc_status = 3;

    // Specifies a list of HTTP headers that should be added to each response for requests that
    // have been rate limited. Applies both to plain HTTP, and gRPC requests.
    // The headers are added even when the rate limit quota was not enforced.
    repeated config.core.v3.HeaderValueOption response_headers_to_add = 4
        [(validate.rules).repeated = {max_items: 10}];
  }

  // ``BucketIdBuilder`` makes it possible to build :ref:`BucketId
  // <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>` with values substituted
  // from the dynamic properties associated with each individual request. See usage examples in
  // the docs to :ref:`bucket_id_builder
  // <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.bucket_id_builder>`
  // field.
  message BucketIdBuilder {
    // Produces the value of the :ref:`BucketId
    // <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>` map.
    message ValueBuilder {
      oneof value_specifier {
        option (validate.required) = true;

        // Static string value  becomes the value in the :ref:`BucketId
        // <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>` map as is.
        string string_value = 1;

        // Dynamic value  evaluated for each request. Must produce a string output, which becomes
        // the value in the :ref:`BucketId <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>`
        // map. For example, extensions with the ``envoy.matching.http.input`` category can be used.
        config.core.v3.TypedExtensionConfig custom_value = 2;
      }
    }

    // The map translated into the ``BucketId`` map.
    //
    // The ``string key`` of this map and becomes the key of ``BucketId`` map as is.
    //
    // The ``ValueBuilder value`` for the key can be:
    //
    // * static ``StringValue string_value``  becomes the value in the ``BucketId`` map as is.
    // * dynamic ``TypedExtensionConfig custom_value``  evaluated for each request. Must produce
    //   a string output, which becomes the value in the the ``BucketId`` map.
    //
    // See usage examples in the docs to :ref:`bucket_id_builder
    // <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.bucket_id_builder>`
    // field.
    map<string, ValueBuilder> bucket_id_builder = 1 [(validate.rules).map = {min_pairs: 1}];
  }

  // ``BucketId`` builder.
  //
  // :ref:`BucketId <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>` is a map from
  // the string key to the string value which serves as bucket identifier common for on
  // the control plane and the data plane.
  //
  // While ``BucketId`` is always static, ``BucketIdBuilder`` allows to populate map values
  // with the dynamic properties associated with the each individual request.
  //
  // Example 1: static fields only
  //
  // ``BucketIdBuilder``:
  //
  // .. validated-code-block:: yaml
  //   :type-name: envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder
  //
  //   bucket_id_builder:
  //     name:
  //       string_value: my_bucket
  //     hello:
  //       string_value: world
  //
  // Produces the following ``BucketId`` for all requests:
  //
  // .. validated-code-block:: yaml
  //   :type-name: envoy.service.rate_limit_quota.v3.BucketId
  //
  //   bucket:
  //     name: my_bucket
  //     hello: world
  //
  // Example 2: static and dynamic fields
  //
  // .. validated-code-block:: yaml
  //   :type-name: envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder
  //
  //   bucket_id_builder:
  //     name:
  //       string_value: my_bucket
  //     env:
  //       custom_value:
  //         typed_config:
  //           '@type': type.googleapis.com/envoy.type.matcher.v3.HttpRequestHeaderMatchInput
  //           header_name: environment
  //
  // In this example, the value of ``BucketId`` key ``env`` is substituted from the ``environment``
  // request header.
  //
  // This is equivalent to the following ``pseudo-code``:
  //
  // .. code-block:: yaml
  //
  //    name: 'my_bucket'
  //    env: $header['environment']
  //
  // For example, the request with the HTTP header ``env`` set to ``staging`` will produce
  // the following ``BucketId``:
  //
  // .. validated-code-block:: yaml
  //   :type-name: envoy.service.rate_limit_quota.v3.BucketId
  //
  //   bucket:
  //     name: my_bucket
  //     env: staging
  //
  // For the request with the HTTP header ``environment`` set to ``prod``, will produce:
  //
  // .. validated-code-block:: yaml
  //   :type-name: envoy.service.rate_limit_quota.v3.BucketId
  //
  //   bucket:
  //     name: my_bucket
  //     env: prod
  //
  // .. note::
  //   The order of ``BucketId`` keys do not matter. Buckets ``{ a: 'A', b: 'B' }`` and
  //   ``{ b: 'B', a: 'A' }`` are identical.
  //
  // If not set, requests will NOT be reported to the server, and will always limited
  // according to :ref:`no_assignment_behavior
  // <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.no_assignment_behavior>`
  // configuration.
  BucketIdBuilder bucket_id_builder = 1;

  // The interval at which the data plane (RLQS client) is to report quota usage for this bucket.
  //
  // When the first request is matched to a bucket with no assignment, the data plane is to report
  // the request immediately in the :ref:`RateLimitQuotaUsageReports
  // <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaUsageReports>` message.
  // For the RLQS server, this signals that the data plane is now subscribed to
  // the quota assignments in this bucket, and will start sending the assignment as described in
  // the :ref:`RLQS documentation <envoy_v3_api_file_envoy/service/rate_limit_quota/v3/rlqs.proto>`.
  //
  // After sending the initial report, the data plane is to continue reporting the bucket usage with
  // the internal specified in this field.
  //
  // If for any reason RLQS client doesn't receive the initial assignment for the reported bucket,
  // the data plane will eventually consider the bucket abandoned and stop sending the usage
  // reports. This is explained in more details at :ref:`Rate Limit Quota Service (RLQS)
  // <envoy_v3_api_file_envoy/service/rate_limit_quota/v3/rlqs.proto>`.
  //
  // [#comment: 100000000 nanoseconds = 0.1 seconds]
  google.protobuf.Duration reporting_interval = 2 [(validate.rules).duration = {
    required: true
    gt {nanos: 100000000}
  }];

  // Customize the deny response to the requests over the rate limit.
  // If not set, the filter will be configured as if an empty message is set,
  // and will behave according to the defaults specified in :ref:`DenyResponseSettings
  // <envoy_v3_api_msg_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.DenyResponseSettings>`.
  DenyResponseSettings deny_response_settings = 3;

  // Configures the behavior in the "no assignment" state: after the first request has been
  // matched to the bucket, and before the the RLQS server returns the first quota assignment.
  //
  // If not set, the default behavior is to allow all requests.
  NoAssignmentBehavior no_assignment_behavior = 4;

  // Configures the behavior in the "expired assignment" state: the bucket's assignment has expired,
  // and cannot be refreshed.
  //
  // If not set, the bucket is abandoned when its ``active`` assignment expires.
  // The process of abandoning the bucket, and restarting the subscription is described in the
  // :ref:`AbandonAction <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
  // message.
  ExpiredAssignmentBehavior expired_assignment_behavior = 5;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.connect_grpc_bridge.v3;

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.connect_grpc_bridge.v3";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/connect_grpc_bridge/v3;connect_grpc_bridgev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: Connect RPC to gRPC] Connect RPC to gRPC bridge
// :ref:`configuration overview <config_http_filters_connect_grpc_bridge>`.
// [#extension: envoy.filters.http.connect_grpc_bridge]

// Connect RPC to gRPC bridge filter configuration
message FilterConfig {
}
syntax = "proto3";

package envoy.extensions.filters.http.original_src.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.original_src.v3";
option java_outer_classname = "OriginalSrcProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/original_src/v3;original_srcv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Original Src Filter]
// Use the Original source address on upstream connections.

// The Original Src filter binds upstream connections to the original source address determined
// for the request. This address could come from something like the Proxy Protocol filter, or it
// could come from trusted http headers.
// [#extension: envoy.filters.http.original_src]
message OriginalSrc {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.original_src.v2alpha1.OriginalSrc";

  // Sets the SO_MARK option on the upstream connection's socket to the provided value. Used to
  // ensure that non-local addresses may be routed back through envoy when binding to the original
  // source address. The option will not be applied if the mark is 0.
  uint32 mark = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.http.cache.v3;

import "envoy/config/route/v3/route_components.proto";
import "envoy/type/matcher/v3/string.proto";

import "google/protobuf/any.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.cache.v3";
option java_outer_classname = "CacheProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/cache/v3;cachev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP Cache Filter]

// [#extension: envoy.filters.http.cache]
// [#next-free-field: 6]
message CacheConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.cache.v2alpha.CacheConfig";

  // [#not-implemented-hide:]
  // Modifies cache key creation by restricting which parts of the URL are included.
  message KeyCreatorParams {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.http.cache.v2alpha.CacheConfig.KeyCreatorParams";

    // If true, exclude the URL scheme from the cache key. Set to true if your origins always
    // produce the same response for http and https requests.
    bool exclude_scheme = 1;

    // If true, exclude the host from the cache key. Set to true if your origins' responses don't
    // ever depend on host.
    bool exclude_host = 2;

    // If ``query_parameters_included`` is nonempty, only query parameters matched
    // by one or more of its matchers are included in the cache key. Any other
    // query params will not affect cache lookup.
    repeated config.route.v3.QueryParameterMatcher query_parameters_included = 3;

    // If ``query_parameters_excluded`` is nonempty, query parameters matched by one
    // or more of its matchers are excluded from the cache key (even if also
    // matched by ``query_parameters_included``), and will not affect cache lookup.
    repeated config.route.v3.QueryParameterMatcher query_parameters_excluded = 4;
  }

  // Config specific to the cache storage implementation. Required unless ``disabled``
  // is true.
  // [#extension-category: envoy.http.cache]
  google.protobuf.Any typed_config = 1;

  // When true, the cache filter is a no-op filter.
  //
  // Possible use-cases for this include:
  // - Turning a filter on and off with :ref:`ECDS <envoy_v3_api_file_envoy/service/extension/v3/config_discovery.proto>`.
  // [#comment: once route-specific overrides are implemented, they are the more likely use-case.]
  google.protobuf.BoolValue disabled = 5;

  // List of matching rules that defines allowed ``Vary`` headers.
  //
  // The ``vary`` response header holds a list of header names that affect the
  // contents of a response, as described by
  // https://httpwg.org/specs/rfc7234.html#caching.negotiated.responses.
  //
  // During insertion, ``allowed_vary_headers`` acts as a allowlist: if a
  // response's ``vary`` header mentions any header names that aren't matched by any rules in
  // ``allowed_vary_headers``, that response will not be cached.
  //
  // During lookup, ``allowed_vary_headers`` controls what request headers will be
  // sent to the cache storage implementation.
  repeated type.matcher.v3.StringMatcher allowed_vary_headers = 2;

  // [#not-implemented-hide:]
  // <TODO(toddmgreer) implement key customization>
  //
  // Modifies cache key creation by restricting which parts of the URL are included.
  KeyCreatorParams key_creator_params = 3;

  // [#not-implemented-hide:]
  // <TODO(toddmgreer) implement size limit>
  //
  // Max body size the cache filter will insert into a cache. 0 means unlimited (though the cache
  // storage implementation may have its own limit beyond which it will reject insertions).
  uint32 max_body_bytes = 4;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/route/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.dynamic_forward_proxy.v3;

import "envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.dynamic_forward_proxy.v3";
option java_outer_classname = "DynamicForwardProxyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/dynamic_forward_proxy/v3;dynamic_forward_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Dynamic forward proxy]

// Configuration for the dynamic forward proxy HTTP filter. See the :ref:`architecture overview
// <arch_overview_http_dynamic_forward_proxy>` for more information.
// [#extension: envoy.filters.http.dynamic_forward_proxy]
message FilterConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.dynamic_forward_proxy.v2alpha.FilterConfig";

  oneof implementation_specifier {
    // The DNS cache configuration that the filter will attach to. Note this configuration must
    // match that of associated :ref:`dynamic forward proxy cluster configuration
    // <envoy_v3_api_field_extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig.dns_cache_config>`.
    common.dynamic_forward_proxy.v3.DnsCacheConfig dns_cache_config = 1;

    // The configuration that the filter will use, when the related dynamic forward proxy cluster enabled
    // sub clusters.
    SubClusterConfig sub_cluster_config = 3;
  }

  // When this flag is set, the filter will add the resolved upstream address in the filter
  // state. The state should be saved with key
  // ``envoy.stream.upstream_address`` (See
  // :repo:`upstream_address.h<source/common/stream_info/upstream_address.h>`).
  bool save_upstream_address = 2;
}

// Per route Configuration for the dynamic forward proxy HTTP filter.
message PerRouteConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.dynamic_forward_proxy.v2alpha.PerRouteConfig";

  oneof host_rewrite_specifier {
    // Indicates that before DNS lookup, the host header will be swapped with
    // this value. If not set or empty, the original host header value
    // will be used and no rewrite will happen.
    //
    // Note: this rewrite affects both DNS lookup and host header forwarding. However, this
    // option shouldn't be used with
    // :ref:`HCM host rewrite <envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_literal>` given that the
    // value set here would be used for DNS lookups whereas the value set in the HCM would be used
    // for host header forwarding which is not the desired outcome.
    string host_rewrite_literal = 1;

    // Indicates that before DNS lookup, the host header will be swapped with
    // the value of this header. If not set or empty, the original host header
    // value will be used and no rewrite will happen.
    //
    // Note: this rewrite affects both DNS lookup and host header forwarding. However, this
    // option shouldn't be used with
    // :ref:`HCM host rewrite header <envoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite>`
    // given that the value set here would be used for DNS lookups whereas the value set in the HCM
    // would be used for host header forwarding which is not the desired outcome.
    //
    // .. note::
    //
    //   If the header appears multiple times only the first value is used.
    string host_rewrite_header = 2;
  }
}

message SubClusterConfig {
  // The timeout used for sub cluster initialization. Defaults to 5s if not set.
  google.protobuf.Duration cluster_init_timeout = 3 [(validate.rules).duration = {gt {}}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/common/dynamic_forward_proxy/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.json_to_metadata.v3;

import "google/protobuf/struct.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.json_to_metadata.v3";
option java_outer_classname = "JsonToMetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/json_to_metadata/v3;json_to_metadatav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Json-To-Metadata Filter]
//
// The configuration for transforming json body into metadata. This is useful
// for matching load balancer subsets, logging, etc.
//
// Json to Metadata :ref:`configuration overview <config_http_filters_json_to_metadata>`.
// [#extension: envoy.filters.http.json_to_metadata]

message JsonToMetadata {
  enum ValueType {
    // The value is a serialized `protobuf.Value
    // <https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/struct.proto#L62>`_.
    PROTOBUF_VALUE = 0;

    STRING = 1;

    NUMBER = 2;
  }

  // [#next-free-field: 6]
  message KeyValuePair {
    // The namespace  if this is empty, the filter's namespace will be used.
    string metadata_namespace = 1;

    // The key to use within the namespace.
    string key = 2 [(validate.rules).string = {min_len: 1}];

    oneof value_type {
      // The value to pair with the given key.
      //
      // When used for on_present case, if value is non-empty it'll be used instead
      // of the the value of the JSON key. If both are empty, the the value of the
      // JSON key is used as-is.
      //
      // When used for on_missing/on_error case, a non-empty value
      // must be provided.
      //
      // It ignores ValueType, i.e., not type casting.
      google.protobuf.Value value = 3;
    }

    // The value's type  defaults to protobuf.Value.
    ValueType type = 4 [(validate.rules).enum = {defined_only: true}];

    // False if we want to overwrite the existing metadata value. Default to false.
    bool preserve_existing_metadata_value = 5;
  }

  message Selector {
    oneof selector {
      // key to match
      string key = 1 [(validate.rules).string = {min_len: 1}];
    }
  }

  // A Rule defines what metadata to apply when a key-value is present, missing in the json
  // or fail to parse the payload.
  message Rule {
    // Specifies that a match will be performed on the value of a property.
    // Here's an example to match on 1 in {"foo": {"bar": 1}, "bar": 2}
    //
    // selectors:
    // - key: foo
    // - key: bar
    repeated Selector selectors = 1 [(validate.rules).repeated = {min_items: 1}];

    // If the attribute is present, apply this metadata KeyValuePair.
    KeyValuePair on_present = 2;

    // If the attribute is missing, apply this metadata KeyValuePair.
    //
    // The value in the KeyValuePair must be set.
    KeyValuePair on_missing = 3;

    // If the body is too large or fail to parse, apply this metadata KeyValuePair.
    //
    // The value in the KeyValuePair must be set.
    KeyValuePair on_error = 4;
  }

  message MatchRules {
    // The list of rules to apply.
    repeated Rule rules = 1 [(validate.rules).repeated = {min_items: 1}];

    // Allowed content-type for json to metadata transformation.
    // Default to ``{"application/json"}``.
    //
    // Set ``allow_empty_content_type`` if empty/missing content-type header
    // is allowed.
    repeated string allow_content_types = 2
        [(validate.rules).repeated = {items {string {min_len: 1}}}];

    // Allowed empty content-type for json to metadata transformation.
    // Default to false.
    bool allow_empty_content_type = 3;
  }

  // At least one of request_rules and response_rules must be provided.
  // Rules to match json body of requests.
  MatchRules request_rules = 1;

  // Rules to match json body of responses.
  MatchRules response_rules = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.http.decompressor.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.decompressor.v3";
option java_outer_classname = "DecompressorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/decompressor/v3;decompressorv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Decompressor]
// [#extension: envoy.filters.http.decompressor]

message Decompressor {
  // Common configuration for filter behavior on both the request and response direction.
  message CommonDirectionConfig {
    // Runtime flag that controls whether the filter is enabled for decompression or not. If set to false, the
    // filter will operate as a pass-through filter. If the message is unspecified, the filter will be enabled.
    config.core.v3.RuntimeFeatureFlag enabled = 1;

    // If set to true, will decompress response even if a ``no-transform`` cache control header is set.
    bool ignore_no_transform_header = 2;
  }

  // Configuration for filter behavior on the request direction.
  message RequestDirectionConfig {
    CommonDirectionConfig common_config = 1;

    // If set to true, and response decompression is enabled, the filter modifies the Accept-Encoding
    // request header by appending the decompressor_library's encoding. Defaults to true.
    google.protobuf.BoolValue advertise_accept_encoding = 2;
  }

  // Configuration for filter behavior on the response direction.
  message ResponseDirectionConfig {
    CommonDirectionConfig common_config = 1;
  }

  // A decompressor library to use for both request and response decompression. Currently only
  // :ref:`envoy.compression.gzip.compressor<envoy_v3_api_msg_extensions.compression.gzip.decompressor.v3.Gzip>`
  // is included in Envoy.
  // [#extension-category: envoy.compression.decompressor]
  config.core.v3.TypedExtensionConfig decompressor_library = 1
      [(validate.rules).message = {required: true}];

  // Configuration for request decompression. Decompression is enabled by default if left empty.
  RequestDirectionConfig request_direction_config = 2;

  // Configuration for response decompression. Decompression is enabled by default if left empty.
  ResponseDirectionConfig response_direction_config = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.compressor.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";

import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.compressor.v3";
option java_outer_classname = "CompressorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/compressor/v3;compressorv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Compressor]
// Compressor :ref:`configuration overview <config_http_filters_compressor>`.
// [#extension: envoy.filters.http.compressor]

// [#next-free-field: 10]
message Compressor {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.compressor.v2.Compressor";

  message CommonDirectionConfig {
    // Runtime flag that controls whether compression is enabled or not for the direction this
    // common config is put in. If set to false, the filter will operate as a pass-through filter
    // in the chosen direction, unless overridden by CompressorPerRoute.
    // If the field is omitted, the filter will be enabled.
    config.core.v3.RuntimeFeatureFlag enabled = 1;

    // Minimum value of Content-Length header of request or response messages (depending on the direction
    // this common config is put in), in bytes, which will trigger compression. The default value is 30.
    google.protobuf.UInt32Value min_content_length = 2;

    // Set of strings that allows specifying which mime-types yield compression; e.g.,
    // application/json, text/html, etc. When this field is not defined, compression will be applied
    // to the following mime-types: "application/javascript", "application/json",
    // "application/xhtml+xml", "image/svg+xml", "text/css", "text/html", "text/plain", "text/xml"
    // and their synonyms.
    repeated string content_type = 3;
  }

  // Configuration for filter behavior on the request direction.
  message RequestDirectionConfig {
    CommonDirectionConfig common_config = 1;
  }

  // Configuration for filter behavior on the response direction.
  message ResponseDirectionConfig {
    CommonDirectionConfig common_config = 1;

    // If true, disables compression when the response contains an etag header. When it is false, the
    // filter will preserve weak etags and remove the ones that require strong validation.
    bool disable_on_etag_header = 2;

    // If true, removes accept-encoding from the request headers before dispatching it to the upstream
    // so that responses do not get compressed before reaching the filter.
    //
    // .. attention::
    //
    //    To avoid interfering with other compression filters in the same chain use this option in
    //    the filter closest to the upstream.
    bool remove_accept_encoding_header = 3;
  }

  // Minimum response length, in bytes, which will trigger compression. The default value is 30.
  google.protobuf.UInt32Value content_length = 1
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Set of strings that allows specifying which mime-types yield compression; e.g.,
  // application/json, text/html, etc. When this field is not defined, compression will be applied
  // to the following mime-types: "application/javascript", "application/json",
  // "application/xhtml+xml", "image/svg+xml", "text/css", "text/html", "text/plain", "text/xml"
  // and their synonyms.
  repeated string content_type = 2
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // If true, disables compression when the response contains an etag header. When it is false, the
  // filter will preserve weak etags and remove the ones that require strong validation.
  bool disable_on_etag_header = 3
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // If true, removes accept-encoding from the request headers before dispatching it to the upstream
  // so that responses do not get compressed before reaching the filter.
  //
  // .. attention::
  //
  //    To avoid interfering with other compression filters in the same chain use this option in
  //    the filter closest to the upstream.
  bool remove_accept_encoding_header = 4
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Runtime flag that controls whether the filter is enabled or not. If set to false, the
  // filter will operate as a pass-through filter, unless overridden by
  // CompressorPerRoute. If not specified, defaults to enabled.
  config.core.v3.RuntimeFeatureFlag runtime_enabled = 5
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // A compressor library to use for compression. Currently only
  // :ref:`envoy.compression.gzip.compressor<envoy_v3_api_msg_extensions.compression.gzip.compressor.v3.Gzip>`
  // is included in Envoy.
  // [#extension-category: envoy.compression.compressor]
  config.core.v3.TypedExtensionConfig compressor_library = 6
      [(validate.rules).message = {required: true}];

  // Configuration for request compression. Compression is disabled by default if left empty.
  RequestDirectionConfig request_direction_config = 7;

  // Configuration for response compression. Compression is enabled by default if left empty.
  //
  // .. attention::
  //
  //    If the field is not empty then the duplicate deprecated fields of the ``Compressor`` message,
  //    such as ``content_length``, ``content_type``, ``disable_on_etag_header``,
  //    ``remove_accept_encoding_header`` and ``runtime_enabled``, are ignored.
  //
  //    Also all the statistics related to response compression will be rooted in
  //    ``<stat_prefix>.compressor.<compressor_library.name>.<compressor_library_stat_prefix>.response.*``
  //    instead of
  //    ``<stat_prefix>.compressor.<compressor_library.name>.<compressor_library_stat_prefix>.*``.
  ResponseDirectionConfig response_direction_config = 8;

  // If true, chooses this compressor first to do compression when the q-values in ``Accept-Encoding`` are same.
  // The last compressor which enables choose_first will be chosen if multiple compressor filters in the chain have choose_first as true.
  bool choose_first = 9;
}

// Per-route overrides of ``ResponseDirectionConfig``. Anything added here should be optional,
// to allow overriding arbitrary subsets of configuration. Omitted fields must have no effect.
message ResponseDirectionOverrides {
  // If set, overrides the filter-level
  // :ref:`remove_accept_encoding_header<envoy_v3_api_field_extensions.filters.http.compressor.v3.Compressor.ResponseDirectionConfig.remove_accept_encoding_header>`.
  google.protobuf.BoolValue remove_accept_encoding_header = 1;
}

// Per-route overrides. As per-route overrides are needed, they should be
// added here, mirroring the structure of ``Compressor``. All fields should be
// optional, to allow overriding arbitrary subsets of configuration.
message CompressorOverrides {
  // If present, response compression is enabled.
  ResponseDirectionOverrides response_direction_config = 1;
}

message CompressorPerRoute {
  oneof override {
    option (validate.required) = true;

    // If set, the filter will operate as a pass-through filter.
    // Overrides Compressor.runtime_enabled and CommonDirectionConfig.enabled.
    bool disabled = 1 [(validate.rules).bool = {const: true}];

    // Per-route overrides. Fields set here will override corresponding fields in ``Compressor``.
    CompressorOverrides overrides = 2;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/wasm/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.wasm.v3;

import "envoy/extensions/wasm/v3/wasm.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.wasm.v3";
option java_outer_classname = "WasmProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/wasm/v3;wasmv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Wasm]
// [#extension: envoy.filters.http.wasm]
// Wasm :ref:`configuration overview <config_http_filters_wasm>`.

message Wasm {
  // General Plugin configuration.
  envoy.extensions.wasm.v3.PluginConfig config = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.basic_auth.v3;

import "envoy/config/core/v3/base.proto";

import "udpa/annotations/sensitive.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.basic_auth.v3";
option java_outer_classname = "BasicAuthProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/basic_auth/v3;basic_authv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Basic Auth]
// Basic Auth :ref:`configuration overview <config_http_filters_basic_auth>`.
// [#extension: envoy.filters.http.basic_auth]

// Basic HTTP authentication.
//
// Example:
//
// .. code-block:: yaml
//
//   users:
//     inline_string: |-
//       user1:{SHA}hashed_user1_password
//       user2:{SHA}hashed_user2_password
//
message BasicAuth {
  // Username-password pairs used to verify user credentials in the "Authorization" header.
  // The value needs to be the htpasswd format.
  // Reference to https://httpd.apache.org/docs/2.4/programs/htpasswd.html
  config.core.v3.DataSource users = 1 [(udpa.annotations.sensitive) = true];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/config/route/v3:pkg",
        "//envoy/extensions/transport_sockets/tls/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.oauth2.v3;

import "envoy/config/core/v3/http_uri.proto";
import "envoy/config/route/v3/route_components.proto";
import "envoy/extensions/transport_sockets/tls/v3/secret.proto";
import "envoy/type/matcher/v3/path.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.oauth2.v3";
option java_outer_classname = "OauthProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/oauth2/v3;oauth2v3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: OAuth]
// OAuth :ref:`configuration overview <config_http_filters_oauth>`.
// [#extension: envoy.filters.http.oauth2]
//

message OAuth2Credentials {
  // [#next-free-field: 6]
  message CookieNames {
    // Cookie name to hold OAuth bearer token value. When the authentication server validates the
    // client and returns an authorization token back to the OAuth filter, no matter what format
    // that token is, if :ref:`forward_bearer_token <envoy_v3_api_field_extensions.filters.http.oauth2.v3.OAuth2Config.forward_bearer_token>`
    // is set to true the filter will send over the bearer token as a cookie with this name to the
    // upstream. Defaults to ``BearerToken``.
    string bearer_token = 1
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];

    // Cookie name to hold OAuth HMAC value. Defaults to ``OauthHMAC``.
    string oauth_hmac = 2
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];

    // Cookie name to hold OAuth expiry value. Defaults to ``OauthExpires``.
    string oauth_expires = 3
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];

    // Cookie name to hold the id token. Defaults to ``IdToken``.
    string id_token = 4
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];

    // Cookie name to hold the refresh token. Defaults to ``RefreshToken``.
    string refresh_token = 5
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];
  }

  // The client_id to be used in the authorize calls. This value will be URL encoded when sent to the OAuth server.
  string client_id = 1 [(validate.rules).string = {min_len: 1}];

  // The secret used to retrieve the access token. This value will be URL encoded when sent to the OAuth server.
  transport_sockets.tls.v3.SdsSecretConfig token_secret = 2
      [(validate.rules).message = {required: true}];

  // Configures how the secret token should be created.
  oneof token_formation {
    option (validate.required) = true;

    // If present, the secret token will be a HMAC using the provided secret.
    transport_sockets.tls.v3.SdsSecretConfig hmac_secret = 3
        [(validate.rules).message = {required: true}];
  }

  // The cookie names used in OAuth filters flow.
  CookieNames cookie_names = 4;
}

// OAuth config
//
// [#next-free-field: 14]
message OAuth2Config {
  enum AuthType {
    // The ``client_id`` and ``client_secret`` will be sent in the URL encoded request body.
    // This type should only be used when Auth server does not support Basic authentication.
    URL_ENCODED_BODY = 0;

    // The ``client_id`` and ``client_secret`` will be sent using HTTP Basic authentication scheme.
    BASIC_AUTH = 1;
  }

  // Endpoint on the authorization server to retrieve the access token from.
  config.core.v3.HttpUri token_endpoint = 1;

  // The endpoint redirect to for authorization in response to unauthorized requests.
  string authorization_endpoint = 2 [(validate.rules).string = {min_len: 1}];

  // Credentials used for OAuth.
  OAuth2Credentials credentials = 3 [(validate.rules).message = {required: true}];

  // The redirect URI passed to the authorization endpoint. Supports header formatting
  // tokens. For more information, including details on header value syntax, see the
  // documentation on :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
  //
  // This URI should not contain any query parameters.
  string redirect_uri = 4 [(validate.rules).string = {min_len: 1}];

  // Matching criteria used to determine whether a path appears to be the result of a redirect from the authorization server.
  type.matcher.v3.PathMatcher redirect_path_matcher = 5
      [(validate.rules).message = {required: true}];

  // The path to sign a user out, clearing their credential cookies.
  type.matcher.v3.PathMatcher signout_path = 6 [(validate.rules).message = {required: true}];

  // Forward the OAuth token as a Bearer to upstream web service.
  bool forward_bearer_token = 7;

  // Any request that matches any of the provided matchers will be passed through without OAuth validation.
  repeated config.route.v3.HeaderMatcher pass_through_matcher = 8;

  // Optional list of OAuth scopes to be claimed in the authorization request. If not specified,
  // defaults to "user" scope.
  // OAuth RFC https://tools.ietf.org/html/rfc6749#section-3.3
  repeated string auth_scopes = 9;

  // Optional resource parameter for authorization request
  // RFC: https://tools.ietf.org/html/rfc8707
  repeated string resources = 10;

  // Defines how ``client_id`` and ``client_secret`` are sent in OAuth client to OAuth server requests.
  // RFC https://datatracker.ietf.org/doc/html/rfc6749#section-2.3.1
  AuthType auth_type = 11 [(validate.rules).enum = {defined_only: true}];

  // If set to true, allows automatic access token refresh using the associated refresh token (see
  // `RFC 6749 section 6 <https://datatracker.ietf.org/doc/html/rfc6749#section-6>`_), provided that the OAuth server supports that.
  // Default value is false.
  google.protobuf.BoolValue use_refresh_token = 12;

  // The default lifetime in seconds of the access token, if omitted by the authorization server.
  //
  // If this value is not set, it will default to ``0s``. In this case, the expiry must be set by
  // the authorization server or the OAuth flow will fail.
  google.protobuf.Duration default_expires_in = 13;
}

// Filter config.
message OAuth2 {
  // Leave this empty to disable OAuth2 for a specific route, using per filter config.
  OAuth2Config config = 1;
}
syntax = "proto3";

package envoy.extensions.filters.http.upstream_codec.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.upstream_codec.v3";
option java_outer_classname = "UpstreamCodecProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/upstream_codec/v3;upstream_codecv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: UpstreamCodec]
// Codec :ref:`configuration overview <config_http_filters_upstream_codec>`.
// [#extension: envoy.filters.http.upstream_codec]

message UpstreamCodec {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.http.gcp_authn.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/http_uri.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.gcp_authn.v3";
option java_outer_classname = "GcpAuthnProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/gcp_authn/v3;gcp_authnv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: GCP authentication]
// GCP authentication :ref:`configuration overview <config_http_filters_gcp_authn>`.
// [#extension: envoy.filters.http.gcp_authn]

// Filter configuration.
message GcpAuthnFilterConfig {
  // The HTTP URI to fetch tokens from GCE Metadata Server(https://cloud.google.com/compute/docs/metadata/overview).
  // The URL format is "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/identity?audience=[AUDIENCE]"
  config.core.v3.HttpUri http_uri = 1 [(validate.rules).message = {required: true}];

  // Retry policy for fetching tokens. This field is optional.
  config.core.v3.RetryPolicy retry_policy = 2;

  // Token cache configuration. This field is optional.
  TokenCacheConfig cache_config = 3;

  // Request header location to extract the token. By default (i.e. if this field is not specified), the token
  // is extracted to the Authorization HTTP header, in the format "Authorization: Bearer <token>".
  TokenHeader token_header = 4;
}

// Audience is the URL of the receiving service that performs token authentication.
// It will be provided to the filter through cluster's typed_filter_metadata.
message Audience {
  string url = 1 [(validate.rules).string = {min_len: 1}];
}

// Token Cache configuration.
message TokenCacheConfig {
  // The number of cache entries. The maximum number of entries is INT64_MAX as it is constrained by underlying cache implementation.
  // Default value 0 (i.e., proto3 defaults) disables the cache by default. Other default values will enable the cache.
  google.protobuf.UInt64Value cache_size = 1 [(validate.rules).uint64 = {lte: 9223372036854775807}];
}

message TokenHeader {
  // The HTTP header's name.
  string name = 1
      [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

  // The header's prefix. The format is "value_prefix<token>"
  // For example, for "Authorization: Bearer <token>", value_prefix="Bearer " with a space at the
  // end.
  string value_prefix = 2
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.geoip.v3;

import "envoy/config/core/v3/extension.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.geoip.v3";
option java_outer_classname = "GeoipProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/geoip/v3;geoipv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: Geoip]
// Geoip :ref:`configuration overview <config_http_filters_geoip>`.
// [#extension: envoy.filters.http.geoip]

message Geoip {
  message XffConfig {
    // The number of additional ingress proxy hops from the right side of the
    // :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
    // determining the origin client's IP address. The default is zero if this option
    // is not specified. See the documentation for
    // :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
    uint32 xff_num_trusted_hops = 1;
  }

  // If set, the :ref:`xff_num_trusted_hops <envoy_v3_api_field_extensions.filters.http.geoip.v3.Geoip.XffConfig.xff_num_trusted_hops>` field will be used to determine
  // trusted client address from ``x-forwarded-for`` header.
  // Otherwise, the immediate downstream connection source address will be used.
  // [#next-free-field: 2]
  XffConfig xff_config = 1;

  // Geoip driver specific configuration which depends on the driver being instantiated.
  // See the geoip drivers for examples:
  //
  // - :ref:`MaxMindConfig <envoy_v3_api_msg_extensions.geoip_providers.maxmind.v3.MaxMindConfig>`
  // [#extension-category: envoy.geoip_providers]
  config.core.v3.TypedExtensionConfig provider = 3 [(validate.rules).message = {required: true}];
}
syntax = "proto3";

package envoy.extensions.filters.http.gzip.v3;

import "envoy/extensions/filters/http/compressor/v3/compressor.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.gzip.v3";
option java_outer_classname = "GzipProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/gzip/v3;gzipv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Gzip]

// [#next-free-field: 12]
message Gzip {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.gzip.v2.Gzip";

  enum CompressionStrategy {
    DEFAULT = 0;
    FILTERED = 1;
    HUFFMAN = 2;
    RLE = 3;
  }

  message CompressionLevel {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.http.gzip.v2.Gzip.CompressionLevel";

    enum Enum {
      DEFAULT = 0;
      BEST = 1;
      SPEED = 2;
    }
  }

  reserved 2, 6, 7, 8;

  reserved "content_length", "content_type", "disable_on_etag_header",
      "remove_accept_encoding_header";

  // Value from 1 to 9 that controls the amount of internal memory used by zlib. Higher values
  // use more memory, but are faster and produce better compression results. The default value is 5.
  google.protobuf.UInt32Value memory_level = 1 [(validate.rules).uint32 = {lte: 9 gte: 1}];

  // A value used for selecting the zlib compression level. This setting will affect speed and
  // amount of compression applied to the content. "BEST" provides higher compression at the cost of
  // higher latency, "SPEED" provides lower compression with minimum impact on response time.
  // "DEFAULT" provides an optimal result between speed and compression. This field will be set to
  // "DEFAULT" if not specified.
  CompressionLevel.Enum compression_level = 3 [(validate.rules).enum = {defined_only: true}];

  // A value used for selecting the zlib compression strategy which is directly related to the
  // characteristics of the content. Most of the time "DEFAULT" will be the best choice, though
  // there are situations which changing this parameter might produce better results. For example,
  // run-length encoding (RLE) is typically used when the content is known for having sequences
  // which same data occurs many consecutive times. For more information about each strategy, please
  // refer to zlib manual.
  CompressionStrategy compression_strategy = 4 [(validate.rules).enum = {defined_only: true}];

  // Value from 9 to 15 that represents the base two logarithmic of the compressor's window size.
  // Larger window results in better compression at the expense of memory usage. The default is 12
  // which will produce a 4096 bytes window. For more details about this parameter, please refer to
  // zlib manual > deflateInit2.
  google.protobuf.UInt32Value window_bits = 9 [(validate.rules).uint32 = {lte: 15 gte: 9}];

  // Set of configuration parameters common for all compression filters. You can define
  // ``content_length``, ``content_type`` and other parameters in this field.
  compressor.v3.Compressor compressor = 10;

  // Value for Zlib's next output buffer. If not set, defaults to 4096.
  // See https://www.zlib.net/manual.html for more details. Also see
  // https://github.com/envoyproxy/envoy/issues/8448 for context on this filter's performance.
  google.protobuf.UInt32Value chunk_size = 11 [(validate.rules).uint32 = {lte: 65536 gte: 4096}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/filters/http/compressor/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.grpc_field_extraction.v3;

import "envoy/config/core/v3/base.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.grpc_field_extraction.v3";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_field_extraction/v3;grpc_field_extractionv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: gRPC Field Extraction]
//
// [#extension: envoy.filters.http.grpc_field_extraction]
//
// Overview
// --------
//
// This filter supports extracting the fields from the first gRPC
// request message no matter if it is unary or streaming and writing the result
// to the destination, for which currently only the static Envoy dynamic metadata `envoy.filters.http.grpc_field_extraction` is supported.
//
// Assumptions
// -----------
//
// This filter assumes
//
// 1. this filter is only applicable for gRPC with Protobuf as payload.
// 2. for bi-directional and client-side gRPC streaming, the initial message from the client should not depend on receiving the server initial metadata.
//
// Process Flow
// ------------
//
// When a request reaches the filter, it will check
//
// 1. if the request is the gRPC request configured for extraction, the filter tries to:
//
//   a. block the incoming data before decoding the first complete gRPC message
//   b. look up the target field from the buffered gRPC message
//   c. write the extraction result into the dynamic metadata and resume the request propagation.
//
// 2. otherwise, pass through the request.
//
// If the request is a malformed one found during 1.a or 1.b, the filter will reject the request.
//
// Config Requirements
// -------------------
//
// Here are config requirements
//
// 1. the target field should be among the following primitive types: `string`, `uint32`, `uint64`, `int32`, `int64`, `sint32`, `sint64`, `fixed32`, `fixed64`, `sfixed32`, `sfixed64`, `float`, `double`.
//
// 2. the target field could be repeated.
//
// 3. the intermediate type could also be repeated.
//
// Output Format
// -------------
//
// 1. the extracted field names/values will be wrapped in be ``field<StringValue>`` -> ``values<ListValue of StringValue>``, which will be added in the dynamic ``metadata<google.protobuf.Struct>``.
//
// 2. if the field value is empty, a empty ``<ListValue>`` will be set.
//
// Performance
// -----------
//
// This filter should be performant as it
//
// 1. converts between the gRPC message from EnvoyBuffer without data copy.
// 2. parse the gRPC message binary directly without deserialization.
//
// though buffering the first message introduces some latency.
//
// Example
// -------
//
// We have the following request definition for the gRPC method `pkg.svc.Method`.
//
// .. code-block:: proto
//
// 	message MethodRequest {
// 	  string foo = 1;
// 	  Nested nested = 2;
// 	  uint32 baz = 3;
// 	  ...
// 	}
//
// 	message Nested {
// 	 repeated string bar = 1;
// 	}
//
// This is the filter config in JSON.
//
// .. code-block:: json
//
// 	{
// 	  "descriptor_set":{},
// 	  "extractions_by_method":{
// 	     "pkg.svc.Method":{
// 	        "request_field_extractions":{
// 	           "foo":{
// 	           },
// 	           "nested.bar":{
// 	           }
// 	           "baz":{
// 	           }
// 	        }
// 	     }
// 	  }
// 	}
//
// During runtime, the filter receives the following `MethodRequest` message in JSON.
//
// .. code-block:: json
//
// 	{
// 	  "foo": "val_foo",
// 	  "nested": { "bar": ["val_bar1", "val_bar2"]}
// 	}
//
// The filter will write the following dynamic metadata(`envoy.filters.http.grpc_field_extraction`) in JSON.
//
// .. code-block:: json
//
// 	{
// 	  "foo":[
// 	     "val_foo"
// 	  ],
// 	  "nested.bar":[
// 	     "val_bar1", "val_bar2"
// 	  ]
// 	  "baz":[
// 	  ]
// 	}

message GrpcFieldExtractionConfig {
  // The proto descriptor set binary for the gRPC services.
  //
  // It could be passed by a local file through ``Datasource.filename`` or embedded in the
  // ``Datasource.inline_bytes``.
  config.core.v3.DataSource descriptor_set = 1 [(validate.rules).message = {required: true}];

  // Specify the extraction info.
  // The key is the fully qualified gRPC method name.
  // ``${package}.${Service}.${Method}``, like
  // ``endpoints.examples.bookstore.BookStore.GetShelf``
  //
  // The value is the field extractions for individual gRPC method.
  map<string, FieldExtractions> extractions_by_method = 2;
}

// This message can be used to support per route config approach later even
// though the Istio doesn't support that so far.
message FieldExtractions {
  // The field extractions for requests.
  // The key is the field path within the grpc request.
  // For example, we can define ``foo.bar.name`` if we want to extract
  // ``Request.foo.bar.name``.
  //
  // .. code-block:: proto
  //
  //  message Request {
  //    Foo foo = 1;
  //  }
  //
  //  message Foo {
  //    Bar bar = 1;
  //  }
  //
  //  message Bar {
  //    string name = 1;
  //  }
  map<string, RequestFieldValueDisposition> request_field_extractions = 1;
}

message RequestFieldValueDisposition {
  oneof disposition {
    // The dynamic metadata namespace. If empty, "envoy.filters.http.grpc_field_extraction" will be used by default.
    //
    // Unimplemented. Uses "envoy.filters.http.grpc_field_extraction" for now.
    string dynamic_metadata = 1;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.aws_request_signing.v3;

import "envoy/type/matcher/v3/string.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.aws_request_signing.v3";
option java_outer_classname = "AwsRequestSigningProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/aws_request_signing/v3;aws_request_signingv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: AwsRequestSigning]
// AwsRequestSigning :ref:`configuration overview <config_http_filters_aws_request_signing>`.
// [#extension: envoy.filters.http.aws_request_signing]

// Top level configuration for the AWS request signing filter.
// [#next-free-field: 7]
message AwsRequestSigning {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.aws_request_signing.v2alpha.AwsRequestSigning";

  enum SigningAlgorithm {
    // Use SigV4 for signing
    AWS_SIGV4 = 0;

    // Use SigV4A for signing
    AWS_SIGV4A = 1;
  }

  // The `service namespace
  // <https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces>`_
  // of the HTTP endpoint.
  //
  // Example: s3
  string service_name = 1 [(validate.rules).string = {min_len: 1}];

  // When signing_algorithm is set to ``AWS_SIGV4`` the region is a standard AWS `region <https://docs.aws.amazon.com/general/latest/gr/rande.html>`_ string for the service
  // hosting the HTTP endpoint.
  //
  // Example: us-west-2
  //
  // When signing_algorithm is set to ``AWS_SIGV4A`` the region is used as a region set.
  //
  // A region set is a comma separated list of AWS regions, such as ``us-east-1,us-east-2`` or wildcard ``*``
  // or even region strings containing wildcards such as ``us-east-*``
  //
  // Example: '*'
  //
  // By configuring a region set, a sigv4a signed request can be sent to multiple regions, rather than being
  // valid for only a single region destination.
  string region = 2 [(validate.rules).string = {min_len: 1}];

  // Indicates that before signing headers, the host header will be swapped with
  // this value. If not set or empty, the original host header value
  // will be used and no rewrite will happen.
  //
  // Note: this rewrite affects both signing and host header forwarding. However, this
  // option shouldn't be used with
  // :ref:`HCM host rewrite <envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_literal>` given that the
  // value set here would be used for signing whereas the value set in the HCM would be used
  // for host header forwarding which is not the desired outcome.
  string host_rewrite = 3;

  // Instead of buffering the request to calculate the payload hash, use the literal string ``UNSIGNED-PAYLOAD``
  // to calculate the payload hash. Not all services support this option. See the `S3
  // <https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html>`_ policy for details.
  bool use_unsigned_payload = 4;

  // A list of request header string matchers that will be excluded from signing. The excluded header can be matched by
  // any patterns defined in the StringMatcher proto (e.g. exact string, prefix, regex, etc).
  //
  // Example:
  // match_excluded_headers:
  // - prefix: x-envoy
  // - exact: foo
  // - exact: bar
  // When applied, all headers that start with "x-envoy" and headers "foo" and "bar" will not be signed.
  repeated type.matcher.v3.StringMatcher match_excluded_headers = 5;

  // Optional Signing algorithm specifier, either ``AWS_SIGV4`` or ``AWS_SIGV4A``, defaulting to ``AWS_SIGV4``.
  SigningAlgorithm signing_algorithm = 6;
}

message AwsRequestSigningPerRoute {
  // Override the global configuration of the filter with this new config.
  // This overrides the entire message of AwsRequestSigning and not at field level.
  AwsRequestSigning aws_request_signing = 1;

  // The human readable prefix to use when emitting stats.
  string stat_prefix = 2 [(validate.rules).string = {min_len: 1}];
}
syntax = "proto3";

package envoy.extensions.filters.http.tap.v3;

import "envoy/extensions/common/tap/v3/common.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.tap.v3";
option java_outer_classname = "TapProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/tap/v3;tapv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Tap]
// Tap :ref:`configuration overview <config_http_filters_tap>`.
// [#extension: envoy.filters.http.tap]

// Top level configuration for the tap filter.
message Tap {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.tap.v2alpha.Tap";

  // Common configuration for the HTTP tap filter.
  common.tap.v3.CommonExtensionConfig common_config = 1
      [(validate.rules).message = {required: true}];

  // Indicates whether HTTP tap filter records the time stamp for request/response headers.
  // Request headers time stamp is stored after receiving request headers.
  // Response headers time stamp is stored after receiving response headers.
  bool record_headers_received_time = 2;

  // Indicates whether report downstream connection info
  bool record_downstream_connection = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/common/tap/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.lua.v3;

import "envoy/config/core/v3/base.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.lua.v3";
option java_outer_classname = "LuaProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/lua/v3;luav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Lua]
// Lua :ref:`configuration overview <config_http_filters_lua>`.
// [#extension: envoy.filters.http.lua]

message Lua {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.lua.v2.Lua";

  // The Lua code that Envoy will execute. This can be a very small script that
  // further loads code from disk if desired. Note that if JSON configuration is used, the code must
  // be properly escaped. YAML configuration may be easier to read since YAML supports multi-line
  // strings so complex scripts can be easily expressed inline in the configuration.
  //
  // This field is deprecated. Please use
  // :ref:`default_source_code <envoy_v3_api_field_extensions.filters.http.lua.v3.Lua.default_source_code>`.
  // Only one of :ref:`inline_code <envoy_v3_api_field_extensions.filters.http.lua.v3.Lua.inline_code>`
  // or :ref:`default_source_code <envoy_v3_api_field_extensions.filters.http.lua.v3.Lua.default_source_code>`
  // can be set for the Lua filter.
  string inline_code = 1
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Map of named Lua source codes that can be referenced in :ref:`LuaPerRoute
  // <envoy_v3_api_msg_extensions.filters.http.lua.v3.LuaPerRoute>`. The Lua source codes can be
  // loaded from inline string or local files.
  //
  // Example:
  //
  // .. code-block:: yaml
  //
  //   source_codes:
  //     hello.lua:
  //       inline_string: |
  //         function envoy_on_response(response_handle)
  //           -- Do something.
  //         end
  //     world.lua:
  //       filename: /etc/lua/world.lua
  //
  map<string, config.core.v3.DataSource> source_codes = 2;

  // The default Lua code that Envoy will execute. If no per route config is provided
  // for the request, this Lua code will be applied.
  config.core.v3.DataSource default_source_code = 3;

  // Optional additional prefix to use when emitting statistics. By default
  // metrics are emitted in *.lua.* namespace. If multiple lua filters are
  // configured in a filter chain, the stats from each filter instance can
  // be emitted using custom stat prefix to distinguish emitted
  // statistics. For example:
  //
  // .. code-block:: yaml
  //
  //   http_filters:
  //     - name: envoy.filters.http.lua
  //       typed_config:
  //         "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
  //         stat_prefix: foo_script # This emits lua.foo_script.errors etc.
  //     - name: envoy.filters.http.lua
  //       typed_config:
  //         "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
  //         stat_prefix: bar_script # This emits lua.bar_script.errors etc.
  //
  string stat_prefix = 4;
}

message LuaPerRoute {
  oneof override {
    option (validate.required) = true;

    // Disable the Lua filter for this particular vhost or route. If disabled is specified in
    // multiple per-filter-configs, the most specific one will be used.
    bool disabled = 1 [(validate.rules).bool = {const: true}];

    // A name of a Lua source code stored in
    // :ref:`Lua.source_codes <envoy_v3_api_field_extensions.filters.http.lua.v3.Lua.source_codes>`.
    string name = 2 [(validate.rules).string = {min_len: 1}];

    // A configured per-route Lua source code that can be served by RDS or provided inline.
    config.core.v3.DataSource source_code = 3;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.grpc_web.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.grpc_web.v3";
option java_outer_classname = "GrpcWebProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_web/v3;grpc_webv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: gRPC Web]
// gRPC Web :ref:`configuration overview <config_http_filters_grpc_web>`.
// [#extension: envoy.filters.http.grpc_web]

// gRPC Web filter config.
message GrpcWeb {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.grpc_web.v2.GrpcWeb";
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.http.composite.v3;

import "envoy/config/core/v3/config_source.proto";
import "envoy/config/core/v3/extension.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.composite.v3";
option java_outer_classname = "CompositeProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/composite/v3;compositev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Composite]
// Composite Filter :ref:`configuration overview <config_http_filters_composite>`.
// [#extension: envoy.filters.http.composite]

// :ref:`Composite filter <config_http_filters_composite>` config. The composite filter config
// allows delegating filter handling to another filter as determined by matching on the request
// headers. This makes it possible to use different filters or filter configurations based on the
// incoming request.
//
// This is intended to be used with
// :ref:`ExtensionWithMatcher <envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcher>`
// where a match tree is specified that indicates (via
// :ref:`ExecuteFilterAction <envoy_v3_api_msg_extensions.filters.http.composite.v3.ExecuteFilterAction>`)
// which filter configuration to create and delegate to.
message Composite {
}

// Configuration for an extension configuration discovery service with name.
message DynamicConfig {
  // The name of the extension configuration. It also serves as a resource name in ExtensionConfigDS.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // Configuration source specifier for an extension configuration discovery
  // service. In case of a failure and without the default configuration,
  // 500(Internal Server Error) will be returned.
  config.core.v3.ExtensionConfigSource config_discovery = 2;
}

// Composite match action (see :ref:`matching docs <arch_overview_matching_api>` for more info on match actions).
// This specifies the filter configuration of the filter that the composite filter should delegate filter interactions to.
message ExecuteFilterAction {
  // Filter specific configuration which depends on the filter being
  // instantiated. See the supported filters for further documentation.
  // Only one of ``typed_config`` or ``dynamic_config`` can be set.
  // [#extension-category: envoy.filters.http]
  config.core.v3.TypedExtensionConfig typed_config = 1
      [(udpa.annotations.field_migrate).oneof_promotion = "config_type"];

  // Dynamic configuration of filter obtained via extension configuration discovery
  // service.
  // Only one of ``typed_config`` or ``dynamic_config`` can be set.
  DynamicConfig dynamic_config = 2
      [(udpa.annotations.field_migrate).oneof_promotion = "config_type"];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.ext_authz.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/config_source.proto";
import "envoy/config/core/v3/grpc_service.proto";
import "envoy/config/core/v3/http_uri.proto";
import "envoy/type/matcher/v3/metadata.proto";
import "envoy/type/matcher/v3/string.proto";
import "envoy/type/v3/http_status.proto";

import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/sensitive.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.ext_authz.v3";
option java_outer_classname = "ExtAuthzProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/ext_authz/v3;ext_authzv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: External Authorization]
// External Authorization :ref:`configuration overview <config_http_filters_ext_authz>`.
// [#extension: envoy.filters.http.ext_authz]

// [#next-free-field: 23]
message ExtAuthz {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.ext_authz.v2.ExtAuthz";

  reserved 4;

  reserved "use_alpha";

  // External authorization service configuration.
  oneof services {
    // gRPC service configuration (default timeout: 200ms).
    config.core.v3.GrpcService grpc_service = 1;

    // HTTP service configuration (default timeout: 200ms).
    HttpService http_service = 3;
  }

  // API version for ext_authz transport protocol. This describes the ext_authz gRPC endpoint and
  // version of messages used on the wire.
  config.core.v3.ApiVersion transport_api_version = 12
      [(validate.rules).enum = {defined_only: true}];

  //  Changes filter's behaviour on errors:
  //
  //  1. When set to true, the filter will ``accept`` client request even if the communication with
  //  the authorization service has failed, or if the authorization service has returned a HTTP 5xx
  //  error.
  //
  //  2. When set to false, ext-authz will ``reject`` client requests and return a ``Forbidden``
  //  response if the communication with the authorization service has failed, or if the
  //  authorization service has returned a HTTP 5xx error.
  //
  // Note that errors can be ``always`` tracked in the :ref:`stats
  // <config_http_filters_ext_authz_stats>`.
  bool failure_mode_allow = 2;

  // When ``failure_mode_allow`` and ``failure_mode_allow_header_add`` are both set to true,
  // ``x-envoy-auth-failure-mode-allowed: true`` will be added to request headers if the communication
  // with the authorization service has failed, or if the authorization service has returned a
  // HTTP 5xx error.
  bool failure_mode_allow_header_add = 19;

  // Enables filter to buffer the client request body and send it within the authorization request.
  // A ``x-envoy-auth-partial-body: false|true`` metadata header will be added to the authorization
  // request message indicating if the body data is partial.
  BufferSettings with_request_body = 5;

  // Clears route cache in order to allow the external authorization service to correctly affect
  // routing decisions. Filter clears all cached routes when:
  //
  // 1. The field is set to ``true``.
  //
  // 2. The status returned from the authorization service is a HTTP 200 or gRPC 0.
  //
  // 3. At least one ``authorization response header`` is added to the client request, or is used for
  // altering another client request header.
  //
  bool clear_route_cache = 6;

  // Sets the HTTP status that is returned to the client when the authorization server returns an error
  // or cannot be reached. The default status is HTTP 403 Forbidden.
  type.v3.HttpStatus status_on_error = 7;

  // Specifies a list of metadata namespaces whose values, if present, will be passed to the
  // ext_authz service. The :ref:`filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.filter_metadata>`
  // is passed as an opaque ``protobuf::Struct``.
  //
  // Please note that this field exclusively applies to the gRPC ext_authz service and has no effect on the HTTP service.
  //
  // For example, if the ``jwt_authn`` filter is used and :ref:`payload_in_metadata
  // <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.payload_in_metadata>` is set,
  // then the following will pass the jwt payload to the authorization server.
  //
  // .. code-block:: yaml
  //
  //    metadata_context_namespaces:
  //    - envoy.filters.http.jwt_authn
  //
  repeated string metadata_context_namespaces = 8;

  // Specifies a list of metadata namespaces whose values, if present, will be passed to the
  // ext_authz service. :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>`
  // is passed as a ``protobuf::Any``.
  //
  // Please note that this field exclusively applies to the gRPC ext_authz service and has no effect on the HTTP service.
  //
  // It works in a way similar to ``metadata_context_namespaces`` but allows Envoy and ext_authz server to share
  // the protobuf message definition in order to do a safe parsing.
  //
  repeated string typed_metadata_context_namespaces = 16;

  // Specifies a list of route metadata namespaces whose values, if present, will be passed to the
  // ext_authz service at :ref:`route_metadata_context <envoy_v3_api_field_service.auth.v3.AttributeContext.route_metadata_context>` in
  // :ref:`CheckRequest <envoy_v3_api_field_service.auth.v3.CheckRequest.attributes>`.
  // :ref:`filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.filter_metadata>` is passed as an opaque ``protobuf::Struct``.
  repeated string route_metadata_context_namespaces = 21;

  // Specifies a list of route metadata namespaces whose values, if present, will be passed to the
  // ext_authz service at :ref:`route_metadata_context <envoy_v3_api_field_service.auth.v3.AttributeContext.route_metadata_context>` in
  // :ref:`CheckRequest <envoy_v3_api_field_service.auth.v3.CheckRequest.attributes>`.
  // :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>` is passed as an ``protobuf::Any``.
  repeated string route_typed_metadata_context_namespaces = 22;

  // Specifies if the filter is enabled.
  //
  // If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is specified,
  // Envoy will lookup the runtime key to get the percentage of requests to filter.
  //
  // If this field is not specified, the filter will be enabled for all requests.
  config.core.v3.RuntimeFractionalPercent filter_enabled = 9;

  // Specifies if the filter is enabled with metadata matcher.
  // If this field is not specified, the filter will be enabled for all requests.
  type.matcher.v3.MetadataMatcher filter_enabled_metadata = 14;

  // Specifies whether to deny the requests, when the filter is disabled.
  // If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFeatureFlag.runtime_key>` is specified,
  // Envoy will lookup the runtime key to determine whether to deny request for
  // filter protected path at filter disabling. If filter is disabled in
  // typed_per_filter_config for the path, requests will not be denied.
  //
  // If this field is not specified, all requests will be allowed when disabled.
  //
  // If a request is denied due to this setting, the response code in :ref:`status_on_error
  // <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.status_on_error>` will
  // be returned.
  config.core.v3.RuntimeFeatureFlag deny_at_disable = 11;

  // Specifies if the peer certificate is sent to the external service.
  //
  // When this field is true, Envoy will include the peer X.509 certificate, if available, in the
  // :ref:`certificate<envoy_v3_api_field_service.auth.v3.AttributeContext.Peer.certificate>`.
  bool include_peer_certificate = 10;

  // Optional additional prefix to use when emitting statistics. This allows to distinguish
  // emitted statistics between configured ``ext_authz`` filters in an HTTP filter chain. For example:
  //
  // .. code-block:: yaml
  //
  //   http_filters:
  //     - name: envoy.filters.http.ext_authz
  //       typed_config:
  //         "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
  //         stat_prefix: waf # This emits ext_authz.waf.ok, ext_authz.waf.denied, etc.
  //     - name: envoy.filters.http.ext_authz
  //       typed_config:
  //         "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
  //         stat_prefix: blocker # This emits ext_authz.blocker.ok, ext_authz.blocker.denied, etc.
  //
  string stat_prefix = 13;

  // Optional labels that will be passed to :ref:`labels<envoy_v3_api_field_service.auth.v3.AttributeContext.Peer.labels>` in
  // :ref:`destination<envoy_v3_api_field_service.auth.v3.AttributeContext.destination>`.
  // The labels will be read from :ref:`metadata<envoy_v3_api_msg_config.core.v3.Node>` with the specified key.
  string bootstrap_metadata_labels_key = 15;

  // Check request to authorization server will include the client request headers that have a correspondent match
  // in the :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>`. If this option isn't specified, then
  // all client request headers are included in the check request to a gRPC authorization server, whereas no client request headers
  // (besides the ones allowed by default - see note below) are included in the check request to an HTTP authorization server.
  // This inconsistency between gRPC and HTTP servers is to maintain backwards compatibility with legacy behavior.
  //
  // .. note::
  //
  //  1. For requests to an HTTP authorization server: in addition to the the user's supplied matchers, ``Host``, ``Method``, ``Path``,
  //     ``Content-Length``, and ``Authorization`` are **additionally included** in the list.
  //
  // .. note::
  //
  //  2. For requests to an HTTP authorization server: *Content-Length* will be set to 0 and the request to the
  //  authorization server will not have a message body. However, the check request can include the buffered
  //  client request body (controlled by :ref:`with_request_body
  //  <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.with_request_body>` setting),
  //  consequently the value of *Content-Length* of the authorization request reflects the size of
  //  its payload size.
  type.matcher.v3.ListStringMatcher allowed_headers = 17;

  // Specifies if the TLS session level details like SNI are sent to the external service.
  //
  // When this field is true, Envoy will include the SNI name used for TLSClientHello, if available, in the
  // :ref:`tls_session<envoy_v3_api_field_service.auth.v3.AttributeContext.tls_session>`.
  bool include_tls_session = 18;

  // Whether to increment cluster statistics (e.g. cluster.<cluster_name>.upstream_rq_*) on authorization failure.
  // Defaults to true.
  google.protobuf.BoolValue charge_cluster_response_stats = 20;
}

// Configuration for buffering the request data.
message BufferSettings {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.ext_authz.v2.BufferSettings";

  // Sets the maximum size of a message body that the filter will hold in memory. Envoy will return
  // ``HTTP 413`` and will *not* initiate the authorization process when buffer reaches the number
  // set in this field. Note that this setting will have precedence over :ref:`failure_mode_allow
  // <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.failure_mode_allow>`.
  uint32 max_request_bytes = 1 [(validate.rules).uint32 = {gt: 0}];

  // When this field is true, Envoy will buffer the message until ``max_request_bytes`` is reached.
  // The authorization request will be dispatched and no 413 HTTP error will be returned by the
  // filter.
  bool allow_partial_message = 2;

  // If true, the body sent to the external authorization service is set with raw bytes, it sets
  // the :ref:`raw_body<envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.raw_body>`
  // field of HTTP request attribute context. Otherwise, :ref:`body
  // <envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.body>` will be filled
  // with UTF-8 string request body.
  //
  // This field only affects configurations using a :ref:`grpc_service
  // <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.grpc_service>`. In configurations that use
  // an :ref:`http_service <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.http_service>`, this
  // has no effect.
  bool pack_as_bytes = 3;
}

// HttpService is used for raw HTTP communication between the filter and the authorization service.
// When configured, the filter will parse the client request and use these attributes to call the
// authorization server. Depending on the response, the filter may reject or accept the client
// request. Note that in any of these events, metadata can be added, removed or overridden by the
// filter:
//
// *On authorization request*, a list of allowed request headers may be supplied. See
// :ref:`allowed_headers
// <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationRequest.allowed_headers>`
// for details. Additional headers metadata may be added to the authorization request. See
// :ref:`headers_to_add
// <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationRequest.headers_to_add>` for
// details.
//
// On authorization response status HTTP 200 OK, the filter will allow traffic to the upstream and
// additional headers metadata may be added to the original client request. See
// :ref:`allowed_upstream_headers
// <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_upstream_headers>`
// for details. Additionally, the filter may add additional headers to the client's response. See
// :ref:`allowed_client_headers_on_success
// <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_client_headers_on_success>`
// for details.
//
// On other authorization response statuses, the filter will not allow traffic. Additional headers
// metadata as well as body may be added to the client's response. See :ref:`allowed_client_headers
// <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_client_headers>`
// for details.
// [#next-free-field: 9]
message HttpService {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.ext_authz.v2.HttpService";

  reserved 3, 4, 5, 6;

  // Sets the HTTP server URI which the authorization requests must be sent to.
  config.core.v3.HttpUri server_uri = 1;

  // Sets a prefix to the value of authorization request header ``Path``.
  string path_prefix = 2;

  // Settings used for controlling authorization request metadata.
  AuthorizationRequest authorization_request = 7;

  // Settings used for controlling authorization response metadata.
  AuthorizationResponse authorization_response = 8;
}

message AuthorizationRequest {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.ext_authz.v2.AuthorizationRequest";

  // Authorization request includes the client request headers that have a correspondent match
  // in the :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>`.
  // This field has been deprecated in favor of :ref:`allowed_headers
  // <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.allowed_headers>`.
  //
  // .. note::
  //
  //   In addition to the the user's supplied matchers, ``Host``, ``Method``, ``Path``,
  //   ``Content-Length``, and ``Authorization`` are **automatically included** to the list.
  //
  // .. note::
  //
  //   By default, ``Content-Length`` header is set to ``0`` and the request to the authorization
  //   service has no message body. However, the authorization request *may* include the buffered
  //   client request body (controlled by :ref:`with_request_body
  //   <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.with_request_body>`
  //   setting) hence the value of its ``Content-Length`` reflects the size of its payload size.
  //
  type.matcher.v3.ListStringMatcher allowed_headers = 1
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Sets a list of headers that will be included to the request to authorization service. Note that
  // client request of the same key will be overridden.
  repeated config.core.v3.HeaderValue headers_to_add = 2;
}

// [#next-free-field: 6]
message AuthorizationResponse {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.ext_authz.v2.AuthorizationResponse";

  // When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
  // response headers that have a correspondent match will be added to the original client request.
  // Note that coexistent headers will be overridden.
  type.matcher.v3.ListStringMatcher allowed_upstream_headers = 1;

  // When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
  // response headers that have a correspondent match will be added to the original client request.
  // Note that coexistent headers will be appended.
  type.matcher.v3.ListStringMatcher allowed_upstream_headers_to_append = 3;

  // When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
  // response headers that have a correspondent match will be added to the client's response. Note
  // that when this list is *not* set, all the authorization response headers, except ``Authority
  // (Host)`` will be in the response to the client. When a header is included in this list, ``Path``,
  // ``Status``, ``Content-Length``, ``WWWAuthenticate`` and ``Location`` are automatically added.
  type.matcher.v3.ListStringMatcher allowed_client_headers = 2;

  // When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
  // response headers that have a correspondent match will be added to the client's response when
  // the authorization response itself is successful, i.e. not failed or denied. When this list is
  // *not* set, no additional headers will be added to the client's response on success.
  type.matcher.v3.ListStringMatcher allowed_client_headers_on_success = 4;

  // When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
  // response headers that have a correspondent match will be emitted as dynamic metadata to be consumed
  // by the next filter. This metadata lives in a namespace specified by the canonical name of extension filter
  // that requires it:
  //
  // - :ref:`envoy.filters.http.ext_authz <config_http_filters_ext_authz_dynamic_metadata>` for HTTP filter.
  // - :ref:`envoy.filters.network.ext_authz <config_network_filters_ext_authz_dynamic_metadata>` for network filter.
  type.matcher.v3.ListStringMatcher dynamic_metadata_from_headers = 5;
}

// Extra settings on a per virtualhost/route/weighted-cluster level.
message ExtAuthzPerRoute {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.ext_authz.v2.ExtAuthzPerRoute";

  oneof override {
    option (validate.required) = true;

    // Disable the ext auth filter for this particular vhost or route.
    // If disabled is specified in multiple per-filter-configs, the most specific one will be used.
    bool disabled = 1 [(validate.rules).bool = {const: true}];

    // Check request settings for this route.
    CheckSettings check_settings = 2 [(validate.rules).message = {required: true}];
  }
}

// Extra settings for the check request.
message CheckSettings {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.ext_authz.v2.CheckSettings";

  // Context extensions to set on the CheckRequest's
  // :ref:`AttributeContext.context_extensions<envoy_v3_api_field_service.auth.v3.AttributeContext.context_extensions>`
  //
  // You can use this to provide extra context for the external authorization server on specific
  // virtual hosts/routes. For example, adding a context extension on the virtual host level can
  // give the ext-authz server information on what virtual host is used without needing to parse the
  // host header. If CheckSettings is specified in multiple per-filter-configs, they will be merged
  // in order, and the result will be used.
  //
  // Merge semantics for this field are such that keys from more specific configs override.
  //
  // .. note::
  //
  //   These settings are only applied to a filter configured with a
  //   :ref:`grpc_service<envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.grpc_service>`.
  map<string, string> context_extensions = 1 [(udpa.annotations.sensitive) = true];

  // When set to true, disable the configured :ref:`with_request_body
  // <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.with_request_body>` for a specific route.
  //
  // Please note that only one of *disable_request_body_buffering* or
  // :ref:`with_request_body <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.CheckSettings.with_request_body>`
  // may be specified.
  bool disable_request_body_buffering = 2;

  // Enable or override request body buffering, which is configured using the
  // :ref:`with_request_body <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.with_request_body>`
  // option for a specific route.
  //
  // Please note that only only one of *with_request_body* or
  // :ref:`disable_request_body_buffering <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.CheckSettings.disable_request_body_buffering>`
  // may be specified.
  BufferSettings with_request_body = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.ratelimit.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/ratelimit/v3/rls.proto";
import "envoy/config/route/v3/route_components.proto";
import "envoy/type/metadata/v3/metadata.proto";
import "envoy/type/v3/http_status.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.ratelimit.v3";
option java_outer_classname = "RateLimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/ratelimit/v3;ratelimitv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Rate limit]
// Rate limit :ref:`configuration overview <config_http_filters_rate_limit>`.
// [#extension: envoy.filters.http.ratelimit]

// [#next-free-field: 14]
message RateLimit {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.rate_limit.v2.RateLimit";

  // Defines the version of the standard to use for X-RateLimit headers.
  //
  // [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.XRateLimitHeadersRFCVersion instead.]
  enum XRateLimitHeadersRFCVersion {
    // X-RateLimit headers disabled.
    OFF = 0;

    // Use `draft RFC Version 03 <https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html>`_.
    DRAFT_VERSION_03 = 1;
  }

  // The rate limit domain to use when calling the rate limit service.
  string domain = 1 [(validate.rules).string = {min_len: 1}];

  // Specifies the rate limit configurations to be applied with the same
  // stage number. If not set, the default stage number is 0.
  //
  // .. note::
  //
  //  The filter supports a range of 0 - 10 inclusively for stage numbers.
  uint32 stage = 2 [(validate.rules).uint32 = {lte: 10}];

  // The type of requests the filter should apply to. The supported
  // types are ``internal``, ``external`` or ``both``. A request is considered internal if
  // :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>` is set to true. If
  // :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>` is not set or false, a
  // request is considered external. The filter defaults to ``both``, and it will apply to all request
  // types.
  string request_type = 3
      [(validate.rules).string = {in: "internal" in: "external" in: "both" in: ""}];

  // The timeout in milliseconds for the rate limit service RPC. If not
  // set, this defaults to 20ms.
  google.protobuf.Duration timeout = 4;

  // The filter's behaviour in case the rate limiting service does
  // not respond back. When it is set to true, Envoy will not allow traffic in case of
  // communication failure between rate limiting service and the proxy.
  bool failure_mode_deny = 5;

  // Specifies whether a ``RESOURCE_EXHAUSTED`` gRPC code must be returned instead
  // of the default ``UNAVAILABLE`` gRPC code for a rate limited gRPC call. The
  // HTTP code will be 200 for a gRPC response.
  bool rate_limited_as_resource_exhausted = 6;

  // Configuration for an external rate limit service provider. If not
  // specified, any calls to the rate limit service will immediately return
  // success.
  config.ratelimit.v3.RateLimitServiceConfig rate_limit_service = 7
      [(validate.rules).message = {required: true}];

  // Defines the standard version to use for X-RateLimit headers emitted by the filter:
  //
  // * ``X-RateLimit-Limit`` - indicates the request-quota associated to the
  //   client in the current time-window followed by the description of the
  //   quota policy. The values are returned by the rate limiting service in
  //   :ref:`current_limit<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.current_limit>`
  //   field. Example: ``10, 10;w=1;name="per-ip", 1000;w=3600``.
  // * ``X-RateLimit-Remaining`` - indicates the remaining requests in the
  //   current time-window. The values are returned by the rate limiting service
  //   in :ref:`limit_remaining<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.limit_remaining>`
  //   field.
  // * ``X-RateLimit-Reset`` - indicates the number of seconds until reset of
  //   the current time-window. The values are returned by the rate limiting service
  //   in :ref:`duration_until_reset<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.duration_until_reset>`
  //   field.
  //
  // In case rate limiting policy specifies more then one time window, the values
  // above represent the window that is closest to reaching its limit.
  //
  // For more information about the headers specification see selected version of
  // the `draft RFC <https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html>`_.
  //
  // Disabled by default.
  //
  // [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.XRateLimitHeadersRFCVersion instead.]
  XRateLimitHeadersRFCVersion enable_x_ratelimit_headers = 8
      [(validate.rules).enum = {defined_only: true}];

  // Disables emitting the :ref:`x-envoy-ratelimited<config_http_filters_router_x-envoy-ratelimited>` header
  // in case of rate limiting (i.e. 429 responses).
  // Having this header not present potentially makes the request retriable.
  bool disable_x_envoy_ratelimited_header = 9;

  // This field allows for a custom HTTP response status code to the downstream client when
  // the request has been rate limited.
  // Defaults to 429 (TooManyRequests).
  //
  // .. note::
  //   If this is set to < 400, 429 will be used instead.
  type.v3.HttpStatus rate_limited_status = 10;

  // Specifies a list of HTTP headers that should be added to each response for requests that
  // have been rate limited.
  repeated config.core.v3.HeaderValueOption response_headers_to_add = 11
      [(validate.rules).repeated = {max_items: 10}];

  // Sets the HTTP status that is returned to the client when the ratelimit server returns an error
  // or cannot be reached. The default status is 500.
  type.v3.HttpStatus status_on_error = 12;

  // Optional additional prefix to use when emitting statistics. This allows to distinguish
  // emitted statistics between configured ``ratelimit`` filters in an HTTP filter chain.
  string stat_prefix = 13;
}

// Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
// Also applies to Local rate limiting :ref:`using descriptors <config_http_filters_local_rate_limit_descriptors>`.
// [#not-implemented-hide:]
message RateLimitConfig {
  // [#next-free-field: 10]
  message Action {
    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("source_cluster", "<local service cluster>")
    //
    // <local service cluster> is derived from the :option:`--service-cluster` option.
    message SourceCluster {
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("destination_cluster", "<routed target cluster>")
    //
    // Once a request matches against a route table rule, a routed cluster is determined by one of
    // the following :ref:`route table configuration <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`
    // settings:
    //
    // * :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` indicates the upstream cluster
    //   to route to.
    // * :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`
    //   chooses a cluster randomly from a set of clusters with attributed weight.
    // * :ref:`cluster_header <envoy_v3_api_field_config.route.v3.RouteAction.cluster_header>` indicates which
    //   header in the request contains the target cluster.
    message DestinationCluster {
    }

    // The following descriptor entry is appended when a header contains a key that matches the
    // ``header_name``:
    //
    // .. code-block:: cpp
    //
    //   ("<descriptor_key>", "<header_value_queried_from_header>")
    message RequestHeaders {
      // The header name to be queried from the request headers. The headers
      // value is used to populate the value of the descriptor entry for the
      // descriptor_key.
      string header_name = 1
          [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

      // The key to use in the descriptor entry.
      string descriptor_key = 2 [(validate.rules).string = {min_len: 1}];

      // If set to true, Envoy skips the descriptor while calling rate limiting service
      // when header is not present in the request. By default it skips calling the
      // rate limiting service if this header is not present in the request.
      bool skip_if_absent = 3;
    }

    // The following descriptor entry is appended to the descriptor and is populated using the
    // trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
    //
    // .. code-block:: cpp
    //
    //   ("remote_address", "<trusted address from x-forwarded-for>")
    message RemoteAddress {
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("generic_key", "<descriptor_value>")
    message GenericKey {
      // The value to use in the descriptor entry.
      string descriptor_value = 1 [(validate.rules).string = {min_len: 1}];

      // An optional key to use in the descriptor entry. If not set it defaults
      // to 'generic_key' as the descriptor key.
      string descriptor_key = 2;
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("header_match", "<descriptor_value>")
    message HeaderValueMatch {
      // The value to use in the descriptor entry.
      string descriptor_value = 1 [(validate.rules).string = {min_len: 1}];

      // If set to true, the action will append a descriptor entry when the
      // request matches the headers. If set to false, the action will append a
      // descriptor entry when the request does not match the headers. The
      // default value is true.
      bool expect_match = 2;

      // Specifies a set of headers that the rate limit action should match
      // on. The action will check the requests headers against all the
      // specified headers in the config. A match will happen if all the
      // headers in the config are present in the request with the same values
      // (or based on presence if the value field is not in the config).
      repeated config.route.v3.HeaderMatcher headers = 3
          [(validate.rules).repeated = {min_items: 1}];
    }

    // The following descriptor entry is appended when the metadata contains a key value:
    //
    // .. code-block:: cpp
    //
    //   ("<descriptor_key>", "<value_queried_from_metadata>")
    // [#next-free-field: 6]
    message MetaData {
      enum Source {
        // Query :ref:`dynamic metadata <well_known_dynamic_metadata>`
        DYNAMIC = 0;

        // Query :ref:`route entry metadata <envoy_v3_api_field_config.route.v3.Route.metadata>`
        ROUTE_ENTRY = 1;
      }

      // The key to use in the descriptor entry.
      string descriptor_key = 1 [(validate.rules).string = {min_len: 1}];

      // Metadata struct that defines the key and path to retrieve the string value. A match will
      // only happen if the value in the metadata is of type string.
      type.metadata.v3.MetadataKey metadata_key = 2 [(validate.rules).message = {required: true}];

      // An optional value to use if ``metadata_key`` is empty. If not set and
      // no value is present under the metadata_key then ``skip_if_absent`` is followed to
      // skip calling the rate limiting service or skip the descriptor.
      string default_value = 3;

      // Source of metadata
      Source source = 4 [(validate.rules).enum = {defined_only: true}];

      // If set to true, Envoy skips the descriptor while calling rate limiting service
      // when ``metadata_key`` is empty and ``default_value`` is not set. By default it skips calling the
      // rate limiting service in that case.
      bool skip_if_absent = 5;
    }

    oneof action_specifier {
      option (validate.required) = true;

      // Rate limit on source cluster.
      SourceCluster source_cluster = 1;

      // Rate limit on destination cluster.
      DestinationCluster destination_cluster = 2;

      // Rate limit on request headers.
      RequestHeaders request_headers = 3;

      // Rate limit on remote address.
      RemoteAddress remote_address = 4;

      // Rate limit on a generic key.
      GenericKey generic_key = 5;

      // Rate limit on the existence of request headers.
      HeaderValueMatch header_value_match = 6;

      // Rate limit on metadata.
      MetaData metadata = 8;

      // Rate limit descriptor extension. See the rate limit descriptor extensions documentation.
      // [#extension-category: envoy.rate_limit_descriptors]
      config.core.v3.TypedExtensionConfig extension = 9;
    }
  }

  message Override {
    // Fetches the override from the dynamic metadata.
    message DynamicMetadata {
      // Metadata struct that defines the key and path to retrieve the struct value.
      // The value must be a struct containing an integer "requests_per_unit" property
      // and a "unit" property with a value parseable to :ref:`RateLimitUnit
      // enum <envoy_v3_api_enum_type.v3.RateLimitUnit>`
      type.metadata.v3.MetadataKey metadata_key = 1 [(validate.rules).message = {required: true}];
    }

    oneof override_specifier {
      option (validate.required) = true;

      // Limit override from dynamic metadata.
      DynamicMetadata dynamic_metadata = 1;
    }
  }

  // Refers to the stage set in the filter. The rate limit configuration only
  // applies to filters with the same stage number. The default stage number is
  // 0.
  //
  // .. note::
  //
  //   The filter supports a range of 0 - 10 inclusively for stage numbers.
  uint32 stage = 1 [(validate.rules).uint32 = {lte: 10}];

  // The key to be set in runtime to disable this rate limit configuration.
  string disable_key = 2;

  // A list of actions that are to be applied for this rate limit configuration.
  // Order matters as the actions are processed sequentially and the descriptor
  // is composed by appending descriptor entries in that sequence. If an action
  // cannot append a descriptor entry, no descriptor is generated for the
  // configuration. See :ref:`composing actions
  // <config_http_filters_rate_limit_composing_actions>` for additional documentation.
  repeated Action actions = 3 [(validate.rules).repeated = {min_items: 1}];

  // An optional limit override to be appended to the descriptor produced by this
  // rate limit configuration. If the override value is invalid or cannot be resolved
  // from metadata, no override is provided. See :ref:`rate limit override
  // <config_http_filters_rate_limit_rate_limit_override>` for more information.
  Override limit = 4;
}

message RateLimitPerRoute {
  // [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.VhRateLimitsOptions instead.]
  enum VhRateLimitsOptions {
    // Use the virtual host rate limits unless the route has a rate limit policy.
    OVERRIDE = 0;

    // Use the virtual host rate limits even if the route has a rate limit policy.
    INCLUDE = 1;

    // Ignore the virtual host rate limits even if the route does not have a rate limit policy.
    IGNORE = 2;
  }

  // The override option determines how the filter handles the cases where there is an override config at a more specific level than this one (from least to most specific: virtual host, route, cluster weight).
  // [#not-implemented-hide:]
  enum OverrideOptions {
    // Client-defined default, typically OVERRIDE_POLICY. If VhRateLimitsOptions is set, that will be used instead.
    DEFAULT = 0;

    // If there is an override config at a more specific level, use that instead of this one.
    OVERRIDE_POLICY = 1;

    // If there is an override config at a more specific level, use data from both.
    INCLUDE_POLICY = 2;

    // If there is an override config at a more specific level, ignore it and use only this one.
    IGNORE_POLICY = 3;
  }

  // Specifies if the rate limit filter should include the virtual host rate limits.
  // [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.VhRateLimitsOptions instead.]
  VhRateLimitsOptions vh_rate_limits = 1 [(validate.rules).enum = {defined_only: true}];

  // Specifies if the rate limit filter should include the lower levels (route level, virtual host level or cluster weight level) rate limits override options.
  // [#not-implemented-hide:]
  OverrideOptions override_option = 2 [(validate.rules).enum = {defined_only: true}];

  // Rate limit configuration. If not set, uses the
  // :ref:`VirtualHost.rate_limits<envoy_v3_api_field_config.route.v3.VirtualHost.rate_limits>` or
  // :ref:`RouteAction.rate_limits<envoy_v3_api_field_config.route.v3.RouteAction.rate_limits>` fields instead.
  // [#not-implemented-hide:]
  repeated RateLimitConfig rate_limits = 3;

  // Overrides the domain. If not set, uses the filter-level domain instead.
  string domain = 4;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/config/ratelimit/v3:pkg",
        "//envoy/config/route/v3:pkg",
        "//envoy/type/metadata/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.credential_injector.v3;

import "envoy/config/core/v3/extension.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.credential_injector.v3";
option java_outer_classname = "CredentialInjectorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/credential_injector/v3;credential_injectorv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: Credential Injector]
// [#not-implemented-hide:]
// Credential Injector :ref:`configuration overview <config_http_filters_credential_injector>`.
// [#extension: envoy.filters.http.credential_injector]

// Credential Injector injects credentials into outgoing HTTP requests. The filter configuration is used to retrieve the credentials, or
// they can be requested through the OAuth2 client credential grant. The credentials obtained are then injected into the Authorization header
// of the proxied HTTP requests, utilizing either the Basic or Bearer scheme.
//
// If the credential is not present, the request will fail with 401 Unauthorized if fail_if_not_present is set to true.
//
// Notice: This filter is intended to be used for workload authentication, which means that the identity associated with the inserted credential
// is considered as the identity of the workload behind the envoy proxy(in this case, envoy is typically deployed as a sidecar alongside that
// workload). Please note that this filter does not handle end user authentication. Its purpose is solely to authenticate the workload itself.
//
// Here is an example of CredentialInjector configuration with Generic credential, which injects an HTTP Basic Auth credential into the proxied requests.
//
//  .. code-block:: yaml
//
//  overwrite: true
//  fail_if_not_present: true
//  credential:
//    name: generic_credential
//    typed_config:
//      "@type": type.googleapis.com/envoy.extensions.injected_credentials.generic.v3.Generic
//      credential:
//        name: credential
//        sds_config:
//          path_config_source:
//            path: credential.yaml
//      header: Authorization
//
// credential.yaml for Basic Auth:
//  .. code-block:: yaml
//
//  resources:
//  - "@type": "type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.Secret"
//    name: credential
//    generic_secret:
//      secret:
//        inline_string: "Basic base64EncodedUsernamePassword"
//
// It can also be configured to inject a Bearer token into the proxied requests.
// credential.yaml for Bearer Token:
//  .. code-block:: yaml
//
//  resources:
//  - "@type": "type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.Secret"
//    name: credential
//    generic_secret:
//      secret:
//        inline_string: "Bearer myToken"
//
message CredentialInjector {
  // Whether to overwrite the value or not if the injected headers already exist.
  // Value defaults to false.
  bool overwrite = 1;

  // Whether to fail the request if the credential is not present.
  // Value defaults to false.
  // If set to true, the request will fail with 401 Unauthorized if the credential is not present.
  bool fail_if_not_present = 2;

  // The credential to inject into the proxied requests
  // TODO add extension-category
  config.core.v3.TypedExtensionConfig credential = 3 [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/config/route/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.jwt_authn.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/http_uri.proto";
import "envoy/config/route/v3/route_components.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.jwt_authn.v3";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/jwt_authn/v3;jwt_authnv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: JWT Authentication]
// JWT Authentication :ref:`configuration overview <config_http_filters_jwt_authn>`.
// [#extension: envoy.filters.http.jwt_authn]

// Please see following for JWT authentication flow:
//
// * `JSON Web Token (JWT) <https://tools.ietf.org/html/rfc7519>`_
// * `The OAuth 2.0 Authorization Framework <https://tools.ietf.org/html/rfc6749>`_
// * `OpenID Connect <http://openid.net/connect>`_
//
// A JwtProvider message specifies how a JSON Web Token (JWT) can be verified. It specifies:
//
// * issuer: the principal that issues the JWT. If specified, it has to match the ``iss`` field in JWT.
// * allowed audiences: the ones in the token have to be listed here.
// * how to fetch public key JWKS to verify the token signature.
// * how to extract JWT token in the request.
// * how to pass successfully verified token payload.
//
// Example:
//
// .. code-block:: yaml
//
//     issuer: https://example.com
//     audiences:
//     - bookstore_android.apps.googleusercontent.com
//     - bookstore_web.apps.googleusercontent.com
//     remote_jwks:
//       http_uri:
//         uri: https://example.com/.well-known/jwks.json
//         cluster: example_jwks_cluster
//         timeout: 1s
//       cache_duration:
//         seconds: 300
//
// [#next-free-field: 19]
message JwtProvider {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider";

  // Alters the payload representation in the request dynamic metadata to facilitate its use in matching.
  message NormalizePayload {
    // Each claim in this list will be interpreted as a space-delimited string
    // and converted to a list of strings based on the delimited values.
    // Example: a token with a claim ``scopes: "email profile"`` is translated
    // to dynamic metadata  ``scopes: ["email", "profile"]`` if this field is
    // set value ``["scopes"]``. This special handling of ``scopes`` is
    // recommended by `RFC8693
    // <https://datatracker.ietf.org/doc/html/rfc8693#name-scope-scopes-claim>`_.
    repeated string space_delimited_claims = 1;
  }

  // Specify the `principal <https://tools.ietf.org/html/rfc7519#section-4.1.1>`_ that issued
  // the JWT, usually a URL or an email address.
  //
  // It is optional. If specified, it has to match the ``iss`` field in JWT,
  // otherwise the JWT ``iss`` field is not checked.
  //
  // Note: ``JwtRequirement`` :ref:`allow_missing <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtRequirement.allow_missing>`
  // and :ref:`allow_missing_or_failed <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtRequirement.allow_missing_or_failed>`
  // are implemented differently than other ``JwtRequirements``. Hence the usage of this field
  // is different as follows if ``allow_missing`` or ``allow_missing_or_failed`` is used:
  //
  // * If a JWT has ``iss`` field, it needs to be specified by this field in one of ``JwtProviders``.
  // * If a JWT doesn't have ``iss`` field, one of ``JwtProviders`` should fill this field empty.
  // * Multiple ``JwtProviders`` should not have same value in this field.
  //
  // Example: https://securetoken.google.com
  // Example: 1234567-compute@developer.gserviceaccount.com
  //
  string issuer = 1;

  // The list of JWT `audiences <https://tools.ietf.org/html/rfc7519#section-4.1.3>`_ are
  // allowed to access. A JWT containing any of these audiences will be accepted. If not specified,
  // will not check audiences in the token.
  //
  // Example:
  //
  // .. code-block:: yaml
  //
  //     audiences:
  //     - bookstore_android.apps.googleusercontent.com
  //     - bookstore_web.apps.googleusercontent.com
  //
  repeated string audiences = 2;

  // `JSON Web Key Set (JWKS) <https://tools.ietf.org/html/rfc7517#appendix-A>`_ is needed to
  // validate signature of a JWT. This field specifies where to fetch JWKS.
  oneof jwks_source_specifier {
    option (validate.required) = true;

    // JWKS can be fetched from remote server via HTTP/HTTPS. This field specifies the remote HTTP
    // URI and how the fetched JWKS should be cached.
    //
    // Example:
    //
    // .. code-block:: yaml
    //
    //    remote_jwks:
    //      http_uri:
    //        uri: https://www.googleapis.com/oauth2/v1/certs
    //        cluster: jwt.www.googleapis.com|443
    //        timeout: 1s
    //      cache_duration:
    //        seconds: 300
    //
    RemoteJwks remote_jwks = 3;

    // JWKS is in local data source. It could be either in a local file or embedded in the
    // inline_string.
    //
    // Example: local file
    //
    // .. code-block:: yaml
    //
    //    local_jwks:
    //      filename: /etc/envoy/jwks/jwks1.txt
    //
    // Example: inline_string
    //
    // .. code-block:: yaml
    //
    //    local_jwks:
    //      inline_string: ACADADADADA
    //
    config.core.v3.DataSource local_jwks = 4;
  }

  // If false, the JWT is removed in the request after a success verification. If true, the JWT is
  // not removed in the request. Default value is false.
  // caveat: only works for from_header & has no effect for JWTs extracted through from_params & from_cookies.
  bool forward = 5;

  // Two fields below define where to extract the JWT from an HTTP request.
  //
  // If no explicit location is specified, the following default locations are tried in order:
  //
  // 1. The Authorization header using the `Bearer schema
  // <https://tools.ietf.org/html/rfc6750#section-2.1>`_. Example::
  //
  //    Authorization: Bearer <token>.
  //
  // 2. `access_token <https://tools.ietf.org/html/rfc6750#section-2.3>`_ query parameter.
  //
  // Multiple JWTs can be verified for a request. Each JWT has to be extracted from the locations
  // its provider specified or from the default locations.
  //
  // Specify the HTTP headers to extract JWT token. For examples, following config:
  //
  // .. code-block:: yaml
  //
  //   from_headers:
  //   - name: x-goog-iap-jwt-assertion
  //
  // can be used to extract token from header::
  //
  //   ``x-goog-iap-jwt-assertion: <JWT>``.
  //
  repeated JwtHeader from_headers = 6;

  // JWT is sent in a query parameter. ``jwt_params`` represents the query parameter names.
  //
  // For example, if config is:
  //
  // .. code-block:: yaml
  //
  //   from_params:
  //   - jwt_token
  //
  // The JWT format in query parameter is::
  //
  //    /path?jwt_token=<JWT>
  //
  repeated string from_params = 7;

  // JWT is sent in a cookie. ``from_cookies`` represents the cookie names to extract from.
  //
  // For example, if config is:
  //
  // .. code-block:: yaml
  //
  //   from_cookies:
  //   - auth-token
  //
  // Then JWT will be extracted from ``auth-token`` cookie in the request.
  //
  repeated string from_cookies = 13;

  // This field specifies the header name to forward a successfully verified JWT payload to the
  // backend. The forwarded data is::
  //
  //    base64url_encoded(jwt_payload_in_JSON)
  //
  // If it is not specified, the payload will not be forwarded.
  string forward_payload_header = 8
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false}];

  // When :ref:`forward_payload_header <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.forward_payload_header>`
  // is specified, the base64 encoded payload will be added to the headers.
  // Normally JWT based64 encode doesn't add padding. If this field is true,
  // the header will be padded.
  //
  // This field is only relevant if :ref:`forward_payload_header <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.forward_payload_header>`
  // is specified.
  bool pad_forward_payload_header = 11;

  // If non empty, successfully verified JWT payloads will be written to StreamInfo DynamicMetadata
  // in the format as: ``namespace`` is the jwt_authn filter name as ````envoy.filters.http.jwt_authn````
  // The value is the ``protobuf::Struct``. The value of this field will be the key for its ``fields``
  // and the value is the ``protobuf::Struct`` converted from JWT JSON payload.
  //
  // For example, if payload_in_metadata is ``my_payload``:
  //
  // .. code-block:: yaml
  //
  //   envoy.filters.http.jwt_authn:
  //     my_payload:
  //       iss: https://example.com
  //       sub: test@example.com
  //       aud: https://example.com
  //       exp: 1501281058
  //
  string payload_in_metadata = 9;

  // Normalizes the payload representation in the request metadata.
  NormalizePayload normalize_payload_in_metadata = 18;

  // If not empty, similar to :ref:`payload_in_metadata <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.payload_in_metadata>`,
  // a successfully verified JWT header will be written to :ref:`Dynamic State <arch_overview_data_sharing_between_filters>`
  // as an entry (``protobuf::Struct``) in ``envoy.filters.http.jwt_authn`` ``namespace`` with the
  // value of this field as the key.
  //
  // For example, if ``header_in_metadata`` is ``my_header``:
  //
  // .. code-block:: yaml
  //
  //   envoy.filters.http.jwt_authn:
  //     my_header:
  //       alg: JWT
  //       kid: EF71iSaosbC5C4tC6Syq1Gm647M
  //       alg: PS256
  //
  // When the metadata has ``envoy.filters.http.jwt_authn`` entry already (for example if
  // :ref:`payload_in_metadata <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.payload_in_metadata>`
  // is not empty), it will be inserted as a new entry in the same ``namespace`` as shown below:
  //
  // .. code-block:: yaml
  //
  //   envoy.filters.http.jwt_authn:
  //     my_payload:
  //       iss: https://example.com
  //       sub: test@example.com
  //       aud: https://example.com
  //       exp: 1501281058
  //     my_header:
  //       alg: JWT
  //       kid: EF71iSaosbC5C4tC6Syq1Gm647M
  //       alg: PS256
  //
  // .. warning::
  //   Using the same key name for :ref:`header_in_metadata <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.payload_in_metadata>`
  //   and :ref:`payload_in_metadata <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.payload_in_metadata>`
  //   is not suggested due to potential override of existing entry, while it is not enforced during
  //   config validation.
  //
  string header_in_metadata = 14;

  // If non empty, the failure status ``::google::jwt_verify::Status`` for a non verified JWT will be written to StreamInfo DynamicMetadata
  // in the format as: ``namespace`` is the jwt_authn filter name as ``envoy.filters.http.jwt_authn``
  // The value is the ``protobuf::Struct``. The values of this field will be ``code`` and ``message``
  // and they will contain the JWT authentication failure status code and a message describing the failure.
  //
  // For example, if failed_status_in_metadata is ``my_auth_failure_status``:
  //
  // .. code-block:: yaml
  //
  //   envoy.filters.http.jwt_authn:
  //     my_auth_failure_status:
  //       code: 3
  //       message: Jwt expired
  string failed_status_in_metadata = 16;

  // Specify the clock skew in seconds when verifying JWT time constraint,
  // such as ``exp``, and ``nbf``. If not specified, default is 60 seconds.
  uint32 clock_skew_seconds = 10;

  // Enables JWT cache, its size is specified by ``jwt_cache_size``.
  // Only valid JWT tokens are cached.
  JwtCacheConfig jwt_cache_config = 12;

  // Add JWT claim to HTTP Header
  // Specify the claim name you want to copy in which HTTP header. For examples, following config:
  // The claim must be of type; string, int, double, bool. Array type claims are not supported
  // .. code-block:: yaml
  //
  //   claim_to_headers:
  //     - name: x-jwt-claim-nested-claim
  //       claim: claim.nested.key
  //
  // This header is only reserved for jwt claim; any other value will be overwritten.
  repeated JwtClaimToHeader claim_to_headers = 15;

  // Clears route cache in order to allow JWT token to correctly affect
  // routing decisions. Filter clears all cached routes when:
  //
  // 1. The field is set to ``true``.
  //
  // 2. At least one ``claim_to_headers`` header is added to the request OR
  //    if ``payload_in_metadata`` is set.
  //
  bool clear_route_cache = 17;
}

// This message specifies JWT Cache configuration.
message JwtCacheConfig {
  // The unit is number of JWT tokens, default to 100.
  uint32 jwt_cache_size = 1;
}

// This message specifies how to fetch JWKS from remote and how to cache it.
message RemoteJwks {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks";

  // The HTTP URI to fetch the JWKS. For example:
  //
  // .. code-block:: yaml
  //
  //    http_uri:
  //      uri: https://www.googleapis.com/oauth2/v1/certs
  //      cluster: jwt.www.googleapis.com|443
  //      timeout: 1s
  //
  config.core.v3.HttpUri http_uri = 1;

  // Duration after which the cached JWKS should be expired. If not specified, default cache
  // duration is 10 minutes.
  google.protobuf.Duration cache_duration = 2 [(validate.rules).duration = {
    lt {seconds: 9000000000}
    gte {nanos: 1000000}
  }];

  // Fetch Jwks asynchronously in the main thread before the listener is activated.
  // Fetched Jwks can be used by all worker threads.
  //
  // If this feature is not enabled:
  //
  // * The Jwks is fetched on-demand when the requests come. During the fetching, first
  //   few requests are paused until the Jwks is fetched.
  // * Each worker thread fetches its own Jwks since Jwks cache is per worker thread.
  //
  // If this feature is enabled:
  //
  // * Fetched Jwks is done in the main thread before the listener is activated. Its fetched
  //   Jwks can be used by all worker threads. Each worker thread doesn't need to fetch its own.
  // * Jwks is ready when the requests come, not need to wait for the Jwks fetching.
  //
  JwksAsyncFetch async_fetch = 3;

  // Retry policy for fetching Jwks. optional. turned off by default.
  //
  // For example:
  //
  // .. code-block:: yaml
  //
  //   retry_policy:
  //     retry_back_off:
  //       base_interval: 0.01s
  //       max_interval: 20s
  //     num_retries: 10
  //
  // will yield a randomized truncated exponential backoff policy with an initial delay of 10ms
  // 10 maximum attempts spaced at most 20s seconds.
  //
  // .. code-block:: yaml
  //
  //   retry_policy:
  //     num_retries:1
  //
  // uses the default :ref:`retry backoff strategy <envoy_v3_api_msg_config.core.v3.BackoffStrategy>`.
  // with the default base interval is 1000 milliseconds. and the default maximum interval of 10 times the base interval.
  //
  // if num_retries is omitted, the default is to allow only one retry.
  //
  //
  // If enabled, the retry policy will apply to all Jwks fetching approaches, e.g. on demand or asynchronously in background.
  //
  //
  config.core.v3.RetryPolicy retry_policy = 4;
}

// Fetch Jwks asynchronously in the main thread when the filter config is parsed.
// The listener is activated only after the Jwks is fetched.
// When the Jwks is expired in the cache, it is fetched again in the main thread.
// The fetched Jwks from the main thread can be used by all worker threads.
message JwksAsyncFetch {
  // If false, the listener is activated after the initial fetch is completed.
  // The initial fetch result can be either successful or failed.
  // If true, it is activated without waiting for the initial fetch to complete.
  // Default is false.
  bool fast_listener = 1;

  // The duration to refetch after a failed fetch. If not specified, default is 1 second.
  google.protobuf.Duration failed_refetch_duration = 2;
}

// This message specifies a header location to extract JWT token.
message JwtHeader {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader";

  // The HTTP header name.
  string name = 1
      [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

  // The value prefix. The value format is "value_prefix<token>"
  // For example, for "Authorization: Bearer <token>", value_prefix="Bearer " with a space at the
  // end.
  string value_prefix = 2
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];
}

// Specify a required provider with audiences.
message ProviderWithAudiences {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences";

  // Specify a required provider name.
  string provider_name = 1;

  // This field overrides the one specified in the JwtProvider.
  repeated string audiences = 2;
}

// This message specifies a Jwt requirement. An empty message means JWT verification is not
// required. Here are some config examples:
//
// .. code-block:: yaml
//
//  # Example 1: not required with an empty message
//
//  # Example 2: require A
//  provider_name: provider-A
//
//  # Example 3: require A or B
//  requires_any:
//    requirements:
//      - provider_name: provider-A
//      - provider_name: provider-B
//
//  # Example 4: require A and B
//  requires_all:
//    requirements:
//      - provider_name: provider-A
//      - provider_name: provider-B
//
//  # Example 5: require A and (B or C)
//  requires_all:
//    requirements:
//      - provider_name: provider-A
//      - requires_any:
//        requirements:
//          - provider_name: provider-B
//          - provider_name: provider-C
//
//  # Example 6: require A or (B and C)
//  requires_any:
//    requirements:
//      - provider_name: provider-A
//      - requires_all:
//        requirements:
//          - provider_name: provider-B
//          - provider_name: provider-C
//
//  # Example 7: A is optional (if token from A is provided, it must be valid, but also allows
//  missing token.)
//  requires_any:
//    requirements:
//    - provider_name: provider-A
//    - allow_missing: {}
//
//  # Example 8: A is optional and B is required.
//  requires_all:
//    requirements:
//    - requires_any:
//        requirements:
//        - provider_name: provider-A
//        - allow_missing: {}
//    - provider_name: provider-B
//
// [#next-free-field: 7]
message JwtRequirement {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement";

  oneof requires_type {
    // Specify a required provider name.
    string provider_name = 1;

    // Specify a required provider with audiences.
    ProviderWithAudiences provider_and_audiences = 2;

    // Specify list of JwtRequirement. Their results are OR-ed.
    // If any one of them passes, the result is passed.
    JwtRequirementOrList requires_any = 3;

    // Specify list of JwtRequirement. Their results are AND-ed.
    // All of them must pass, if one of them fails or missing, it fails.
    JwtRequirementAndList requires_all = 4;

    // The requirement is always satisfied even if JWT is missing or the JWT
    // verification fails. A typical usage is: this filter is used to only verify
    // JWTs and pass the verified JWT payloads to another filter, the other filter
    // will make decision. In this mode, all JWT tokens will be verified.
    google.protobuf.Empty allow_missing_or_failed = 5;

    // The requirement is satisfied if JWT is missing, but failed if JWT is
    // presented but invalid. Similar to allow_missing_or_failed, this is used
    // to only verify JWTs and pass the verified payload to another filter. The
    // different is this mode will reject requests with invalid tokens.
    google.protobuf.Empty allow_missing = 6;
  }
}

// This message specifies a list of RequiredProvider.
// Their results are OR-ed; if any one of them passes, the result is passed
message JwtRequirementOrList {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList";

  // Specify a list of JwtRequirement.
  repeated JwtRequirement requirements = 1 [(validate.rules).repeated = {min_items: 2}];
}

// This message specifies a list of RequiredProvider.
// Their results are AND-ed; all of them must pass, if one of them fails or missing, it fails.
message JwtRequirementAndList {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList";

  // Specify a list of JwtRequirement.
  repeated JwtRequirement requirements = 1 [(validate.rules).repeated = {min_items: 2}];
}

// This message specifies a Jwt requirement for a specific Route condition.
// Example 1:
//
// .. code-block:: yaml
//
//    - match:
//        prefix: /healthz
//
// In above example, "requires" field is empty for /healthz prefix match,
// it means that requests matching the path prefix don't require JWT authentication.
//
// Example 2:
//
// .. code-block:: yaml
//
//    - match:
//        prefix: /
//      requires: { provider_name: provider-A }
//
// In above example, all requests matched the path prefix require jwt authentication
// from "provider-A".
message RequirementRule {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule";

  // The route matching parameter. Only when the match is satisfied, the "requires" field will
  // apply.
  //
  // For example: following match will match all requests.
  //
  // .. code-block:: yaml
  //
  //    match:
  //      prefix: /
  //
  config.route.v3.RouteMatch match = 1 [(validate.rules).message = {required: true}];

  // Specify a Jwt requirement.
  // If not specified, Jwt verification is disabled.
  oneof requirement_type {
    // Specify a Jwt requirement. Please see detail comment in message JwtRequirement.
    JwtRequirement requires = 2;

    // Use requirement_name to specify a Jwt requirement.
    // This requirement_name MUST be specified at the
    // :ref:`requirement_map <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtAuthentication.requirement_map>`
    // in ``JwtAuthentication``.
    string requirement_name = 3 [(validate.rules).string = {min_len: 1}];
  }
}

// This message specifies Jwt requirements based on stream_info.filterState.
// This FilterState should use ``Router::StringAccessor`` object to set a string value.
// Other HTTP filters can use it to specify Jwt requirements dynamically.
//
// Example:
//
// .. code-block:: yaml
//
//    name: jwt_selector
//    requires:
//      issuer_1:
//        provider_name: issuer1
//      issuer_2:
//        provider_name: issuer2
//
// If a filter set "jwt_selector" with "issuer_1" to FilterState for a request,
// jwt_authn filter will use JwtRequirement{"provider_name": "issuer1"} to verify.
message FilterStateRule {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule";

  // The filter state name to retrieve the ``Router::StringAccessor`` object.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // A map of string keys to requirements. The string key is the string value
  // in the FilterState with the name specified in the ``name`` field above.
  map<string, JwtRequirement>
  requires = 3;
}

// This is the Envoy HTTP filter config for JWT authentication.
//
// For example:
//
// .. code-block:: yaml
//
//   providers:
//      provider1:
//        issuer: issuer1
//        audiences:
//        - audience1
//        - audience2
//        remote_jwks:
//          http_uri:
//            uri: https://example.com/.well-known/jwks.json
//            cluster: example_jwks_cluster
//            timeout: 1s
//      provider2:
//        issuer: issuer2
//        local_jwks:
//          inline_string: jwks_string
//
//   rules:
//      # Not jwt verification is required for /health path
//      - match:
//          prefix: /health
//
//      # Jwt verification for provider1 is required for path prefixed with "prefix"
//      - match:
//          prefix: /prefix
//        requires:
//          provider_name: provider1
//
//      # Jwt verification for either provider1 or provider2 is required for all other requests.
//      - match:
//          prefix: /
//        requires:
//          requires_any:
//            requirements:
//              - provider_name: provider1
//              - provider_name: provider2
//
// [#next-free-field: 6]
message JwtAuthentication {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication";

  // Map of provider names to JwtProviders.
  //
  // .. code-block:: yaml
  //
  //   providers:
  //     provider1:
  //        issuer: issuer1
  //        audiences:
  //        - audience1
  //        - audience2
  //        remote_jwks:
  //          http_uri:
  //            uri: https://example.com/.well-known/jwks.json
  //            cluster: example_jwks_cluster
  //            timeout: 1s
  //      provider2:
  //        issuer: provider2
  //        local_jwks:
  //          inline_string: jwks_string
  //
  map<string, JwtProvider> providers = 1;

  // Specifies requirements based on the route matches. The first matched requirement will be
  // applied. If there are overlapped match conditions, please put the most specific match first.
  //
  // Examples
  //
  // .. code-block:: yaml
  //
  //   rules:
  //     - match:
  //         prefix: /healthz
  //     - match:
  //         prefix: /baz
  //       requires:
  //         provider_name: provider1
  //     - match:
  //         prefix: /foo
  //       requires:
  //         requires_any:
  //           requirements:
  //             - provider_name: provider1
  //             - provider_name: provider2
  //     - match:
  //         prefix: /bar
  //       requires:
  //         requires_all:
  //           requirements:
  //             - provider_name: provider1
  //             - provider_name: provider2
  //
  repeated RequirementRule rules = 2;

  // This message specifies Jwt requirements based on stream_info.filterState.
  // Other HTTP filters can use it to specify Jwt requirements dynamically.
  // The ``rules`` field above is checked first, if it could not find any matches,
  // check this one.
  FilterStateRule filter_state_rules = 3;

  // When set to true, bypass the `CORS preflight request
  // <http://www.w3.org/TR/cors/#cross-origin-request-with-preflight>`_ regardless of JWT
  // requirements specified in the rules.
  bool bypass_cors_preflight = 4;

  // A map of unique requirement_names to JwtRequirements.
  // :ref:`requirement_name <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.PerRouteConfig.requirement_name>`
  // in ``PerRouteConfig`` uses this map to specify a JwtRequirement.
  map<string, JwtRequirement> requirement_map = 5;
}

// Specify per-route config.
message PerRouteConfig {
  oneof requirement_specifier {
    option (validate.required) = true;

    // Disable Jwt Authentication for this route.
    bool disabled = 1 [(validate.rules).bool = {const: true}];

    // Use requirement_name to specify a JwtRequirement.
    // This requirement_name MUST be specified at the
    // :ref:`requirement_map <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtAuthentication.requirement_map>`
    // in ``JwtAuthentication``. If no, the requests using this route will be rejected with 403.
    string requirement_name = 2 [(validate.rules).string = {min_len: 1}];
  }
}

// This message specifies a combination of header name and claim name.
message JwtClaimToHeader {
  // The HTTP header name to copy the claim to.
  // The header name will be sanitized and replaced.
  string header_name = 1
      [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

  // The field name for the JWT Claim : it can be a nested claim of type (eg. "claim.nested.key", "sub")
  // String separated with "." in case of nested claims. The nested claim name must use dot "." to separate
  // the JSON name path.
  string claim_name = 2 [(validate.rules).string = {min_len: 1}];
}
syntax = "proto3";

package envoy.extensions.filters.http.csrf.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/type/matcher/v3/string.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.csrf.v3";
option java_outer_classname = "CsrfProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/csrf/v3;csrfv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: CSRF]
// Cross-Site Request Forgery :ref:`configuration overview <config_http_filters_csrf>`.
// [#extension: envoy.filters.http.csrf]

// CSRF filter config.
message CsrfPolicy {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.csrf.v2.CsrfPolicy";

  // Specifies the % of requests for which the CSRF filter is enabled.
  //
  // If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is specified,
  // Envoy will lookup the runtime key to get the percentage of requests to filter.
  //
  // .. note::
  //
  //   This field defaults to 100/:ref:`HUNDRED
  //   <envoy_v3_api_enum_type.v3.FractionalPercent.DenominatorType>`.
  config.core.v3.RuntimeFractionalPercent filter_enabled = 1
      [(validate.rules).message = {required: true}];

  // Specifies that CSRF policies will be evaluated and tracked, but not enforced.
  //
  // This is intended to be used when ``filter_enabled`` is off and will be ignored otherwise.
  //
  // If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is specified,
  // Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
  // and track the request's ``Origin`` and ``Destination`` to determine if it's valid, but will not
  // enforce any policies.
  config.core.v3.RuntimeFractionalPercent shadow_enabled = 2;

  // Specifies additional source origins that will be allowed in addition to
  // the destination origin.
  //
  // More information on how this can be configured via runtime can be found
  // :ref:`here <csrf-configuration>`.
  repeated type.matcher.v3.StringMatcher additional_origins = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.kill_request.v3;

import "envoy/type/v3/percent.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.kill_request.v3";
option java_outer_classname = "KillRequestProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/kill_request/v3;kill_requestv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Kill Request]
// Kill Request :ref:`configuration overview <config_http_filters_kill_request>`.
// [#extension: envoy.filters.http.kill_request]

// Configuration for KillRequest filter.
message KillRequest {
  // On which direction should the filter check for the ``kill_request_header``.
  // Default to ``REQUEST`` if unspecified.
  enum Direction {
    REQUEST = 0;
    RESPONSE = 1;
  }

  // The probability that a Kill request will be triggered.
  type.v3.FractionalPercent probability = 1;

  // The name of the kill request header. If this field is not empty, it will override the :ref:`default header <config_http_filters_kill_request_http_header>` name. Otherwise the default header name will be used.
  string kill_request_header = 2
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];

  Direction direction = 3 [(validate.rules).enum = {defined_only: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.alternate_protocols_cache.v3;

import "envoy/config/core/v3/protocol.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.alternate_protocols_cache.v3";
option java_outer_classname = "AlternateProtocolsCacheProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/alternate_protocols_cache/v3;alternate_protocols_cachev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Alternate Protocols Cache]

// Configuration for the alternate protocols cache HTTP filter.
// [#extension: envoy.filters.http.alternate_protocols_cache]
message FilterConfig {
  // If set, causes the use of the alternate protocols cache, which is responsible for
  // parsing and caching HTTP Alt-Svc headers. This enables the use of HTTP/3 for upstream
  // servers that advertise supporting it.
  // TODO(RyanTheOptimist): Make this field required when HTTP/3 is enabled via auto_http.
  config.core.v3.AlternateProtocolsCacheOptions alternate_protocols_cache_options = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.proto_message_logging.v3;

import "envoy/config/core/v3/base.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.proto_message_logging.v3";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/proto_message_logging/v3;proto_message_loggingv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#not-implemented-hide:]
// [#protodoc-title: Proto Message Logging]
// Proto Message Logging :ref:`configuration overview
// <config_http_filters_proto_message_logging>`.
// [#extension: envoy.filters.http.proto_message_logging]
//
// ProtoMessageLogging filter supports logging scrubbed gRPC requests/responses(proto messages)
// as google.protobuf.Struct and storing results
// in the dynamic metadata `envoy.filters.http.proto_message_logging` for later access.
//
// # Assumptions
// This filter assumes it is only applicable for gRPC with Protobuf as payload.
//
// # Process Flow
// On the request path, it will check
//
// 1. if the incoming gRPC request is configured, the filter tries to:
//
//   a. buffer the incoming data to complete protobuf messages
//   b. log individual protobuf messages according to directives
//   c. write the result into the dynamic metadata.
//   d. pass through the request data
//
// 2. otherwise, pass through the request.
//
// On the response path, it will check
//
// 1. if the incoming gRPC request is configured, the filter tries to:
//
//   a. buffer the incoming data to complete protobuf messages
//   b. log individual protobuf messages according to directives
//   c. write the result into the dynamic metadata.
//   d. pass through the response data
//
// 2. otherwise, pass through the response.
//
// # Config Requirements
// Here are config requirements
//
// 1. the log target field should be among the following primitive types: `string`, `uint32`, `uint64`, `int32`, `int64`, `sint32`, `sint64`, `fixed32`, `fixed64`, `sfixed32`, `sfixed64`, `float`, `double`.
//
// 2. the target field could be repeated.
//
// 3. the intermediate type could also be repeated.
//
// # Output Format
// The logged requests and responses will be  will be added in the dynamic ``metadata<google.protobuf.Struct>`` with the same layout of the message.
//
// For the default `FIRST_AND_LAST` mode, it will be like:
//   {
//     "requests":{
//        "first":{
//           "foo": "val_foo1",
//           ...
//        }
//        "last":{
//           "foo": "val_foo3",
//           ...
//        }
//     },
//     "responses":{
//        "first":{
//           "baz": "val_baz1",
//           ...
//        }
//        "last":{
//           "baz": "val_foo3",
//           ...
//        }
//     }
//   }
//
//
// # Example for `FIRST_AND_LAST` mode
// Let's say we have the following definition for the bi-streaming request
// `pkg.svc.Method`.
//
// .. code-block:: proto
//
//   message MethodRequest {
//     string foo = 1;
//     Nested nested = 2;
//     Msg redacted = 3;
//     ...
//   }
//
//   message MethodResponse {
//     string baz = 1;
//   }
//
//   message Nested {
//     Msg double_nested = 2;
//   }
//
//   message Msg {
//     string bar = 1;
//     string not_logged = 2;
//   }
//
// This is the filter config in JSON.
//
// .. code-block:: json
//
//   {
//     "descriptor_set":{},
//     "mode": "FIRST_AND_LAST",
//     "logging_by_method":{
//        "pkg.svc.Method":{
//           "request_logging_by_field":{
//              "foo":"LOG",
//              "nested.doubled_nested.bar":"LOG",
//              "redacted":"LOG_REDACT"
//           },
//           "response_logging_by_field":{
//              "bar":"LOG",
//           }
//        }
//     }
//   }
//
// During runtime, the filter receives the following `MethodRequest` message in
// JSON.
//
// .. code-block:: json
//
//   {
//     "foo": "val_foo1",
//     "nested": { "double_nested": {"bar": "val_bar1", "not_logged": "val_not_logged1"},
//     "redacted": { "bar": "val_redacted_bar1"}
//   }
//   {
//     "foo": "val_foo2",
//     "nested": { "double_nested": {"bar": "val_bar2", "not_logged": "val_not_logged2"},
//     "redacted": { "bar": "val_redacted_bar2"}
//   }
//   {
//     "foo": "val_foo3",
//     "nested": { "double_nested": {"bar": "val_bar3", "not_logged": "val_not_logged3"},
//     "redacted": { "bar": "val_redacted_bar3"}
//   }
//
// the filter receives the following `MethodResponse` message in
// JSON.
//
// .. code-block:: json
//
//   {
//     "baz": "val_baz1",
//   }
//   {
//     "baz": "val_baz2",
//   }
//   {
//     "baz": "val_baz3",
//   }
//
// The filter will write the following dynamic
// metadata(`envoy.filters.http.proto_message_logging`) in JSON.
//
// .. code-block:: json
//
//   {
//     "requests":{
//        "first":{
//           "foo": "val_foo1",
//           "nested": { "double_nested": {"bar": "val_bar1"}},
//           "redacted": {}
//        }
//        "last":{
//           "foo": "val_foo3",
//           "nested": { "double_nested": {"bar": "val_bar3"}},
//           "redacted": {}
//        }
//     },
//     "responses":{
//        "first":{
//           "baz": "val_baz1"
//        }
//        "last":{
//           "baz": "val_foo3"
//        }
//     }
//   }

message ProtoMessageLoggingConfig {
  enum LogMode {
    LogMode_UNSPECIFIED = 0;

    // The filter will log the first and the last message for
    // for streaming cases, containing
    // client-side streaming, server-side streaming or bi-directional streaming.
    FIRST_AND_LAST = 1;
  }

  // The proto descriptor set binary for the gRPC services.
  oneof descriptor_set {
    // It could be passed by a local file through ``Datasource.filename`` or
    // embedded in the ``Datasource.inline_bytes``.
    config.core.v3.DataSource data_source = 1;

    // Unimplemented, the key of proto descriptor TypedMetadata.
    // Among filters depending on the proto descriptor, we can have a TypedMetadata
    // for proto descriptors, so that these filters can share one copy of proto
    // descriptor in memory.
    string proto_descriptor_typed_metadata = 2;
  }

  LogMode mode = 3;

  // Specify the message logging info.
  // The key is the fully qualified gRPC method name.
  // ``${package}.${Service}.${Method}``, like
  // ``endpoints.examples.bookstore.BookStore.GetShelf``
  //
  // The value is the message logging information for individual gRPC methods.
  map<string, MethodLogging> logging_by_method = 4;
}

// This message can be used to support per route config approach later even
// though the Istio doesn't support that so far.
message MethodLogging {
  enum LogDirective {
    LogDirective_UNSPECIFIED = 0;

    // The value of this field will be logged.
    LOG = 1;

    // It should be only annotated on Message type fields so if the field isn't
    // empty, an empty Struct will be logged.
    LOG_REDACT = 2;
  }

  // The mapping of field path to its LogDirective for request messages
  map<string, LogDirective> request_logging_by_field = 2;

  // The mapping of field path to its LogDirective for response messages
  map<string, LogDirective> response_logging_by_field = 3;
}
syntax = "proto3";

package envoy.extensions.filters.http.ip_tagging.v3;

import "envoy/config/core/v3/address.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.ip_tagging.v3";
option java_outer_classname = "IpTaggingProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/ip_tagging/v3;ip_taggingv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: IP tagging]
// IP tagging :ref:`configuration overview <config_http_filters_ip_tagging>`.
// [#extension: envoy.filters.http.ip_tagging]

message IPTagging {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.ip_tagging.v2.IPTagging";

  // The type of requests the filter should apply to. The supported types
  // are internal, external or both. The
  // :ref:`x-forwarded-for<config_http_conn_man_headers_x-forwarded-for_internal_origin>` header is
  // used to determine if a request is internal and will result in
  // :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>`
  // being set. The filter defaults to both, and it will apply to all request types.
  enum RequestType {
    // Both external and internal requests will be tagged. This is the default value.
    BOTH = 0;

    // Only internal requests will be tagged.
    INTERNAL = 1;

    // Only external requests will be tagged.
    EXTERNAL = 2;
  }

  // Supplies the IP tag name and the IP address subnets.
  message IPTag {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.http.ip_tagging.v2.IPTagging.IPTag";

    // Specifies the IP tag name to apply.
    string ip_tag_name = 1;

    // A list of IP address subnets that will be tagged with
    // ip_tag_name. Both IPv4 and IPv6 are supported.
    repeated config.core.v3.CidrRange ip_list = 2;
  }

  // The type of request the filter should apply to.
  RequestType request_type = 1 [(validate.rules).enum = {defined_only: true}];

  // [#comment:TODO(ccaraman): Extend functionality to load IP tags from file system.
  // Tracked by issue https://github.com/envoyproxy/envoy/issues/2695]
  // The set of IP tags for the filter.
  repeated IPTag ip_tags = 4 [(validate.rules).repeated = {min_items: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.grpc_stats.v3;

import "envoy/config/core/v3/grpc_method_list.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.grpc_stats.v3";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_stats/v3;grpc_statsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: gRPC statistics] gRPC statistics filter
// :ref:`configuration overview <config_http_filters_grpc_stats>`.
// [#extension: envoy.filters.http.grpc_stats]

// gRPC statistics filter configuration
// [#next-free-field: 6]
message FilterConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.grpc_stats.v2alpha.FilterConfig";

  // If true, the filter maintains a filter state object with the request and response message
  // counts.
  bool emit_filter_state = 1;

  oneof per_method_stat_specifier {
    // If set, specifies an allowlist of service/methods that will have individual stats
    // emitted for them. Any call that does not match the allowlist will be counted
    // in a stat with no method specifier: ``cluster.<name>.grpc.*``.
    config.core.v3.GrpcMethodList individual_method_stats_allowlist = 2;

    // If set to true, emit stats for all service/method names.
    //
    // If set to false, emit stats for all service/message types to the same stats without including
    // the service/method in the name, with prefix ``cluster.<name>.grpc``. This can be useful if
    // service/method granularity is not needed, or if each cluster only receives a single method.
    //
    // .. attention::
    //   This option is only safe if all clients are trusted. If this option is enabled
    //   with untrusted clients, the clients could cause unbounded growth in the number of stats in
    //   Envoy, using unbounded memory and potentially slowing down stats pipelines.
    //
    // .. attention::
    //   If neither ``individual_method_stats_allowlist`` nor ``stats_for_all_methods`` is set, the
    //   behavior will default to ``stats_for_all_methods=false``.
    google.protobuf.BoolValue stats_for_all_methods = 3;
  }

  // If true, the filter will gather a histogram for the request time of the upstream.
  // It works with :ref:`stats_for_all_methods
  // <envoy_v3_api_field_extensions.filters.http.grpc_stats.v3.FilterConfig.stats_for_all_methods>`
  // and :ref:`individual_method_stats_allowlist
  // <envoy_v3_api_field_extensions.filters.http.grpc_stats.v3.FilterConfig.individual_method_stats_allowlist>` the same way
  // request_message_count and response_message_count works.
  bool enable_upstream_stats = 4;

  // If true, the filter will replace dots in the grpc_service_name with underscores before emitting
  // the metrics. Only works when :ref:`stats_for_all_methods
  // <envoy_v3_api_field_extensions.filters.http.grpc_stats.v3.FilterConfig.stats_for_all_methods>`
  // is set to true. It could cause metrics to be merged if the edited service name conflicts with
  // an existing service. For example there are both service "foo.bar" & "foo_bar" running.
  // This config can fix incorrect gRPC metrics with dots because the existing stats tag extractor
  // assumes no dots in the gRPC service name. By default this is set as false.
  bool replace_dots_in_grpc_service_name = 5;
}

// gRPC statistics filter state object in protobuf form.
message FilterObject {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.grpc_stats.v2alpha.FilterObject";

  // Count of request messages in the request stream.
  uint64 request_message_count = 1;

  // Count of response messages in the response stream.
  uint64 response_message_count = 2;
}
syntax = "proto3";

package envoy.extensions.filters.http.set_metadata.v3;

import "google/protobuf/any.proto";
import "google/protobuf/struct.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.set_metadata.v3";
option java_outer_classname = "SetMetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/set_metadata/v3;set_metadatav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Set-Metadata Filter]
//
// This filters adds or updates dynamic metadata with static data.
//
// [#extension: envoy.filters.http.set_metadata]

message Metadata {
  // The metadata namespace.
  string metadata_namespace = 1 [(validate.rules).string = {min_len: 1}];

  // Allow the filter to overwrite or merge with an existing value in the namespace.
  bool allow_overwrite = 2;

  // The value to place at the namespace. If ``allow_overwrite``, this will
  // overwrite or merge with any existing values in that namespace. See
  // :ref:`the filter documentation <config_http_filters_set_metadata>` for
  // more information on how this value is merged with potentially existing
  // ones if ``allow_overwrite`` is configured. Only one of ``value`` and
  // ``typed_value`` may be set.
  google.protobuf.Struct value = 3;

  // The value to place at the namespace. If ``allow_overwrite``, this will
  // overwrite any existing values in that namespace. Only one of ``value`` and
  // ``typed_value`` may be set.
  google.protobuf.Any typed_value = 4;
}

message Config {
  // The metadata namespace.
  // This field is deprecated; please use ``metadata`` as replacement.
  string metadata_namespace = 1
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // The untyped value to update the dynamic metadata namespace with. See
  // :ref:`the filter documentation <config_http_filters_set_metadata>` for
  // more information on how this value is merged with potentially existing
  // ones.
  // This field is deprecated; please use ``metadata`` as replacement.
  google.protobuf.Struct value = 2
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Defines changes to be made to dynamic metadata.
  repeated Metadata metadata = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.cors.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/type/matcher/v3/string.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.cors.v3";
option java_outer_classname = "CorsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/cors/v3;corsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Cors]
// CORS Filter :ref:`configuration overview <config_http_filters_cors>`.
// [#extension: envoy.filters.http.cors]

// Cors filter config. Set this in
// ref:`http_filters <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.http_filters>`
// to enable the CORS filter.
//
// Please note that the :ref:`CorsPolicy <envoy_v3_api_msg_extensions.filters.http.cors.v3.CorsPolicy>`
// must be configured in the ``RouteConfiguration`` as ``typed_per_filter_config`` at some level to make the filter work.
message Cors {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.cors.v2.Cors";
}

// Per route configuration for the CORS filter. This configuration should be configured in the ``RouteConfiguration`` as ``typed_per_filter_config`` at some level to
// make the filter work.
// [#next-free-field: 10]
message CorsPolicy {
  // Specifies string patterns that match allowed origins. An origin is allowed if any of the
  // string matchers match.
  repeated type.matcher.v3.StringMatcher allow_origin_string_match = 1;

  // Specifies the content for the ``access-control-allow-methods`` header.
  string allow_methods = 2;

  // Specifies the content for the ``access-control-allow-headers`` header.
  string allow_headers = 3;

  // Specifies the content for the ``access-control-expose-headers`` header.
  string expose_headers = 4;

  // Specifies the content for the ``access-control-max-age`` header.
  string max_age = 5;

  // Specifies whether the resource allows credentials.
  google.protobuf.BoolValue allow_credentials = 6;

  // Specifies the % of requests for which the CORS filter is enabled.
  //
  // If neither ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS
  // filter will be enabled for 100% of the requests.
  //
  // If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is
  // specified, Envoy will lookup the runtime key to get the percentage of requests to filter.
  config.core.v3.RuntimeFractionalPercent filter_enabled = 7;

  // Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not
  // enforced.
  //
  // This field is intended to be used when ``filter_enabled`` is off. That field have to explicitly disable
  // the filter in order for this setting to take effect.
  //
  // If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is specified,
  // Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
  // and track the request's ``Origin`` to determine if it's valid but will not enforce any policies.
  config.core.v3.RuntimeFractionalPercent shadow_enabled = 8;

  // Specify whether allow requests whose target server's IP address is more private than that from
  // which the request initiator was fetched.
  //
  // More details refer to https://developer.chrome.com/blog/private-network-access-preflight.
  google.protobuf.BoolValue allow_private_network_access = 9;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.header_mutation.v3;

import "envoy/config/common/mutation_rules/v3/mutation_rules.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.header_mutation.v3";
option java_outer_classname = "HeaderMutationProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/header_mutation/v3;header_mutationv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Header mutation filter configuration]
// [#extension: envoy.filters.http.header_mutation]

message Mutations {
  // The request mutations are applied before the request is forwarded to the upstream cluster.
  repeated config.common.mutation_rules.v3.HeaderMutation request_mutations = 1;

  // The response mutations are applied before the response is sent to the downstream client.
  repeated config.common.mutation_rules.v3.HeaderMutation response_mutations = 2;
}

// Per route configuration for the header mutation filter.
message HeaderMutationPerRoute {
  Mutations mutations = 1;
}

// Configuration for the header mutation filter. The mutation rules in the filter configuration will
// always be applied first and then the per-route mutation rules, if both are specified.
message HeaderMutation {
  Mutations mutations = 1;

  // If per route HeaderMutationPerRoute config is configured at multiple route levels, header mutations
  // at all specified levels are evaluated. By default, the order is from most specific (i.e. route entry level)
  // to least specific (i.e. route configuration level). Later header mutations may override earlier mutations.
  //
  // This order can be reversed by setting this field to true. In other words, most specific level mutation
  // is evaluated last.
  bool most_specific_header_mutations_wins = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/common/mutation_rules/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.admission_control.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/type/v3/range.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.admission_control.v3";
option java_outer_classname = "AdmissionControlProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/admission_control/v3;admission_controlv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Admission Control]
// [#extension: envoy.filters.http.admission_control]

// [#next-free-field: 8]
message AdmissionControl {
  // Default method of specifying what constitutes a successful request. All status codes that
  // indicate a successful request must be explicitly specified if not relying on the default
  // values.
  message SuccessCriteria {
    message HttpCriteria {
      // Status code ranges that constitute a successful request. Configurable codes are in the
      // range [100, 600).
      repeated type.v3.Int32Range http_success_status = 1
          [(validate.rules).repeated = {min_items: 1}];
    }

    message GrpcCriteria {
      // Status codes that constitute a successful request.
      // Mappings can be found at: https://github.com/grpc/grpc/blob/master/doc/statuscodes.md.
      repeated uint32 grpc_success_status = 1 [(validate.rules).repeated = {min_items: 1}];
    }

    // If HTTP criteria are unspecified, all HTTP status codes below 500 are treated as successful
    // responses.
    //
    // .. note::
    //
    //    The default HTTP codes considered successful by the admission controller are done so due
    //    to the unlikelihood that sending fewer requests would change their behavior (for example:
    //    redirects, unauthorized access, or bad requests won't be alleviated by sending less
    //    traffic).
    HttpCriteria http_criteria = 1;

    // GRPC status codes to consider as request successes. If unspecified, defaults to: Ok,
    // Cancelled, Unknown, InvalidArgument, NotFound, AlreadyExists, Unauthenticated,
    // FailedPrecondition, OutOfRange, PermissionDenied, and Unimplemented.
    //
    // .. note::
    //
    //    The default gRPC codes that are considered successful by the admission controller are
    //    chosen because of the unlikelihood that sending fewer requests will change the behavior.
    GrpcCriteria grpc_criteria = 2;
  }

  // If set to false, the admission control filter will operate as a pass-through filter. If the
  // message is unspecified, the filter will be enabled.
  config.core.v3.RuntimeFeatureFlag enabled = 1;

  // Defines how a request is considered a success/failure.
  oneof evaluation_criteria {
    option (validate.required) = true;

    SuccessCriteria success_criteria = 2;
  }

  // The sliding time window over which the success rate is calculated. The window is rounded to the
  // nearest second. Defaults to 30s.
  google.protobuf.Duration sampling_window = 3;

  // Rejection probability is defined by the formula::
  //
  //     max(0, (rq_count -  rq_success_count / sr_threshold) / (rq_count + 1)) ^ (1 / aggression)
  //
  // The aggression dictates how heavily the admission controller will throttle requests upon SR
  // dropping at or below the threshold. A value of 1 will result in a linear increase in
  // rejection probability as SR drops. Any values less than 1.0, will be set to 1.0. If the
  // message is unspecified, the aggression is 1.0. See `the admission control documentation
  // <https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/admission_control_filter.html>`_
  // for a diagram illustrating this.
  config.core.v3.RuntimeDouble aggression = 4;

  // Dictates the success rate at which the rejection probability is non-zero. As success rate drops
  // below this threshold, rejection probability will increase. Any success rate above the threshold
  // results in a rejection probability of 0. Defaults to 95%.
  config.core.v3.RuntimePercent sr_threshold = 5;

  // If the average RPS of the sampling window is below this threshold, the request
  // will not be rejected, even if the success rate is lower than sr_threshold.
  // Defaults to 0.
  config.core.v3.RuntimeUInt32 rps_threshold = 6;

  // The probability of rejection will never exceed this value, even if the failure rate is rising.
  // Defaults to 80%.
  config.core.v3.RuntimePercent max_rejection_probability = 7;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.bandwidth_limit.v3;

import "envoy/config/core/v3/base.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.bandwidth_limit.v3";
option java_outer_classname = "BandwidthLimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/bandwidth_limit/v3;bandwidth_limitv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Bandwidth limit]
// Bandwidth limit :ref:`configuration overview <config_http_filters_bandwidth_limit>`.
// [#extension: envoy.filters.http.bandwidth_limit]

// [#next-free-field: 8]
message BandwidthLimit {
  // Defines the mode for the bandwidth limit filter.
  // Values represent bitmask.
  enum EnableMode {
    // Filter is disabled.
    DISABLED = 0;

    // Filter enabled only for incoming traffic.
    REQUEST = 1;

    // Filter enabled only for outgoing traffic.
    RESPONSE = 2;

    // Filter enabled for both incoming and outgoing traffic.
    REQUEST_AND_RESPONSE = 3;
  }

  // The human readable prefix to use when emitting stats.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // The enable mode for the bandwidth limit filter.
  // Default is Disabled.
  EnableMode enable_mode = 2 [(validate.rules).enum = {defined_only: true}];

  // The limit supplied in KiB/s.
  //
  // .. note::
  //   It's fine for the limit to be unset for the global configuration since the bandwidth limit
  //   can be applied at a the virtual host or route level. Thus, the limit must be set for the
  //   per route configuration otherwise the config will be rejected.
  //
  // .. note::
  //   When using per route configuration, the limit becomes unique to that route.
  //
  google.protobuf.UInt64Value limit_kbps = 3 [(validate.rules).uint64 = {gte: 1}];

  // Optional Fill interval in milliseconds for the token refills. Defaults to 50ms.
  // It must be at least 20ms to avoid too aggressive refills.
  google.protobuf.Duration fill_interval = 4 [(validate.rules).duration = {
    lte {seconds: 1}
    gte {nanos: 20000000}
  }];

  // Runtime flag that controls whether the filter is enabled or not. If not specified, defaults
  // to enabled.
  config.core.v3.RuntimeFeatureFlag runtime_enabled = 5;

  // Enable response trailers.
  //
  // .. note::
  //
  //   If set true, the following 4 trailers will be added, prefixed by ``response_trailer_prefix``:
  //   * bandwidth-request-delay-ms: delay time in milliseconds it took for the request stream transfer including request body transfer time and the time added by the filter.
  //   * bandwidth-response-delay-ms: delay time in milliseconds it took for the response stream transfer including response body transfer time and the time added by the filter.
  //   * bandwidth-request-filter-delay-ms: delay time in milliseconds in request stream transfer added by the filter.
  //   * bandwidth-response-filter-delay-ms: delay time in milliseconds that added by the filter.
  //   If :ref:`enable_mode <envoy_v3_api_field_extensions.filters.http.bandwidth_limit.v3.BandwidthLimit.enable_mode>` is ``DISABLED`` or ``REQUEST``, the trailers will not be set.
  //   If both the request and response delay time is 0, the trailers will not be set.
  //
  bool enable_response_trailers = 6;

  // Optional The prefix for the response trailers.
  string response_trailer_prefix = 7
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.adaptive_concurrency.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/type/v3/http_status.proto";
import "envoy/type/v3/percent.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.adaptive_concurrency.v3";
option java_outer_classname = "AdaptiveConcurrencyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/adaptive_concurrency/v3;adaptive_concurrencyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Adaptive Concurrency]
// Adaptive Concurrency Control :ref:`configuration overview
// <config_http_filters_adaptive_concurrency>`.
// [#extension: envoy.filters.http.adaptive_concurrency]

// Configuration parameters for the gradient controller.
message GradientControllerConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.adaptive_concurrency.v2alpha.GradientControllerConfig";

  // Parameters controlling the periodic recalculation of the concurrency limit from sampled request
  // latencies.
  message ConcurrencyLimitCalculationParams {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.http.adaptive_concurrency.v2alpha.GradientControllerConfig."
        "ConcurrencyLimitCalculationParams";

    // The allowed upper-bound on the calculated concurrency limit. Defaults to 1000.
    google.protobuf.UInt32Value max_concurrency_limit = 2 [(validate.rules).uint32 = {gt: 0}];

    // The period of time samples are taken to recalculate the concurrency limit.
    google.protobuf.Duration concurrency_update_interval = 3 [(validate.rules).duration = {
      required: true
      gt {}
    }];
  }

  // Parameters controlling the periodic minRTT recalculation.
  // [#next-free-field: 6]
  message MinimumRTTCalculationParams {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.http.adaptive_concurrency.v2alpha.GradientControllerConfig."
        "MinimumRTTCalculationParams";

    // The time interval between recalculating the minimum request round-trip time. Has to be
    // positive.
    google.protobuf.Duration interval = 1 [(validate.rules).duration = {
      required: true
      gte {nanos: 1000000}
    }];

    // The number of requests to aggregate/sample during the minRTT recalculation window before
    // updating. Defaults to 50.
    google.protobuf.UInt32Value request_count = 2 [(validate.rules).uint32 = {gt: 0}];

    // Randomized time delta that will be introduced to the start of the minRTT calculation window.
    // This is represented as a percentage of the interval duration. Defaults to 15%.
    //
    // Example: If the interval is 10s and the jitter is 15%, the next window will begin
    // somewhere in the range (10s - 11.5s).
    type.v3.Percent jitter = 3;

    // The concurrency limit set while measuring the minRTT. Defaults to 3.
    google.protobuf.UInt32Value min_concurrency = 4 [(validate.rules).uint32 = {gt: 0}];

    // Amount added to the measured minRTT to add stability to the concurrency limit during natural
    // variability in latency. This is expressed as a percentage of the measured value and can be
    // adjusted to allow more or less tolerance to the sampled latency values.
    //
    // Defaults to 25%.
    type.v3.Percent buffer = 5;
  }

  // The percentile to use when summarizing aggregated samples. Defaults to p50.
  type.v3.Percent sample_aggregate_percentile = 1;

  ConcurrencyLimitCalculationParams concurrency_limit_params = 2
      [(validate.rules).message = {required: true}];

  MinimumRTTCalculationParams min_rtt_calc_params = 3 [(validate.rules).message = {required: true}];
}

message AdaptiveConcurrency {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.adaptive_concurrency.v2alpha.AdaptiveConcurrency";

  oneof concurrency_controller_config {
    option (validate.required) = true;

    // Gradient concurrency control will be used.
    GradientControllerConfig gradient_controller_config = 1
        [(validate.rules).message = {required: true}];
  }

  // If set to false, the adaptive concurrency filter will operate as a pass-through filter. If the
  // message is unspecified, the filter will be enabled.
  config.core.v3.RuntimeFeatureFlag enabled = 2;

  // This field allows for a custom HTTP response status code to the downstream client when
  // the concurrency limit has been exceeded.
  // Defaults to 503 (Service Unavailable).
  //
  // .. note::
  //   If this is set to < 400, 503 will be used instead.
  type.v3.HttpStatus concurrency_limit_exceeded_status = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.cdn_loop.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.cdn_loop.v3";
option java_outer_classname = "CdnLoopProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/cdn_loop/v3;cdn_loopv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP CDN-Loop Filter]
// [#extension: envoy.filters.http.cdn_loop]

// CDN-Loop Header filter config. See the :ref:`configuration overview
// <config_http_filters_cdn_loop>` for more information.
message CdnLoopConfig {
  // The CDN identifier to use for loop checks and to append to the
  // CDN-Loop header.
  //
  // RFC 8586 calls this the cdn-id. The cdn-id can either be a
  // pseudonym or hostname the CDN is in control of.
  //
  // cdn_id must not be empty.
  string cdn_id = 1 [(validate.rules).string = {min_len: 1}];

  // The maximum allowed count of cdn_id in the downstream CDN-Loop
  // request header.
  //
  // The default of 0 means a request can transit the CdnLoopFilter
  // once. A value of 1 means that a request can transit the
  // CdnLoopFilter twice and so on.
  uint32 max_allowed_occurrences = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.http.grpc_http1_reverse_bridge.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.grpc_http1_reverse_bridge.v3";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_http1_reverse_bridge/v3;grpc_http1_reverse_bridgev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: gRPC HTTP/1.1 Reverse Bridge]
// gRPC HTTP/1.1 Reverse Bridge :ref:`configuration overview
// <config_http_filters_grpc_http1_reverse_bridge>`.
// [#extension: envoy.filters.http.grpc_http1_reverse_bridge]

// gRPC reverse bridge filter configuration
message FilterConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.grpc_http1_reverse_bridge.v2alpha1.FilterConfig";

  // The content-type to pass to the upstream when the gRPC bridge filter is applied.
  // The filter will also validate that the upstream responds with the same content type.
  string content_type = 1 [(validate.rules).string = {min_len: 1}];

  // If true, Envoy will assume that the upstream doesn't understand gRPC frames and
  // strip the gRPC frame from the request, and add it back in to the response. This will
  // hide the gRPC semantics from the upstream, allowing it to receive and respond with a
  // simple binary encoded protobuf. In order to calculate the ``Content-Length`` header value, Envoy
  // will buffer the upstream response unless :ref:`response_size_header
  // <envoy_v3_api_field_extensions.filters.http.grpc_http1_reverse_bridge.v3.FilterConfig.response_size_header>`
  // is set, in which case Envoy will use the value of an upstream header to calculate the content
  // length.
  bool withhold_grpc_frames = 2;

  // When :ref:`withhold_grpc_frames
  // <envoy_v3_api_field_extensions.filters.http.grpc_http1_reverse_bridge.v3.FilterConfig.withhold_grpc_frames>`
  // is true, this option controls how Envoy calculates the ``Content-Length``. When
  // ``response_size_header`` is empty, Envoy will buffer the upstream response to calculate its
  // size. When ``response_size_header`` is set to a non-empty string, Envoy will stream the response
  // to the downstream and it will use the value of the response header with this name to set the
  // ``Content-Length`` header and gRPC frame size. If the header with this name is repeated, only
  // the first value will be used.
  //
  // Envoy will treat the upstream response as an error if this option is specified and the header
  // is missing or if the value does not match the actual response body size.
  string response_size_header = 3
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false}];
}

// gRPC reverse bridge filter configuration per virtualhost/route/weighted-cluster level.
message FilterConfigPerRoute {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.grpc_http1_reverse_bridge.v2alpha1.FilterConfigPerRoute";

  // If true, disables gRPC reverse bridge filter for this particular vhost or route.
  // If disabled is specified in multiple per-filter-configs, the most specific one will be used.
  bool disabled = 1;
}
syntax = "proto3";

package envoy.extensions.filters.http.fault.v3;

import "envoy/config/route/v3/route_components.proto";
import "envoy/extensions/filters/common/fault/v3/fault.proto";
import "envoy/type/v3/percent.proto";

import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.fault.v3";
option java_outer_classname = "FaultProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/fault/v3;faultv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Fault Injection]
// Fault Injection :ref:`configuration overview <config_http_filters_fault_injection>`.
// [#extension: envoy.filters.http.fault]

// [#next-free-field: 6]
message FaultAbort {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.fault.v2.FaultAbort";

  // Fault aborts are controlled via an HTTP header (if applicable). See the
  // :ref:`HTTP fault filter <config_http_filters_fault_injection_http_header>` documentation for
  // more information.
  message HeaderAbort {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.config.filter.http.fault.v2.FaultAbort.HeaderAbort";
  }

  reserved 1;

  oneof error_type {
    option (validate.required) = true;

    // HTTP status code to use to abort the HTTP request.
    uint32 http_status = 2 [(validate.rules).uint32 = {lt: 600 gte: 200}];

    // gRPC status code to use to abort the gRPC request.
    uint32 grpc_status = 5;

    // Fault aborts are controlled via an HTTP header (if applicable).
    HeaderAbort header_abort = 4;
  }

  // The percentage of requests/operations/connections that will be aborted with the error code
  // provided.
  type.v3.FractionalPercent percentage = 3;
}

// [#next-free-field: 17]
message HTTPFault {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.fault.v2.HTTPFault";

  // If specified, the filter will inject delays based on the values in the
  // object.
  common.fault.v3.FaultDelay delay = 1;

  // If specified, the filter will abort requests based on the values in
  // the object. At least ``abort`` or ``delay`` must be specified.
  FaultAbort abort = 2;

  // Specifies the name of the (destination) upstream cluster that the
  // filter should match on. Fault injection will be restricted to requests
  // bound to the specific upstream cluster.
  string upstream_cluster = 3;

  // Specifies a set of headers that the filter should match on. The fault
  // injection filter can be applied selectively to requests that match a set of
  // headers specified in the fault filter config. The chances of actual fault
  // injection further depend on the value of the :ref:`percentage
  // <envoy_v3_api_field_extensions.filters.http.fault.v3.FaultAbort.percentage>` field.
  // The filter will check the request's headers against all the specified
  // headers in the filter config. A match will happen if all the headers in the
  // config are present in the request with the same values (or based on
  // presence if the ``value`` field is not in the config).
  repeated config.route.v3.HeaderMatcher headers = 4;

  // Faults are injected for the specified list of downstream hosts. If this
  // setting is not set, faults are injected for all downstream nodes.
  // Downstream node name is taken from :ref:`the HTTP
  // x-envoy-downstream-service-node
  // <config_http_conn_man_headers_downstream-service-node>` header and compared
  // against downstream_nodes list.
  repeated string downstream_nodes = 5;

  // The maximum number of faults that can be active at a single time via the configured fault
  // filter. Note that because this setting can be overridden at the route level, it's possible
  // for the number of active faults to be greater than this value (if injected via a different
  // route). If not specified, defaults to unlimited. This setting can be overridden via
  // ``runtime <config_http_filters_fault_injection_runtime>`` and any faults that are not injected
  // due to overflow will be indicated via the ``faults_overflow
  // <config_http_filters_fault_injection_stats>`` stat.
  //
  // .. attention::
  //   Like other :ref:`circuit breakers <arch_overview_circuit_break>` in Envoy, this is a fuzzy
  //   limit. It's possible for the number of active faults to rise slightly above the configured
  //   amount due to the implementation details.
  google.protobuf.UInt32Value max_active_faults = 6;

  // The response rate limit to be applied to the response body of the stream. When configured,
  // the percentage can be overridden by the :ref:`fault.http.rate_limit.response_percent
  // <config_http_filters_fault_injection_runtime>` runtime key.
  //
  // .. attention::
  //  This is a per-stream limit versus a connection level limit. This means that concurrent streams
  //  will each get an independent limit.
  common.fault.v3.FaultRateLimit response_rate_limit = 7;

  // The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
  // runtime. The default is: fault.http.delay.fixed_delay_percent
  string delay_percent_runtime = 8;

  // The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
  // runtime. The default is: fault.http.abort.abort_percent
  string abort_percent_runtime = 9;

  // The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
  // runtime. The default is: fault.http.delay.fixed_duration_ms
  string delay_duration_runtime = 10;

  // The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
  // runtime. The default is: fault.http.abort.http_status
  string abort_http_status_runtime = 11;

  // The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
  // runtime. The default is: fault.http.max_active_faults
  string max_active_faults_runtime = 12;

  // The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
  // runtime. The default is: fault.http.rate_limit.response_percent
  string response_rate_limit_percent_runtime = 13;

  // The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
  // runtime. The default is: fault.http.abort.grpc_status
  string abort_grpc_status_runtime = 14;

  // To control whether stats storage is allocated dynamically for each downstream server.
  // If set to true, "x-envoy-downstream-service-cluster" field of header will be ignored by this filter.
  // If set to false, dynamic stats storage will be allocated for the downstream cluster name.
  // Default value is false.
  bool disable_downstream_cluster_stats = 15;

  // When an abort or delay fault is executed, the metadata struct provided here will be added to the
  // request's dynamic metadata under the namespace corresponding to the name of the fault filter.
  // This data can be logged as part of Access Logs using the :ref:`command operator
  // <config_access_log_command_operators>` %DYNAMIC_METADATA(NAMESPACE)%, where NAMESPACE is the name of
  // the fault filter.
  google.protobuf.Struct filter_metadata = 16;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/route/v3:pkg",
        "//envoy/extensions/filters/common/fault/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.set_filter_state.v3;

import "envoy/extensions/filters/common/set_filter_state/v3/value.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.set_filter_state.v3";
option java_outer_classname = "SetFilterStateProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/set_filter_state/v3;set_filter_statev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Set-Filter-State Filter]
//
// This filter sets or updates the dynamic filter state. See :ref:`the filter
// documentation <config_http_filters_set_filter_state>` for more information on
// how this filter should be used.
//
// [#extension: envoy.filters.http.set_filter_state]

message Config {
  // A sequence of the filter state values to apply in the specified order
  // when a new request is received.
  repeated common.set_filter_state.v3.FilterStateValue on_request_headers = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/filters/common/set_filter_state/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.aws_lambda.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.aws_lambda.v3";
option java_outer_classname = "AwsLambdaProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/aws_lambda/v3;aws_lambdav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: AWS Lambda]
// AWS Lambda :ref:`configuration overview <config_http_filters_aws_lambda>`.
// [#extension: envoy.filters.http.aws_lambda]

// AWS Lambda filter config
message Config {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.aws_lambda.v2alpha.Config";

  enum InvocationMode {
    // This is the more common mode of invocation, in which Lambda responds after it has completed the function. In
    // this mode the output of the Lambda function becomes the response of the HTTP request.
    SYNCHRONOUS = 0;

    // In this mode Lambda responds immediately but continues to process the function asynchronously. This mode can be
    // used to signal events for example. In this mode, Lambda responds with an acknowledgment that it received the
    // call which is translated to an HTTP 200 OK by the filter.
    ASYNCHRONOUS = 1;
  }

  // The ARN of the AWS Lambda to invoke when the filter is engaged
  // Must be in the following format:
  // arn:<partition>:lambda:<region>:<account-number>:function:<function-name>
  string arn = 1 [(validate.rules).string = {min_len: 1}];

  // Whether to transform the request (headers and body) to a JSON payload or pass it as is.
  bool payload_passthrough = 2;

  // Determines the way to invoke the Lambda function.
  InvocationMode invocation_mode = 3 [(validate.rules).enum = {defined_only: true}];
}

// Per-route configuration for AWS Lambda. This can be useful when invoking a different Lambda function or a different
// version of the same Lambda depending on the route.
message PerRouteConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.aws_lambda.v2alpha.PerRouteConfig";

  Config invoke_config = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.http.ext_proc.v3;

import "envoy/config/common/mutation_rules/v3/mutation_rules.proto";
import "envoy/config/core/v3/grpc_service.proto";
import "envoy/extensions/filters/http/ext_proc/v3/processing_mode.proto";
import "envoy/type/matcher/v3/string.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.ext_proc.v3";
option java_outer_classname = "ExtProcProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/ext_proc/v3;ext_procv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: External Processing Filter]
// External Processing Filter
// [#extension: envoy.filters.http.ext_proc]

// The External Processing filter allows an external service to act on HTTP traffic in a flexible way.

// **Current Implementation Status:**
// All options and processing modes are implemented except for the following:
//
// * Dynamic metadata in responses from the external processor is ignored.
// * "async mode" is not implemented.

// The filter communicates with an external gRPC service called an "external processor"
// that can do a variety of things with the request and response:
//
// * Access and modify the HTTP headers on the request, response, or both
// * Access and modify the HTTP request and response bodies
// * Access and modify the dynamic stream metadata
// * Immediately send an HTTP response downstream and terminate other processing
//
// The filter communicates with the server using a gRPC bidirectional stream. After the initial
// request, the external server is in control over what additional data is sent to it
// and how it should be processed.
//
// By implementing the protocol specified by the stream, the external server can choose:
//
// * Whether it receives the response message at all
// * Whether it receives the message body at all, in separate chunks, or as a single buffer
// * Whether subsequent HTTP requests are transmitted synchronously or whether they are
//   sent asynchronously.
// * To modify request or response trailers if they already exist
//
// The filter supports up to six different processing steps. Each is represented by
// a gRPC stream message that is sent to the external processor. For each message, the
// processor must send a matching response.
//
// * Request headers: Contains the headers from the original HTTP request.
// * Request body: Delivered if they are present and sent in a single message if
//   the BUFFERED or BUFFERED_PARTIAL mode is chosen, in multiple messages if the
//   STREAMED mode is chosen, and not at all otherwise.
// * Request trailers: Delivered if they are present and if the trailer mode is set
//   to SEND.
// * Response headers: Contains the headers from the HTTP response. Keep in mind
//   that if the upstream system sends them before processing the request body that
//   this message may arrive before the complete body.
// * Response body: Sent according to the processing mode like the request body.
// * Response trailers: Delivered according to the processing mode like the
//   request trailers.
//
// By default, the processor sends only the request and response headers messages.
// This may be changed to include any of the six steps by changing the processing_mode
// setting of the filter configuration, or by setting the mode_override of any response
// from the external processor. The latter is only enabled if allow_mode_override is
// set to true. This way, a processor may, for example, use information
// in the request header to determine whether the message body must be examined, or whether
// the proxy should simply stream it straight through.
//
// All of this together allows a server to process the filter traffic in fairly
// sophisticated ways. For example:
//
// * A server may choose to examine all or part of the HTTP message bodies depending
//   on the content of the headers.
// * A server may choose to immediately reject some messages based on their HTTP
//   headers (or other dynamic metadata) and more carefully examine others.
// * A server may asynchronously monitor traffic coming through the filter by inspecting
//   headers, bodies, or both, and then decide to switch to a synchronous processing
//   mode, either permanently or temporarily.
//
// The protocol itself is based on a bidirectional gRPC stream. Envoy will send the
// server
// :ref:`ProcessingRequest <envoy_v3_api_msg_service.ext_proc.v3.ProcessingRequest>`
// messages, and the server must reply with
// :ref:`ProcessingResponse <envoy_v3_api_msg_service.ext_proc.v3.ProcessingResponse>`.
//
// Stats about each gRPC call are recorded in a :ref:`dynamic filter state
// <arch_overview_advanced_filter_state_sharing>` object in a namespace matching the filter
// name.
//
// [#next-free-field: 16]
message ExternalProcessor {
  // Configuration for the gRPC service that the filter will communicate with.
  // The filter supports both the "Envoy" and "Google" gRPC clients.
  config.core.v3.GrpcService grpc_service = 1 [(validate.rules).message = {required: true}];

  // By default, if the gRPC stream cannot be established, or if it is closed
  // prematurely with an error, the filter will fail. Specifically, if the
  // response headers have not yet been delivered, then it will return a 500
  // error downstream. If they have been delivered, then instead the HTTP stream to the
  // downstream client will be reset.
  // With this parameter set to true, however, then if the gRPC stream is prematurely closed
  // or could not be opened, processing continues without error.
  bool failure_mode_allow = 2;

  // Specifies default options for how HTTP headers, trailers, and bodies are
  // sent. See ProcessingMode for details.
  ProcessingMode processing_mode = 3;

  // [#not-implemented-hide:]
  // If true, send each part of the HTTP request or response specified by ProcessingMode
  // asynchronously -- in other words, send the message on the gRPC stream and then continue
  // filter processing. If false, which is the default, suspend filter execution after
  // each message is sent to the remote service and wait up to "message_timeout"
  // for a reply.
  bool async_mode = 4;

  // Envoy provides a number of :ref:`attributes <arch_overview_attributes>`
  // for expressive policies. Each attribute name provided in this field will be
  // matched against that list and populated in the request_headers message.
  // See the :ref:`attribute documentation <arch_overview_request_attributes>`
  // for the list of supported attributes and their types.
  repeated string request_attributes = 5;

  // Envoy provides a number of :ref:`attributes <arch_overview_attributes>`
  // for expressive policies. Each attribute name provided in this field will be
  // matched against that list and populated in the response_headers message.
  // See the :ref:`attribute documentation <arch_overview_attributes>`
  // for the list of supported attributes and their types.
  repeated string response_attributes = 6;

  // Specifies the timeout for each individual message sent on the stream and
  // when the filter is running in synchronous mode. Whenever the proxy sends
  // a message on the stream that requires a response, it will reset this timer,
  // and will stop processing and return an error (subject to the processing mode)
  // if the timer expires before a matching response is received. There is no
  // timeout when the filter is running in asynchronous mode. Zero is a valid
  // config which means the timer will be triggered immediately. If not
  // configured, default is 200 milliseconds.
  google.protobuf.Duration message_timeout = 7 [(validate.rules).duration = {
    lte {seconds: 3600}
    gte {}
  }];

  // Optional additional prefix to use when emitting statistics. This allows to distinguish
  // emitted statistics between configured *ext_proc* filters in an HTTP filter chain.
  string stat_prefix = 8;

  // Rules that determine what modifications an external processing server may
  // make to message headers. If not set, all headers may be modified except
  // for "host", ":authority", ":scheme", ":method", and headers that start
  // with the header prefix set via
  // :ref:`header_prefix <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.header_prefix>`
  // (which is usually "x-envoy").
  // Note that changing headers such as "host" or ":authority" may not in itself
  // change Envoy's routing decision, as routes can be cached. To also force the
  // route to be recomputed, set the
  // :ref:`clear_route_cache <envoy_v3_api_field_service.ext_proc.v3.CommonResponse.clear_route_cache>`
  // field to true in the same response.
  config.common.mutation_rules.v3.HeaderMutationRules mutation_rules = 9;

  // Specify the upper bound of
  // :ref:`override_message_timeout <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.override_message_timeout>`
  // If not specified, by default it is 0, which will effectively disable the ``override_message_timeout`` API.
  google.protobuf.Duration max_message_timeout = 10 [(validate.rules).duration = {
    lte {seconds: 3600}
    gte {}
  }];

  // Prevents clearing the route-cache when the
  // :ref:`clear_route_cache <envoy_v3_api_field_service.ext_proc.v3.CommonResponse.clear_route_cache>`
  // field is set in an external processor response.
  bool disable_clear_route_cache = 11;

  // Allow headers matching the ``forward_rules`` to be forwarded to the external processing server.
  // If not set, all headers are forwarded to the external processing server.
  HeaderForwardingRules forward_rules = 12;

  // Additional metadata to be added to the filter state for logging purposes. The metadata
  // will be added to StreamInfo's filter state under the namespace corresponding to the
  // ext_proc filter name.
  google.protobuf.Struct filter_metadata = 13;

  // If ``allow_mode_override`` is set to true, the filter config :ref:`processing_mode
  // <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
  // can be overridden by the response message from the external processing server
  // :ref:`mode_override <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.mode_override>`.
  // If not set, ``mode_override`` API in the response message will be ignored.
  bool allow_mode_override = 14;

  // If set to true, ignore the
  // :ref:`immediate_response <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.immediate_response>`
  // message in an external processor response. In such case, no local reply will be sent.
  // Instead, the stream to the external processor will be closed. There will be no
  // more external processing for this stream from now on.
  bool disable_immediate_response = 15;
}

// The HeaderForwardingRules structure specifies what headers are
// allowed to be forwarded to the external processing server.
//
// This works as below:
//
//   1. If neither ``allowed_headers`` nor ``disallowed_headers`` is set, all headers are forwarded.
//   2. If both ``allowed_headers`` and ``disallowed_headers`` are set, only headers in the
//      ``allowed_headers`` but not in the ``disallowed_headers`` are forwarded.
//   3. If ``allowed_headers`` is set, and ``disallowed_headers`` is not set, only headers in
//      the ``allowed_headers`` are forwarded.
//   4. If ``disallowed_headers`` is set, and ``allowed_headers`` is not set, all headers except
//      headers in the ``disallowed_headers`` are forwarded.
message HeaderForwardingRules {
  // If set, specifically allow any header in this list to be forwarded to the external
  // processing server. This can be overridden by the below ``disallowed_headers``.
  type.matcher.v3.ListStringMatcher allowed_headers = 1;

  // If set, specifically disallow any header in this list to be forwarded to the external
  // processing server. This overrides the above ``allowed_headers`` if a header matches both.
  type.matcher.v3.ListStringMatcher disallowed_headers = 2;
}

// Extra settings that may be added to per-route configuration for a
// virtual host or cluster.
message ExtProcPerRoute {
  oneof override {
    option (validate.required) = true;

    // Disable the filter for this particular vhost or route.
    // If disabled is specified in multiple per-filter-configs, the most specific one will be used.
    bool disabled = 1 [(validate.rules).bool = {const: true}];

    // Override aspects of the configuration for this route. A set of
    // overrides in a more specific configuration will override a "disabled"
    // flag set in a less-specific one.
    ExtProcOverrides overrides = 2;
  }
}

// Overrides that may be set on a per-route basis
// [#next-free-field: 6]
message ExtProcOverrides {
  // Set a different processing mode for this route than the default.
  ProcessingMode processing_mode = 1;

  // [#not-implemented-hide:]
  // Set a different asynchronous processing option than the default.
  bool async_mode = 2;

  // [#not-implemented-hide:]
  // Set different optional attributes than the default setting of the
  // ``request_attributes`` field.
  repeated string request_attributes = 3;

  // [#not-implemented-hide:]
  // Set different optional properties than the default setting of the
  // ``response_attributes`` field.
  repeated string response_attributes = 4;

  // Set a different gRPC service for this route than the default.
  config.core.v3.GrpcService grpc_service = 5;
}
syntax = "proto3";

package envoy.extensions.filters.http.ext_proc.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.ext_proc.v3";
option java_outer_classname = "ProcessingModeProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/ext_proc/v3;ext_procv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: External Processing Filter]
// External Processing Filter Processing Mode
// [#extension: envoy.filters.http.ext_proc]

// This configuration describes which parts of an HTTP request and
// response are sent to a remote server and how they are delivered.

// [#next-free-field: 7]
message ProcessingMode {
  // Control how headers and trailers are handled
  enum HeaderSendMode {
    // The default HeaderSendMode depends on which part of the message is being
    // processed. By default, request and response headers are sent,
    // while trailers are skipped.
    DEFAULT = 0;

    // Send the header or trailer.
    SEND = 1;

    // Do not send the header or trailer.
    SKIP = 2;
  }

  // Control how the request and response bodies are handled
  // When body mutation by external processor is enabled, ext_proc filter will always remove
  // the content length header in three cases below because content length can not be guaranteed
  // to be set correctly:
  // 1) STREAMED BodySendMode: header processing completes before body mutation comes back.
  // 2) BUFFERED_PARTIAL BodySendMode: body is buffered and could be injected in different phases.
  // 3) BUFFERED BodySendMode + SKIP HeaderSendMode: header processing (e.g., update content-length) is skipped.
  //
  // In Envoy's http1 codec implementation, removing content length will enable chunked transfer
  // encoding whenever feasible. The recipient (either client or server) must be able
  // to parse and decode the chunked transfer coding.
  // (see `details in RFC9112 <https://tools.ietf.org/html/rfc9112#section-7.1>`_).
  //
  // In BUFFERED BodySendMode + SEND HeaderSendMode, content length header is allowed but it is
  // external processor's responsibility to set the content length correctly matched to the length
  // of mutated body. If they don't match, the corresponding body mutation will be rejected and
  // local reply will be sent with an error message.
  enum BodySendMode {
    // Do not send the body at all. This is the default.
    NONE = 0;

    // Stream the body to the server in pieces as they arrive at the
    // proxy.
    STREAMED = 1;

    // Buffer the message body in memory and send the entire body at once.
    // If the body exceeds the configured buffer limit, then the
    // downstream system will receive an error.
    BUFFERED = 2;

    // Buffer the message body in memory and send the entire body in one
    // chunk. If the body exceeds the configured buffer limit, then the body contents
    // up to the buffer limit will be sent.
    BUFFERED_PARTIAL = 3;
  }

  // How to handle the request header. Default is "SEND".
  HeaderSendMode request_header_mode = 1 [(validate.rules).enum = {defined_only: true}];

  // How to handle the response header. Default is "SEND".
  HeaderSendMode response_header_mode = 2 [(validate.rules).enum = {defined_only: true}];

  // How to handle the request body. Default is "NONE".
  BodySendMode request_body_mode = 3 [(validate.rules).enum = {defined_only: true}];

  // How do handle the response body. Default is "NONE".
  BodySendMode response_body_mode = 4 [(validate.rules).enum = {defined_only: true}];

  // How to handle the request trailers. Default is "SKIP".
  HeaderSendMode request_trailer_mode = 5 [(validate.rules).enum = {defined_only: true}];

  // How to handle the response trailers. Default is "SKIP".
  HeaderSendMode response_trailer_mode = 6 [(validate.rules).enum = {defined_only: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/common/mutation_rules/v3:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.custom_response.v3;

import "xds/annotations/v3/status.proto";
import "xds/type/matcher/v3/matcher.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.custom_response.v3";
option java_outer_classname = "CustomResponseProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/custom_response/v3;custom_responsev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: Custom Response Filter]
// [#extension: envoy.filters.http.custom_response]

// The Custom Response Filter allows for replacing upstream responses.

// The filter configuration is a collection of custom response
// policies in a matcher tree. The configuration can be defined at the filter,
// virtual host or route level. The response will be matched against the most
// specific to the least specific config, till a match is found.
message CustomResponse {
  // Matcher to match against the original response to select a
  // :ref:`Custom Response Policy <extension_category_envoy.http.custom_response>`
  // that will override the original response. The matching is done by matching
  // against :ref:`response header values<extension_category_envoy.matching.http.input>`
  // Example:
  //
  // .. validated-code-block:: yaml
  //   :type-name: xds.type.matcher.v3.Matcher
  //
  //   matcher_list:
  //     matchers:
  //       # Apply a locally stored custom response to any 4xx response.
  //     - predicate:
  //         single_predicate:
  //           input:
  //             name: 4xx_response
  //             typed_config:
  //               "@type": type.googleapis.com/envoy.type.matcher.v3.HttpResponseStatusCodeClassMatchInput
  //           value_match:
  //             exact: "4xx"
  //       on_match:
  //         action:
  //           name: action
  //           typed_config:
  //             "@type": type.googleapis.com/envoy.extensions.http.custom_response.local_response_policy.v3.LocalResponsePolicy
  //             status_code: 499
  //             body:
  //               inline_string: "not allowed"
  //             body_format:
  //               json_format:
  //                 status: "%RESPONSE_CODE%"
  //                 message: "%LOCAL_REPLY_BODY%"
  //             response_headers_to_add:
  //             - header:
  //                 key: "foo"
  //                 value: "x-bar"
  //       # Redirect to different upstream if the status code is one of 502, 503 or 504.
  //     - predicate:
  //         or_matcher:
  //           predicate:
  //           - single_predicate:
  //               input:
  //                 name: "502_response"
  //                 typed_config:
  //                   "@type": type.googleapis.com/envoy.type.matcher.v3.HttpResponseStatusCodeMatchInput
  //               value_match:
  //                 exact: "502"
  //           - single_predicate:
  //               input:
  //                 name: "503_response"
  //                 typed_config:
  //                   "@type": type.googleapis.com/envoy.type.matcher.v3.HttpResponseStatusCodeMatchInput
  //               value_match:
  //                 exact: "503"
  //           - single_predicate:
  //               input:
  //                 name: "504_response"
  //                 typed_config:
  //                   "@type": type.googleapis.com/envoy.type.matcher.v3.HttpResponseStatusCodeMatchInput
  //               value_match:
  //                 exact: "504"
  //       on_match:
  //         action:
  //           name: action
  //           typed_config:
  //             "@type": type.googleapis.com/envoy.extensions.http.custom_response.redirect_policy.v3.RedirectPolicy
  //             status_code: 299
  //             uri: "https://foo.example/gateway_error"
  //             response_headers_to_add:
  //             - header:
  //                 key: "foo2"
  //                 value: "x-bar2"
  //
  // -- attention::
  //  The first matched policy wins. Once the response is matched, matcher
  //  evaluations end.
  //
  // Refer to :ref:`Unified Matcher API <envoy_v3_api_msg_.xds.type.matcher.v3.Matcher>`
  // documentation for more information on the matcher trees.
  // [#extension-category: envoy.http.custom_response]
  xds.type.matcher.v3.Matcher custom_response_matcher = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
        "@com_github_cncf_xds//xds/type/matcher/v3:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/common/async_files/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.file_system_buffer.v3;

import "envoy/extensions/common/async_files/v3/async_file_manager.proto";

import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.file_system_buffer.v3";
option java_outer_classname = "FileSystemBufferProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/file_system_buffer/v3;file_system_bufferv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: FileSystemBufferFilterConfig]
// [#extension: envoy.filters.http.file_system_buffer]

// The behavior of the filter for a stream.
// [#next-free-field: 6]
message BufferBehavior {
  message StreamWhenPossible {
  }

  message Bypass {
  }

  message InjectContentLengthIfNecessary {
  }

  message FullyBufferAndAlwaysInjectContentLength {
  }

  message FullyBuffer {
  }

  oneof behavior {
    option (validate.required) = true;

    // Don't inject ``content-length`` header.
    // Output immediately, buffer only if output is slower than input.
    StreamWhenPossible stream_when_possible = 1;

    // Never buffer, do nothing.
    Bypass bypass = 2;

    // If ``content-length`` is not present, buffer the entire input,
    // inject ``content-length`` header, then output.
    // If ``content-length`` is already present, act like ``stream_when_possible``.
    InjectContentLengthIfNecessary inject_content_length_if_necessary = 3;

    // Always buffer the entire input, and inject ``content-length``,
    // overwriting any provided content-length header.
    FullyBufferAndAlwaysInjectContentLength fully_buffer_and_always_inject_content_length = 4;

    // Always buffer the entire input, do not modify ``content-length``.
    FullyBuffer fully_buffer = 5;
  }
}

// The configuration for one direction of the filter behavior.
message StreamConfig {
  // Whether to bypass / stream / fully buffer / etc.
  // If unset in route, vhost and listener config, the default is ``stream_when_possible``.
  BufferBehavior behavior = 1;

  // The amount stored in the memory buffer before buffering to disk.
  // If unset in route, vhost and listener config, defaults to a hardcoded value of 1MiB
  google.protobuf.UInt64Value memory_buffer_bytes_limit = 2 [(validate.rules).uint64 = {gt: 0}];

  // The maximum storage (excluding memory) to be buffered in this filter.
  // If unset in route, vhost and listener config, defaults to a hardcoded value of 32MiB
  google.protobuf.UInt64Value storage_buffer_bytes_limit = 3;

  // The maximum amount that can be queued for writing to storage, above which the
  // source is requested to pause. If unset, defaults to the same value as
  // ``memory_buffer_bytes_limit``.
  //
  // For example, assuming the recipient is not consuming data at all, if
  // ``memory_buffer_bytes_limit`` was 32MiB, and ``storage_buffer_queue_high_watermark_bytes``
  // was 64MiB, and the filesystem is backed up so writes are not occurring promptly,
  // then:
  //
  // * Any request less than 32MiB will eventually pass through without ever attempting
  //   to write to disk.
  // * Any request with over 32MiB buffered will start trying to write to disk.
  //   If it reaches (32+64)MiB buffered in memory (write to disk isn't keeping up), a high
  //   watermark signal is sent to the source.
  // * Any stream whose total size exceeds
  //   ``memory_buffer_bytes_limit + storage_buffer_bytes_limit`` will provoke an error.
  //   (Note, if the recipient *is* consuming data then it is possible for such an
  //   oversized request to pass through the buffer filter, provided the recipient
  //   isn't consuming data too slowly.)
  //
  // The low watermark signal is sent when the memory buffer is at size
  // ``memory_buffer_bytes_limit + (storage_buffer_queue_high_watermark_bytes / 2)``.
  google.protobuf.UInt64Value storage_buffer_queue_high_watermark_bytes = 4;
}

// A :ref:`file system buffer <config_http_filters_file_system_buffer>` filter configuration.
//
// Route-specific configs override only the fields they explicitly include; unset
// fields inherit from the vhost or listener-level config, or, if never set,
// and not required, use a default value.
message FileSystemBufferFilterConfig {
  // A configuration for an AsyncFileManager.
  //
  // If unset in route, vhost and listener, and the behavior is not ``bypass``
  // in both directions, an Internal Server Error response will be sent.
  common.async_files.v3.AsyncFileManagerConfig manager_config = 1;

  // An optional path to which the unlinked files should be written - this may
  // determine which physical storage device will be used.
  //
  // If unset in route, vhost and listener, will use the environment variable
  // ``TMPDIR``, or, if that's also unset, will use ``/tmp``.
  google.protobuf.StringValue storage_buffer_path = 2;

  // Optional configuration for how to buffer (or not) requests.
  // If unset in route, vhost and listener, ``StreamConfig`` default values will be used
  // (with behavior ``stream_when_possible``)
  StreamConfig request = 3;

  // Optional configuration for how to buffer (or not) responses.
  // If unset in route, vhost and listener, ``StreamConfig`` default values will be used
  // (with behavior ``stream_when_possible``)
  StreamConfig response = 4;
}
syntax = "proto3";

package envoy.extensions.filters.http.stateful_session.v3;

import "envoy/config/core/v3/extension.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.stateful_session.v3";
option java_outer_classname = "StatefulSessionProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/stateful_session/v3;stateful_sessionv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Stateful session filter]
// Stateful session :ref:`configuration overview <config_http_filters_stateful_session>`.
// [#extension: envoy.filters.http.stateful_session]

message StatefulSession {
  // Specific implementation of session state. This session state will be used to store and
  // get address of the upstream host to which the session is assigned.
  //
  // [#extension-category: envoy.http.stateful_session]
  config.core.v3.TypedExtensionConfig session_state = 1;

  // If set to True, the HTTP request must be routed to the requested destination.
  // If the requested destination is not available, Envoy returns 503. Defaults to False.
  bool strict = 2;
}

message StatefulSessionPerRoute {
  oneof override {
    option (validate.required) = true;

    // Disable the stateful session filter for this particular vhost or route. If disabled is
    // specified in multiple per-filter-configs, the most specific one will be used.
    bool disabled = 1 [(validate.rules).bool = {const: true}];

    // Per-route stateful session configuration that can be served by RDS or static route table.
    StatefulSession stateful_session = 2;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.health_check.v3;

import "envoy/config/route/v3/route_components.proto";
import "envoy/type/v3/percent.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.health_check.v3";
option java_outer_classname = "HealthCheckProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/health_check/v3;health_checkv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Health check]
// Health check :ref:`configuration overview <config_http_filters_health_check>`.
// [#extension: envoy.filters.http.health_check]

// [#next-free-field: 6]
message HealthCheck {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.health_check.v2.HealthCheck";

  reserved 2;

  // Specifies whether the filter operates in pass through mode or not.
  google.protobuf.BoolValue pass_through_mode = 1 [(validate.rules).message = {required: true}];

  // If operating in pass through mode, the amount of time in milliseconds
  // that the filter should cache the upstream response.
  google.protobuf.Duration cache_time = 3;

  // If operating in non-pass-through mode, specifies a set of upstream cluster
  // names and the minimum percentage of servers in each of those clusters that
  // must be healthy or degraded in order for the filter to return a 200.
  //
  // .. note::
  //
  //    This value is interpreted as an integer by truncating, so 12.50% will be calculated
  //    as if it were 12%.
  map<string, type.v3.Percent> cluster_min_healthy_percentages = 4;

  // Specifies a set of health check request headers to match on. The health check filter will
  // check a requests headers against all the specified headers. To specify the health check
  // endpoint, set the ``:path`` header to match on.
  repeated config.route.v3.HeaderMatcher headers = 5;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/route/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.filters.http.buffer.v3;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.buffer.v3";
option java_outer_classname = "BufferProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/buffer/v3;bufferv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Buffer]
// Buffer :ref:`configuration overview <config_http_filters_buffer>`.
// [#extension: envoy.filters.http.buffer]

message Buffer {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.buffer.v2.Buffer";

  reserved 2;

  // The maximum request size that the filter will buffer before the connection
  // manager will stop buffering and return a 413 response.
  google.protobuf.UInt32Value max_request_bytes = 1
      [(validate.rules).uint32 = {gt: 0}, (validate.rules).message = {required: true}];
}

message BufferPerRoute {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.buffer.v2.BufferPerRoute";

  oneof override {
    option (validate.required) = true;

    // Disable the buffer filter for this particular vhost or route.
    bool disabled = 1 [(validate.rules).bool = {const: true}];

    // Override the global configuration of the filter with this new config.
    Buffer buffer = 2 [(validate.rules).message = {required: true}];
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.filters.http.router.v3;

import "envoy/config/accesslog/v3/accesslog.proto";
import "envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.router.v3";
option java_outer_classname = "RouterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/router/v3;routerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Router]
// Router :ref:`configuration overview <config_http_filters_router>`.
// [#extension: envoy.filters.http.router]

// [#next-free-field: 10]
message Router {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.http.router.v2.Router";

  message UpstreamAccessLogOptions {
    // If set to true, an upstream access log will be recorded when an upstream stream is
    // associated to an http request. Note: Each HTTP request received for an already established
    // connection will result in an upstream access log record. This includes, for example,
    // consecutive HTTP requests over the same connection or a request that is retried.
    // In case a retry is applied, an upstream access log will be recorded for each retry.
    bool flush_upstream_log_on_upstream_stream = 1;

    // The interval to flush the upstream access logs. By default, the router will flush an upstream
    // access log on stream close, when the HTTP request is complete. If this field is set, the router
    // will flush access logs periodically at the specified interval. This is especially useful in the
    // case of long-lived requests, such as CONNECT and Websockets.
    // The interval must be at least 1 millisecond.
    google.protobuf.Duration upstream_log_flush_interval = 2
        [(validate.rules).duration = {gte {nanos: 1000000}}];
  }

  // Whether the router generates dynamic cluster statistics. Defaults to
  // true. Can be disabled in high performance scenarios.
  google.protobuf.BoolValue dynamic_stats = 1;

  // Whether to start a child span for egress routed calls. This can be
  // useful in scenarios where other filters (auth, ratelimit, etc.) make
  // outbound calls and have child spans rooted at the same ingress
  // parent. Defaults to false.
  //
  // .. attention::
  //   This field is deprecated by the
  //   :ref:`spawn_upstream_span <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.spawn_upstream_span>`.
  //   Please use that ``spawn_upstream_span`` field to control the span creation.
  bool start_child_span = 2
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Configuration for HTTP upstream logs emitted by the router. Upstream logs
  // are configured in the same way as access logs, but each log entry represents
  // an upstream request. Presuming retries are configured, multiple upstream
  // requests may be made for each downstream (inbound) request.
  repeated config.accesslog.v3.AccessLog upstream_log = 3;

  // Additional upstream access log options.
  UpstreamAccessLogOptions upstream_log_options = 9;

  // Do not add any additional ``x-envoy-`` headers to requests or responses. This
  // only affects the :ref:`router filter generated x-envoy- headers
  // <config_http_filters_router_headers_set>`, other Envoy filters and the HTTP
  // connection manager may continue to set ``x-envoy-`` headers.
  bool suppress_envoy_headers = 4;

  // Specifies a list of HTTP headers to strictly validate. Envoy will reject a
  // request and respond with HTTP status 400 if the request contains an invalid
  // value for any of the headers listed in this field. Strict header checking
  // is only supported for the following headers:
  //
  // Value must be a ','-delimited list (i.e. no spaces) of supported retry
  // policy values:
  //
  // * :ref:`config_http_filters_router_x-envoy-retry-grpc-on`
  // * :ref:`config_http_filters_router_x-envoy-retry-on`
  //
  // Value must be an integer:
  //
  // * :ref:`config_http_filters_router_x-envoy-max-retries`
  // * :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`
  // * :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`
  repeated string strict_check_headers = 5 [(validate.rules).repeated = {
    items {
      string {
        in: "x-envoy-upstream-rq-timeout-ms"
        in: "x-envoy-upstream-rq-per-try-timeout-ms"
        in: "x-envoy-max-retries"
        in: "x-envoy-retry-grpc-on"
        in: "x-envoy-retry-on"
      }
    }
  }];

  // If not set, ingress Envoy will ignore
  // :ref:`config_http_filters_router_x-envoy-expected-rq-timeout-ms` header, populated by egress
  // Envoy, when deriving timeout for upstream cluster.
  bool respect_expected_rq_timeout = 6;

  // If set, Envoy will avoid incrementing HTTP failure code stats
  // on gRPC requests. This includes the individual status code value
  // (e.g. upstream_rq_504) and group stats (e.g. upstream_rq_5xx).
  // This field is useful if interested in relying only on the gRPC
  // stats filter to define success and failure metrics for gRPC requests
  // as not all failed gRPC requests charge HTTP status code metrics. See
  // :ref:`gRPC stats filter<config_http_filters_grpc_stats>` documentation
  // for more details.
  bool suppress_grpc_request_failure_code_stats = 7;

  // .. note::
  //   Upstream HTTP filters are currently in alpha.
  //
  // Optional HTTP filters for the upstream HTTP filter chain.
  //
  // These filters will be applied for all requests that pass through the router.
  // They will also be applied to shadowed requests.
  // Upstream HTTP filters cannot change route or cluster.
  // Upstream HTTP filters specified on the cluster will override these filters.
  //
  // If using upstream HTTP filters, please be aware that local errors sent by
  // upstream HTTP filters will not trigger retries, and local errors sent by
  // upstream HTTP filters will count as a final response if hedging is configured.
  // [#extension-category: envoy.filters.http.upstream]
  repeated network.http_connection_manager.v3.HttpFilter upstream_http_filters = 8;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/accesslog/v3:pkg",
        "//envoy/extensions/filters/network/http_connection_manager/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.request_id.uuid.v3;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.request_id.uuid.v3";
option java_outer_classname = "UuidProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/request_id/uuid/v3;uuidv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: UUID]
// [#extension: envoy.request_id.uuid]

// Configuration for the default UUID request ID extension which has the following behavior:
//
// 1. Request ID is propagated using the :ref:`x-request-id
//    <config_http_conn_man_headers_x-request-id>` header.
//
// 2. Request ID is a universally unique identifier `(UUID4)
//    <https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)>`_.
//
// 3. Tracing decision (sampled, forced, etc) is set in 14th nibble of the UUID. By default this will
//    overwrite existing UUIDs received in the ``x-request-id`` header if the trace sampling decision
//    is changed. The 14th nibble of the UUID4 has been chosen because it is fixed to '4' by the
//    standard. Thus, '4' indicates a default UUID and no trace status. This nibble is swapped to:
//
//      a. '9': Sampled.
//      b. 'a': Force traced due to server-side override.
//      c. 'b': Force traced due to client-side request ID joining.
//
//    See the :ref:`x-request-id <config_http_conn_man_headers_x-request-id>` documentation for
//    more information.
message UuidRequestIdConfig {
  // Whether the implementation alters the UUID to contain the trace sampling decision as per the
  // ``UuidRequestIdConfig`` message documentation. This defaults to true. If disabled no
  // modification to the UUID will be performed. It is important to note that if disabled,
  // stable sampling of traces, access logs, etc. will no longer work and only random sampling will
  // be possible.
  google.protobuf.BoolValue pack_trace_reason = 1;

  // Set whether to use :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` for sampling or not.
  // This defaults to true. See the :ref:`context propagation <arch_overview_tracing_context_propagation>`
  // overview for more information.
  google.protobuf.BoolValue use_request_id_for_trace_sampling = 2;
}
syntax = "proto3";

package envoy.extensions.rbac.audit_loggers.stream.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.rbac.audit_loggers.stream.v3";
option java_outer_classname = "StreamProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/rbac/audit_loggers/stream/v3;streamv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Standard Streams RBAC Audit Loggers]
// [#not-implemented-hide:]

// Custom configuration for the RBAC audit logger that writes log entries
// directly to the operating system's standard output.
// The logger outputs in JSON format and is currently not configurable.
message StdoutAuditLog {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.rbac.matchers.upstream_ip_port.v3;

import "envoy/config/core/v3/address.proto";
import "envoy/type/v3/range.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.rbac.matchers.upstream_ip_port.v3";
option java_outer_classname = "UpstreamIpPortMatcherProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/rbac/matchers/upstream_ip_port/v3;upstream_ip_portv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: RBAC upstream IP and port matcher plugin]
// [#extension: envoy.rbac.matchers.upstream_ip_port]

// This is configuration for matching upstream ip and port.
// Note that although both fields are optional, at least one of IP or port must be supplied. If only
// one is supplied the other is a wildcard match.
// This matcher requires a filter in the chain to have saved the upstream address in the
// filter state before the matcher is executed by RBAC filter. The state should be saved with key
// ``envoy.stream.upstream_address`` (See
// :repo:`upstream_address.h<source/common/stream_info/upstream_address.h>`).
// Also, See :repo:`proxy_filter.cc<source/extensions/filters/http/dynamic_forward_proxy/proxy_filter.cc>`
// for an example of a filter which populates the FilterState.
message UpstreamIpPortMatcher {
  // A CIDR block that will be used to match the upstream IP.
  // Both Ipv4 and Ipv6 ranges can be matched.
  config.core.v3.CidrRange upstream_ip = 1;

  // A port range that will be used to match the upstream port.
  type.v3.Int64Range upstream_port_range = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.bootstrap.internal_listener.v3;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.bootstrap.internal_listener.v3";
option java_outer_classname = "InternalListenerProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/bootstrap/internal_listener/v3;internal_listenerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Internal Listener]
// Internal Listener :ref:`overview <config_internal_listener>`.
// [#extension: envoy.bootstrap.internal_listener]

// Configuration for internal listener.
message InternalListener {
  // The internal listener client connection buffer size in KiB.
  // For example, if ``buffer_size_kb`` is set to 5, then the actual buffer size is
  // 5 KiB = 5 * 1024 bytes.
  // If the ``buffer_size_kb`` is not specified, the buffer size is set to 1024 KiB.
  google.protobuf.UInt32Value buffer_size_kb = 1 [(validate.rules).uint32 = {lte: 8192 gte: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.retry.host.omit_canary_hosts.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.retry.host.omit_canary_hosts.v3";
option java_outer_classname = "OmitCanaryHostsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/retry/host/omit_canary_hosts/v3;omit_canary_hostsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Omit Canary Hosts Predicate]
// [#extension: envoy.retry_host_predicates.omit_canary_hosts]

message OmitCanaryHostsPredicate {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.retry.omit_canary_hosts.v2.OmitCanaryHostsPredicate";
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.retry.host.omit_host_metadata.v3;

import "envoy/config/core/v3/base.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.retry.host.omit_host_metadata.v3";
option java_outer_classname = "OmitHostMetadataConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/retry/host/omit_host_metadata/v3;omit_host_metadatav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Omit host metadata retry predicate]

// A retry host predicate that can be used to reject a host based on
// predefined metadata match criteria.
// [#extension: envoy.retry_host_predicates.omit_host_metadata]
message OmitHostMetadataConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.retry.omit_host_metadata.v2.OmitHostMetadataConfig";

  // Retry host predicate metadata match criteria. The hosts in
  // the upstream cluster with matching metadata will be omitted while
  // attempting a retry of a failed request. The metadata should be specified
  // under the ``envoy.lb`` key.
  config.core.v3.Metadata metadata_match = 1;
}
syntax = "proto3";

package envoy.extensions.retry.host.previous_hosts.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.retry.host.previous_hosts.v3";
option java_outer_classname = "PreviousHostsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/retry/host/previous_hosts/v3;previous_hostsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Previous Hosts Predicate]
// [#extension: envoy.retry_host_predicates.previous_hosts]

message PreviousHostsPredicate {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.retry.previous_hosts.v2.PreviousHostsPredicate";
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.retry.priority.previous_priorities.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.retry.priority.previous_priorities.v3";
option java_outer_classname = "PreviousPrioritiesConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/retry/priority/previous_priorities/v3;previous_prioritiesv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Previous priorities retry selector]

// A retry host selector that attempts to spread retries between priorities, even if certain
// priorities would not normally be attempted due to higher priorities being available.
//
// As priorities get excluded, load will be distributed amongst the remaining healthy priorities
// based on the relative health of the priorities, matching how load is distributed during regular
// host selection. For example, given priority healths of {100, 50, 50}, the original load will be
// {100, 0, 0} (since P0 has capacity to handle 100% of the traffic). If P0 is excluded, the load
// changes to {0, 50, 50}, because P1 is only able to handle 50% of the traffic, causing the
// remaining to spill over to P2.
//
// Each priority attempted will be excluded until there are no healthy priorities left, at which
// point the list of attempted priorities will be reset, essentially starting from the beginning.
// For example, given three priorities P0, P1, P2 with healthy % of 100, 0 and 50 respectively, the
// following sequence of priorities would be selected (assuming update_frequency = 1):
// Attempt 1: P0 (P0 is 100% healthy)
// Attempt 2: P2 (P0 already attempted, P2 only healthy priority)
// Attempt 3: P0 (no healthy priorities, reset)
// Attempt 4: P2
//
// In the case of all upstream hosts being unhealthy, no adjustments will be made to the original
// priority load, so behavior should be identical to not using this plugin.
//
// Using this PriorityFilter requires rebuilding the priority load, which runs in O(# of
// priorities), which might incur significant overhead for clusters with many priorities.
// [#extension: envoy.retry_priorities.previous_priorities]
message PreviousPrioritiesConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.retry.previous_priorities.PreviousPrioritiesConfig";

  // How often the priority load should be updated based on previously attempted priorities. Useful
  // to allow each priorities to receive more than one request before being excluded or to reduce
  // the number of times that the priority load has to be recomputed.
  //
  // For example, by setting this to 2, then the first two attempts (initial attempt and first
  // retry) will use the unmodified priority load. The third and fourth attempt will use priority
  // load which excludes the priorities routed to with the first two attempts, and the fifth and
  // sixth attempt will use the priority load excluding the priorities used for the first four
  // attempts.
  //
  // Must be greater than 0.
  int32 update_frequency = 1 [(validate.rules).int32 = {gt: 0}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.config.validators.minimum_clusters.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.config.validators.minimum_clusters.v3";
option java_outer_classname = "MinimumClustersProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/config/validators/minimum_clusters/v3;minimum_clustersv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Minimum Clusters]
// [#extension: envoy.config.validators.minimum_clusters_validator]

// Validates a CDS config, and ensures that the number of clusters is above the
// set threshold.
message MinimumClustersValidator {
  // The minimal clusters threshold. Any CDS config update leading to less than
  // this number will be rejected.
  // Default value is 0.
  uint32 min_clusters_num = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.path.rewrite.uri_template.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.path.rewrite.uri_template.v3";
option java_outer_classname = "UriTemplateRewriteProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/path/rewrite/uri_template/v3;uri_templatev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Uri Template Rewrite Config]
// [#extension: envoy.path.rewrite.uri_template.uri_template_rewriter]

// Indicates that during forwarding, portions of the path that match the
// pattern should be rewritten, even allowing the substitution of variables
// from the match pattern into the new path as specified by the rewrite template.
// This is useful to allow application paths to be
// rewritten in a way that is aware of segments with variable content like
// identifiers. The router filter will place the original path as it was
// before the rewrite into the :ref:`x-envoy-original-path
// <config_http_filters_router_x-envoy-original-path>` header.
//
// Only one of :ref:`prefix_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`,
// :ref:`regex_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>`,
// or *path_template_rewrite* may be specified.
//
// Template pattern matching types:
//
// * ``*`` : Matches a single path component, up to the next path separator: /
//
// * ``**`` : Matches zero or more path segments. If present, must be the last operator.
//
// * ``{name} or {name=*}`` :  A named variable matching one path segment up to the next path separator: /.
//
// * ``{name=videos/*}`` : A named variable matching more than one path segment.
//      The path component matching videos/* is captured as the named variable.
//
// * ``{name=**}`` : A named variable matching zero or more path segments.
//
// Only named matches can be used to perform rewrites.
//
// Examples using path_template_rewrite:
//
// * The pattern ``/{one}/{two}`` paired with a substitution string of ``/{two}/{one}`` would
//   transform ``/cat/dog`` into ``/dog/cat``.
//
// * The pattern ``/videos/{language=lang/*}/*`` paired with a substitution string of
//   ``/{language}`` would transform ``/videos/lang/en/video.m4s`` into ``lang/en``.
//
// * The path pattern ``/content/{format}/{lang}/{id}/{file}.vtt`` paired with a substitution
//   string of ``/{lang}/{format}/{file}.vtt`` would transform ``/content/hls/en-us/12345/en_193913.vtt``
//   into ``/en-us/hls/en_193913.vtt``.
message UriTemplateRewriteConfig {
  string path_template_rewrite = 1 [(validate.rules).string = {min_len: 1 max_len: 256}];
}
syntax = "proto3";

package envoy.extensions.path.match.uri_template.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.path.match.uri_template.v3";
option java_outer_classname = "UriTemplateMatchProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/path/match/uri_template/v3;uri_templatev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Uri Template Match Config]
// [#extension: envoy.path.match.uri_template.uri_template_matcher]

// If specified, the route is a template match rule meaning that the
// ``:path`` header (without the query string) must match the given
// ``path_template`` pattern.
//
// Path template matching types:
//
// * ``*`` : Matches a single path component, up to the next path separator: /
//
// * ``**`` : Matches zero or more path segments. If present, must be the last operator.
//
// * ``{name} or {name=*}`` :  A named variable matching one path segment up to the next path separator: /.
//
// * ``{name=videos/*}`` : A named variable matching more than one path segment.
//      The path component matching videos/* is captured as the named variable.
//
// * ``{name=**}`` : A named variable matching zero or more path segments.
//
//
// For example:
//
// * ``/videos/*/*/*.m4s`` would match ``videos/123414/hls/1080p5000_00001.m4s``
//
// * ``/videos/{file}`` would match ``/videos/1080p5000_00001.m4s``
//
// * ``/**.mpd`` would match ``/content/123/india/dash/55/manifest.mpd``
message UriTemplateMatchConfig {
  string path_template = 1 [(validate.rules).string = {min_len: 1 max_len: 256}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.regex_engines.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.regex_engines.v3";
option java_outer_classname = "GoogleRe2Proto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/regex_engines/v3;regex_enginesv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Google RE2]
// [#extension: envoy.regex_engines.google_re2]

// Google's `RE2 <https://github.com/google/re2>`_ regex engine. The regex string must adhere to
// the documented `syntax <https://github.com/google/re2/wiki/Syntax>`_. The engine is designed
// to complete execution in linear time as well as limit the amount of memory used.
//
// Envoy emits two stats for tracking the program size of regexes: the histogram ``re2.program_size``,
// which records the program size, and the counter ``re2.exceeded_warn_level``, which is incremented
// each time the program size exceeds the warn level threshold.
message GoogleRE2 {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.clusters.dynamic_forward_proxy.v3;

import "envoy/config/cluster/v3/cluster.proto";
import "envoy/config/core/v3/address.proto";
import "envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.clusters.dynamic_forward_proxy.v3";
option java_outer_classname = "ClusterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/clusters/dynamic_forward_proxy/v3;dynamic_forward_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Dynamic forward proxy cluster configuration]

// Configuration for the dynamic forward proxy cluster. See the :ref:`architecture overview
// <arch_overview_http_dynamic_forward_proxy>` for more information.
// [#extension: envoy.clusters.dynamic_forward_proxy]
message ClusterConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.cluster.dynamic_forward_proxy.v2alpha.ClusterConfig";

  oneof cluster_implementation_specifier {
    // The DNS cache configuration that the cluster will attach to. Note this configuration must
    // match that of associated :ref:`dynamic forward proxy HTTP filter configuration
    // <envoy_v3_api_field_extensions.filters.http.dynamic_forward_proxy.v3.FilterConfig.dns_cache_config>`.
    common.dynamic_forward_proxy.v3.DnsCacheConfig dns_cache_config = 1;

    // Configuration for sub clusters, when this configuration is enabled,
    // Envoy will create an independent sub cluster dynamically for each host:port.
    // Most of the configuration of a sub cluster is inherited from the current cluster,
    // i.e. health_checks, dns_resolvers and etc.
    // And the load_assignment will be set to the only one endpoint, host:port.
    //
    // Compared to the dns_cache_config, it has the following advantages:
    //
    // 1. sub clusters will be created with the STRICT_DNS DiscoveryType,
    //    so that Envoy will use all of the IPs resolved from the host.
    //
    // 2. each sub cluster is full featured cluster, with lb_policy and health check and etc enabled.
    //
    SubClustersConfig sub_clusters_config = 4;
  }

  // If true allow the cluster configuration to disable the auto_sni and auto_san_validation options
  // in the :ref:`cluster's upstream_http_protocol_options
  // <envoy_v3_api_field_config.cluster.v3.Cluster.upstream_http_protocol_options>`
  bool allow_insecure_cluster_options = 2;

  // If true allow HTTP/2 and HTTP/3 connections to be reused for requests to different
  // origins than the connection was initially created for. This will only happen when the
  // resolved address for the new connection matches the peer address of the connection and
  // the TLS certificate is also valid for the new hostname. For example, if a connection
  // has previously been established to foo.example.com at IP 1.2.3.4 with a certificate
  // that is valid for ``*.example.com``, then this connection could be used for requests to
  // bar.example.com if that also resolved to 1.2.3.4.
  //
  // .. note::
  //   By design, this feature will maximize reuse of connections. This means that instead
  //   opening a new connection when an existing connection reaches the maximum number of
  //   concurrent streams, requests will instead be sent to the existing connection.
  //
  // .. note::
  //   The coalesced connections might be to upstreams that would not be otherwise
  //   selected by Envoy. See the section `Connection Reuse in RFC 7540
  //   <https://datatracker.ietf.org/doc/html/rfc7540#section-9.1.1>`_
  //
  bool allow_coalesced_connections = 3;
}

// Configuration for sub clusters. Hard code STRICT_DNS cluster type now.
message SubClustersConfig {
  // The :ref:`load balancer type <arch_overview_load_balancing_types>` to use
  // when picking a host in a sub cluster. Note that CLUSTER_PROVIDED is not allowed here.
  config.cluster.v3.Cluster.LbPolicy lb_policy = 1 [(validate.rules).enum = {defined_only: true}];

  // The maximum number of sub clusters that the DFP cluster will hold. If not specified defaults to 1024.
  google.protobuf.UInt32Value max_sub_clusters = 2 [(validate.rules).uint32 = {gt: 0}];

  // The TTL for sub clusters that are unused. Sub clusters that have not been used in the configured time
  // interval will be purged. If not specified defaults to 5m.
  google.protobuf.Duration sub_cluster_ttl = 3 [(validate.rules).duration = {gt {}}];

  // Sub clusters that should be created & warmed upon creation. This might provide a
  // performance improvement, in the form of cache hits, for sub clusters that are going to be
  // warmed during steady state and are known at config load time.
  repeated config.core.v3.SocketAddress preresolve_clusters = 4;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/cluster/v3:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/extensions/common/dynamic_forward_proxy/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.clusters.redis.v3;

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.clusters.redis.v3";
option java_outer_classname = "RedisClusterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/clusters/redis/v3;redisv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Redis Cluster Configuration]
// This cluster adds support for `Redis Cluster <https://redis.io/topics/cluster-spec>`_, as part
// of :ref:`Envoy's support for Redis Cluster <arch_overview_redis>`.
//
// Redis Cluster is an extension of Redis which supports sharding and high availability (where a
// shard that loses its primary fails over to a replica, and designates it as the new primary).
// However, as there is no unified frontend or proxy service in front of Redis Cluster, the client
// (in this case Envoy) must locally maintain the state of the Redis Cluster, specifically the
// topology. A random node in the cluster is queried for the topology using the `CLUSTER SLOTS
// command <https://redis.io/commands/cluster-slots>`_. This result is then stored locally, and
// updated at user-configured intervals.
//
// Additionally, if
// :ref:`enable_redirection<envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings.enable_redirection>`
// is true, then moved and ask redirection errors from upstream servers will trigger a topology
// refresh when they exceed a user-configured error threshold.
//
// Example:
//
// .. code-block:: yaml
//
//     name: name
//     connect_timeout: 0.25s
//     dns_lookup_family: V4_ONLY
//     hosts:
//     - socket_address:
//       address: foo.bar.com
//       port_value: 22120
//     cluster_type:
//     name: envoy.clusters.redis
//     typed_config:
//       "@type": type.googleapis.com/google.protobuf.Struct
//       value:
//         cluster_refresh_rate: 30s
//         cluster_refresh_timeout: 0.5s
//         redirect_refresh_interval: 10s
//         redirect_refresh_threshold: 10
// [#extension: envoy.clusters.redis]

// [#next-free-field: 7]
message RedisClusterConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.cluster.redis.RedisClusterConfig";

  // Interval between successive topology refresh requests. If not set, this defaults to 5s.
  google.protobuf.Duration cluster_refresh_rate = 1 [(validate.rules).duration = {gt {}}];

  // Timeout for topology refresh request. If not set, this defaults to 3s.
  google.protobuf.Duration cluster_refresh_timeout = 2 [(validate.rules).duration = {gt {}}];

  // The minimum interval that must pass after triggering a topology refresh request before a new
  // request can possibly be triggered again. Any errors received during one of these
  // time intervals are ignored. If not set, this defaults to 5s.
  google.protobuf.Duration redirect_refresh_interval = 3;

  // The number of redirection errors that must be received before
  // triggering a topology refresh request. If not set, this defaults to 5.
  // If this is set to 0, topology refresh after redirect is disabled.
  google.protobuf.UInt32Value redirect_refresh_threshold = 4;

  // The number of failures that must be received before triggering a topology refresh request.
  // If not set, this defaults to 0, which disables the topology refresh due to failure.
  uint32 failure_refresh_threshold = 5;

  // The number of hosts became degraded or unhealthy before triggering a topology refresh request.
  // If not set, this defaults to 0, which disables the topology refresh due to degraded or
  // unhealthy host.
  uint32 host_degraded_refresh_threshold = 6;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.clusters.aggregate.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.clusters.aggregate.v3";
option java_outer_classname = "ClusterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/clusters/aggregate/v3;aggregatev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Aggregate cluster configuration]

// Configuration for the aggregate cluster. See the :ref:`architecture overview
// <arch_overview_aggregate_cluster>` for more information.
// [#extension: envoy.clusters.aggregate]
message ClusterConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.cluster.aggregate.v2alpha.ClusterConfig";

  // Load balancing clusters in aggregate cluster. Clusters are prioritized based on the order they
  // appear in this list.
  repeated string clusters = 1 [(validate.rules).repeated = {min_items: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.network.dns_resolver.apple.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.network.dns_resolver.apple.v3";
option java_outer_classname = "AppleDnsResolverProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/network/dns_resolver/apple/v3;applev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: apple DNS resolver]
// [#extension: envoy.network.dns_resolver.apple]

// Configuration for apple DNS resolver.
message AppleDnsResolverConfig {
  // The resolver will avoid the system's heuristics to only return
  // IPv4 or IPv6 addresses that it considers to be "routable", instead
  // returning all possible IPv4 or IPv6 addresses. This setting is
  // ignored if the DNS lookup family is set to v4-only or v6-only.
  // This should remain false in the vast majority of cases, but may be
  // useful when performing custom filtering of addresses, such as with
  // Happy Eyeballs.
  bool include_unroutable_families = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.network.dns_resolver.getaddrinfo.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.network.dns_resolver.getaddrinfo.v3";
option java_outer_classname = "GetaddrinfoDnsResolverProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/network/dns_resolver/getaddrinfo/v3;getaddrinfov3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: getaddrinfo DNS resolver]
// [#extension: envoy.network.dns_resolver.getaddrinfo]

// Configuration for getaddrinfo DNS resolver. This resolver will use the system's getaddrinfo()
// function to resolve hosts.
//
// .. attention::
//
//   This resolver uses a single background thread to do resolutions. As such, it is not currently
//   advised for use in situations requiring a high resolution rate. A thread pool can be added
//   in the future if needed.
//
// .. attention::
//
//   Resolutions currently use a hard coded TTL of 60s because the getaddrinfo() API does not
//   provide the actual TTL. Configuration for this can be added in the future if needed.
message GetAddrInfoDnsResolverConfig {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.network.dns_resolver.cares.v3;

import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/resolver.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.network.dns_resolver.cares.v3";
option java_outer_classname = "CaresDnsResolverProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/network/dns_resolver/cares/v3;caresv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: c-ares DNS resolver]
// [#extension: envoy.network.dns_resolver.cares]

// Configuration for c-ares DNS resolver.
message CaresDnsResolverConfig {
  // A list of dns resolver addresses.
  // :ref:`use_resolvers_as_fallback<envoy_v3_api_field_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.use_resolvers_as_fallback>`
  // below dictates if the DNS client should override system defaults or only use the provided
  // resolvers if the system defaults are not available, i.e., as a fallback.
  repeated config.core.v3.Address resolvers = 1 [(validate.rules).repeated = {min_items: 1}];

  // If true use the resolvers listed in the
  // :ref:`resolvers<envoy_v3_api_field_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.resolvers>`
  // field only if c-ares is unable to obtain a
  // nameserver from the system (e.g., /etc/resolv.conf).
  // Otherwise, the resolvers listed in the resolvers list will override the default system
  // resolvers. Defaults to false.
  bool use_resolvers_as_fallback = 3;

  // The resolver will query available network interfaces and determine if there are no available
  // interfaces for a given IP family. It will then filter these addresses from the results it
  // presents. e.g., if there are no available IPv4 network interfaces, the resolver will not
  // provide IPv4 addresses.
  bool filter_unroutable_families = 4;

  // Configuration of DNS resolver option flags which control the behavior of the DNS resolver.
  config.core.v3.DnsResolverOptions dns_resolver_options = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.network.socket_interface.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.network.socket_interface.v3";
option java_outer_classname = "DefaultSocketInterfaceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/network/socket_interface/v3;socket_interfacev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Default socket interface configuration]

// Configuration for default socket interface that relies on OS dependent syscall to create
// sockets.
message DefaultSocketInterface {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.wasm.v3;

import "envoy/config/core/v3/base.proto";

import "google/protobuf/any.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.wasm.v3";
option java_outer_classname = "WasmProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/wasm/v3;wasmv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Wasm]
// [#extension: envoy.bootstrap.wasm]

// Configuration for restricting Proxy-Wasm capabilities available to modules.
message CapabilityRestrictionConfig {
  // The Proxy-Wasm capabilities which will be allowed. Capabilities are mapped by
  // name. The ``SanitizationConfig`` which each capability maps to is currently unimplemented and ignored,
  // and so should be left empty.
  //
  // The capability names are given in the
  // `Proxy-Wasm ABI <https://github.com/proxy-wasm/spec/tree/master/abi-versions/vNEXT>`_.
  // Additionally, the following WASI capabilities from
  // `this list <https://github.com/WebAssembly/WASI/blob/master/phases/snapshot/docs.md#modules>`_
  // are implemented and can be allowed:
  // ``fd_write``, ``fd_read``, ``fd_seek``, ``fd_close``, ``fd_fdstat_get``, ``environ_get``, ``environ_sizes_get``,
  // ``args_get``, ``args_sizes_get``, ``proc_exit``, ``clock_time_get``, ``random_get``.
  map<string, SanitizationConfig> allowed_capabilities = 1;
}

// Configuration for sanitization of inputs to an allowed capability.
//
// NOTE: This is currently unimplemented.
message SanitizationConfig {
}

// Configuration for a Wasm VM.
// [#next-free-field: 8]
message VmConfig {
  // An ID which will be used along with a hash of the wasm code (or the name of the registered Null
  // VM plugin) to determine which VM will be used for the plugin. All plugins which use the same
  // ``vm_id`` and code will use the same VM. May be left blank. Sharing a VM between plugins can
  // reduce memory utilization and make sharing of data easier which may have security implications.
  // [#comment: TODO: add ref for details.]
  string vm_id = 1;

  // The Wasm runtime type, defaults to the first available Wasm engine used at Envoy build-time.
  // The priority to search for the available engine is: v8 -> wasmtime -> wamr -> wavm.
  // Available Wasm runtime types are registered as extensions. The following runtimes are included
  // in Envoy code base:
  //
  // .. _extension_envoy.wasm.runtime.null:
  //
  // **envoy.wasm.runtime.null**: Null sandbox, the Wasm module must be compiled and linked into the
  // Envoy binary. The registered name is given in the ``code`` field as ``inline_string``.
  //
  // .. _extension_envoy.wasm.runtime.v8:
  //
  // **envoy.wasm.runtime.v8**: `V8 <https://v8.dev/>`_-based WebAssembly runtime.
  //
  // .. _extension_envoy.wasm.runtime.wamr:
  //
  // **envoy.wasm.runtime.wamr**: `WAMR <https://github.com/bytecodealliance/wasm-micro-runtime/>`_-based WebAssembly runtime.
  // This runtime is not enabled in the official build.
  //
  // .. _extension_envoy.wasm.runtime.wavm:
  //
  // **envoy.wasm.runtime.wavm**: `WAVM <https://wavm.github.io/>`_-based WebAssembly runtime.
  // This runtime is not enabled in the official build.
  //
  // .. _extension_envoy.wasm.runtime.wasmtime:
  //
  // **envoy.wasm.runtime.wasmtime**: `Wasmtime <https://wasmtime.dev/>`_-based WebAssembly runtime.
  // This runtime is not enabled in the official build.
  //
  // [#extension-category: envoy.wasm.runtime]
  string runtime = 2;

  // The Wasm code that Envoy will execute.
  config.core.v3.AsyncDataSource code = 3;

  // The Wasm configuration used in initialization of a new VM
  // (proxy_on_start). ``google.protobuf.Struct`` is serialized as JSON before
  // passing it to the plugin. ``google.protobuf.BytesValue`` and
  // ``google.protobuf.StringValue`` are passed directly without the wrapper.
  google.protobuf.Any configuration = 4;

  // Allow the wasm file to include pre-compiled code on VMs which support it.
  // Warning: this should only be enable for trusted sources as the precompiled code is not
  // verified.
  bool allow_precompiled = 5;

  // If true and the code needs to be remotely fetched and it is not in the cache then NACK the configuration
  // update and do a background fetch to fill the cache, otherwise fetch the code asynchronously and enter
  // warming state.
  bool nack_on_code_cache_miss = 6;

  // Specifies environment variables to be injected to this VM which will be available through
  // WASI's ``environ_get`` and ``environ_get_sizes`` system calls. Note that these functions are mostly implicitly
  // called in your language's standard library, so you do not need to call them directly and you can access to env
  // vars just like when you do on native platforms.
  // Warning: Envoy rejects the configuration if there's conflict of key space.
  EnvironmentVariables environment_variables = 7;
}

message EnvironmentVariables {
  // The keys of *Envoy's* environment variables exposed to this VM. In other words, if a key exists in Envoy's environment
  // variables, then that key-value pair will be injected. Note that if a key does not exist, it will be ignored.
  repeated string host_env_keys = 1;

  // Explicitly given key-value pairs to be injected to this VM in the form of "KEY=VALUE".
  map<string, string> key_values = 2;
}

// Base Configuration for Wasm Plugins e.g. filters and services.
// [#next-free-field: 7]
message PluginConfig {
  // A unique name for a filters/services in a VM for use in identifying the filter/service if
  // multiple filters/services are handled by the same ``vm_id`` and ``root_id`` and for
  // logging/debugging.
  string name = 1;

  // A unique ID for a set of filters/services in a VM which will share a RootContext and Contexts
  // if applicable (e.g. an Wasm HttpFilter and an Wasm AccessLog). If left blank, all
  // filters/services with a blank root_id with the same ``vm_id`` will share Context(s).
  string root_id = 2;

  // Configuration for finding or starting VM.
  oneof vm {
    VmConfig vm_config = 3;
    // TODO: add referential VM configurations.
  }

  // Filter/service configuration used to configure or reconfigure a plugin
  // (``proxy_on_configure``).
  // ``google.protobuf.Struct`` is serialized as JSON before
  // passing it to the plugin. ``google.protobuf.BytesValue`` and
  // ``google.protobuf.StringValue`` are passed directly without the wrapper.
  google.protobuf.Any configuration = 4;

  // If there is a fatal error on the VM (e.g. exception, abort(), on_start or on_configure return false),
  // then all plugins associated with the VM will either fail closed (by default), e.g. by returning an HTTP 503 error,
  // or fail open (if 'fail_open' is set to true) by bypassing the filter. Note: when on_start or on_configure return false
  // during xDS updates the xDS configuration will be rejected and when on_start or on_configuration return false on initial
  // startup the proxy will not start.
  bool fail_open = 5;

  // Configuration for restricting Proxy-Wasm capabilities available to modules.
  CapabilityRestrictionConfig capability_restriction_config = 6;
}

// WasmService is configured as a built-in ``envoy.wasm_service`` :ref:`WasmService
// <config_wasm_service>` This opaque configuration will be used to create a Wasm Service.
message WasmService {
  // General plugin configuration.
  PluginConfig config = 1;

  // If true, create a single VM rather than creating one VM per worker. Such a singleton can
  // not be used with filters.
  bool singleton = 2;
}
syntax = "proto3";

package envoy.extensions.access_loggers.filters.cel.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.access_loggers.filters.cel.v3";
option java_outer_classname = "CelProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/filters/cel/v3;celv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: ExpressionFilter]
// [#extension: envoy.access_loggers.extension_filters.cel]

// ExpressionFilter is an access logging filter that evaluates configured
// symbolic Common Expression Language expressions to inform the decision
// to generate an access log.
message ExpressionFilter {
  // Expression that, when evaluated, will be used to filter access logs.
  // Expressions are based on the set of Envoy :ref:`attributes <arch_overview_attributes>`.
  // The provided expression must evaluate to true for logging (expression errors are considered false).
  // Examples:
  //
  // * ``response.code >= 400``
  // * ``(connection.mtls && request.headers['x-log-mtls'] == 'true') || request.url_path.contains('v1beta3')``
  string expression = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.access_loggers.file.v3;

import "envoy/config/core/v3/substitution_format_string.proto";

import "google/protobuf/struct.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.access_loggers.file.v3";
option java_outer_classname = "FileProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/file/v3;filev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: File access log]
// [#extension: envoy.access_loggers.file]

// Custom configuration for an :ref:`AccessLog <envoy_v3_api_msg_config.accesslog.v3.AccessLog>`
// that writes log entries directly to a file. Configures the built-in ``envoy.access_loggers.file``
// AccessLog.
// [#next-free-field: 6]
message FileAccessLog {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.accesslog.v2.FileAccessLog";

  // A path to a local file to which to write the access log entries.
  string path = 1 [(validate.rules).string = {min_len: 1}];

  oneof access_log_format {
    // Access log :ref:`format string<config_access_log_format_strings>`.
    // Envoy supports :ref:`custom access log formats <config_access_log_format>` as well as a
    // :ref:`default format <config_access_log_default_format>`.
    // This field is deprecated.
    // Please use :ref:`log_format <envoy_v3_api_field_extensions.access_loggers.file.v3.FileAccessLog.log_format>`.
    string format = 2 [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

    // Access log :ref:`format dictionary<config_access_log_format_dictionaries>`. All values
    // are rendered as strings.
    // This field is deprecated.
    // Please use :ref:`log_format <envoy_v3_api_field_extensions.access_loggers.file.v3.FileAccessLog.log_format>`.
    google.protobuf.Struct json_format = 3
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

    // Access log :ref:`format dictionary<config_access_log_format_dictionaries>`. Values are
    // rendered as strings, numbers, or boolean values as appropriate. Nested JSON objects may
    // be produced by some command operators (e.g.FILTER_STATE or DYNAMIC_METADATA). See the
    // documentation for a specific command operator for details.
    // This field is deprecated.
    // Please use :ref:`log_format <envoy_v3_api_field_extensions.access_loggers.file.v3.FileAccessLog.log_format>`.
    google.protobuf.Struct typed_json_format = 4
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

    // Configuration to form access log data and format.
    // If not specified, use :ref:`default format <config_access_log_default_format>`.
    config.core.v3.SubstitutionFormatString log_format = 5
        [(validate.rules).message = {required: true}];
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.access_loggers.grpc.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/config_source.proto";
import "envoy/config/core/v3/grpc_service.proto";
import "envoy/type/tracing/v3/custom_tag.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.access_loggers.grpc.v3";
option java_outer_classname = "AlsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/grpc/v3;grpcv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: gRPC Access Log Service (ALS)]

// Configuration for the built-in ``envoy.access_loggers.http_grpc``
// :ref:`AccessLog <envoy_v3_api_msg_config.accesslog.v3.AccessLog>`. This configuration will
// populate :ref:`StreamAccessLogsMessage.http_logs
// <envoy_v3_api_field_service.accesslog.v3.StreamAccessLogsMessage.http_logs>`.
// [#extension: envoy.access_loggers.http_grpc]
message HttpGrpcAccessLogConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.accesslog.v2.HttpGrpcAccessLogConfig";

  CommonGrpcAccessLogConfig common_config = 1 [(validate.rules).message = {required: true}];

  // Additional request headers to log in :ref:`HTTPRequestProperties.request_headers
  // <envoy_v3_api_field_data.accesslog.v3.HTTPRequestProperties.request_headers>`.
  repeated string additional_request_headers_to_log = 2;

  // Additional response headers to log in :ref:`HTTPResponseProperties.response_headers
  // <envoy_v3_api_field_data.accesslog.v3.HTTPResponseProperties.response_headers>`.
  repeated string additional_response_headers_to_log = 3;

  // Additional response trailers to log in :ref:`HTTPResponseProperties.response_trailers
  // <envoy_v3_api_field_data.accesslog.v3.HTTPResponseProperties.response_trailers>`.
  repeated string additional_response_trailers_to_log = 4;
}

// Configuration for the built-in ``envoy.access_loggers.tcp_grpc`` type. This configuration will
// populate ``StreamAccessLogsMessage.tcp_logs``.
// [#extension: envoy.access_loggers.tcp_grpc]
message TcpGrpcAccessLogConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.accesslog.v2.TcpGrpcAccessLogConfig";

  CommonGrpcAccessLogConfig common_config = 1 [(validate.rules).message = {required: true}];
}

// Common configuration for gRPC access logs.
// [#next-free-field: 9]
message CommonGrpcAccessLogConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.accesslog.v2.CommonGrpcAccessLogConfig";

  // The friendly name of the access log to be returned in :ref:`StreamAccessLogsMessage.Identifier
  // <envoy_v3_api_msg_service.accesslog.v3.StreamAccessLogsMessage.Identifier>`. This allows the
  // access log server to differentiate between different access logs coming from the same Envoy.
  string log_name = 1 [(validate.rules).string = {min_len: 1}];

  // The gRPC service for the access log service.
  config.core.v3.GrpcService grpc_service = 2 [(validate.rules).message = {required: true}];

  // API version for access logs service transport protocol. This describes the access logs service
  // gRPC endpoint and version of messages used on the wire.
  config.core.v3.ApiVersion transport_api_version = 6
      [(validate.rules).enum = {defined_only: true}];

  // Interval for flushing access logs to the gRPC stream. Logger will flush requests every time
  // this interval is elapsed, or when batch size limit is hit, whichever comes first. Defaults to
  // 1 second.
  google.protobuf.Duration buffer_flush_interval = 3 [(validate.rules).duration = {gt {}}];

  // Soft size limit in bytes for access log entries buffer. Logger will buffer requests until
  // this limit it hit, or every time flush interval is elapsed, whichever comes first. Setting it
  // to zero effectively disables the batching. Defaults to 16384.
  google.protobuf.UInt32Value buffer_size_bytes = 4;

  // Additional filter state objects to log in :ref:`filter_state_objects
  // <envoy_v3_api_field_data.accesslog.v3.AccessLogCommon.filter_state_objects>`.
  // Logger will call ``FilterState::Object::serializeAsProto`` to serialize the filter state object.
  repeated string filter_state_objects_to_log = 5;

  // Sets the retry policy when the establishment of a gRPC stream fails.
  // If the stream succeeds at least once in establishing itself,
  // no retry will be performed no matter what gRPC status is received.
  // Note that only :ref:`num_retries <envoy_v3_api_field_config.core.v3.RetryPolicy.num_retries>`
  // will be used in this configuration. This feature is used only when you are using
  // :ref:`Envoy gRPC client <envoy_v3_api_field_config.core.v3.GrpcService.envoy_grpc>`.
  config.core.v3.RetryPolicy grpc_stream_retry_policy = 7;

  // A list of custom tags with unique tag name to create tags for the logs.
  repeated type.tracing.v3.CustomTag custom_tags = 8;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/tracing/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.access_loggers.open_telemetry.v3;

import "envoy/extensions/access_loggers/grpc/v3/als.proto";

import "opentelemetry/proto/common/v1/common.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.access_loggers.open_telemetry.v3";
option java_outer_classname = "LogsServiceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/open_telemetry/v3;open_telemetryv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: OpenTelemetry (gRPC) Access Log]

// Configuration for the built-in ``envoy.access_loggers.open_telemetry``
// :ref:`AccessLog <envoy_v3_api_msg_config.accesslog.v3.AccessLog>`. This configuration will
// populate `opentelemetry.proto.collector.v1.logs.ExportLogsServiceRequest.resource_logs <https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/collector/logs/v1/logs_service.proto>`_.
// In addition, the request start time is set in the dedicated field.
// [#extension: envoy.access_loggers.open_telemetry]
// [#next-free-field: 6]
message OpenTelemetryAccessLogConfig {
  // [#comment:TODO(itamarkam): add 'filter_state_objects_to_log' to logs.]
  grpc.v3.CommonGrpcAccessLogConfig common_config = 1 [(validate.rules).message = {required: true}];

  // If specified, Envoy will not generate built-in resource labels
  // like ``log_name``, ``zone_name``, ``cluster_name``, ``node_name``.
  bool disable_builtin_labels = 5;

  // OpenTelemetry `Resource <https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/logs/v1/logs.proto#L51>`_
  // attributes are filled with Envoy node info.
  // Example: ``resource_attributes { values { key: "region" value { string_value: "cn-north-7" } } }``.
  opentelemetry.proto.common.v1.KeyValueList resource_attributes = 4;

  // OpenTelemetry `LogResource <https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/logs/v1/logs.proto>`_
  // fields, following `Envoy access logging formatting <https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage>`_.
  //
  // See 'body' in the LogResource proto for more details.
  // Example: ``body { string_value: "%PROTOCOL%" }``.
  opentelemetry.proto.common.v1.AnyValue body = 2;

  // See 'attributes' in the LogResource proto for more details.
  // Example: ``attributes { values { key: "user_agent" value { string_value: "%REQ(USER-AGENT)%" } } }``.
  opentelemetry.proto.common.v1.KeyValueList attributes = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/access_loggers/grpc/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@opentelemetry_proto//:common",
    ],
)
syntax = "proto3";

package envoy.extensions.access_loggers.stream.v3;

import "envoy/config/core/v3/substitution_format_string.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.access_loggers.stream.v3";
option java_outer_classname = "StreamProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/stream/v3;streamv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Standard Streams Access loggers]

// Custom configuration for an :ref:`AccessLog <envoy_v3_api_msg_config.accesslog.v3.AccessLog>`
// that writes log entries directly to the operating system's standard output.
// [#extension: envoy.access_loggers.stdout]
message StdoutAccessLog {
  oneof access_log_format {
    // Configuration to form access log data and format.
    // If not specified, use :ref:`default format <config_access_log_default_format>`.
    config.core.v3.SubstitutionFormatString log_format = 1
        [(validate.rules).message = {required: true}];
  }
}

// Custom configuration for an :ref:`AccessLog <envoy_v3_api_msg_config.accesslog.v3.AccessLog>`
// that writes log entries directly to the operating system's standard error.
// [#extension: envoy.access_loggers.stderr]
message StderrAccessLog {
  oneof access_log_format {
    // Configuration to form access log data and format.
    // If not specified, use :ref:`default format <config_access_log_default_format>`.
    config.core.v3.SubstitutionFormatString log_format = 1
        [(validate.rules).message = {required: true}];
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/wasm/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.access_loggers.wasm.v3;

import "envoy/extensions/wasm/v3/wasm.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.access_loggers.wasm.v3";
option java_outer_classname = "WasmProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/wasm/v3;wasmv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Wasm access log]
// [#extension: envoy.access_loggers.wasm]

// Custom configuration for an :ref:`AccessLog <envoy_v3_api_msg_config.accesslog.v3.AccessLog>`
// that calls into a WASM VM. Configures the built-in ``envoy.access_loggers.wasm``
// AccessLog.
message WasmAccessLog {
  envoy.extensions.wasm.v3.PluginConfig config = 1;
}
syntax = "proto3";

package envoy.extensions.udp_packet_writer.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.udp_packet_writer.v3";
option java_outer_classname = "UdpGsoBatchWriterFactoryProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/udp_packet_writer/v3;udp_packet_writerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: UDP GSO batch packet writer config]
// [#extension: envoy.udp_packet_writer.gso]

// Configuration for the UDP GSO batch packet writer factory.
message UdpGsoBatchWriterFactory {
}
syntax = "proto3";

package envoy.extensions.udp_packet_writer.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.udp_packet_writer.v3";
option java_outer_classname = "UdpDefaultWriterFactoryProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/udp_packet_writer/v3;udp_packet_writerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: UDP packet writer config]
// [#extension: envoy.udp_packet_writer.default]

// Configuration for the default UDP packet writer factory which simply
// uses the kernel's sendmsg() to send UDP packets.
message UdpDefaultWriterFactory {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.stat_sinks.open_telemetry.v3;

import "envoy/config/core/v3/grpc_service.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.stat_sinks.open_telemetry.v3";
option java_outer_classname = "OpenTelemetryProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/stat_sinks/open_telemetry/v3;open_telemetryv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Open Telemetry Stats Sink]
// Stats configuration proto schema for ``envoy.stat_sinks.open_telemetry`` sink.
// [#extension: envoy.stat_sinks.open_telemetry]

// [#next-free-field: 7]
message SinkConfig {
  oneof protocol_specifier {
    option (validate.required) = true;

    // The upstream gRPC cluster that implements the OTLP/gRPC collector.
    config.core.v3.GrpcService grpc_service = 1 [(validate.rules).message = {required: true}];
  }

  // If set to true, counters will be emitted as deltas, and the OTLP message will have
  // ``AGGREGATION_TEMPORALITY_DELTA`` set as AggregationTemporality.
  bool report_counters_as_deltas = 2;

  // If set to true, histograms will be emitted as deltas, and the OTLP message will have
  // ``AGGREGATION_TEMPORALITY_DELTA`` set as AggregationTemporality.
  bool report_histograms_as_deltas = 3;

  // If set to true, metrics will have their tags emitted as OTLP attributes, which may
  // contain values used by the tag extractor or additional tags added during stats creation.
  // Otherwise, no attributes will be associated with the export message. Default value is true.
  google.protobuf.BoolValue emit_tags_as_attributes = 4;

  // If set to true, metric names will be represented as the tag extracted name instead
  // of the full metric name. Default value is true.
  google.protobuf.BoolValue use_tag_extracted_name = 5;

  // If set, emitted stats names will be prepended with a prefix, so full stat name will be
  // <prefix>.<stats_name>. For example, if the stat name is "foo.bar" and prefix is
  // "pre", the full stat name will be "pre.foo.bar". If this field is not set, there is no
  // prefix added. According to the example, the full stat name will remain "foo.bar".
  string prefix = 6;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/wasm/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.stat_sinks.wasm.v3;

import "envoy/extensions/wasm/v3/wasm.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.stat_sinks.wasm.v3";
option java_outer_classname = "WasmProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/stat_sinks/wasm/v3;wasmv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Wasm]
// Wasm :ref:`configuration overview <config_stat_sinks_wasm>`.
// [#extension: envoy.stat_sinks.wasm]

message Wasm {
  // General Plugin configuration.
  envoy.extensions.wasm.v3.PluginConfig config = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.stat_sinks.graphite_statsd.v3;

import "envoy/config/core/v3/address.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.stat_sinks.graphite_statsd.v3";
option java_outer_classname = "GraphiteStatsdProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/stat_sinks/graphite_statsd/v3;graphite_statsdv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Graphite+Statsd]
// Stats configuration proto schema for ``envoy.stat_sinks.graphite_statsd`` sink.
// The sink emits stats with `Graphite <https://graphite.readthedocs.io/en/latest/tags.html>`_
// compatible tags. Tags are configurable via :ref:`StatsConfig
// <envoy_v3_api_msg_config.metrics.v3.StatsConfig>`.
// [#extension: envoy.stat_sinks.graphite_statsd]

message GraphiteStatsdSink {
  oneof statsd_specifier {
    option (validate.required) = true;

    // The UDP address of a running Graphite-compliant listener. If specified,
    // statistics will be flushed to this address.
    config.core.v3.Address address = 1;
  }

  // Optional custom metric name prefix. See :ref:`StatsdSink's prefix field
  // <envoy_v3_api_field_config.metrics.v3.StatsdSink.prefix>` for more details.
  string prefix = 3;

  // Optional max datagram size to use when sending UDP messages. By default Envoy
  // will emit one metric per datagram. By specifying a max-size larger than a single
  // metric, Envoy will emit multiple, new-line separated metrics. The max datagram
  // size should not exceed your network's MTU.
  //
  // Note that this value may not be respected if smaller than a single metric.
  google.protobuf.UInt64Value max_bytes_per_datagram = 4 [(validate.rules).uint64 = {gt: 0}];
}
syntax = "proto3";

package envoy.extensions.injected_credentials.oauth2.v3;

import "envoy/config/core/v3/http_uri.proto";
import "envoy/extensions/transport_sockets/tls/v3/secret.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.injected_credentials.oauth2.v3";
option java_outer_classname = "Oauth2Proto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/injected_credentials/oauth2/v3;oauth2v3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: OAuth2 Credential]
// [#not-implemented-hide:]
// [#extension: envoy.injected_credentials.oauth2]

// OAuth2 extension can be used to retrieve an OAuth2 access token from an authorization server and inject it into the
// proxied requests.
// Currently, only the Client Credentials Grant flow is supported.
// The access token will be injected into the request headers using the ``Authorization`` header as a bearer token.
message OAuth2 {
  enum AuthType {
    // The ``client_id`` and ``client_secret`` will be sent using HTTP Basic authentication scheme.
    BASIC_AUTH = 0;

    // The ``client_id`` and ``client_secret`` will be sent in the URL encoded request body.
    // This type should only be used when Auth server does not support Basic authentication.
    URL_ENCODED_BODY = 1;
  }

  // Credentials to authenticate client to the authorization server.
  // Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-2.3) for details.
  message ClientCredentials {
    // Client ID.
    // Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-2.3.1) for details.
    string client_id = 1 [(validate.rules).string = {min_len: 1}];

    // Client secret.
    // Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-2.3.1) for details.
    transport_sockets.tls.v3.SdsSecretConfig client_secret = 2
        [(validate.rules).message = {required: true}];

    // The method to use when sending credentials to the authorization server.
    // Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-2.3.1) for details.
    AuthType auth_type = 3;
  }

  // Endpoint on the authorization server to retrieve the access token from.
  // Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-3.2) for details.
  config.core.v3.HttpUri token_endpoint = 1 [(validate.rules).message = {required: true}];

  // Optional list of OAuth scopes to be claimed in the authorization request.
  // Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-4.4.2) for details.
  repeated string scopes = 2;

  oneof flow_type {
    option (validate.required) = true;

    // Client Credentials Grant.
    // Refer to [RFC 6749: The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749#section-4.4) for details.
    ClientCredentials client_credentials = 3;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/extensions/transport_sockets/tls/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.injected_credentials.generic.v3;

import "envoy/extensions/transport_sockets/tls/v3/secret.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.injected_credentials.generic.v3";
option java_outer_classname = "GenericProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/injected_credentials/generic/v3;genericv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: Generic Credential]
// [#not-implemented-hide:]
// [#extension: envoy.injected_credentials.generic]

// Generic extension can be used to inject HTTP Basic Auth, Bearer Token, or any arbitrary credential
// into the proxied requests.
// The credential will be injected into the specified HTTP request header.
// Example:
//
//  .. code-block:: yaml
//
//  credential:
//    name: generic_credential
//    typed_config:
//      "@type": type.googleapis.com/envoy.extensions.injected_credentials.generic.v3.Generic
//      credential:
//        name: credential
//        sds_config:
//          path_config_source:
//            path: credential.yaml
//      header: Authorization
//
// credential.yaml for Basic Auth:
//
//  .. code-block:: yaml
//
//  resources:
//  - "@type": "type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.Secret"
//    name: credential
//    generic_secret:
//      secret:
//        inline_string: "Basic base64EncodedUsernamePassword"
//
// Refer to [RFC 7617: The 'Basic' HTTP Authentication Scheme](https://www.rfc-editor.org/rfc/rfc7617) for details.
//
// credential.yaml for Bearer Token:
//
//  .. code-block:: yaml
//  resources:
//  - "@type": "type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.Secret"
//    name: credential
//    generic_secret:
//      secret:
//        inline_string: "Bearer myToken"
//
// Refer to [RFC 6750: The OAuth 2.0 Authorization Framework: Bearer Token Usage](https://www.rfc-editor.org/rfc/rfc6750) for details.
//
message Generic {
  // The SDS configuration for the credential that will be injected to the specified HTTP request header.
  // It must be a generic secret.
  transport_sockets.tls.v3.SdsSecretConfig credential = 1
      [(validate.rules).message = {required: true}];

  // The header that will be injected to the HTTP request with the provided credential.
  // If not set, filter will default to: ``Authorization``
  string header = 2
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/transport_sockets/tls/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.health_checkers.redis.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.health_checkers.redis.v3";
option java_outer_classname = "RedisProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/health_checkers/redis/v3;redisv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Redis]
// Redis health checker :ref:`configuration overview <config_health_checkers_redis>`.
// [#extension: envoy.health_checkers.redis]

message Redis {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.health_checker.redis.v2.Redis";

  // If set, optionally perform ``EXISTS <key>`` instead of ``PING``. A return value
  // from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
  // than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
  // by setting the specified key to any value and waiting for traffic to drain.
  string key = 1;
}
syntax = "proto3";

package envoy.extensions.health_checkers.thrift.v3;

import "envoy/extensions/filters/network/thrift_proxy/v3/thrift_proxy.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.health_checkers.thrift.v3";
option java_outer_classname = "ThriftProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/health_checkers/thrift/v3;thriftv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Thrift]
// Thrift health checker :ref:`configuration overview <config_health_checkers_thrift>`.
// [#extension: envoy.health_checkers.thrift]

message Thrift {
  // Specifies the method name that will be set on each health check request dispatched to an upstream host.
  // Note that method name is case sensitive.
  string method_name = 1 [(validate.rules).string = {min_len: 1}];

  // Configures the transport type to be used with the health checks. Note that
  // :ref:`AUTO_TRANSPORT<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.TransportType.AUTO_TRANSPORT>`
  // is not supported, and we don't honor :ref:`ThriftProtocolOptions<envoy_v3_api_msg_extensions.filters.network.thrift_proxy.v3.ThriftProtocolOptions>`
  // since it's possible to set to :ref:`AUTO_TRANSPORT<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.TransportType.AUTO_TRANSPORT>`.
  // [#extension-category: envoy.filters.network]
  filters.network.thrift_proxy.v3.TransportType transport = 2
      [(validate.rules).enum = {defined_only: true}];

  // Configures the protocol type to be used with the health checks. Note that
  // :ref:`AUTO_PROTOCOL<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.ProtocolType.AUTO_PROTOCOL>`
  // and :ref:`TWITTER<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.ProtocolType.TWITTER>`
  // are not supported, and we don't honor :ref:`ThriftProtocolOptions<envoy_v3_api_msg_extensions.filters.network.thrift_proxy.v3.ThriftProtocolOptions>`
  // since it's possible to set to :ref:`AUTO_PROTOCOL<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.ProtocolType.AUTO_PROTOCOL>`
  // or :ref:`TWITTER<envoy_v3_api_enum_value_extensions.filters.network.thrift_proxy.v3.ProtocolType.TWITTER>`.
  filters.network.thrift_proxy.v3.ProtocolType protocol = 3
      [(validate.rules).enum = {defined_only: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/filters/network/thrift_proxy/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.common.matching.v3;

import "envoy/config/common/matcher/v3/matcher.proto";
import "envoy/config/core/v3/extension.proto";

import "xds/type/matcher/v3/matcher.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.common.matching.v3";
option java_outer_classname = "ExtensionMatcherProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/common/matching/v3;matchingv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Extension matcher]

// Wrapper around an existing extension that provides an associated matcher. This allows
// decorating an existing extension with a matcher, which can be used to match against
// relevant protocol data.
message ExtensionWithMatcher {
  // The associated matcher. This is deprecated in favor of xds_matcher.
  config.common.matcher.v3.Matcher matcher = 1
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // The associated matcher.
  xds.type.matcher.v3.Matcher xds_matcher = 3;

  // The underlying extension config.
  config.core.v3.TypedExtensionConfig extension_config = 2
      [(validate.rules).message = {required: true}];
}

// Extra settings on a per virtualhost/route/weighted-cluster level.
message ExtensionWithMatcherPerRoute {
  // Matcher override.
  xds.type.matcher.v3.Matcher xds_matcher = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/common/matcher/v3:pkg",
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/type/matcher/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.common.async_files.v3;

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.common.async_files.v3";
option java_outer_classname = "AsyncFileManagerProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/common/async_files/v3;async_filesv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: AsyncFileManager configuration]

// Configuration to instantiate or select a singleton ``AsyncFileManager``.
message AsyncFileManagerConfig {
  message ThreadPool {
    // The number of threads to use. If unset or zero, will default to the number
    // of concurrent threads the hardware supports. This default is subject to
    // change if performance analysis suggests it.
    uint32 thread_count = 1 [(validate.rules).uint32 = {lte: 1024}];
  }

  // An optional identifier for the manager. An empty string is a valid identifier
  // for a common, default ``AsyncFileManager``.
  //
  // Reusing the same id with different configurations in the same envoy instance
  // is an error.
  string id = 1;

  oneof manager_type {
    option (validate.required) = true;

    // Configuration for a thread-pool based async file manager.
    ThreadPool thread_pool = 2;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.common.dynamic_forward_proxy.v3;

import "envoy/config/cluster/v3/cluster.proto";
import "envoy/config/common/key_value/v3/config.proto";
import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/resolver.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.common.dynamic_forward_proxy.v3";
option java_outer_classname = "DnsCacheProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/common/dynamic_forward_proxy/v3;dynamic_forward_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Dynamic forward proxy common configuration]

// Configuration of circuit breakers for resolver.
message DnsCacheCircuitBreakers {
  // The maximum number of pending requests that Envoy will allow to the
  // resolver. If not specified, the default is 1024.
  google.protobuf.UInt32Value max_pending_requests = 1;
}

// Configuration for the dynamic forward proxy DNS cache. See the :ref:`architecture overview
// <arch_overview_http_dynamic_forward_proxy>` for more information.
// [#next-free-field: 15]
message DnsCacheConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.common.dynamic_forward_proxy.v2alpha.DnsCacheConfig";

  // The name of the cache. Multiple named caches allow independent dynamic forward proxy
  // configurations to operate within a single Envoy process using different configurations. All
  // configurations with the same name *must* otherwise have the same settings when referenced
  // from different configuration components. Configuration will fail to load if this is not
  // the case.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // The DNS lookup family to use during resolution.
  //
  // [#comment:TODO(mattklein123): Figure out how to support IPv4/IPv6 "happy eyeballs" mode. The
  // way this might work is a new lookup family which returns both IPv4 and IPv6 addresses, and
  // then configures a host to have a primary and fall back address. With this, we could very
  // likely build a "happy eyeballs" connection pool which would race the primary / fall back
  // address and return the one that wins. This same method could potentially also be used for
  // QUIC to TCP fall back.]
  config.cluster.v3.Cluster.DnsLookupFamily dns_lookup_family = 2
      [(validate.rules).enum = {defined_only: true}];

  // The DNS refresh rate for unresolved DNS hosts. If not specified defaults to 60s.
  //
  // The refresh rate is rounded to the closest millisecond, and must be at least 1ms.
  //
  // Once a host has been resolved, the refresh rate will be the DNS TTL, capped
  // at a minimum of ``dns_min_refresh_rate``.
  google.protobuf.Duration dns_refresh_rate = 3
      [(validate.rules).duration = {gte {nanos: 1000000}}];

  // The minimum rate that DNS resolution will occur. Per ``dns_refresh_rate``, once a host is
  // resolved, the DNS TTL will be used, with a minimum set by ``dns_min_refresh_rate``.
  // ``dns_min_refresh_rate`` defaults to 5s and must also be >= 5s.
  google.protobuf.Duration dns_min_refresh_rate = 14
      [(validate.rules).duration = {gte {seconds: 5}}];

  // The TTL for hosts that are unused. Hosts that have not been used in the configured time
  // interval will be purged. If not specified defaults to 5m.
  //
  // .. note:
  //
  //   The TTL is only checked at the time of DNS refresh, as specified by ``dns_refresh_rate``. This
  //   means that if the configured TTL is shorter than the refresh rate the host may not be removed
  //   immediately.
  //
  //  .. note:
  //
  //   The TTL has no relation to DNS TTL and is only used to control Envoy's resource usage.
  google.protobuf.Duration host_ttl = 4 [(validate.rules).duration = {gt {}}];

  // The maximum number of hosts that the cache will hold. If not specified defaults to 1024.
  //
  // .. note:
  //
  //   The implementation is approximate and enforced independently on each worker thread, thus
  //   it is possible for the maximum hosts in the cache to go slightly above the configured
  //   value depending on timing. This is similar to how other circuit breakers work.
  google.protobuf.UInt32Value max_hosts = 5 [(validate.rules).uint32 = {gt: 0}];

  // If the DNS failure refresh rate is specified,
  // this is used as the cache's DNS refresh rate when DNS requests are failing. If this setting is
  // not specified, the failure refresh rate defaults to the dns_refresh_rate.
  config.cluster.v3.Cluster.RefreshRate dns_failure_refresh_rate = 6;

  // The config of circuit breakers for resolver. It provides a configurable threshold.
  // Envoy will use dns cache circuit breakers with default settings even if this value is not set.
  DnsCacheCircuitBreakers dns_cache_circuit_breaker = 7;

  // Always use TCP queries instead of UDP queries for DNS lookups.
  // This field is deprecated in favor of ``dns_resolution_config``
  // which aggregates all of the DNS resolver configuration in a single message.
  bool use_tcp_for_dns_lookups = 8
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // DNS resolution configuration which includes the underlying dns resolver addresses and options.
  // This field is deprecated in favor of
  // :ref:`typed_dns_resolver_config <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.typed_dns_resolver_config>`.
  config.core.v3.DnsResolutionConfig dns_resolution_config = 9
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
  // or any other DNS resolver types and the related parameters.
  // For example, an object of
  // :ref:`CaresDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
  // can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
  // :ref:`dns_resolution_config <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_resolution_config>`
  // configuration.
  // During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
  // when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
  // When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
  // [#extension-category: envoy.network.dns_resolver]
  config.core.v3.TypedExtensionConfig typed_dns_resolver_config = 12;

  // Hostnames that should be preresolved into the cache upon creation. This might provide a
  // performance improvement, in the form of cache hits, for hostnames that are going to be
  // resolved during steady state and are known at config load time.
  repeated config.core.v3.SocketAddress preresolve_hostnames = 10;

  // The timeout used for DNS queries. This timeout is independent of any timeout and retry policy
  // used by the underlying DNS implementation (e.g., c-areas and Apple DNS) which are opaque.
  // Setting this timeout will ensure that queries succeed or fail within the specified time frame
  // and are then retried using the standard refresh rates. Defaults to 5s if not set.
  google.protobuf.Duration dns_query_timeout = 11 [(validate.rules).duration = {gt {}}];

  // Configuration to flush the DNS cache to long term storage.
  config.common.key_value.v3.KeyValueStoreConfig key_value_config = 13;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/cluster/v3:pkg",
        "//envoy/config/common/key_value/v3:pkg",
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/tap/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.common.tap.v3;

import "envoy/config/tap/v3/common.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.common.tap.v3";
option java_outer_classname = "CommonProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/common/tap/v3;tapv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common tap extension configuration]

// Common configuration for all tap extensions.
message CommonExtensionConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.common.tap.v2alpha.CommonExtensionConfig";

  oneof config_type {
    option (validate.required) = true;

    // If specified, the tap filter will be configured via an admin handler.
    AdminConfig admin_config = 1;

    // If specified, the tap filter will be configured via a static configuration that cannot be
    // changed.
    config.tap.v3.TapConfig static_config = 2;
  }
}

// Configuration for the admin handler. See :ref:`here <config_http_filters_tap_admin_handler>` for
// more information.
message AdminConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.common.tap.v2alpha.AdminConfig";

  // Opaque configuration ID. When requests are made to the admin handler, the passed opaque ID is
  // matched to the configured filter opaque ID to determine which filter to configure.
  string config_id = 1 [(validate.rules).string = {min_len: 1}];
}
syntax = "proto3";

package envoy.extensions.common.ratelimit.v3;

import "envoy/type/v3/ratelimit_unit.proto";
import "envoy/type/v3/token_bucket.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.common.ratelimit.v3";
option java_outer_classname = "RatelimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/common/ratelimit/v3;ratelimitv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common rate limit components]

// Defines the version of the standard to use for X-RateLimit headers.
enum XRateLimitHeadersRFCVersion {
  // X-RateLimit headers disabled.
  OFF = 0;

  // Use `draft RFC Version 03 <https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html>`_ where 3 headers will be added:
  //
  // * ``X-RateLimit-Limit`` - indicates the request-quota associated to the
  //   client in the current time-window followed by the description of the
  //   quota policy. The value is returned by the maximum tokens of the token bucket.
  // * ``X-RateLimit-Remaining`` - indicates the remaining requests in the
  //   current time-window. The value is returned by the remaining tokens in the token bucket.
  // * ``X-RateLimit-Reset`` - indicates the number of seconds until reset of
  //   the current time-window. The value is returned by the remaining fill interval of the token bucket.
  DRAFT_VERSION_03 = 1;
}

enum VhRateLimitsOptions {
  // Use the virtual host rate limits unless the route has a rate limit policy.
  OVERRIDE = 0;

  // Use the virtual host rate limits even if the route has a rate limit policy.
  INCLUDE = 1;

  // Ignore the virtual host rate limits even if the route does not have a rate limit policy.
  IGNORE = 2;
}

// A RateLimitDescriptor is a list of hierarchical entries that are used by the service to
// determine the final rate limit key and overall allowed limit. Here are some examples of how
// they might be used for the domain "envoy".
//
// .. code-block:: cpp
//
//   ["authenticated": "false"], ["remote_address": "10.0.0.1"]
//
// What it does: Limits all unauthenticated traffic for the IP address 10.0.0.1. The
// configuration supplies a default limit for the *remote_address* key. If there is a desire to
// raise the limit for 10.0.0.1 or block it entirely it can be specified directly in the
// configuration.
//
// .. code-block:: cpp
//
//   ["authenticated": "false"], ["path": "/foo/bar"]
//
// What it does: Limits all unauthenticated traffic globally for a specific path (or prefix if
// configured that way in the service).
//
// .. code-block:: cpp
//
//   ["authenticated": "false"], ["path": "/foo/bar"], ["remote_address": "10.0.0.1"]
//
// What it does: Limits unauthenticated traffic to a specific path for a specific IP address.
// Like (1) we can raise/block specific IP addresses if we want with an override configuration.
//
// .. code-block:: cpp
//
//   ["authenticated": "true"], ["client_id": "foo"]
//
// What it does: Limits all traffic for an authenticated client "foo"
//
// .. code-block:: cpp
//
//   ["authenticated": "true"], ["client_id": "foo"], ["path": "/foo/bar"]
//
// What it does: Limits traffic to a specific path for an authenticated client "foo"
//
// The idea behind the API is that (1)/(2)/(3) and (4)/(5) can be sent in 1 request if desired.
// This enables building complex application scenarios with a generic backend.
//
// Optionally the descriptor can contain a limit override under a "limit" key, that specifies
// the number of requests per unit to use instead of the number configured in the
// rate limiting service.
message RateLimitDescriptor {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.ratelimit.RateLimitDescriptor";

  message Entry {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.ratelimit.RateLimitDescriptor.Entry";

    // Descriptor key.
    string key = 1 [(validate.rules).string = {min_len: 1}];

    // Descriptor value.
    string value = 2 [(validate.rules).string = {min_len: 1}];
  }

  // Override rate limit to apply to this descriptor instead of the limit
  // configured in the rate limit service. See :ref:`rate limit override
  // <config_http_filters_rate_limit_rate_limit_override>` for more information.
  message RateLimitOverride {
    // The number of requests per unit of time.
    uint32 requests_per_unit = 1;

    // The unit of time.
    type.v3.RateLimitUnit unit = 2 [(validate.rules).enum = {defined_only: true}];
  }

  // Descriptor entries.
  repeated Entry entries = 1 [(validate.rules).repeated = {min_items: 1}];

  // Optional rate limit override to supply to the ratelimit service.
  RateLimitOverride limit = 2;
}

message LocalRateLimitDescriptor {
  // Descriptor entries.
  repeated v3.RateLimitDescriptor.Entry entries = 1 [(validate.rules).repeated = {min_items: 1}];

  // Token Bucket algorithm for local ratelimiting.
  type.v3.TokenBucket token_bucket = 2 [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.formatter.req_without_query.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.formatter.req_without_query.v3";
option java_outer_classname = "ReqWithoutQueryProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/formatter/req_without_query/v3;req_without_queryv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Formatter extension for printing request without query string]
// [#extension: envoy.formatter.req_without_query]

// ReqWithoutQuery formatter extension implements REQ_WITHOUT_QUERY command operator that
// works the same way as :ref:`REQ <config_access_log_format_req>` except that it will
// remove the query string. It is used to avoid logging any sensitive information into
// the access log.
// See :ref:`here <config_access_log>` for more information on access log configuration.

// %REQ_WITHOUT_QUERY(X?Y):Z%
//   An HTTP request header where X is the main HTTP header, Y is the alternative one, and Z is an
//   optional parameter denoting string truncation up to Z characters long. The value is taken from
//   the HTTP request header named X first and if it's not set, then request header Y is used. If
//   none of the headers are present '-' symbol will be in the log.

// Configuration for the request without query formatter.
message ReqWithoutQuery {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.formatter.metadata.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.formatter.metadata.v3";
option java_outer_classname = "MetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/formatter/metadata/v3;metadatav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Formatter extension for printing various types of metadata]
// [#extension: envoy.formatter.metadata]

// Metadata formatter extension implements METADATA command operator that
// prints all types of metadata. The first parameter taken by METADATA operator defines
// type of metadata. The following types of metadata are supported (case sensitive):
//
// * DYNAMIC
// * CLUSTER
// * ROUTE
// * UPSTREAM_HOST
// * LISTENER
//
// See :ref:`here <config_access_log>` for more information on access log configuration.

// %METADATA(TYPE:NAMESPACE:KEY):Z%
//    :ref:`Metadata <envoy_v3_api_msg_config.core.v3.Metadata>` info,
//    where TYPE is type of metadata (see above for supported types),
//    NAMESPACE is the filter namespace used when setting the metadata, KEY is an optional
//    lookup key in the namespace with the option of specifying nested keys separated by ':',
//    and Z is an optional parameter denoting string truncation up to Z characters long.
//    The data will be logged as a JSON string. For example, for the following ROUTE metadata:
//
//    ``com.test.my_filter: {"test_key": "foo", "test_object": {"inner_key": "bar"}}``
//
//    * %METADATA(ROUTE:com.test.my_filter)% will log: ``{"test_key": "foo", "test_object": {"inner_key": "bar"}}``
//    * %METADATA(ROUTE:com.test.my_filter:test_key)% will log: ``foo``
//    * %METADATA(ROUTE:com.test.my_filter:test_object)% will log: ``{"inner_key": "bar"}``
//    * %METADATA(ROUTE:com.test.my_filter:test_object:inner_key)% will log: ``bar``
//    * %METADATA(ROUTE:com.unknown_filter)% will log: ``-``
//    * %METADATA(ROUTE:com.test.my_filter:unknown_key)% will log: ``-``
//    * %METADATA(ROUTE:com.test.my_filter):25% will log (truncation at 25 characters): ``{"test_key": "foo", "test``
//
//  .. note::
//
//    For typed JSON logs, this operator renders a single value with string, numeric, or boolean type
//    when the referenced key is a simple value. If the referenced key is a struct or list value, a
//    JSON struct or list is rendered. Structs and lists may be nested. In any event, the maximum
//    length is ignored.
//
//  .. note::
//
//    METADATA(DYNAMIC:NAMESPACE:KEY):Z is equivalent to :ref:`DYNAMIC_METADATA(NAMESPACE:KEY):Z<config_access_log_format_dynamic_metadata>`
//    METADATA(CLUSTER:NAMESPACE:KEY):Z is equivalent to :ref:`CLUSTER_METADATA(NAMESPACE:KEY):Z<config_access_log_format_cluster_metadata>`
//    METADATA(UPSTREAM_HOST:NAMESPACE:KEY):Z is equivalent to :ref:`UPSTREAM_METADATA(NAMESPACE:KEY):Z<config_access_log_format_upstream_host_metadata>`

message Metadata {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.formatter.cel.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.formatter.cel.v3";
option java_outer_classname = "CelProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/formatter/cel/v3;celv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Formatter extension for printing CEL expressions]
// [#extension: envoy.formatter.cel]

// CEL formatter extension implements CEL command operator that evaluates configured
// symbolic Common Expression Language expressions to generate an access log.
//
// See :ref:`here <config_access_log>` for more information on access log configuration.

// %CEL(EXPRESSION):Z%
// Expressions are based on the set of Envoy :ref:`attributes <arch_overview_attributes>`.
// Expression errors are considered `-`. Z is an optional parameter denoting string
// truncation up to Z characters long.
//
// Examples:
//
// * ``%CEL(response.code)%``
// * ``%CEL(connection.mtls)%``
// * ``%CEL(request.headers['x-envoy-original-path']):10%``
// * ``%CEL(request.headers['x-log-mtls'] || request.url_path.contains('v1beta3'))%``

// Configuration for the CEL formatter.
message Cel {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/geoip_providers/common/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.geoip_providers.maxmind.v3;

import "envoy/extensions/geoip_providers/common/v3/common.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.geoip_providers.maxmind.v3";
option java_outer_classname = "MaxmindProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/geoip_providers/maxmind/v3;maxmindv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: MaxMind Geolocation Provider]
// MaxMind geolocation provider :ref:`configuration overview <config_geoip_providers_maxmind>`.
// At least one geolocation database path :ref:`city_db_path <envoy_v3_api_field_extensions.geoip_providers.maxmind.v3.MaxMindConfig.city_db_path>`,
// :ref:`isp_db_path <envoy_v3_api_field_extensions.geoip_providers.maxmind.v3.MaxMindConfig.isp_db_path>` or
// :ref:`anon_db_path <envoy_v3_api_field_extensions.geoip_providers.maxmind.v3.MaxMindConfig.anon_db_path>` must be configured.
// [#extension: envoy.geoip_providers.maxmind]

message MaxMindConfig {
  // Full file path to the Maxmind city database, e.g. /etc/GeoLite2-City.mmdb.
  // Database file is expected to have .mmdb extension.
  string city_db_path = 1 [(validate.rules).string = {pattern: "^$|^.*\\.mmdb$"}];

  // Full file path to the Maxmind ASN database, e.g. /etc/GeoLite2-ASN.mmdb.
  // Database file is expected to have .mmdb extension.
  string isp_db_path = 2 [(validate.rules).string = {pattern: "^$|^.*\\.mmdb$"}];

  // Full file path to the Maxmind anonymous IP database, e.g. /etc/GeoIP2-Anonymous-IP.mmdb.
  // Database file is expected to have .mmdb extension.
  string anon_db_path = 3 [(validate.rules).string = {pattern: "^$|^.*\\.mmdb$"}];

  // Common provider configuration that specifies which geolocation headers will be populated with geolocation data.
  common.v3.CommonGeoipProviderConfig common_provider_config = 4
      [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.geoip_providers.common.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.geoip_providers.common.v3";
option java_outer_classname = "CommonProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/geoip_providers/common/v3;commonv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common Geolocation Provider Configuration]
// Common geolocation provider :ref:`configuration overview <config_geoip_providers_common>`.
// Common configuration shared across geolocation providers.

message CommonGeoipProviderConfig {
  // The set of geolocation headers to add to request. If any of the configured headers is present
  // in the incoming request, it will be overridden by the :ref:`Geoip filter <config_http_filters_geoip>`.
  // [#next-free-field: 10]
  message GeolocationHeadersToAdd {
    // If set, the header will be used to populate the country ISO code associated with the IP address.
    string country = 1
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];

    // If set, the header will be used to populate the city associated with the IP address.
    string city = 2
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];

    // If set, the header will be used to populate the region ISO code associated with the IP address.
    // The least specific subdivision will be selected as region value.
    string region = 3
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];

    // If set, the header will be used to populate the ASN associated with the IP address.
    string asn = 4
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];

    // If set, the IP address will be checked if it belongs to any type of anonymization network (e.g. VPN, public proxy etc)
    // and header will be populated with the check result. Header value will be set to either "true" or "false" depending on the check result.
    string is_anon = 5
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];

    // If set, the IP address will be checked if it belongs to a VPN and header will be populated with the check result.
    // Header value will be set to either "true" or "false" depending on the check result.
    string anon_vpn = 6
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];

    // If set, the IP address will be checked if it belongs to a hosting provider and header will be populated with the check result.
    // Header value will be set to either "true" or "false" depending on the check result.
    string anon_hosting = 7
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];

    // If set, the IP address will be checked if it belongs to a TOR exit node and header will be populated with the check result.
    // Header value will be set to either "true" or "false" depending on the check result.
    string anon_tor = 8
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];

    // If set, the IP address will be checked if it belongs to a public proxy and header will be populated with the check result.
    // Header value will be set to either "true" or "false" depending on the check result.
    string anon_proxy = 9
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME ignore_empty: true}];
  }

  // Configuration for geolocation headers to add to request.
  GeolocationHeadersToAdd geo_headers_to_add = 1 [(validate.rules).message = {required: true}];
}
syntax = "proto3";

package envoy.extensions.internal_redirect.previous_routes.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.internal_redirect.previous_routes.v3";
option java_outer_classname = "PreviousRoutesConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/internal_redirect/previous_routes/v3;previous_routesv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Previous routes internal redirect predicate]

// An internal redirect predicate that rejects redirect targets that are pointing
// to a route that has been followed by a previous redirect from the current route.
// [#extension: envoy.internal_redirect_predicates.previous_routes]
message PreviousRoutesConfig {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.internal_redirect.allow_listed_routes.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.internal_redirect.allow_listed_routes.v3";
option java_outer_classname = "AllowListedRoutesConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/internal_redirect/allow_listed_routes/v3;allow_listed_routesv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Allow listed routes internal redirect predicate]

// An internal redirect predicate that accepts only explicitly allowed target routes.
// [#extension: envoy.internal_redirect_predicates.allow_listed_routes]
message AllowListedRoutesConfig {
  // The list of routes that's allowed as redirect target by this predicate,
  // identified by the route's :ref:`name <envoy_v3_api_field_config.route.v3.Route.route>`.
  // Empty route names are not allowed.
  repeated string allowed_route_names = 1
      [(validate.rules).repeated = {items {string {min_len: 1}}}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.internal_redirect.safe_cross_scheme.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.internal_redirect.safe_cross_scheme.v3";
option java_outer_classname = "SafeCrossSchemeConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/internal_redirect/safe_cross_scheme/v3;safe_cross_schemev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: SafeCrossScheme internal redirect predicate]

// An internal redirect predicate that checks the scheme between the
// downstream url and the redirect target url and allows a) same scheme
// redirect and b) safe cross scheme redirect, which means if the downstream
// scheme is HTTPS, both HTTPS and HTTP redirect targets are allowed, but if the
// downstream scheme is HTTP, only HTTP redirect targets are allowed.
// [#extension: envoy.internal_redirect_predicates.safe_cross_scheme]
message SafeCrossSchemeConfig {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.load_balancing_policies.pick_first.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.pick_first.v3";
option java_outer_classname = "PickFirstProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/pick_first/v3;pick_firstv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Pick First Load Balancing Policy]
// [#not-implemented-hide:]

// This configuration allows the built-in PICK_FIRST LB policy to be configured
// via the LB policy extension point.
message PickFirst {
  // If set to true, instructs the LB policy to shuffle the list of addresses
  // received from the name resolver before attempting to connect to them.
  bool shuffle_address_list = 1;
}
syntax = "proto3";

package envoy.extensions.load_balancing_policies.subset.v3;

import "envoy/config/cluster/v3/cluster.proto";

import "google/protobuf/struct.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.subset.v3";
option java_outer_classname = "SubsetProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/subset/v3;subsetv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Subset Load Balancing Policy]
// [#extension: envoy.load_balancing_policies.subset]

// Optionally divide the endpoints in this cluster into subsets defined by
// endpoint metadata and selected by route and weighted cluster metadata.
// [#next-free-field: 11]
message Subset {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.cluster.v3.LbSubsetConfig";

  // If NO_FALLBACK is selected, a result
  // equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
  // any cluster endpoint may be returned (subject to policy, health checks,
  // etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
  // endpoints matching the values from the default_subset field.
  enum LbSubsetFallbackPolicy {
    NO_FALLBACK = 0;
    ANY_ENDPOINT = 1;
    DEFAULT_SUBSET = 2;
  }

  enum LbSubsetMetadataFallbackPolicy {
    // No fallback. Route metadata will be used as-is.
    METADATA_NO_FALLBACK = 0;

    // A special metadata key ``fallback_list`` will be used to provide variants of metadata to try.
    // Value of ``fallback_list`` key has to be a list. Every list element has to be a struct - it will
    // be merged with route metadata, overriding keys that appear in both places.
    // ``fallback_list`` entries will be used in order until a host is found.
    //
    // ``fallback_list`` key itself is removed from metadata before subset load balancing is performed.
    //
    // Example:
    //
    // for metadata:
    //
    // .. code-block:: yaml
    //
    //   version: 1.0
    //   fallback_list:
    //     - version: 2.0
    //       hardware: c64
    //     - hardware: c32
    //     - version: 3.0
    //
    // at first, metadata:
    //
    // .. code-block:: json
    //
    //   {"version": "2.0", "hardware": "c64"}
    //
    // will be used for load balancing. If no host is found, metadata:
    //
    // .. code-block:: json
    //
    //   {"version": "1.0", "hardware": "c32"}
    //
    // is next to try. If it still results in no host, finally metadata:
    //
    // .. code-block:: json
    //
    //   {"version": "3.0"}
    //
    // is used.
    FALLBACK_LIST = 1;
  }

  // Specifications for subsets.
  message LbSubsetSelector {
    // Allows to override top level fallback policy per selector.
    enum LbSubsetSelectorFallbackPolicy {
      // If NOT_DEFINED top level config fallback policy is used instead.
      NOT_DEFINED = 0;

      // If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
      NO_FALLBACK = 1;

      // If ANY_ENDPOINT is selected, any cluster endpoint may be returned
      // (subject to policy, health checks, etc).
      ANY_ENDPOINT = 2;

      // If DEFAULT_SUBSET is selected, load balancing is performed over the
      // endpoints matching the values from the default_subset field.
      DEFAULT_SUBSET = 3;

      // If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
      // keys reduced to
      // :ref:`fallback_keys_subset<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.fallback_keys_subset>`.
      // It allows for a fallback to a different, less specific selector if some of the keys of
      // the selector are considered optional.
      KEYS_SUBSET = 4;
    }

    // List of keys to match with the weighted cluster metadata.
    repeated string keys = 1;

    // Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
    // choosing a host, but updating hosts is faster, especially for large numbers of hosts.
    //
    // If a match is found to a host, that host will be used regardless of priority levels.
    //
    // When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in ``keys``
    // will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
    // :ref:`lb_subsets_single_host_per_subset_duplicate<config_cluster_manager_cluster_stats_subset_lb>` indicates how many duplicates are
    // present in the current configuration.
    bool single_host_per_subset = 4;

    // The behavior used when no endpoint subset matches the selected route's
    // metadata.
    LbSubsetSelectorFallbackPolicy fallback_policy = 2
        [(validate.rules).enum = {defined_only: true}];

    // Subset of
    // :ref:`keys<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.keys>` used by
    // :ref:`KEYS_SUBSET<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
    // fallback policy.
    // It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
    // For any other fallback policy the parameter is not used and should not be set.
    // Only values also present in
    // :ref:`keys<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.keys>` are allowed, but
    // ``fallback_keys_subset`` cannot be equal to ``keys``.
    repeated string fallback_keys_subset = 3;
  }

  // The behavior used when no endpoint subset matches the selected route's
  // metadata. The value defaults to
  // :ref:`NO_FALLBACK<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy.NO_FALLBACK>`.
  LbSubsetFallbackPolicy fallback_policy = 1 [(validate.rules).enum = {defined_only: true}];

  // Specifies the default subset of endpoints used during fallback if
  // fallback_policy is
  // :ref:`DEFAULT_SUBSET<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
  // Each field in default_subset is
  // compared to the matching LbEndpoint.Metadata under the ``envoy.lb``
  // namespace. It is valid for no hosts to match, in which case the behavior
  // is the same as a fallback_policy of
  // :ref:`NO_FALLBACK<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy.NO_FALLBACK>`.
  google.protobuf.Struct default_subset = 2;

  // For each entry, LbEndpoint.Metadata's
  // ``envoy.lb`` namespace is traversed and a subset is created for each unique
  // combination of key and value. For example:
  //
  // .. code-block:: json
  //
  //   { "subset_selectors": [
  //       { "keys": [ "version" ] },
  //       { "keys": [ "stage", "hardware_type" ] }
  //   ]}
  //
  // A subset is matched when the metadata from the selected route and
  // weighted cluster contains the same keys and values as the subset's
  // metadata. The same host may appear in multiple subsets.
  repeated LbSubsetSelector subset_selectors = 3;

  // By default, only when the request metadata has exactly the **same** keys as one of subset selectors and
  // the values of the related keys are matched, the load balancer will have a valid subset for the request.
  // For example, given the following subset selectors:
  //
  // .. code-block:: json
  //
  //   { "subset_selectors": [
  //       { "keys": [ "version" ] },
  //       { "keys": [ "stage", "version" ] }
  //   ]}
  //
  // A request with metadata ``{"redundant-key": "redundant-value", "stage": "prod", "version": "v1"}`` or
  // ``{"redundant-key": "redundant-value", "version": "v1"}`` will not have a valid subset even if the values
  // of keys ``stage`` and ``version`` are matched because of the redundant key/value pair in the request
  // metadata.
  //
  // By setting this field to true, the most appropriate keys will be filtered out from the request metadata
  // according to the subset selectors. And then the filtered keys and related values will be matched to find
  // the valid host subset. By this way, redundant key/value pairs are allowed in the request metadata. The keys
  // of a request metadata could be superset of the keys of the subset selectors and need not to be exactly the
  // same as the keys of the subset selectors.
  //
  // More specifically, if the keys of a request metadata is a superset of one of the subset selectors, then only
  // the values of the keys that in the selector keys will be matched. Take the above example, if the request
  // metadata is ``{"redundant-key": "redundant-value", "stage": "prod", "version": "v1"}``, the load balancer
  // will only match the values of ``stage`` and ``version`` to find an appropriate subset because ``stage``
  // ``version`` are contained by the second subset selector and the redundant ``redundant-key`` will be
  // ignored.
  //
  // .. note::
  //   If the keys of request metadata is superset of multiple different subset selectors keys, the subset
  //   selector with most keys to win. For example, given subset selectors
  //   ``{"subset_selectors": ["keys": ["A", "B", "C"], ["A", "B"]]}`` and request metadata ``{"A": "-",
  //   "B": "-", "C": "-", "D": "-"}``, keys ``A``, ``B``, ``C`` will be evaluated.
  //   If the keys of request metadata is superset of multiple different subset selectors keys and the number
  //   of selector keys are same, then the one placed in front to win. For example, given subset selectors
  //   ``{"subset_selectors": ["keys": ["A", "B"], ["C", "D"]]}`` and request metadata ``{"A": "-", "B": "-",
  //   "C": "-", "D": "-"}``, keys ``A``, ``B`` will be evaluated.
  //
  bool allow_redundant_keys = 10;

  // If true, routing to subsets will take into account the localities and locality weights of the
  // endpoints when making the routing decision.
  //
  // There are some potential pitfalls associated with enabling this feature, as the resulting
  // traffic split after applying both a subset match and locality weights might be undesirable.
  //
  // Consider for example a situation in which you have 50/50 split across two localities X/Y
  // which have 100 hosts each without subsetting. If the subset LB results in X having only 1
  // host selected but Y having 100, then a lot more load is being dumped on the single host in X
  // than originally anticipated in the load balancing assignment delivered via EDS.
  bool locality_weight_aware = 4;

  // When used with locality_weight_aware, scales the weight of each locality by the ratio
  // of hosts in the subset vs hosts in the original subset. This aims to even out the load
  // going to an individual locality if said locality is disproportionately affected by the
  // subset predicate.
  bool scale_locality_weight = 5;

  // If true, when a fallback policy is configured and its corresponding subset fails to find
  // a host this will cause any host to be selected instead.
  //
  // This is useful when using the default subset as the fallback policy, given the default
  // subset might become empty. With this option enabled, if that happens the LB will attempt
  // to select a host from the entire cluster.
  bool panic_mode_any = 6;

  // If true, metadata specified for a metadata key will be matched against the corresponding
  // endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
  // and any of the elements in the list matches the criteria.
  bool list_as_any = 7;

  // Fallback mechanism that allows to try different route metadata until a host is found.
  // If load balancing process, including all its mechanisms (like
  // :ref:`fallback_policy<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.subset.fallback_policy>`)
  // fails to select a host, this policy decides if and how the process is repeated using another metadata.
  //
  // The value defaults to
  // :ref:`METADATA_NO_FALLBACK
  // <envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.subset.LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK>`.
  LbSubsetMetadataFallbackPolicy metadata_fallback_policy = 8
      [(validate.rules).enum = {defined_only: true}];

  // The child LB policy to create for endpoint-picking within the chosen subset.
  config.cluster.v3.LoadBalancingPolicy subset_lb_policy = 9
      [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/cluster/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/load_balancing_policies/common/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.load_balancing_policies.round_robin.v3;

import "envoy/extensions/load_balancing_policies/common/v3/common.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.round_robin.v3";
option java_outer_classname = "RoundRobinProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/round_robin/v3;round_robinv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Round Robin Load Balancing Policy]
// [#extension: envoy.load_balancing_policies.round_robin]

// This configuration allows the built-in ROUND_ROBIN LB policy to be configured via the LB policy
// extension point. See the :ref:`load balancing architecture overview
// <arch_overview_load_balancing_types>` for more information.
message RoundRobin {
  // Configuration for slow start mode.
  // If this configuration is not set, slow start will not be not enabled.
  common.v3.SlowStartConfig slow_start_config = 1;

  // Configuration for local zone aware load balancing or locality weighted load balancing.
  common.v3.LocalityLbConfig locality_lb_config = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/extensions/load_balancing_policies/common/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.load_balancing_policies.ring_hash.v3;

import "envoy/extensions/load_balancing_policies/common/v3/common.proto";

import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.ring_hash.v3";
option java_outer_classname = "RingHashProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/ring_hash/v3;ring_hashv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Ring Hash Load Balancing Policy]
// [#extension: envoy.load_balancing_policies.ring_hash]

// This configuration allows the built-in RING_HASH LB policy to be configured via the LB policy
// extension point. See the :ref:`load balancing architecture overview
// <arch_overview_load_balancing_types>` for more information.
// [#next-free-field: 8]
message RingHash {
  // The hash function used to hash hosts onto the ketama ring.
  enum HashFunction {
    // Currently defaults to XX_HASH.
    DEFAULT_HASH = 0;

    // Use `xxHash <https://github.com/Cyan4973/xxHash>`_.
    XX_HASH = 1;

    // Use `MurmurHash2 <https://sites.google.com/site/murmurhash/>`_, this is compatible with
    // std:hash<string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
    // on Linux and not macOS.
    MURMUR_HASH_2 = 2;
  }

  // The hash function used to hash hosts onto the ketama ring. The value defaults to
  // :ref:`XX_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
  HashFunction hash_function = 1 [(validate.rules).enum = {defined_only: true}];

  // Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
  // provided host) the better the request distribution will reflect the desired weights. Defaults
  // to 1024 entries, and limited to 8M entries. See also
  // :ref:`maximum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size>`.
  google.protobuf.UInt64Value minimum_ring_size = 2
      [(validate.rules).uint64 = {lte: 8388608 gte: 1}];

  // Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
  // to further constrain resource use. See also
  // :ref:`minimum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size>`.
  google.protobuf.UInt64Value maximum_ring_size = 3 [(validate.rules).uint64 = {lte: 8388608}];

  // If set to ``true``, the cluster will use hostname instead of the resolved
  // address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
  //
  // .. note::
  //   This is deprecated and please use :ref:`consistent_hashing_lb_config
  //   <envoy_v3_api_field_extensions.load_balancing_policies.ring_hash.v3.RingHash.consistent_hashing_lb_config>` instead.
  bool use_hostname_for_hashing = 4
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
  // no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
  // If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
  // Minimum is 100.
  //
  // This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
  // ``hash_balance_factor``, requests to any upstream host are capped at ``hash_balance_factor/100`` times the average number of requests
  // across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
  // is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
  // the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
  // cascading overflow effect when choosing the next host in the ring/table).
  //
  // If weights are specified on the hosts, they are respected.
  //
  // This is an O(N) algorithm, unlike other load balancers. Using a lower ``hash_balance_factor`` results in more hosts
  // being probed, so use a higher value if you require better performance.
  //
  // .. note::
  //   This is deprecated and please use :ref:`consistent_hashing_lb_config
  //   <envoy_v3_api_field_extensions.load_balancing_policies.ring_hash.v3.RingHash.consistent_hashing_lb_config>` instead.
  google.protobuf.UInt32Value hash_balance_factor = 5 [
    deprecated = true,
    (validate.rules).uint32 = {gte: 100},
    (envoy.annotations.deprecated_at_minor_version) = "3.0"
  ];

  // Common configuration for hashing-based load balancing policies.
  common.v3.ConsistentHashingLbConfig consistent_hashing_lb_config = 6;

  // Enable locality weighted load balancing for ring hash lb explicitly.
  common.v3.LocalityLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 7;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.load_balancing_policies.common.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/type/v3/percent.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.common.v3";
option java_outer_classname = "CommonProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/common/v3;commonv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common configuration for two or more load balancing policy extensions]

message LocalityLbConfig {
  // Configuration for :ref:`zone aware routing
  // <arch_overview_load_balancing_zone_aware_routing>`.
  message ZoneAwareLbConfig {
    // Configures percentage of requests that will be considered for zone aware routing
    // if zone aware routing is configured. If not specified, the default is 100%.
    // * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
    // * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
    type.v3.Percent routing_enabled = 1;

    // Configures minimum upstream cluster size required for zone aware routing
    // If upstream cluster size is less than specified, zone aware routing is not performed
    // even if zone aware routing is configured. If not specified, the default is 6.
    // * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
    // * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
    google.protobuf.UInt64Value min_cluster_size = 2;

    // If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
    // mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
    // requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
    // failing service.
    bool fail_traffic_on_panic = 3;
  }

  // Configuration for :ref:`locality weighted load balancing
  // <arch_overview_load_balancing_locality_weighted_lb>`
  message LocalityWeightedLbConfig {
  }

  oneof locality_config_specifier {
    option (validate.required) = true;

    // Configuration for local zone aware load balancing.
    ZoneAwareLbConfig zone_aware_lb_config = 1;

    // Enable locality weighted load balancing.
    LocalityWeightedLbConfig locality_weighted_lb_config = 2;
  }
}

// Configuration for :ref:`slow start mode <arch_overview_load_balancing_slow_start>`.
message SlowStartConfig {
  // Represents the size of slow start window.
  // If set, the newly created host remains in slow start mode starting from its creation time
  // for the duration of slow start window.
  google.protobuf.Duration slow_start_window = 1;

  // This parameter controls the speed of traffic increase over the slow start window. Defaults to 1.0,
  // so that endpoint would get linearly increasing amount of traffic.
  // When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly.
  // The value of aggression parameter should be greater than 0.0.
  // By tuning the parameter, is possible to achieve polynomial or exponential shape of ramp-up curve.
  //
  // During slow start window, effective weight of an endpoint would be scaled with time factor and aggression:
  // ``new_weight = weight * max(min_weight_percent, time_factor ^ (1 / aggression))``,
  // where ``time_factor=(time_since_start_seconds / slow_start_time_seconds)``.
  //
  // As time progresses, more and more traffic would be sent to endpoint, which is in slow start window.
  // Once host exits slow start, time_factor and aggression no longer affect its weight.
  config.core.v3.RuntimeDouble aggression = 2;

  // Configures the minimum percentage of origin weight that avoids too small new weight,
  // which may cause endpoints in slow start mode receive no traffic in slow start window.
  // If not specified, the default is 10%.
  type.v3.Percent min_weight_percent = 3;
}

// Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
message ConsistentHashingLbConfig {
  // If set to ``true``, the cluster will use hostname instead of the resolved
  // address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
  bool use_hostname_for_hashing = 1;

  // Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
  // no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
  // If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
  // Minimum is 100.
  //
  // Applies to both Ring Hash and Maglev load balancers.
  //
  // This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
  // ``hash_balance_factor``, requests to any upstream host are capped at ``hash_balance_factor/100`` times the average number of requests
  // across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
  // is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
  // the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
  // cascading overflow effect when choosing the next host in the ring/table).
  //
  // If weights are specified on the hosts, they are respected.
  //
  // This is an O(N) algorithm, unlike other load balancers. Using a lower ``hash_balance_factor`` results in more hosts
  // being probed, so use a higher value if you require better performance.
  google.protobuf.UInt32Value hash_balance_factor = 2 [(validate.rules).uint32 = {gte: 100}];
}
syntax = "proto3";

package envoy.extensions.load_balancing_policies.client_side_weighted_round_robin.v3;

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.client_side_weighted_round_robin.v3";
option java_outer_classname = "ClientSideWeightedRoundRobinProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/client_side_weighted_round_robin/v3;client_side_weighted_round_robinv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Client-Side Weighted Round Robin Load Balancing Policy]
// [#not-implemented-hide:]

// Configuration for the client_side_weighted_round_robin LB policy.
//
// This policy differs from the built-in ROUND_ROBIN policy in terms of
// how the endpoint weights are determined. In the ROUND_ROBIN policy,
// the endpoint weights are sent by the control plane via EDS. However,
// in this policy, the endpoint weights are instead determined via qps (queries
// per second), eps (errors per second), and utilization metrics sent by the
// endpoint using the Open Request Cost Aggregation (ORCA) protocol. Utilization
// is determined by using the ORCA application_utilization field, if set, or
// else falling back to the cpu_utilization field. All queries count toward qps,
// regardless of result. Only failed queries count toward eps. A config
// parameter error_utilization_penalty controls the penalty to adjust endpoint
// weights using eps and qps. The weight of a given endpoint is computed as:
//   qps / (utilization + eps/qps * error_utilization_penalty)
//
// See the :ref:`load balancing architecture overview<arch_overview_load_balancing_types>` for more information.
//
// [#next-free-field: 7]
message ClientSideWeightedRoundRobin {
  // Whether to enable out-of-band utilization reporting collection from
  // the endpoints. By default, per-request utilization reporting is used.
  google.protobuf.BoolValue enable_oob_load_report = 1;

  // Load reporting interval to request from the server. Note that the
  // server may not provide reports as frequently as the client requests.
  // Used only when enable_oob_load_report is true. Default is 10 seconds.
  google.protobuf.Duration oob_reporting_period = 2;

  // A given endpoint must report load metrics continuously for at least
  // this long before the endpoint weight will be used. This avoids
  // churn when the set of endpoint addresses changes. Takes effect
  // both immediately after we establish a connection to an endpoint and
  // after weight_expiration_period has caused us to stop using the most
  // recent load metrics. Default is 10 seconds.
  google.protobuf.Duration blackout_period = 3;

  // If a given endpoint has not reported load metrics in this long,
  // then we stop using the reported weight. This ensures that we do
  // not continue to use very stale weights. Once we stop using a stale
  // value, if we later start seeing fresh reports again, the
  // blackout_period applies. Defaults to 3 minutes.
  google.protobuf.Duration weight_expiration_period = 4;

  // How often endpoint weights are recalculated. Values less than 100ms are
  // capped at 100ms. Default is 1 second.
  google.protobuf.Duration weight_update_period = 5;

  // The multiplier used to adjust endpoint weights with the error rate
  // calculated as eps/qps. Configuration is rejected if this value is negative.
  // Default is 1.0.
  google.protobuf.FloatValue error_utilization_penalty = 6 [(validate.rules).float = {gte: 0.0}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.load_balancing_policies.least_request.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/extensions/load_balancing_policies/common/v3/common.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.least_request.v3";
option java_outer_classname = "LeastRequestProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/least_request/v3;least_requestv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Least Request Load Balancing Policy]
// [#extension: envoy.load_balancing_policies.least_request]

// This configuration allows the built-in LEAST_REQUEST LB policy to be configured via the LB policy
// extension point. See the :ref:`load balancing architecture overview
// <arch_overview_load_balancing_types>` for more information.
// [#next-free-field: 6]
message LeastRequest {
  // The number of random healthy hosts from which the host with the fewest active requests will
  // be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
  google.protobuf.UInt32Value choice_count = 1 [(validate.rules).uint32 = {gte: 2}];

  // The following formula is used to calculate the dynamic weights when hosts have different load
  // balancing weights:
  //
  // ``weight = load_balancing_weight / (active_requests + 1)^active_request_bias``
  //
  // The larger the active request bias is, the more aggressively active requests will lower the
  // effective weight when all host weights are not equal.
  //
  // ``active_request_bias`` must be greater than or equal to 0.0.
  //
  // When ``active_request_bias == 0.0`` the Least Request Load Balancer doesn't consider the number
  // of active requests at the time it picks a host and behaves like the Round Robin Load
  // Balancer.
  //
  // When ``active_request_bias > 0.0`` the Least Request Load Balancer scales the load balancing
  // weight by the number of active requests at the time it does a pick.
  //
  // The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
  // host sets changes, e.g., whenever there is a host membership update or a host load balancing
  // weight change.
  //
  // .. note::
  //   This setting only takes effect if all host weights are not equal.
  config.core.v3.RuntimeDouble active_request_bias = 2;

  // Configuration for slow start mode.
  // If this configuration is not set, slow start will not be not enabled.
  common.v3.SlowStartConfig slow_start_config = 3;

  // Configuration for local zone aware load balancing or locality weighted load balancing.
  common.v3.LocalityLbConfig locality_lb_config = 4;

  // [#not-implemented-hide:]
  // Configuration for performing full scan on the list of hosts.
  // If this configuration is set, when selecting the host a full scan on the list hosts will be
  // used to select the one with least requests instead of using random choices.
  google.protobuf.BoolValue enable_full_scan = 5;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/extensions/load_balancing_policies/common/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/load_balancing_policies/common/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.load_balancing_policies.maglev.v3;

import "envoy/extensions/load_balancing_policies/common/v3/common.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.maglev.v3";
option java_outer_classname = "MaglevProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/maglev/v3;maglevv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Maglev Load Balancing Policy]
// [#extension: envoy.load_balancing_policies.maglev]

// This configuration allows the built-in Maglev LB policy to be configured via the LB policy
// extension point. See the :ref:`load balancing architecture overview
// <arch_overview_load_balancing_types>` and :ref:`Maglev<arch_overview_load_balancing_types_maglev>` for more information.
message Maglev {
  // The table size for Maglev hashing. Maglev aims for "minimal disruption" rather than an absolute guarantee.
  // Minimal disruption means that when the set of upstream hosts change, a connection will likely be sent to the same
  // upstream as it was before. Increasing the table size reduces the amount of disruption.
  // The table size must be prime number limited to 5000011. If it is not specified, the default is 65537.
  google.protobuf.UInt64Value table_size = 1 [(validate.rules).uint64 = {lte: 5000011}];

  // Common configuration for hashing-based load balancing policies.
  common.v3.ConsistentHashingLbConfig consistent_hashing_lb_config = 2;

  // Enable locality weighted load balancing for maglev lb explicitly.
  common.v3.LocalityLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;
}
syntax = "proto3";

package envoy.extensions.load_balancing_policies.wrr_locality.v3;

import "envoy/config/cluster/v3/cluster.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.wrr_locality.v3";
option java_outer_classname = "WrrLocalityProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/wrr_locality/v3;wrr_localityv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Weighted Round Robin Locality-Picking Load Balancing Policy]
// [#not-implemented-hide:]

// Configuration for the wrr_locality LB policy. See the :ref:`load balancing architecture overview
// <arch_overview_load_balancing_types>` for more information.
message WrrLocality {
  // The child LB policy to create for endpoint-picking within the chosen locality.
  config.cluster.v3.LoadBalancingPolicy endpoint_picking_policy = 1
      [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/cluster/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.load_balancing_policies.random.v3;

import "envoy/extensions/load_balancing_policies/common/v3/common.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.random.v3";
option java_outer_classname = "RandomProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/random/v3;randomv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Random Load Balancing Policy]
// [#extension: envoy.load_balancing_policies.random]

// This configuration allows the built-in Random LB policy to be configured via the LB policy
// extension point. See the :ref:`load balancing architecture overview
// <arch_overview_load_balancing_types>` for more information.
message Random {
  // Configuration for local zone aware load balancing or locality weighted load balancing.
  common.v3.LocalityLbConfig locality_lb_config = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/load_balancing_policies/common/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.load_balancing_policies.cluster_provided.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.cluster_provided.v3";
option java_outer_classname = "ClusterProvidedProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/cluster_provided/v3;cluster_providedv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Cluster Provided Load Balancing Policy]
// [#extension: envoy.load_balancing_policies.cluster_provided]

// The cluster provided load balancing policy allows cluster to specify its own load balancing.
// If this extension is configured, the target cluster must provide load balancer when the cluster
// is created.
//
// .. note::
//   Cluster provided load balancing policy could not be used as sub-policy of other hierarchical
//   load balancing policies, such as subset load balancing policy.
message ClusterProvided {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.watchdog.profile_action.v3;

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.watchdog.profile_action.v3";
option java_outer_classname = "ProfileActionProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/watchdog/profile_action/v3;profile_actionv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Watchdog Action that does CPU profiling.]
// [#extension: envoy.watchdog.profile_action]

// Configuration for the profile watchdog action.
message ProfileActionConfig {
  // How long the profile should last. If not set defaults to 5 seconds.
  google.protobuf.Duration profile_duration = 1;

  // File path to the directory to output profiles.
  string profile_path = 2 [(validate.rules).string = {min_len: 1}];

  // Limits the max number of profiles that can be generated by this action
  // over its lifetime to avoid filling the disk.
  // If not set (i.e. it's 0), a default of 10 will be used.
  uint64 max_profiles = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/common/async_files/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.http.cache.file_system_http_cache.v3;

import "envoy/extensions/common/async_files/v3/async_file_manager.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.http.cache.file_system_http_cache.v3";
option java_outer_classname = "FileSystemHttpCacheProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/http/cache/file_system_http_cache/v3;file_system_http_cachev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: FileSystemHttpCacheConfig]
// [#extension: envoy.extensions.http.cache.file_system_http_cache]

// Configuration for a cache implementation that caches in the local file system.
//
// By default this cache uses a least-recently-used eviction strategy.
//
// For implementation details, see `DESIGN.md <https://github.com/envoyproxy/envoy/blob/main/source/extensions/http/cache/file_system_http_cache/DESIGN.md>`_.
// [#next-free-field: 11]
message FileSystemHttpCacheConfig {
  // Configuration of a manager for how the file system is used asynchronously.
  common.async_files.v3.AsyncFileManagerConfig manager_config = 1
      [(validate.rules).message = {required: true}];

  // Path at which the cache files will be stored.
  //
  // This also doubles as the unique identifier for a cache, so a cache can be shared
  // between different routes, or separate paths can be used to specify separate caches.
  //
  // If the same ``cache_path`` is used in more than one ``CacheConfig``, the rest of the
  // ``FileSystemHttpCacheConfig`` must also match, and will refer to the same cache
  // instance.
  string cache_path = 2 [(validate.rules).string = {min_len: 1}];

  // The maximum size of the cache in bytes - when reached, cache eviction is triggered.
  //
  // This is measured as the sum of file sizes, such that it includes headers, trailers,
  // and metadata, but does not include e.g. file system overhead and block size padding.
  //
  // If unset there is no limit except file system failure.
  google.protobuf.UInt64Value max_cache_size_bytes = 3;

  // The maximum size of a cache entry in bytes - larger responses will not be cached.
  //
  // This is measured as the file size for the cache entry, such that it includes
  // headers, trailers, and metadata.
  //
  // If unset there is no limit.
  //
  // [#not-implemented-hide:]
  google.protobuf.UInt64Value max_individual_cache_entry_size_bytes = 4;

  // The maximum number of cache entries - when reached, cache eviction is triggered.
  //
  // If unset there is no limit.
  google.protobuf.UInt64Value max_cache_entry_count = 5;

  // A number of folders into which to subdivide the cache.
  //
  // Setting this can help with performance in file systems where a large number of inodes
  // in a single branch degrades performance. The optimal value in that case would be
  // ``sqrt(expected_cache_entry_count)``.
  //
  // On file systems that perform well with many inodes, the default value of 1 should be used.
  //
  // [#not-implemented-hide:]
  uint32 cache_subdivisions = 6;

  // The amount of the maximum cache size or count to evict when cache eviction is
  // triggered. For example, if ``max_cache_size_bytes`` is 10000000 and ``evict_fraction``
  // is 0.2, then when the cache exceeds 10MB, entries will be evicted until the cache size is
  // less than or equal to 8MB.
  //
  // The default value of 0 means when the cache exceeds 10MB, entries will be evicted only
  // until the cache is less than or equal to 10MB.
  //
  // Evicting a larger fraction will mean the eviction thread will run less often (sparing
  // CPU load) at the cost of more cache misses due to the extra evicted entries.
  //
  // [#not-implemented-hide:]
  float evict_fraction = 7;

  // The longest amount of time to wait before running a cache eviction pass. An eviction
  // pass may not necessarily remove any files, but it will update the cache state to match
  // the on-disk state. This can be important if multiple instances are accessing the same
  // cache in parallel. (e.g. if two instances each independently added non-overlapping 10MB
  // of content to a cache with a 15MB limit, neither instance would be aware that the limit
  // was exceeded without this synchronizing pass.)
  //
  // If an eviction pass has not happened within this duration, the eviction thread will
  // be awoken and perform an eviction pass.
  //
  // If unset, there will be no eviction passes except those triggered by cache limits.
  //
  // [#not-implemented-hide:]
  google.protobuf.Duration max_eviction_period = 8;

  // The shortest amount of time between cache eviction passes. This can be used to reduce
  // eviction churn, if your cache max size can be flexible. If a cache eviction pass already
  // occurred more recently than this period when another would be triggered, that new
  // pass is cancelled.
  //
  // This means the cache can potentially grow beyond ``max_cache_size_bytes`` by as much as
  // can be written within the duration specified.
  //
  // Generally you would use *either* ``min_eviction_period`` *or* ``evict_fraction`` to
  // reduce churn. Both together will work but since they're both aiming for the same goal,
  // it's simpler not to.
  //
  // [#not-implemented-hide:]
  google.protobuf.Duration min_eviction_period = 9;

  // If true, and the cache path does not exist, attempt to create the cache path, including
  // any missing directories leading up to it. On failure, the config is rejected.
  //
  // If false, and the cache path does not exist, the config is rejected.
  //
  // [#not-implemented-hide:]
  bool create_cache_path = 10;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.http.cache.simple_http_cache.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.http.cache.simple_http_cache.v3";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/http/cache/simple_http_cache/v3;simple_http_cachev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: SimpleHttpCache CacheFilter storage plugin]

// [#extension: envoy.extensions.http.cache.simple]
message SimpleHttpCacheConfig {
}
syntax = "proto3";

package envoy.extensions.http.early_header_mutation.header_mutation.v3;

import "envoy/config/common/mutation_rules/v3/mutation_rules.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.http.early_header_mutation.header_mutation.v3";
option java_outer_classname = "HeaderMutationProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/http/early_header_mutation/header_mutation/v3;header_mutationv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Default early header mutation extension]
// [#extension: envoy.http.early_header_mutation.header_mutation]

// This extension allows for early header mutation by the substitution formatter.
message HeaderMutation {
  repeated config.common.mutation_rules.v3.HeaderMutation mutations = 1
      [(validate.rules).repeated = {min_items: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/common/mutation_rules/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.http.header_validators.envoy_default.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.http.header_validators.envoy_default.v3";
option java_outer_classname = "HeaderValidatorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/http/header_validators/envoy_default/v3;envoy_defaultv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Envoy's default Header Validator config]

// This extension validates that HTTP request and response headers are well formed according to respective RFCs.
//
// #. HTTP/1 header map validity according to `RFC 7230 section 3.2 <https://datatracker.ietf.org/doc/html/rfc7230#section-3.2>`_
// #. Syntax of HTTP/1 request target URI and response status
// #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2 <https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2>`_
// #. Syntax of HTTP/2 pseudo headers
// #. HTTP/3 header map validity according to `RFC 9114 section 4.3  <https://www.rfc-editor.org/rfc/rfc9114.html>`_
// #. Syntax of HTTP/3 pseudo headers
// #. Syntax of Content-Length and Transfer-Encoding
// #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
// #. Normalization of the URI path according to `Normalization and Comparison <https://datatracker.ietf.org/doc/html/rfc3986#section-6>`_
//    without `case normalization <https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1>`_
//
// [#comment:TODO(yanavlasov): Put #extension: envoy.http.header_validators.envoy_default after it is not hidden any more]
// [#next-free-field: 6]
message HeaderValidatorConfig {
  // Action to take when Envoy receives client request with header names containing underscore
  // characters.
  // Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
  // as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
  // characters.
  enum HeadersWithUnderscoresAction {
    // Allow headers with underscores. This is the default behavior.
    ALLOW = 0;

    // Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
    // end with the stream reset. The
    // :ref:`httpN.requests_rejected_with_underscores_in_headers <config_http_conn_man_stats_per_codec>` counter
    // is incremented for each rejected request.
    REJECT_REQUEST = 1;

    // Drop the client header with name containing underscores. The header is dropped before the filter chain is
    // invoked and as such filters will not see dropped headers. The
    // :ref:`httpN.dropped_headers_with_underscores <config_http_conn_man_stats_per_codec>` is incremented for
    // each dropped header.
    DROP_HEADER = 2;
  }

  message UriPathNormalizationOptions {
    // Determines the action for requests that contain ``%2F``, ``%2f``, ``%5C`` or ``%5c`` sequences in the URI path.
    // This operation occurs before URL normalization and the merge slashes transformations if they were enabled.
    enum PathWithEscapedSlashesAction {
      // Default behavior specific to implementation (i.e. Envoy) of this configuration option.
      // Envoy, by default, takes the ``KEEP_UNCHANGED`` action.
      // NOTE: the implementation may change the default behavior at-will.
      IMPLEMENTATION_SPECIFIC_DEFAULT = 0;

      // Keep escaped slashes.
      KEEP_UNCHANGED = 1;

      // Reject client request with the 400 status. gRPC requests will be rejected with the ``INTERNAL`` (13) error code.
      // The ``http#.downstream_rq_failed_path_normalization`` counter is incremented for each rejected request.
      REJECT_REQUEST = 2;

      // Unescape ``%2F`` and ``%5C`` sequences and redirect the request to the new path if these sequences were present.
      // The redirect occurs after path normalization and merge slashes transformations if they were configured.
      // NOTE: gRPC requests will be rejected with the ``INTERNAL`` (13) error code.
      // This option minimizes possibility of path confusion exploits by forcing request with unescaped slashes to
      // traverse all parties: downstream client, intermediate proxies, Envoy and upstream server.
      // The ``http#.downstream_rq_redirected_with_normalized_path`` counter is incremented for each
      // redirected request.
      UNESCAPE_AND_REDIRECT = 3;

      // Unescape ``%2F`` and ``%5C`` sequences.
      // Note: this option should not be enabled if intermediaries perform path based access control as
      // it may lead to path confusion vulnerabilities.
      UNESCAPE_AND_FORWARD = 4;
    }

    // Should paths be normalized according to RFC 3986?
    // This operation overwrites the original request URI path and the new path is used for processing of
    // the request by HTTP filters and proxied to the upstream service.
    // Envoy will respond with 400 to requests with malformed paths that fail path normalization.
    // The default behavior is to normalize the path.
    // This value may be overridden by the runtime variable
    // :ref:`http_connection_manager.normalize_path<config_http_conn_man_runtime_normalize_path>`.
    // See `Normalization and Comparison <https://datatracker.ietf.org/doc/html/rfc3986#section-6>`_
    // for details of normalization.
    // Note that Envoy does not perform
    // `case normalization <https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1>`_
    // URI path normalization can be applied to a portion of requests by setting the
    // ``envoy_default_header_validator.path_normalization`` runtime value.
    bool skip_path_normalization = 1;

    // Determines if adjacent slashes in the path are merged into one.
    // This operation overwrites the original request URI path and the new path is used for processing of
    // the request by HTTP filters and proxied to the upstream service.
    // Setting this option to true will cause incoming requests with path ``//dir///file`` to not match against
    // route with ``prefix`` match set to ``/dir``. Defaults to ``false``. Note that slash merging is not part of
    // `HTTP spec <https://datatracker.ietf.org/doc/html/rfc3986>`_ and is provided for convenience.
    // Merging of slashes in URI path can be applied to a portion of requests by setting the
    // ``envoy_default_header_validator.merge_slashes`` runtime value.
    bool skip_merging_slashes = 2;

    // The action to take when request URL path contains escaped slash sequences (``%2F``, ``%2f``, ``%5C`` and ``%5c``).
    // This operation may overwrite the original request URI path and the new path is used for processing of
    // the request by HTTP filters and proxied to the upstream service.
    PathWithEscapedSlashesAction path_with_escaped_slashes_action = 3
        [(validate.rules).enum = {defined_only: true}];
  }

  message Http1ProtocolOptions {
    // Allows Envoy to process HTTP/1 requests/responses with both ``Content-Length`` and ``Transfer-Encoding``
    // headers set. By default such messages are rejected, but if option is enabled - Envoy will
    // remove the ``Content-Length`` header and process the message.
    // See `RFC7230, sec. 3.3.3 <https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.3>`_ for details.
    //
    // .. attention::
    //   Enabling this option might lead to request smuggling vulnerabilities, especially if traffic
    //   is proxied via multiple layers of proxies.
    bool allow_chunked_length = 1;
  }

  Http1ProtocolOptions http1_protocol_options = 1;

  // The URI path normalization options.
  // By default Envoy normalizes URI path using the default values of the :ref:`UriPathNormalizationOptions
  // <envoy_v3_api_msg_extensions.http.header_validators.envoy_default.v3.HeaderValidatorConfig.UriPathNormalizationOptions>`.
  // URI path transformations specified by the ``uri_path_normalization_options`` configuration can be applied to a portion
  // of requests by setting the ``envoy_default_header_validator.uri_path_transformations`` runtime value.
  // Caution: disabling path normalization may lead to path confusion vulnerabilities in access control or incorrect service
  // selection.
  UriPathNormalizationOptions uri_path_normalization_options = 2;

  // Restrict HTTP methods to these defined in the `RFC 7231 section 4.1 <https://datatracker.ietf.org/doc/html/rfc7231#section-4.1>`_
  // Envoy will respond with 400 to requests with disallowed methods.
  // By default methods with arbitrary names are accepted.
  bool restrict_http_methods = 3;

  // Action to take when a client request with a header name containing underscore characters is received.
  // If this setting is not specified, the value defaults to ALLOW.
  HeadersWithUnderscoresAction headers_with_underscores_action = 4;

  // Allow requests with fragment in URL path and strip the fragment before request processing.
  // By default Envoy rejects requests with fragment in URL path.
  bool strip_fragment_from_path = 5;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.http.original_ip_detection.xff.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.http.original_ip_detection.xff.v3";
option java_outer_classname = "XffProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/http/original_ip_detection/xff/v3;xffv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: XFF original IP detection extension]

// This extension allows for the original downstream remote IP to be detected
// by reading the :ref:`config_http_conn_man_headers_x-forwarded-for` header.
//
// [#extension: envoy.http.original_ip_detection.xff]
message XffConfig {
  // The number of additional ingress proxy hops from the right side of the
  // :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
  // determining the origin client's IP address. The default is zero if this option
  // is not specified. See the documentation for
  // :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
  uint32 xff_num_trusted_hops = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.http.original_ip_detection.custom_header.v3;

import "envoy/type/v3/http_status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.http.original_ip_detection.custom_header.v3";
option java_outer_classname = "CustomHeaderProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/http/original_ip_detection/custom_header/v3;custom_headerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Custom header original IP detection extension]

// This extension allows for the original downstream remote IP to be detected
// by reading the value from a configured header name. If the value is successfully parsed
// as an IP, it'll be treated as the effective downstream remote address and seen as such
// by all filters. See :ref:`original_ip_detection_extensions
// <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.original_ip_detection_extensions>`
// for an overview of how extensions operate and what happens when an extension fails
// to detect the remote IP.
//
// [#extension: envoy.http.original_ip_detection.custom_header]
message CustomHeaderConfig {
  // The header name containing the original downstream remote address, if present.
  //
  // Note: in the case of a multi-valued header, only the first value is tried and the rest are ignored.
  string header_name = 1
      [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: true}];

  // If set to true, the extension could decide that the detected address should be treated as
  // trusted by the HCM. If the address is considered :ref:`trusted<config_http_conn_man_headers_x-forwarded-for_trusted_client_address>`,
  // it might be used as input to determine if the request is internal (among other things).
  bool allow_extension_to_set_address_as_trusted = 2;

  // If this is set, the request will be rejected when detection fails using it as the HTTP response status.
  //
  // .. note::
  //   If this is set to < 400 or > 511, the default status 403 will be used instead.
  type.v3.HttpStatus reject_with_status = 3;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.http.header_formatters.preserve_case.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.http.header_formatters.preserve_case.v3";
option java_outer_classname = "PreserveCaseProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/http/header_formatters/preserve_case/v3;preserve_casev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Preserve case header formatter]
// [#extension: envoy.http.stateful_header_formatters.preserve_case]

// Configuration for the preserve case header formatter.
// See the :ref:`header casing <config_http_conn_man_header_casing>` configuration guide for more
// information.
message PreserveCaseFormatterConfig {
  enum FormatterTypeOnEnvoyHeaders {
    // Use LowerCase on Envoy added headers.
    DEFAULT = 0;

    // Use ProperCaseHeaderKeyFormatter on Envoy added headers that upper cases the first character
    // in each word. The first character as well as any alpha character following a special
    // character is upper cased.
    PROPER_CASE = 1;
  }

  // Allows forwarding reason phrase text.
  // This is off by default, and a standard reason phrase is used for a corresponding HTTP response code.
  bool forward_reason_phrase = 1;

  // Type of formatter to use on headers which are added by Envoy (which are lower case by default).
  // The default type is DEFAULT, use LowerCase on Envoy headers.
  FormatterTypeOnEnvoyHeaders formatter_type_on_envoy_headers = 2
      [(validate.rules).enum = {defined_only: true}];
}
syntax = "proto3";

package envoy.extensions.http.custom_response.local_response_policy.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/substitution_format_string.proto";

import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.http.custom_response.local_response_policy.v3";
option java_outer_classname = "LocalResponsePolicyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/http/custom_response/local_response_policy/v3;local_response_policyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: Local Response Policy for Custom Response]
// [#extension: envoy.http.custom_response.local_response_policy]

// Custom response policy to serve a locally stored response to the
// downstream.
message LocalResponsePolicy {
  // Optional new local reply body text. It will be used
  // in the ``%LOCAL_REPLY_BODY%`` command operator in the ``body_format``.
  config.core.v3.DataSource body = 1;

  // Optional body format to be used for this response. If ``body_format`` is  not
  // provided, and ``body`` is, the contents of ``body`` will be used to populate
  // the body of the local reply without formatting.
  config.core.v3.SubstitutionFormatString body_format = 2;

  // The new response status code if specified.
  google.protobuf.UInt32Value status_code = 3 [(validate.rules).uint32 = {lt: 600 gte: 200}];

  // HTTP headers to add to the response. This allows the
  // response policy to append, to add or to override headers of
  // the original response for local body, or the custom response from the
  // remote body, before it is sent to a downstream client.
  repeated config.core.v3.HeaderValueOption response_headers_to_add = 4
      [(validate.rules).repeated = {max_items: 1000}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.http.custom_response.redirect_policy.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/config/route/v3/route_components.proto";

import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.http.custom_response.redirect_policy.v3";
option java_outer_classname = "RedirectPolicyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/http/custom_response/redirect_policy/v3;redirect_policyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: Redirect Policy for Custom Response]
// [#extension: envoy.http.custom_response.redirect_policy]

// Custom response policy to internally redirect the original response to a different
// upstream.
// [#next-free-field: 7]
message RedirectPolicy {
  oneof redirect_action_specifier {
    option (validate.required) = true;

    // The Http URI to redirect the original request to, to get the custom
    // response.
    // It should be a full FQDN with protocol, host and path.
    //
    // Example:
    //
    // .. code-block:: yaml
    //
    //    uri: https://www.mydomain.com/path/to/404.txt
    //
    string uri = 1 [(validate.rules).string = {min_len: 1}];

    // Specify elements of the redirect url individually.
    // Note: Do not specify the ``response_code`` field in ``redirect_action``, use
    // ``status_code`` instead.
    // The following fields in ``redirect_action`` are currently not supported,
    // and specifying them will cause the config to be rejected:
    // - ``prefix_rewrite``
    // - ``regex_rewrite``
    config.route.v3.RedirectAction redirect_action = 2;
  }

  // The new response status code if specified. This is used to override the
  // status code of the response from the new upstream if it is not an error status.
  google.protobuf.UInt32Value status_code = 3 [(validate.rules).uint32 = {lte: 999 gte: 100}];

  // HTTP headers to add to the response. This allows the
  // response policy to append, to add or to override headers of
  // the original response for local body, or the custom response from the
  // remote body, before it is sent to a downstream client.
  // Note that these are not applied if the redirected response is an error
  // response.
  repeated config.core.v3.HeaderValueOption response_headers_to_add = 4
      [(validate.rules).repeated = {max_items: 1000}];

  // HTTP headers to add to the request before it is internally redirected.
  repeated config.core.v3.HeaderValueOption request_headers_to_add = 5
      [(validate.rules).repeated = {max_items: 1000}];

  // Custom action to modify request headers before selection of the
  // redirected route.
  // [#comment: TODO(pradeepcrao) add an extension category.]
  config.core.v3.TypedExtensionConfig modify_request_headers_action = 6;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/config/route/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.http.stateful_session.cookie.v3;

import "envoy/type/http/v3/cookie.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.http.stateful_session.cookie.v3";
option java_outer_classname = "CookieProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/http/stateful_session/cookie/v3;cookiev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Cookie based stateful session extension]

// This extension allows the session state to be tracked via cookies.
//
// This extension first encodes the address of the upstream host selected by the load balancer
// into a ``set-cookie`` response header with the :ref:`cookie configuration
// <envoy_v3_api_field_extensions.http.stateful_session.cookie.v3.CookieBasedSessionState.cookie>`.
// when new requests are incoming, this extension will try to parse the specific upstream host
// address by the cookie name. If the address parsed from the cookie corresponds to a valid
// upstream host, this upstream host will be selected first. See :ref:`stateful session filter
// <envoy_v3_api_msg_extensions.filters.http.stateful_session.v3.StatefulSession>`.
//
// For example, if the cookie name is set to ``sticky-host``, envoy will prefer ``1.2.3.4:80``
// as the upstream host when the request contains the following header:
//
// .. code-block:: none
//
//     cookie: sticky-host="MS4yLjMuNDo4MA=="
//
// When processing the upstream response, if ``1.2.3.4:80`` is indeed the final choice the extension
// does nothing. If ``1.2.3.4:80`` is not the final choice, the new selected host will be used to
// update the cookie (via the ``set-cookie`` response header).
//
// [#extension: envoy.http.stateful_session.cookie]
message CookieBasedSessionState {
  // The cookie configuration used to track session state.
  type.http.v3.Cookie cookie = 1 [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/type/http/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.http.stateful_session.header.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.http.stateful_session.header.v3";
option java_outer_classname = "HeaderProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/http/stateful_session/header/v3;headerv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Header based stateful session extension]

// This extension allows the session state to be tracked via request headers.
//
// This extension encodes the address of the upstream host selected by the load balancer
// into a response header with the :ref:`header configuration
// <envoy_v3_api_msg_extensions.http.stateful_session.header.v3.HeaderBasedSessionState>`.
// When new requests are incoming, this extension will try to parse the specific upstream host
// address by header name. If the address parsed from the header corresponds to a valid
// upstream host, this upstream host will be selected first. See :ref:`stateful session filter
// <envoy_v3_api_msg_extensions.filters.http.stateful_session.v3.StatefulSession>`.
//
// For example, if the header name is set to ``session-header``, Envoy will prefer ``1.2.3.4:80``
// as the upstream host when the request contains the following header:
//
// .. code-block:: none
//
//     session-header: "MS4yLjMuNDo4MA=="
//
// When processing the upstream response, if ``1.2.3.4:80`` is indeed the final choice the extension
// does nothing. If ``1.2.3.4:80`` is not the final choice, the new selected host will be set to
// response headers (via the ``session-header`` response header).
//
// [#extension: envoy.http.stateful_session.header]
message HeaderBasedSessionState {
  // The name that will be used to obtain header value from downstream HTTP request or generate
  // new header for downstream.
  string name = 1 [(validate.rules).string = {min_len: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.upstreams.tcp.v3;

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.upstreams.tcp.v3";
option java_outer_classname = "TcpProtocolOptionsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/upstreams/tcp/v3;tcpv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: TCP Protocol Options]
// [#extension: envoy.upstreams.tcp.tcp_protocol_options]

// TCProtocolOptions specifies TCP upstream protocol options. This object
// is used in
// :ref:`typed_extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`,
// keyed by the name ``envoy.extensions.upstreams.tcp.v3.TcpProtocolOptions``.
//
// .. code::
//
//   clusters:
//     - name: some_service
//       connect_timeout: 5s
//       typed_extension_protocol_options:
//         envoy.extensions.upstreams.tcp.v3.TcpProtocolOptions:
//           "@type": type.googleapis.com/envoy.extensions.upstreams.tcp.v3.TcpProtocolOptions
//           idle_timeout: 10m
//        .... [further cluster config]

message TcpProtocolOptions {
  // The idle timeout for the connection. The idle timeout is defined as the period in which
  // the connection is not associated with a downstream connection. When the idle timeout is
  // reached, the connection will be closed.
  //
  // If not set, the default idle timeout is 10 minutes. To disable idle timeouts, explicitly set this to 0.
  //
  // .. warning::
  //   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
  //   FIN packets, etc.
  google.protobuf.Duration idle_timeout = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.upstreams.tcp.generic.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.upstreams.tcp.generic.v3";
option java_outer_classname = "GenericConnectionPoolProtoOuterClass";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/upstreams/tcp/generic/v3;genericv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Generic Connection Pool]

// A connection pool which forwards downstream TCP as TCP or HTTP to upstream,
// based on CONNECT configuration.
// [#extension: envoy.upstreams.tcp.generic]
message GenericConnectionPoolProto {
}
syntax = "proto3";

package envoy.extensions.upstreams.http.udp.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.upstreams.http.udp.v3";
option java_outer_classname = "UdpConnectionPoolProtoOuterClass";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/upstreams/http/udp/v3;udpv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Udp Connection Pool]

// A connection pool which forwards downstream HTTP as UDP to upstream,
// [#extension: envoy.upstreams.http.udp]
message UdpConnectionPoolProto {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.upstreams.http.tcp.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.upstreams.http.tcp.v3";
option java_outer_classname = "TcpConnectionPoolProtoOuterClass";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/upstreams/http/tcp/v3;tcpv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Tcp Connection Pool]

// A connection pool which forwards downstream HTTP as TCP to upstream,
// [#extension: envoy.upstreams.http.tcp]
message TcpConnectionPoolProto {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.upstreams.http.v3;

import "envoy/config/core/v3/extension.proto";
import "envoy/config/core/v3/protocol.proto";
import "envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.upstreams.http.v3";
option java_outer_classname = "HttpProtocolOptionsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/upstreams/http/v3;httpv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP Protocol Options]
// [#extension: envoy.upstreams.http.http_protocol_options]

// HttpProtocolOptions specifies Http upstream protocol options. This object
// is used in
// :ref:`typed_extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`,
// keyed by the name ``envoy.extensions.upstreams.http.v3.HttpProtocolOptions``.
//
// This controls what protocol(s) should be used for upstream and how said protocol(s) are configured.
//
// This replaces the prior pattern of explicit protocol configuration directly
// in the cluster. So a configuration like this, explicitly configuring the use of HTTP/2 upstream:
//
// .. code::
//
//   clusters:
//     - name: some_service
//       connect_timeout: 5s
//       upstream_http_protocol_options:
//         auto_sni: true
//       common_http_protocol_options:
//         idle_timeout: 1s
//       http2_protocol_options:
//         max_concurrent_streams: 100
//        .... [further cluster config]
//
// Would now look like this:
//
// .. code::
//
//   clusters:
//     - name: some_service
//       connect_timeout: 5s
//       typed_extension_protocol_options:
//         envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
//           "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
//           upstream_http_protocol_options:
//             auto_sni: true
//           common_http_protocol_options:
//             idle_timeout: 1s
//           explicit_http_config:
//             http2_protocol_options:
//               max_concurrent_streams: 100
//        .... [further cluster config]
// [#next-free-field: 8]
message HttpProtocolOptions {
  // If this is used, the cluster will only operate on one of the possible upstream protocols.
  // Note that HTTP/2 or above should generally be used for upstream gRPC clusters.
  message ExplicitHttpConfig {
    oneof protocol_config {
      option (validate.required) = true;

      config.core.v3.Http1ProtocolOptions http_protocol_options = 1;

      config.core.v3.Http2ProtocolOptions http2_protocol_options = 2;

      // .. warning::
      //   QUIC upstream support is currently not ready for internet use.
      //   Please see :ref:`here <arch_overview_http3>` for details.
      config.core.v3.Http3ProtocolOptions http3_protocol_options = 3;
    }
  }

  // If this is used, the cluster can use either of the configured protocols, and
  // will use whichever protocol was used by the downstream connection.
  //
  // If HTTP/3 is configured for downstream and not configured for upstream,
  // HTTP/3 requests will fail over to HTTP/2.
  message UseDownstreamHttpConfig {
    config.core.v3.Http1ProtocolOptions http_protocol_options = 1;

    config.core.v3.Http2ProtocolOptions http2_protocol_options = 2;

    // .. warning::
    //   QUIC upstream support is currently not ready for internet use.
    //   Please see :ref:`here <arch_overview_http3>` for details.
    config.core.v3.Http3ProtocolOptions http3_protocol_options = 3;
  }

  // If this is used, the cluster can use either HTTP/1 or HTTP/2, and will use whichever
  // protocol is negotiated by ALPN with the upstream.
  // Clusters configured with ``AutoHttpConfig`` will use the highest available
  // protocol; HTTP/2 if supported, otherwise HTTP/1.
  // If the upstream does not support ALPN, ``AutoHttpConfig`` will fail over to HTTP/1.
  // This can only be used with transport sockets which support ALPN. Using a
  // transport socket which does not support ALPN will result in configuration
  // failure. The transport layer may be configured with custom ALPN, but the default ALPN
  // for the cluster (or if custom ALPN fails) will be "h2,http/1.1".
  message AutoHttpConfig {
    config.core.v3.Http1ProtocolOptions http_protocol_options = 1;

    config.core.v3.Http2ProtocolOptions http2_protocol_options = 2;

    // Unlike HTTP/1 and HTTP/2, HTTP/3 will not be configured unless it is
    // present, and (soon) only if there is an indication of server side
    // support.
    // See :ref:`here <arch_overview_http3_upstream>` for more information on
    // when HTTP/3 will be used, and when Envoy will fail over to TCP.
    //
    // .. warning::
    //   QUIC upstream support is currently not ready for internet use.
    //   Please see :ref:`here <arch_overview_http3>` for details.
    config.core.v3.Http3ProtocolOptions http3_protocol_options = 3;

    // The presence of alternate protocols cache options causes the use of the
    // alternate protocols cache, which is responsible for parsing and caching
    // HTTP Alt-Svc headers. This enables the use of HTTP/3 for origins that
    // advertise supporting it.
    //
    // .. note::
    //   This is required when HTTP/3 is enabled.
    config.core.v3.AlternateProtocolsCacheOptions alternate_protocols_cache_options = 4;
  }

  // This contains options common across HTTP/1 and HTTP/2
  config.core.v3.HttpProtocolOptions common_http_protocol_options = 1;

  // This contains common protocol options which are only applied upstream.
  config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 2;

  // This controls the actual protocol to be used upstream.
  oneof upstream_protocol_options {
    option (validate.required) = true;

    // To explicitly configure either HTTP/1 or HTTP/2 (but not both!) use ``explicit_http_config``.
    // If the ``explicit_http_config`` is empty, HTTP/1.1 is used.
    ExplicitHttpConfig explicit_http_config = 3;

    // This allows switching on protocol based on what protocol the downstream
    // connection used.
    UseDownstreamHttpConfig use_downstream_protocol_config = 4;

    // This allows switching on protocol based on ALPN
    AutoHttpConfig auto_config = 5;
  }

  // .. note::
  //   Upstream HTTP filters are currently in alpha.
  //
  // Optional HTTP filters for the upstream HTTP filter chain.
  //
  // These filters will be applied for all HTTP streams which flow through this
  // cluster. Unlike downstream HTTP filters, they will *not* be applied to terminated CONNECT requests.
  //
  // If using upstream HTTP filters, please be aware that local errors sent by
  // upstream HTTP filters will not trigger retries, and local errors sent by
  // upstream HTTP filters will count as a final response if hedging is configured.
  // [#extension-category: envoy.filters.http.upstream]
  repeated filters.network.http_connection_manager.v3.HttpFilter http_filters = 6;

  // Configuration options for Unified Header Validation (UHV).
  // UHV is an extensible mechanism for checking validity of HTTP responses.
  //
  // [#comment:TODO(yanavlasov): Make it a link to the default header validator doc when it becomes visible.]
  // Leaving this field unspecified, selects the default header validator ``envoy.http.header_validators.envoy_default``.
  //
  // [#not-implemented-hide:]
  // [#extension-category: envoy.http.header_validators]
  config.core.v3.TypedExtensionConfig header_validation_config = 7;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/extensions/filters/network/http_connection_manager/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.upstreams.http.http.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.upstreams.http.http.v3";
option java_outer_classname = "HttpConnectionPoolProtoOuterClass";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/upstreams/http/http/v3;httpv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Http Connection Pool]

// A connection pool which forwards downstream HTTP as HTTP to upstream.
// [#extension: envoy.upstreams.http.http]
message HttpConnectionPoolProto {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.upstreams.http.generic.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.upstreams.http.generic.v3";
option java_outer_classname = "GenericConnectionPoolProtoOuterClass";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/upstreams/http/generic/v3;genericv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Generic Connection Pool]

// A connection pool which forwards downstream HTTP as TCP, UDP or HTTP to upstream,
// based on CONNECT configuration.
// [#extension: envoy.upstreams.http.generic]
message GenericConnectionPoolProto {
}
syntax = "proto3";

package envoy.extensions.compression.brotli.decompressor.v3;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.compression.brotli.decompressor.v3";
option java_outer_classname = "BrotliProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/compression/brotli/decompressor/v3;decompressorv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Brotli Decompressor]
// [#extension: envoy.compression.brotli.decompressor]

message Brotli {
  // If true, disables "canny" ring buffer allocation strategy.
  // Ring buffer is allocated according to window size, despite the real size of the content.
  bool disable_ring_buffer_reallocation = 1;

  // Value for decompressor's next output buffer. If not set, defaults to 4096.
  google.protobuf.UInt32Value chunk_size = 2 [(validate.rules).uint32 = {lte: 65536 gte: 4096}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.compression.brotli.compressor.v3;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.compression.brotli.compressor.v3";
option java_outer_classname = "BrotliProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/compression/brotli/compressor/v3;compressorv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Brotli Compressor]
// [#extension: envoy.compression.brotli.compressor]

// [#next-free-field: 7]
message Brotli {
  enum EncoderMode {
    DEFAULT = 0;
    GENERIC = 1;
    TEXT = 2;
    FONT = 3;
  }

  // Value from 0 to 11 that controls the main compression speed-density lever.
  // The higher quality, the slower compression. The default value is 3.
  google.protobuf.UInt32Value quality = 1 [(validate.rules).uint32 = {lte: 11}];

  // A value used to tune encoder for specific input. For more information about modes,
  // please refer to brotli manual: https://brotli.org/encode.html#aa6f
  // This field will be set to "DEFAULT" if not specified.
  EncoderMode encoder_mode = 2 [(validate.rules).enum = {defined_only: true}];

  // Value from 10 to 24 that represents the base two logarithmic of the compressor's window size.
  // Larger window results in better compression at the expense of memory usage. The default is 18.
  // For more details about this parameter, please refer to brotli manual:
  // https://brotli.org/encode.html#a9a8
  google.protobuf.UInt32Value window_bits = 3 [(validate.rules).uint32 = {lte: 24 gte: 10}];

  // Value from 16 to 24 that represents the base two logarithmic of the compressor's input block
  // size. Larger input block results in better compression at the expense of memory usage. The
  // default is 24. For more details about this parameter, please refer to brotli manual:
  // https://brotli.org/encode.html#a9a8
  google.protobuf.UInt32Value input_block_bits = 4 [(validate.rules).uint32 = {lte: 24 gte: 16}];

  // Value for compressor's next output buffer. If not set, defaults to 4096.
  google.protobuf.UInt32Value chunk_size = 5 [(validate.rules).uint32 = {lte: 65536 gte: 4096}];

  // If true, disables "literal context modeling" format feature.
  // This flag is a "decoding-speed vs compression ratio" trade-off.
  bool disable_literal_context_modeling = 6;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.compression.gzip.decompressor.v3;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.compression.gzip.decompressor.v3";
option java_outer_classname = "GzipProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/compression/gzip/decompressor/v3;decompressorv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Gzip Decompressor]
// [#extension: envoy.compression.gzip.decompressor]

message Gzip {
  // Value from 9 to 15 that represents the base two logarithmic of the decompressor's window size.
  // The decompression window size needs to be equal or larger than the compression window size.
  // The default window size is 15.
  // This is so that the decompressor can decompress a response compressed by a compressor with any compression window size.
  // For more details about this parameter, please refer to `zlib manual <https://www.zlib.net/manual.html>`_ > inflateInit2.
  google.protobuf.UInt32Value window_bits = 1 [(validate.rules).uint32 = {lte: 15 gte: 9}];

  // Value for zlib's decompressor output buffer. If not set, defaults to 4096.
  // See https://www.zlib.net/manual.html for more details.
  google.protobuf.UInt32Value chunk_size = 2 [(validate.rules).uint32 = {lte: 65536 gte: 4096}];

  // An upper bound to the number of times the output buffer is allowed to be bigger than the size of
  // the accumulated input. This value is used to prevent decompression bombs. If not set, defaults to 100.
  // [#comment:TODO(rojkov): Re-design the Decompressor interface to handle compression bombs gracefully instead of this quick solution.
  // See https://github.com/envoyproxy/envoy/commit/d4c39e635603e2f23e1e08ddecf5a5fb5a706338 for details.]
  google.protobuf.UInt32Value max_inflate_ratio = 3 [(validate.rules).uint32 = {lte: 1032 gte: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.compression.gzip.compressor.v3;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.compression.gzip.compressor.v3";
option java_outer_classname = "GzipProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/compression/gzip/compressor/v3;compressorv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Gzip Compressor]
// [#extension: envoy.compression.gzip.compressor]

// [#next-free-field: 6]
message Gzip {
  // All the values of this enumeration translate directly to zlib's compression strategies.
  // For more information about each strategy, please refer to zlib manual.
  enum CompressionStrategy {
    DEFAULT_STRATEGY = 0;
    FILTERED = 1;
    HUFFMAN_ONLY = 2;
    RLE = 3;
    FIXED = 4;
  }

  enum CompressionLevel {
    option allow_alias = true;

    DEFAULT_COMPRESSION = 0;
    BEST_SPEED = 1;
    COMPRESSION_LEVEL_1 = 1;
    COMPRESSION_LEVEL_2 = 2;
    COMPRESSION_LEVEL_3 = 3;
    COMPRESSION_LEVEL_4 = 4;
    COMPRESSION_LEVEL_5 = 5;
    COMPRESSION_LEVEL_6 = 6;
    COMPRESSION_LEVEL_7 = 7;
    COMPRESSION_LEVEL_8 = 8;
    COMPRESSION_LEVEL_9 = 9;
    BEST_COMPRESSION = 9;
  }

  // Value from 1 to 9 that controls the amount of internal memory used by zlib. Higher values
  // use more memory, but are faster and produce better compression results. The default value is 5.
  google.protobuf.UInt32Value memory_level = 1 [(validate.rules).uint32 = {lte: 9 gte: 1}];

  // A value used for selecting the zlib compression level. This setting will affect speed and
  // amount of compression applied to the content. "BEST_COMPRESSION" provides higher compression
  // at the cost of higher latency and is equal to "COMPRESSION_LEVEL_9". "BEST_SPEED" provides
  // lower compression with minimum impact on response time, the same as "COMPRESSION_LEVEL_1".
  // "DEFAULT_COMPRESSION" provides an optimal result between speed and compression. According
  // to zlib's manual this level gives the same result as "COMPRESSION_LEVEL_6".
  // This field will be set to "DEFAULT_COMPRESSION" if not specified.
  CompressionLevel compression_level = 2 [(validate.rules).enum = {defined_only: true}];

  // A value used for selecting the zlib compression strategy which is directly related to the
  // characteristics of the content. Most of the time "DEFAULT_STRATEGY" will be the best choice,
  // which is also the default value for the parameter, though there are situations when
  // changing this parameter might produce better results. For example, run-length encoding (RLE)
  // is typically used when the content is known for having sequences which same data occurs many
  // consecutive times. For more information about each strategy, please refer to zlib manual.
  CompressionStrategy compression_strategy = 3 [(validate.rules).enum = {defined_only: true}];

  // Value from 9 to 15 that represents the base two logarithmic of the compressor's window size.
  // Larger window results in better compression at the expense of memory usage. The default is 12
  // which will produce a 4096 bytes window. For more details about this parameter, please refer to
  // zlib manual > deflateInit2.
  google.protobuf.UInt32Value window_bits = 4 [(validate.rules).uint32 = {lte: 15 gte: 9}];

  // Value for Zlib's next output buffer. If not set, defaults to 4096.
  // See https://www.zlib.net/manual.html for more details. Also see
  // https://github.com/envoyproxy/envoy/issues/8448 for context on this filter's performance.
  google.protobuf.UInt32Value chunk_size = 5 [(validate.rules).uint32 = {lte: 65536 gte: 4096}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.compression.zstd.decompressor.v3;

import "envoy/config/core/v3/base.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.compression.zstd.decompressor.v3";
option java_outer_classname = "ZstdProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/compression/zstd/decompressor/v3;decompressorv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Zstd Decompressor]
// [#extension: envoy.compression.zstd.decompressor]

message Zstd {
  // Dictionaries for decompression. Zstd offers dictionary compression, which greatly improves
  // efficiency on small files and messages. It is necessary to ensure that the dictionary used for
  // decompression is the same as the compression dictionary. Multiple dictionaries can be set, and the
  // dictionary will be automatically selected for decompression according to the dictionary ID in the
  // source content.
  // Please refer to `zstd manual <https://github.com/facebook/zstd/blob/dev/programs/zstd.1.md#dictionary-builder>`_
  // to train specific dictionaries for decompression.
  repeated config.core.v3.DataSource dictionaries = 1;

  // Value for decompressor's next output buffer. If not set, defaults to 4096.
  google.protobuf.UInt32Value chunk_size = 2 [(validate.rules).uint32 = {lte: 65536 gte: 4096}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.compression.zstd.compressor.v3;

import "envoy/config/core/v3/base.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.compression.zstd.compressor.v3";
option java_outer_classname = "ZstdProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/compression/zstd/compressor/v3;compressorv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Zstd Compressor]
// [#extension: envoy.compression.zstd.compressor]

// [#next-free-field: 6]
message Zstd {
  // Reference to http://facebook.github.io/zstd/zstd_manual.html
  enum Strategy {
    DEFAULT = 0;
    FAST = 1;
    DFAST = 2;
    GREEDY = 3;
    LAZY = 4;
    LAZY2 = 5;
    BTLAZY2 = 6;
    BTOPT = 7;
    BTULTRA = 8;
    BTULTRA2 = 9;
  }

  // Set compression parameters according to pre-defined compression level table.
  // Note that exact compression parameters are dynamically determined,
  // depending on both compression level and source content size (when known).
  // Value 0 means default, and default level is 3.
  // Setting a level does not automatically set all other compression parameters
  // to default. Setting this will however eventually dynamically impact the compression
  // parameters which have not been manually set. The manually set
  // ones will 'stick'.
  google.protobuf.UInt32Value compression_level = 1;

  // A 32-bits checksum of content is written at end of frame. If not set, defaults to false.
  bool enable_checksum = 2;

  // The higher the value of selected strategy, the more complex it is,
  // resulting in stronger and slower compression.
  // Special: value 0 means "use default strategy".
  Strategy strategy = 3 [(validate.rules).enum = {defined_only: true}];

  // A dictionary for compression. Zstd offers dictionary compression, which greatly improves
  // efficiency on small files and messages. Each dictionary will be generated with a dictionary ID
  // that can be used to search the same dictionary during decompression.
  // Please refer to `zstd manual <https://github.com/facebook/zstd/blob/dev/programs/zstd.1.md#dictionary-builder>`_
  // to train a specific dictionary for compression.
  config.core.v3.DataSource dictionary = 4;

  // Value for compressor's next output buffer. If not set, defaults to 4096.
  google.protobuf.UInt32Value chunk_size = 5 [(validate.rules).uint32 = {lte: 65536 gte: 4096}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_google_googleapis//google/api/expr/v1alpha1:syntax_proto",
    ],
)
syntax = "proto3";

package envoy.extensions.rate_limit_descriptors.expr.v3;

import "google/api/expr/v1alpha1/syntax.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.rate_limit_descriptors.expr.v3";
option java_outer_classname = "ExprProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/rate_limit_descriptors/expr/v3;exprv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Rate limit descriptor expression]
// [#extension: envoy.rate_limit_descriptors.expr]

// The following descriptor entry is appended with a value computed
// from a symbolic Common Expression Language expression.
// See :ref:`attributes <arch_overview_attributes>` for the set of
// available attributes.
//
// .. code-block:: cpp
//
//   ("<descriptor_key>", "<expression_value>")
message Descriptor {
  // The key to use in the descriptor entry.
  string descriptor_key = 1 [(validate.rules).string = {min_len: 1}];

  // If set to true, Envoy skips the descriptor if the expression evaluates to an error.
  // By default, the rate limit is not applied when an expression produces an error.
  bool skip_if_error = 2;

  oneof expr_specifier {
    // Expression in a text form, e.g. "connection.requested_server_name".
    string text = 3 [(validate.rules).string = {min_len: 1}];

    // Parsed expression in AST form.
    google.api.expr.v1alpha1.Expr parsed = 4;
  }
}
syntax = "proto3";

package envoy.extensions.transport_sockets.s2a.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.s2a.v3";
option java_outer_classname = "S2aProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/s2a/v3;s2av3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#not-implemented-hide:]
// Configuration for S2A transport socket. This allows Envoy clients to
// configure how to offload mTLS handshakes to the S2A service.
// https://github.com/google/s2a-go#readme
message S2AConfiguration {
  // The address of the S2A. This can be an IP address or a hostname,
  // followed by a port number.
  string s2a_address = 1 [(validate.rules).string = {min_len: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.transport_sockets.tap.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/extensions/common/tap/v3/common.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.tap.v3";
option java_outer_classname = "TapProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tap/v3;tapv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Tap]
// [#extension: envoy.transport_sockets.tap]

// Configuration for tap transport socket. This wraps another transport socket, providing the
// ability to interpose and record in plain text any traffic that is surfaced to Envoy.
message Tap {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.transport_socket.tap.v2alpha.Tap";

  // Common configuration for the tap transport socket.
  common.tap.v3.CommonExtensionConfig common_config = 1
      [(validate.rules).message = {required: true}];

  // The underlying transport socket being wrapped.
  config.core.v3.TransportSocket transport_socket = 2 [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/extensions/common/tap/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.transport_sockets.starttls.v3;

import "envoy/extensions/transport_sockets/raw_buffer/v3/raw_buffer.proto";
import "envoy/extensions/transport_sockets/tls/v3/tls.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.starttls.v3";
option java_outer_classname = "StarttlsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/starttls/v3;starttlsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: StartTls]
// [#extension: envoy.transport_sockets.starttls]

// StartTls transport socket addresses situations when a protocol starts in clear-text and
// negotiates an in-band switch to TLS. StartTls transport socket is protocol agnostic. In the
// case of downstream StartTls a network filter is required which understands protocol exchange
// and a state machine to signal to the StartTls transport socket when a switch to TLS is
// required. Similarly, upstream StartTls requires the owner of an upstream transport socket to
// manage the state machine necessary to properly coordinate negotiation with the upstream and
// signal to the transport socket when a switch to secure transport is required.

// Configuration for a downstream StartTls transport socket.
// StartTls transport socket wraps two sockets:
// * raw_buffer socket which is used at the beginning of the session
// * TLS socket used when a protocol negotiates a switch to encrypted traffic.
message StartTlsConfig {
  // (optional) Configuration for clear-text socket used at the beginning of the session.
  raw_buffer.v3.RawBuffer cleartext_socket_config = 1;

  // Configuration for a downstream TLS socket.
  transport_sockets.tls.v3.DownstreamTlsContext tls_socket_config = 2
      [(validate.rules).message = {required: true}];
}

// Configuration for an upstream StartTls transport socket.
// StartTls transport socket wraps two sockets:
// * raw_buffer socket which is used at the beginning of the session
// * TLS socket used when a protocol negotiates a switch to encrypted traffic.
message UpstreamStartTlsConfig {
  // (optional) Configuration for clear-text socket used at the beginning of the session.
  raw_buffer.v3.RawBuffer cleartext_socket_config = 1;

  // Configuration for an upstream TLS socket.
  transport_sockets.tls.v3.UpstreamTlsContext tls_socket_config = 2
      [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/transport_sockets/raw_buffer/v3:pkg",
        "//envoy/extensions/transport_sockets/tls/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.transport_sockets.tls.v3;

import "envoy/config/core/v3/address.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/extensions/transport_sockets/tls/v3/common.proto";
import "envoy/extensions/transport_sockets/tls/v3/secret.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.tls.v3";
option java_outer_classname = "TlsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3;tlsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: TLS transport socket]
// [#extension: envoy.transport_sockets.tls]
// The TLS contexts below provide the transport socket configuration for upstream/downstream TLS.

// [#next-free-field: 6]
message UpstreamTlsContext {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.auth.UpstreamTlsContext";

  // Common TLS context settings.
  //
  // .. attention::
  //
  //   Server certificate verification is not enabled by default. Configure
  //   :ref:`trusted_ca<envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>` to enable
  //   verification.
  CommonTlsContext common_tls_context = 1;

  // SNI string to use when creating TLS backend connections.
  string sni = 2 [(validate.rules).string = {max_bytes: 255}];

  // If true, server-initiated TLS renegotiation will be allowed.
  //
  // .. attention::
  //
  //   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
  bool allow_renegotiation = 3;

  // Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
  // for TLSv1.2 and older) to store for the purpose of session resumption.
  //
  // Defaults to 1, setting this to 0 disables session resumption.
  google.protobuf.UInt32Value max_session_keys = 4;

  // This field is used to control the enforcement, whereby the handshake will fail if the keyUsage extension
  // is present and incompatible with the TLS usage. Currently, the default value is false (i.e., enforcement off)
  // but it is expected to be changed to true by default in a future release.
  // ``ssl.was_key_usage_invalid`` in :ref:`listener metrics <config_listener_stats>` will be set for certificate
  // configurations that would fail if this option were set to true.
  google.protobuf.BoolValue enforce_rsa_key_usage = 5;
}

// [#next-free-field: 11]
message DownstreamTlsContext {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.auth.DownstreamTlsContext";

  enum OcspStaplePolicy {
    // OCSP responses are optional. If an OCSP response is absent
    // or expired, the associated certificate will be used for
    // connections without an OCSP staple.
    LENIENT_STAPLING = 0;

    // OCSP responses are optional. If an OCSP response is absent,
    // the associated certificate will be used without an
    // OCSP staple. If a response is provided but is expired,
    // the associated certificate will not be used for
    // subsequent connections. If no suitable certificate is found,
    // the connection is rejected.
    STRICT_STAPLING = 1;

    // OCSP responses are required. Configuration will fail if
    // a certificate is provided without an OCSP response. If a
    // response expires, the associated certificate will not be
    // used connections. If no suitable certificate is found, the
    // connection is rejected.
    MUST_STAPLE = 2;
  }

  // Common TLS context settings.
  CommonTlsContext common_tls_context = 1;

  // If specified, Envoy will reject connections without a valid client
  // certificate.
  google.protobuf.BoolValue require_client_certificate = 2;

  // If specified, Envoy will reject connections without a valid and matching SNI.
  // [#not-implemented-hide:]
  google.protobuf.BoolValue require_sni = 3;

  oneof session_ticket_keys_type {
    // TLS session ticket key settings.
    TlsSessionTicketKeys session_ticket_keys = 4;

    // Config for fetching TLS session ticket keys via SDS API.
    SdsSecretConfig session_ticket_keys_sds_secret_config = 5;

    // Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
    // server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
    // If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
    // the keys specified through either :ref:`session_ticket_keys <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
    // or :ref:`session_ticket_keys_sds_secret_config <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
    // If this config is set to false and no keys are explicitly configured, the TLS server will issue
    // TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
    // implication that sessions cannot be resumed across hot restarts or on different hosts.
    bool disable_stateless_session_resumption = 7;
  }

  // If set to true, the TLS server will not maintain a session cache of TLS sessions. (This is
  // relevant only for TLSv1.2 and earlier.)
  bool disable_stateful_session_resumption = 10;

  // If specified, ``session_timeout`` will change the maximum lifetime (in seconds) of the TLS session.
  // Currently this value is used as a hint for the `TLS session ticket lifetime (for TLSv1.2) <https://tools.ietf.org/html/rfc5077#section-5.6>`_.
  // Only seconds can be specified (fractional seconds are ignored).
  google.protobuf.Duration session_timeout = 6 [(validate.rules).duration = {
    lt {seconds: 4294967296}
    gte {}
  }];

  // Config for whether to use certificates if they do not have
  // an accompanying OCSP response or if the response expires at runtime.
  // Defaults to LENIENT_STAPLING
  OcspStaplePolicy ocsp_staple_policy = 8 [(validate.rules).enum = {defined_only: true}];

  // Multiple certificates are allowed in Downstream transport socket to serve different SNI.
  // If the client provides SNI but no such cert matched, it will decide to full scan certificates or not based on this config.
  // Defaults to false. See more details in :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>`.
  google.protobuf.BoolValue full_scan_certs_on_sni_mismatch = 9;
}

// TLS key log configuration.
// The key log file format is "format used by NSS for its SSLKEYLOGFILE debugging output" (text taken from openssl man page)
message TlsKeyLog {
  // The path to save the TLS key log.
  string path = 1 [(validate.rules).string = {min_len: 1}];

  // The local IP address that will be used to filter the connection which should save the TLS key log
  // If it is not set, any local IP address  will be matched.
  repeated config.core.v3.CidrRange local_address_range = 2;

  // The remote IP address that will be used to filter the connection which should save the TLS key log
  // If it is not set, any remote IP address will be matched.
  repeated config.core.v3.CidrRange remote_address_range = 3;
}

// TLS context shared by both client and server TLS contexts.
// [#next-free-field: 16]
message CommonTlsContext {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.auth.CommonTlsContext";

  // Config for Certificate provider to get certificates. This provider should allow certificates to be
  // fetched/refreshed over the network asynchronously with respect to the TLS handshake.
  //
  // DEPRECATED: This message is not currently used, but if we ever do need it, we will want to
  // move it out of CommonTlsContext and into common.proto, similar to the existing
  // CertificateProviderPluginInstance message.
  //
  // [#not-implemented-hide:]
  message CertificateProvider {
    // opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
    // a root-certificate (validation context) or "TLS" to specify a new tls-certificate.
    string name = 1 [(validate.rules).string = {min_len: 1}];

    // Provider specific config.
    // Note: an implementation is expected to dedup multiple instances of the same config
    // to maintain a single certificate-provider instance. The sharing can happen, for
    // example, among multiple clusters or between the tls_certificate and validation_context
    // certificate providers of a cluster.
    // This config could be supplied inline or (in future) a named xDS resource.
    oneof config {
      option (validate.required) = true;

      config.core.v3.TypedExtensionConfig typed_config = 2;
    }
  }

  // Similar to CertificateProvider above, but allows the provider instances to be configured on
  // the client side instead of being sent from the control plane.
  //
  // DEPRECATED: This message was moved outside of CommonTlsContext
  // and now lives in common.proto.
  //
  // [#not-implemented-hide:]
  message CertificateProviderInstance {
    // Provider instance name. This name must be defined in the client's configuration (e.g., a
    // bootstrap file) to correspond to a provider instance (i.e., the same data in the typed_config
    // field that would be sent in the CertificateProvider message if the config was sent by the
    // control plane). If not present, defaults to "default".
    //
    // Instance names should generally be defined not in terms of the underlying provider
    // implementation (e.g., "file_watcher") but rather in terms of the function of the
    // certificates (e.g., "foo_deployment_identity").
    string instance_name = 1;

    // Opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
    // a root-certificate (validation context) or "example.com" to specify a certificate for a
    // particular domain. Not all provider instances will actually use this field, so the value
    // defaults to the empty string.
    string certificate_name = 2;
  }

  message CombinedCertificateValidationContext {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext";

    // How to validate peer certificates.
    CertificateValidationContext default_validation_context = 1
        [(validate.rules).message = {required: true}];

    // Config for fetching validation context via SDS API. Note SDS API allows certificates to be
    // fetched/refreshed over the network asynchronously with respect to the TLS handshake.
    SdsSecretConfig validation_context_sds_secret_config = 2
        [(validate.rules).message = {required: true}];

    // Certificate provider for fetching CA certs. This will populate the
    // ``default_validation_context.trusted_ca`` field.
    // [#not-implemented-hide:]
    CertificateProvider validation_context_certificate_provider = 3
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

    // Certificate provider instance for fetching CA certs. This will populate the
    // ``default_validation_context.trusted_ca`` field.
    // [#not-implemented-hide:]
    CertificateProviderInstance validation_context_certificate_provider_instance = 4
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];
  }

  reserved 5;

  // TLS protocol versions, cipher suites etc.
  TlsParameters tls_params = 1;

  // Only a single TLS certificate is supported in client contexts. In server contexts,
  // :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>` can be associated with the
  // same context to allow both RSA and ECDSA certificates and support SNI-based selection.
  //
  // Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
  // and ``tls_certificate_provider_instance`` may be used.
  // [#next-major-version: These mutually exclusive fields should ideally be in a oneof, but it's
  // not legal to put a repeated field in a oneof. In the next major version, we should rework
  // this to avoid this problem.]
  repeated TlsCertificate tls_certificates = 2;

  // Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
  // fetched/refreshed over the network asynchronously with respect to the TLS handshake.
  //
  // The same number and types of certificates as :ref:`tls_certificates <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.tls_certificates>`
  // are valid in the the certificates fetched through this setting.
  //
  // Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
  // and ``tls_certificate_provider_instance`` may be used.
  // [#next-major-version: These mutually exclusive fields should ideally be in a oneof, but it's
  // not legal to put a repeated field in a oneof. In the next major version, we should rework
  // this to avoid this problem.]
  repeated SdsSecretConfig tls_certificate_sds_secret_configs = 6;

  // Certificate provider instance for fetching TLS certs.
  //
  // Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
  // and ``tls_certificate_provider_instance`` may be used.
  // [#not-implemented-hide:]
  CertificateProviderPluginInstance tls_certificate_provider_instance = 14;

  // Certificate provider for fetching TLS certificates.
  // [#not-implemented-hide:]
  CertificateProvider tls_certificate_certificate_provider = 9
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // Certificate provider instance for fetching TLS certificates.
  // [#not-implemented-hide:]
  CertificateProviderInstance tls_certificate_certificate_provider_instance = 11
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  oneof validation_context_type {
    // How to validate peer certificates.
    CertificateValidationContext validation_context = 3;

    // Config for fetching validation context via SDS API. Note SDS API allows certificates to be
    // fetched/refreshed over the network asynchronously with respect to the TLS handshake.
    SdsSecretConfig validation_context_sds_secret_config = 7;

    // Combined certificate validation context holds a default CertificateValidationContext
    // and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
    // and default CertificateValidationContext are merged into a new CertificateValidationContext
    // for validation. This merge is done by Message::MergeFrom(), so dynamic
    // CertificateValidationContext overwrites singular fields in default
    // CertificateValidationContext, and concatenates repeated fields to default
    // CertificateValidationContext, and logical OR is applied to boolean fields.
    CombinedCertificateValidationContext combined_validation_context = 8;

    // Certificate provider for fetching validation context.
    // [#not-implemented-hide:]
    CertificateProvider validation_context_certificate_provider = 10
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

    // Certificate provider instance for fetching validation context.
    // [#not-implemented-hide:]
    CertificateProviderInstance validation_context_certificate_provider_instance = 12
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];
  }

  // Supplies the list of ALPN protocols that the listener should expose. In
  // practice this is likely to be set to one of two values (see the
  // :ref:`codec_type
  // <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.codec_type>`
  // parameter in the HTTP connection manager for more information):
  //
  // * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
  // * "http/1.1" If the listener is only going to support HTTP/1.1.
  //
  // There is no default for this parameter. If empty, Envoy will not expose ALPN.
  repeated string alpn_protocols = 4;

  // Custom TLS handshaker. If empty, defaults to native TLS handshaking
  // behavior.
  config.core.v3.TypedExtensionConfig custom_handshaker = 13;

  // TLS key log configuration
  TlsKeyLog key_log = 15;
}
syntax = "proto3";

package envoy.extensions.transport_sockets.tls.v3;

import public "envoy/extensions/transport_sockets/tls/v3/common.proto";
import public "envoy/extensions/transport_sockets/tls/v3/secret.proto";
import public "envoy/extensions/transport_sockets/tls/v3/tls.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.tls.v3";
option java_outer_classname = "CertProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3;tlsv3";
syntax = "proto3";

package envoy.extensions.transport_sockets.tls.v3;

import "envoy/config/core/v3/base.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.tls.v3";
option java_outer_classname = "TlsSpiffeValidatorConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3;tlsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: SPIFFE Certificate Validator]
// [#extension: envoy.tls.cert_validator.spiffe]

// Configuration specific to the `SPIFFE <https://github.com/spiffe/spiffe>`_ certificate validator.
//
// Example:
//
// .. validated-code-block:: yaml
//   :type-name: envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext
//
//   custom_validator_config:
//     name: envoy.tls.cert_validator.spiffe
//     typed_config:
//       "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.SPIFFECertValidatorConfig
//       trust_domains:
//       - name: foo.com
//         trust_bundle:
//           filename: "foo.pem"
//       - name: envoy.com
//         trust_bundle:
//           filename: "envoy.pem"
//
// In this example, a presented peer certificate whose SAN matches ``spiffe://foo.com/**`` is validated against
// the "foo.pem" x.509 certificate. All the trust bundles are isolated from each other, so no trust domain can mint
// a SVID belonging to another trust domain. That means, in this example, a SVID signed by ``envoy.com``'s CA with ``spiffe://foo.com/**``
// SAN would be rejected since Envoy selects the trust bundle according to the presented SAN before validate the certificate.
//
// Note that SPIFFE validator inherits and uses the following options from :ref:`CertificateValidationContext <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.CertificateValidationContext>`.
//
// - :ref:`allow_expired_certificate <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.allow_expired_certificate>` to allow expired certificates.
// - :ref:`match_typed_subject_alt_names <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>` to match **URI** SAN of certificates. Unlike the default validator, SPIFFE validator only matches **URI** SAN (which equals to SVID in SPIFFE terminology) and ignore other SAN types.
//
message SPIFFECertValidatorConfig {
  message TrustDomain {
    // Name of the trust domain, ``example.com``, ``foo.bar.gov`` for example.
    // Note that this must *not* have "spiffe://" prefix.
    string name = 1 [(validate.rules).string = {min_len: 1}];

    // Specify a data source holding x.509 trust bundle used for validating incoming SVID(s) in this trust domain.
    config.core.v3.DataSource trust_bundle = 2;
  }

  // This field specifies trust domains used for validating incoming X.509-SVID(s).
  repeated TrustDomain trust_domains = 1 [(validate.rules).repeated = {min_items: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/config/core/v3:pkg",
        "//envoy/type/matcher/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.transport_sockets.tls.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/config_source.proto";
import "envoy/extensions/transport_sockets/tls/v3/common.proto";

import "udpa/annotations/sensitive.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.tls.v3";
option java_outer_classname = "SecretProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3;tlsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Secrets configuration]

message GenericSecret {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.auth.GenericSecret";

  // Secret of generic type and is available to filters.
  config.core.v3.DataSource secret = 1 [(udpa.annotations.sensitive) = true];
}

message SdsSecretConfig {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.auth.SdsSecretConfig";

  // Name by which the secret can be uniquely referred to. When both name and config are specified,
  // then secret can be fetched and/or reloaded via SDS. When only name is specified, then secret
  // will be loaded from static resources.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  config.core.v3.ConfigSource sds_config = 2;
}

// [#next-free-field: 6]
message Secret {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.auth.Secret";

  // Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
  string name = 1;

  oneof type {
    TlsCertificate tls_certificate = 2;

    TlsSessionTicketKeys session_ticket_keys = 3;

    CertificateValidationContext validation_context = 4;

    GenericSecret generic_secret = 5;
  }
}
syntax = "proto3";

package envoy.extensions.transport_sockets.tls.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/extension.proto";
import "envoy/type/matcher/v3/string.proto";

import "google/protobuf/any.proto";
import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/migrate.proto";
import "udpa/annotations/sensitive.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.tls.v3";
option java_outer_classname = "CommonProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3;tlsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common TLS configuration]

// [#next-free-field: 6]
message TlsParameters {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.auth.TlsParameters";

  enum TlsProtocol {
    // Envoy will choose the optimal TLS version.
    TLS_AUTO = 0;

    // TLS 1.0
    TLSv1_0 = 1;

    // TLS 1.1
    TLSv1_1 = 2;

    // TLS 1.2
    TLSv1_2 = 3;

    // TLS 1.3
    TLSv1_3 = 4;
  }

  // Minimum TLS protocol version. By default, it's ``TLSv1_2`` for both clients and servers.
  //
  // TLS protocol versions below TLSv1_2 require setting compatible ciphers with the
  // ``cipher_suites`` setting as the default ciphers no longer include compatible ciphers.
  //
  // .. attention::
  //
  //   Using TLS protocol versions below TLSv1_2 has serious security considerations and risks.
  TlsProtocol tls_minimum_protocol_version = 1 [(validate.rules).enum = {defined_only: true}];

  // Maximum TLS protocol version. By default, it's ``TLSv1_2`` for clients and ``TLSv1_3`` for
  // servers.
  TlsProtocol tls_maximum_protocol_version = 2 [(validate.rules).enum = {defined_only: true}];

  // If specified, the TLS listener will only support the specified `cipher list
  // <https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>`_
  // when negotiating TLS 1.0-1.2 (this setting has no effect when negotiating TLS 1.3).
  //
  // If not specified, a default list will be used. Defaults are different for server (downstream) and
  // client (upstream) TLS configurations.
  // Defaults will change over time in response to security considerations; If you care, configure
  // it instead of using the default.
  //
  // In non-FIPS builds, the default server cipher list is:
  //
  // .. code-block:: none
  //
  //   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
  //   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
  //   ECDHE-ECDSA-AES256-GCM-SHA384
  //   ECDHE-RSA-AES256-GCM-SHA384
  //
  // In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default server cipher list is:
  //
  // .. code-block:: none
  //
  //   ECDHE-ECDSA-AES128-GCM-SHA256
  //   ECDHE-RSA-AES128-GCM-SHA256
  //   ECDHE-ECDSA-AES256-GCM-SHA384
  //   ECDHE-RSA-AES256-GCM-SHA384
  //
  // In non-FIPS builds, the default client cipher list is:
  //
  // .. code-block:: none
  //
  //   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
  //   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
  //   ECDHE-ECDSA-AES256-GCM-SHA384
  //   ECDHE-RSA-AES256-GCM-SHA384
  //
  // In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default client cipher list is:
  //
  // .. code-block:: none
  //
  //   ECDHE-ECDSA-AES128-GCM-SHA256
  //   ECDHE-RSA-AES128-GCM-SHA256
  //   ECDHE-ECDSA-AES256-GCM-SHA384
  //   ECDHE-RSA-AES256-GCM-SHA384
  repeated string cipher_suites = 3;

  // If specified, the TLS connection will only support the specified ECDH
  // curves. If not specified, the default curves will be used.
  //
  // In non-FIPS builds, the default curves are:
  //
  // .. code-block:: none
  //
  //   X25519
  //   P-256
  //
  // In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default curve is:
  //
  // .. code-block:: none
  //
  //   P-256
  repeated string ecdh_curves = 4;

  // If specified, the TLS connection will only support the specified signature algorithms.
  // The list is ordered by preference.
  // If not specified, the default signature algorithms defined by BoringSSL will be used.
  //
  // Default signature algorithms selected by BoringSSL (may be out of date):
  //
  // .. code-block:: none
  //
  //   ecdsa_secp256r1_sha256
  //   rsa_pss_rsae_sha256
  //   rsa_pkcs1_sha256
  //   ecdsa_secp384r1_sha384
  //   rsa_pss_rsae_sha384
  //   rsa_pkcs1_sha384
  //   rsa_pss_rsae_sha512
  //   rsa_pkcs1_sha512
  //   rsa_pkcs1_sha1
  //
  // Signature algorithms supported by BoringSSL (may be out of date):
  //
  // .. code-block:: none
  //
  //   rsa_pkcs1_sha256
  //   rsa_pkcs1_sha384
  //   rsa_pkcs1_sha512
  //   ecdsa_secp256r1_sha256
  //   ecdsa_secp384r1_sha384
  //   ecdsa_secp521r1_sha512
  //   rsa_pss_rsae_sha256
  //   rsa_pss_rsae_sha384
  //   rsa_pss_rsae_sha512
  //   ed25519
  //   rsa_pkcs1_sha1
  //   ecdsa_sha1
  repeated string signature_algorithms = 5;
}

// BoringSSL private key method configuration. The private key methods are used for external
// (potentially asynchronous) signing and decryption operations. Some use cases for private key
// methods would be TPM support and TLS acceleration.
message PrivateKeyProvider {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.auth.PrivateKeyProvider";

  reserved 2;

  reserved "config";

  // Private key method provider name. The name must match a
  // supported private key method provider type.
  string provider_name = 1 [(validate.rules).string = {min_len: 1}];

  // Private key method provider specific configuration.
  oneof config_type {
    google.protobuf.Any typed_config = 3 [(udpa.annotations.sensitive) = true];
  }

  // If the private key provider isn't available (eg. the required hardware capability doesn't existed),
  // Envoy will fallback to the BoringSSL default implementation when the ``fallback`` is true.
  // The default value is ``false``.
  bool fallback = 4;
}

// [#next-free-field: 9]
message TlsCertificate {
  option (udpa.annotations.versioning).previous_message_type = "envoy.api.v2.auth.TlsCertificate";

  // The TLS certificate chain.
  //
  // If ``certificate_chain`` is a filesystem path, a watch will be added to the
  // parent directory for any file moves to support rotation. This currently
  // only applies to dynamic secrets, when the ``TlsCertificate`` is delivered via
  // SDS.
  config.core.v3.DataSource certificate_chain = 1;

  // The TLS private key.
  //
  // If ``private_key`` is a filesystem path, a watch will be added to the parent
  // directory for any file moves to support rotation. This currently only
  // applies to dynamic secrets, when the ``TlsCertificate`` is delivered via SDS.
  config.core.v3.DataSource private_key = 2 [(udpa.annotations.sensitive) = true];

  // ``Pkcs12`` data containing TLS certificate, chain, and private key.
  //
  // If ``pkcs12`` is a filesystem path, the file will be read, but no watch will
  // be added to the parent directory, since ``pkcs12`` isn't used by SDS.
  // This field is mutually exclusive with ``certificate_chain``, ``private_key`` and ``private_key_provider``.
  // This can't be marked as ``oneof`` due to API compatibility reasons. Setting
  // both :ref:`private_key <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>`,
  // :ref:`certificate_chain <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.certificate_chain>`,
  // or :ref:`private_key_provider <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>`
  // and :ref:`pkcs12 <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.pkcs12>`
  // fields will result in an error. Use :ref:`password
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.password>`
  // to specify the password to unprotect the ``PKCS12`` data, if necessary.
  config.core.v3.DataSource pkcs12 = 8 [(udpa.annotations.sensitive) = true];

  // If specified, updates of file-based ``certificate_chain`` and ``private_key``
  // sources will be triggered by this watch. The certificate/key pair will be
  // read together and validated for atomic read consistency (i.e. no
  // intervening modification occurred between cert/key read, verified by file
  // hash comparisons). This allows explicit control over the path watched, by
  // default the parent directories of the filesystem paths in
  // ``certificate_chain`` and ``private_key`` are watched if this field is not
  // specified. This only applies when a ``TlsCertificate`` is delivered by SDS
  // with references to filesystem paths. See the :ref:`SDS key rotation
  // <sds_key_rotation>` documentation for further details.
  config.core.v3.WatchedDirectory watched_directory = 7;

  // BoringSSL private key method provider. This is an alternative to :ref:`private_key
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` field. This can't be
  // marked as ``oneof`` due to API compatibility reasons. Setting both :ref:`private_key
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` and
  // :ref:`private_key_provider
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>` fields will result in an
  // error.
  PrivateKeyProvider private_key_provider = 6;

  // The password to decrypt the TLS private key. If this field is not set, it is assumed that the
  // TLS private key is not password encrypted.
  config.core.v3.DataSource password = 3 [(udpa.annotations.sensitive) = true];

  // The OCSP response to be stapled with this certificate during the handshake.
  // The response must be DER-encoded and may only be  provided via ``filename`` or
  // ``inline_bytes``. The response may pertain to only one certificate.
  config.core.v3.DataSource ocsp_staple = 4;

  // [#not-implemented-hide:]
  repeated config.core.v3.DataSource signed_certificate_timestamp = 5;
}

message TlsSessionTicketKeys {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.auth.TlsSessionTicketKeys";

  // Keys for encrypting and decrypting TLS session tickets. The
  // first key in the array contains the key to encrypt all new sessions created by this context.
  // All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
  // by, for example, putting the new key first, and the previous key second.
  //
  // If :ref:`session_ticket_keys <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
  // is not specified, the TLS library will still support resuming sessions via tickets, but it will
  // use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
  // or on different hosts.
  //
  // Each key must contain exactly 80 bytes of cryptographically-secure random data. For
  // example, the output of ``openssl rand 80``.
  //
  // .. attention::
  //
  //   Using this feature has serious security considerations and risks. Improper handling of keys
  //   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
  //   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
  //   discussion. To minimize the risk, you must:
  //
  //   * Keep the session ticket keys at least as secure as your TLS certificate private keys
  //   * Rotate session ticket keys at least daily, and preferably hourly
  //   * Always generate keys using a cryptographically-secure random data source
  repeated config.core.v3.DataSource keys = 1
      [(validate.rules).repeated = {min_items: 1}, (udpa.annotations.sensitive) = true];
}

// Indicates a certificate to be obtained from a named CertificateProvider plugin instance.
// The plugin instances are defined in the client's bootstrap file.
// The plugin allows certificates to be fetched/refreshed over the network asynchronously with
// respect to the TLS handshake.
// [#not-implemented-hide:]
message CertificateProviderPluginInstance {
  // Provider instance name. If not present, defaults to "default".
  //
  // Instance names should generally be defined not in terms of the underlying provider
  // implementation (e.g., "file_watcher") but rather in terms of the function of the
  // certificates (e.g., "foo_deployment_identity").
  string instance_name = 1;

  // Opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
  // a root-certificate (validation context) or "example.com" to specify a certificate for a
  // particular domain. Not all provider instances will actually use this field, so the value
  // defaults to the empty string.
  string certificate_name = 2;
}

// Matcher for subject alternative names, to match both type and value of the SAN.
message SubjectAltNameMatcher {
  // Indicates the choice of GeneralName as defined in section 4.2.1.5 of RFC 5280 to match
  // against.
  enum SanType {
    SAN_TYPE_UNSPECIFIED = 0;
    EMAIL = 1;
    DNS = 2;
    URI = 3;
    IP_ADDRESS = 4;
  }

  // Specification of type of SAN. Note that the default enum value is an invalid choice.
  SanType san_type = 1 [(validate.rules).enum = {defined_only: true not_in: 0}];

  // Matcher for SAN value.
  type.matcher.v3.StringMatcher matcher = 2 [(validate.rules).message = {required: true}];
}

// [#next-free-field: 17]
message CertificateValidationContext {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.auth.CertificateValidationContext";

  // Peer certificate verification mode.
  enum TrustChainVerification {
    // Perform default certificate verification (e.g., against CA / verification lists)
    VERIFY_TRUST_CHAIN = 0;

    // Connections where the certificate fails verification will be permitted.
    // For HTTP connections, the result of certificate verification can be used in route matching. (
    // see :ref:`validated <envoy_v3_api_field_config.route.v3.RouteMatch.TlsContextMatchOptions.validated>` ).
    ACCEPT_UNTRUSTED = 1;
  }

  reserved 4, 5;

  reserved "verify_subject_alt_name";

  // TLS certificate data containing certificate authority certificates to use in verifying
  // a presented peer certificate (e.g. server certificate for clusters or client certificate
  // for listeners). If not specified and a peer certificate is presented it will not be
  // verified. By default, a client certificate is optional, unless one of the additional
  // options (:ref:`require_client_certificate
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.require_client_certificate>`,
  // :ref:`verify_certificate_spki
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>`,
  // :ref:`verify_certificate_hash
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>`, or
  // :ref:`match_typed_subject_alt_names
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`) is also
  // specified.
  //
  // It can optionally contain certificate revocation lists, in which case Envoy will verify
  // that the presented peer certificate has not been revoked by one of the included CRLs. Note
  // that if a CRL is provided for any certificate authority in a trust chain, a CRL must be
  // provided for all certificate authorities in that chain. Failure to do so will result in
  // verification failure for both revoked and unrevoked certificates from that chain.
  // The behavior of requiring all certificates to contain CRLs can be altered by
  // setting :ref:`only_verify_leaf_cert_crl <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.only_verify_leaf_cert_crl>`
  // true. If set to true, only the final certificate in the chain undergoes CRL verification.
  //
  // See :ref:`the TLS overview <arch_overview_ssl_enabling_verification>` for a list of common
  // system CA locations.
  //
  // If ``trusted_ca`` is a filesystem path, a watch will be added to the parent
  // directory for any file moves to support rotation. This currently only
  // applies to dynamic secrets, when the ``CertificateValidationContext`` is
  // delivered via SDS.
  //
  // X509_V_FLAG_PARTIAL_CHAIN is set by default, so non-root/intermediate ca certificate in ``trusted_ca``
  // can be treated as trust anchor as well. It allows verification with building valid partial chain instead
  // of a full chain.
  //
  // Only one of ``trusted_ca`` and ``ca_certificate_provider_instance`` may be specified.
  //
  // [#next-major-version: This field and watched_directory below should ideally be moved into a
  // separate sub-message, since there's no point in specifying the latter field without this one.]
  config.core.v3.DataSource trusted_ca = 1
      [(udpa.annotations.field_migrate).oneof_promotion = "ca_cert_source"];

  // Certificate provider instance for fetching TLS certificates.
  //
  // Only one of ``trusted_ca`` and ``ca_certificate_provider_instance`` may be specified.
  // [#not-implemented-hide:]
  CertificateProviderPluginInstance ca_certificate_provider_instance = 13
      [(udpa.annotations.field_migrate).oneof_promotion = "ca_cert_source"];

  // If specified, updates of a file-based ``trusted_ca`` source will be triggered
  // by this watch. This allows explicit control over the path watched, by
  // default the parent directory of the filesystem path in ``trusted_ca`` is
  // watched if this field is not specified. This only applies when a
  // ``CertificateValidationContext`` is delivered by SDS with references to
  // filesystem paths. See the :ref:`SDS key rotation <sds_key_rotation>`
  // documentation for further details.
  config.core.v3.WatchedDirectory watched_directory = 11;

  // An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
  // SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
  // matches one of the specified values.
  //
  // A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
  // can be generated with the following command:
  //
  // .. code-block:: bash
  //
  //   $ openssl x509 -in path/to/client.crt -noout -pubkey
  //     | openssl pkey -pubin -outform DER
  //     | openssl dgst -sha256 -binary
  //     | openssl enc -base64
  //   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
  //
  // This is the format used in HTTP Public Key Pinning.
  //
  // When both:
  // :ref:`verify_certificate_hash
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>` and
  // :ref:`verify_certificate_spki
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>` are specified,
  // a hash matching value from either of the lists will result in the certificate being accepted.
  //
  // .. attention::
  //
  //   This option is preferred over :ref:`verify_certificate_hash
  //   <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>`,
  //   because SPKI is tied to a private key, so it doesn't change when the certificate
  //   is renewed using the same private key.
  repeated string verify_certificate_spki = 3
      [(validate.rules).repeated = {items {string {min_len: 44 max_bytes: 44}}}];

  // An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
  // the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
  //
  // A hex-encoded SHA-256 of the certificate can be generated with the following command:
  //
  // .. code-block:: bash
  //
  //   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
  //   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
  //
  // A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
  // can be generated with the following command:
  //
  // .. code-block:: bash
  //
  //   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
  //   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
  //
  // Both of those formats are acceptable.
  //
  // When both:
  // :ref:`verify_certificate_hash
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>` and
  // :ref:`verify_certificate_spki
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>` are specified,
  // a hash matching value from either of the lists will result in the certificate being accepted.
  repeated string verify_certificate_hash = 2
      [(validate.rules).repeated = {items {string {min_len: 64 max_bytes: 95}}}];

  // An optional list of Subject Alternative name matchers. If specified, Envoy will verify that the
  // Subject Alternative Name of the presented certificate matches one of the specified matchers.
  // The matching uses "any" semantics, that is to say, the SAN is verified if at least one matcher is
  // matched.
  //
  // When a certificate has wildcard DNS SAN entries, to match a specific client, it should be
  // configured with exact match type in the :ref:`string matcher <envoy_v3_api_msg_type.matcher.v3.StringMatcher>`.
  // For example if the certificate has "\*.example.com" as DNS SAN entry, to allow only "api.example.com",
  // it should be configured as shown below.
  //
  // .. code-block:: yaml
  //
  //  match_typed_subject_alt_names:
  //  - san_type: DNS
  //    matcher:
  //      exact: "api.example.com"
  //
  // .. attention::
  //
  //   Subject Alternative Names are easily spoofable and verifying only them is insecure,
  //   therefore this option must be used together with :ref:`trusted_ca
  //   <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`.
  repeated SubjectAltNameMatcher match_typed_subject_alt_names = 15;

  // This field is deprecated in favor of
  // :ref:`match_typed_subject_alt_names
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`.
  // Note that if both this field and :ref:`match_typed_subject_alt_names
  // <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`
  // are specified, the former (deprecated field) is ignored.
  repeated type.matcher.v3.StringMatcher match_subject_alt_names = 9
      [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];

  // [#not-implemented-hide:] Must present signed certificate time-stamp.
  google.protobuf.BoolValue require_signed_certificate_timestamp = 6;

  // An optional `certificate revocation list
  // <https://en.wikipedia.org/wiki/Certificate_revocation_list>`_
  // (in PEM format). If specified, Envoy will verify that the presented peer
  // certificate has not been revoked by this CRL. If this DataSource contains
  // multiple CRLs, all of them will be used. Note that if a CRL is provided
  // for any certificate authority in a trust chain, a CRL must be provided
  // for all certificate authorities in that chain. Failure to do so will
  // result in verification failure for both revoked and unrevoked certificates
  // from that chain. This default behavior can be altered by setting
  // :ref:`only_verify_leaf_cert_crl <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.only_verify_leaf_cert_crl>` to
  // true.
  //
  // If ``crl`` is a filesystem path, a watch will be added to the parent
  // directory for any file moves to support rotation. This currently only
  // applies to dynamic secrets, when the ``CertificateValidationContext`` is
  // delivered via SDS.
  config.core.v3.DataSource crl = 7;

  // If specified, Envoy will not reject expired certificates.
  bool allow_expired_certificate = 8;

  // Certificate trust chain verification mode.
  TrustChainVerification trust_chain_verification = 10
      [(validate.rules).enum = {defined_only: true}];

  // The configuration of an extension specific certificate validator.
  // If specified, all validation is done by the specified validator,
  // and the behavior of all other validation settings is defined by the specified validator (and may be entirely ignored, unused, and unvalidated).
  // Refer to the documentation for the specified validator. If you do not want a custom validation algorithm, do not set this field.
  // [#extension-category: envoy.tls.cert_validator]
  config.core.v3.TypedExtensionConfig custom_validator_config = 12;

  // If this option is set to true, only the certificate at the end of the
  // certificate chain will be subject to validation by :ref:`CRL <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.crl>`.
  bool only_verify_leaf_cert_crl = 14;

  // Defines maximum depth of a certificate chain accepted in verification, the default limit is 100, though this can be system-dependent.
  // This number does not include the leaf but includes the trust anchor, so a depth of 1 allows the leaf and one CA certificate. If a trusted issuer
  // appears in the chain, but in a depth larger than configured, the certificate validation will fail.
  // This matches the semantics of ``SSL_CTX_set_verify_depth`` in OpenSSL 1.0.x and older versions of BoringSSL. It differs from ``SSL_CTX_set_verify_depth``
  // in OpenSSL 1.1.x and newer versions of BoringSSL in that the trust anchor is included.
  // Trusted issues are specified by setting :ref:`trusted_ca <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`
  google.protobuf.UInt32Value max_verify_depth = 16 [(validate.rules).uint32 = {lte: 100}];
}
syntax = "proto3";

package envoy.extensions.transport_sockets.alts.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.alts.v3";
option java_outer_classname = "AltsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/alts/v3;altsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: ALTS]
// [#extension: envoy.transport_sockets.alts]

// Configuration for ALTS transport socket. This provides Google's ALTS protocol to Envoy.
// Store the peer identity in dynamic metadata, namespace is "envoy.transport_socket.peer_information", key is "peer_identity".
// https://cloud.google.com/security/encryption-in-transit/application-layer-transport-security/
message Alts {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.transport_socket.alts.v2alpha.Alts";

  // The location of a handshaker service, this is usually 169.254.169.254:8080
  // on GCE.
  string handshaker_service = 1 [(validate.rules).string = {min_len: 1}];

  // The acceptable service accounts from peer, peers not in the list will be rejected in the
  // handshake validation step. If empty, no validation will be performed.
  repeated string peer_service_accounts = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.transport_sockets.http_11_proxy.v3;

import "envoy/config/core/v3/base.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.http_11_proxy.v3";
option java_outer_classname = "UpstreamHttp11ConnectProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/http_11_proxy/v3;http_11_proxyv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Upstream HTTP/1.1 Proxy]
// [#extension: envoy.transport_sockets.http_11_proxy]

// Configuration for HTTP/1.1 proxy transport sockets.
// This is intended for use in Envoy Mobile, though may eventually be extended
// for upstream Envoy use.
// If this transport socket is configured, and an intermediate filter adds the
// stream info necessary for proxying to the stream info (as the test filter
// does :repo:`here <test/integration/filters/header_to_proxy_filter.cc>`) then
//
// * Upstream connections will be directed to the specified proxy address rather
//   than the host's address
// * Upstream TLS connections will have a raw HTTP/1.1 CONNECT header prefaced
//   to the payload, and 200 response stripped (if less than 200 bytes)
// * Plaintext HTTP/1.1 connections will be sent with a fully qualified URL.
//
// This transport socket is not compatible with HTTP/3, plaintext HTTP/2, or raw TCP.
message Http11ProxyUpstreamTransport {
  // The underlying transport socket being wrapped.
  config.core.v3.TransportSocket transport_socket = 1 [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.transport_sockets.proxy_protocol.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/config/core/v3/proxy_protocol.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.proxy_protocol.v3";
option java_outer_classname = "UpstreamProxyProtocolProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/proxy_protocol/v3;proxy_protocolv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Upstream Proxy Protocol]
// [#extension: envoy.transport_sockets.upstream_proxy_protocol]

// Configuration for PROXY protocol socket
message ProxyProtocolUpstreamTransport {
  // The PROXY protocol settings
  config.core.v3.ProxyProtocolConfig config = 1;

  // The underlying transport socket being wrapped.
  config.core.v3.TransportSocket transport_socket = 2 [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "//envoy/type/metadata/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.transport_sockets.internal_upstream.v3;

import "envoy/config/core/v3/base.proto";
import "envoy/type/metadata/v3/metadata.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.internal_upstream.v3";
option java_outer_classname = "InternalUpstreamProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/internal_upstream/v3;internal_upstreamv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Internal Upstream]
// [#extension: envoy.transport_sockets.internal_upstream]

// Configuration for the internal upstream address. An internal address defines
// a loopback user space socket residing in the same proxy instance. This
// extension allows passing additional structured state across the user space
// socket in addition to the regular byte stream. The purpose is to facilitate
// communication between filters on the downstream and the upstream internal
// connections. All filter state objects that are shared with the upstream
// connection are also shared with the downstream internal connection using
// this transport socket.
message InternalUpstreamTransport {
  // Describes the location of the imported metadata value.
  // If the metadata with the given name is not present at the source location,
  // then no metadata is passed through for this particular instance.
  message MetadataValueSource {
    // Specifies what kind of metadata.
    type.metadata.v3.MetadataKind kind = 1 [(validate.rules).message = {required: true}];

    // Name is the filter namespace used in the dynamic metadata.
    string name = 2 [(validate.rules).string = {min_len: 1}];
  }

  // Specifies the metadata namespaces and values to insert into the downstream
  // internal connection dynamic metadata when an internal address is used as a
  // host. If the destination name is repeated across two metadata source
  // locations, and both locations contain the metadata with the given name,
  // then the latter in the list overrides the former.
  repeated MetadataValueSource passthrough_metadata = 1;

  // The underlying transport socket being wrapped.
  config.core.v3.TransportSocket transport_socket = 3 [(validate.rules).message = {required: true}];
}
syntax = "proto3";

package envoy.extensions.transport_sockets.raw_buffer.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.raw_buffer.v3";
option java_outer_classname = "RawBufferProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/raw_buffer/v3;raw_bufferv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Raw Buffer]
// [#extension: envoy.transport_sockets.raw_buffer]

// Configuration for raw buffer transport socket.
message RawBuffer {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.transport_socket.raw_buffer.v2.RawBuffer";
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.transport_sockets.tcp_stats.v3;

import "envoy/config/core/v3/base.proto";

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.tcp_stats.v3";
option java_outer_classname = "TcpStatsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tcp_stats/v3;tcp_statsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: TCP Stats Transport Socket wrapper]
// [#extension: envoy.transport_sockets.tcp_stats]

// Configuration for the TCP Stats transport socket wrapper, which wraps another transport socket for
// all communication, but emits stats about the underlying TCP connection.
//
// The stats are documented :ref:`here <config_listener_stats_tcp>` for listeners and
// :ref:`here <config_cluster_manager_cluster_stats_tcp>` for clusters.
//
// This transport socket is currently only supported on Linux.
message Config {
  // The underlying transport socket being wrapped.
  config.core.v3.TransportSocket transport_socket = 1 [(validate.rules).message = {required: true}];

  // Period to update stats while the connection is open. If unset, updates only happen when the
  // connection is closed. Stats are always updated one final time when the connection is closed.
  google.protobuf.Duration update_period = 2 [(validate.rules).duration = {gte {nanos: 1000000}}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.transport_sockets.quic.v3;

import "envoy/extensions/transport_sockets/tls/v3/tls.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.transport_sockets.quic.v3";
option java_outer_classname = "QuicTransportProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/quic/v3;quicv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: quic transport]
// [#comment:#extension: envoy.transport_sockets.quic]

// Configuration for Downstream QUIC transport socket. This provides Google's implementation of Google QUIC and IETF QUIC to Envoy.
message QuicDownstreamTransport {
  tls.v3.DownstreamTlsContext downstream_tls_context = 1
      [(validate.rules).message = {required: true}];

  // If false, QUIC will tell TLS to reject any early data and to stop issuing 0-RTT credentials with resumption session tickets. This will prevent clients from sending 0-RTT requests.
  // Default to true.
  google.protobuf.BoolValue enable_early_data = 2;
}

// Configuration for Upstream QUIC transport socket. This provides Google's implementation of Google QUIC and IETF QUIC to Envoy.
message QuicUpstreamTransport {
  tls.v3.UpstreamTlsContext upstream_tls_context = 1 [(validate.rules).message = {required: true}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/extensions/transport_sockets/tls/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.early_data.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.early_data.v3";
option java_outer_classname = "DefaultEarlyDataPolicyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/early_data/v3;early_datav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP request early data policy]

// [#extension: envoy.route.early_data_policy.default]
// The default rule to allow/disallow a request to be sent as early data. It's an empty config now. Configuring it will disallow any request to be sent over early data.
message DefaultEarlyDataPolicy {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.resource_monitors.injected_resource.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.resource_monitors.injected_resource.v3";
option java_outer_classname = "InjectedResourceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/resource_monitors/injected_resource/v3;injected_resourcev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Injected resource]
// [#extension: envoy.resource_monitors.injected_resource]

// The injected resource monitor allows injecting a synthetic resource pressure into Envoy
// via a text file, which must contain a floating-point number in the range [0..1] representing
// the resource pressure and be updated atomically by a symbolic link swap.
// This is intended primarily for integration tests to force Envoy into an overloaded state.
message InjectedResourceConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.resource_monitor.injected_resource.v2alpha.InjectedResourceConfig";

  string filename = 1 [(validate.rules).string = {min_len: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.resource_monitors.fixed_heap.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.resource_monitors.fixed_heap.v3";
option java_outer_classname = "FixedHeapProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/resource_monitors/fixed_heap/v3;fixed_heapv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Fixed heap]
// [#extension: envoy.resource_monitors.fixed_heap]

// The fixed heap resource monitor reports the Envoy process memory pressure, computed as a
// fraction of currently reserved heap memory divided by a statically configured maximum
// specified in the FixedHeapConfig.
message FixedHeapConfig {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.resource_monitor.fixed_heap.v2alpha.FixedHeapConfig";

  uint64 max_heap_size_bytes = 1 [(validate.rules).uint64 = {gt: 0}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.resource_monitors.downstream_connections.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.resource_monitors.downstream_connections.v3";
option java_outer_classname = "DownstreamConnectionsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/resource_monitors/downstream_connections/v3;downstream_connectionsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Downstream connections]
// [#extension: envoy.resource_monitors.downstream_connections]

// The downstream connections resource monitor tracks the global number of open downstream connections.
message DownstreamConnectionsConfig {
  // Maximum threshold for global open downstream connections, defaults to 0.
  // If monitor is enabled in Overload manager api, this field should be explicitly configured with value greater than 0.
  int64 max_active_downstream_connections = 1 [(validate.rules).int64 = {gt: 0}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.key_value.file_based.v3;

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.key_value.file_based.v3";
option java_outer_classname = "ConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/key_value/file_based/v3;file_basedv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Key/value file-based store storage plugin]

// [#extension: envoy.key_value.file_based]
// This is configuration to flush a key value store out to disk.
message FileBasedKeyValueStoreConfig {
  option (xds.annotations.v3.message_status).work_in_progress = true;

  // The filename to read the keys and values from, and write the keys and
  // values to.
  string filename = 1 [(validate.rules).string = {min_len: 1}];

  // The interval at which the key value store should be flushed to the file.
  google.protobuf.Duration flush_interval = 2;

  // The maximum number of entries to cache, or 0 to allow for unlimited entries.
  // Defaults to 1000 if not present.
  google.protobuf.UInt32Value max_entries = 3;
}
syntax = "proto3";

package envoy.extensions.tracers.opentelemetry.samplers.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.tracers.opentelemetry.samplers.v3";
option java_outer_classname = "AlwaysOnSamplerProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/tracers/opentelemetry/samplers/v3;samplersv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Always On Sampler config]
// Configuration for the "AlwaysOn" Sampler extension.
// The sampler follows the "AlwaysOn" implementation from the OpenTelemetry
// SDK specification.
//
// See:
// `AlwaysOn sampler specification <https://opentelemetry.io/docs/specs/otel/trace/sdk/#alwayson>`_
// [#extension: envoy.tracers.opentelemetry.samplers.always_on]

message AlwaysOnSamplerConfig {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.tracers.opentelemetry.resource_detectors.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.tracers.opentelemetry.resource_detectors.v3";
option java_outer_classname = "DynatraceResourceDetectorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/tracers/opentelemetry/resource_detectors/v3;resource_detectorsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Dynatrace Resource Detector config]

// Configuration for the Dynatrace Resource Detector extension.
// The resource detector reads from the Dynatrace enrichment files
// and adds host/process related attributes to the OpenTelemetry resource.
//
// See:
//
// `Enrich ingested data with Dynatrace-specific dimensions <https://docs.dynatrace.com/docs/shortlink/enrichment-files>`_
//
// [#extension: envoy.tracers.opentelemetry.resource_detectors.dynatrace]
message DynatraceResourceDetectorConfig {
}
syntax = "proto3";

package envoy.extensions.tracers.opentelemetry.resource_detectors.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.tracers.opentelemetry.resource_detectors.v3";
option java_outer_classname = "EnvironmentResourceDetectorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/tracers/opentelemetry/resource_detectors/v3;resource_detectorsv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Environment Resource Detector config]

// Configuration for the Environment Resource detector extension.
// The resource detector reads from the ``OTEL_RESOURCE_ATTRIBUTES``
// environment variable, as per the OpenTelemetry specification.
//
// See:
//
// `OpenTelemetry specification <https://github.com/open-telemetry/opentelemetry-specification/blob/v1.24.0/specification/resource/sdk.md#detecting-resource-information-from-the-environment>`_
//
// [#extension: envoy.tracers.opentelemetry.resource_detectors.environment]
message EnvironmentResourceDetectorConfig {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.quic.connection_id_generator.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.quic.connection_id_generator.v3";
option java_outer_classname = "EnvoyDeterministicConnectionIdGeneratorProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/quic/connection_id_generator/v3;connection_id_generatorv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: QUIC connection ID generator config]
// [#extension: envoy.quic.deterministic_connection_id_generator]

// Configuration for a connection ID generator implementation which issues predictable CIDs with stable first 4 bytes.
message DeterministicConnectionIdGeneratorConfig {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.quic.proof_source.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.quic.proof_source.v3";
option java_outer_classname = "ProofSourceProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/quic/proof_source/v3;proof_sourcev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: QUIC proof source config]
// [#extension: envoy.quic.proof_source.filter_chain]

// Configuration for the default QUIC proof source.
message ProofSourceConfig {
}
syntax = "proto3";

package envoy.extensions.quic.crypto_stream.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.quic.crypto_stream.v3";
option java_outer_classname = "CryptoStreamProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/quic/crypto_stream/v3;crypto_streamv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: QUIC server crypto stream config]
// [#extension: envoy.quic.crypto_stream.server.quiche]

// Configuration for the default QUIC server crypto stream provided by QUICHE.
message CryptoServerStreamConfig {
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.quic.server_preferred_address.v3;

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.quic.server_preferred_address.v3";
option java_outer_classname = "FixedServerPreferredAddressConfigProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/quic/server_preferred_address/v3;server_preferred_addressv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: QUIC server preferred address config]
// [#extension: envoy.quic.server_preferred_address.fixed]

// Configuration for FixedServerPreferredAddressConfig.
message FixedServerPreferredAddressConfig {
  // [#comment:TODO(danzh2010): discuss with API shepherds before removing WiP status.]

  option (xds.annotations.v3.message_status).work_in_progress = true;

  oneof ipv4_type {
    // String representation of IPv4 address, i.e. "127.0.0.2".
    // If not specified, none will be configured.
    string ipv4_address = 1;
  }

  oneof ipv6_type {
    // String representation of IPv6 address, i.e. "::1".
    // If not specified, none will be configured.
    string ipv6_address = 2;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.extensions.health_check.event_sinks.file.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.health_check.event_sinks.file.v3";
option java_outer_classname = "FileProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/health_check/event_sinks/file/v3;filev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Health Check Log File Sink]
// [#extension: envoy.health_check.event_sinks.file]

// Health check event file sink.
// The health check event will be converted to JSON.
message HealthCheckEventFileSink {
  // Specifies the path to the health check event log.
  string event_log_path = 1 [(validate.rules).string = {min_len: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.extensions.router.cluster_specifiers.lua.v3;

import "envoy/config/core/v3/base.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.router.cluster_specifiers.lua.v3";
option java_outer_classname = "LuaProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/router/cluster_specifiers/lua/v3;luav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Lua]
//
// Lua cluster specifier :ref:`configuration reference documentation <config_http_cluster_specifier_lua>`.
// [#extension: envoy.router.cluster_specifier_plugin.lua]

message LuaConfig {
  // The lua code that Envoy will execute to select cluster.
  config.core.v3.DataSource source_code = 1 [(validate.rules).message = {required: true}];

  // Default cluster. It will be used when the lua code execute failure.
  string default_cluster = 2;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/config/core/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.annotations;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/annotations";

import "google/protobuf/descriptor.proto";

// [#protodoc-title: Deprecation]
// Adds annotations for deprecated fields and enums to allow tagging proto
// fields as fatal by default and the minor version on which the field was
// deprecated. One Envoy release after deprecation, deprecated fields will be
// disallowed by default, a state which is reversible with
// :ref:`runtime overrides <config_runtime_deprecation>`.

// Magic number in this file derived from top 28bit of SHA256 digest of
// "envoy.annotation.disallowed_by_default" and "envoy.annotation.deprecated_at_minor_version"
extend google.protobuf.FieldOptions {
  bool disallowed_by_default = 189503207;

  // The API major and minor version on which the field was deprecated
  // (e.g., "3.5" for major version 3 and minor version 5).
  string deprecated_at_minor_version = 157299826;
}

// Magic number in this file derived from top 28bit of SHA256 digest of
// "envoy.annotation.disallowed_by_default_enum" and
// "envoy.annotation.deprecated_at_minor_version_eum"
extend google.protobuf.EnumValueOptions {
  bool disallowed_by_default_enum = 70100853;

  // The API major and minor version on which the enum value was deprecated
  // (e.g., "3.5" for major version 3 and minor version 5).
  string deprecated_at_minor_version_enum = 181198657;
}
load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package()
syntax = "proto3";

package envoy.annotations;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/annotations";

import "google/protobuf/descriptor.proto";

// [#protodoc-title: Resource]

// Magic number in this file derived from top 28bit of SHA256 digest of "envoy.annotation.resource".
extend google.protobuf.ServiceOptions {
  ResourceAnnotation resource = 265073217;
}

message ResourceAnnotation {
  // Annotation for xDS services that indicates the fully-qualified Protobuf type for the resource
  // type.
  string type = 1;
}
syntax = "proto3";

package envoy.type;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.type";
option java_outer_classname = "HttpProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: HTTP]

enum CodecClientType {
  HTTP1 = 0;

  HTTP2 = 1;

  // [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
  // caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
  // to distinguish HTTP1 and HTTP2 traffic.
  HTTP3 = 2;
}
syntax = "proto3";

package envoy.type.tracing.v2;

import "envoy/type/metadata/v2/metadata.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.tracing.v2";
option java_outer_classname = "CustomTagProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/tracing/v2;tracingv2";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Custom Tag]

// Describes custom tags for the active span.
// [#next-free-field: 6]
message CustomTag {
  // Literal type custom tag with static value for the tag value.
  message Literal {
    // Static literal value to populate the tag value.
    string value = 1 [(validate.rules).string = {min_bytes: 1}];
  }

  // Environment type custom tag with environment name and default value.
  message Environment {
    // Environment variable name to obtain the value to populate the tag value.
    string name = 1 [(validate.rules).string = {min_bytes: 1}];

    // When the environment variable is not found,
    // the tag value will be populated with this default value if specified,
    // otherwise no tag will be populated.
    string default_value = 2;
  }

  // Header type custom tag with header name and default value.
  message Header {
    // Header name to obtain the value to populate the tag value.
    string name = 1
        [(validate.rules).string = {min_bytes: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

    // When the header does not exist,
    // the tag value will be populated with this default value if specified,
    // otherwise no tag will be populated.
    string default_value = 2;
  }

  // Metadata type custom tag using
  // :ref:`MetadataKey <envoy_api_msg_type.metadata.v2.MetadataKey>` to retrieve the protobuf value
  // from :ref:`Metadata <envoy_api_msg_core.Metadata>`, and populate the tag value with
  // `the canonical JSON <https://developers.google.com/protocol-buffers/docs/proto3#json>`_
  // representation of it.
  message Metadata {
    // Specify what kind of metadata to obtain tag value from.
    metadata.v2.MetadataKind kind = 1;

    // Metadata key to define the path to retrieve the tag value.
    metadata.v2.MetadataKey metadata_key = 2;

    // When no valid metadata is found,
    // the tag value would be populated with this default value if specified,
    // otherwise no tag would be populated.
    string default_value = 3;
  }

  // Used to populate the tag name.
  string tag = 1 [(validate.rules).string = {min_bytes: 1}];

  // Used to specify what kind of custom tag.
  oneof type {
    option (validate.required) = true;

    // A literal custom tag.
    Literal literal = 2;

    // An environment custom tag.
    Environment environment = 3;

    // A request header custom tag.
    Header request_header = 4;

    // A custom tag to obtain tag value from the metadata.
    Metadata metadata = 5;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/type/metadata/v2:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.type.tracing.v3;

import "envoy/type/metadata/v3/metadata.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.tracing.v3";
option java_outer_classname = "CustomTagProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3;tracingv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Custom Tag]

// Describes custom tags for the active span.
// [#next-free-field: 6]
message CustomTag {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.tracing.v2.CustomTag";

  // Literal type custom tag with static value for the tag value.
  message Literal {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.tracing.v2.CustomTag.Literal";

    // Static literal value to populate the tag value.
    string value = 1 [(validate.rules).string = {min_len: 1}];
  }

  // Environment type custom tag with environment name and default value.
  message Environment {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.tracing.v2.CustomTag.Environment";

    // Environment variable name to obtain the value to populate the tag value.
    string name = 1 [(validate.rules).string = {min_len: 1}];

    // When the environment variable is not found,
    // the tag value will be populated with this default value if specified,
    // otherwise no tag will be populated.
    string default_value = 2;
  }

  // Header type custom tag with header name and default value.
  message Header {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.tracing.v2.CustomTag.Header";

    // Header name to obtain the value to populate the tag value.
    string name = 1
        [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

    // When the header does not exist,
    // the tag value will be populated with this default value if specified,
    // otherwise no tag will be populated.
    string default_value = 2;
  }

  // Metadata type custom tag using
  // :ref:`MetadataKey <envoy_v3_api_msg_type.metadata.v3.MetadataKey>` to retrieve the protobuf value
  // from :ref:`Metadata <envoy_v3_api_msg_config.core.v3.Metadata>`, and populate the tag value with
  // `the canonical JSON <https://developers.google.com/protocol-buffers/docs/proto3#json>`_
  // representation of it.
  message Metadata {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.tracing.v2.CustomTag.Metadata";

    // Specify what kind of metadata to obtain tag value from.
    metadata.v3.MetadataKind kind = 1;

    // Metadata key to define the path to retrieve the tag value.
    metadata.v3.MetadataKey metadata_key = 2;

    // When no valid metadata is found,
    // the tag value would be populated with this default value if specified,
    // otherwise no tag would be populated.
    string default_value = 3;
  }

  // Used to populate the tag name.
  string tag = 1 [(validate.rules).string = {min_len: 1}];

  // Used to specify what kind of custom tag.
  oneof type {
    option (validate.required) = true;

    // A literal custom tag.
    Literal literal = 2;

    // An environment custom tag.
    Environment environment = 3;

    // A request header custom tag.
    Header request_header = 4;

    // A custom tag to obtain tag value from the metadata.
    Metadata metadata = 5;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/type/metadata/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.type;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type";
option java_outer_classname = "PercentProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Percent]

// Identifies a percentage, in the range [0.0, 100.0].
message Percent {
  double value = 1 [(validate.rules).double = {lte: 100.0 gte: 0.0}];
}

// A fractional percentage is used in cases in which for performance reasons performing floating
// point to integer conversions during randomness calculations is undesirable. The message includes
// both a numerator and denominator that together determine the final fractional value.
//
// * **Example**: 1/100 = 1%.
// * **Example**: 3/10000 = 0.03%.
message FractionalPercent {
  // Fraction percentages support several fixed denominator values.
  enum DenominatorType {
    // 100.
    //
    // **Example**: 1/100 = 1%.
    HUNDRED = 0;

    // 10,000.
    //
    // **Example**: 1/10000 = 0.01%.
    TEN_THOUSAND = 1;

    // 1,000,000.
    //
    // **Example**: 1/1000000 = 0.0001%.
    MILLION = 2;
  }

  // Specifies the numerator. Defaults to 0.
  uint32 numerator = 1;

  // Specifies the denominator. If the denominator specified is less than the numerator, the final
  // fractional percentage is capped at 1 (100%).
  DenominatorType denominator = 2 [(validate.rules).enum = {defined_only: true}];
}
syntax = "proto3";

package envoy.type.matcher;

import "envoy/type/matcher/string.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher";
option java_outer_classname = "PathProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Path matcher]

// Specifies the way to match a path on HTTP request.
message PathMatcher {
  oneof rule {
    option (validate.required) = true;

    // The `path` must match the URL path portion of the :path header. The query and fragment
    // string (if present) are removed in the URL path portion.
    // For example, the path */data* will match the *:path* header */data#fragment?param=value*.
    StringMatcher path = 1 [(validate.rules).message = {required: true}];
  }
}
syntax = "proto3";

package envoy.type.matcher;

import "envoy/type/matcher/regex.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher";
option java_outer_classname = "StringProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: String matcher]

// Specifies the way to match a string.
// [#next-free-field: 7]
message StringMatcher {
  oneof match_pattern {
    option (validate.required) = true;

    // The input string must match exactly the string specified here.
    //
    // Examples:
    //
    // * *abc* only matches the value *abc*.
    string exact = 1;

    // The input string must have the prefix specified here.
    // Note: empty prefix is not allowed, please use regex instead.
    //
    // Examples:
    //
    // * *abc* matches the value *abc.xyz*
    string prefix = 2 [(validate.rules).string = {min_len: 1}];

    // The input string must have the suffix specified here.
    // Note: empty prefix is not allowed, please use regex instead.
    //
    // Examples:
    //
    // * *abc* matches the value *xyz.abc*
    string suffix = 3 [(validate.rules).string = {min_len: 1}];

    // The input string must match the regular expression specified here.
    // The regex grammar is defined `here
    // <https://en.cppreference.com/w/cpp/regex/ecmascript>`_.
    //
    // Examples:
    //
    // * The regex ``\d{3}`` matches the value *123*
    // * The regex ``\d{3}`` does not match the value *1234*
    // * The regex ``\d{3}`` does not match the value *123.456*
    //
    // .. attention::
    //   This field has been deprecated in favor of `safe_regex` as it is not safe for use with
    //   untrusted input in all cases.
    string regex = 4 [
      deprecated = true,
      (validate.rules).string = {max_bytes: 1024},
      (envoy.annotations.disallowed_by_default) = true
    ];

    // The input string must match the regular expression specified here.
    RegexMatcher safe_regex = 5 [(validate.rules).message = {required: true}];
  }

  // If true, indicates the exact/prefix/suffix matching should be case insensitive. This has no
  // effect for the safe_regex match.
  // For example, the matcher *data* will match both input string *Data* and *data* if set to true.
  bool ignore_case = 6;
}

// Specifies a list of ways to match a string.
message ListStringMatcher {
  repeated StringMatcher patterns = 1 [(validate.rules).repeated = {min_items: 1}];
}
syntax = "proto3";

package envoy.type.matcher;

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher";
option java_outer_classname = "RegexProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Regex matcher]

// A regex matcher designed for safety when used with untrusted input.
message RegexMatcher {
  // Google's `RE2 <https://github.com/google/re2>`_ regex engine. The regex string must adhere to
  // the documented `syntax <https://github.com/google/re2/wiki/Syntax>`_. The engine is designed
  // to complete execution in linear time as well as limit the amount of memory used.
  //
  // Envoy supports program size checking via runtime. The runtime keys ``re2.max_program_size.error_level``
  // and ``re2.max_program_size.warn_level`` can be set to integers as the maximum program size or
  // complexity that a compiled regex can have before an exception is thrown or a warning is
  // logged, respectively. ``re2.max_program_size.error_level`` defaults to 100, and
  // ``re2.max_program_size.warn_level`` has no default if unset (will not check/log a warning).
  //
  // Envoy emits two stats for tracking the program size of regexes: the histogram `re2.program_size`,
  // which records the program size, and the counter `re2.exceeded_warn_level`, which is incremented
  // each time the program size exceeds the warn level threshold.
  message GoogleRE2 {
    // This field controls the RE2 "program size" which is a rough estimate of how complex a
    // compiled regex is to evaluate. A regex that has a program size greater than the configured
    // value will fail to compile. In this case, the configured max program size can be increased
    // or the regex can be simplified. If not specified, the default is 100.
    //
    // This field is deprecated; regexp validation should be performed on the management server
    // instead of being done by each individual client.
    google.protobuf.UInt32Value max_program_size = 1 [deprecated = true];
  }

  oneof engine_type {
    option (validate.required) = true;

    // Google's RE2 regex engine.
    GoogleRE2 google_re2 = 1 [(validate.rules).message = {required: true}];
  }

  // The regex match string. The string must be supported by the configured engine.
  string regex = 2 [(validate.rules).string = {min_len: 1}];
}

// Describes how to match a string and then produce a new string using a regular
// expression and a substitution string.
message RegexMatchAndSubstitute {
  // The regular expression used to find portions of a string (hereafter called
  // the "subject string") that should be replaced. When a new string is
  // produced during the substitution operation, the new string is initially
  // the same as the subject string, but then all matches in the subject string
  // are replaced by the substitution string. If replacing all matches isn't
  // desired, regular expression anchors can be used to ensure a single match,
  // so as to replace just one occurrence of a pattern. Capture groups can be
  // used in the pattern to extract portions of the subject string, and then
  // referenced in the substitution string.
  RegexMatcher pattern = 1;

  // The string that should be substituted into matching portions of the
  // subject string during a substitution operation to produce a new string.
  // Capture groups in the pattern can be referenced in the substitution
  // string. Note, however, that the syntax for referring to capture groups is
  // defined by the chosen regular expression engine. Google's `RE2
  // <https://github.com/google/re2>`_ regular expression engine uses a
  // backslash followed by the capture group number to denote a numbered
  // capture group. E.g., ``\1`` refers to capture group 1, and ``\2`` refers
  // to capture group 2.
  string substitution = 2;
}
syntax = "proto3";

package envoy.type.matcher;

import "envoy/type/matcher/string.proto";
import "envoy/type/matcher/struct.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.type.matcher";
option java_outer_classname = "NodeProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Node matcher]

// Specifies the way to match a Node.
// The match follows AND semantics.
message NodeMatcher {
  // Specifies match criteria on the node id.
  StringMatcher node_id = 1;

  // Specifies match criteria on the node metadata.
  repeated StructMatcher node_metadatas = 2;
}
syntax = "proto3";

package envoy.type.matcher;

import "envoy/type/matcher/value.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher";
option java_outer_classname = "StructProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Struct matcher]

// StructMatcher provides a general interface to check if a given value is matched in
// google.protobuf.Struct. It uses `path` to retrieve the value
// from the struct and then check if it's matched to the specified value.
//
// For example, for the following Struct:
//
// .. code-block:: yaml
//
//        fields:
//          a:
//            struct_value:
//              fields:
//                b:
//                  struct_value:
//                    fields:
//                      c:
//                        string_value: pro
//                t:
//                  list_value:
//                    values:
//                      - string_value: m
//                      - string_value: n
//
// The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value "pro"
// from the Metadata which is matched to the specified prefix match.
//
// .. code-block:: yaml
//
//    path:
//    - key: a
//    - key: b
//    - key: c
//    value:
//      string_match:
//        prefix: pr
//
// The following StructMatcher is matched as the code will match one of the string values in the
// list at the path [a, t].
//
// .. code-block:: yaml
//
//    path:
//    - key: a
//    - key: t
//    value:
//      list_match:
//        one_of:
//          string_match:
//            exact: m
//
// An example use of StructMatcher is to match metadata in envoy.v*.core.Node.
message StructMatcher {
  // Specifies the segment in a path to retrieve value from Struct.
  message PathSegment {
    oneof segment {
      option (validate.required) = true;

      // If specified, use the key to retrieve the value in a Struct.
      string key = 1 [(validate.rules).string = {min_len: 1}];
    }
  }

  // The path to retrieve the Value from the Struct.
  repeated PathSegment path = 2 [(validate.rules).repeated = {min_items: 1}];

  // The StructMatcher is matched if the value retrieved by path is matched to this value.
  ValueMatcher value = 3 [(validate.rules).message = {required: true}];
}
syntax = "proto3";

package envoy.type.matcher;

import "envoy/type/matcher/number.proto";
import "envoy/type/matcher/string.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher";
option java_outer_classname = "ValueProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Value matcher]

// Specifies the way to match a ProtobufWkt::Value. Primitive values and ListValue are supported.
// StructValue is not supported and is always not matched.
// [#next-free-field: 7]
message ValueMatcher {
  // NullMatch is an empty message to specify a null value.
  message NullMatch {
  }

  // Specifies how to match a value.
  oneof match_pattern {
    option (validate.required) = true;

    // If specified, a match occurs if and only if the target value is a NullValue.
    NullMatch null_match = 1;

    // If specified, a match occurs if and only if the target value is a double value and is
    // matched to this field.
    DoubleMatcher double_match = 2;

    // If specified, a match occurs if and only if the target value is a string value and is
    // matched to this field.
    StringMatcher string_match = 3;

    // If specified, a match occurs if and only if the target value is a bool value and is equal
    // to this field.
    bool bool_match = 4;

    // If specified, value match will be performed based on whether the path is referring to a
    // valid primitive value in the metadata. If the path is referring to a non-primitive value,
    // the result is always not matched.
    bool present_match = 5;

    // If specified, a match occurs if and only if the target value is a list value and
    // is matched to this field.
    ListMatcher list_match = 6;
  }
}

// Specifies the way to match a list value.
message ListMatcher {
  oneof match_pattern {
    option (validate.required) = true;

    // If specified, at least one of the values in the list must match the value specified.
    ValueMatcher one_of = 1;
  }
}
syntax = "proto3";

package envoy.type.matcher;

import "envoy/type/matcher/value.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher";
option java_outer_classname = "MetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Metadata matcher]

// MetadataMatcher provides a general interface to check if a given value is matched in
// :ref:`Metadata <envoy_api_msg_core.Metadata>`. It uses `filter` and `path` to retrieve the value
// from the Metadata and then check if it's matched to the specified value.
//
// For example, for the following Metadata:
//
// .. code-block:: yaml
//
//    filter_metadata:
//      envoy.filters.http.rbac:
//        fields:
//          a:
//            struct_value:
//              fields:
//                b:
//                  struct_value:
//                    fields:
//                      c:
//                        string_value: pro
//                t:
//                  list_value:
//                    values:
//                      - string_value: m
//                      - string_value: n
//
// The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value "pro"
// from the Metadata which is matched to the specified prefix match.
//
// .. code-block:: yaml
//
//    filter: envoy.filters.http.rbac
//    path:
//    - key: a
//    - key: b
//    - key: c
//    value:
//      string_match:
//        prefix: pr
//
// The following MetadataMatcher is matched as the code will match one of the string values in the
// list at the path [a, t].
//
// .. code-block:: yaml
//
//    filter: envoy.filters.http.rbac
//    path:
//    - key: a
//    - key: t
//    value:
//      list_match:
//        one_of:
//          string_match:
//            exact: m
//
// An example use of MetadataMatcher is specifying additional metadata in envoy.filters.http.rbac to
// enforce access control based on dynamic metadata in a request. See :ref:`Permission
// <envoy_api_msg_config.rbac.v2.Permission>` and :ref:`Principal
// <envoy_api_msg_config.rbac.v2.Principal>`.

// [#next-major-version: MetadataMatcher should use StructMatcher]
message MetadataMatcher {
  // Specifies the segment in a path to retrieve value from Metadata.
  // Note: Currently it's not supported to retrieve a value from a list in Metadata. This means that
  // if the segment key refers to a list, it has to be the last segment in a path.
  message PathSegment {
    oneof segment {
      option (validate.required) = true;

      // If specified, use the key to retrieve the value in a Struct.
      string key = 1 [(validate.rules).string = {min_len: 1}];
    }
  }

  // The filter name to retrieve the Struct from the Metadata.
  string filter = 1 [(validate.rules).string = {min_len: 1}];

  // The path to retrieve the Value from the Struct.
  repeated PathSegment path = 2 [(validate.rules).repeated = {min_items: 1}];

  // The MetadataMatcher is matched if the value retrieved by path is matched to this value.
  ValueMatcher value = 3 [(validate.rules).message = {required: true}];
}
syntax = "proto3";

package envoy.type.matcher.v3;

import "envoy/type/matcher/v3/string.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher.v3";
option java_outer_classname = "PathProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3;matcherv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Path matcher]

// Specifies the way to match a path on HTTP request.
message PathMatcher {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.matcher.PathMatcher";

  oneof rule {
    option (validate.required) = true;

    // The ``path`` must match the URL path portion of the :path header. The query and fragment
    // string (if present) are removed in the URL path portion.
    // For example, the path ``/data`` will match the ``:path`` header ``/data#fragment?param=value``.
    StringMatcher path = 1 [(validate.rules).message = {required: true}];
  }
}
syntax = "proto3";

package envoy.type.matcher.v3;

import "envoy/type/matcher/v3/regex.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher.v3";
option java_outer_classname = "StringProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3;matcherv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: String matcher]

// Specifies the way to match a string.
// [#next-free-field: 8]
message StringMatcher {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.matcher.StringMatcher";

  reserved 4;

  reserved "regex";

  oneof match_pattern {
    option (validate.required) = true;

    // The input string must match exactly the string specified here.
    //
    // Examples:
    //
    // * ``abc`` only matches the value ``abc``.
    string exact = 1;

    // The input string must have the prefix specified here.
    // Note: empty prefix is not allowed, please use regex instead.
    //
    // Examples:
    //
    // * ``abc`` matches the value ``abc.xyz``
    string prefix = 2 [(validate.rules).string = {min_len: 1}];

    // The input string must have the suffix specified here.
    // Note: empty prefix is not allowed, please use regex instead.
    //
    // Examples:
    //
    // * ``abc`` matches the value ``xyz.abc``
    string suffix = 3 [(validate.rules).string = {min_len: 1}];

    // The input string must match the regular expression specified here.
    RegexMatcher safe_regex = 5 [(validate.rules).message = {required: true}];

    // The input string must have the substring specified here.
    // Note: empty contains match is not allowed, please use regex instead.
    //
    // Examples:
    //
    // * ``abc`` matches the value ``xyz.abc.def``
    string contains = 7 [(validate.rules).string = {min_len: 1}];
  }

  // If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. This
  // has no effect for the safe_regex match.
  // For example, the matcher ``data`` will match both input string ``Data`` and ``data`` if set to true.
  bool ignore_case = 6;
}

// Specifies a list of ways to match a string.
message ListStringMatcher {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.type.matcher.ListStringMatcher";

  repeated StringMatcher patterns = 1 [(validate.rules).repeated = {min_items: 1}];
}
syntax = "proto3";

package envoy.type.matcher.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.type.matcher.v3";
option java_outer_classname = "StatusCodeInputProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3;matcherv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common HTTP Inputs]

// Match input indicates that matching should be done on the response status
// code.
message HttpResponseStatusCodeMatchInput {
}

// Match input indicates that the matching should be done on the class of the
// response status code. For eg: 1xx, 2xx, 3xx, 4xx or 5xx.
message HttpResponseStatusCodeClassMatchInput {
}
syntax = "proto3";

package envoy.type.matcher.v3;

import "google/protobuf/wrappers.proto";

import "envoy/annotations/deprecation.proto";
import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher.v3";
option java_outer_classname = "RegexProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3;matcherv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Regex matcher]

// A regex matcher designed for safety when used with untrusted input.
message RegexMatcher {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.matcher.RegexMatcher";

  // Google's `RE2 <https://github.com/google/re2>`_ regex engine. The regex string must adhere to
  // the documented `syntax <https://github.com/google/re2/wiki/Syntax>`_. The engine is designed
  // to complete execution in linear time as well as limit the amount of memory used.
  //
  // Envoy supports program size checking via runtime. The runtime keys ``re2.max_program_size.error_level``
  // and ``re2.max_program_size.warn_level`` can be set to integers as the maximum program size or
  // complexity that a compiled regex can have before an exception is thrown or a warning is
  // logged, respectively. ``re2.max_program_size.error_level`` defaults to 100, and
  // ``re2.max_program_size.warn_level`` has no default if unset (will not check/log a warning).
  //
  // Envoy emits two stats for tracking the program size of regexes: the histogram ``re2.program_size``,
  // which records the program size, and the counter ``re2.exceeded_warn_level``, which is incremented
  // each time the program size exceeds the warn level threshold.
  message GoogleRE2 {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.matcher.RegexMatcher.GoogleRE2";

    // This field controls the RE2 "program size" which is a rough estimate of how complex a
    // compiled regex is to evaluate. A regex that has a program size greater than the configured
    // value will fail to compile. In this case, the configured max program size can be increased
    // or the regex can be simplified. If not specified, the default is 100.
    //
    // This field is deprecated; regexp validation should be performed on the management server
    // instead of being done by each individual client.
    //
    // .. note::
    //
    //  Although this field is deprecated, the program size will still be checked against the
    //  global ``re2.max_program_size.error_level`` runtime value.
    //
    google.protobuf.UInt32Value max_program_size = 1
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];
  }

  oneof engine_type {
    // Google's RE2 regex engine.
    GoogleRE2 google_re2 = 1
        [deprecated = true, (envoy.annotations.deprecated_at_minor_version) = "3.0"];
  }

  // The regex match string. The string must be supported by the configured engine. The regex is matched
  // against the full string, not as a partial match.
  string regex = 2 [(validate.rules).string = {min_len: 1}];
}

// Describes how to match a string and then produce a new string using a regular
// expression and a substitution string.
message RegexMatchAndSubstitute {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.type.matcher.RegexMatchAndSubstitute";

  // The regular expression used to find portions of a string (hereafter called
  // the "subject string") that should be replaced. When a new string is
  // produced during the substitution operation, the new string is initially
  // the same as the subject string, but then all matches in the subject string
  // are replaced by the substitution string. If replacing all matches isn't
  // desired, regular expression anchors can be used to ensure a single match,
  // so as to replace just one occurrence of a pattern. Capture groups can be
  // used in the pattern to extract portions of the subject string, and then
  // referenced in the substitution string.
  RegexMatcher pattern = 1 [(validate.rules).message = {required: true}];

  // The string that should be substituted into matching portions of the
  // subject string during a substitution operation to produce a new string.
  // Capture groups in the pattern can be referenced in the substitution
  // string. Note, however, that the syntax for referring to capture groups is
  // defined by the chosen regular expression engine. Google's `RE2
  // <https://github.com/google/re2>`_ regular expression engine uses a
  // backslash followed by the capture group number to denote a numbered
  // capture group. E.g., ``\1`` refers to capture group 1, and ``\2`` refers
  // to capture group 2.
  string substitution = 2
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];
}
syntax = "proto3";

package envoy.type.matcher.v3;

import "envoy/type/matcher/v3/string.proto";
import "envoy/type/matcher/v3/struct.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.type.matcher.v3";
option java_outer_classname = "NodeProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3;matcherv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Node matcher]

// Specifies the way to match a Node.
// The match follows AND semantics.
message NodeMatcher {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.matcher.NodeMatcher";

  // Specifies match criteria on the node id.
  StringMatcher node_id = 1;

  // Specifies match criteria on the node metadata.
  repeated StructMatcher node_metadatas = 2;
}
syntax = "proto3";

package envoy.type.matcher.v3;

import "envoy/type/matcher/v3/value.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher.v3";
option java_outer_classname = "StructProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3;matcherv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Struct matcher]

// StructMatcher provides a general interface to check if a given value is matched in
// google.protobuf.Struct. It uses ``path`` to retrieve the value
// from the struct and then check if it's matched to the specified value.
//
// For example, for the following Struct:
//
// .. code-block:: yaml
//
//        fields:
//          a:
//            struct_value:
//              fields:
//                b:
//                  struct_value:
//                    fields:
//                      c:
//                        string_value: pro
//                t:
//                  list_value:
//                    values:
//                      - string_value: m
//                      - string_value: n
//
// The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value "pro"
// from the Metadata which is matched to the specified prefix match.
//
// .. code-block:: yaml
//
//    path:
//    - key: a
//    - key: b
//    - key: c
//    value:
//      string_match:
//        prefix: pr
//
// The following StructMatcher is matched as the code will match one of the string values in the
// list at the path [a, t].
//
// .. code-block:: yaml
//
//    path:
//    - key: a
//    - key: t
//    value:
//      list_match:
//        one_of:
//          string_match:
//            exact: m
//
// An example use of StructMatcher is to match metadata in envoy.v*.core.Node.
message StructMatcher {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.matcher.StructMatcher";

  // Specifies the segment in a path to retrieve value from Struct.
  message PathSegment {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.matcher.StructMatcher.PathSegment";

    oneof segment {
      option (validate.required) = true;

      // If specified, use the key to retrieve the value in a Struct.
      string key = 1 [(validate.rules).string = {min_len: 1}];
    }
  }

  // The path to retrieve the Value from the Struct.
  repeated PathSegment path = 2 [(validate.rules).repeated = {min_items: 1}];

  // The StructMatcher is matched if the value retrieved by path is matched to this value.
  ValueMatcher value = 3 [(validate.rules).message = {required: true}];
}
syntax = "proto3";

package envoy.type.matcher.v3;

import "envoy/type/matcher/v3/number.proto";
import "envoy/type/matcher/v3/string.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher.v3";
option java_outer_classname = "ValueProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3;matcherv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Value matcher]

// Specifies the way to match a ProtobufWkt::Value. Primitive values and ListValue are supported.
// StructValue is not supported and is always not matched.
// [#next-free-field: 8]
message ValueMatcher {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.matcher.ValueMatcher";

  // NullMatch is an empty message to specify a null value.
  message NullMatch {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.matcher.ValueMatcher.NullMatch";
  }

  // Specifies how to match a value.
  oneof match_pattern {
    option (validate.required) = true;

    // If specified, a match occurs if and only if the target value is a NullValue.
    NullMatch null_match = 1;

    // If specified, a match occurs if and only if the target value is a double value and is
    // matched to this field.
    DoubleMatcher double_match = 2;

    // If specified, a match occurs if and only if the target value is a string value and is
    // matched to this field.
    StringMatcher string_match = 3;

    // If specified, a match occurs if and only if the target value is a bool value and is equal
    // to this field.
    bool bool_match = 4;

    // If specified, value match will be performed based on whether the path is referring to a
    // valid primitive value in the metadata. If the path is referring to a non-primitive value,
    // the result is always not matched.
    bool present_match = 5;

    // If specified, a match occurs if and only if the target value is a list value and
    // is matched to this field.
    ListMatcher list_match = 6;

    // If specified, a match occurs if and only if any of the alternatives in the match accept the value.
    OrMatcher or_match = 7;
  }
}

// Specifies the way to match a list value.
message ListMatcher {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.matcher.ListMatcher";

  oneof match_pattern {
    option (validate.required) = true;

    // If specified, at least one of the values in the list must match the value specified.
    ValueMatcher one_of = 1;
  }
}

// Specifies a list of alternatives for the match.
message OrMatcher {
  repeated ValueMatcher value_matchers = 1 [(validate.rules).repeated = {min_items: 2}];
}
syntax = "proto3";

package envoy.type.matcher.v3;

import "envoy/type/matcher/v3/string.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher.v3";
option java_outer_classname = "FilterStateProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3;matcherv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Filter state matcher]

// FilterStateMatcher provides a general interface for matching the filter state objects.
message FilterStateMatcher {
  // The filter state key to retrieve the object.
  string key = 1 [(validate.rules).string = {min_len: 1}];

  oneof matcher {
    option (validate.required) = true;

    // Matches the filter state object as a string value.
    StringMatcher string_match = 2;
  }
}
syntax = "proto3";

package envoy.type.matcher.v3;

import "envoy/type/matcher/v3/value.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher.v3";
option java_outer_classname = "MetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3;matcherv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Metadata matcher]

// MetadataMatcher provides a general interface to check if a given value is matched in
// :ref:`Metadata <envoy_v3_api_msg_config.core.v3.Metadata>`. It uses `filter` and `path` to retrieve the value
// from the Metadata and then check if it's matched to the specified value.
//
// For example, for the following Metadata:
//
// .. code-block:: yaml
//
//    filter_metadata:
//      envoy.filters.http.rbac:
//        fields:
//          a:
//            struct_value:
//              fields:
//                b:
//                  struct_value:
//                    fields:
//                      c:
//                        string_value: pro
//                t:
//                  list_value:
//                    values:
//                      - string_value: m
//                      - string_value: n
//
// The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value "pro"
// from the Metadata which is matched to the specified prefix match.
//
// .. code-block:: yaml
//
//    filter: envoy.filters.http.rbac
//    path:
//    - key: a
//    - key: b
//    - key: c
//    value:
//      string_match:
//        prefix: pr
//
// The following MetadataMatcher is matched as the code will match one of the string values in the
// list at the path [a, t].
//
// .. code-block:: yaml
//
//    filter: envoy.filters.http.rbac
//    path:
//    - key: a
//    - key: t
//    value:
//      list_match:
//        one_of:
//          string_match:
//            exact: m
//
// An example use of MetadataMatcher is specifying additional metadata in envoy.filters.http.rbac to
// enforce access control based on dynamic metadata in a request. See :ref:`Permission
// <envoy_v3_api_msg_config.rbac.v3.Permission>` and :ref:`Principal
// <envoy_v3_api_msg_config.rbac.v3.Principal>`.

// [#next-major-version: MetadataMatcher should use StructMatcher]
message MetadataMatcher {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.matcher.MetadataMatcher";

  // Specifies the segment in a path to retrieve value from Metadata.
  // Note: Currently it's not supported to retrieve a value from a list in Metadata. This means that
  // if the segment key refers to a list, it has to be the last segment in a path.
  message PathSegment {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.matcher.MetadataMatcher.PathSegment";

    oneof segment {
      option (validate.required) = true;

      // If specified, use the key to retrieve the value in a Struct.
      string key = 1 [(validate.rules).string = {min_len: 1}];
    }
  }

  // The filter name to retrieve the Struct from the Metadata.
  string filter = 1 [(validate.rules).string = {min_len: 1}];

  // The path to retrieve the Value from the Struct.
  repeated PathSegment path = 2 [(validate.rules).repeated = {min_items: 1}];

  // The MetadataMatcher is matched if the value retrieved by path is matched to this value.
  ValueMatcher value = 3 [(validate.rules).message = {required: true}];

  // If true, the match result will be inverted.
  bool invert = 4;
}
syntax = "proto3";

package envoy.type.matcher.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher.v3";
option java_outer_classname = "HttpInputsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3;matcherv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common HTTP inputs]

// Match input indicates that matching should be done on a specific request header.
// The resulting input string will be all headers for the given key joined by a comma,
// e.g. if the request contains two 'foo' headers with value 'bar' and 'baz', the input
// string will be 'bar,baz'.
// [#comment:TODO(snowp): Link to unified matching docs.]
// [#extension: envoy.matching.inputs.request_headers]
message HttpRequestHeaderMatchInput {
  // The request header to match on.
  string header_name = 1
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false}];
}

// Match input indicates that matching should be done on a specific request trailer.
// The resulting input string will be all headers for the given key joined by a comma,
// e.g. if the request contains two 'foo' headers with value 'bar' and 'baz', the input
// string will be 'bar,baz'.
// [#comment:TODO(snowp): Link to unified matching docs.]
// [#extension: envoy.matching.inputs.request_trailers]
message HttpRequestTrailerMatchInput {
  // The request trailer to match on.
  string header_name = 1
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false}];
}

// Match input indicating that matching should be done on a specific response header.
// The resulting input string will be all headers for the given key joined by a comma,
// e.g. if the response contains two 'foo' headers with value 'bar' and 'baz', the input
// string will be 'bar,baz'.
// [#comment:TODO(snowp): Link to unified matching docs.]
// [#extension: envoy.matching.inputs.response_headers]
message HttpResponseHeaderMatchInput {
  // The response header to match on.
  string header_name = 1
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false}];
}

// Match input indicates that matching should be done on a specific response trailer.
// The resulting input string will be all headers for the given key joined by a comma,
// e.g. if the request contains two 'foo' headers with value 'bar' and 'baz', the input
// string will be 'bar,baz'.
// [#comment:TODO(snowp): Link to unified matching docs.]
// [#extension: envoy.matching.inputs.response_trailers]
message HttpResponseTrailerMatchInput {
  // The response trailer to match on.
  string header_name = 1
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false}];
}

// Match input indicates that matching should be done on a specific query parameter.
// The resulting input string will be the first query parameter for the value
// 'query_param'.
// [#extension: envoy.matching.inputs.query_params]
message HttpRequestQueryParamMatchInput {
  // The query parameter to match on.
  string query_param = 1 [(validate.rules).string = {min_len: 1}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/type/v3:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.type.matcher.v3;

import "envoy/type/v3/range.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher.v3";
option java_outer_classname = "NumberProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3;matcherv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Number matcher]

// Specifies the way to match a double value.
message DoubleMatcher {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.matcher.DoubleMatcher";

  oneof match_pattern {
    option (validate.required) = true;

    // If specified, the input double value must be in the range specified here.
    // Note: The range is using half-open interval semantics [start, end).
    type.v3.DoubleRange range = 1;

    // If specified, the input double value must be equal to the value specified here.
    double exact = 2;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "//envoy/annotations:pkg",
        "//envoy/type:pkg",
        "@com_github_cncf_xds//udpa/annotations:pkg",
    ],
)
syntax = "proto3";

package envoy.type.matcher;

import "envoy/type/range.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.matcher";
option java_outer_classname = "NumberProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/matcher";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Number matcher]

// Specifies the way to match a double value.
message DoubleMatcher {
  oneof match_pattern {
    option (validate.required) = true;

    // If specified, the input double value must be in the range specified here.
    // Note: The range is using half-open interval semantics [start, end).
    DoubleRange range = 1;

    // If specified, the input double value must be equal to the value specified here.
    double exact = 2;
  }
}
syntax = "proto3";

package envoy.type;

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type";
option java_outer_classname = "TokenBucketProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Token bucket]

// Configures a token bucket, typically used for rate limiting.
message TokenBucket {
  // The maximum tokens that the bucket can hold. This is also the number of tokens that the bucket
  // initially contains.
  uint32 max_tokens = 1 [(validate.rules).uint32 = {gt: 0}];

  // The number of tokens added to the bucket during each fill interval. If not specified, defaults
  // to a single token.
  google.protobuf.UInt32Value tokens_per_fill = 2 [(validate.rules).uint32 = {gt: 0}];

  // The fill interval that tokens are added to the bucket. During each fill interval
  // `tokens_per_fill` are added to the bucket. The bucket will never contain more than
  // `max_tokens` tokens.
  google.protobuf.Duration fill_interval = 3 [(validate.rules).duration = {
    required: true
    gt {}
  }];
}
syntax = "proto3";

package envoy.type.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.type.v3";
option java_outer_classname = "HttpProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/v3;typev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP]

enum CodecClientType {
  HTTP1 = 0;

  HTTP2 = 1;

  // [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
  // caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
  // to distinguish HTTP1 and HTTP2 traffic.
  HTTP3 = 2;
}
syntax = "proto3";

package envoy.type.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.v3";
option java_outer_classname = "PercentProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/v3;typev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Percent]

// Identifies a percentage, in the range [0.0, 100.0].
message Percent {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.Percent";

  double value = 1 [(validate.rules).double = {lte: 100.0 gte: 0.0}];
}

// A fractional percentage is used in cases in which for performance reasons performing floating
// point to integer conversions during randomness calculations is undesirable. The message includes
// both a numerator and denominator that together determine the final fractional value.
//
// * **Example**: 1/100 = 1%.
// * **Example**: 3/10000 = 0.03%.
message FractionalPercent {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.FractionalPercent";

  // Fraction percentages support several fixed denominator values.
  enum DenominatorType {
    // 100.
    //
    // **Example**: 1/100 = 1%.
    HUNDRED = 0;

    // 10,000.
    //
    // **Example**: 1/10000 = 0.01%.
    TEN_THOUSAND = 1;

    // 1,000,000.
    //
    // **Example**: 1/1000000 = 0.0001%.
    MILLION = 2;
  }

  // Specifies the numerator. Defaults to 0.
  uint32 numerator = 1;

  // Specifies the denominator. If the denominator specified is less than the numerator, the final
  // fractional percentage is capped at 1 (100%).
  DenominatorType denominator = 2 [(validate.rules).enum = {defined_only: true}];
}
syntax = "proto3";

package envoy.type.v3;

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.v3";
option java_outer_classname = "TokenBucketProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/v3;typev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Token bucket]

// Configures a token bucket, typically used for rate limiting.
message TokenBucket {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.TokenBucket";

  // The maximum tokens that the bucket can hold. This is also the number of tokens that the bucket
  // initially contains.
  uint32 max_tokens = 1 [(validate.rules).uint32 = {gt: 0}];

  // The number of tokens added to the bucket during each fill interval. If not specified, defaults
  // to a single token.
  google.protobuf.UInt32Value tokens_per_fill = 2 [(validate.rules).uint32 = {gt: 0}];

  // The fill interval that tokens are added to the bucket. During each fill interval
  // ``tokens_per_fill`` are added to the bucket. The bucket will never contain more than
  // ``max_tokens`` tokens.
  google.protobuf.Duration fill_interval = 3 [(validate.rules).duration = {
    required: true
    gt {}
  }];
}
syntax = "proto3";

package envoy.type.v3;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.type.v3";
option java_outer_classname = "RatelimitUnitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/v3;typev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Ratelimit Time Unit]

// Identifies the unit of of time for rate limit.
enum RateLimitUnit {
  // The time unit is not known.
  UNKNOWN = 0;

  // The time unit representing a second.
  SECOND = 1;

  // The time unit representing a minute.
  MINUTE = 2;

  // The time unit representing an hour.
  HOUR = 3;

  // The time unit representing a day.
  DAY = 4;

  // The time unit representing a month.
  MONTH = 5;

  // The time unit representing a year.
  YEAR = 6;
}
syntax = "proto3";

package envoy.type.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.type.v3";
option java_outer_classname = "SemanticVersionProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/v3;typev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Semantic version]

// Envoy uses SemVer (https://semver.org/). Major/minor versions indicate
// expected behaviors and APIs, the patch version field is used only
// for security fixes and can be generally ignored.
message SemanticVersion {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.SemanticVersion";

  uint32 major_number = 1;

  uint32 minor_number = 2;

  uint32 patch = 3;
}
syntax = "proto3";

package envoy.type.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.v3";
option java_outer_classname = "HashPolicyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/v3;typev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Hash Policy]

// Specifies the hash policy
message HashPolicy {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.HashPolicy";

  // The source IP will be used to compute the hash used by hash-based load balancing
  // algorithms.
  message SourceIp {
    option (udpa.annotations.versioning).previous_message_type = "envoy.type.HashPolicy.SourceIp";
  }

  // An Object in the :ref:`filterState <arch_overview_data_sharing_between_filters>` will be used
  // to compute the hash used by hash-based load balancing algorithms.
  message FilterState {
    // The name of the Object in the filterState, which is an Envoy::Hashable object. If there is no
    // data associated with the key, or the stored object is not Envoy::Hashable, no hash will be
    // produced.
    string key = 1 [(validate.rules).string = {min_len: 1}];
  }

  oneof policy_specifier {
    option (validate.required) = true;

    SourceIp source_ip = 1;

    FilterState filter_state = 2;
  }
}
syntax = "proto3";

package envoy.type.v3;

import "envoy/type/v3/ratelimit_unit.proto";
import "envoy/type/v3/token_bucket.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.v3";
option java_outer_classname = "RatelimitStrategyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/v3;typev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: Rate Limit Strategies]

message RateLimitStrategy {
  // Choose between allow all and deny all.
  enum BlanketRule {
    ALLOW_ALL = 0;
    DENY_ALL = 1;
  }

  // Best-effort limit of the number of requests per time unit.
  //
  // Allows to specify the desired requests per second (RPS, QPS), requests per minute (QPM, RPM),
  // etc., without specifying a rate limiting algorithm implementation.
  //
  // ``RequestsPerTimeUnit`` strategy does not demand any specific rate limiting algorithm to be
  // used (in contrast to the :ref:`TokenBucket <envoy_v3_api_msg_type.v3.TokenBucket>`,
  // for example). It implies that the implementation details of rate limiting algorithm are
  // irrelevant as long as the configured number of "requests per time unit" is achieved.
  //
  // Note that the ``TokenBucket`` is still a valid implementation of the ``RequestsPerTimeUnit``
  // strategy, and may be chosen to enforce the rate limit. However, there's no guarantee it will be
  // the ``TokenBucket`` in particular, and not the Leaky Bucket, the Sliding Window, or any other
  // rate limiting algorithm that fulfills the requirements.
  message RequestsPerTimeUnit {
    // The desired number of requests per :ref:`time_unit
    // <envoy_v3_api_field_type.v3.RateLimitStrategy.RequestsPerTimeUnit.time_unit>` to allow.
    // If set to ``0``, deny all (equivalent to ``BlanketRule.DENY_ALL``).
    //
    // .. note::
    //   Note that the algorithm implementation determines the course of action for the requests
    //   over the limit. As long as the ``requests_per_time_unit`` converges on the desired value,
    //   it's allowed to treat this field as a soft-limit: allow bursts, redistribute the allowance
    //   over time, etc.
    //
    uint64 requests_per_time_unit = 1;

    // The unit of time. Ignored when :ref:`requests_per_time_unit
    // <envoy_v3_api_field_type.v3.RateLimitStrategy.RequestsPerTimeUnit.requests_per_time_unit>`
    // is ``0`` (deny all).
    RateLimitUnit time_unit = 2 [(validate.rules).enum = {defined_only: true}];
  }

  oneof strategy {
    option (validate.required) = true;

    // Allow or Deny the requests.
    // If unset, allow all.
    BlanketRule blanket_rule = 1 [(validate.rules).enum = {defined_only: true}];

    // Best-effort limit of the number of requests per time unit, f.e. requests per second.
    // Does not prescribe any specific rate limiting algorithm, see :ref:`RequestsPerTimeUnit
    // <envoy_v3_api_msg_type.v3.RateLimitStrategy.RequestsPerTimeUnit>` for details.
    RequestsPerTimeUnit requests_per_time_unit = 2;

    // Limit the requests by consuming tokens from the Token Bucket.
    // Allow the same number of requests as the number of tokens available in
    // the token bucket.
    TokenBucket token_bucket = 3;
  }
}
syntax = "proto3";

package envoy.type.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.v3";
option java_outer_classname = "HttpStatusProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/v3;typev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP status codes]

// HTTP response codes supported in Envoy.
// For more details: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
enum StatusCode {
  // Empty - This code not part of the HTTP status code specification, but it is needed for proto
  // `enum` type.
  Empty = 0;

  Continue = 100;

  OK = 200;

  Created = 201;

  Accepted = 202;

  NonAuthoritativeInformation = 203;

  NoContent = 204;

  ResetContent = 205;

  PartialContent = 206;

  MultiStatus = 207;

  AlreadyReported = 208;

  IMUsed = 226;

  MultipleChoices = 300;

  MovedPermanently = 301;

  Found = 302;

  SeeOther = 303;

  NotModified = 304;

  UseProxy = 305;

  TemporaryRedirect = 307;

  PermanentRedirect = 308;

  BadRequest = 400;

  Unauthorized = 401;

  PaymentRequired = 402;

  Forbidden = 403;

  NotFound = 404;

  MethodNotAllowed = 405;

  NotAcceptable = 406;

  ProxyAuthenticationRequired = 407;

  RequestTimeout = 408;

  Conflict = 409;

  Gone = 410;

  LengthRequired = 411;

  PreconditionFailed = 412;

  PayloadTooLarge = 413;

  URITooLong = 414;

  UnsupportedMediaType = 415;

  RangeNotSatisfiable = 416;

  ExpectationFailed = 417;

  MisdirectedRequest = 421;

  UnprocessableEntity = 422;

  Locked = 423;

  FailedDependency = 424;

  UpgradeRequired = 426;

  PreconditionRequired = 428;

  TooManyRequests = 429;

  RequestHeaderFieldsTooLarge = 431;

  InternalServerError = 500;

  NotImplemented = 501;

  BadGateway = 502;

  ServiceUnavailable = 503;

  GatewayTimeout = 504;

  HTTPVersionNotSupported = 505;

  VariantAlsoNegotiates = 506;

  InsufficientStorage = 507;

  LoopDetected = 508;

  NotExtended = 510;

  NetworkAuthenticationRequired = 511;
}

// HTTP status.
message HttpStatus {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.HttpStatus";

  // Supplies HTTP response code.
  StatusCode code = 1 [(validate.rules).enum = {defined_only: true not_in: 0}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = [
        "@com_github_cncf_xds//udpa/annotations:pkg",
        "@com_github_cncf_xds//xds/annotations/v3:pkg",
    ],
)
syntax = "proto3";

package envoy.type.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";

option java_package = "io.envoyproxy.envoy.type.v3";
option java_outer_classname = "RangeProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/v3;typev3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Range]

// Specifies the int64 start and end of the range using half-open interval semantics [start,
// end).
message Int64Range {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.Int64Range";

  // start of the range (inclusive)
  int64 start = 1;

  // end of the range (exclusive)
  int64 end = 2;
}

// Specifies the int32 start and end of the range using half-open interval semantics [start,
// end).
message Int32Range {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.Int32Range";

  // start of the range (inclusive)
  int32 start = 1;

  // end of the range (exclusive)
  int32 end = 2;
}

// Specifies the double start and end of the range using half-open interval semantics [start,
// end).
message DoubleRange {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.DoubleRange";

  // start of the range (inclusive)
  double start = 1;

  // end of the range (exclusive)
  double end = 2;
}
syntax = "proto3";

package envoy.type;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.type";
option java_outer_classname = "SemanticVersionProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Semantic Version]

// Envoy uses SemVer (https://semver.org/). Major/minor versions indicate
// expected behaviors and APIs, the patch version field is used only
// for security fixes and can be generally ignored.
message SemanticVersion {
  uint32 major_number = 1;

  uint32 minor_number = 2;

  uint32 patch = 3;
}
syntax = "proto3";

package envoy.type.http.v3;

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.http.v3";
option java_outer_classname = "CookieProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/http/v3;httpv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: HTTP cookie API]

// Cookie defines an API for obtaining or generating HTTP cookie.
message Cookie {
  // The name that will be used to obtain cookie value from downstream HTTP request or generate
  // new cookie for downstream.
  string name = 1 [(validate.rules).string = {min_len: 1}];

  // Duration of cookie. This will be used to set the expiry time of a new cookie when it is
  // generated. Set this to 0 to use a session cookie.
  google.protobuf.Duration ttl = 2 [(validate.rules).duration = {gte {}}];

  // Path of cookie. This will be used to set the path of a new cookie when it is generated.
  // If no path is specified here, no path will be set for the cookie.
  string path = 3;
}
syntax = "proto3";

package envoy.type.http.v3;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.http.v3";
option java_outer_classname = "PathTransformationProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/http/v3;httpv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Path Transformations API]

// PathTransformation defines an API to apply a sequence of operations that can be used to alter
// text before it is used for matching or routing. Multiple actions can be applied in the same
// Transformation, forming a sequential pipeline. The transformations will be performed in the order
// that they appear.
//
// This API is a work in progress.

message PathTransformation {
  // A type of operation to alter text.
  message Operation {
    // Should text be normalized according to RFC 3986? This typically is used for path headers
    // before any processing of requests by HTTP filters or routing. This applies percent-encoded
    // normalization and path segment normalization. Fails on characters disallowed in URLs
    // (e.g. NULLs). See `Normalization and Comparison
    // <https://tools.ietf.org/html/rfc3986#section-6>`_ for details of normalization. Note that
    // this options does not perform `case normalization
    // <https://tools.ietf.org/html/rfc3986#section-6.2.2.1>`_
    message NormalizePathRFC3986 {
    }

    // Determines if adjacent slashes are merged into one. A common use case is for a request path
    // header. Using this option in ``:ref: PathNormalizationOptions
    // <envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions>``
    // will allow incoming requests with path ``//dir///file`` to match against route with ``prefix``
    // match set to ``/dir``. When using for header transformations, note that slash merging is not
    // part of `HTTP spec <https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
    message MergeSlashes {
    }

    oneof operation_specifier {
      option (validate.required) = true;

      // Enable path normalization per RFC 3986.
      NormalizePathRFC3986 normalize_path_rfc_3986 = 2;

      // Enable merging adjacent slashes.
      MergeSlashes merge_slashes = 3;
    }
  }

  // A list of operations to apply. Transformations will be performed in the order that they appear.
  repeated Operation operations = 1;
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.type;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type";
option java_outer_classname = "HashPolicyProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Hash Policy]

// Specifies the hash policy
message HashPolicy {
  // The source IP will be used to compute the hash used by hash-based load balancing
  // algorithms.
  message SourceIp {
  }

  oneof policy_specifier {
    option (validate.required) = true;

    SourceIp source_ip = 1;
  }
}
syntax = "proto3";

package envoy.type;

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type";
option java_outer_classname = "HttpStatusProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: HTTP status codes]

// HTTP response codes supported in Envoy.
// For more details: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
enum StatusCode {
  // Empty - This code not part of the HTTP status code specification, but it is needed for proto
  // `enum` type.
  Empty = 0;

  Continue = 100;

  OK = 200;

  Created = 201;

  Accepted = 202;

  NonAuthoritativeInformation = 203;

  NoContent = 204;

  ResetContent = 205;

  PartialContent = 206;

  MultiStatus = 207;

  AlreadyReported = 208;

  IMUsed = 226;

  MultipleChoices = 300;

  MovedPermanently = 301;

  Found = 302;

  SeeOther = 303;

  NotModified = 304;

  UseProxy = 305;

  TemporaryRedirect = 307;

  PermanentRedirect = 308;

  BadRequest = 400;

  Unauthorized = 401;

  PaymentRequired = 402;

  Forbidden = 403;

  NotFound = 404;

  MethodNotAllowed = 405;

  NotAcceptable = 406;

  ProxyAuthenticationRequired = 407;

  RequestTimeout = 408;

  Conflict = 409;

  Gone = 410;

  LengthRequired = 411;

  PreconditionFailed = 412;

  PayloadTooLarge = 413;

  URITooLong = 414;

  UnsupportedMediaType = 415;

  RangeNotSatisfiable = 416;

  ExpectationFailed = 417;

  MisdirectedRequest = 421;

  UnprocessableEntity = 422;

  Locked = 423;

  FailedDependency = 424;

  UpgradeRequired = 426;

  PreconditionRequired = 428;

  TooManyRequests = 429;

  RequestHeaderFieldsTooLarge = 431;

  InternalServerError = 500;

  NotImplemented = 501;

  BadGateway = 502;

  ServiceUnavailable = 503;

  GatewayTimeout = 504;

  HTTPVersionNotSupported = 505;

  VariantAlsoNegotiates = 506;

  InsufficientStorage = 507;

  LoopDetected = 508;

  NotExtended = 510;

  NetworkAuthenticationRequired = 511;
}

// HTTP status.
message HttpStatus {
  // Supplies HTTP response code.
  StatusCode code = 1 [(validate.rules).enum = {defined_only: true not_in: 0}];
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.type;

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.type";
option java_outer_classname = "RangeProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Range]

// Specifies the int64 start and end of the range using half-open interval semantics [start,
// end).
message Int64Range {
  // start of the range (inclusive)
  int64 start = 1;

  // end of the range (exclusive)
  int64 end = 2;
}

// Specifies the int32 start and end of the range using half-open interval semantics [start,
// end).
message Int32Range {
  // start of the range (inclusive)
  int32 start = 1;

  // end of the range (exclusive)
  int32 end = 2;
}

// Specifies the double start and end of the range using half-open interval semantics [start,
// end).
message DoubleRange {
  // start of the range (inclusive)
  double start = 1;

  // end of the range (exclusive)
  double end = 2;
}
syntax = "proto3";

package envoy.type.metadata.v2;

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.metadata.v2";
option java_outer_classname = "MetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/metadata/v2;metadatav2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.type.metadata.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Metadata]

// MetadataKey provides a general interface using `key` and `path` to retrieve value from
// :ref:`Metadata <envoy_api_msg_core.Metadata>`.
//
// For example, for the following Metadata:
//
// .. code-block:: yaml
//
//    filter_metadata:
//      envoy.xxx:
//        prop:
//          foo: bar
//          xyz:
//            hello: envoy
//
// The following MetadataKey will retrieve a string value "bar" from the Metadata.
//
// .. code-block:: yaml
//
//    key: envoy.xxx
//    path:
//    - key: prop
//    - key: foo
//
message MetadataKey {
  // Specifies the segment in a path to retrieve value from Metadata.
  // Currently it is only supported to specify the key, i.e. field name, as one segment of a path.
  message PathSegment {
    oneof segment {
      option (validate.required) = true;

      // If specified, use the key to retrieve the value in a Struct.
      string key = 1 [(validate.rules).string = {min_bytes: 1}];
    }
  }

  // The key name of Metadata to retrieve the Struct from the metadata.
  // Typically, it represents a builtin subsystem or custom extension.
  string key = 1 [(validate.rules).string = {min_bytes: 1}];

  // The path to retrieve the Value from the Struct. It can be a prefix or a full path,
  // e.g. ``[prop, xyz]`` for a struct or ``[prop, foo]`` for a string in the example,
  // which depends on the particular scenario.
  //
  // Note: Due to that only the key type segment is supported, the path can not specify a list
  // unless the list is the last segment.
  repeated PathSegment path = 2 [(validate.rules).repeated = {min_items: 1}];
}

// Describes what kind of metadata.
message MetadataKind {
  // Represents dynamic metadata associated with the request.
  message Request {
  }

  // Represents metadata from :ref:`the route<envoy_api_field_route.Route.metadata>`.
  message Route {
  }

  // Represents metadata from :ref:`the upstream cluster<envoy_api_field_Cluster.metadata>`.
  message Cluster {
  }

  // Represents metadata from :ref:`the upstream
  // host<envoy_api_field_endpoint.LbEndpoint.metadata>`.
  message Host {
  }

  oneof kind {
    option (validate.required) = true;

    // Request kind of metadata.
    Request request = 1;

    // Route kind of metadata.
    Route route = 2;

    // Cluster kind of metadata.
    Cluster cluster = 3;

    // Host kind of metadata.
    Host host = 4;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.type.metadata.v3;

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.type.metadata.v3";
option java_outer_classname = "MetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3;metadatav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Metadata]

// MetadataKey provides a general interface using ``key`` and ``path`` to retrieve value from
// :ref:`Metadata <envoy_v3_api_msg_config.core.v3.Metadata>`.
//
// For example, for the following Metadata:
//
// .. code-block:: yaml
//
//    filter_metadata:
//      envoy.xxx:
//        prop:
//          foo: bar
//          xyz:
//            hello: envoy
//
// The following MetadataKey will retrieve a string value "bar" from the Metadata.
//
// .. code-block:: yaml
//
//    key: envoy.xxx
//    path:
//    - key: prop
//    - key: foo
//
message MetadataKey {
  option (udpa.annotations.versioning).previous_message_type = "envoy.type.metadata.v2.MetadataKey";

  // Specifies the segment in a path to retrieve value from Metadata.
  // Currently it is only supported to specify the key, i.e. field name, as one segment of a path.
  message PathSegment {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.metadata.v2.MetadataKey.PathSegment";

    oneof segment {
      option (validate.required) = true;

      // If specified, use the key to retrieve the value in a Struct.
      string key = 1 [(validate.rules).string = {min_len: 1}];
    }
  }

  // The key name of Metadata to retrieve the Struct from the metadata.
  // Typically, it represents a builtin subsystem or custom extension.
  string key = 1 [(validate.rules).string = {min_len: 1}];

  // The path to retrieve the Value from the Struct. It can be a prefix or a full path,
  // e.g. ``[prop, xyz]`` for a struct or ``[prop, foo]`` for a string in the example,
  // which depends on the particular scenario.
  //
  // Note: Due to that only the key type segment is supported, the path can not specify a list
  // unless the list is the last segment.
  repeated PathSegment path = 2 [(validate.rules).repeated = {min_items: 1}];
}

// Describes what kind of metadata.
message MetadataKind {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.type.metadata.v2.MetadataKind";

  // Represents dynamic metadata associated with the request.
  message Request {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.metadata.v2.MetadataKind.Request";
  }

  // Represents metadata from :ref:`the route<envoy_v3_api_field_config.route.v3.Route.metadata>`.
  message Route {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.metadata.v2.MetadataKind.Route";
  }

  // Represents metadata from :ref:`the upstream cluster<envoy_v3_api_field_config.cluster.v3.Cluster.metadata>`.
  message Cluster {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.metadata.v2.MetadataKind.Cluster";
  }

  // Represents metadata from :ref:`the upstream
  // host<envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>`.
  message Host {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.metadata.v2.MetadataKind.Host";
  }

  oneof kind {
    option (validate.required) = true;

    // Request kind of metadata.
    Request request = 1;

    // Route kind of metadata.
    Route route = 2;

    // Cluster kind of metadata.
    Cluster cluster = 3;

    // Host kind of metadata.
    Host host = 4;
  }
}
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.watchdog.v3;

import "google/protobuf/duration.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.watchdog.v3";
option java_outer_classname = "AbortActionProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/watchdog/v3;watchdogv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Watchdog Action that kills a stuck thread to kill the process.]

// A GuardDogAction that will terminate the process by killing the
// stuck thread. This would allow easier access to the call stack of the stuck
// thread since we would run signal handlers on that thread. By default
// this will be registered to run as the last watchdog action on KILL and
// MULTIKILL events if those are enabled.
message AbortActionConfig {
  // How long to wait for the thread to respond to the thread kill function
  // before killing the process from this action. This is a blocking action.
  // By default this is 5 seconds.
  google.protobuf.Duration wait_duration = 1;
}
This contains watchdog actions that are part of core Envoy, and therefore cannot
be in the extensions directory.
# DO NOT EDIT. This file is generated by tools/proto_format/proto_sync.py.

load("@envoy_api//bazel:api_build_system.bzl", "api_proto_package")

licenses(["notice"])  # Apache 2

api_proto_package(
    deps = ["@com_github_cncf_xds//udpa/annotations:pkg"],
)
syntax = "proto3";

package envoy.api.v2;

import "envoy/api/v2/core/base.proto";

import "google/protobuf/any.proto";
import "google/rpc/status.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.api.v2";
option java_outer_classname = "DiscoveryProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/api/v2;apiv2";
option (udpa.annotations.file_migrate).move_to_package = "envoy.service.discovery.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Common discovery API components]

// A DiscoveryRequest requests a set of versioned resources of the same type for
// a given Envoy node on some API.
// [#next-free-field: 7]
message DiscoveryRequest {
  // The version_info provided in the request messages will be the version_info
  // received with the most recent successfully processed response or empty on
  // the first request. It is expected that no new request is sent after a
  // response is received until the Envoy instance is ready to ACK/NACK the new
  // configuration. ACK/NACK takes place by returning the new API config version
  // as applied or the previous API config version respectively. Each type_url
  // (see below) has an independent version associated with it.
  string version_info = 1;

  // The node making the request.
  core.Node node = 2;

  // List of resources to subscribe to, e.g. list of cluster names or a route
  // configuration name. If this is empty, all resources for the API are
  // returned. LDS/CDS may have empty resource_names, which will cause all
  // resources for the Envoy instance to be returned. The LDS and CDS responses
  // will then imply a number of resources that need to be fetched via EDS/RDS,
  // which will be explicitly enumerated in resource_names.
  repeated string resource_names = 3;

  // Type of the resource that is being requested, e.g.
  // "type.googleapis.com/envoy.api.v2.ClusterLoadAssignment". This is implicit
  // in requests made via singleton xDS APIs such as CDS, LDS, etc. but is
  // required for ADS.
  string type_url = 4;

  // nonce corresponding to DiscoveryResponse being ACK/NACKed. See above
  // discussion on version_info and the DiscoveryResponse nonce comment. This
  // may be empty only if 1) this is a non-persistent-stream xDS such as HTTP,
  // or 2) the client has not yet accepted an update in this xDS stream (unlike
  // delta, where it is populated only for new explicit ACKs).
  string response_nonce = 5;

  // This is populated when the previous :ref:`DiscoveryResponse <envoy_api_msg_DiscoveryResponse>`
  // failed to update configuration. The *message* field in *error_details* provides the Envoy
  // internal exception related to the failure. It is only intended for consumption during manual
  // debugging, the string provided is not guaranteed to be stable across Envoy versions.
  google.rpc.Status error_detail = 6;
}

// [#next-free-field: 7]
message DiscoveryResponse {
  // The version of the response data.
  string version_info = 1;

  // The response resources. These resources are typed and depend on the API being called.
  repeated google.protobuf.Any resources = 2;

  // [#not-implemented-hide:]
  // Canary is used to support two Envoy command line flags:
  //
  // * --terminate-on-canary-transition-failure. When set, Envoy is able to
  //   terminate if it detects that configuration is stuck at canary. Consider
  //   this example sequence of updates:
  //   - Management server applies a canary config successfully.
  //   - Management server rolls back to a production config.
  //   - Envoy rejects the new production config.
  //   Since there is no sensible way to continue receiving configuration
  //   updates, Envoy will then terminate and apply production config from a
  //   clean slate.
  // * --dry-run-canary. When set, a canary response will never be applied, only
  //   validated via a dry run.
  bool canary = 3;

  // Type URL for resources. Identifies the xDS API when muxing over ADS.
  // Must be consistent with the type_url in the 'resources' repeated Any (if non-empty).
  string type_url = 4;

  // For gRPC based subscriptions, the nonce provides a way to explicitly ack a
  // specific DiscoveryResponse in a following DiscoveryRequest. Additional
  // messages may have been sent by Envoy to the management server for the
  // previous version on the stream prior to this DiscoveryResponse, that were
  // unprocessed at response send time. The nonce allows the management server
  // to ignore any further DiscoveryRequests for the previous version until a
  // DiscoveryRequest bearing the nonce. The nonce is optional and is not
  // required for non-stream based xDS implementations.
  string nonce = 5;

  // [#not-implemented-hide:]
  // The control plane instance that sent the response.
  core.ControlPlane control_plane = 6;
}

// DeltaDiscoveryRequest and DeltaDiscoveryResponse are used in a new gRPC
// endpoint for Delta xDS.
//
// With Delta xDS, the DeltaDiscoveryResponses do not need to include a full
// snapshot of the tracked resources. Instead, DeltaDiscoveryResponses are a
// diff to the state of a xDS client.
// In Delta XDS there are per-resource versions, which allow tracking state at
// the resource granularity.
// An xDS Delta session is always in the context of a gRPC bidirectional
// stream. This allows the xDS server to keep track of the state of xDS clients
// connected to it.
//
// In Delta xDS the nonce field is required and used to pair
// DeltaDiscoveryResponse to a DeltaDiscoveryRequest ACK or NACK.
// Optionally, a response message level system_version_info is present for
// debugging purposes only.
//
// DeltaDiscoveryRequest plays two independent roles. Any DeltaDiscoveryRequest
// can be either or both of: [1] informing the server of what resources the
// client has gained/lost interest in (using resource_names_subscribe and
// resource_names_unsubscribe), or [2] (N)ACKing an earlier resource update from
// the server (using response_nonce, with presence of error_detail making it a NACK).
// Additionally, the first message (for a given type_url) of a reconnected gRPC stream
// has a third role: informing the server of the resources (and their versions)
// that the client already possesses, using the initial_resource_versions field.
//
// As with state-of-the-world, when multiple resource types are multiplexed (ADS),
// all requests/acknowledgments/updates are logically walled off by type_url:
// a Cluster ACK exists in a completely separate world from a prior Route NACK.
// In particular, initial_resource_versions being sent at the "start" of every
// gRPC stream actually entails a message for each type_url, each with its own
// initial_resource_versions.
// [#next-free-field: 8]
message DeltaDiscoveryRequest {
  // The node making the request.
  core.Node node = 1;

  // Type of the resource that is being requested, e.g.
  // "type.googleapis.com/envoy.api.v2.ClusterLoadAssignment".
  string type_url = 2;

  // DeltaDiscoveryRequests allow the client to add or remove individual
  // resources to the set of tracked resources in the context of a stream.
  // All resource names in the resource_names_subscribe list are added to the
  // set of tracked resources and all resource names in the resource_names_unsubscribe
  // list are removed from the set of tracked resources.
  //
  // *Unlike* state-of-the-world xDS, an empty resource_names_subscribe or
  // resource_names_unsubscribe list simply means that no resources are to be
  // added or removed to the resource list.
  // *Like* state-of-the-world xDS, the server must send updates for all tracked
  // resources, but can also send updates for resources the client has not subscribed to.
  //
  // NOTE: the server must respond with all resources listed in resource_names_subscribe,
  // even if it believes the client has the most recent version of them. The reason:
  // the client may have dropped them, but then regained interest before it had a chance
  // to send the unsubscribe message. See DeltaSubscriptionStateTest.RemoveThenAdd.
  //
  // These two fields can be set in any DeltaDiscoveryRequest, including ACKs
  // and initial_resource_versions.
  //
  // A list of Resource names to add to the list of tracked resources.
  repeated string resource_names_subscribe = 3;

  // A list of Resource names to remove from the list of tracked resources.
  repeated string resource_names_unsubscribe = 4;

  // Informs the server of the versions of the resources the xDS client knows of, to enable the
  // client to continue the same logical xDS session even in the face of gRPC stream reconnection.
  // It will not be populated: [1] in the very first stream of a session, since the client will
  // not yet have any resources,  [2] in any message after the first in a stream (for a given
  // type_url), since the server will already be correctly tracking the client's state.
  // (In ADS, the first message *of each type_url* of a reconnected stream populates this map.)
  // The map's keys are names of xDS resources known to the xDS client.
  // The map's values are opaque resource versions.
  map<string, string> initial_resource_versions = 5;

  // When the DeltaDiscoveryRequest is a ACK or NACK message in response
  // to a previous DeltaDiscoveryResponse, the response_nonce must be the
  // nonce in the DeltaDiscoveryResponse.
  // Otherwise (unlike in DiscoveryRequest) response_nonce must be omitted.
  string response_nonce = 6;

  // This is populated when the previous :ref:`DiscoveryResponse <envoy_api_msg_DiscoveryResponse>`
  // failed to update configuration. The *message* field in *error_details*
  // provides the Envoy internal exception related to the failure.
  google.rpc.Status error_detail = 7;
}

// [#next-free-field: 7]
message DeltaDiscoveryResponse {
  // The version of the response data (used for debugging).
  string system_version_info = 1;

  // The response resources. These are typed resources, whose types must match
  // the type_url field.
  repeated Resource resources = 2;

  // field id 3 IS available!

  // Type URL for resources. Identifies the xDS API when muxing over ADS.
  // Must be consistent with the type_url in the Any within 'resources' if 'resources' is non-empty.
  string type_url = 4;

  // Resources names of resources that have be deleted and to be removed from the xDS Client.
  // Removed resources for missing resources can be ignored.
  repeated string removed_resources = 6;

  // The nonce provides a way for DeltaDiscoveryRequests to uniquely
  // reference a DeltaDiscoveryResponse when (N)ACKing. The nonce is required.
  string nonce = 5;
}

message Resource {
  // The resource's name, to distinguish it from others of the same type of resource.
  string name = 3;

  // The aliases are a list of other names that this resource can go by.
  repeated string aliases = 4;

  // The resource level version. It allows xDS to track the state of individual
  // resources.
  string version = 1;

  // The resource being tracked.
  google.protobuf.Any resource = 2;
}
syntax = "proto3";

package envoy.api.v2.cluster;

import "google/protobuf/any.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.api.v2.cluster";
option java_outer_classname = "FilterProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/api/v2/cluster";
option csharp_namespace = "Envoy.Api.V2.ClusterNS";
option ruby_package = "Envoy::Api::V2::ClusterNS";
option (udpa.annotations.file_migrate).move_to_package = "envoy.config.cluster.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Upstream filters]
// Upstream filters apply to the connections to the upstream cluster hosts.

message Filter {
  // The name of the filter to instantiate. The name must match a
  // :ref:`supported filter <config_network_filters>`.
  string name = 1 [(validate.rules).string = {min_bytes: 1}];

  // Filter specific configuration which depends on the filter being
  // instantiated. See the supported filters for further documentation.
  google.protobuf.Any typed_config = 2;
}
syntax = "proto3";

package envoy.api.v2.cluster;

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/migrate.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.api.v2.cluster";
option java_outer_classname = "OutlierDetectionProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/api/v2/cluster";
option csharp_namespace = "Envoy.Api.V2.ClusterNS";
option ruby_package = "Envoy::Api::V2::ClusterNS";
option (udpa.annotations.file_migrate).move_to_package = "envoy.config.cluster.v3";
option (udpa.annotations.file_status).package_version_status = FROZEN;

// [#protodoc-title: Outlier detection]

// See the :ref:`architecture overview <arch_overview_outlier_detection>` for
// more information on outlier detection.
// [#next-free-field: 21]
message OutlierDetection {
  // The number of consecutive server-side error responses (for HTTP traffic,
  // 5xx responses; for TCP traffic, connection failures; for Redis, failure to
  // respond PONG; etc.) before a consecutive 5xx ejection occurs. Defaults to 5.
  google.protobuf.UInt32Value consecutive_5xx = 1;

  // The time interval between ejection analysis sweeps. This can result in
  // both new ejections as well as hosts being returned to service. Defaults
  // to 10000ms or 10s.
  google.protobuf.Duration interval = 2 [(validate.rules).duration = {gt {}}];

  // The base time that a host is ejected for. The real time is equal to the
  // base time multiplied by the number of times the host has been ejected.
  // Defaults to 30000ms or 30s.
  google.protobuf.Duration base_ejection_time = 3 [(validate.rules).duration = {gt {}}];

  // The maximum % of an upstream cluster that can be ejected due to outlier
  // detection. Defaults to 10% but will eject at least one host regardless of the value.
  google.protobuf.UInt32Value max_ejection_percent = 4 [(validate.rules).uint32 = {lte: 100}];

  // The % chance that a host will be actually ejected when an outlier status
  // is detected through consecutive 5xx. This setting can be used to disable
  // ejection or to ramp it up slowly. Defaults to 100.
  google.protobuf.UInt32Value enforcing_consecutive_5xx = 5 [(validate.rules).uint32 = {lte: 100}];

  // The % chance that a host will be actually ejected when an outlier status
  // is detected through success rate statistics. This setting can be used to
  // disable ejection or to ramp it up slowly. Defaults to 100.
  google.protobuf.UInt32Value enforcing_success_rate = 