``, ``upstream_request_attempt_count``, ``connection_termination_details`` and tls ``ja3`` field in the
    grpc access log and also log the tls ``sni`` and ``ja3`` field in the grpc access log when envoy is configured as a tls
    forward proxy.
- area: grpc_json_transcoder
  change: |
    added support for parsing enum value case insensitively enabled by the config :ref:`case_insensitive_enum_parsing
    <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.case_insensitive_enum_parsing>`.
- area: grpc_json_transcoder
  change: |
    added support for newline-delimited streams in :ref:`stream_newline_delimited
    <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.PrintOptions.stream_newline_delimited>`.
- area: grpc_stats
  change: |
    added support for replacing dots of gRPC service name with underscores in the gRPC stats by the config
    :ref:`replace_dots_in_grpc_service_name
    <envoy_v3_api_field_extensions.filters.http.grpc_stats.v3.FilterConfig.replace_dots_in_grpc_service_name>`.
- area: http
  change: |
    Added :ref:`HeaderBasedSessionState
    <envoy_v3_api_msg_extensions.http.stateful_session.header.v3.HeaderBasedSessionState>` to manage :ref:`StatefulSession
    State <envoy_v3_api_msg_extensions.filters.http.stateful_session.v3.StatefulSession>` via request/response header.

deprecated:
- area: http
  change: |
    deprecated :ref:`append <envoy_v3_api_field_config.core.v3.HeaderValueOption.append>` and please use :ref:`append_action
    <envoy_v3_api_field_config.core.v3.HeaderValueOption.append_action>` first.
- area: router
  change: |
    deprecated :ref:`total weight <envoy_v3_api_field_config.route.v3.WeightedCluster.total_weight>` for weighted clusters.
    The sum of the :ref:`clusters' weights <envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.weight>` will
    be used as the total weight.
- area: cors
  change: |
    deprecated :ref:`cors field of virtual host <envoy_v3_api_field_config.route.v3.VirtualHost.cors>` and :ref:`cors field
    of route action <envoy_v3_api_field_config.route.v3.RouteAction.cors>`. Please use
    :ref:`VirtualHost.typed_per_filter_config <envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`,
    :ref:`Route.typed_per_filter_config <envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>` or
    :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config
    <envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>` to configure the CORS HTTP
    filter by the type :ref:`CorsPolicy in filter <envoy_v3_api_msg_extensions.filters.http.cors.v3.CorsPolicy>`.
date: September 29, 2020

changes:
- area: docs
  change: |
    fix docs for v1.15.1.
date: July 21, 2022

bug_fixes:
- area: docker
  change: |
    update Docker images (``distroless`` -> ``49d2923f35d6``) to resolve CVE issues in container packages.
date: October 31, 2019

changes:
- area: access log
  change: |
    added a new flag for :ref:`downstream protocol error
    <envoy_api_field_data.accesslog.v2.ResponseFlags.downstream_protocol_error>`.
- area: access log
  change: |
    added :ref:`buffering <envoy_api_field_config.accesslog.v2.CommonGrpcAccessLogConfig.buffer_size_bytes>` and
    :ref:`periodical flushing <envoy_api_field_config.accesslog.v2.CommonGrpcAccessLogConfig.buffer_flush_interval>` support
    to gRPC access logger. Defaults to 16KB buffer and flushing every 1 second.
- area: access log
  change: |
    added DOWNSTREAM_DIRECT_REMOTE_ADDRESS and DOWNSTREAM_DIRECT_REMOTE_ADDRESS_WITHOUT_PORT :ref:`access log formatters
    <config_access_log_format>` and gRPC access logger.
- area: access log
  change: |
    gRPC Access Log Service (ALS) support added for :ref:`TCP access logs
    <envoy_api_msg_config.accesslog.v2.TcpGrpcAccessLogConfig>`.
- area: access log
  change: |
    reintroduced :ref:`filesystem <filesystem_stats>` stats and added the ``write_failed`` counter to track failed log
    writes.
- area: admin
  change: |
    added ability to configure listener :ref:`socket options <envoy_api_field_config.bootstrap.v2.Admin.socket_options>`.
- area: admin
  change: |
    added config dump support for Secret Discovery Service :ref:`SecretConfigDump
    <envoy_api_msg_admin.v2alpha.SecretsConfigDump>`.
- area: admin
  change: |
    added support for :ref:`draining <operations_admin_interface_drain>` listeners via admin interface.
- area: admin
  change: |
    added :http:get:`/stats/recentlookups`, :http:post:`/stats/recentlookups/clear`,
    :http:post:`/stats/recentlookups/disable`, and :http:post:`/stats/recentlookups/enable` endpoints.
- area: api
  change: |
    added :ref:`set_node_on_first_message_only <envoy_api_field_core.ApiConfigSource.set_node_on_first_message_only>` option
    to omit the node identifier from the subsequent discovery requests on the same stream.
- area: buffer filter
  change: |
    now populates content-length header if not present. This behavior can be temporarily disabled using the runtime feature
    ``envoy.reloadable_features.buffer_filter_populate_content_length``.
- area: build
  change: |
    official released binary is now PIE so it can be run with ASLR.
- area: config
  change: |
    added support for :ref:`delta xDS <arch_overview_dynamic_config_delta>` (including ADS) delivery.
- area: config
  change: |
    enforcing that terminal filters (e.g. HttpConnectionManager for L4, router for L7) be the last in their respective
    filter chains.
- area: config
  change: |
    added access log :ref:`extension filter <envoy_api_field_config.filter.accesslog.v2.AccessLogFilter.extension_filter>`.
- area: config
  change: |
    added support for :option:`--reject-unknown-dynamic-fields`, providing independent control over whether unknown fields
    are rejected in static and dynamic configuration. By default, unknown fields in static configuration are rejected and
    are allowed in dynamic configuration. Warnings are logged for the first use of any unknown field and these occurrences
    are counted in the :ref:`server.static_unknown_fields <server_statistics>` and :ref:`server.dynamic_unknown_fields
    <server_statistics>` statistics.
- area: config
  change: |
    added async data access for local and remote data sources.
- area: config
  change: |
    changed the default value of :ref:`initial_fetch_timeout <envoy_api_field_core.ConfigSource.initial_fetch_timeout>` from
    0s to 15s. This is a change in behaviour in the sense that Envoy will move to the next initialization phase, even if the
    first config is not delivered in 15s. Refer to :ref:`initialization process <arch_overview_initialization>` for more
    details.
- area: config
  change: |
    added stat :ref:`init_fetch_timeout <config_cluster_manager_cds>`.
- area: config
  change: |
    tls_context in Cluster and FilterChain are deprecated in favor of transport socket. See :ref:`deprecated documentation
    <deprecated>` for more information.
- area: csrf
  change: |
    added PATCH to supported methods.
- area: dns
  change: |
    added support for configuring :ref:`dns_failure_refresh_rate <envoy_api_field_Cluster.dns_failure_refresh_rate>` to set
    the DNS refresh rate during failures.
- area: ext_authz
  change: |
    added :ref:`configurable ability <envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.metadata_context_namespaces>`
    to send dynamic metadata to the ``ext_authz`` service.
- area: ext_authz
  change: |
    added :ref:`filter_enabled RuntimeFractionalPercent flag
    <envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.filter_enabled>` to filter.
- area: ext_authz
  change: |
    added tracing to the HTTP client.
- area: ext_authz
  change: |
    deprecated :ref:`cluster scope stats <config_http_filters_ext_authz_stats>` in favour of filter scope stats.
- area: fault
  change: |
    added overrides for default runtime keys in :ref:`HTTPFault <envoy_api_msg_config.filter.http.fault.v2.HTTPFault>`
    filter.
- area: grpc
  change: |
    added :ref:`AWS IAM grpc credentials extension <envoy_api_file_envoy/config/grpc_credential/v2alpha/aws_iam.proto>` for
    AWS-managed xDS.
- area: grpc
  change: |
    added :ref:`gRPC stats filter <config_http_filters_grpc_stats>` for collecting stats about gRPC calls and streaming
    message counts.
- area: grpc-json
  change: |
    added support for :ref:`ignoring unknown query parameters
    <envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.ignore_unknown_query_parameters>`.
- area: grpc-json
  change: |
    added support for :ref:`the grpc-status-details-bin header
    <envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.convert_grpc_status>`.
- area: header to metadata
  change: |
    added :ref:`PROTOBUF_VALUE
    <envoy_api_enum_value_config.filter.http.header_to_metadata.v2.Config.ValueType.PROTOBUF_VALUE>` and :ref:`ValueEncode
    <envoy_api_enum_config.filter.http.header_to_metadata.v2.Config.ValueEncode>` to support protobuf Value and Base64
    encoding.
- area: http
  change: |
    added a default one hour idle timeout to upstream and downstream connections. HTTP connections with no streams and no
    activity will be closed after one hour unless the default idle_timeout is overridden. To disable upstream idle timeouts,
    set the :ref:`idle_timeout <envoy_api_field_core.HttpProtocolOptions.idle_timeout>` to zero in Cluster
    :ref:`http_protocol_options <envoy_api_field_Cluster.common_http_protocol_options>`. To disable downstream idle
    timeouts, either set :ref:`idle_timeout <envoy_api_field_core.HttpProtocolOptions.idle_timeout>` to zero in the
    HttpConnectionManager :ref:`common_http_protocol_options
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.common_http_protocol_options>`
    or set the deprecated :ref:`connection manager
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.idle_timeout>` field to zero.
- area: http
  change: |
    added the ability to format HTTP/1.1 header keys using :ref:`header_key_format
    <envoy_api_field_core.Http1ProtocolOptions.header_key_format>`.
- area: http
  change: |
    added the ability to reject HTTP/1.1 requests with invalid HTTP header values, using the runtime feature
    ``envoy.reloadable_features.strict_header_validation``.
- area: http
  change: |
    changed Envoy to forward existing x-forwarded-proto from upstream trusted proxies. Guarded by
    ``envoy.reloadable_features.trusted_forwarded_proto`` which defaults true.
- area: http
  change: |
    added the ability to configure the behavior of the server response header, via the :ref:`server_header_transformation
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.server_header_transformation>`
    field.
- area: http
  change: |
    added the ability to :ref:`merge adjacent slashes
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.merge_slashes>` in the path.
- area: http
  change: |
    :ref:`AUTO <envoy_api_enum_value_config.filter.network.http_connection_manager.v2.HttpConnectionManager.CodecType.AUTO>`
    codec protocol inference now requires the H2 magic bytes to be the first bytes transmitted by a downstream client.
- area: http
  change: |
    remove h2c upgrade headers for HTTP/1 as h2c upgrades are currently not supported.
- area: http
  change: |
    absolute URL support is now on by default. The prior behavior can be reinstated by setting :ref:`allow_absolute_url
    <envoy_api_field_core.Http1ProtocolOptions.allow_absolute_url>` to false.
- area: http
  change: |
    support :ref:`host rewrite <envoy_api_msg_config.filter.http.dynamic_forward_proxy.v2alpha.PerRouteConfig>` in the
    dynamic forward proxy.
- area: http
  change: |
    support :ref:`disabling the filter per route
    <envoy_api_msg_config.filter.http.grpc_http1_reverse_bridge.v2alpha1.FilterConfigPerRoute>` in the grpc http1 reverse
    bridge filter.
- area: http
  change: |
    added the ability to :ref:`configure max connection duration
    <envoy_api_field_core.HttpProtocolOptions.max_connection_duration>` for downstream connections.
- area: listeners
  change: |
    added :ref:`continue_on_listener_filters_timeout <envoy_api_field_Listener.continue_on_listener_filters_timeout>` to
    configure whether a listener will still create a connection when listener filters time out.
- area: listeners
  change: |
    added :ref:`HTTP inspector listener filter <config_listener_filters_http_inspector>`.
- area: listeners
  change: |
    added :ref:`connection balancer <envoy_api_field_Listener.connection_balance_config>` configuration for TCP listeners.
- area: listeners
  change: |
    listeners now close the listening socket as part of the draining stage as soon as workers stop accepting their
    connections.
- area: lua
  change: |
    extended ``httpCall()`` and ``respond()`` APIs to accept headers with entry values that can be a string or table of
    strings.
- area: lua
  change: |
    extended ``dynamicMetadata:set()`` to allow setting complex values.
- area: metrics_service
  change: |
    added support for flushing histogram buckets.
- area: outlier_detector
  change: |
    added :ref:`support for the grpc-status response header <arch_overview_outlier_detection_grpc>` by mapping it to HTTP
    status. Guarded by envoy.reloadable_features.outlier_detection_support_for_grpc_status which defaults to true.
- area: performance
  change: |
    new buffer implementation enabled by default (to disable add "--use-libevent-buffers 1" to the command-line arguments
    when starting Envoy).
- area: performance
  change: |
    stats symbol table implementation (disabled by default; to test it, add "--use-fake-symbol-table 0" to the command-line
    arguments when starting Envoy).
- area: rbac
  change: |
    added support for DNS SAN as :ref:`principal_name
    <envoy_api_field_config.rbac.v2.Principal.Authenticated.principal_name>`.
- area: redis
  change: |
    added :ref:`enable_command_stats
    <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.enable_command_stats>` to enable
    :ref:`per command statistics <arch_overview_redis_cluster_command_stats>` for upstream clusters.
- area: redis
  change: |
    added :ref:`read_policy <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.read_policy>`
    to allow reading from redis replicas for Redis Cluster deployments.
- area: redis
  change: |
    fixed a bug where the redis health checker ignored the upstream auth password.
- area: redis
  change: |
    enable_hashtaging is always enabled when the upstream uses open source Redis cluster protocol.
- area: regex
  change: |
    introduced new :ref:`RegexMatcher <envoy_api_msg_type.matcher.RegexMatcher>` type that provides a safe regex
    implementation for untrusted user input. This type is now used in all configuration that processes user provided input.
    See :ref:`deprecated configuration details <deprecated>` for more information.
- area: rbac
  change: |
    added conditions to the policy, see :ref:`condition <envoy_api_field_config.rbac.v2.Policy.condition>`.
- area: router
  change: |
    added :ref:`rq_retry_skipped_request_not_complete <config_http_filters_router_stats>` counter stat to router stats.
- area: router
  change: |
    :ref:`scoped routing <arch_overview_http_routing_route_scope>` is supported.
- area: router
  change: |
    added new :ref:`retriable-headers <config_http_filters_router_x-envoy-retry-on>` retry policy. Retries can now be
    configured to trigger by arbitrary response header matching.
- area: router
  change: |
    added ability for most specific header mutations to take precedence, see :ref:`route configuration's most specific
    header mutations wins flag <envoy_api_field_RouteConfiguration.most_specific_header_mutations_wins>`.
- area: router
  change: |
    added :ref:`respect_expected_rq_timeout
    <envoy_api_field_config.filter.http.router.v2.Router.respect_expected_rq_timeout>` that instructs ingress Envoy to
    respect :ref:`config_http_filters_router_x-envoy-expected-rq-timeout-ms` header, populated by egress Envoy, when
    deriving timeout for upstream cluster.
- area: router
  change: |
    added new :ref:`retriable request headers <envoy_api_field_route.Route.per_request_buffer_limit_bytes>` to route
    configuration, to allow limiting buffering for retries and shadowing.
- area: router
  change: |
    added new :ref:`retriable request headers <envoy_api_field_route.RetryPolicy.retriable_request_headers>` to retry
    policies. Retries can now be configured to only trigger on request header match.
- area: router
  change: |
    added the ability to match a route based on whether a TLS certificate has been :ref:`presented
    <envoy_api_field_route.RouteMatch.TlsContextMatchOptions.presented>` by the downstream connection.
- area: router check tool
  change: |
    added coverage reporting & enforcement.
- area: router check tool
  change: |
    added comprehensive coverage reporting.
- area: router check tool
  change: |
    added deprecated field check.
- area: router check tool
  change: |
    added flag for only printing results of failed tests.
- area: router check tool
  change: |
    added support for outputting missing tests in the detailed coverage report.
- area: router check tool
  change: |
    added coverage reporting for direct response routes.
- area: runtime
  change: |
    allows for the ability to parse boolean values.
- area: runtime
  change: |
    allows for the ability to parse integers as double values and vice-versa.
- area: sds
  change: |
    added :ref:`session_ticket_keys_sds_secret_config
    <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys_sds_secret_config>` for loading TLS Session Ticket
    Encryption Keys using SDS API.
- area: server
  change: |
    added a post initialization lifecycle event, in addition to the existing startup and shutdown events.
- area: server
  change: |
    added :ref:`per-handler listener stats <config_listener_stats_per_handler>` and :ref:`per-worker watchdog stats
    <operations_performance_watchdog>` to help diagnosing event loop imbalance and general performance issues.
- area: stats
  change: |
    added unit support to histogram.
- area: tcp_proxy
  change: |
    the default :ref:`idle_timeout <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.idle_timeout>` is now 1
    hour.
- area: thrift_proxy
  change: |
    fixed crashing bug on invalid transport/protocol framing.
- area: thrift_proxy
  change: |
    added support for stripping service name from method when using the multiplexed protocol.
- area: tls
  change: |
    added verification of IP address SAN fields in certificates against configured SANs in the certificate validation
    context.
- area: tracing
  change: |
    added support to the Zipkin reporter for sending list of spans as Zipkin JSON v2 and protobuf message over HTTP.
    certificate validation context.
- area: tracing
  change: |
    added tags for gRPC response status and message.
- area: tracing
  change: |
    added :ref:`max_path_tag_length
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.tracing>` to support customizing
    the length of the request path included in the extracted `http.url
    <https://github.com/opentracing/specification/blob/master/semantic_conventions.md#standard-span-tags-and-log-fields>`_
    tag.
- area: upstream
  change: |
    added :ref:`an option <envoy_api_field_Cluster.CommonLbConfig.close_connections_on_host_set_change>` that allows
    draining HTTP, TCP connection pools on cluster membership change.
- area: upstream
  change: |
    added :ref:`transport_socket_matches <envoy_api_field_Cluster.transport_socket_matches>`, support using different
    transport socket config when connecting to different upstream endpoints within a cluster.
- area: upstream
  change: |
    added network filter chains to upstream connections, see :ref:`filters <envoy_api_field_Cluster.filters>`.
- area: upstream
  change: |
    added new :ref:`failure-percentage based outlier detection <arch_overview_outlier_detection_failure_percentage>` mode.
- area: upstream
  change: |
    uses p2c to select hosts for least-requests load balancers if all host weights are the same, even in cases where weights
    are not equal to 1.
- area: upstream
  change: |
    added :ref:`fail_traffic_on_panic <envoy_api_field_Cluster.CommonLbConfig.ZoneAwareLbConfig.fail_traffic_on_panic>` to
    allow failing all requests to a cluster during panic state.
- area: zookeeper
  change: |
    parses responses and emits latency stats.

deprecated:
- area: load_balancing
  change: |
    The ``ORIGINAL_DST_LB`` :ref:`load balancing policy <envoy_api_field_Cluster.lb_policy>` is deprecated, use
    CLUSTER_PROVIDED policy instead when configuring an :ref:`original destination cluster <envoy_api_field_Cluster.type>`.
- area: matching
  change: |
    The ``regex`` field in :ref:`StringMatcher <envoy_api_msg_type.matcher.StringMatcher>` has been deprecated in favor of
    the ``safe_regex`` field.
- area: routing
  change: |
    The ``regex`` field in :ref:`RouteMatch <envoy_api_msg_route.RouteMatch>` has been deprecated in favor of the
    ``safe_regex`` field.
- area: cors
  change: |
    The ``allow_origin`` and ``allow_origin_regex`` fields in :ref:`CorsPolicy <envoy_api_msg_route.CorsPolicy>` have been
    deprecated in favor of the ``allow_origin_string_match`` field.
- area: cluster
  change: |
    The ``pattern`` and ``method`` fields in :ref:`VirtualCluster <envoy_api_msg_route.VirtualCluster>` have been deprecated
    in favor of the ``headers`` field.
- area: matching
  change: |
    The ``regex_match`` field in :ref:`HeaderMatcher <envoy_api_msg_route.HeaderMatcher>` has been deprecated in favor of
    the ``safe_regex_match`` field.
- area: matching
  change: |
    The ``value`` and ``regex`` fields in :ref:`QueryParameterMatcher <envoy_api_msg_route.QueryParameterMatcher>` has been
    deprecated in favor of the ``string_match`` and ``present_match`` fields.
- area: options
  change: |
    The :option:`--allow-unknown-fields` command-line option, use :option:`--allow-unknown-static-fields` instead.
- area: zipkin
  change: |
    The use of ``HTTP_JSON_V1`` :ref:`Zipkin collector endpoint version
    <envoy_api_field_config.trace.v2.ZipkinConfig.collector_endpoint_version>` or not explicitly specifying it is
    deprecated, use ``HTTP_JSON`` or ``HTTP_PROTO`` instead.
- area: listener
  change: |
    The ``operation_name`` field in :ref:`HTTP connection manager
    <envoy_api_msg_config.filter.network.http_connection_manager.v2.HttpConnectionManager>` has been deprecated in favor of
    the ``traffic_direction`` field in :ref:`Listener <envoy_api_msg_Listener>`. The latter takes priority if specified.
- area: tls
  change: |
    The ``tls_context`` field in :ref:`Filter chain <envoy_api_field_listener.FilterChain.tls_context>` message and
    :ref:`Cluster <envoy_api_field_Cluster.tls_context>` message have been deprecated in favor of ``transport_socket`` with
    name ``envoy.transport_sockets.tls``. The latter takes priority if specified.
- area: health_check
  change: |
    The ``use_http2`` field in :ref:`HTTP health checker <envoy_api_msg_core.HealthCheck.HttpHealthCheck>` has been
    deprecated in favor of the ``codec_client_type`` field.
- area: grpc
  change: |
    The use of :ref:`gRPC bridge filter <config_http_filters_grpc_bridge>` for gRPC stats has been deprecated in favor of
    the dedicated :ref:`gRPC stats filter <config_http_filters_grpc_stats>`.
- area: ext_authz
  change: |
    Ext_authz filter stats ``ok``, ``error``, ``denied``, ``failure_mode_allowed`` in ``cluster.<route target
    cluster>.ext_authz.`` namespace is deprecated. Use ``http.<stat_prefix>.ext_authz.`` namespace to access same counters
    instead.
- area: udpa
  change: |
    Use of ``google.protobuf.Struct`` for extension opaque configs is deprecated. Use ``google.protobuf.Any`` instead or
    pack ``udpa.type.v1.TypedStruct`` in ``google.protobuf.Any``.
date: October 17, 2022

bug_fixes:
- area: lua
  change: |
    fixed a bug causing response headers set by a Lua script to not be sent in the response
    (https://github.com/envoyproxy/envoy/issues/22401). This bug was introduced in Envoy v1.23.0.
date: April 25, 2023

bug_fixes:
- area: tls
  change: |
    Fix build FIPS compliance when using both FIPS mode and Wasm extensions (``--define boringssl=fips`` and ``--define wasm=v8``).
date: July 7, 2020

changes:
- area: tls
  change: |
    fixed a bug where wilcard matching for "\*.foo.com" also matched domains of the form "a.b.foo.com". This behavior can be
    temporarily reverted by setting runtime feature ``envoy.reloadable_features.fix_wildcard_matching`` to false.
date: November 30, 2022

bug_fixes:
- area: ci
  change: |
    assorted fixes.
- area: dependencies
  change: |
    update curl, kafka, wasm to mitigate CVEs.
- area: docker
  change: |
    update Docker images (``distroless`` -> ``4b22ca3c6``) to resolve CVE issues in container packages.
**Summary of changes**:

* Envoy Mobile can now be built without C++ exceptions using the `--define=envoy_exceptions=disabled` Bazel flag.
* Add the logical `OR` operation to value matchers.
* Add xDS support for Envoy Mobile Android (AAR) library.
* Add configurable HTTP status when a global rate limit service fails.
* Opentelemetry tracer: add support for environment resource detector.
* Added HTTP basic auth extension.
* Add support for ext_authz to send route metadata.
* Allow per route body buffering configuration in ext_authz.
* Datadog: honor extracted sampling decisions to avoid dropping samples.
* gRPC side streams: make idle connection timeout configurable.
* Support CEL expressions in ext_proc for extraction of request or response atributes.
* HTTP: clear hop by hop `Transfer-Encoding` header.
* Redis: Add support for the `WATCH` and `GETDEL` commands.
* Adds strict mode for stateful session filter, that rejects requests if destination host is not available.
* Internal redirects: support passing headers from response to request.
* Add implementation of the `drop_overload` Cluster API.
* HTTP/2: discard the `Host` header when `:authority` is present.
* grpc_http1_bridge: add `<ignore_query_params>` option.
* Access Log: Add `EMIT_TIME` command operator.
* ECDS now supports composite filter.
* Enable new oghttp2 codec for HTTP/2 connections.
date: May 11, 2021

new_features:
- area: http
  change: |
    added the ability to :ref:`unescape slash sequences
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.path_with_escaped_slashes_action>`
    in the path. Requests with unescaped slashes can be proxied, rejected or redirected to the new unescaped path. By
    default this feature is disabled. The default behavior can be overridden through
    :ref:`http_connection_manager.path_with_escaped_slashes_action
    <config_http_conn_man_runtime_path_with_escaped_slashes_action>` runtime variable. This action can be selectively
    enabled for a portion of requests by setting the :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling
    <config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled>` runtime variable.
date: April 26, 2023

bug_fixes:
- area: tls
  change: |
    Fix build FIPS compliance when using both FIPS mode and Wasm extensions (``--define boringssl=fips`` and ``--define wasm=v8``).
date: November 30, 2016

changes:
- area: config
  change: |
    Switch from Jannson to RapidJSON for our JSON library (allowing for a configuration schema in 1.2.0).
- area: deps
  change: |
    Upgrade :ref:`recommended version <v1.5:install_requirements>` of various other libraries.
- area: dns
  change: |
    Configurable DNS refresh rate for DNS service discovery types.
- area: circuit_breaking
  change: |
    Upstream circuit breaker configuration can be :ref:`overridden via runtime
    <v1.5:config_cluster_manager_cluster_runtime>`.
- area: routing
  change: |
    :ref:`Zone aware routing support <v1.5:arch_overview_load_balancing_zone_aware_routing>`.
- area: matching
  change: |
    Generic header matching routing rule.
- area: http2
  change: |
    HTTP/2 graceful connection draining (double GOAWAY).
- area: dyanmodb
  change: |
    DynamoDB filter :ref:`per shard statistics <v1.5:config_http_filters_dynamo>` (pre-release AWS feature).
- area: fault_injection
  change: |
    Initial release of the :ref:`fault injection HTTP filter <v1.5:config_http_filters_fault_injection>`.
- area: rate_limit
  change: |
    HTTP :ref:`rate limit filter <v1.5:config_http_filters_rate_limit>` enhancements (note that the configuration for HTTP
    rate limiting is going to be overhauled in 1.2.0).
- area: retry
  change: |
    Added :ref:`refused-stream retry policy <v1.5:config_http_filters_router_x-envoy-retry-on>`.
- area: routing
  change: |
    Multiple :ref:`priority queues <v1.5:arch_overview_http_routing_priority>` for upstream clusters (configurable on a per
    route basis, with separate connection pools, circuit breakers, etc.).
- area: circuit_breaking
  change: |
    Added max connection circuit breaking to the :ref:`TCP proxy filter <v1.5:arch_overview_tcp_proxy>`.
- area: options
  change: |
    Added :ref:`CLI <v1.5:operations_cli>` options for setting the logging file flush interval as well as the drain/shutdown
    time during hot restart.
- area: performance
  change: |
    A very large number of performance enhancements for core HTTP/TCP proxy flows as well as a few new configuration flags
    to allow disabling expensive features if they are not needed (specifically request ID generation and dynamic response
    code stats).
- area: mongo
  change: |
    Support Mongo 3.2 in the :ref:`Mongo sniffing filter <v1.5:config_network_filters_mongo_proxy>`.
- area: envoy
  change: |
    Lots of other small fixes and enhancements not listed.
date: August 24, 2021

minor_behavior_changes:
- area: http
  change: |
    reject requests with \#fragment in the URI path. The fragment is not allowed to be part of request URI according to
    RFC3986 (3.5), RFC7230 (5.1) and RFC 7540 (8.1.2.3). Rejection of requests can be changed to stripping the \#fragment
    instead by setting the runtime guard ``envoy.reloadable_features.http_reject_path_with_fragment`` to false. This
    behavior can further be changed to the deprecated behavior of keeping the fragment by setting the runtime guard
    ``envoy.reloadable_features.http_strip_fragment_from_path_unsafe_if_disabled``. This runtime guard must only be set to
    false when existing non-compliant traffic relies on \#fragment in URI. When this option is enabled, Envoy request
    authorization extensions may be bypassed. This override and its associated behavior will be decommissioned after the
    standard deprecation period.

bug_fixes:
- area: ext_authz
  change: |
    fix the ext_authz filter to correctly merge multiple same headers using the ``,`` as separator in the check request to
    the external authorization service.
- area: http
  change: |
    limit use of deferred resets in the http2 codec to server-side connections. Use of deferred reset for client connections
    can result in incorrect behavior and performance problems.
- area: jwt_authn
  change: |
    unauthorized responses now correctly include a ``www-authenticate`` header.

new_features:
- area: listener
  change: |
    added an option when balancing across active listeners and wildcard matching is used to return the listener that matches
    the IP family type associated with the listener's socket address. It is off by default, but is turned on by default in
    v1.19. To set change the runtime guard ``envoy.reloadable_features.listener_wildcard_match_ip_family`` to true.
date: June 9, 2022

bug_fixes:
- area: decompression
  change: |
    fixed CVE-2022-29225 due to which decompressors can be zip bombed. Previously decompressors were susceptible to memory
    inflation in takes in which specially crafted payloads could cause a large amount of memory usage by Envoy. The max
    inflation payload size is now limited.  This change can be reverted via the
    ``envoy.reloadable_features.enable_compression_bomb_protection`` runtime flag.
- area: health_check
  change: |
    fixed CVE-2022-29224 which caused a segfault in GrpcHealthCheckerImpl. An attacker-controlled upstream server that is
    health checked using gRPC health checking can crash Envoy via a null pointer dereference in certain circumstances.
- area: oauth
  change: |
    fixed CVE-2022-29226 due to which oauth filter allows trivial bypass. The OAuth filter implementation does not include a
    mechanism for validating access tokens, so by design when the HMAC signed cookie is missing a full authentication flow
    should be triggered. However, the current implementation assumes that access tokens are always validated thus allowing
    access in the presence of any access token attached to the request.
- area: oauth
  change: |
    fixed CVE-2022-29228 due to which oauth filter calls continueDecoding() from within decodeHeaders(). The OAuth filter
    would try to invoke the remaining filters in the chain after emitting a local response, which triggers an ASSERT() in
    newer versions and corrupts memory on earlier versions.
- area: router
  change: |
    fixed CVE-2022-29227 which caused an internal redirect crash for requests with body/trailers. Envoy would previously
    crash in some cases when processing internal redirects for requests with bodies or trailers if the redirect prompts an
    Envoy-generated local reply.
date: June 30, 2020

changes:
- area: buffer
  change: |
    fixed CVE-2020-12603 by avoiding fragmentation, and tracking of HTTP/2 data and control frames in the output buffer.
- area: http
  change: |
    fixed CVE-2020-12604 by changing :ref:`stream_idle_timeout
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>` to also
    defend against an HTTP/2 peer that does not open stream window once an entire response has been buffered to be sent to a
    downstream client.
- area: http
  change: |
    fixed CVE-2020-12605 by including request URL in request header size computation, and rejecting partial headers that
    exceed configured limits.
- area: listener
  change: |
    fixed CVE-2020-8663 by adding runtime support for :ref:`per-listener limits <config_listeners_runtime>` on
    active/accepted connections.
- area: overload management
  change: |
    fixed CVE-2020-8663 by adding runtime support for :ref:`global limits <config_overload_manager>` on active/accepted
    connections.
date: October 17, 2023

bug_fixes:
- area: tracing
  change: |
    Fixed a bug in the Datadog tracer where Datadog's "operation name" field would contain what should be in the "resource name" field.
- area: http
  change: |
    Fixed a bug where processing of deferred streams with the value of ``http.max_requests_per_io_cycle`` more than 1,
    can cause a crash.
date: October 8, 2020

behavior_changes:
- area: build
  change: |
    added visibility rules for upstream. If these cause visibility related breakage, see notes in `BUILD
    <https://github.com/envoyproxy/envoy/blob/release/v1.16/BUILD>`_.
- area: build
  change: |
    tcmalloc changes require Clang 9. This requirement change can be avoided by building with ``--define
    tcmalloc=gperftools`` to use the older tcmalloc code.
- area: config
  change: |
    additional warnings have been added for the use of v2 APIs. These appear as log messages and are also captured in the
    :ref:`deprecated_feature_use <runtime_stats>` counter after server initialization.
- area: dns
  change: |
    ``envoy.restart_features.use_apple_api_for_dns_lookups`` is on by default. This flag only affects Apple platforms
    (macOS, iOS). It is incompatible to have the runtime flag set to true at the same time as specifying the
    ````use_tcp_for_dns_lookups```` option or custom dns resolvers. Doing so will cause failure.
- area: watchdog
  change: |
    added two guarddogs, breaking the aggregated stats for the single guarddog system. The aggregated stats for the
    guarddogs will have the following prefixes: ``main_thread`` and ``workers``. Concretely, anything monitoring
    ``server.watchdog_miss`` and ``server.watchdog_mega_miss`` will need to be updated.

minor_behavior_changes:
- area: adaptive concurrency
  change: |
    added a response body / grpc-message header for rejected requests.
- area: async_client
  change: |
    minor change to handling header only responses more similar to header-with-empty-body responses.
- area: build
  change: |
    an :ref:`Ubuntu based debug image <install_binaries>` is built and published in DockerHub.
- area: build
  change: |
    the debug information will be generated separately to reduce target size and reduce compilation time when build in
    compilation mode ``dbg`` and ``opt``. Users will need to build dwp file to debug with gdb.
- area: compressor
  change: |
    always insert ``Vary`` headers for compressible resources even if it's decided not to compress a response due to
    incompatible ``Accept-Encoding`` value. The ``Vary`` header needs to be inserted to let a caching proxy in front of
    Envoy know that the requested resource still can be served with compression applied.
- area: decompressor
  change: |
    headers-only requests were incorrectly not advertising accept-encoding when configured to do so. This is now fixed.
- area: ext_authz filter
  change: |
    request timeout will now count from the time the check request is created, instead of when it becomes active. This makes
    sure that the timeout is enforced even if the ``ext_authz`` cluster's circuit breaker is engaged. This behavior can be
    reverted by setting runtime feature ``envoy.reloadable_features.ext_authz_measure_timeout_on_check_created`` to false.
    When enabled, a new ``ext_authz.timeout`` stat is counted when timeout occurs. See :ref:`stats
    <config_http_filters_ext_authz_stats>`.
- area: grpc reverse bridge
  change: |
    upstream headers will no longer be propagated when the response is missing or contains an unexpected content-type.
- area: http
  change: |
    added :ref:`contains <envoy_api_msg_type.matcher.StringMatcher>`, a new string matcher type which matches if the value
    of the string has the substring mentioned in contains matcher.
- area: http
  change: |
    added :ref:`contains <envoy_api_msg_route.HeaderMatcher>`, a new header matcher type which matches if the value of the
    header has the substring mentioned in contains matcher.
- area: http
  change: |
    added :ref:`headers_to_add
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ResponseMapper.headers_to_add>` to :ref:`local
    reply mapper <config_http_conn_man_local_reply>` to allow its users to add/append/override response HTTP headers to
    local replies.
- area: http
  change: |
    added HCM level configuration of :ref:`error handling on invalid messaging
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`
    which substantially changes Envoy's behavior when encountering invalid HTTP/1.1 defaulting to closing the connection
    instead of allowing reuse. This can temporarily be reverted by setting
    ``envoy.reloadable_features.hcm_stream_error_on_invalid_message`` to false, or permanently reverted by setting the
    HTTP/1 configuration :ref:`override_stream_error_on_invalid_http_message
    <envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message>` to true to
    restore prior HTTP/1.1 behavior (i.e. connection isn't terminated) and to retain prior HTTP/2 behavior (i.e. connection
    is terminated).
- area: http
  change: |
    added HCM level configuration of :ref:`error handling on invalid messaging
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`
    which substantially changes Envoy's behavior when encountering invalid HTTP/1.1 defaulting to closing the connection
    instead of allowing reuse. This can temporarily be reverted by setting
    ``envoy.reloadable_features.hcm_stream_error_on_invalid_message`` to false, or permanently reverted by setting the
    :ref:`HCM option
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`
    to true to restore prior HTTP/1.1 beavior and setting the *new* HTTP/2 configuration
    :ref:`override_stream_error_on_invalid_http_message
    <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message>` to false to
    retain prior HTTP/2 behavior.
- area: http
  change: |
    applying route level header modifications to local replies sent on that route. This behavior may be temporarily reverted
    by setting ``envoy.reloadable_features.always_apply_route_header_rules`` to false.
- area: http
  change: |
    changed Envoy to send GOAWAY to HTTP2 downstreams when the :ref:`disable_keepalive
    <config_overload_manager_overload_actions>` overload action is active. This behavior may be temporarily reverted by
    setting ``envoy.reloadable_features.overload_manager_disable_keepalive_drain_http2`` to false.
- area: http
  change: |
    changed Envoy to send error headers and body when possible. This behavior may be temporarily reverted by setting
    ``envoy.reloadable_features.allow_response_for_timeout`` to false.
- area: http
  change: |
    changed empty trailers encoding behavior by sending empty data with ``end_stream`` true (instead of sending empty
    trailers) for HTTP/2. This behavior can be reverted temporarily by setting runtime feature
    ``envoy.reloadable_features.http2_skip_encoding_empty_trailers`` to false.
- area: http
  change: |
    changed how local replies are processed for requests which transform from grpc to not-grpc, or not-grpc to grpc.
    Previously the initial generated reply depended on which filter sent the reply, but now the reply is consistently
    generated the way the downstream expects. This behavior can be temporarily reverted by setting
    ``envoy.reloadable_features.unify_grpc_handling`` to false.
- area: http
  change: |
    clarified and enforced 1xx handling. Multiple 100-continue headers are coalesced when proxying. 1xx headers other than
    {100, 101} are dropped.
- area: http
  change: |
    fixed a bug in access logs where early stream termination could be incorrectly tagged as a downstream disconnect, and
    disconnects after partial response were not flagged.
- area: http
  change: |
    fixed the 100-continue response path to properly handle upstream failure by sending 5xx responses. This behavior can be
    temporarily reverted by setting ``envoy.reloadable_features.allow_500_after_100`` to false.
- area: http
  change: |
    the per-stream FilterState maintained by the HTTP connection manager will now provide read/write access to the
    downstream connection FilterState. As such, code that relies on interacting with this might see a change in behavior.
- area: logging
  change: |
    added fine-grain logging for file level log control with logger management at administration interface. It can be
    enabled by option :option:`--enable-fine-grain-logging`.
- area: logging
  change: |
    changed default log format to ``"[%Y-%m-%d %T.%e][%t][%l][%n] [%g:%#] %v"`` and default value of ``--log-format-prefix-
    with-location`` to ``0``.
- area: logging
  change: |
    nghttp2 log messages no longer appear at trace level unless ``ENVOY_NGHTTP2_TRACE`` is set in the environment.
- area: lua
  change: |
    changed the response body returned by ``httpCall()`` API to raw data. Previously, the returned data was string.
- area: memory
  change: |
    switched to the `new tcmalloc <https://github.com/google/tcmalloc>`_ for linux_x86_64 builds. The `old tcmalloc
    <https://github.com/gperftools/gperftools>`_ can still be enabled with the ``--define tcmalloc=gperftools`` option.
- area: postgres
  change: |
    changed log format to tokenize fields of Postgres messages.
- area: router
  change: |
    added transport failure reason to response body when upstream reset happens. After this change, the response body will
    be of the form ``upstream connect error or disconnect/reset before headers. reset reason:{}, transport failure
    reason:{}``.This behavior may be reverted by setting runtime feature
    ``envoy.reloadable_features.http_transport_failure_reason_in_body`` to false.
- area: router
  change: |
    now consumes all retry related headers to prevent them from being propagated to the upstream. This behavior may be
    reverted by setting runtime feature ``envoy.reloadable_features.consume_all_retry_headers`` to false.
- area: stats
  change: |
    the fake symbol table implemention has been removed from the binary, and the option ``--use-fake-symbol-table`` is now a
    no-op with a warning.
- area: thrift_proxy
  change: |
    special characters {'\0', '\r', '\n'} will be stripped from thrift headers.
- area: watchdog
  change: |
    replaced single watchdog with separate watchdog configuration for worker threads and for the main thread configured via
    :ref:`Watchdogs <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.watchdogs>`. It works with :ref:`watchdog
    <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.watchdog>` by having the worker thread and main thread watchdogs have
    same config.

bug_fixes:
- area: csrf
  change: |
    fixed issues with regards to origin and host header parsing.
- area: dynamic_forward_proxy
  change: |
    only perform DNS lookups for routes to Dynamic Forward Proxy clusters since other cluster types handle DNS lookup
    themselves.
- area: fault
  change: |
    fixed an issue with ``active_faults`` gauge not being decremented for when abort faults were injected.
- area: fault
  change: |
    made the HeaderNameValues::prefix() method const.
- area: grpc-web
  change: |
    fixed an issue with failing HTTP/2 requests on some browsers. Notably, WebKit-based browsers
    (https://bugs.webkit.org/show_bug.cgi?id=210108), Internet Explorer 11, and Edge (pre-Chromium).
- area: http
  change: |
    fixed CVE-2020-25018 by rolling back the ``GURL`` dependency to previous state (reverted: ``2d69e30``, ``d828958``, and
    ``c9c4709`` commits) due to potential of crashing when Unicode URIs are present in requests.
- area: http
  change: |
    fixed bugs in datadog and squash filter's handling of responses with no bodies.
- area: http
  change: |
    made the HeaderValues::prefix() method const.
- area: jwt_authn
  change: |
    supports jwt payload without "iss" field.
- area: listener
  change: |
    fixed crash at listener inplace update when connection load balancer is set.
- area: rocketmq_proxy
  change: |
    fixed an issue involving incorrect header lengths. In debug mode it causes crash and in release mode it causes
    underflow.
- area: thrift_proxy
  change: |
    fixed crashing bug on request overflow.
- area: udp_proxy
  change: |
    fixed a crash due to UDP packets being processed after listener removal.

removed_config_or_runtime:
- area: http
  change: |
    removed legacy header sanitization and the runtime guard ``envoy.reloadable_features.strict_header_validation``.
- area: http
  change: |
    removed legacy transfer-encoding enforcement and runtime guard
    ``envoy.reloadable_features.reject_unsupported_transfer_encodings``.
- area: http
  change: |
    removed configurable strict host validation and runtime guard ``envoy.reloadable_features.strict_authority_validation``.
- area: http
  change: |
    removed the connection header sanitization runtime guard ``envoy.reloadable_features.connection_header_sanitization``.

new_features:
- area: access log
  change: |
    added a :ref:`dynamic metadata filter <envoy_v3_api_msg_config.accesslog.v3.MetadataFilter>` for access logs, which
    filters whether to log based on matching dynamic metadata.
- area: access log
  change: |
    added support for :ref:`%DOWNSTREAM_PEER_FINGERPRINT_1% <config_access_log_format_response_flags>` as a response flag.
- area: access log
  change: |
    added support for :ref:`%CONNECTION_TERMINATION_DETAILS% <config_access_log_format_connection_termination_details>` as a
    log command operator about why the connection is terminated by Envoy.
- area: access log
  change: |
    added support for nested objects in :ref:`JSON logging mode <config_access_log_format_dictionaries>`.
- area: access log
  change: |
    added :ref:`omit_empty_values <envoy_v3_api_field_config.core.v3.SubstitutionFormatString.omit_empty_values>` option to
    omit unset value from formatted log.
- area: access log
  change: |
    added support for :ref:`%CONNECTION_ID% <config_access_log_format_connection_id>` for the downstream connection
    identifier.
- area: admin
  change: |
    added :ref:`circuit breakers settings <envoy_v3_api_msg_config.cluster.v3.CircuitBreakers>` information to GET
    /clusters?format=json :ref:`cluster status <envoy_v3_api_msg_admin.v3.ClusterStatus>`.
- area: admin
  change: |
    added :ref:`node <envoy_v3_api_msg_config.core.v3.Node>` information to GET /server_info :ref:`response object
    <envoy_v3_api_msg_admin.v3.ServerInfo>`.
- area: admin
  change: |
    added the ability to dump init manager unready targets information :ref:`/init_dump
    <operations_admin_interface_init_dump>` and :ref:`/init_dump?mask={} <operations_admin_interface_init_dump_by_mask>`.
- area: admission control
  change: |
    added the :ref:`admission control <envoy_v3_api_msg_extensions.filters.http.admission_control.v3alpha.AdmissionControl>`
    filter for client-side request throttling.
- area: build
  change: |
    enable building envoy :ref:`arm64 images <install_binaries>` by buildx tool in x86 CI platform.
- area: cluster
  change: |
    added new :ref:`connection_pool_per_downstream_connection
    <envoy_v3_api_field_config.cluster.v3.Cluster.connection_pool_per_downstream_connection>` flag, which enable creation of
    a new connection pool for each downstream connection.
- area: decompressor filter
  change: |
    reports compressed and uncompressed bytes in trailers.
- area: dns
  change: |
    added support for doing DNS resolution using Apple's DnsService APIs in Apple platforms (macOS, iOS). This feature is ON
    by default, and is only configurable via the ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime key. Note
    that this value is latched during server startup and changing the runtime key is a no-op during the lifetime of the
    process.
- area: dns_filter
  change: |
    added support for answering :ref:`service record <envoy_v3_api_msg_data.dns.v3.DnsTable.DnsService>` queries.
- area: dynamic_forward_proxy
  change: |
    added :ref:`use_tcp_for_dns_lookups
    <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.use_tcp_for_dns_lookups>` option to use
    TCP for DNS lookups in order to match the DNS options for :ref:`Clusters <envoy_v3_api_msg_config.cluster.v3.Cluster>`.
- area: ext_authz filter
  change: |
    added support for emitting dynamic metadata for both :ref:`HTTP <config_http_filters_ext_authz_dynamic_metadata>` and
    :ref:`network <config_network_filters_ext_authz_dynamic_metadata>` filters. The emitted dynamic metadata is set by
    :ref:`dynamic metadata <envoy_v3_api_field_service.auth.v3.CheckResponse.dynamic_metadata>` field in a returned
    :ref:`CheckResponse <envoy_v3_api_msg_service.auth.v3.CheckResponse>`.
- area: ext_authz filter
  change: |
    added :ref:`stat_prefix <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.stat_prefix>` as an optional
    additional prefix for the statistics emitted from ``ext_authz`` HTTP filter.
- area: ext_authz filter
  change: |
    added support for enabling the filter based on :ref:`dynamic metadata
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.filter_enabled_metadata>`.
- area: ext_authz filter
  change: |
    added support for letting the authorization server instruct Envoy to remove headers from the original request by setting
    the new field :ref:`headers_to_remove <envoy_v3_api_field_service.auth.v3.OkHttpResponse.headers_to_remove>` before
    forwarding it to the upstream.
- area: ext_authz filter
  change: |
    added support for sending :ref:`raw bytes as request body
    <envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.raw_body>` of a gRPC check request by setting
    :ref:`pack_as_bytes <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.BufferSettings.pack_as_bytes>` to true.
- area: ext_authz_filter
  change: |
    added :ref:`disable_request_body_buffering
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.CheckSettings.disable_request_body_buffering>` to disable
    request data buffering per-route.
- area: grpc-json
  change: |
    support specifying ``response_body`` field in for ``google.api.HttpBody`` message.
- area: hds
  change: |
    added :ref:`cluster_endpoints_health
    <envoy_v3_api_field_service.health.v3.EndpointHealthResponse.cluster_endpoints_health>` to HDS responses, keeping
    endpoints in the same groupings as they were configured in the HDS specifier by cluster and locality instead of as a
    flat list.
- area: hds
  change: |
    added :ref:`transport_socket_matches <envoy_v3_api_field_service.health.v3.ClusterHealthCheck.transport_socket_matches>`
    to HDS cluster health check specifier, so the existing match filter :ref:`transport_socket_match_criteria
    <envoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>` in the repeated field
    :ref:`health_checks <envoy_v3_api_field_service.health.v3.ClusterHealthCheck.health_checks>` has context to match
    against. This unblocks support for health checks over HTTPS and HTTP/2.
- area: hot restart
  change: |
    added :option:`--socket-path` and :option:`--socket-mode` to configure UDS path in the filesystem and set permission to
    it.
- area: http
  change: |
    added HTTP/2 support for :ref:`connection keepalive
    <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.connection_keepalive>` via PING.
- area: http
  change: |
    added support for :ref:`%DOWNSTREAM_PEER_FINGERPRINT_1% <config_http_conn_man_headers_custom_request_headers>` as custom
    header.
- area: http
  change: |
    added :ref:`allow_chunked_length <envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length>`
    configuration option for HTTP/1 codec to allow processing requests/responses with both Content-Length and Transfer-
    Encoding: chunked headers. If such message is served and option is enabled - per RFC Content-Length is ignored and
    removed.
- area: http
  change: |
    added :ref:`CDN Loop filter <envoy_v3_api_msg_extensions.filters.http.cdn_loop.v3alpha.CdnLoopConfig>` and
    :ref:`documentation <config_http_filters_cdn_loop>`.
- area: http
  change: |
    added :ref:`MaxStreamDuration proto <envoy_v3_api_msg_config.route.v3.RouteAction.MaxStreamDuration>` for configuring
    per-route downstream duration timeouts.
- area: http
  change: |
    introduced new HTTP/1 and HTTP/2 codec implementations that will remove the use of exceptions for control flow due to
    high risk factors and instead use error statuses. The old behavior is used by default for HTTP/1.1 and HTTP/2 server
    connections. The new codecs can be enabled for testing by setting the runtime feature
    ``envoy.reloadable_features.new_codec_behavior`` to true. The new codecs will be in development for one month, and then
    enabled by default while the old codecs are deprecated.
- area: http
  change: |
    modified the HTTP header-map data-structure to use an underlying dictionary and a list (no change to the header-map
    API). To conform with previous versions, the use of a dictionary is currently disabled. It can be enabled by setting the
    ``envoy.http.headermap.lazy_map_min_size`` runtime feature to a non-negative number which defines the minimal number of
    headers in a request/response/trailers required for using a dictionary in addition to the list. Our current benchmarks
    suggest that the value 3 is a good threshold for most workloads.
- area: load balancer
  change: |
    added :ref:`RingHashLbConfig <envoy_v3_api_msg_config.cluster.v3.Cluster.MaglevLbConfig>` to configure the table size of
    Maglev consistent hash.
- area: load balancer
  change: |
    added a :ref:`configuration <envoy_v3_api_msg_config.cluster.v3.Cluster.LeastRequestLbConfig>` option to specify the
    active request bias used by the least request load balancer.
- area: load balancer
  change: |
    added an :ref:`option
    <envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.single_host_per_subset>` to optimize
    subset load balancing when there is only one host per subset.
- area: load balancer
  change: |
    added support for bounded load per host for consistent hash load balancers via :ref:`hash_balance_factor
    <envoy_api_field_Cluster.CommonLbConfig.consistent_hashing_lb_config>`.
- area: local_reply config
  change: |
    added :ref:`content_type <envoy_v3_api_field_config.core.v3.SubstitutionFormatString.content_type>` field to set
    content-type.
- area: lua
  change: |
    added Lua APIs to access :ref:`SSL connection info <config_http_filters_lua_ssl_socket_info>` object.
- area: lua
  change: |
    added Lua API for :ref:`base64 escaping a string <config_http_filters_lua_stream_handle_api_base64_escape>`.
- area: lua
  change: |
    added Lua API for :ref:`setting the current buffer content <config_http_filters_lua_buffer_wrapper_api_set_bytes>`.
- area: lua
  change: |
    added new :ref:`source_code <envoy_v3_api_field_extensions.filters.http.lua.v3.LuaPerRoute.source_code>` field to
    support the dispatching of inline Lua code in per route configuration of Lua filter.
- area: overload management
  change: |
    add :ref:`scaling <envoy_v3_api_field_config.overload.v3.Trigger.scaled>` trigger for OverloadManager actions.
- area: postgres network filter
  change: |
    :ref:`metadata <config_network_filters_postgres_proxy_dynamic_metadata>` is produced based on SQL query.
- area: proxy protocol
  change: |
    added support for generating the header upstream using :ref:`Proxy Protocol Transport Socket
    <extension_envoy.transport_sockets.upstream_proxy_protocol>`.
- area: ratelimit
  change: |
    added :ref:`enable_x_ratelimit_headers <envoy_v3_api_msg_extensions.filters.http.ratelimit.v3.RateLimit>` option to
    enable ``X-RateLimit-*`` headers as defined in `draft RFC <https://tools.ietf.org/id/draft-polli-ratelimit-
    headers-03.html>`_.
- area: ratelimit
  change: |
    added :ref:`per route config <envoy_v3_api_msg_extensions.filters.http.ratelimit.v3.RateLimitPerRoute>` for rate limit
    filter.
- area: ratelimit
  change: |
    added support for optional :ref:`descriptor_key <envoy_v3_api_field_config.route.v3.RateLimit.Action.generic_key>` to
    Generic Key action.
- area: rbac filter
  change: |
    added the name of the matched policy to the response code detail when a request is rejected by the RBAC filter.
- area: rbac filter
  change: |
    added a log action to the :ref:`RBAC filter <envoy_v3_api_msg_config.rbac.v3.RBAC>` which sets dynamic metadata to
    inform access loggers whether to log.
- area: redis
  change: |
    added fault injection support :ref:`fault injection for redis proxy
    <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.faults>`, described further in
    :ref:`configuration documentation <config_network_filters_redis_proxy>`.
- area: router
  change: |
    added a new :ref:`rate limited retry back off <envoy_v3_api_msg_config.route.v3.RetryPolicy.RateLimitedRetryBackOff>`
    strategy that uses headers like ``Retry-After`` or ``X-RateLimit-Reset`` to decide the back off interval.
- area: router
  change: |
    added new :ref:`envoy-ratelimited <config_http_filters_router_retry_policy-envoy-ratelimited>` retry policy, which
    allows retrying envoy's own rate limited responses.
- area: router
  change: |
    added new :ref:`host_rewrite_path_regex <envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_path_regex>`
    option, which allows rewriting Host header based on path.
- area: router
  change: |
    added support for DYNAMIC_METADATA :ref:`header formatter <config_http_conn_man_headers_custom_request_headers>`.
- area: router_check_tool
  change: |
    added support for ``request_header_matches``, ``response_header_matches`` to :ref:`router check tool
    <config_tools_router_check_tool>`.
- area: signal
  change: |
    added support for calling fatal error handlers without envoy's signal handler, via
    FatalErrorHandler::callFatalErrorHandlers().
- area: stats
  change: |
    added optional histograms to :ref:`cluster stats <config_cluster_manager_cluster_stats_request_response_sizes>` that
    track headers and body sizes of requests and responses.
- area: stats
  change: |
    allow configuring histogram buckets for stats sinks and admin endpoints that support it.
- area: tap
  change: |
    added :ref:`generic body matcher <envoy_v3_api_msg_config.tap.v3.HttpGenericBodyMatch>` to scan http requests and
    responses for text or hex patterns.
- area: tcp_proxy
  change: |
    added :ref:`max_downstream_connection_duration
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.max_downstream_connection_duration>` for downstream
    connection. When max duration is reached the connection will be closed.
- area: tcp_proxy
  change: |
    allow earlier network filters to set metadataMatchCriteria on the connection StreamInfo to influence load balancing.
- area: tls
  change: |
    added OCSP stapling support through the :ref:`ocsp_staple
    <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.TlsCertificate>` and :ref:`ocsp_staple_policy
    <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.DownstreamTlsContext>` configuration options. See :ref:`OCSP
    Stapling <arch_overview_ssl_ocsp_stapling>` for usage and runtime flags.
- area: tls
  change: |
    introduce new :ref:`extension point
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.custom_handshaker>` for overriding :ref:`TLS
    handshaker <arch_overview_ssl>` behavior.
- area: tls
  change: |
    switched from using socket BIOs to using custom BIOs that know how to interact with IoHandles. The feature can be
    disabled by setting runtime feature ``envoy.reloadable_features.tls_use_io_handle_bio`` to false.
- area: tracing
  change: |
    added ability to set some :ref:`optional segment fields <envoy_v3_api_field_config.trace.v3.XRayConfig.segment_fields>`
    in the AWS  X-Ray tracer.
- area: udp_proxy
  change: |
    added :ref:`hash_policies <envoy_v3_api_msg_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig>` to support hash based
    routing.
- area: udp_proxy
  change: |
    added :ref:`use_original_src_ip <envoy_v3_api_msg_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig>` option to
    replicate the downstream remote address of the packets on the upstream side of Envoy. It is similar to :ref:`original
    source filter <envoy_v3_api_msg_extensions.filters.listener.original_src.v3.OriginalSrc>`.
- area: watchdog
  change: |
    support randomizing the watchdog's kill timeout to prevent synchronized kills via a maximium jitter parameter
    :ref:`max_kill_timeout_jitter <envoy_v3_api_field_config.bootstrap.v3.Watchdog.max_kill_timeout_jitter>`.
- area: watchdog
  change: |
    supports an extension point where actions can be registered to fire on watchdog events such as miss, megamiss, kill and
    multikill. See :ref:`watchdog actions <envoy_v3_api_field_config.bootstrap.v3.Watchdog.actions>`.
- area: watchdog
  change: |
    watchdog action extension that does cpu profiling. See :ref:`Profile Action
    <envoy_v3_api_file_envoy/extensions/watchdog/profile_action/v3alpha/profile_action.proto>`.
- area: watchdog
  change: |
    watchdog action extension that sends SIGABRT to the stuck thread to terminate the process. See :ref:`Abort Action
    <envoy_v3_api_msg_extensions.watchdog.abort_action.v3alpha.abortactionconfig>`.
- area: xds
  change: |
    added :ref:`extension config discovery <envoy_v3_api_msg_config.core.v3.ExtensionConfigSource>` support for HTTP
    filters.
- area: xds
  change: |
    added support for mixed v2/v3 discovery response, which enable type url downgrade and upgrade. This feature is disabled
    by default and is controlled by runtime guard ``envoy.reloadable_features.enable_type_url_downgrade_and_upgrade``.
- area: zlib
  change: |
    added option to use `zlib-ng <https://github.com/zlib-ng/zlib-ng>`_ as zlib library.

deprecated:
- area: build
  change: |
    alpine based debug image is deprecated in favor of :ref:`Ubuntu based debug image <install_binaries>`.
- area: cluster
  change: |
    the :ref:`track_timeout_budgets <envoy_v3_api_field_config.cluster.v3.Cluster.track_timeout_budgets>` field has been
    deprecated in favor of ``timeout_budgets`` part of an :ref:`Optional Configuration
    <envoy_v3_api_field_config.cluster.v3.Cluster.track_cluster_stats>`.
- area: ext_authz
  change: |
    the :ref:`dynamic metadata <envoy_v3_api_field_service.auth.v3.OkHttpResponse.dynamic_metadata>` field in
    :ref:`OkHttpResponse <envoy_v3_api_msg_service.auth.v3.OkHttpResponse>` has been deprecated in favor of :ref:`dynamic
    metadata <envoy_v3_api_field_service.auth.v3.CheckResponse.dynamic_metadata>` field in :ref:`CheckResponse
    <envoy_v3_api_msg_service.auth.v3.CheckResponse>`.
- area: hds
  change: |
    the :ref:`endpoints_health <envoy_v3_api_field_service.health.v3.EndpointHealthResponse.endpoints_health>` field has
    been deprecated in favor of :ref:`cluster_endpoints_health
    <envoy_v3_api_field_service.health.v3.EndpointHealthResponse.cluster_endpoints_health>` to maintain grouping by cluster
    and locality.
- area: router
  change: |
    the :ref:`include_vh_rate_limits <envoy_v3_api_field_config.route.v3.RouteAction.include_vh_rate_limits>` field has been
    deprecated in favor of :ref:`vh_rate_limits
    <envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimitPerRoute.vh_rate_limits>`.
- area: router
  change: |
    the :ref:`max_grpc_timeout <envoy_v3_api_field_config.route.v3.RouteAction.max_grpc_timeout>` field has been deprecated
    in favor of :ref:`grpc_timeout_header_max
    <envoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_max>`.
- area: router
  change: |
    the :ref:`grpc_timeout_offset <envoy_v3_api_field_config.route.v3.RouteAction.grpc_timeout_offset>` field has been
    deprecated in favor of :ref:`grpc_timeout_header_offset
    <envoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_offset>`.
- area: tap
  change: |
    the :ref:`match_config <envoy_v3_api_field_config.tap.v3.TapConfig.match_config>` field has been deprecated in favor of
    :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` field.
- area: router_check_tool
  change: |
    ``request_header_fields``, ``response_header_fields`` config deprecated in favor of ``request_header_matches``,
    ``response_header_matches``.
- area: watchdog
  change: |
    :ref:`watchdog <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.watchdog>` deprecated in favor of :ref:`watchdogs
    <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.watchdogs>`.
date: July 13, 2023

bug_fixes:
- area: dependency
  change: |
    update gRPC -> 1.49.0 to resolve:

    - `CVE-2023-1428 <https://nvd.nist.gov/vuln/detail/CVE-2023-1428>`_.
    - `CVE-2023-32731 <https://nvd.nist.gov/vuln/detail/CVE-2023-32731>`_.
- area: http2
  change: |
    Fix memory leak in nghttp2 when scheduled requests are cancelled due to the ``GOAWAY`` frame being received from the
    upstream service. Fix `CVE-2023-35945 <https://nvd.nist.gov/vuln/detail/CVE-2023-35945>`_..
date: February 27, 2023

bug_fixes:
- area: dependency
  change: |
    update Kafka to resolve CVE-2023-25194.

new_features:
- area: docker
  change: |
    unify published images as tag variants. For example, ``envoyproxy/envoy-dev`` is now available
    as ``envoyproxy/envoy:dev``.
date: September 29, 2020

changes:
- area: http
  change: |
    fixed CVE-2020-25017. Previously header matching did not match on all headers for non-inline headers. This patch
    changes the default behavior to always logically match on all headers. Multiple individual
    headers will be logically concatenated with ``,`` similar to what is done with inline headers. This
    makes the behavior effectively consistent. This behavior can be temporary reverted by setting
    the runtime value ``envoy.reloadable_features.http_match_on_all_headers`` to ``false``.

    Targeted fixes have been additionally performed on the following extensions which make them
    consider all duplicate headers by default as a comma concatenated list:

      1. Any extension using CEL matching on headers.
      2. The header to metadata filter.
      3. The JWT filter.
      4. The Lua filter.

    Like primary header matching used in routing, RBAC, etc. this behavior can be disabled by setting
    the runtime value ``envoy.reloadable_features.http_match_on_all_headers`` to ``false``.
date: October 16, 2023

bug_fixes:
- area: tracing
  change: |
    Fixed a bug in the Datadog tracer where Datadog's "operation name" field would contain what should be in the "resource name" field.
- area: http
  change: |
    Fixed a bug where processing of deferred streams with the value of ``http.max_requests_per_io_cycle`` more than 1,
    can cause a crash.
date: October 5, 2021

behavior_changes:
- area: config
  change: |
    due to the switch to using work-in-progress annotations and warnings to indicate APIs
    subject to change, the following API packages have been force migrated from ``v3alpha`` to ``v3``:
    ``envoy.extensions.access_loggers.open_telemetry.v3``,
    ``envoy.extensions.cache.simple_http_cache.v3``,
    ``envoy.extensions.filters.http.admission_control.v3``,
    ``envoy.extensions.filters.http.bandwidth_limit.v3``,
    ``envoy.extensions.filters.http.cache.v3``,
    ``envoy.extensions.filters.http.cdn_loop.v3``,
    ``envoy.extensions.filters.http.ext_proc.v3``,
    ``envoy.extensions.filters.http.oauth2.v3``,
    ``envoy.extensions.filters.network.sni_dynamic_forward_proxy.v3``,
    ``envoy.extensions.filters.udp.dns_filter.v3``,
    ``envoy.extensions.transport_sockets.s2a.v3``,
    ``envoy.extensions.watchdog.profile_action.v3``,
    ``envoy.service.ext_proc.v3``, and
    ``envoy.watchdog.v3``. If your production deployment was using one of these APIs, you will be
    forced to potentially vendor the old proto file to continue serving old versions of Envoy.
    The project realizes this is unfortunate because some of these are known to be used in production,
    however the project does not have the resources to undergo a migration in which we support
    ``v3alpha`` and ``v3`` at the same time. The switch to using work-in-progress annotations with
    clear and explicit warnings will avoid any such issue in the future. We apologize again for any
    difficulty this change causes, though it is for the best. Additionally, some of the above
    namespaces have had their work-in-progress annotations removed due to known production usage.
    Thus, they will not warn and are offered full API stability support by the project from this
    point forward.
- area: config
  change: |
    the ``--bootstrap-version`` CLI flag has been removed, Envoy has only been able to accept v3
    bootstrap configurations since 1.18.0.
- area: contrib
  change: |
    the :ref:`squash filter <config_http_filters_squash>` has been moved to
    :ref:`contrib images <install_contrib>`.
- area: contrib
  change: |
    the :ref:`kafka broker filter <config_network_filters_kafka_broker>` has been moved to
    :ref:`contrib images <install_contrib>`.
- area: contrib
  change: |
    the :ref:`RocketMQ proxy filter <config_network_filters_rocketmq_proxy>` has been moved to
    :ref:`contrib images <install_contrib>`.
- area: contrib
  change: |
    the :ref:`Postgres proxy filter <config_network_filters_postgres_proxy>` has been moved to
    :ref:`contrib images <install_contrib>`.
- area: contrib
  change: |
    the :ref:`MySQL proxy filter <config_network_filters_mysql_proxy>` has been moved to
    :ref:`contrib images <install_contrib>`.
- area: dns_filter
  change: |
    :ref:`dns_filter <envoy_v3_api_msg_extensions.filters.udp.dns_filter.v3.DnsFilterConfig>`
    protobuf fields have been renumbered to restore compatibility with Envoy
    1.18, breaking compatibility with Envoy 1.19.0 and 1.19.1. The new field
    numbering allows control planes supporting Envoy 1.18 to gracefully upgrade to
    :ref:`dns_resolution_config
    <envoy_v3_api_field_extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig.dns_resolution_config>`,
    provided they skip over Envoy 1.19.0 and 1.19.1.
    Control planes upgrading from Envoy 1.19.0 and 1.19.1 will need to
    vendor the corresponding protobuf definitions to ensure that the
    renumbered fields have the types expected by those releases.
- area: extensions
  change: |
    deprecated extension names now default to triggering a configuration error.
    The previous warning-only behavior may be temporarily reverted by setting the runtime key
    ``envoy.deprecated_features.allow_deprecated_extension_names`` to true.

minor_behavior_changes:
- area: client_ssl_auth filter
  change: |
    now sets additional termination details and ``UAEX`` response flag when the client certificate is not in the allowed-list.
- area: config
  change: |
    configuration files ending in .yml now load as YAML.
- area: config
  change: |
    configuration file extensions now ignore case when deciding the file type. E.g., .JSON files load as JSON.
- area: config
  change: |
    reduced log level for "Unable to establish new stream" xDS logs to debug. The log level
    for "gRPC config stream closed" is now reduced to debug when the status is ``Ok`` or has been
    retriable (``DeadlineExceeded``, ``ResourceExhausted``, or ``Unavailable``) for less than 30
    seconds.
- area: config
  change: |
    use of work-in-progress API files, messages, or fields will now generate an explicit
    warning. Please read the text about ``(xds.annotations.v3.file_status).work_in_progress``,
    ``(xds.annotations.v3.message_status).work_in_progress``, and
    ``(xds.annotations.v3.field_status).work_in_progress``
    `here <https://github.com/envoyproxy/envoy/blob/main/api/STYLE.md>`_ for more information. Some
    APIs that are known to be implicitly not work-in-progress have been force migrated and are
    individually indicated elsewhere in the release notes. A server-wide ``wip_protos`` counter has
    also been added in :ref:`server statistics <server_statistics>` to track this.
- area: ext_authz
  change: |
    fixed skipping authentication when returning either a direct response or a redirect. This behavior can be temporarily
    reverted by setting the ``envoy.reloadable_features.http_ext_authz_do_not_skip_direct_response_and_redirect`` runtime
    guard to false.
- area: grpc
  change: |
    gRPC async client can be cached and shared across filter instances in the same thread, this feature is turned off by
    default, can be turned on by setting runtime guard ``envoy.reloadable_features.enable_grpc_async_client_cache`` to true.
- area: http
  change: |
    correct the use of the ``x-forwarded-proto`` header and the ``:scheme`` header. Where they differ
    (which is rare) ``:scheme`` will now be used for serving redirect URIs and cached content. This behavior
    can be reverted by setting runtime guard ``correct_scheme_and_xfp`` to false.
- area: http
  change: |
    reject requests with \#fragment in the URI path. The fragment is not allowed to be part of the request
    URI according to RFC3986 (3.5), RFC7230 (5.1) and RFC 7540 (8.1.2.3). Rejection of requests can be changed
    to stripping the \#fragment instead by setting the runtime guard ``envoy.reloadable_features.http_reject_path_with_fragment``
    to false. This behavior can further be changed to the deprecated behavior of keeping the fragment by setting the runtime
    guard ``envoy.reloadable_features.http_strip_fragment_from_path_unsafe_if_disabled``. This runtime guard must only be set
    to false when existing non-compliant traffic relies on \#fragment in URI. When this option is enabled, Envoy request
    authorization extensions may be bypassed. This override and its associated behavior will be decommissioned after the
    standard deprecation period.
- area: http
  change: |
    set the default :ref:`lazy headermap threshold <arch_overview_http_header_map_settings>` to 3,
    which defines the minimal number of headers in a request/response/trailers required for using a
    dictionary in addition to the list. Setting the ``envoy.http.headermap.lazy_map_min_size`` runtime
    feature to a non-negative number will override the default value.
- area: http
  change: |
    stop processing pending H/2 frames if connection transitioned to a closed state. This behavior can be temporarily reverted
    by setting the ``envoy.reloadable_features.skip_dispatching_frames_for_closed_connection`` to false.
- area: listener
  change: |
    added the :ref:`enable_reuse_port <envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port>`
    field and changed the default for ``reuse_port`` from false to true, as the feature is now well
    supported on the majority of production Linux kernels in use. The default change is aware of the hot
    restart, as otherwise, the change would not be backward compatible between restarts. This means
    that hot restarting onto a new binary will retain the default of false until the binary undergoes
    a full restart. To retain the previous behavior, either explicitly set the new configuration
    field to false, or set the runtime feature flag ``envoy.reloadable_features.listener_reuse_port_default_enabled``
    to false. As part of this change, the use of ``reuse_port`` for TCP listeners on both macOS and
    Windows has been disabled due to suboptimal behavior. See the field documentation for more
    information.
- area: listener
  change: |
    destroy per network filter chain stats when a network filter chain is removed during the listener in-place update.
- area: quic
  change: |
    enables IETF connection migration. This feature requires a stable UDP packet routine in the L4 load balancer with the
    same first-4-bytes in connection id. It can be turned off by setting runtime guard
    ``envoy.reloadable_features.FLAGS_quic_reloadable_flag_quic_connection_migration_use_new_cid_v2`` to false.
- area: thrift_proxy
  change: |
    allow Framed and Header transport combinations to perform :ref:`payload passthrough
    <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.ThriftProxy.payload_passthrough>`.

bug_fixes:
- area: access log
  change: |
    fix ``%UPSTREAM_CLUSTER%`` when used in http upstream access logs. Previously, it was always logging as an unset value.
- area: aws request signer
  change: |
    fix the AWS Request Signer extension to correctly normalize the path and query string to be signed according to AWS'
    guidelines, so that the hash on the server side matches. See `AWS SigV4 documentation
    <https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html>`_.
- area: cluster
  change: |
    delete pools when they're idle to fix unbounded memory use when using PROXY protocol upstream with tcp_proxy. This
    behavior can be temporarily reverted by setting the ``envoy.reloadable_features.conn_pool_delete_when_idle`` runtime guard
    to false.
- area: cluster
  change: |
    finish cluster warming even if hosts are removed before health check initialization. This only affected clusters with
    :ref:`ignore_health_on_host_removal <envoy_v3_api_field_config.cluster.v3.Cluster.ignore_health_on_host_removal>`.
- area: compressor
  change: |
    fix a bug where if trailers were added and a subsequent filter paused the filter chain, the request could be stalled.
    This behavior can be reverted by setting ``envoy.reloadable_features.fix_added_trailers`` to false.
- area: dynamic forward proxy
  change: |
    fixing a validation bug where san and sni checks were not applied setting :ref:`http_protocol_options
    <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` via
    :ref:`typed_extension_protocol_options <envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
- area: ext_authz
  change: |
    fix the ext_authz filter to correctly merge multiple same headers using the ',' as separator in the check request to
    the external authorization service.
- area: ext_authz
  change: |
    fix the use of ``append`` field of :ref:`response_headers_to_add
    <envoy_v3_api_field_service.auth.v3.OkHttpResponse.response_headers_to_add>` to set or append encoded response headers
    from a gRPC auth server.
- area: ext_authz
  change: |
    fix the HTTP ext_authz filter to respond with ``403 Forbidden`` when a gRPC auth server sends a denied check response
    with an empty HTTP status code.
- area: ext_authz
  change: |
    the network ext_authz filter now correctly sets dynamic metadata returned by the authorization service for non-OK responses.
    This behavior now matches the http ext_authz filter.
- area: hcm
  change: |
    remove deprecation for :ref:`xff_num_trusted_hops
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops>`
    and forbid mixing ip detection extensions with old related knobs.
- area: http
  change: |
    limit use of deferred resets in the http2 codec to server-side connections. Use of deferred reset for client connections
    can result in incorrect behavior and performance problems.
- area: listener
  change: |
    fixed an issue on Windows where connections are not handled by all worker threads.
- area: lua
  change: |
    fix ``BodyBuffer`` setting a Lua string and printing Lua string containing hex characters. Previously, ``BodyBuffer``
    setting a Lua string or printing strings with hex characters will be truncated.
- area: xray
  change: |
    fix the AWS X-Ray tracer bug where span's error, fault and throttle information was not reported properly as per the
    `AWS X-Ray documentation <https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html>`_. Before
    this fix, server error was reported under the 'annotations' section of the segment data.

removed_config_or_runtime:
- area: http
  change: |
    removed ``envoy.reloadable_features.http_upstream_wait_connect_response`` runtime guard and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.allow_preconnect`` runtime guard and legacy code paths.
- area: listener
  change: |
    removed ``envoy.reloadable_features.disable_tls_inspector_injection`` runtime guard and legacy code paths.
- area: ocsp
  change: |
    removed ``envoy.reloadable_features.check_ocsp_policy deprecation`` runtime guard and legacy code paths.
- area: ocsp
  change: |
    removed ``envoy.reloadable_features.require_ocsp_response_for_must_staple_certs deprecation`` and legacy code paths.
- area: quic
  change: |
    removed ``envoy.reloadable_features.prefer_quic_kernel_bpf_packet_routing`` runtime guard.

new_features:
- area: access_log
  change: |
    added :ref:`METADATA <envoy_v3_api_msg_extensions.formatter.metadata.v3.Metadata>` token to handle all types of metadata
    (DYNAMIC, CLUSTER, ROUTE).
- area: bootstrap
  change: |
    added :ref:`inline_headers <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.inline_headers>` in the bootstrap to make
    custom inline headers bootstrap configurable.
- area: contrib
  change: |
    added new :ref:`contrib images <install_contrib>` which contain contrib extensions.
- area: dns
  change: |
    added :ref:`V4_PREFERRED <envoy_v3_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.V4_PREFERRED>` option to return
    V6 addresses only if V4 addresses are not available.
- area: ext_authz
  change: |
    added :ref:`dynamic_metadata_from_headers
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.dynamic_metadata_from_headers>` to support
    emitting dynamic metadata from headers returned by an external authorization service via HTTP.
- area: grpc reverse bridge
  change: |
    added a new :ref:`option
    <envoy_v3_api_field_extensions.filters.http.grpc_http1_reverse_bridge.v3.FilterConfig.response_size_header>` to support
    streaming response bodies when withholding gRPC frames from the upstream.
- area: grpc_json_transcoder
  change: |
    added support to unescape '+' in query parameters to space with a new config field :ref:`query_param_unescape_plus
    <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.query_param_unescape_plus>`.
- area: http
  change: |
    added cluster_header in :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`
    to allow routing to the weighted cluster specified in the request_header.
- area: http
  change: |
    added :ref:`alternate_protocols_cache_options <envoy_v3_api_msg_config.core.v3.AlternateProtocolsCacheOptions>` for enabling
    HTTP/3 connections to servers which advertise HTTP/3 support via
    `HTTP Alternative Services <https://tools.ietf.org/html/rfc7838>`_ and caching the advertisements to disk.
- area: http
  change: |
    added :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>` in the header matcher.
- area: http
  change: |
    added :ref:`x-envoy-upstream-stream-duration-ms <config_http_filters_router_x-envoy-upstream-stream-duration-ms>` that
    allows configuring the max stream duration via a request header.
- area: http
  change: |
    added support for :ref:`max_requests_per_connection
    <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_requests_per_connection>` for both upstream and downstream
    connections.
- area: http
  change: |
    sanitizing the referer header as documented :ref:`here <config_http_conn_man_headers_referer>`. This feature can be
    temporarily turned off by setting runtime guard ``envoy.reloadable_features.sanitize_http_header_referer`` to false.
- area: http
  change: |
    validating outgoing HTTP/2 CONNECT requests to ensure that if ``:path`` is set that ``:protocol`` is present. This
    behavior can be temporarily turned off by setting runtime guard ``envoy.reloadable_features.validate_connect`` to false.
- area: jwt_authn
  change: |
    added support for :ref:`Jwt Cache <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.jwt_cache_config>`
    and its size can be specified by
    :ref:`jwt_cache_size <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtCacheConfig.jwt_cache_size>`.
- area: jwt_authn
  change: |
    added support for extracting JWTs from request cookies using
    :ref:`from_cookies <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.from_cookies>`.
- area: jwt_authn
  change: |
    added support for setting the extracted headers from a successfully verified JWT using
    :ref:`header_in_metadata <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.header_in_metadata>` to
    dynamic metadata.
- area: listener
  change: |
    new listener metric ``downstream_cx_transport_socket_connect_timeout`` to track transport socket timeouts.
- area: lua
  change: |
    added ``header:getAtIndex()`` and ``header:getNumValues()`` methods to :ref:`header object
    <config_http_filters_lua_header_wrapper>` for retrieving the value of a header at certain index and get the total number
    of values for a given header.
- area: matcher
  change: |
    added :ref:`invert <envoy_v3_api_field_type.matcher.v3.MetadataMatcher.invert>` for inverting the match result in the
    metadata matcher.
- area: overload
  change: |
    add a new overload action that resets streams using a lot of memory. To enable the tracking of allocated bytes in buffers
    that a stream is using we need to configure the minimum threshold for tracking via
    :ref:`buffer_factory_config <envoy_v3_api_field_config.overload.v3.OverloadManager.buffer_factory_config>`. We have an
    overload action ``Envoy::Server::OverloadActionNameValues::ResetStreams`` that takes advantage of the tracking to reset
    the most expensive stream first.
- area: rbac
  change: |
    added :ref:`destination_port_range <envoy_v3_api_field_config.rbac.v3.Permission.destination_port_range>` for matching
    range of destination ports.
- area: rbac
  change: |
    added :ref:`matcher <envoy_v3_api_field_config.rbac.v3.Permission.matcher>` along with extension category
    ``extension_category_envoy.rbac.matchers`` for custom RBAC permission matchers. Added reference implementation for matchers
    :ref:`envoy.rbac.matchers.upstream_ip_port <extension_envoy.rbac.matchers.upstream_ip_port>`.
- area: route config
  change: |
    added :ref:`dynamic_metadata <envoy_v3_api_field_config.route.v3.RouteMatch.dynamic_metadata>` for routing based on dynamic
    metadata.
- area: router
  change: |
    added retry options predicate extensions configured via :ref:`retry_options_predicates.
    <envoy_v3_api_field_config.route.v3.RetryPolicy.retry_options_predicates>` These extensions allow modification of requests
    between retries at the router level. There are not currently any built-in extensions that implement this extension point.
- area: router
  change: |
    added :ref:`per_try_idle_timeout <envoy_v3_api_field_config.route.v3.RetryPolicy.per_try_idle_timeout>` timeout configuration.
- area: router
  change: |
    added an optional :ref:`override_auto_sni_header
    <envoy_v3_api_field_config.core.v3.UpstreamHttpProtocolOptions.override_auto_sni_header>` to support setting SNI value
    from an arbitrary header other than host/authority.
- area: sxg_filter
  change: |
    added filter to transform response to SXG package to :ref:`contrib images <install_contrib>`. This can be enabled by setting
    :ref:`SXG <envoy_v3_api_msg_extensions.filters.http.sxg.v3alpha.SXG>` configuration.
- area: thrift_proxy
  change: |
    added support for :ref:`mirroring requests
    <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.RouteAction.request_mirror_policies>`.
- area: udp
  change: |
    allows updating filter chain in-place through LDS, which is supported by Quic listener. Such listener config will be
    rejected in other connection-less UDP listener implementations. It can be reverted by
    ``envoy.reloadable_features.udp_listener_updates_filter_chain_in_place``.
- area: udp
  change: |
    disallow L4 filter chain in config which configures connection-less UDP listener. It can be reverted by
    ``envoy.reloadable_features.udp_listener_updates_filter_chain_in_place``.
- area: upstream
  change: |
    added support for :ref:`slow start mode <arch_overview_load_balancing_slow_start>`, which allows to progresively increase
    traffic for new endpoints.
- area: upstream
  change: |
    extended :ref:`Round Robin load balancer configuration <envoy_v3_api_field_config.cluster.v3.Cluster.round_robin_lb_config>`
    with :ref:`slow start <envoy_v3_api_field_config.cluster.v3.Cluster.RoundRobinLbConfig.slow_start_config>` support.
- area: upstream
  change: |
    extended :ref:`Least Request load balancer configuration
    <envoy_v3_api_field_config.cluster.v3.Cluster.least_request_lb_config>` with :ref:`slow start
    <envoy_v3_api_field_config.cluster.v3.Cluster.LeastRequestLbConfig.slow_start_config>` support.
- area: windows
  change: |
    added a new container image based on Windows Nanoserver 2022.
- area: xray
  change: |
    request direction (``ingress`` or ``egress``) is recorded as X-Ray trace segment's annotation by name ``direction``.

deprecated:
- area: api
  change: |
    the :ref:`matcher <envoy_v3_api_field_extensions.common.matching.v3.ExtensionWithMatcher.matcher>` field has been
    deprecated in favor of :ref:`matcher <envoy_v3_api_field_extensions.common.matching.v3.ExtensionWithMatcher.xds_matcher>`
    in order to break a build dependency.
- area: cluster
  change: |
    :ref:`max_requests_per_connection <envoy_v3_api_field_config.cluster.v3.Cluster.max_requests_per_connection>` is deprecated
    in favor of
    :ref:`max_requests_per_connection <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_requests_per_connection>`.
- area: http
  change: |
    the HeaderMatcher fields :ref:`exact_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.exact_match>`,
    :ref:`safe_regex_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.safe_regex_match>`,
    :ref:`prefix_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.prefix_match>`,
    :ref:`suffix_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.suffix_match>` and
    :ref:`contains_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.contains_match>` are deprecated by :ref:`string_match
    <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
- area: listener
  change: |
    :ref:`reuse_port <envoy_v3_api_field_config.listener.v3.Listener.reuse_port>` has been
    deprecated in favor of :ref:`enable_reuse_port <envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port>`.
    At the same time, the default has been changed from false to true. See above for more information.
date: May 11, 2021

new_features:
- area: http
  change: |
    added the ability to :ref:`unescape slash sequences
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.path_with_escaped_slashes_action>`
    in the path. Requests with unescaped slashes can be proxied, rejected or redirected to the new unescaped path. By
    default this feature is disabled. The default behavior can be overridden through
    :ref:`http_connection_manager.path_with_escaped_slashes_action
    <config_http_conn_man_runtime_path_with_escaped_slashes_action>` runtime variable. This action can be selectively
    enabled for a portion of requests by setting the :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling
    <config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled>` runtime variable.
date: April 4, 2023

behavior_changes:
- area: http
  change: |
    validate upstream request header names and values. The new runtime flag
    ``envoy.reloadable_features.validate_upstream_headers`` can be used for revert this behavior.

bug_fixes:
- area: grpc
  change: |
    when Envoy was configured to use ext_authz, ext_proc, tap, ratelimit filters, and grpc access log service and an http
    header with non-UTF-8 data was received, Envoy would generate an invalid protobuf message and send it to the configured
    service. The receiving service would typically generate an error when decoding the protobuf message. For ext_authz that
    was configured with ``failure_mode_allow: true``, the request would have been allowed in this case. For the other services,
    this could have resulted in other unforseen errors such as a lack of visibility into requests (eg request not logged). Envoy
    will now by default sanitize the values sent in gRPC service calls to be valid UTF-8, replacing data that is not valid UTF-8
    with a '!' character. This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.service_sanitize_non_utf8_strings`` to false.
- area: http
  change: |
    fixed a bug where ``x-envoy-original-path`` was not being sanitized when sent from untrusted users. This behavioral change
    can be temporarily reverted by setting ``envoy.reloadable_features.sanitize_original_path`` to false.
- area: http
  change: |
    stop forwarding ``:method`` value which is not a valid token defined in https://www.rfc-editor.org/rfc/rfc9110#section-5.6.2.
    Also, reject ``:method`` and ``:scheme`` headers with multiple values.
- area: http3
  change: |
    reject pseudo headers violating RFC 9114. Specifically, pseudo-header fields with more than one value for the ``:method``
    (non-``CONNECT``), ``:scheme``, and ``:path``; or pseudo-header fields after regular header fields; or undefined
    pseudo-headers.
- area: lua
  change: |
    lua coroutine should not execute after local reply is sent.
- area: oauth
  change: |
    fixed a bug where the oauth2 filter would crash if it received a redirect URL without a state query param set.
date: April 26, 2023

bug_fixes:
- area: tls
  change: |
    Fix build FIPS compliance when using both FIPS mode and Wasm extensions (``--define boringssl=fips`` and ``--define wasm=v8``).
date: April 15, 2021

bug_fixes:
- area: code
  change: |
    fixed some whitespace to make fix_format happy.
date: October 8, 2019

changes:
- area: http
  change: |
    fixed CVE-2019-15226 by adding a cached byte size in HeaderMap.
- area: http
  change: |
    added :ref:`max headers count <envoy_api_field_core.HttpProtocolOptions.max_headers_count>` for http connections. The
    default limit is 100.
- area: upstream
  change: |
    runtime feature ``envoy.reloadable_features.max_response_headers_count`` overrides the default limit for upstream
    :ref:`max headers count <envoy_api_field_Cluster.common_http_protocol_options>`.
- area: http
  change: |
    added :ref:`common_http_protocol_options
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.common_http_protocol_options>`
    Runtime feature ``envoy.reloadable_features.max_request_headers_count`` overrides the default limit for downstream
    :ref:`max headers count
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.common_http_protocol_options>`.
- area: regex
  change: |
    backported safe regex matcher fix for CVE-2019-15225.

deprecated:
- area: hcm
  change: |
    Use of :ref:`idle_timeout
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.idle_timeout>` is deprecated.
    Use :ref:`common_http_protocol_options
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.common_http_protocol_options>`
    instead.
date: June 14, 2022

minor_behavior_changes:
- area: tls
  change: |
    if both :ref:`match_subject_alt_names
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_subject_alt_names>` and
    :ref:`match_typed_subject_alt_names
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>` are
    specified, the former (deprecated) field is ignored. Previously, setting both fields would result in an error.

bug_fixes:
- area: docker
  change: |
    update Docker images (``distroless`` -> ``d65ac1a``) to resolve CVE issues in container packages.
date: April 8, 2020

changes:
- area: request_id_extension
  change: |
    fixed static initialization for noop request id extension.
date: March 24, 2023

bug_fixes:
- area: dependency
  change: |
    update Wasmtime -> 6.0.1, to resolve CVE-2023-26489, CVE-2023-27477.
date: June 9, 2022

bug_fixes:
- area: decompression
  change: |
    fixed CVE-2022-29225 due to which decompressors can be zip bombed. Previously decompressors were susceptible to memory
    inflation in takes in which specially crafted payloads could cause a large amount of memory usage by Envoy. The max
    inflation payload size is now limited.  This change can be reverted via the
    ``envoy.reloadable_features.enable_compression_bomb_protection`` runtime flag.
- area: health_check
  change: |
    fixed CVE-2022-29224 which caused a segfault in GrpcHealthCheckerImpl. An attacker-controlled upstream server that is
    health checked using gRPC health checking can crash Envoy via a null pointer dereference in certain circumstances.
- area: oauth
  change: |
    fixed CVE-2022-29226 due to which oauth filter allows trivial bypass. The OAuth filter implementation does not include a
    mechanism for validating access tokens, so by design when the HMAC signed cookie is missing a full authentication flow
    should be triggered. However, the current implementation assumes that access tokens are always validated thus allowing
    access in the presence of any access token attached to the request.
- area: oauth
  change: |
    fixed CVE-2022-29228 due to which oauth filter calls continueDecoding() from within decodeHeaders(). The OAuth filter
    would try to invoke the remaining filters in the chain after emitting a local response, which triggers an ASSERT() in
    newer versions and corrupts memory on earlier versions.
- area: router
  change: |
    fixed CVE-2022-29227 which caused an internal redirect crash for requests with body/trailers. Envoy would previously
    crash in some cases when processing internal redirects for requests with bodies or trailers if the redirect prompts an
    Envoy-generated local reply.
date: April 25, 2022

minor_behavior_changes:
- area: perf
  change: |
    ssl contexts are now tracked without scan based garbage collection and greatly improved the performance on secret
    update.

bug_fixes:
- area: docker
  change: |
    update Docker images to resolve CVE issues in container packages (#20760).
date: March 1, 2023

bug_fixes:
- area: dependency
  change: |
    update Kafka to resolve CVE-2023-25194.

new_features:
- area: docker
  change: |
    unify published images as tag variants. For example, ``envoyproxy/envoy-dev`` is now available
    as ``envoyproxy/envoy:dev``.

deprecated:
- area: ext_authz
  change: |
    deprecated (1.25.0) :ref:`ext_authz.v3.AuthorizationRequest.allowed_headers
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationRequest.allowed_headers>` in favour
    of :ref:`ext_authz.v3.ExtAuthz.allowed_headers
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.allowed_headers>`.
date: July 7, 2020

changes:
- area: access log
  change: |
    access logger extensions use the "envoy.access_loggers" name space. A mapping
    of extension names is available in the :ref:`deprecated <deprecated>` documentation.
- area: access log
  change: |
    added support for ``%DOWNSTREAM_LOCAL_PORT%`` :ref:`access log formatters <config_access_log_format>`.
- area: access log
  change: |
    fixed ``%DOWSTREAM_DIRECT_REMOTE_ADDRESS%`` when used with PROXY protocol listener filter.
- area: access log
  change: |
    introduced :ref:`connection-level access loggers <envoy_api_field_Listener.access_log>`.
- area: adaptive concurrency
  change: |
    fixed bug that allowed concurrency limits to drop below the configured
    minimum.
- area: adaptive concurrency
  change: |
    minRTT is now triggered when the minimum concurrency is maintained for 5
    consecutive sampling intervals.
- area: admin
  change: |
    added support for displaying ip address subject alternate names in :ref:`certs <operations_admin_interface_certs>`
    end point.
- area: admin
  change: |
    added :http:post:`/reopen_logs` endpoint to control log rotation.
- area: api
  change: |
    froze v2 xDS API. New feature development in the API should occur in v3 xDS. While the v2 xDS API has
    been deprecated since 1.13.0, it will continue to be supported by Envoy until EOY 2020. See
    :ref:`api_supported_versions`.
- area: aws_lambda
  change: |
    added :ref:`AWS Lambda filter <config_http_filters_aws_lambda>` that converts HTTP requests to Lambda
    invokes. This effectively makes Envoy act as an egress gateway to AWS Lambda.
- area: aws_request_signing
  change: |
    a few fixes so that it works with S3.
- area: config
  change: |
    added stat :ref:`update_time <config_cluster_manager_cds>`.
- area: config
  change: |
    use type URL to select an extension whenever the config type URL (or its previous versions) uniquely identify a typed
    extension, see :ref:`extension configuration <config_overview_extension_configuration>`.
- area: datasource
  change: |
    added retry policy for remote async data source.
- area: dns
  change: |
    added support for :ref:`dns_failure_refresh_rate
    <envoy_api_field_config.common.dynamic_forward_proxy.v2alpha.DnsCacheConfig.dns_failure_refresh_rate>` for the :ref:`dns
    cache <envoy_api_msg_config.common.dynamic_forward_proxy.v2alpha.DnsCacheConfig>` to set the DNS refresh rate during
    failures.
- area: dns
  change: |
    the STRICT_DNS cluster now only resolves to 0 hosts if DNS resolution successfully returns 0 hosts.
- area: eds
  change: |
    added :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.hostname>` field for endpoints and :ref:`hostname
    <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>` field for endpoint's health check config.
    This enables auto host rewrite and customizing the host header during health checks for eds endpoints.
- area: ext_authz
  change: |
    disabled the use of lowercase string matcher for headers matching in HTTP-based ``ext_authz``.
    Can be reverted temporarily by setting runtime feature
    ``envoy.reloadable_features.ext_authz_http_service_enable_case_sensitive_string_matcher`` to false.
- area: fault
  change: |
    added support for controlling abort faults with :ref:`HTTP header fault configuration
    <config_http_filters_fault_injection_http_header>` to the HTTP fault filter.
- area: grpc-json
  change: |
    added support for building HTTP request into
    `google.api.HttpBody <https://github.com/googleapis/googleapis/blob/master/google/api/httpbody.proto>`_.
- area: grpc-stats
  change: |
    added option to limit which messages stats are created for.
- area: http
  change: |
    added HTTP/1.1 flood protection. Can be temporarily disabled using the runtime feature
    ``envoy.reloadable_features.http1_flood_protection``.
- area: http
  change: |
    added :ref:`headers_with_underscores_action setting <envoy_api_field_core.HttpProtocolOptions.headers_with_underscores_action>`
    to control how client requests with header names containing underscore characters are handled. The options are to allow such
    headers, reject request or drop headers. The default is to allow headers, preserving existing behavior.
- area: http
  change: |
    added :ref:`max_stream_duration <envoy_api_field_core.HttpProtocolOptions.max_stream_duration>` to specify the duration of
    existing streams. See :ref:`connection and stream timeouts <faq_configuration_timeouts>`.
- area: http
  change: |
    connection header sanitizing has been modified to always sanitize if there is no upgrade, including when an h2c upgrade
    attempt has been removed.
- area: http
  change: |
    fixed a bug that could send extra METADATA frames and underflow memory when encoding METADATA frames on a connection that was
    dispatching data.
- area: http
  change: |
    fixing a bug in HTTP/1.0 responses where Connection: keep-alive was not appended for connections which were kept alive.
- area: http
  change: |
    http filter extensions use the "envoy.filters.http" name space. A mapping of extension names is available in the
    :ref:`deprecated <deprecated>` documentation.
- area: http
  change: |
    the runtime feature ``http.connection_manager.log_flood_exception`` is removed and replaced with a connection access log
    response code.
- area: http
  change: |
    upgrade parser library, which removes support for "identity" transfer-encoding value.
- area: listener filters
  change: |
    listener filter extensions use the "envoy.filters.listener" name space. A
    mapping of extension names is available in the :ref:`deprecated <deprecated>` documentation.
- area: listeners
  change: |
    added :ref:`listener filter matcher api <envoy_api_field_listener.ListenerFilter.filter_disabled>` to disable individual
    listener filter on matching downstream connections.
- area: loadbalancing
  change: |
    added support for using hostname for consistent hash loadbalancing via :ref:`consistent_hash_lb_config
    <envoy_api_field_Cluster.CommonLbConfig.consistent_hashing_lb_config>`.
- area: loadbalancing
  change: |
    added support for :ref:`retry host predicates <envoy_api_field_route.RetryPolicy.retry_host_predicate>` in conjunction
    with consistent hashing load balancers (ring hash and maglev).
- area: lua
  change: |
    added a parameter to ``httpCall`` that makes it possible to have the call be asynchronous.
- area: lua
  change: |
    added moonjit support.
- area: mongo
  change: |
    the stat emitted for queries without a max time set in the :ref:`MongoDB filter <config_network_filters_mongo_proxy>` was
    modified to emit correctly for Mongo v3.2+.
- area: network filters
  change: |
    added a :ref:`direct response filter <config_network_filters_direct_response>`.
- area: network filters
  change: |
    network filter extensions use the "envoy.filters.network" name space. A mapping of extension names is available in the
    :ref:`deprecated <deprecated>` documentation.
- area: rbac
  change: |
    added :ref:`remote_ip <envoy_api_field_config.rbac.v2.Principal.remote_ip>` and :ref:`direct_remote_ip
    <envoy_api_field_config.rbac.v2.Principal.direct_remote_ip>` for matching downstream remote IP address.
- area: rbac
  change: |
    deprecated :ref:`source_ip <envoy_api_field_config.rbac.v2.Principal.source_ip>` with
    :ref:`direct_remote_ip <envoy_api_field_config.rbac.v2.Principal.direct_remote_ip>` and
    :ref:`remote_ip <envoy_api_field_config.rbac.v2.Principal.remote_ip>`.
- area: request_id_extension
  change: |
    added an ability to extend request ID handling at :ref:`HTTP connection manager
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.request_id_extension>`.
- area: retry
  change: |
    added a retry predicate that :ref:`rejects hosts based on metadata.
    <envoy_api_field_route.RetryPolicy.retry_host_predicate>`.
- area: router
  change: |
    added ability to set attempt count in downstream response, see :ref:`virtual host's include response attempt count config
    <envoy_api_field_route.VirtualHost.include_attempt_count_in_response>`.
- area: router
  change: |
    added additional stats for :ref:`virtual clusters <config_http_filters_router_vcluster_stats>`.
- area: router
  change: |
    added :ref:`auto_san_validation <envoy_api_field_core.UpstreamHttpProtocolOptions.auto_san_validation>` to support
    overrriding SAN validation to transport socket for new upstream connections based on the downstream HTTP host/authority
    header.
- area: router
  change: |
    added the ability to match a route based on whether a downstream TLS connection certificate has been
    :ref:`validated <envoy_api_field_route.RouteMatch.TlsContextMatchOptions.validated>`.
- area: router
  change: |
    added support for :ref:`regex_rewrite
    <envoy_api_field_route.RouteAction.regex_rewrite>` for path rewriting using regular expressions and capture groups.
- area: router
  change: |
    added support for ``%DOWNSTREAM_LOCAL_PORT%`` :ref:`header formatter <config_http_conn_man_headers_custom_request_headers>`.
- area: router
  change: |
    don't ignore :ref:`per_try_timeout <envoy_api_field_route.RetryPolicy.per_try_timeout>` when the
    :ref:`global route timeout <envoy_api_field_route.RouteAction.timeout>` is disabled.
- area: router
  change: |
    strip whitespace for :ref:`retry_on <envoy_api_field_route.RetryPolicy.retry_on>`, :ref:`grpc-retry-on header
    <config_http_filters_router_x-envoy-retry-grpc-on>` and :ref:`retry-on header <config_http_filters_router_x-envoy-retry-on>`.
- area: runtime
  change: |
    enabling the runtime feature ``envoy.deprecated_features.allow_deprecated_extension_names`` disables the use of deprecated
    extension names.
- area: runtime
  change: |
    integer values may now be parsed as booleans.
- area: sds
  change: |
    added :ref:`GenericSecret <envoy_api_msg_auth.GenericSecret>` to support secret of generic type.
- area: sds
  change: |
    added :ref:`certificate rotation <xds_certificate_rotation>` support for certificates in static resources.
- area: server
  change: |
    the SIGUSR1 access log reopen warning now is logged at info level.
- area: stat sinks
  change: |
    stat sink extensions use the ``envoy.stat_sinks`` name space. A mapping of extension names is available in the
    :ref:`deprecated <deprecated>` documentation.
- area: thrift_proxy
  change: |
    added router filter stats to docs.
- area: tls
  change: |
    added configuration to disable stateless TLS session resumption :ref:`disable_stateless_session_resumption
    <envoy_api_field_auth.DownstreamTlsContext.disable_stateless_session_resumption>`.
- area: tracing
  change: |
    added gRPC service configuration to the OpenCensus Stackdriver and OpenCensus Agent tracers.
- area: tracing
  change: |
    tracer extensions use the "envoy.tracers" name space. A mapping of extension names is available in the
    :ref:`deprecated <deprecated>` documentation.
- area: upstream
  change: |
    added ``upstream_rq_retry_limit_exceeded`` to :ref:`cluster <config_cluster_manager_cluster_stats>`, and
    :ref:`virtual cluster <config_http_filters_router_vcluster_stats>` stats.
- area: upstream
  change: |
    changed load distribution algorithm when all priorities enter
    :ref:`panic mode <arch_overview_load_balancing_panic_threshold>`.
- area: upstream
  change: |
    combined HTTP/1 and HTTP/2 connection pool code. This means that circuit breaker limits for both requests and connections
    apply to both pool types. Also, HTTP/2 now has the option to limit concurrent requests on a connection, and allow multiple
    draining connections. The old behavior is deprecated, but can be used during the deprecation period by disabling runtime
    feature ``envoy.reloadable_features.new_http1_connection_pool_behavior`` or
    ``envoy.reloadable_features.new_http2_connection_pool_behavior`` and then re-configure your clusters or restart Envoy.
    The behavior will not switch until the connection pools are recreated. The new circuit breaker behavior is described
    :ref:`here <arch_overview_circuit_break>`.
- area: zlib
  change: |
    by default zlib is initialized to use its default strategy (Z_DEFAULT_STRATEGY)
    instead of the fixed one (Z_FIXED). The difference is that the use of dynamic
    Huffman codes is enabled now resulting in better compression ratio for normal data.

deprecated:
- area: circuit_breaker
  change: |
    The previous behavior for upstream connection pool circuit breaking described
    `here <https://www.envoyproxy.io/docs/envoy/v1.13.0/intro/arch_overview/upstream/circuit_breaking>`_ has
    been deprecated in favor of the new behavior described :ref:`here <arch_overview_circuit_break>`.
- area: logging
  change: |
    Access Logger, Listener Filter, HTTP Filter, Network Filter, Stats Sink, and Tracer names have been deprecated in favor of
    the extension name from the envoy build system. Disable the runtime feature
    ``envoy.deprecated_features.allow_deprecated_extension_names`` to disallow the deprecated names. Use of these extension
    names generates a log message and increments the ``deprecated_feature_use`` metric in stats.

    .. csv-table::
      :header: Canonical Names, Deprecated Names
      :widths: 1, 1

      envoy.access_loggers.file, envoy.file_access_log
      envoy.access_loggers.http_grpc, envoy.http_grpc_access_log
      envoy.access_loggers.tcp_grpc, envoy.tcp_grpc_access_log
      envoy.filters.http.buffer, envoy.buffer
      envoy.filters.http.cors, envoy.cors
      envoy.filters.http.csrf, envoy.csrf
      envoy.filters.http.dynamo, envoy.http_dynamo_filter
      envoy.filters.http.ext_authz, envoy.ext_authz
      envoy.filters.http.fault, envoy.fault
      envoy.filters.http.grpc_http1_bridge, envoy.grpc_http1_bridge
      envoy.filters.http.grpc_json_transcoder, envoy.grpc_json_transcoder
      envoy.filters.http.grpc_web, envoy.grpc_web
      envoy.filters.http.gzip, envoy.gzip
      envoy.filters.http.health_check, envoy.health_check
      envoy.filters.http.ip_tagging, envoy.ip_tagging
      envoy.filters.http.lua, envoy.lua
      envoy.filters.http.ratelimit, envoy.rate_limit
      envoy.filters.http.router, envoy.router
      envoy.filters.http.squash, envoy.squash
      envoy.filters.listener.http_inspector, envoy.listener.http_inspector
      envoy.filters.listener.original_dst, envoy.listener.original_dst
      envoy.filters.listener.original_src, envoy.listener.original_src
      envoy.filters.listener.proxy_protocol, envoy.listener.proxy_protocol
      envoy.filters.listener.tls_inspector, envoy.listener.tls_inspector
      envoy.filters.network.client_ssl_auth, envoy.client_ssl_auth
      envoy.filters.network.echo, envoy.echo
      envoy.filters.network.ext_authz, envoy.ext_authz
      envoy.filters.network.http_connection_manager, envoy.http_connection_manager
      envoy.filters.network.mongo_proxy, envoy.mongo_proxy
      envoy.filters.network.ratelimit, envoy.ratelimit
      envoy.filters.network.redis_proxy, envoy.redis_proxy
      envoy.filters.network.tcp_proxy, envoy.tcp_proxy
      envoy.stat_sinks.dog_statsd, envoy.dog_statsd
      envoy.stat_sinks.metrics_service, envoy.metrics_service
      envoy.stat_sinks.statsd, envoy.statsd
      envoy.tracers.dynamic_ot, envoy.dynamic.ot
      envoy.tracers.lightstep, envoy.lightstep
      envoy.tracers.zipkin, envoy.zipkin

    .. note::
      Some renamed filters produce metadata using their filter name as the metadata namespace:

      * Mongo Proxy Filter
      * Zookeeper Filter

      The metadata generated by these filters may be consumed by the following extensions, whose
      configurations may need to be adjusted to use the new names.

      * Access Loggers
      * HTTP and Network Ext Authz filters
      * HTTP and Network RBAC filters
      * Tracers

- area: matching
  change: |
    The previous behavior of auto ignoring case in headers matching:
    :ref:`allowed_headers <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationRequest.allowed_headers>`,
    :ref:`allowed_upstream_headers <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_upstream_headers>`,
    and :ref:`allowed_client_headers <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_client_headers>`
    of HTTP-based ``ext_authz`` has been deprecated in favor of explicitly setting the
    :ref:`ignore_case <envoy_api_field_type.matcher.StringMatcher.ignore_case>` field.
- area: route_checker_tool
  change: |
    The ``header_fields``, ``custom_header_fields``, and ``additional_headers`` fields for the route checker
    tool have been deprecated in favor of ``request_header_fields``, ``response_header_fields``,
    ``additional_request_headers``, and ``additional_response_headers``.
- area: compression
  change: |
    The ``content_length``, ``content_type``, ``disable_on_etag_header`` and ``remove_accept_encoding_header``
    fields in :ref:`HTTP Gzip filter config <envoy_api_msg_config.filter.http.gzip.v2.Gzip>` have
    been deprecated in favor of ``compressor``.
- area: compression
  change: |
    The statistics counter ``header_gzip`` in :ref:`HTTP Gzip filter <config_http_filters_gzip>`
    has been deprecated in favor of ``header_compressor_used``.
- area: streaming
  change: |
    Support for the undocumented HTTP/1.1 ``:no-chunks`` pseudo-header has been removed. If an extension
    was using this it can achieve the same behavior via the new ``http1StreamEncoderOptions()`` API.
- area: grpc_stats
  change: |
    The grpc_stats filter behavior of by default creating a new stat for every message type seen is deprecated.
    The default will switch to only creating a fixed set of stats. The previous behavior can be enabled by enabling
    :ref:`stats_for_all_methods <envoy_api_field_config.filter.http.grpc_stats.v2alpha.FilterConfig.stats_for_all_methods>`,
    and the previous default can be enabled until the end of the deprecation period by enabling runtime feature
    ``envoy.deprecated_features.grpc_stats_filter_enable_stats_for_all_methods_by_default``.
- area: rbac
  change: |
    The :ref:`source_ip <envoy_api_field_config.rbac.v2.Principal.source_ip>` field in
    `RBAC <https://github.com/envoyproxy/envoy/blob/release/v1.14/api/envoy/config/rbac/v2/rbac.proto>`_ has been deprecated
    in favor of :ref:`direct_remote_ip <envoy_api_field_config.rbac.v2.Principal.direct_remote_ip>` and
    :ref:`remote_ip <envoy_api_field_config.rbac.v2.Principal.remote_ip>`.
date: July 25, 2022

bug_fixes:
- area: docker
  change: |
    update Docker images (``distroless`` -> ``49d2923f35d6``) to resolve CVE issues in container packages.
date: April 15, 2021

behavior_changes:
- area: config
  change: |
    the v2 xDS API is no longer supported by the Envoy binary.
- area: grpc_stats
  change: |
    the default value for :ref:`stats_for_all_methods
    <envoy_v3_api_field_extensions.filters.http.grpc_stats.v3.FilterConfig.stats_for_all_methods>` is switched from true to
    false, in order to avoid possible memory exhaustion due to an untrusted downstream sending a large number of unique
    method names. The previous default value was deprecated in version 1.14.0. This only changes the behavior when the value
    is not set. The previous behavior can be used by setting the value to true. This behavior change by be overridden by
    setting runtime feature ``envoy.deprecated_features.grpc_stats_filter_enable_stats_for_all_methods_by_default``.
- area: http
  change: |
    fixing a standards compliance issue with :scheme. The :scheme header sent upstream is now based on the original URL
    scheme, rather than set based on the security of the upstream connection. This behavior can be temporarily reverted by
    setting ``envoy.reloadable_features.preserve_downstream_scheme`` to false.
- area: http
  change: |
    http3 is now enabled/disabled via build option ``--define http3=disabled`` rather than the extension framework. The
    behavior is the same, but builds may be affected for platforms or build configurations where http3 is not supported.
- area: http
  change: |
    resolving inconsistencies between :scheme and X-Forwarded-Proto. :scheme will now be set for all HTTP/1.1 requests. This
    changes the behavior of the gRPC access logger, Wasm filters, CSRF filter and oath2 filter for HTTP/1 traffic, where
    :scheme was previously not set. This change also validates that for front-line Envoys (Envoys configured with
    :ref:`xff_num_trusted_hops
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops>`
    set to 0 and :ref:`use_remote_address
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>` set
    to true) that HTTP/1.1 https schemed requests can not be sent over non-TLS connections. All behavioral changes listed
    here can be temporarily reverted by setting ``envoy.reloadable_features.add_and_validate_scheme_header`` to false.
- area: http
  change: |
    when a protocol error is detected in response from upstream, Envoy sends 502 BadGateway downstream and access log entry
    contains UPE flag. This behavior change can be overwritten to use error code 503 by setting
    ``envoy.reloadable_features.return_502_for_upstream_protocol_errors`` to false.

minor_behavior_changes:
- area: access_logs
  change: |
    change command operator %UPSTREAM_CLUSTER% to resolve to :ref:`alt_stat_name
    <envoy_v3_api_field_config.cluster.v3.Cluster.alt_stat_name>` if provided. This behavior can be reverted by disabling
    the runtime feature ``envoy.reloadable_features.use_observable_cluster_name``.
- area: access_logs
  change: |
    fix substition formatter to recognize commands ending with an integer such as DOWNSTREAM_PEER_FINGERPRINT_256.
- area: access_logs
  change: |
    set the error flag ``NC`` for ``no cluster found`` instead of ``NR`` if the route is found but the corresponding cluster
    is not available.
- area: admin
  change: |
    added :ref:`observability_name <envoy_v3_api_field_admin.v3.ClusterStatus.observability_name>` information to GET
    /clusters?format=json :ref:`cluster status <envoy_v3_api_msg_admin.v3.ClusterStatus>`.
- area: dns
  change: |
    both the :ref:`strict DNS <arch_overview_service_discovery_types_strict_dns>` and :ref:`logical DNS
    <arch_overview_service_discovery_types_logical_dns>` cluster types now honor the :ref:`hostname
    <envoy_v3_api_field_config.endpoint.v3.Endpoint.hostname>` field if not empty. Previously resolved hosts would have
    their hostname set to the configured DNS address for use with logging, :ref:`auto_host_rewrite
    <envoy_api_field_route.RouteAction.auto_host_rewrite>`, etc. Setting the hostname manually allows overriding the
    internal hostname used for such features while still allowing the original DNS resolution name to be used.
- area: grpc_json_transcoder
  change: |
    the filter now adheres to encoder and decoder buffer limits. Requests and responses that require buffering over the
    limits will be directly rejected. The behavior can be reverted by disabling runtime feature
    ``envoy.reloadable_features.grpc_json_transcoder_adhere_to_buffer_limits``. To reduce or increase the buffer limits the
    filter adheres to, reference the :ref:`flow control documentation <faq_flow_control>`.
- area: hds
  change: |
    support custom health check port via :ref:`health_check_config
    <envoy_v3_api_msg_config.endpoint.v3.endpoint.healthcheckconfig>`.
- area: healthcheck
  change: |
    the :ref:`health check filter <config_http_filters_health_check>` now sends the :ref:`x-envoy-immediate-health-check-
    fail <config_http_filters_router_x-envoy-immediate-health-check-fail>` header for all responses when Envoy is in the
    health check failed state. Additionally, receiving the :ref:`x-envoy-immediate-health-check-fail
    <config_http_filters_router_x-envoy-immediate-health-check-fail>` header (either in response to normal traffic or in
    response to an HTTP :ref:`active health check <arch_overview_health_checking>`) will cause Envoy to immediately
    :ref:`exclude <arch_overview_load_balancing_excluded>` the host from load balancing calculations. This has the useful
    property that such hosts, which are being explicitly told to disable traffic, will not be counted for panic routing
    calculations. See the excluded documentation for more information. This behavior can be temporarily reverted by setting
    the ``envoy.reloadable_features.health_check.immediate_failure_exclude_from_cluster`` feature flag to false. Note that
    the runtime flag covers *both* the health check filter responding with ``x-envoy-immediate-health-check-fail`` in all
    cases (versus just non-HC requests) as well as whether receiving ``x-envoy-immediate-health-check-fail`` will cause
    exclusion or not. Thus, depending on the Envoy deployment, the feature flag may need to be flipped on both downstream
    and upstream instances, depending on the reason.
- area: http
  change: |
    added support for internal redirects with bodies. This behavior can be disabled temporarily by setting
    ``envoy.reloadable_features.internal_redirects_with_body`` to false.
- area: http
  change: |
    increase the maximum allowed number of initial connection WINDOW_UPDATE frames sent by the peer from 1 to 5.
- area: http
  change: |
    no longer adding content-length: 0 for requests which should not have bodies. This behavior can be temporarily reverted
    by setting ``envoy.reloadable_features.dont_add_content_length_for_bodiless_requests`` false.
- area: http
  change: |
    switched the path canonicalizer to `googleurl <https://quiche.googlesource.com/googleurl>`_ instead of
    ``//source/common/chromium_url``. The new path canonicalizer is enabled by default. To revert to the legacy path
    canonicalizer, enable the runtime flag ``envoy.reloadable_features.remove_forked_chromium_url``.
- area: http
  change: |
    upstream flood and abuse checks now increment the count of opened HTTP/2 streams when Envoy sends initial HEADERS frame
    for the new stream. Before the counter was incrementred when Envoy received response HEADERS frame with the END_HEADERS
    flag set from upstream server.
- area: lua
  change: |
    added function ``timestamp`` to provide millisecond resolution timestamps by passing in
    ``EnvoyTimestampResolution.MILLISECOND``.
- area: oauth filter
  change: |
    added the optional parameter :ref:`auth_scopes
    <envoy_v3_api_field_extensions.filters.http.oauth2.v3alpha.OAuth2Config.auth_scopes>` with default value of 'user' if
    not provided. This allows this value to be overridden in the Authorization request to the OAuth provider.
- area: perf
  change: |
    allow reading more bytes per operation from raw sockets to improve performance.
- area: router
  change: |
    extended custom date formatting to DOWNSTREAM_PEER_CERT_V_START and DOWNSTREAM_PEER_CERT_V_END when using :ref:`custom
    request/response header formats <config_http_conn_man_headers_custom_request_headers>`.
- area: router
  change: |
    made the path rewrite available without finalizing headers, so the filter could calculate the current value of the final
    url.
- area: tracing
  change: |
    added ``upstream_cluster.name`` tag that resolves to resolve to :ref:`alt_stat_name
    <envoy_v3_api_field_config.cluster.v3.Cluster.alt_stat_name>` if provided (and otherwise the cluster name).
- area: udp
  change: |
    configuration has been added for :ref:`GRO <envoy_v3_api_field_config.core.v3.UdpSocketConfig.prefer_gro>` which used to
    be force enabled if the OS supports it. The default is now disabled for server sockets and enabled for client sockets
    (see the new features section for links).
- area: upstream
  change: |
    host weight changes now cause a full load balancer rebuild as opposed to happening atomically inline. This change has
    been made to support load balancer pre-computation of data structures based on host weight, but may have performance
    implications if host weight changes are very frequent. This change can be disabled by setting the
    ``envoy.reloadable_features.upstream_host_weight_change_causes_rebuild`` feature flag to false. If setting this flag to
    false is required in a deployment please open an issue against the project.

bug_fixes:
- area: active http health checks
  change: |
    properly handles HTTP/2 GOAWAY frames from the upstream. Previously a GOAWAY frame due to a graceful listener drain
    could cause improper failed health checks due to streams being refused by the upstream on a connection that is going
    away. To revert to old GOAWAY handling behavior, set the runtime feature
    ``envoy.reloadable_features.health_check.graceful_goaway_handling`` to false.
- area: adaptive concurrency
  change: |
    fixed a bug where concurrent requests on different worker threads could update minRTT back-to-back.
- area: buffer
  change: |
    tighten network connection read and write buffer high watermarks in preparation to more careful enforcement of read
    limits. Buffer high-watermark is now set to the exact configured value; previously it was set to value + 1.
- area: cdn_loop
  change: |
    check that the entirety of the :ref:`cdn_id
    <envoy_v3_api_field_extensions.filters.http.cdn_loop.v3alpha.CdnLoopConfig.cdn_id>` field is a valid CDN identifier.
- area: cds
  change: |
    fix blocking the update for a warming cluster when the update is the same as the active version.
- area: ext_authz
  change: |
    emit :ref:`CheckResponse.dynamic_metadata <envoy_v3_api_field_service.auth.v3.CheckResponse.dynamic_metadata>` when the
    external authorization response has "Denied" check status.
- area: fault injection
  change: |
    stop counting as active fault after delay elapsed. Previously fault injection filter continues to count the injected
    delay as an active fault even after it has elapsed. This produces incorrect output statistics and impacts the max number
    of consecutive faults allowed (e.g., for long-lived streams). This change decreases the active fault count when the
    delay fault is the only active and has gone finished.
- area: filter_chain
  change: |
    fix filter chain matching with the server name as the case-insensitive way.
- area: grpc-web
  change: |
    fix local reply and non-proto-encoded gRPC response handling for small response bodies. This fix can be temporarily
    reverted by setting ``envoy.reloadable_features.grpc_web_fix_non_proto_encoded_response_handling`` to false.
- area: grpc_http_bridge
  change: |
    the downstream HTTP status is now correctly set for trailers-only responses from the upstream.
- area: header map
  change: |
    pick the right delimiter to append multiple header values to the same key. Previouly header with multiple values were
    coalesced with ",", after this fix cookie headers should be coalesced with " ;". This doesn't affect Http1 or Http2
    requests because these 2 codecs coalesce cookie headers before adding it to header map. To revert to the old behavior,
    set the runtime feature ``envoy.reloadable_features.header_map_correctly_coalesce_cookies`` to false.
- area: http
  change: |
    avoid grpc-status overwrite on when sending local replies if that field has already been set.
- area: http
  change: |
    disallowing "host:" in request_headers_to_add for behavioral consistency with rejecting :authority header. This behavior
    can be temporarily reverted by setting ``envoy.reloadable_features.treat_host_like_authority`` to false.
- area: http
  change: |
    fixed an issue where Envoy did not handle peer stream limits correctly, and queued streams in nghttp2 rather than
    establish new connections. This behavior can be temporarily reverted by setting
    ``envoy.reloadable_features.improved_stream_limit_handling`` to false.
- area: http
  change: |
    fixed a bug where setting :ref:`MaxStreamDuration proto
    <envoy_v3_api_msg_config.route.v3.RouteAction.MaxStreamDuration>` did not disable legacy timeout defaults.
- area: http
  change: |
    fixed a crash upon receiving empty HTTP/2 metadata frames. Received empty metadata frames are now counted in the HTTP/2
    codec stat :ref:`metadata_empty_frames <config_http_conn_man_stats_per_codec>`.
- area: http
  change: |
    fixed a remotely exploitable integer overflow via a very large grpc-timeout value causes undefined behavior.
- area: http
  change: |
    reverting a behavioral change where upstream connect timeouts were temporarily treated differently from other connection
    failures. The change back to the original behavior can be temporarily reverted by setting
    ``envoy.reloadable_features.treat_upstream_connect_timeout_as_connect_failure`` to false.
- area: jwt_authn
  change: |
    reject requests with a proper error if JWT has the wrong issuer when allow_missing is used. Before this change, the
    requests are accepted.
- area: listener
  change: |
    prevent crashing when an unknown listener config proto is received and debug logging is enabled.
- area: mysql_filter
  change: |
    improve the codec ability of mysql filter at connection phase, it can now decode MySQL5.7+ connection phase protocol
    packet.
- area: overload
  change: |
    fix a bug that can cause use-after-free when one scaled timer disables another one with the same duration.
- area: sni
  change: |
    as the server name in sni should be case-insensitive, envoy will convert the server name as lower case first before any
    other process inside envoy.
- area: tls
  change: |
    fix a crash when peer sends a TLS Alert with an unknown code.
- area: tls
  change: |
    fix the subject alternative name of the presented certificate matches the specified matchers as the case-insensitive way
    when it uses DNS name.
- area: tls
  change: |
    fix issue where OCSP was inadvertently removed from SSL response in multi-context scenarios.
- area: upstream
  change: |
    fix handling of moving endpoints between priorities when active health checks are enabled. Previously moving to a higher
    numbered priority was a NOOP, and moving to a lower numbered priority caused an abort.
- area: upstream
  change: |
    retry budgets will now set default values for xDS configurations.
- area: zipkin
  change: |
    fix 'verbose' mode to emit annotations for stream events. This was the documented behavior, but wasn't behaving as
    documented.

removed_config_or_runtime:
- area: access_logs
  change: |
    removed legacy unbounded access logs and runtime guard ``envoy.reloadable_features.disallow_unbounded_access_logs``.
- area: dns
  change: |
    removed legacy buggy wildcard matching path and runtime guard ``envoy.reloadable_features.fix_wildcard_matching``.
- area: dynamic_forward_proxy
  change: |
    removed ``envoy.reloadable_features.enable_dns_cache_circuit_breakers`` and legacy code path.
- area: http
  change: |
    removed legacy connect behavior and runtime guard ``envoy.reloadable_features.stop_faking_paths``.
- area: http
  change: |
    removed legacy connection close behavior and runtime guard ``envoy.reloadable_features.fixed_connection_close``.
- area: http
  change: |
    removed legacy HTTP/1.1 error reporting path and runtime guard ``envoy.reloadable_features.early_errors_via_hcm``.
- area: http
  change: |
    removed legacy sanitization path for upgrade response headers and runtime guard
    ``envoy.reloadable_features.fix_upgrade_response``.
- area: http
  change: |
    removed legacy date header overwriting logic and runtime guard ``envoy.reloadable_features.preserve_upstream_date
    deprecation``.
- area: http
  change: |
    removed legacy ALPN handling and runtime guard ``envoy.reloadable_features.http_default_alpn``.
- area: listener
  change: |
    removed legacy runtime guard ``envoy.reloadable_features.listener_in_place_filterchain_update``.
- area: router
  change: |
    removed ``envoy.reloadable_features.consume_all_retry_headers`` and legacy code path.
- area: router
  change: |
    removed ``envoy.reloadable_features.preserve_query_string_in_path_redirects`` and legacy code path.

new_features:
- area: access log
  change: |
    added a new :ref:`OpenTelemetry access logger
    <envoy_v3_api_msg_extensions.access_loggers.open_telemetry.v3alpha.OpenTelemetryAccessLogConfig>` extension, allowing a
    flexible log structure with native Envoy access log formatting.
- area: access log
  change: |
    added the new response flag ``NC`` for upstream cluster not found. The error flag is set when the http or tcp route is
    found for the request but the cluster is not available.
- area: access log
  change: |
    added the :ref:`formatters <envoy_v3_api_field_config.core.v3.SubstitutionFormatString.formatters>` extension point for
    custom formatters (command operators).
- area: access log
  change: |
    added support for cross platform writing to :ref:`standard output
    <envoy_v3_api_msg_extensions.access_loggers.stream.v3.StdoutAccessLog>` and :ref:`standard error
    <envoy_v3_api_msg_extensions.access_loggers.stream.v3.StderrAccessLog>`.
- area: access log
  change: |
    support command operator: %FILTER_CHAIN_NAME% for the downstream tcp and http request.
- area: access log
  change: |
    support command operator: %REQUEST_HEADERS_BYTES%, %RESPONSE_HEADERS_BYTES%, and %RESPONSE_TRAILERS_BYTES%.
- area: admin
  change: |
    added support for :ref:`access loggers <envoy_v3_api_msg_config.accesslog.v3.AccessLog>` to the admin interface.
- area: composite filter
  change: |
    added new :ref:`composite filter <config_http_filters_composite>` that can be used to instantiate different filter
    configuratios based on matching incoming data.
- area: compression
  change: |
    add brotli :ref:`compressor <envoy_v3_api_msg_extensions.compression.brotli.compressor.v3.Brotli>` and
    :ref:`decompressor <envoy_v3_api_msg_extensions.compression.brotli.decompressor.v3.Brotli>`.
- area: compression
  change: |
    extended the compression allow compressing when the content length header is not present. This behavior may be
    temporarily reverted by setting ``envoy.reloadable_features.enable_compression_without_content_length_header`` to false.
- area: config
  change: |
    add ``envoy.features.fail_on_any_deprecated_feature`` runtime key, which matches the behaviour of compile-time flag
    ``ENVOY_DISABLE_DEPRECATED_FEATURES``, i.e. use of deprecated fields will cause a crash.
- area: config
  change: |
    the ``Node`` :ref:`dynamic context parameters <envoy_v3_api_field_config.core.v3.Node.dynamic_parameters>` are populated
    in discovery requests when set on the server instance.
- area: dispatcher
  change: |
    supports a stack of ``Envoy::ScopeTrackedObject`` instead of a single tracked object. This will allow Envoy to dump more
    debug information on crash.
- area: ext_authz
  change: |
    added :ref:`response_headers_to_add <envoy_v3_api_field_service.auth.v3.OkHttpResponse.response_headers_to_add>` to
    support sending response headers to downstream clients on OK authorization checks via gRPC.
- area: ext_authz
  change: |
    added :ref:`allowed_client_headers_on_success
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_client_headers_on_success>` to
    support sending response headers to downstream clients on OK external authorization checks via HTTP.
- area: grpc_json_transcoder
  change: |
    added :ref:`request_validation_options
    <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.request_validation_options>` to
    reject invalid requests early.
- area: grpc_json_transcoder
  change: |
    filter can now be configured on per-route/per-vhost level as well. Leaving empty list of services in the filter
    configuration disables transcoding on the specific route.
- area: http
  change: |
    added support for ``Envoy::ScopeTrackedObject`` for HTTP/1 and HTTP/2 dispatching. Crashes while inside the dispatching
    loop should dump debug information. Furthermore, HTTP/1 and HTTP/2 clients now dumps the originating request whose
    response from the upstream caused Envoy to crash.
- area: http
  change: |
    added support for :ref:`preconnecting <envoy_v3_api_msg_config.cluster.v3.Cluster.PreconnectPolicy>`. Preconnecting is
    off by default, but recommended for clusters serving latency-sensitive traffic, especially if using HTTP/1.1.
- area: http
  change: |
    added support for stream filters to mutate the cached route set by HCM route resolution. Useful for filters in a filter
    chain that want to override specific methods/properties of a route. See :ref:`http route mutation
    <arch_overview_http_filters_route_mutation>` docs for more information.
- area: http
  change: |
    added new runtime config ``envoy.reloadable_features.check_unsupported_typed_per_filter_config``, the default value is
    true. When the value is true, envoy will reject virtual host-specific typed per filter config when the filter doesn't
    support it.
- area: http
  change: |
    added the ability to preserve HTTP/1 header case across the proxy. See the :ref:`header casing
    <config_http_conn_man_header_casing>` documentation for more information.
- area: http
  change: |
    change frame flood and abuse checks to the upstream HTTP/2 codec to ON by default. It can be disabled by setting the
    ``envoy.reloadable_features.upstream_http2_flood_checks`` runtime key to false.
- area: http
  change: |
    hash multiple header values instead of only hash the first header value. It can be disabled by setting the
    ``envoy.reloadable_features.hash_multiple_header_values`` runtime key to false. See the :ref:`HashPolicy's Header
    configuration <envoy_v3_api_msg_config.route.v3.RouteAction.HashPolicy.Header>` for more information.
- area: json
  change: |
    introduced new JSON parser (https://github.com/nlohmann/json) to replace RapidJSON. The new parser is disabled by
    default. To test the new RapidJSON parser, enable the runtime feature ``envoy.reloadable_features.remove_legacy_json``.
- area: kill_request
  change: |
    :ref:`Kill Request <config_http_filters_kill_request>` now supports bidirection killing.
- area: listener
  change: |
    added an optional :ref:`stat_prefix <envoy_v3_api_field_config.listener.v3.Listener.stat_prefix>`.
- area: loadbalancer
  change: |
    added the ability to specify the hash_key for a host when using a consistent hashing loadbalancer (ringhash, maglev)
    using the :ref:`LbEndpoint.Metadata <envoy_api_field_endpoint.LbEndpoint.metadata>` e.g.: ``"envoy.lb": {"hash_key":
    "..."}``.
- area: log
  change: |
    added a new custom flag ``%j`` to the log pattern to print the actual message to log as JSON escaped string.
- area: oauth filter
  change: |
    added the optional parameter :ref:`resources
    <envoy_v3_api_field_extensions.filters.http.oauth2.v3alpha.OAuth2Config.resources>`. Set this value to add multiple
    "resource" parameters in the Authorization request sent to the OAuth provider. This acts as an identifier representing
    the protected resources the client is requesting a token for.
- area: original_dst
  change: |
    added support for :ref:`Original Destination <config_listener_filters_original_dst>` on Windows. This enables the use of
    Envoy as a sidecar proxy on Windows.
- area: overload
  change: |
    add support for scaling :ref:`transport connection timeouts
    <envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.TRANSPORT_SOCKET_CONNECT>`. This
    can be used to reduce the TLS handshake timeout in response to overload.
- area: postgres
  change: |
    added ability to :ref:`terminate SSL
    <envoy_v3_api_field_extensions.filters.network.postgres_proxy.v3alpha.PostgresProxy.terminate_ssl>`.
- area: rbac
  change: |
    added :ref:`shadow_rules_stat_prefix <envoy_v3_api_field_extensions.filters.http.rbac.v3.RBAC.shadow_rules_stat_prefix>`
    to allow adding custom prefix to the stats emitted by shadow rules.
- area: route config
  change: |
    added :ref:`allow_post field <envoy_v3_api_field_config.route.v3.RouteAction.UpgradeConfig.ConnectConfig.allow_post>`
    for allowing POST payload as raw TCP.
- area: route config
  change: |
    added :ref:`max_direct_response_body_size_bytes
    <envoy_v3_api_field_config.route.v3.RouteConfiguration.max_direct_response_body_size_bytes>` to set maximum :ref:`direct
    response body <envoy_v3_api_field_config.route.v3.DirectResponseAction.body>` size in bytes. If not specified the
    default remains 4096 bytes.
- area: server
  change: |
    added ``fips_mode`` to :ref:`server compilation settings <server_compilation_settings_statistics>` related statistic.
- area: server
  change: |
    added :option:`--enable-core-dump` flag to enable core dumps via prctl (Linux-based systems only).
- area: tcp_proxy
  change: |
    add support for converting raw TCP streams into HTTP/1.1 CONNECT requests. See :ref:`upgrade documentation
    <tunneling-tcp-over-http>` for details.
- area: tcp_proxy
  change: |
    added a :ref:`use_post field
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.use_post>` for using HTTP POST to
    proxy TCP streams.
- area: tcp_proxy
  change: |
    added a :ref:`headers_to_add field
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.headers_to_add>` for setting
    additional headers to the HTTP requests for TCP proxing.
- area: thrift_proxy
  change: |
    added a :ref:`max_requests_per_connection field
    <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.ThriftProxy.max_requests_per_connection>` for setting
    maximum requests for per downstream connection.
- area: thrift_proxy
  change: |
    added per upstream metrics within the :ref:`thrift router
    <envoy_v3_api_msg_extensions.filters.network.thrift_proxy.router.v3.Router>` for messagetype counters in
    request/response.
- area: thrift_proxy
  change: |
    added per upstream metrics within the :ref:`thrift router
    <envoy_v3_api_msg_extensions.filters.network.thrift_proxy.router.v3.Router>` for request time histograms.
- area: tls peer certificate validation
  change: |
    added :ref:`SPIFFE validator <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.SPIFFECertValidatorConfig>` for
    supporting isolated multiple trust bundles in a single listener or cluster.
- area: tracing
  change: |
    added the :ref:`pack_trace_reason
    <envoy_v3_api_field_extensions.request_id.uuid.v3.UuidRequestIdConfig.pack_trace_reason>` field as well as explicit
    configuration for the built-in :ref:`UuidRequestIdConfig
    <envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig>` request ID implementation. See the trace context
    propagation :ref:`architecture overview <arch_overview_tracing_context_propagation>` for more information.
- area: udp
  change: |
    added :ref:`downstream <config_listener_stats_udp>` and :ref:`upstream <config_udp_listener_filters_udp_proxy_stats>`
    statistics for dropped datagrams.
- area: udp
  change: |
    added :ref:`downstream_socket_config <envoy_v3_api_field_config.listener.v3.UdpListenerConfig.downstream_socket_config>`
    listener configuration to allow configuration of downstream max UDP datagram size. Also added
    :ref:`upstream_socket_config
    <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.upstream_socket_config>` UDP proxy configuration
    to allow configuration of upstream max UDP datagram size. The defaults for both remain 1500 bytes.
- area: udp
  change: |
    added configuration for :ref:`GRO <envoy_v3_api_field_config.core.v3.UdpSocketConfig.prefer_gro>`. The default is
    disabled for :ref:`downstream sockets
    <envoy_v3_api_field_config.listener.v3.UdpListenerConfig.downstream_socket_config>` and enabled for :ref:`upstream
    sockets <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.upstream_socket_config>`.

deprecated:
- area: admin
  change: |
    :ref:`access_log_path <envoy_v3_api_field_config.bootstrap.v3.Admin.access_log_path>` is deprecated in favor for
    :ref:`access loggers <envoy_v3_api_msg_config.accesslog.v3.AccessLog>`.
date: April 12, 2023

bug_fixes:
- area: dependency
  change: |
    update Curl -> 8.0.1 to resolve CVE-2023-27535, CVE-2023-27536, CVE-2023-27538.
- area: http
  change: |
    amend the fix for ``x-envoy-original-path`` so it removes the header only at edge.
    Previously this would also remove the header at any Envoy instance upstream of an external request, including an Envoy
    instance that added the header.
date: April 15, 2021

changes:
- area: http
  change: |
    fixed a crash upon receiving empty HTTP/2 metadata frames. Received empty metadata frames are now counted in the HTTP/2
    codec stat :ref:`metadata_empty_frames <config_http_conn_man_stats_per_codec>`.
- area: http
  change: |
    fixed a remotely exploitable integer overflow via a very large grpc-timeout value causes undefined behavior.
- area: http
  change: |
    fixed URL parsing for HTTP/1.1 fully qualified URLs and connect requests containing IPv6 addresses.
- area: http
  change: |
    fixed bugs in datadog and squash filter's handling of responses with no bodies.
- area: http
  change: |
    reverting a behavioral change where upstream connect timeouts were temporarily treated differently from other connection
    failures. The change back to the original behavior can be temporarily reverted by setting
    ``envoy.reloadable_features.treat_upstream_connect_timeout_as_connect_failure`` to false.
- area: tls
  change: |
    fix detection of the upstream connection close event.
date: April 11, 2023

bug_fixes:
- area: dependency
  change: |
    update Curl -> 8.0.1 to resolve CVE-2023-27535, CVE-2023-27536, CVE-2023-27538.
- area: http
  change: |
    amend the fix for ``x-envoy-original-path`` so it removes the header only at edge.
    Previously this would also remove the header at any Envoy instance upstream of an external request, including an Envoy
    instance that added the header.
date: November 30, 2021

minor_behavior_changes:
- area: config
  change: |
    the log message for "gRPC config stream closed" now uses the most recent error message, and reports seconds instead of
    milliseconds for how long the most recent status has been received.

bug_fixes:
- area: http
  change: |
    remove redundant Warn log in HTTP codec.
- area: listener
  change: |
    fix a crash when updating any listener that does not bind to port.
- area: listener
  change: |
    listener add can reuse the listener socket of a draining filter chain listener and fix the request lost.
- area: mac
  change: |
    fix crash on startup on macOS 12 by changing the default allocator.
- area: tcp
  change: |
    fixed a bug where upstream circuit breakers applied HTTP per-request bounds to TCP connections.
date: July 7, 2020

changes:
- area: tls
  change: |
    fixed a bug where wilcard matching for "\*.foo.com" also matched domains of the form "a.b.foo.com". This behavior can be
    temporarily reverted by setting runtime feature ``envoy.reloadable_features.fix_wildcard_matching`` to false.
date: February 7, 2023

bug_fixes:
- area: validation
  change: |
    fixed a crash which could happen when optional ``engine_type`` is not provided in regex.
- area: dependency
  change: |
    Add boringssl patch to resolve CVE-2023-0286. Note that the FIPS build is not patched/fixed.

new_features:
- area: docker
  change: |
    use new ``nossl`` images for ``distroless`` Docker build.
date: November 20, 2020

bug_fixes:
- area: examples
  change: |
    examples use v3 configs.
- area: listener
  change: |
    fix crash when disabling or re-enabling listeners due to overload while processing LDS updates.
- area: proxy_proto
  change: |
    fixed a bug where the wrong downstream address got sent to upstream connections.
- area: proxy_proto
  change: |
    fixed a bug where network filters would not have the correct ``downstreamRemoteAddress()`` when accessed from the
    ``StreamInfo``. This could result in incorrect enforcement of RBAC rules in the RBAC network filter (but not in the RBAC
    HTTP filter), or incorrect access log addresses from tcp_proxy.
- area: tls
  change: |
    fix read resumption after triggering buffer high-watermark and all remaining request/response bytes are stored in the
    SSL connection's internal buffers.
- area: udp
  change: |
    fixed issue in which receiving truncated UDP datagrams would cause Envoy to crash.
date: June 2, 2023

bug_fixes:
- area: boringssl
  change: |
    Fixed the crash that occurs when contrib is compiled with ``boringssl=fips`` defined.
- area: dependency
  change: |
    update Wasmtime and related deps -> 9.0.3 to resolve
    `CVE-2023-30624 <https://nvd.nist.gov/vuln/detail/CVE-2023-30624>`_.
- area: dependency
  change: |
    update C-ares -> 1.91.1 to resolve:

    - `CVE-2023-31130 <https://nvd.nist.gov/vuln/detail/CVE-2023-31130>`_.
    - `CVE-2023-31147 <https://nvd.nist.gov/vuln/detail/CVE-2023-31147>`_.
    - `CVE-2023-31124 <https://nvd.nist.gov/vuln/detail/CVE-2023-31124>`_.
    - `CVE-2023-32067 <https://nvd.nist.gov/vuln/detail/CVE-2023-32067>`_.
date: June 8, 2020

changes:
- area: http
  change: |
    added :ref:`headers_with_underscores_action setting
    <envoy_api_field_core.HttpProtocolOptions.headers_with_underscores_action>` to control how client requests with header
    names containing underscore characters are handled. The options are to allow such headers, reject request or drop
    headers. The default is to allow headers, preserving existing behavior.
- area: http
  change: |
    fixed CVE-2020-11080 by rejecting HTTP/2 SETTINGS frames with too many parameters.
date: April 15, 2022

behavior_changes:
- area: sip-proxy
  change: |
    change API by replacing ``own_domain`` with :ref:`local_services
    <envoy_v3_api_msg_extensions.filters.network.sip_proxy.v3alpha.LocalService>`.
- area: tls
  change: |
    set TLS v1.2 as the default minimal version for servers. Users can still explicitly opt-in to 1.0 and 1.1 using
    :ref:`tls_minimum_protocol_version
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsParameters.tls_minimum_protocol_version>`.

minor_behavior_changes:
- area: access_log
  change: |
    log all header values in the grpc access log.
- area: build
  change: |
    ``VERSION`` and ``API_VERSION`` have been renamed to ``VERSION.txt`` and ``API_VERSION.txt`` respectively to avoid
    conflicts with the C++ ``<version>`` header.
- area: config
  change: |
    type URL is used to lookup extensions regardless of the name field. This may cause problems for empty filter
    configurations or mis-matched protobuf as the typed configurations. This behavioral change can be temporarily reverted
    by setting runtime guard ``envoy.reloadable_features.no_extension_lookup_by_name`` to false.
- area: config
  change: |
    warning messages for protobuf unknown fields now contain ancestors for easier troubleshooting.
- area: cryptomb
  change: |
    remove RSA PKCS1 v1.5 padding support.
- area: decompressor
  change: |
    decompressor does not duplicate ``accept-encoding`` header values anymore. This behavioral change can be reverted by
    setting runtime guard ``envoy.reloadable_features.append_to_accept_content_encoding_only_once`` to false.
- area: dynamic_forward_proxy
  change: |
    if a DNS resolution fails, failing immediately with a specific resolution error, rather than finishing up all local
    filters and failing to select an upstream host.
- area: ecds
  change: |
    changed to use ``http_filter`` stat prefix as the metrics root for ECDS subscriptions. This behavior can be temporarily
    reverted by setting ``envoy.reloadable_features.top_level_ecds_stats`` to false.
- area: ext_authz
  change: |
    added requested server name in ext_authz network filter for auth review.
- area: ext_authz
  change: |
    forward :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>` selected by
    :ref:`typed_metadata_context_namespaces
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.typed_metadata_context_namespaces>` to external auth
    service.
- area: file
  change: |
    changed disk based files to truncate files which are not being appended to. This behavioral change can be temporarily
    reverted by setting runtime guard ``envoy.reloadable_features.append_or_truncate`` to false.
- area: grpc
  change: |
    flip runtime guard ``envoy.reloadable_features.enable_grpc_async_client_cache`` to be default enabled. async grpc client
    created through ``getOrCreateRawAsyncClient`` will be cached by default.
- area: health_checker
  change: |
    exposing ``initial_metadata`` to GrpcHealthCheck in a way similar to ``request_headers_to_add`` of HttpHealthCheck.
- area: http
  change: |
    added the ability to have multiple URI type Subject Alternative Names of the client certificate in the
    :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header.
- area: http
  change: |
    avoiding delay-close for HTTP/1.0 responses framed by ``connection: close`` as well as HTTP/1.1 if the request is fully
    read. This means for responses to such requests, the FIN will be sent immediately after the response. This behavior can
    be temporarily reverted by setting ``envoy.reloadable_features.skip_delay_close`` to false.  If clients are seen to be
    receiving sporadic partial responses and flipping this flag fixes it, please notify the project immediately.
- area: http
  change: |
    changed the http status code to 504 from 408 if the request times out after the request is completed. This behavior can
    be temporarily reverted by setting the runtime guard
    ``envoy.reloadable_features.override_request_timeout_by_gateway_timeout`` to false.
- area: http
  change: |
    lazy disable downstream connection reading in the HTTP/1 codec to reduce unnecessary system calls. This behavioral
    change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.http1_lazy_read_disable`` to
    false.
- area: http
  change: |
    now the max concurrent streams of http2 connection can not only be adjusted down according to the SETTINGS frame but
    also can be adjusted up. Of course, it can not exceed the configured upper bounds. This fix is guarded by
    ``envoy.reloadable_features.http2_allow_capacity_increase_by_settings``.
- area: http
  change: |
    respecting ``content-type`` in :ref:`headers_to_add
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ResponseMapper.headers_to_add>` even when the
    response body is modified. This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.allow_adding_content_type_in_local_replies`` to false.
- area: http
  change: |
    when writing custom filters, ``injectEncodedDataToFilterChain`` and ``injectDecodedDataToFilterChain`` now trigger
    sending of headers if they were not yet sent due to ``StopIteration``. Previously, calling one of the inject functions
    in that state would trigger an assertion. See issue #19891 for more details.
- area: listener
  change: |
    the :ref:`ipv4_compat <envoy_v3_api_field_config.core.v3.socketaddress.ipv4_compat>` flag can only be set on Ipv6
    address and Ipv4-mapped Ipv6 address. A runtime guard is added ``envoy.reloadable_features.strict_check_on_ipv4_compat``
    and the default is true.
- area: network
  change: |
    add a new ConnectionEvent ``ConnectedZeroRtt`` which may be raised by QUIC connections to allow early data to be sent
    before the handshake finishes. This event is ignored at callsites which is only reachable for TCP connections in the
    Envoy core code. Any extensions which depend on ConnectionEvent enum value should audit their usage of it to make sure
    this new event is handled appropriately.
- area: oauth2
  change: |
    disable chunked transfer encoding in the token request to be compatible with Azure AD (login.microsoftonline.com).
- area: perf
  change: |
    tls contexts are now tracked without scan based garbage collection greatly improving the performance on secret update.
- area: ratelimit
  change: |
    the :ref:`header_value_match <envoy_v3_api_msg_config.route.v3.ratelimit.action.HeaderValueMatch>` config now supports
    custom descriptor keys.
- area: router
  change: |
    record upstream request timeouts for all cases and not just for those requests which are awaiting headers. This
    behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.do_not_await_headers_on_upstream_timeout_to_emit_stats`` to false.
- area: runtime
  change: |
    deprecated runtime flags set via configuration files or xDS will now ENVOY_BUG, rather than silently resulting in
    unexpected behavior on the data plane by no longer applying removed code paths.
- area: runtime
  change: |
    removed global runtime as Envoy default. This behavioral change can be reverted by setting runtime guard
    ``envoy.restart_features.no_runtime_singleton`` to false.
- area: sip-proxy
  change: |
    add customized affinity support by adding :ref:`tra_service_config
    <envoy_v3_api_msg_extensions.filters.network.sip_proxy.tra.v3alpha.TraServiceConfig>` and :ref:`customized_affinity
    <envoy_v3_api_msg_extensions.filters.network.sip_proxy.v3alpha.CustomizedAffinity>`.
- area: sip-proxy
  change: |
    add support for the ``503`` response code. When there is something wrong occurred, send ``503 Service Unavailable`` back
    to downstream.
- area: stateful session http filter
  change: |
    only enable cookie based session state when request path matches the configured cookie path.
- area: tracing
  change: |
    set tracing error tag for grpc non-ok response code only when it is a upstream error. Client error will not be tagged as
    a grpc error. This fix is guarded by ``envoy.reloadable_features.update_grpc_response_error_tag``.

bug_fixes:
- area: access_log
  change: |
    fix memory leak when reopening an access log fails. Access logs will now try to be reopened on each subsequent flush
    attempt after a failure.
- area: data plane
  change: |
    fix crash when internal redirect selects a route configured with direct response or redirect actions.
- area: data plane
  change: |
    fix error handling where writing to a socket failed while under the stack of processing. This should only effect HTTP/3.
    This behavioral change can be reverted by setting ``envoy.reloadable_features.allow_upstream_inline_write`` to false.
- area: eds
  change: |
    fix the eds cluster update by allowing update on the locality of the cluster endpoints. This behavioral change can be
    temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.support_locality_update_on_eds_cluster_endpoints`` to false.
- area: hot restart
  change: |
    fixed a bug where an incorrect fd was passed to child when a tcp listener and a udp listener listen to the same address
    because socket type was not used to find the matching listener for a url.
- area: http
  change: |
    fixed a bug where ``%RESPONSE_CODE_DETAILS%`` was not set correctly in :ref:`request_headers_to_add
    <envoy_v3_api_field_config.route.v3.RouteConfiguration.request_headers_to_add>`.
- area: http
  change: |
    fixed a bug where ``100-continue`` comparison in the ``Expect`` request header field was case sensitive. This RFC
    compliant behavior can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.http_100_continue_case_insensitive`` to false.
- area: jwt_authn
  change: |
    fixed a bug where a JWT with empty "iss" is passed even the field :ref:`issuer
    <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.issuer>` is specified. If the "issuer" field is
    specified, "iss" in the JWT should match it.
- area: jwt_authn
  change: |
    fixed the crash when a CONNECT request is sent to JWT filter configured with regex match on the Host header.
- area: router
  change: |
    fixed mirror policy :ref:`runtime_fraction
    <envoy_v3_api_field_config.route.v3.RouteAction.RequestMirrorPolicy.runtime_fraction>` to correctly allow reading from a
    fractional percent value stored in runtime in all cases. Previously it would only do this if the default numerator was
    above 0, otherwise it would use the integer variant with a default of 0. The default of 0 is retained, but runtime
    lookup will happen in all cases and recognize a stored fractional percent.
- area: tcp_proxy
  change: |
    fix a crash that occurs when configured for :ref:`upstream tunneling
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.tunneling_config>` and the downstream connection
    disconnects while the the upstream connection or http/2 stream is still being established.
- area: tls
  change: |
    fix a bug while matching a certificate SAN with an exact value in ``match_typed_subject_alt_names`` of a listener where
    wildcard ``*`` character is not the only character of the dns label. Example, ``baz*.example.net`` and
    ``*baz.example.net`` and ``b*z.example.net`` will match ``baz1.example.net`` and ``foobaz.example.net`` and
    ``buzz.example.net``, respectively.
- area: upstream
  change: |
    added cluster slow start config :ref:`min_weight_percent
    <envoy_v3_api_field_config.cluster.v3.Cluster.SlowStartConfig.min_weight_percent>` field to avoid too big EDF deadline
    which cause slow start endpoints receiving no traffic, default 10%. This fix is related to `issue \#19526
    <https://github.com/envoyproxy/envoy/issues/19526>`_.
- area: upstream
  change: |
    fix stack overflow when a cluster with large number of idle connections is removed.
- area: xds
  change: |
    fix a crash that occurs when Envoy receives a discovery response without ``control_plane`` field.
- area: xds
  change: |
    fix the wildcard resource versions that are sent upon reconnection when using delta-xds mode.
- area: xray
  change: |
    fix the AWS X-Ray tracer extension to not sample the trace if ``sampled=`` keyword is not present in the header
    ``x-amzn-trace-id``.
- area: xray
  change: |
    fix the AWS X-Ray tracer extension to annotate a child span with ``type=subsegment`` to correctly relate subsegments to
    a parent segment. Previously a subsegment would be treated as an independent segment.
- area: xray
  change: |
    fix the AWS X-Ray tracer extension to reuse the trace ID already present in the header ``x-amzn-trace-id`` instead of
    creating a new one.
- area: xray
  change: |
    fix the AWS X-Ray tracer extension to set the HTTP ``X-Forwarded-For`` header value as ``client_ip`` in the segment
    data.

removed_config_or_runtime:
- area: access_log
  change: |
    removed ``envoy.reloadable_features.unquote_log_string_values`` and legacy code paths.
- area: grpc_bridge_filter
  change: |
    removed ``envoy.reloadable_features.grpc_bridge_stats_disabled`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.hash_multiple_header_values`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.no_chunked_encoding_header_for_304`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.preserve_downstream_scheme`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.require_strict_1xx_and_204_response_headers`` and
    ``envoy.reloadable_features.send_strict_1xx_and_204_response_headers`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.strip_port_from_connect`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.use_observable_cluster_name`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.http_transport_failure_reason_in_body`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.allow_response_for_timeout`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.http2_consume_stream_refused_errors`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.internal_redirects_with_body`` and legacy code paths.
- area: json
  change: |
    removed ``envoy.reloadable_features.remove_legacy_json`` and legacy code paths.
- area: listener
  change: |
    removed ``envoy.reloadable_features.listener_reuse_port_default_enabled`` and legacy code paths.
- area: listener
  change: |
    removed ``envoy.reloadable_features.listener_wildcard_match_ip_family`` and legacy code paths.
- area: udp
  change: |
    removed ``envoy.reloadable_features.udp_per_event_loop_read_limit`` and legacy code paths.
- area: upstream
  change: |
    removed ``envoy.reloadable_features.health_check.graceful_goaway_handling`` and legacy code paths.
- area: xds
  change: |
    removed ``envoy.reloadable_features.vhds_heartbeats`` and legacy code paths.

new_features:
- area: access_log
  change: |
    added new access_log command operator ``%GRPC_STATUS_NUMBER%``.
- area: access_log
  change: |
    added new access_log command operator ``%ENVIRONMENT(X):Z%``.
- area: access_log
  change: |
    added TCP proxy upstream and downstream byte logging. This can be accessed through the ``%DOWNSTREAM_WIRE_BYTES_SENT%``,
    ``%DOWNSTREAM_WIRE_BYTES_RECEIVED%``, ``%UPSTREAM_WIRE_BYTES_SENT%``, and ``%UPSTREAM_WIRE_BYTES_RECEIVED%`` access_log
    command operatrors.
- area: access_log
  change: |
    make consistent access_log format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all combinations
    of local & remote addresses for upstream & downstream connections.
- area: admin
  change: |
    :http:post:`/logging` now accepts ``/logging?paths=name1:level1,name2:level2,...`` to change multiple log levels at
    once.
- area: cluster
  change: |
    added support for per host limits in :ref:`circuit breakers settings
    <envoy_v3_api_msg_config.cluster.v3.CircuitBreakers>`. Currently only :ref:`max_connections
    <envoy_v3_api_field_config.cluster.v3.CircuitBreakers.Thresholds.max_connections>` is supported.
- area: cluster
  change: |
    added support to restore original destination address from any desired header via setting :ref:`http_header_name
    <envoy_v3_api_field_config.cluster.v3.Cluster.OriginalDstLbConfig.http_header_name>`.
- area: cluster
  change: |
    support :ref:`override host status restriction
    <envoy_v3_api_field_config.cluster.v3.Cluster.CommonLbConfig.override_host_status>`.
- area: compression
  change: |
    add zstd :ref:`compressor <envoy_v3_api_msg_extensions.compression.zstd.compressor.v3.Zstd>` and :ref:`decompressor
    <envoy_v3_api_msg_extensions.compression.zstd.decompressor.v3.Zstd>`.
- area: config
  change: |
    added new file based xDS configuration via :ref:`path_config_source
    <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`. :ref:`watched_directory
    <envoy_v3_api_field_config.core.v3.PathConfigSource.watched_directory>` can be used to setup an independent watch for
    when to reload the file path, for example when using Kubernetes ConfigMaps to deliver configuration. See the linked
    documentation for more information.
- area: config
  change: |
    added new :ref:`custom config validators <config_config_validation>` to dynamically verify config updates.
- area: cors
  change: |
    add dynamic support for headers ``access-control-allow-methods`` and ``access-control-allow-headers`` in cors.
- area: dns
  change: |
    added :ref:`dns_min_refresh_rate
    <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_min_refresh_rate>` to the DNS cache
    implementation to configure the minimum DNS refresh rate, regardless of returned TTL. This was previously hard coded to
    5s and defaults to 5s if unset.
- area: gcp authentication http filter
  change: |
    added :ref:`gcp authentication http filter <config_http_filters_gcp_authn>`.
- area: http
  change: |
    added ``random_value_specifier`` in :ref:`weighted_clusters
    <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>` to allow random value to be specified from
    configuration proto.
- area: http
  change: |
    added ``request_mirror_policies`` to higher levels (i.e., :ref:`request_mirror_policies
    <envoy_v3_api_field_config.route.v3.RouteConfiguration.request_mirror_policies>` in :ref:`RouteConfiguration
    <envoy_v3_api_msg_config.route.v3.RouteConfiguration>` and :ref:`request_mirror_policies
    <envoy_v3_api_field_config.route.v3.VirtualHost.request_mirror_policies>` in :ref:`VirtualHost
    <envoy_v3_api_msg_config.route.v3.VirtualHost>`) which applies to :ref:`request_mirror_policies
    <envoy_v3_api_field_config.route.v3.RouteAction.request_mirror_policies>` in all routes underneath without configured
    mirror policies.
- area: http
  change: |
    added support for :ref:`cidr_ranges
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig.cidr_ranges>`
    for configuring list of CIDR ranges that are considered internal.
- area: http
  change: |
    added support for :ref:`proxy_status_config
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.proxy_status_config>`
    for configuring `Proxy-Status <https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-proxy-status-08>`_ HTTP response
    header fields.
- area: http
  change: |
    make consistent custom header format fields ``%(DOWN|DIRECT_DOWN|UP)STREAM_(LOCAL|REMOTE)_*%`` to provide all
    combinations of local & remote addresses for upstream & downstream connections.
- area: http2
  change: |
    adds the new runtime feature ``envoy.reloadable_features.http2_use_oghttp2``, disabled by default, that guards use of a
    new HTTP/2 implementation.
- area: http2
  change: |
    re-enabled the HTTP/2 wrapper API. This should be a transparent change that does not affect functionality. Any behavior
    changes can be reverted by setting the ``envoy.reloadable_features.http2_new_codec_wrapper`` runtime feature to false.
- area: http3
  change: |
    add :ref:`enable_early_data
    <envoy_v3_api_field_extensions.transport_sockets.quic.v3.QuicDownstreamTransport.enable_early_data>` to turn on/off
    downstream early data support.
- area: http3
  change: |
    downstream HTTP/3 support is now GA! Upstream HTTP/3 also GA for specific deployments. See :ref:`here
    <arch_overview_http3>` for details.
- area: http3
  change: |
    supports upstream HTTP/3 retries. Automatically retry `0-RTT safe requests <https://www.rfc-
    editor.org/rfc/rfc7231#section-4.2.1>`_ if they are rejected because they are sent `too early
    <https://datatracker.ietf.org/doc/html/rfc8470#section-5.2>`_. And automatically retry 0-RTT safe requests if connect
    attempt fails later on and the cluster is configured with TCP fallback. And add retry on ``http3-post-connect-failure``
    policy which allows retry of failed HTTP/3 requests with TCP fallback even after handshake if the cluster is configured
    with TCP fallback. This feature is guarded by
    ``envoy.reloadable_features.conn_pool_new_stream_with_early_data_and_http3``.
- area: listener
  change: |
    implement :ref:`matching API <arch_overview_matching_listener>` for selecting filter chains.
- area: local_ratelimit
  change: |
    added support for sharing the rate limiter between multiple network filter chains or listeners via :ref:`share_key
    <envoy_v3_api_field_extensions.filters.network.local_ratelimit.v3.LocalRateLimit.share_key>`.
- area: local_ratelimit
  change: |
    added support for ``X-RateLimit-*`` headers as defined in `draft RFC <https://tools.ietf.org/id/draft-polli-ratelimit-
    headers-03.html>`_.
- area: matching
  change: |
    the matching API can now express a match tree that will always match by omitting a matcher at the top level.
- area: outlier_detection
  change: |
    :ref:`max_ejection_time_jitter <envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>` configuration
    added to allow adding a random value to the ejection time to prevent 'thundering herd' scenarios. Defaults to 0 so as to
    not break or change the behavior of existing deployments.
- area: ratelimit
  change: |
    added :ref:`rate_limited_status <envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimit.rate_limited_status>`
    to support return a custom HTTP response status code to the downstream client when the request has been rate limited.
- area: ratelimit
  change: |
    network rate limiter supports runtime value substitution using stream info and substitution formatting via :ref:`Network
    Rate Limiter <config_network_filters_ratelimit_substitution_formatter>`.
- area: redis
  change: |
    support for hostnames returned in ``cluster_slots`` response is now available.
- area: router
  change: |
    added :ref:`path_separated_prefix <envoy_v3_api_field_config.route.v3.RouteMatch.path_separated_prefix>` to make route
    creation more efficient.
- area: schema_validator_tool
  change: |
    added ``bootstrap`` checking to the :ref:`schema validator check tool <install_tools_schema_validator_check_tool>`.
- area: schema_validator_tool
  change: |
    added ``--fail-on-deprecated`` and ``--fail-on-wip`` to the :ref:`schema validator check tool
    <install_tools_schema_validator_check_tool>` to allow failing the check if either deprecated or work-in-progress fields
    are used.
- area: schema_validator_tool
  change: |
    fixed linking of all extensions into the :ref:`schema validator check tool <install_tools_schema_validator_check_tool>`
    so that all typed configurations can be properly verified.
- area: schema_validator_tool
  change: |
    the :ref:`schema validator check tool <install_tools_schema_validator_check_tool>` will now recurse into all sub
    messages, including Any messages, and perform full validation (deprecation, work-in-progress, PGV, etc.). Previously
    only top-level messages were fully validated.
- area: stats
  change: |
    histogram_buckets query parameter added to stats endpoint to change histogram output to show buckets.
- area: tap
  change: |
    added support for buffering an arbitrary number of tapped traces before returning to the client via a new :ref:`buffered
    admin sink <envoy_v3_api_field_config.tap.v3.OutputSink.buffered_admin>`.
- area: tcp_proxy
  change: |
    added support for on demand cluster. If the :ref:`on_demand
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.on_demand>` is set and the destination cluster is
    not present, a delta CDS request will be sent and the tcp proxy flow will be resumed after that cds response.
- area: thrift
  change: |
    add support for connection draining. This can be enabled by setting the runtime guard
    ``envoy.reloadable_features.thrift_connection_draining`` to true.
- area: thrift
  change: |
    added support for dynamic routing through aggregated discovery service.
- area: tls
  change: |
    add support for tls key log :ref:`key_log
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.key_log>`.
- area: tools
  change: |
    the project now ships a :ref:`tools docker image <install_tools>` which contains tools useful in support systems such as
    CI, CD, etc. The :ref:`schema validator check tool <install_tools_schema_validator_check_tool>` has been added to the
    tools image.
- area: udp_proxy
  change: |
    added :ref:`matcher <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.matcher>` to support matching
    and routing to different clusters.
- area: udp_proxy
  change: |
    added support for :ref:`access_log <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.access_log>`.

deprecated:
- area: config
  change: |
    deprecated :ref:`path <envoy_v3_api_field_config.core.v3.ConfigSource.path>` in favor of :ref:`path_config_source
    <envoy_v3_api_field_config.core.v3.ConfigSource.path_config_source>`.
- area: http
  change: |
    deprecated ``envoy.http.headermap.lazy_map_min_size``.  If you are using this config knob you can revert this
    temporarily by setting ``envoy.reloadable_features.deprecate_global_ints`` to true but you MUST file an upstream issue
    to ensure this feature remains available.
- area: http
  change: |
    removing support for long-deprecated old style filter names, e.g. envoy.router, envoy.lua.
- area: re2
  change: |
    removed undocumented histograms ``re2.program_size`` and ``re2.exceeded_warn_level``.
- area: thrift
  change: |
    deprecated TTwitter protocol since we believe it's not used and it's causing significant maintenance burden.
- area: udp_proxy
  change: |
    deprecated :ref:`cluster <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.cluster>` in favor of
    :ref:`matcher <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.matcher>`.
date: April 12, 2023

bug_fixes:
- area: dependency
  change: |
    update Curl -> 8.0.1 to resolve CVE-2023-27535, CVE-2023-27536, CVE-2023-27538.
- area: http
  change: |
    amend the fix for ``x-envoy-original-path`` so it removes the header only at edge.
    Previously this would also remove the header at any Envoy instance upstream of an external request, including an Envoy
    instance that added the header.
date: May 17, 2017

changes:
- area: envoy
  change: |
    As of this release, we now have an official :repo:`breaking change policy <v1.5:/CONTRIBUTING.md#breaking-change-
    policy>`. Note that there are numerous breaking configuration changes in this release. They are not listed here. Future
    releases will adhere to the policy and have clear documentation on deprecations and changes.
- area: build
  change: |
    Bazel is now the canonical build system (replacing CMake). There have been a huge number of changes to the
    development/build/test flow. See :repo:`/bazel/README.md` and :repo:`/ci/README.md` for more information.
- area: outlier_detection
  change: |
    :ref:`Outlier detection <v1.5:arch_overview_outlier_detection>` has been expanded to include success rate variance, and
    all parameters are now configurable in both runtime and in the JSON configuration.
- area: listener
  change: |
    TCP level listener and cluster connections now have configurable receive buffer limits at which point connection level
    back pressure is applied. Full end to end flow control will be available in a future release.
- area: redis
  change: |
    :ref:`Redis health checking <v1.5:config_cluster_manager_cluster_hc>` has been added as an active health check type.
    Full Redis support will be documented/supported in 1.4.0.
- area: health_checking
  change: |
    :ref:`TCP health checking <v1.5:config_cluster_manager_cluster_hc_tcp_health_checking>` now supports a "connect only"
    mode that only checks if the remote server can be connected to without writing/reading any data.
- area: ssl
  change: |
    `BoringSSL <https://boringssl.googlesource.com/boringssl>`_ is now the only supported TLS provider. The default cipher
    suites and ECDH curves have been updated with more modern defaults for both listener and cluster connections.
- area: matching
  change: |
    The ``header value match`` rate limit action has been expanded to include an ``expect match`` parameter.
- area: rate_limiting
  change: |
    Route level HTTP rate limit configurations now do not inherit the virtual host level configurations by default. Use
    ``include_vh_rate_limits`` to inherit the virtual host level options if desired.
- area: routing
  change: |
    HTTP routes can now add request headers on a per route and per virtual host basis via the :ref:`request_headers_to_add
    <v1.5:config_http_conn_man_headers_custom_request_headers>` option.
- area: examples
  change: |
    The :ref:`example configurations <v1.5:install_ref_configs>` have been refreshed to demonstrate the latest features.
- area: retry
  change: |
    ``per_try_timeout_ms`` can now be configured in a route's retry policy in addition to via the :ref:`x-envoy-upstream-rq-
    per-try-timeout-ms <v1.5:config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms>` HTTP header.
- area: matching
  change: |
    HTTP virtual host matching now includes support for prefix wildcard domains (e.g., ``*.lyft.com``).
- area: tracing
  change: |
    The default for tracing random sampling has been changed to 100% and is still configurable in :ref:`runtime
    <v1.5:config_http_conn_man_runtime>`.
- area: tracing
  change: |
    HTTP tracing configuration has been extended to allow tags to be populated from arbitrary HTTP headers.
- area: rate_limiting
  change: |
    The :ref:`HTTP rate limit filter <v1.5:config_http_filters_rate_limit>` can now be applied to internal, external, or all
    requests via the ``request_type`` option.
- area: listener
  change: |
    :ref:`Listener binding <v1.5:config_listeners>` now requires specifying an ``address`` field. This can be used to bind a
    listener to both a specific address as well as a port.
- area: mongodb
  change: |
    The :ref:`MongoDB filter <v1.5:config_network_filters_mongo_proxy>` now emits a stat for queries that do not have
    ``$maxTimeMS`` set.
- area: mongodb
  change: |
    The :ref:`MongoDB filter <v1.5:config_network_filters_mongo_proxy>` now emits logs that are fully valid JSON.
- area: profiling
  change: |
    The CPU profiler output path is now configurable.
- area: watchdog
  change: |
    A watchdog system has been added that can kill the server if a deadlock is detected.
- area: routing
  change: |
    A :ref:`route table checking tool <v1.5:install_tools_route_table_check_tool>` has been added that can be used to test
    route tables before use.
- area: examples
  change: |
    We have added an :ref:`example repo <v1.5:extending>` that shows how to compile/link a custom filter.
- area: outlier_detection
  change: |
    Added additional cluster wide information related to outlier detection to the :ref:`/clusters admin endpoint
    <v1.5:operations_admin_interface>`.
- area: certificates
  change: |
    Multiple SANs can now be verified via the ``verify_subject_alt_name`` setting. Additionally, URI type SANs can be
    verified.
- area: filters
  change: |
    HTTP filters can now be passed opaque configuration specified on a per route basis.
- area: debugging
  change: |
    By default Envoy now has a built in crash handler that will print a back trace. This behavior can be disabled if desired
    via the ``--define=signal_trace=disabled`` Bazel option.
- area: zipkin
  change: |
    Zipkin has been added as a supported :ref:`tracing provider <v1.5:arch_overview_tracing>`.
- area: envoy
  change: |
    Numerous small changes and fixes not listed here.
date: July 13, 2023

bug_fixes:
- area: original_dst
  change: |
    Fixes an issue with the ORIGINAL_DST cluster cleanup timer lifetime, which
    can occur if the cluster is removed while the timer is armed.
- area: http2
  change: |
    Fix memory leak in nghttp2 when scheduled requests are cancelled due to the ``GOAWAY`` frame being received from the
    upstream service. Fix `CVE-2023-35945 <https://nvd.nist.gov/vuln/detail/CVE-2023-35945>`_.
# NB: you cannot remove sections from here without breaking old changelogs
#     also, adding a section here requires an update to `envoy.base.utils.typing`
changes:
  title: Changes
behavior_changes:
  title: Incompatible behavior changes
  description: |
    *Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*
minor_behavior_changes:
  title: Minor behavior changes
  description: |
    *Changes that may cause incompatibilities for some users, but should not for most*
bug_fixes:
  title: Bug fixes
  description: |
    *Changes expected to improve the state of the world and are unlikely to have negative effects*
removed_config_or_runtime:
  title: Removed config or runtime
  description: |
    *Normally occurs at the end of the* :ref:`deprecation period <deprecated>`
new_features:
  title: New features
deprecated:
  title: Deprecated
date: March 20, 2018

changes:
- area: access log
  change: |
    added ``DOWNSTREAM_REMOTE_ADDRESS``, ``DOWNSTREAM_REMOTE_ADDRESS_WITHOUT_PORT``, and ``DOWNSTREAM_LOCAL_ADDRESS``
    :ref:`access log formatters <config_access_log_format>`. ``DOWNSTREAM_ADDRESS`` access log formatter has been
    deprecated.
- area: access log
  change: |
    added less than or equal (LE) :ref:`comparison filter <envoy_api_msg_config.filter.accesslog.v2.ComparisonFilter>`.
- area: access log
  change: |
    added configuration to :ref:`runtime filter <envoy_api_msg_config.filter.accesslog.v2.RuntimeFilter>` to set default
    sampling rate, divisor, and whether to use independent randomness or not.
- area: admin
  change: |
    added :ref:`/runtime <operations_admin_interface_runtime>` admin endpoint to read the current runtime values.
- area: build
  change: |
    added support for :repo:`building Envoy with exported symbols <bazel#enabling-optional-features>`. This change allows
    scripts loaded with the Lua filter to load shared object libraries such as those installed via `LuaRocks
    <https://luarocks.org/>`_.
- area: config
  change: |
    added support for sending error details as `grpc.rpc.Status
    <https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto>`_ in :ref:`DiscoveryRequest
    <envoy_api_msg_DiscoveryRequest>`.
- area: config
  change: |
    added support for :ref:`inline delivery <envoy_api_msg_core.DataSource>` of TLS certificates and private keys.
- area: config
  change: |
    added restrictions for the backing :ref:`config sources <envoy_api_msg_core.ConfigSource>` of xDS resources. For
    filesystem based xDS the file must exist at configuration time. For cluster based xDS the backing cluster must be
    statically defined and be of non-EDS type.
- area: grpc
  change: |
    the Google gRPC C++ library client is now supported as specified in the :ref:`gRPC services overview
    <arch_overview_grpc_services>` and :ref:`GrpcService <envoy_api_msg_core.GrpcService>`.
- area: grpc-json
  change: |
    added support for :ref:`inline descriptors
    <envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.proto_descriptor_bin>`.
- area: health check
  change: |
    added :ref:`gRPC health check <envoy_api_field_core.HealthCheck.grpc_health_check>` based on `grpc.health.v1.Health
    <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_ service.
- area: health check
  change: |
    added ability to set :ref:`host header value <envoy_api_field_core.HealthCheck.HttpHealthCheck.host>` for http health
    check.
- area: health check
  change: |
    extended the health check filter to support computation of the health check response based on the :ref:`percentage of
    healthy servers in upstream clusters
    <envoy_api_field_config.filter.http.health_check.v2.HealthCheck.cluster_min_healthy_percentages>`.
- area: health check
  change: |
    added setting for :ref:`no-traffic interval <envoy_api_field_core.HealthCheck.no_traffic_interval>`.
- area: http
  change: |
    added idle timeout for :ref:`upstream http connections <envoy_api_field_core.HttpProtocolOptions.idle_timeout>`.
- area: http
  change: |
    added support for :ref:`proxying 100-Continue responses
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.proxy_100_continue>`.
- area: http
  change: |
    added the ability to pass a URL encoded PEM encoded peer certificate in the
    :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header.
- area: http
  change: |
    added support for trusting additional hops in the :ref:`config_http_conn_man_headers_x-forwarded-for` request header.
- area: http
  change: |
    added support for :ref:`incoming HTTP/1.0 <envoy_api_field_core.Http1ProtocolOptions.accept_http_10>`.
- area: hot restart
  change: |
    added SIGTERM propagation to children to :ref:`hot-restarter.py <operations_hot_restarter>`, which enables using it as a
    parent of containers.
- area: ip tagging
  change: |
    added :ref:`HTTP IP Tagging filter <config_http_filters_ip_tagging>`.
- area: listeners
  change: |
    added support for :ref:`listening for both IPv4 and IPv6 <envoy_api_field_core.SocketAddress.ipv4_compat>` when binding
    to ::.
- area: listeners
  change: |
    added support for listening on :ref:`UNIX domain sockets <envoy_api_field_core.Address.pipe>`.
- area: listeners
  change: |
    added support for :ref:`abstract unix domain sockets <envoy_api_msg_core.Pipe>` on Linux. The abstract namespace can be
    used by prepending '@' to a socket path.
- area: load balancer
  change: |
    added cluster configuration for :ref:`healthy panic threshold
    <envoy_api_field_Cluster.CommonLbConfig.healthy_panic_threshold>` percentage.
- area: load balancer
  change: |
    added :ref:`Maglev <arch_overview_load_balancing_types_maglev>` consistent hash load balancer.
- area: load balancer
  change: |
    added support for :ref:`LocalityLbEndpoints <envoy_api_msg_endpoint.LocalityLbEndpoints>` priorities.
- area: lua
  change: |
    added headers :ref:`replace() <config_http_filters_lua_header_wrapper>` API.
- area: lua
  change: |
    extended to support :ref:`metadata object <config_http_filters_lua_metadata_wrapper>` API.
- area: redis
  change: |
    added local ``PING`` support to the :ref:`Redis filter <arch_overview_redis>`.
- area: redis
  change: |
    added ``GEORADIUS_RO`` and ``GEORADIUSBYMEMBER_RO`` to the :ref:`Redis command splitter <arch_overview_redis>`
    allowlist.
- area: router
  change: |
    added ``DOWNSTREAM_REMOTE_ADDRESS_WITHOUT_PORT``, ``DOWNSTREAM_LOCAL_ADDRESS``,
    ``DOWNSTREAM_LOCAL_ADDRESS_WITHOUT_PORT``, ``PROTOCOL``, and ``UPSTREAM_METADATA`` :ref:`header formatters
    <config_http_conn_man_headers_custom_request_headers>`. The ``CLIENT_IP`` header formatter has been deprecated.
- area: router
  change: |
    added gateway-error :ref:`retry-on <config_http_filters_router_x-envoy-retry-on>` policy.
- area: router
  change: |
    added support for route matching based on :ref:`URL query string parameters
    <envoy_api_msg_route.QueryParameterMatcher>`.
- area: router
  change: |
    added support for more granular weighted cluster routing by allowing the :ref:`total_weight
    <envoy_api_field_route.WeightedCluster.total_weight>` to be specified in configuration.
- area: router
  change: |
    added support for :ref:`custom request/response headers <config_http_conn_man_headers_custom_request_headers>` with
    mixed static and dynamic values.
- area: router
  change: |
    added support for :ref:`direct responses <envoy_api_field_route.Route.direct_response>`. I.e., sending a preconfigured
    HTTP response without proxying anywhere.
- area: router
  change: |
    added support for :ref:`HTTPS redirects <envoy_api_field_route.RedirectAction.https_redirect>` on specific routes.
- area: router
  change: |
    added support for :ref:`prefix_rewrite <envoy_api_field_route.RedirectAction.prefix_rewrite>` for redirects.
- area: router
  change: |
    added support for :ref:`stripping the query string <envoy_api_field_route.RedirectAction.strip_query>` for redirects.
- area: router
  change: |
    added support for downstream request/upstream response :ref:`header manipulation
    <config_http_conn_man_headers_custom_request_headers>` in :ref:`weighted cluster <envoy_api_msg_route.WeightedCluster>`.
- area: router
  change: |
    added support for :ref:`range based header matching <envoy_api_field_route.HeaderMatcher.range_match>` for request
    routing.
- area: squash
  change: |
    added support for the :ref:`Squash microservices debugger <config_http_filters_squash>`. Allows debugging an incoming
    request to a microservice in the mesh.
- area: stats
  change: |
    added metrics service API implementation.
- area: stats
  change: |
    added native :ref:`DogStatsd <envoy_api_msg_config.metrics.v2.DogStatsdSink>` support.
- area: stats
  change: |
    added support for :ref:`fixed stats tag values <envoy_api_field_config.metrics.v2.TagSpecifier.fixed_value>` which will
    be added to all metrics.
- area: tcp proxy
  change: |
    added support for specifying a :ref:`metadata matcher
    <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.metadata_match>` for upstream clusters in the tcp filter.
- area: tcp proxy
  change: |
    improved TCP proxy to correctly proxy TCP half-close.
- area: tcp proxy
  change: |
    added :ref:`idle timeout <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.idle_timeout>`.
- area: tcp proxy
  change: |
    access logs now bring an IP address without a port when using DOWNSTREAM_ADDRESS. Use :ref:`DOWNSTREAM_REMOTE_ADDRESS
    <config_access_log_format>` instead.
- area: tracing
  change: |
    added support for dynamically loading an :ref:`OpenTracing tracer <envoy_api_msg_config.trace.v2.DynamicOtConfig>`.
- area: tracing
  change: |
    when using the Zipkin tracer, it is now possible for clients to specify the sampling decision (using the
    :ref:`x-b3-sampled <config_http_conn_man_headers_x-b3-sampled>` header) and have the decision propagated through to
    subsequently invoked services.
- area: tracing
  change: |
    when using the Zipkin tracer, it is no longer necessary to propagate the :ref:`x-ot-span-context
    <config_http_conn_man_headers_x-ot-span-context>` header. See more on trace context propagation :ref:`here
    <arch_overview_tracing>`.
- area: transport sockets
  change: |
    added transport socket interface to allow custom implementations of transport sockets. A transport socket provides read
    and write logic with buffer encryption and decryption (if applicable). The existing TLS implementation has been
    refactored with the interface.
- area: upstream
  change: |
    added support for specifying an :ref:`alternate stats name <envoy_api_field_Cluster.alt_stat_name>` while emitting stats
    for clusters.
- area: envoy
  change: |
    Many small bug fixes and performance improvements not listed.

deprecated:
- area: logging
  change: |
    ``DOWNSTREAM_ADDRESS`` log formatter is deprecated. Use ``DOWNSTREAM_REMOTE_ADDRESS_WITHOUT_PORT`` instead.
- area: headers
  change: |
    ``CLIENT_IP`` header formatter is deprecated. Use ``DOWNSTREAM_REMOTE_ADDRESS_WITHOUT_PORT`` instead.
- area: lds
  change: |
    'use_original_dst' field in the v2 LDS API is deprecated. Use listener filters and filter chain matching instead.
- area: matching
  change: |
    ``value`` and ``regex`` fields in the ``HeaderMatcher`` message is deprecated. Use the ``exact_match`` or
    ``regex_match`` oneof instead.
date: February 7, 2023

bug_fixes:
- area: dependency
  change: |
    Add boringssl patch to resolve CVE-2023-0286. Note that the FIPS build is not patched/fixed.
date: June 30, 2020

changes:
- area: buffer
  change: |
    fixed CVE-2020-12603 by avoiding fragmentation, and tracking of HTTP/2 data and control frames in the output buffer.
- area: http
  change: |
    fixed CVE-2020-12604 by changing :ref:`stream_idle_timeout
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>` to also
    defend against an HTTP/2 peer that does not open stream window once an entire response has been buffered to be sent to a
    downstream client.
- area: http
  change: |
    fixed CVE-2020-12605 by including request URL in request header size computation, and rejecting partial headers that
    exceed configured limits.
- area: listener
  change: |
    fixed CVE-2020-8663 by adding runtime support for :ref:`per-listener limits <config_listeners_runtime>` on
    active/accepted connections.
- area: overload management
  change: |
    fixed CVE-2020-8663 by adding runtime support for :ref:`global limits <config_overload_manager>` on active/accepted
    connections.
date: November 28, 2022

bug_fixes:
- area: bazel
  change: |
    updated to 5.0.0.
- area: ci
  change: |
    assorted fixes.
- area: dependencies
  change: |
    update Curl, Kafka, Wasm to mitigate CVEs.
- area: docker
  change: |
    update Docker images (``distroless`` -> ``4b22ca3c6``) to resolve CVE issues in container packages.
date: July 11, 2019

changes:
- area: access log
  change: |
    added a new field for downstream TLS session ID to file and gRPC access logger.
- area: access log
  change: |
    added a new field for route name to file and gRPC access logger.
- area: access log
  change: |
    added a new field for response code details in :ref:`file access logger
    <config_access_log_format_response_code_details>` and :ref:`gRPC access logger
    <envoy_api_field_data.accesslog.v2.HTTPResponseProperties.response_code_details>`.
- area: access log
  change: |
    added several new variables for exposing information about the downstream TLS connection to :ref:`file access logger
    <config_access_log_format_response_code_details>` and :ref:`gRPC access logger
    <envoy_api_field_data.accesslog.v2.AccessLogCommon.tls_properties>`.
- area: access log
  change: |
    added a new flag for request rejected due to failed strict header check.
- area: admin
  change: |
    the administration interface now includes a :ref:`/ready endpoint <operations_admin_interface>` for easier readiness
    checks.
- area: admin
  change: |
    extend :ref:`/runtime_modify endpoint <operations_admin_interface_runtime_modify>` to support parameters within the
    request body.
- area: admin
  change: |
    the :ref:`/listener endpoint <operations_admin_interface_listeners>` now returns :ref:`listeners.proto
    <envoy_api_msg_admin.v2alpha.Listeners>` which includes listener names and ports.
- area: admin
  change: |
    added host priority to :http:get:`/clusters` and :http:get:`/clusters?format=json` endpoint response.
- area: admin
  change: |
    the :ref:`/clusters endpoint <operations_admin_interface_clusters>` now shows hostname for each host, useful for DNS
    based clusters.
- area: api
  change: |
    track and report requests issued since last load report.
- area: build
  change: |
    releases are built with Clang and linked with LLD.
- area: config
  change: |
    added :ref:`stats_server_version_override <envoy_api_field_config.bootstrap.v2.bootstrap.stats_config>` in bootstrap,
    that can be used to override :ref:`server.version statistic <statistics>`.
- area: control-plane
  change: |
    management servers can respond with HTTP 304 to indicate that config is up to date for Envoy proxies polling a
    :ref:`REST API Config Type <envoy_api_field_core.ApiConfigSource.api_type>`.
- area: csrf
  change: |
    added support for allowlisting additional source origins.
- area: dns
  change: |
    added support for getting DNS record TTL which is used by STRICT_DNS/LOGICAL_DNS cluster as DNS refresh rate.
- area: dubbo_proxy
  change: |
    support the :ref:`dubbo proxy filter <config_network_filters_dubbo_proxy>`.
- area: dynamo_request_parser
  change: |
    adding support for transactions. Adds check for new types of dynamodb operations (TransactWriteItems, TransactGetItems)
    and awareness for new types of dynamodb errors (IdempotentParameterMismatchException, TransactionCanceledException,
    TransactionInProgressException).
- area: eds
  change: |
    added support to specify max time for which endpoints can be used :ref:`gRPC filter
    <envoy_api_msg_ClusterLoadAssignment.Policy>`.
- area: eds
  change: |
    removed max limit for ``load_balancing_weight``.
- area: event
  change: |
    added :ref:`loop duration and poll delay statistics <operations_performance>`.
- area: ext_authz
  change: |
    added a ``x-envoy-auth-partial-body`` metadata header set to ``false|true`` indicating if there is a partial body sent
    in the authorization request message.
- area: ext_authz
  change: |
    added configurable status code that allows customizing HTTP responses on filter check status errors.
- area: ext_authz
  change: |
    added option to ``ext_authz`` that allows the filter clearing route cache.
- area: grpc-json
  change: |
    added support for :ref:`auto mapping
    <envoy_api_field_config.filter.http.transcoder.v2.GrpcJsonTranscoder.auto_mapping>`.
- area: health check
  change: |
    added :ref:`initial jitter <envoy_api_field_core.HealthCheck.initial_jitter>` to add jitter to the first health check in
    order to prevent thundering herd on Envoy startup.
- area: hot restart
  change: |
    stats are no longer shared between hot restart parent/child via shared memory, but rather by RPC. Hot restart version
    incremented to 11.
- area: http
  change: |
    added the ability to pass a URL encoded PEM encoded peer certificate chain in the
    :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header.
- area: http
  change: |
    fixed a bug where large unbufferable responses were not tracked in stats and logs correctly.
- area: http
  change: |
    fixed a crashing bug where gRPC local replies would cause segfaults when upstream access logging was on.
- area: http
  change: |
    mitigated a race condition with the :ref:`delayed_close_timeout
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.delayed_close_timeout>` where it
    could trigger while actively flushing a pending write buffer for a downstream connection.
- area: http
  change: |
    added support for :ref:`preserve_external_request_id
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.preserve_external_request_id>`
    that represents whether the x-request-id should not be reset on edge entry inside mesh.
- area: http
  change: |
    changed ``sendLocalReply`` to send percent-encoded ``GrpcMessage``.
- area: http
  change: |
    added a :ref:`header_prefix <envoy_api_field_config.bootstrap.v2.Bootstrap.header_prefix>` configuration option to allow
    Envoy to send and process x-custom- prefixed headers rather than x-envoy.
- area: http
  change: |
    added :ref:`dynamic forward proxy <arch_overview_http_dynamic_forward_proxy>` support.
- area: http
  change: |
    tracking the active stream and dumping state in Envoy crash handlers. This can be disabled by building with ``--define
    disable_object_dump_on_signal_trace=disabled``.
- area: jwt_authn
  change: |
    make filter's parsing of JWT more flexible, allowing syntax like ``jwt=eyJhbGciOiJS...ZFnFIw,extra=7,realm=123``.
- area: listener
  change: |
    added :ref:`source IP <envoy_api_field_listener.FilterChainMatch.source_prefix_ranges>` and :ref:`source port
    <envoy_api_field_listener.FilterChainMatch.source_ports>` filter chain matching.
- area: lua
  change: |
    exposed functions to Lua to verify digital signature.
- area: original_src filter
  change: |
    added the :ref:`filter <config_http_filters_original_src>`.
- area: outlier_detector
  change: |
    added configuration :ref:`outlier_detection.split_external_local_origin_errors
    <envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>` to distinguish locally and externally
    generated errors. See :ref:`arch_overview_outlier_detection` for full details.
- area: rbac
  change: |
    migrated from v2alpha to v2.
- area: redis
  change: |
    add support for Redis cluster custom cluster type.
- area: redis
  change: |
    automatically route commands using cluster slots for Redis cluster.
- area: redis
  change: |
    added :ref:`prefix routing <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.prefix_routes>` to enable
    routing commands based on their key's prefix to different upstream.
- area: redis
  change: |
    added :ref:`request mirror policy
    <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.request_mirror_policy>` to enable
    shadow traffic and/or dual writes.
- area: redis
  change: |
    add support for zpopmax and zpopmin commands.
- area: redis
  change: |
    added :ref:`max_buffer_size_before_flush
    <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.max_buffer_size_before_flush>` to
    batch commands together until the encoder buffer hits a certain size, and :ref:`buffer_flush_timeout
    <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.buffer_flush_timeout>` to control how
    quickly the buffer is flushed if it is not full.
- area: redis
  change: |
    added auth support :ref:`downstream_auth_password
    <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.downstream_auth_password>` for downstream client
    authentication, and :ref:`auth_password
    <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProtocolOptions.auth_password>` to configure authentication
    passwords for upstream server clusters.
- area: retry
  change: |
    added a retry predicate that :ref:`rejects canary hosts. <envoy_api_field_route.RetryPolicy.retry_host_predicate>`.
- area: router
  change: |
    add support for configuring a :ref:`gRPC timeout offset <envoy_api_field_route.RouteAction.grpc_timeout_offset>` on
    incoming requests.
- area: router
  change: |
    added ability to control retry back-off intervals via :ref:`retry policy
    <envoy_api_msg_route.RetryPolicy.RetryBackOff>`.
- area: router
  change: |
    added ability to issue a hedged retry in response to a per try timeout via a :ref:`hedge policy
    <envoy_api_msg_route.HedgePolicy>`.
- area: router
  change: |
    added a route name field to each http route in route.Route list.
- area: router
  change: |
    added several new variables for exposing information about the downstream TLS connection via :ref:`header formatters
    <config_http_conn_man_headers_custom_request_headers>`.
- area: router
  change: |
    per try timeouts will no longer start before the downstream request has been received in full by the router.This ensures
    that the per try timeout does not account for slow downstreams and that will not start before the global timeout.
- area: router
  change: |
    added :ref:`RouteAction's auto_host_rewrite_header <envoy_api_field_route.RouteAction.auto_host_rewrite_header>` to
    allow upstream host header substitution with some other header's value.
- area: router
  change: |
    added support for UPSTREAM_REMOTE_ADDRESS :ref:`header formatter <config_http_conn_man_headers_custom_request_headers>`.
- area: router
  change: |
    add ability to reject a request that includes invalid values for headers configured in :ref:`strict_check_headers
    <envoy_api_field_config.filter.http.router.v2.Router.strict_check_headers>`.
- area: runtime
  change: |
    added support for :ref:`flexible layering configuration
    <envoy_api_field_config.bootstrap.v2.Bootstrap.layered_runtime>`.
- area: runtime
  change: |
    added support for statically :ref:`specifying the runtime in the bootstrap configuration
    <envoy_api_field_config.bootstrap.v2.Runtime.base>`.
- area: runtime
  change: |
    :ref:`Runtime Discovery Service (RTDS) <config_runtime_rtds>` support added to layered runtime configuration.
- area: sandbox
  change: |
    added :ref:`CSRF sandbox <install_sandboxes_csrf>`.
- area: server
  change: |
    ``--define manual_stamp=manual_stamp`` was added to allow server stamping outside of binary rules. more info in the
    `bazel docs <https://github.com/envoyproxy/envoy/blob/main/bazel/README.md#enabling-optional-features>`_.
- area: server
  change: |
    added :ref:`server state <statistics>` statistic.
- area: server
  change: |
    added :ref:`initialization_time_ms <statistics>` statistic.
- area: subset
  change: |
    added :ref:`list_as_any <envoy_api_field_Cluster.LbSubsetConfig.list_as_any>` option to the subset lb which allows
    matching metadata against any of the values in a list value on the endpoints.
- area: tools
  change: |
    added `proto <https://github.com/envoyproxy/envoy/blob/v1.11.0/test/tools/router_check/validation.proto>`_ support for
    :ref:`router check tool <install_tools_route_table_check_tool>` tests.
- area: tracing
  change: |
    add trace sampling configuration to the route, to override the route level.
- area: upstream
  change: |
    added :ref:`upstream_cx_pool_overflow <config_cluster_manager_cluster_stats>` for the connection pool circuit breaker.
- area: upstream
  change: |
    an EDS management server can now force removal of a host that is still passing active health checking by first marking
    the host as failed via EDS health check and subsequently removing it in a future update. This is a mechanism to work
    around a race condition in which an EDS implementation may remove a host before it has stopped passing active HC, thus
    causing the host to become stranded until a future update.
- area: upstream
  change: |
    added :ref:`an option <envoy_api_field_Cluster.CommonLbConfig.ignore_new_hosts_until_first_hc>` that allows ignoring new
    hosts for the purpose of load balancing calculations until they have been health checked for the first time.
- area: upstream
  change: |
    added runtime error checking to prevent setting dns type to STRICT_DNS or LOGICAL_DNS when custom resolver name is
    specified.
- area: upstream
  change: |
    added possibility to override fallback_policy per specific selector in :ref:`subset load balancer
    <arch_overview_load_balancer_subsets>`.
- area: upstream
  change: |
    the :ref:`logical DNS cluster <arch_overview_service_discovery_types_logical_dns>` now displays the current resolved IP
    address in admin output instead of 0.0.0.0.

deprecated:
- area: options
  change: |
    The --max-stats and --max-obj-name-len flags no longer has any effect.
- area: redis
  change: |
    Use of :ref:`cluster <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.cluster>` in
    :ref:`redis_proxy.proto <envoy_api_file_envoy/config/filter/network/redis_proxy/v2/redis_proxy.proto>` is deprecated.
    Set a :ref:`catch_all_route
    <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route>` instead.
- area: redis
  change: |
    Use of :ref:`catch_all_cluster
    <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_cluster>` in
    :ref:`redis_proxy.proto <envoy_api_file_envoy/config/filter/network/redis_proxy/v2/redis_proxy.proto>` is deprecated.
    Set a :ref:`catch_all_route
    <envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route>` instead.
- area: router_check_tool
  change: |
    Use of json based schema in router check tool tests. The tests should follow validation `schema
    <https://github.com/envoyproxy/envoy/blob/v1.11.0/test/tools/router_check/validation.proto>`_.
- area: listener
  change: |
    Use of the v1 style route configuration for the :ref:`TCP proxy filter <config_network_filters_tcp_proxy>` is now fully
    replaced with listener :ref:`filter chain matching <envoy_api_msg_listener.FilterChainMatch>`. Use this instead.
- area: config
  change: |
    Use of :ref:`runtime <envoy_api_field_config.bootstrap.v2.Bootstrap.runtime>` in :ref:`Bootstrap
    <envoy_api_msg_config.bootstrap.v2.Bootstrap>`. Use :ref:`layered_runtime
    <envoy_api_field_config.bootstrap.v2.Bootstrap.layered_runtime>` instead.
- area: config
  change: |
    Specifying "deprecated_v1: true" in HTTP and network filter configuration to allow loading JSON configuration is now
    deprecated and will be removed in a following release. Update any custom filters to use protobuf configuration. A struct
    can be used for a mostly 1:1 conversion if needed. The ``envoy.deprecated_features.v1_filter_json_config`` runtime key
    can be used to temporarily enable this feature once the deprecation becomes fail by default.
date: May 11, 2021

bug_fixes:
- area: zipkin
  change: |
    fix timestamp serializaiton in annotations. A prior bug fix exposed an issue with timestamps being serialized as
    strings.

removed_config_or_runtime:
- area: tls
  change: |
    removed ``envoy.reloadable_features.tls_use_io_handle_bio`` runtime guard and legacy code path.

new_features:
- area: http
  change: |
    added the ability to :ref:`unescape slash sequences
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.path_with_escaped_slashes_action>`
    in the path. Requests with unescaped slashes can be proxied, rejected or redirected to the new unescaped path. By
    default this feature is disabled. The default behavior can be overridden through
    :ref:`http_connection_manager.path_with_escaped_slashes_action
    <config_http_conn_man_runtime_path_with_escaped_slashes_action>` runtime variable. This action can be selectively
    enabled for a portion of requests by setting the :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling
    <config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled>` runtime variable.
date: April 5, 2023

behavior_changes:
- area: http
  change: |
    Validate upstream request header names and values. The new runtime flag
    ``envoy.reloadable_features.validate_upstream_headers`` can be used for revert this behavior.

bug_fixes:
- area: oauth2
  change: |
    fixed a bug where the oauth2 filter would crash if it received a redirect URL without a state query param set.
- area: lua
  change: |
    lua coroutine should not execute after local reply is sent.
- area: grpc
  change: |
    when Envoy was configured to use ext_authz, ext_proc, tap, ratelimit filters, and grpc access log service and an http
    header with non-UTF-8 data was received, Envoy would generate an invalid protobuf message and send it to the configured
    service. The receiving service would typically generate an error when decoding the protobuf message. For ext_authz that
    was configured with ``failure_mode_allow: true``, the request would have been allowed in this case. For the other services,
    this could have resulted in other unforseen errors such as a lack of visibility into requests (eg request not logged). Envoy
    will now by default sanitize the values sent in gRPC service calls to be valid UTF-8, replacing data that is not valid UTF-8
    with a '!' character. This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.service_sanitize_non_utf8_strings`` to false.
- area: http
  change: |
    stop forwarding ``:method`` value which is not a valid token defined in https://www.rfc-editor.org/rfc/rfc9110#section-5.6.2.
    Also, reject ``:method`` and ``:scheme`` headers with multiple values.
- area: http3
  change: |
    reject pseudo headers violating RFC 9114. Specifically, pseudo-header fields with more than one value for the ``:method``
    (non-``CONNECT``), ``:scheme``, and ``:path``; or pseudo-header fields after regular header fields; or undefined
    pseudo-headers.
- area: http
  change: |
    fixed a bug where ``x-envoy-original-path`` was not being sanitized when sent from untrusted users. This behavioral change
    can be temporarily reverted by setting ``envoy.reloadable_features.sanitize_original_path`` to false.
date: February 22, 2022

bug_fixes:
- area: data plane
  change: |
    fix crash when internal redirect selects a route configured with direct response or redirect actions.
- area: jwt_authn
  change: |
    fixed the crash when a CONNECT request is sent to JWT filter configured with regex match on the Host header.
- area: tcp_proxy
  change: |
    fix a crash that occurs when configured for :ref:`upstream tunneling
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.tunneling_config>` and the downstream connection
    disconnects while the the upstream connection or http/2 stream is still being established.
- area: upstream
  change: |
    fix stack overflow when a cluster with large number of idle connections is removed.

new_features:
- area: tls
  change: |
    added support for :ref:`match_typed_subject_alt_names
    <v1.21:envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`
    for subject alternative names to enforce specifying the subject alternative name type for the matcher to prevent
    matching against an unintended type in the certificate.

deprecated:
- area: tls
  change: |
    :ref:`match_subject_alt_names
    <v1.21:envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_subject_alt_names>` has
    been deprecated in favor of the :ref:`match_typed_subject_alt_names
    <v1.21:envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`.
date: July 26, 2023

behavior_changes:
- area: build
  change: |
    Moved the subset, ring_hash, and maglev LB code into extensions. If you use these load balancers and override
    :repo:`bazel/extensions_build_config.bzl` you will need to include them explicitly.
- area: build
  change: |
    Moved xDS code extensions. If you use the xDS and override :repo:`bazel/extensions_build_config.bzl` you will
    need to include the new config_subscriptions explicitly.
- area: http
  change: |
    When ``append_x_forwarded_host`` is enabled for a given route action it is now only appended iff it is different from the last
    value in the list. This resolves issues where a retry caused the same value to be appended multiple times. This
    behavioral change can be temporarily reverted by setting runtime guard ``envoy_reloadable_features_append_xfh_idempotent`` to ``false``.
- area: ext_proc
  change: |
    The proto field :ref:`value <envoy_v3_api_field_config.core.v3.HeaderValue.value>` type is string.
    This make it unable to support enconding non-utf8 characters in the ``HeaderValue`` message.
    To support sending header value with non-utf8 characters, a new proto field is added in the HeaderValue message:
    :ref:`raw_value <envoy_v3_api_field_config.core.v3.HeaderValue.raw_value>`.
    The header values are now encoded in this ``raw_value`` field when Envoy ext_proc filter sending
    and receiving messages from the ext_proc server. This behavioral change can be temporarily
    reverted by setting the runtime guard ``envoy_reloadable_features_send_header_raw_value`` to ``false``.
- area: ext_proc
  change: |
    Apply header mutation rules from the ext_proc config to the ``ImmediateResponse``. This behavior change can be temporarily
    reverted by setting the runtime guard ``envoy_reloadable_features_immediate_response_use_filter_mutation_rule`` to false.
- area: active health check
  change: |
    Preserve the active-health check status of a host after a cluster/assignment update. This is now preserved in cases
    where the assignment updates a host's locality. This behavioral change can be temporarily reverted by setting the
    runtime flag ``envoy.reloadable_features.keep_endpoint_active_hc_status_on_locality_update`` to ``false``.
- area: quic
  change: |
    Add a default false runtime flag ``envoy.reloadable_features.quic_reject_all`` to disable QUIC listener if needed.
- area: stats tls
  change: |
    Fixed metric tag extraction so that TLS parameters are properly extracted from the stats, both for listeners and clusters.
    This changes the Prometheus names from
    ``envoy_listener_ssl_ciphers_ECDHE_RSA_AES128_GCM_SHA256{envoy_listener_address="0.0.0.0_10000"}`` to
    ``envoy_listener_ssl_ciphers{envoy_listener_address="0.0.0.0_10000", envoy_ssl_cipher="ECDHE_RSA_AES128_GCM_SHA256"}``, and
    similar for ``envoy_listener_ssl_versions_TLSv1_2``, ``envoy_cluster_ssl_versions_TLSv1_2``, ``envoy_listener_ssl_curves_P_256``,
    ``envoy_cluster_ssl_curves_P_256``, ``envoy_listener_ssl_sigalgs_rsa_pss_rsae_sha256``.

minor_behavior_changes:
- area: connection pool
  change: |
    Increase granularity mapping connection pool failures to specific stream failure reasons to make it more transparent why
    the stream is reset when a connection pool's connection fails.
- area: custom response
  change: |
    The filter now traverses matchers from most specific to least specific per filter config till a match is found for the response.
- area: http1
  change: |
    Allowing mixed case schemes in absolute urls (e.g. HtTp://www.google.com). Mixed case schemes will be normalized to
    the lower cased equivalents before being forwarded upstream. This behavior can be reverted by setting runtime flag
    ``envoy.reloadable_features.allow_absolute_url_with_mixed_scheme`` to false.
- area: http1
  change: |
    The HTTP1 server-side codec no longer considers encoding 1xx headers as
    starting the response. This allows the codec to raise protocol errors,
    sending detailed local replies instead of just closing the connection. This
    behavior can be reverted by setting runtime flag
    ``envoy.reloadable_features.http1_allow_codec_error_response_after_1xx_headers``
    to ``false``.
- area: dns
  change: |
    Changing the DNS cache to use ``host:port`` as the cache key rather than ``host``. This allows a
    downstream DFP filter to serve both secure and insecure clusters. This behavioral change
    can be reverted by setting runtime flag ``envoy.reloadable_features.dfp_mixed_scheme`` to ``false``.
- area: uhv
  change: |
    Preserve case of %-encoded triplets in the default header validator. This behavior can be reverted by setting runtime flag
    ``envoy.reloadable_features.uhv_preserve_url_encoded_case`` to ``false``, in which case %-encoded triplets are normalized
    to uppercase characters. This setting is only applicable when the Unversal Header Validator is enabled and has no effect otherwise.
- area: uhv
  change: |
    Allow malformed URL encoded triplets in the default header validator. This behavior can be reverted by setting runtime flag
    ``envoy.reloadable_features.uhv_allow_malformed_url_encoding`` to ``false``, in which case requests with malformed URL encoded triplets
    in path are rejected. This setting is only applicable when the Unversal Header Validator is enabled and has no effect otherwise.
- area: ext_proc
  change: |
    When :ref:`clear_route_cache <envoy_v3_api_field_service.ext_proc.v3.CommonResponse.clear_route_cache>` is set, ext_proc will check
    for header mutations beforce clearing the route cache. Failures due to this check will be counted under the
    ``clear_route_cache_ignored`` stat.
- area: aws
  change: |
    Added support for fetching credentials from the AWS credentials file, which only happens if credentials cannot be fetched
    from environment variables. This behavioral change can be reverted by setting runtime guard
    ``envoy.reloadable_features.enable_aws_credentials_file`` to ``false``.
- area: http cookies
  change: |
    Changed internal format of http cookie to protobuf and added expiry timestamp. Processing expired cookie
    results in selection of a new upstream host and sending a new cookie to the client. Previous format of
    the cookie is still accepted, but is planned to be obsoleted in the future.
    This behavior change can be reverted by setting
    ``envoy.reloadable_features.stateful_session_encode_ttl_in_cookie`` to ``false``.
- area: overload manager
  change: |
    Changed behavior of the overload manager to error on unknown overload
    manager actions. Prior it would silently fail.  This change can be reverted
    temporarily by setting the runtime guard
    ``envoy.reloadable_features.overload_manager_error_unknown_action`` to
    false.
- area: router
  change: |
    Added check for existing metadata before setting metadata due to ``auto_sni``, ``auto_san_validation``, or
    ``override_auto_sni_header`` to prevent triggering ``ENVOY_BUG`` when an earlier filter has set the metadata.
- area: resource_monitors
  change: |
    Changed behavior of the fixed heap monitor to count unused mapped pages as
    free memory. This change can be reverted temporarily by setting the runtime guard
    ``envoy.reloadable_features.count_unused_mapped_pages_as_free`` to ``false``.
- area: ext_proc
  change: |
    Filter metadata containing ext proc stats has been moved from ``ext-proc-logging-info`` to a namespace corresponding
    to the name of the ext_proc filter.
- area: stats
  change: |
    Added new type of gauge with type hidden. These stats are hidden from admin/stats-sinks but can shown with a
    query-parameter of ``/stats?hidden=include`` or ``/stats?hidden=showonly``.
- area: ext_authz
  change: |
    Forward :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>` selected by
    ``typed_metadata_context_namespaces`` and :ref:`filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.filter_metadata>`
    selected by
    :ref:`metadata_context_namespaces <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.metadata_context_namespaces>`
    from connection metadata to external auth service. This is addition to the current behavior of forwarding request metadata.
    In the event of both connection and request metadata containing the requested metadata the request value will be provided.
- area: eds
  change: |
    Added the ability to specify mulitple addresses for a host in an EDS cluster. Connections to the host with more than one
    address will be established using the Happy Eyeballs algorithm.
- area: upstream
  change: |
    Changed behavior of the unpausing connect with 2xx status codes. This change can be reverted temporarily by
    setting the runtime guard ``envoy.reloadable_features.upstream_allow_connect_with_2xx`` to ``false``.
- area: http
  change: |
    Round trip time will not be refreshed for every request by default. And if this is necessary, it can be
    enabled by setting runtime guard ``envoy.reloadable_features.refresh_rtt_after_request`` to ``true``.
- area: http
  change: |
    Envoy will now lower case scheme values by default. This behaviorial change can be temporarily reverted
    by setting runtime guard ``envoy.reloadable_features.lowercase_scheme`` to ``false``.

bug_fixes:
- area: oauth2
  change: |
    The Max-Age attribute of Set-Cookie HTTP response header was being assigned a value representing Seconds Since
    the Epoch, causing cookies to expire in ~53 years. This was fixed an now it is being assigned a value representing
    the number of seconds until the cookie expires.
    This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.oauth_use_standard_max_age_value`` to ``false``.
- area: tls
  change: |
    Fix build FIPS compliance when using both FIPS mode and Wasm extensions (``--define boringssl=fips`` and ``--define wasm=v8``).
- area: http
  change: |
    Switched Envoy internal scheme checks from case sensitive to case insensitive. This behaviorial change can be temporarily
    reverted by setting runtime guard ``envoy.reloadable_features.handle_uppercase_scheme`` to ``false``.

    Fix `CVE-2023-35944 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-pvgm-7jpg-pw5g>`_.

- area: ext_authz
  change: |
    Fix a bug where the ext_authz filter will ignore the request body when the
    :ref:`pack_as_bytes <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.BufferSettings.pack_as_bytes>` is set to ``true`` and
    HTTP authorization service is configured.
- area: ext_authz
  change: |
    Fix a bug where the ext_authz filter will remove non UTF-8 characters from the body of a request when configured
    to use :ref:`http_service <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.http_service>`, if configured
    to send the body.
- area: router
  change: |
    Fixed the bug that updating :ref:`scope_key_builder
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scope_key_builder>`
    of SRDS config doesn't work and multiple HCM share the same ``scope_key_builder``.
- area: http
  change: |
    The :ref:`is_optional
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.is_optional>`
    field of HTTP filter can only be used for configuration loading of
    :ref:`HTTP filter <envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.HttpFilter>`
    and will be ignored for loading of route or virtual host level filter config. This behavioral change
    can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.ignore_optional_option_from_hcm_for_route_config`` to ``false``.
    You can also use
    :ref:`route/virtual host optional flag <envoy_v3_api_field_config.route.v3.FilterConfig.is_optional>`
    as a replacement of the feature.
- area: logging
  change: |
    Do not display GRPC_STATUS_NUMBER for non gRPC requests.
    This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.validate_grpc_header_before_log_grpc_status`` to ``false``.
- area: boringssl
  change: |
    Fixed the crash that occurs when contrib is compiled with ``boringssl=fips`` defined.
- area: oauth2
  change: |
    The ``httpOnly`` attribute for ``Set-Cookie`` for tokens in HTTP response header was missing,
    causing tokens to be accessible from the JavaScript making the apps vulnerable.
    This was fixed now by marking the cookie as ``httpOnly``.
    This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.oauth_make_token_cookie_httponly`` to ``false``.

    Fix `CVE-2023-35941 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-7mhv-gr67-hq55>`_.

- area: opentelemetry/grpc/access log
  change: |
    Fixed a bug in the open telemetry access logger. This logger now uses the
    server scope for stats instead of the listener's global scope. This fixes a
    use-after-free that can occur if the listener is drained but the cached
    gRPC access logger uses the listener's global scope for stats.

    Fix `CVE-2023-35942 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-69vr-g55c-v2v4>`_.

- area: dependency
  change: |
    Update Wasmtime and related deps -> 9.0.3 to resolve
    `CVE-2023-30624 <https://nvd.nist.gov/vuln/detail/CVE-2023-30624>`_.
- area: dependency
  change: |
    Update C-ares -> 1.91.1 to resolve:

    - `CVE-2023-31130 <https://nvd.nist.gov/vuln/detail/CVE-2023-31130>`_.
    - `CVE-2023-31147 <https://nvd.nist.gov/vuln/detail/CVE-2023-31147>`_.
    - `CVE-2023-31124 <https://nvd.nist.gov/vuln/detail/CVE-2023-31124>`_.
    - `CVE-2023-32067 <https://nvd.nist.gov/vuln/detail/CVE-2023-32067>`_.
- area: tcp_proxy
  change: |
    Fixed assert crash when multiple ``readDisable`` are called for TCP tunneling
    scenarios, by allowing multiple calls. This will also cause stats that indicate
    disable or enable of downstream read to be flushed only once per actual disabling
    or enabling.
- area: redis_proxy
  change: |
    Fixes a bug where route properties such as ``key_formatter``,
    ``prefix`` and ``remove_prefix`` do not take effect when configured for :ref:`catch_all_route
    <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.catch_all_route>`.
- area: upstream
  change: |
    Fixes a bug where the ``healthStatus()`` method of host return incorrect health status
    when the host status is updated by the EDS.
- area: upstream
  change: |
    Fixes a bug where the ``healthStatus()`` method of host return unmatched health status
    with the ``coarseHealth()`` method.
- area: original_dst
  change: |
    Fixes an issue with the ``ORIGINAL_DST`` cluster cleanup timer lifetime, which
    can occur if the cluster is removed while the timer is armed.
- area: maglev loadbalancer
  change: |
    Fixes maglev stability problem. Previously, maglev returns slightly different backend assignment from the same backends and keys.
- area: redis
  change: |
    Fixes a bug where redis transactions do not work properly when redis traffic is mirrored.
- area: http2
  change: |
    Fix memory leak in nghttp2 when scheduled requests are cancelled due to the ``GOAWAY`` frame being received from the
    upstream service.
- area: cors
  change: |
    Fix a use-after-free bug that occurs in the CORS filter if the ``origin`` header is removed between
    request header decoding and response header encoding.

    Fix `CVE-2023-35943 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-mc6h-6j9x-v3gq>`_.

- area: oauth2
  change: |
    Fixed a cookie validator bug that meant the HMAC calculation could be the same for different payloads.

    This prevents malicious clients from constructing credentials with permanent validity in some specific scenarios.
- area: postgres
  change: |
    Enable parsing when using upstream SSL.

removed_config_or_runtime:
- area: http
  change: |
    Removed runtime key ``envoy.reloadable_features.closer_shadow_behavior`` and legacy code paths.
- area: http
  change: |
    Removed runtime key ``envoy.reloadable_features.allow_upstream_filters`` and legacy code paths.
- area: quic
  change: |
    Removed runtime key ``envoy.reloadable_features.quic_defer_send_in_response_to_packet`` and legacy code paths.
- area: upstream
  change: |
    Removed runtime key ``envoy.reloadable_features.fix_hash_key`` and legacy code paths.
- area: logging
  change: |
    Removed runtime key ``envoy.reloadable_features.correct_remote_address`` and legacy code paths.
- area: http
  change: |
    Removed runtime key ``envoy.reloadable_features.http_response_half_close`` and legacy code paths.
- area: udp
  change: |
    Removed runtime key ``envoy.reloadable_features.udp_proxy_connect`` and legacy code paths.
- area: header_formatters
  change: |
    Removed runtime key ``envoy.reloadable_features.unified_header_formatter`` and legacy code paths.
- area: tls
  change: |
    Remove runtime key ``envoy.reloadable_features.tls_async_cert_validation`` and legacy code paths.
- area: config
  change: |
    Removed runtime key ``envoy.reloadable_features.delta_xds_subscription_state_tracking_fix`` and legacy code paths.
- area: http
  change: |
    Removed runtime key ``envoy.reloadable_features.http_strip_fragment_from_path_unsafe_if_disabled`` and legacy code paths.
- area: grpc_stats
  change: |
    Removed runtime key ``envoy.deprecated_features.grpc_stats_filter_enable_stats_for_all_methods_by_default`` and legacy code paths.

new_features:
- area: golang
  change: |
    Added new :ref:`l4 golang network filter <config_network_filters_golang>`.
- area: access_log
  change: |
    Added ``%ACCESS_LOG_TYPE%`` substitution string, to help distinguishing between access log records and when they are being
    recorded. Please refer to the access log configuration documentation for more information.
- area: access_log
  change: |
    Added :ref:`CEL <envoy_v3_api_msg_extensions.formatter.cel.v3.Cel>` access log formatter to print CEL expression.
- area: access_log
  change: |
    (QUIC only) Added support for %BYTES_RETRANSMITTED% and %PACKETS_RETRANSMITTED%.
- area: access_log
  change: |
    Added :ref:`DisableBuiltinLables
    <envoy_v3_api_field_extensions.access_loggers.open_telemetry.v3.OpenTelemetryAccessLogConfig.disable_builtin_labels>`
    to disable envoy builtin resource labels.
- area: dynamic_forward_proxy
  change: |
    Added :ref:`sub_clusters_config
    <envoy_v3_api_field_extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig.sub_clusters_config>` to enable
    independent sub cluster for each host:port, with STRICT_DNS cluster type.
- area: http
  change: |
    Added runtime feature ``envoy.reloadable_features.max_request_headers_size_kb`` to override the default value of
    :ref:`max request headers size
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.max_request_headers_kb>`.
- area: http
  change: |
    Added support for CONNECT-UDP (RFC 9298). Can be disabled by setting runtime feature
    ``envoy.reloadable_features.enable_connect_udp_support`` to false.
- area: listeners
  change: |
    Added :ref:`max_connections_to_accept_per_socket_event
    <envoy_v3_api_field_config.listener.v3.Listener.max_connections_to_accept_per_socket_event>`
    that sets the maximum number of new connections to be accepted per socket
    event on a listener. If there are more connections to be accepted beyond
    the maximum, the remaining connections would be processed in later
    dispatcher loop iterations. Added listener histogram
    ``connections_accepted_per_socket_event`` to allow users to empirically
    determine an appropriate configuration for their deployment.
- area: load shed point
  change: |
    Added load shed point ``envoy.load_shed_points.http_connection_manager_decode_headers`` that rejects new http streams
    by sending a local reply.
- area: load shed point
  change: |
    Added load shed point ``envoy.load_shed_points.http1_server_abort_dispatch`` that rejects HTTP1 server processing of requests.
- area: load shed point
  change: |
    Added load shed point ``envoy.load_shed_points.http2_server_go_away_on_dispatch`` that sends
    ``GOAWAY`` for HTTP2 server processing of requests.  When a ``GOAWAY`` frame is submitted by
    this the counter ``http2.goaway_sent`` will be incremented.
- area: matchers
  change: |
    Added :ref:`RuntimeFraction <envoy_v3_api_msg_extensions.matching.input_matchers.runtime_fraction.v3.RuntimeFraction>` input
    matcher. It allows matching hash of the input on a runtime key.
- area: stat_sinks
  change: |
    Added ``envoy.stat_sinks.open_telemetry`` stats_sink, that supports flushing metrics by the OTLP protocol,
    for supported Open Telemetry collectors.
- area: redis_proxy
  change: |
    Added new configuration field :ref:`key_formatter
    <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.key_formatter>` to format redis key.
    The field supports using %KEY% as a formatter command for substituting the redis key as part of the substitution formatter expression.
- area: stats
  change: |
    Added config :ref:`enable_deferred_creation_stats
    <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.DeferredStatOptions.enable_deferred_creation_stats>`.
    When set to ``true``, enables deferred instantiation on supported stats structures.
- area: ratelimit
  change: |
    Added new configuration field :ref:`domain
    <envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimitPerRoute.domain>` to allow for setting rate limit domains on a
    per-route basis.
- area: tls_inspector
  change: |
    Added histogram ``bytes_processed`` which records the number of bytes of
    the tls_inspector processed while analyzing for tls usage. In cases where
    the connection uses tls this records the tls client hello size. In cases
    where the connection doesn't use tls this records the amount of bytes the
    tls_inspector processed until it realized the connection was not using tls.
- area: tls_inspector
  change: |
    Added new configuration field :ref:`initial_read_buffer_size
    <envoy_v3_api_field_extensions.filters.listener.tls_inspector.v3.TlsInspector.initial_read_buffer_size>`
    to allow users to tune the buffer size requested by the filter. If
    configured, and the filter needs additional bytes, the filter will double
    the number of bytes requested up to the default 64KiB maximum.
- area: access_log
  change: |
    Added access log filter :ref:`log_type_filter <envoy_v3_api_field_config.accesslog.v3.AccessLogFilter.log_type_filter>`
    to filter access log records based on the type of the record.
- area: ext_proc
  change: |
    Added new configuration field
    :ref:`disable_clear_route_cache <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.disable_clear_route_cache>`
    to force the ext_proc filter from clearing the route cache. Failures to clear from setting this field will be counted under the
    ``clear_route_cache_disabled`` stat.
- area: ext_proc
  change: |
    Added new configuration field
    :ref:`allow_mode_override <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.allow_mode_override>`
    If set to true, the filter config
    :ref:`processing_mode <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
    can be overridden by the
    :ref:`mode_override <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.mode_override>`
    in the response message from the external processing server.
    If not set, the ``mode_override`` API in the response message will be ignored.
- area: ext_proc
  change: |
    :ref:`forward_rules <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.forward_rules>`
    to only allow headers matching the rules to be forwarded to the external processing server.
- area: redis_proxy
  change: |
    Added new field :ref:`connection_rate_limit
    <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings.connection_rate_limit>`
    to limit reconnection rate to redis server to avoid reconnection storm.
- area: match_delegate
  change: |
    Added :ref:`per route configuration
    <envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcherPerRoute>` to the
    :ref:`ExtensionWithMatcher
    <envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcher>` filter.
    Which allows the associated matcher to be defined on a per route basis.
- area: match_delegate
  change: |
    If no matcher is set the :ref:`ExtensionWithMatcher
    <envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcher>` filter is now set to skip rather than erroring out.
- area: access_log
  change: |
    Added additional HCM access log option :ref:`flush_log_on_tunnel_successfully_established
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.flush_log_on_tunnel_successfully_established>`.
    Enabling this option will write a log to all access loggers when HTTP tunnels (e.g. Websocket and ``CONNECT``)
    are successfully established.
- area: admin
  change: |
    Adds a new admin stats html bucket-mode ``detailed`` to generate all recorded buckets and summary percentiles.
- area: http
  change: |
    Add support to the route/virtual host level
    :ref:`is_optional <envoy_v3_api_field_config.route.v3.FilterConfig.is_optional>` field.
    A route/virtual host level per filter config can be marked as optional, which means that if
    the filter fails to load, the configuration will no be rejected.
- area: upstream
  change: |
    Added :ref:`cluster provided extension
    <envoy_v3_api_msg_extensions.load_balancing_policies.cluster_provided.v3.ClusterProvided>`
    to suppport the :ref:`load balancer policy <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>`.
- area: fault
  change: |
    Added new field ``envoy.extensions.filters.http.fault.v3.HTTPFault.filter_metadata`` to aid in logging.
    Metadata will be stored in StreamInfo dynamic metadata under a namespace corresponding to the name of the fault filter.
- area: load_balancing
  change: |
    Added new option
    :ref:`weighted_priority_health <envoy_v3_api_field_config.endpoint.v3.ClusterLoadAssignment.Policy.weighted_priority_health>`
    to compute the health of a :ref:`priority level <arch_overview_load_balancing_priority_levels>` by using
    :ref:`load balancing weight <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.load_balancing_weight>`
    instead of the count of healthy hosts.
- area: application_logs
  change: |
    Added bootstrap option
    :ref:`application_log_format <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat.json_format>`
    to enable setting application log format as JSON structure.
- area: application_logs
  change: |
    Added bootstrap option
    :ref:`application_log_format <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat.text_format>`
    to enable setting application log text format from config.
- area: ext_proc
  change: |
    Added new field ``filter_metadata <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExtProc.filter_metadata`` to aid in logging.
    Metadata will be stored in ``StreamInfo`` filter metadata under a namespace corresponding to the name of the ext proc filter.
- area: matching
  change: |
    Added CEL(Common Expression Language) matcher support :ref:`CEL data input <extension_envoy.matching.inputs.cel_data_input>`
    and :ref:`CEL input matcher <extension_envoy.matching.matchers.cel_matcher>`.
- area: tls
  change: |
    Added support for hot-reloading CRL file when the file changes on disk.
    This works with dynamic secrets when
    :ref:`CertificateValidationContext <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.CertificateValidationContext>`
    is delivered via SDS.
- area: http
  change: |
    Added support for configuring additional :ref:`cookie attributes <envoy_v3_api_msg_config.route.v3.RouteAction.HashPolicy.cookie>`.
- area: http
  change: |
    Added support for the route/virtual host level
    :ref:`disabled <envoy_v3_api_field_config.route.v3.FilterConfig.disabled>` field.
    A route/virtual host level per filter config can be marked as disabled, which means that
    the filter will be disabled in a specific route/virtual host.
- area: health_check
  change: |
    Added host related information :ref:`metadata <envoy_v3_api_field_data.core.v3.HealthCheckEvent.metadata>` and
    :ref:`locality <envoy_v3_api_field_data.core.v3.HealthCheckEvent.locality>` to
    the :ref:`health check event <envoy_v3_api_msg_data.core.v3.HealthCheckEvent>` definition.
- area: zookeeper
  change: |
    Added the ``addWatch`` opcode support to the ZooKeeper proxy filter.
- area: config
  change: |
    added a statistic :ref:`warming_state <config_cluster_stats>` to indicate the current warming state of a cluster.
- area: access_log
  change: |
    Added bytes snapshotting for upstream and downstream logging that will be reset after every periodic log. Downstream
    periodic loggers should read ``BytesMeter::bytesAtLastDownstreamPeriodicLog()``, and upstream periodic loggers should read
    ``BytesMeter::bytesAtLastUpstreamPeriodicLog()``.
- area: lds
  change: |
    Pause SRDS when LDS is updated.
- area: http
  change: |
    Added :ref:`outbound_control_frames_active <statistics>` and :ref:`outbound_frames_active <statistics>`
    statistic.
- area: original_dst
  change: |
    Filter state is pulled from request context first (if available), then falls back to connection context. Added ability to pick host
    from dynamic metadata using :ref:`metadata_key <envoy_v3_api_field_config.cluster.v3.Cluster.OriginalDstLbConfig.metadata_key>`.
    Same behavior - looks in request context first (if available), falls back to connection context.
- area: tls
  change: |
    Added support to configure the new config option
    :ref:`enforce_rsa_key_usage <envoy_v3_api_field_extensions.transport_sockets.tls.v3.UpstreamTlsContext.enforce_rsa_key_usage>`.
    This can be used to override its configuration in BoringSSL. It is currently default to false but expected to be changed
    to true by default in a future release. ``ssl.was_key_usage_invalid`` is added to :ref:`listener metrics <config_listener_stats>`
    and will be incremented for certificate configurations that would fail if this option were set to true.
- area: http
  change: |
    Added ``OVERWRITE_IF_EXISTS`` header manipulation keyword to overwrite a header only when it exists before manipulation.
- area: tls
  change: |
    Added FIPS compliant build for arm64.

deprecated:
- area: access_log
  change: |
    Deprecated (1.25.0) :ref:`intermediate_log_entry <envoy_v3_api_field_data.accesslog.v3.AccessLogCommon.intermediate_log_entry>`
    in favour of :ref:`access_log_type <envoy_v3_api_field_data.accesslog.v3.AccessLogCommon.access_log_type>`.
- area: health_check
  change: |
    deprecated the :ref:`HealthCheck event_log_path <envoy_v3_api_field_config.core.v3.HealthCheck.event_log_path>` in favor of
    :ref:`HealthCheck event_logger extension <envoy_v3_api_field_config.core.v3.HealthCheck.event_logger>`.
- area: stats
  change: |
    Added :ref:`enable_deferred_creation_stats
    <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.DeferredStatOptions.enable_deferred_creation_stats>`.
    support for ``ClusterTrafficStats``.
- area: access_log
  change: |
    Added ``%DOWNSTREAM_LOCAL_DNS_SAN%``, ``%DOWNSTREAM_PEER_DNS_SAN%``, ``%DOWNSTREAM_LOCAL_IP_SAN%``
    and ``%DOWNSTREAM_PEER_IP_SAN%`` substitution formatters.
date: June 30, 2020

changes:
- area: buffer
  change: |
    fixed CVE-2020-12603 by avoiding fragmentation, and tracking of HTTP/2 data and control frames in the output buffer.
- area: http
  change: |
    fixed CVE-2020-12604 by changing :ref:`stream_idle_timeout
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>` to also
    defend against an HTTP/2 peer that does not open stream window once an entire response has been buffered to be sent to a
    downstream client.
- area: http
  change: |
    fixed CVE-2020-12605 by including request URL in request header size computation, and rejecting partial headers that
    exceed configured limits.
- area: listener
  change: |
    fixed CVE-2020-8663 by adding runtime support for :ref:`per-listener limits <config_listeners_runtime>` on
    active/accepted connections.
- area: overload management
  change: |
    fixed CVE-2020-8663 by adding runtime support for :ref:`global limits <config_overload_manager>` on active/accepted
    connections.
date: April 4, 2023

behavior_changes:
- area: http
  change: |
    Validate upstream request header names and values. The new runtime flag
    ``envoy.reloadable_features.validate_upstream_headers`` can be used for revert this behavior.

bug_fixes:
- area: oauth2
  change: |
    fixed a bug where the oauth2 filter would crash if it received a redirect URL without a state query param set.
- area: lua
  change: |
    lua coroutine should not execute after local reply is sent.
- area: grpc
  change: |
    when Envoy was configured to use ext_authz, ext_proc, tap, ratelimit filters, and grpc access log service and an http
    header with non-UTF-8 data was received, Envoy would generate an invalid protobuf message and send it to the configured
    service. The receiving service would typically generate an error when decoding the protobuf message. For ext_authz that
    was configured with ``failure_mode_allow: true``, the request would have been allowed in this case. For the other services,
    this could have resulted in other unforseen errors such as a lack of visibility into requests (eg request not logged). Envoy
    will now by default sanitize the values sent in gRPC service calls to be valid UTF-8, replacing data that is not valid UTF-8
    with a '!' character. This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.service_sanitize_non_utf8_strings`` to false.
- area: http
  change: |
    stop forwarding ``:method`` value which is not a valid token defined in https://www.rfc-editor.org/rfc/rfc9110#section-5.6.2.
    Also, reject ``:method`` and ``:scheme`` headers with multiple values.
- area: http3
  change: |
    reject pseudo headers violating RFC 9114. Specifically, pseudo-header fields with more than one value for the ``:method``
    (non-``CONNECT``), ``:scheme``, and ``:path``; or pseudo-header fields after regular header fields; or undefined
    pseudo-headers.
- area: http
  change: |
    fixed a bug where ``x-envoy-original-path`` was not being sanitized when sent from untrusted users. This behavioral change
    can be temporarily reverted by setting ``envoy.reloadable_features.sanitize_original_path`` to false.
date: December 7, 2020

bug_fixes:
- area: http
  change: |
    fixed URL parsing for HTTP/1.1 fully qualified URLs and connect requests containing IPv6 addresses.
- area: vrp
  change: |
    allow supervisord to open its log file.
date: July 26, 2023

minor_behavior_changes:
- area: http
  change: |
    Envoy will now lower case scheme values by default. This behaviorial change can be temporarily reverted
    by setting runtime guard ``envoy.reloadable_features.lowercase_scheme`` to ``false``.

bug_fixes:
- area: cors
  change: |
    Fix a use-after-free bug that occurs in the CORS filter if the ``origin`` header is removed between
    request header decoding and response header encoding.

    Fix `CVE-2023-35943 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-mc6h-6j9x-v3gq>`_.
- area: http
  change: |
    Switched Envoy internal scheme checks from case sensitive to case insensitive. This behaviorial change can be temporarily
    reverted by setting runtime guard ``envoy.reloadable_features.handle_uppercase_scheme`` to ``false``.

    Fix `CVE-2023-35944 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-pvgm-7jpg-pw5g>`_.
- area: opentelemetry/grpc/access log
  change: |
    Fixed a bug in the open telemetry access logger. This logger now uses the
    server scope for stats instead of the listener's global scope. This fixes a
    use-after-free that can occur if the listener is drained but the cached
    gRPC access logger uses the listener's global scope for stats.

    Fix `CVE-2023-35942 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-69vr-g55c-v2v4>`_.
- area: oauth2
  change: |
    Fixed a cookie validator bug that meant that the HMAC calculation could be same for different payloads.

    This prevents malicious clients from constructing credentials with permanent validity in some specific scenarios.

    Fix `CVE-2023-35941 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-7mhv-gr67-hq55>`_.

new_features:
- area: tls
  change: |
    Added FIPS compliant build for arm64.
date: March 3, 2020

changes:
- area: buffer
  change: |
    force copy when appending small slices to OwnedImpl buffer to avoid fragmentation.
- area: http
  change: |
    added HTTP/1.1 flood protection. Can be temporarily disabled using the runtime feature
    ``envoy.reloadable_features.http1_flood_protection``.
- area: listeners
  change: |
    fixed issue where :ref:`TLS inspector listener filter <config_listener_filters_tls_inspector>` could have been bypassed
    by a client using only TLS 1.3.
- area: rbac
  change: |
    added :ref:`url_path <envoy_api_field_config.rbac.v2.Permission.url_path>` for matching URL path without the query and
    fragment string.
- area: sds
  change: |
    fixed the SDS vulnerability that TLS validation context (e.g., subject alt name or hash) cannot be effectively validated
    in some cases.
date: Pending

behavior_changes:
# *Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*

minor_behavior_changes:
# *Changes that may cause incompatibilities for some users, but should not for most*
- area: adaptive concurrency filter stats
  change: |
    Multiply the gradient value stat by 1000 to make it more granular (values will range between 500 and 2000).

bug_fixes:
# *Changes expected to improve the state of the world and are unlikely to have negative effects*
- area: tracers
  change: |
    use unary RPC calls for OpenTelemetry trace exports, rather than client-side streaming connections.

removed_config_or_runtime:
# *Normally occurs at the end of the* :ref:`deprecation period <deprecated>`
- area: http
  change: |
    Removed ``envoy.reloadable_features.allow_absolute_url_with_mixed_scheme`` runtime flag and legacy code paths.
- area: overload manager
  change: |
    removed ``envoy.reloadable_features.overload_manager_error_unknown_action`` and legacy code paths.

new_features:
- area: aws_request_signing
  change: |
    Update ``aws_request_signing`` filter to support use as an upstream HTTP filter. This allows successful calculation of
    signatures after the forwarding stage has completed, particularly if the path element is modified.
- area: grpc reverse bridge
  change: |
    Change HTTP status to 200 to respect the gRPC protocol. This may cause problems for incorrect gRPC clients expecting the filter
    to preserve HTTP 1.1 responses.  This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.grpc_http1_reverse_bridge_change_http_status`` to false.
- area: ext_proc
  change: |
    implemented
    :ref:`request_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.request_attributes>`
    and
    :ref:`response_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.response_attributes>`
    config APIs to enable sending and receiving attributes to/from the external processing server.
- area: access log
  change: |
    added support for :ref:`%UPSTREAM_CONNECTION_ID% <config_access_log_format_upstream_connection_id>` for the upstream connection
    identifier.

deprecated:
date: July 27, 2022

bug_fixes:
- area: docker
  change: |
    update Docker images (``distroless`` -> ``49d2923f35d6``) to resolve CVE issues in container packages.
date: June 10, 2022

bug_fixes:
- area: ci
  change: |
    fixes/workarounds for CI that prevented publication of version 1.22.1.
date: January 20, 2020

changes:
- area: access log
  change: |
    added ``FILTER_STATE`` :ref:`access log formatters <config_access_log_format>` and gRPC access logger.
- area: admin
  change: |
    added the ability to filter :ref:`/config_dump <operations_admin_interface_config_dump>`.
- area: access log
  change: |
    added a :ref:`typed JSON logging mode <config_access_log_format_dictionaries>` to output access logs in JSON format with
    non-string values.
- area: access log
  change: |
    fixed ``UPSTREAM_LOCAL_ADDRESS`` :ref:`access log formatters <config_access_log_format>` to work for http requests.
- area: access log
  change: |
    added ``HOSTNAME``.
- area: api
  change: |
    remove all support for v1.
- area: api
  change: |
    added ability to specify ``mode`` for :ref:`Pipe <envoy_api_field_core.Pipe.mode>`.
- area: api
  change: |
    support for the v3 xDS API added. See :ref:`api_supported_versions`.
- area: aws_request_signing
  change: |
    added new alpha HTTP AWS request signing filter.
- area: buffer
  change: |
    remove old implementation.
- area: build
  change: |
    official released binary is now built against libc++.
- area: cluster
  change: |
    added :ref:`aggregate cluster <arch_overview_aggregate_cluster>` that allows load balancing between clusters.
- area: config
  change: |
    all category names of internal envoy extensions are prefixed with the 'envoy.' prefix to follow the reverse DNS naming
    notation.
- area: decompressor
  change: |
    remove decompressor hard assert failure and replace with an error flag.
- area: ext_authz
  change: |
    added :ref:`configurable ability <envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.include_peer_certificate>` to
    send the :ref:`certificate <envoy_api_field_service.auth.v2.AttributeContext.Peer.certificate>` to the ``ext_authz``
    service.
- area: fault
  change: |
    fixed an issue where the http fault filter would repeatedly check the percentage of abort/delay when the ``x-envoy-
    downstream-service-cluster`` header was included in the request to ensure that the actual percentage of abort/delay
    matches the configuration of the filter.
- area: health check
  change: |
    gRPC health checker sets the gRPC deadline to the configured timeout duration.
- area: health check
  change: |
    added :ref:`TlsOptions <envoy_api_msg_core.HealthCheck.TlsOptions>` to allow TLS configuration overrides.
- area: health check
  change: |
    added :ref:`service_name_matcher <envoy_api_field_core.HealthCheck.HttpHealthCheck.service_name_matcher>` to better
    compare the service name patterns for health check identity.
- area: http
  change: |
    added strict validation that ``CONNECT`` is refused as it is not yet implemented. This can be reversed temporarily by
    setting the runtime feature ``envoy.reloadable_features.strict_method_validation`` to false.
- area: http
  change: |
    added support for http1 trailers. To enable use :ref:`enable_trailers
    <envoy_api_field_core.Http1ProtocolOptions.enable_trailers>`.
- area: http
  change: |
    added the ability to sanitize headers nominated by the Connection header. This new behavior is guarded by
    ``envoy.reloadable_features.connection_header_sanitization`` which defaults to true.
- area: http
  change: |
    blocks unsupported transfer-encodings. Can be reverted temporarily by setting runtime feature
    ``envoy.reloadable_features.reject_unsupported_transfer_encodings`` to false.
- area: http
  change: |
    support :ref:`auto_host_rewrite_header
    <envoy_api_field_config.filter.http.dynamic_forward_proxy.v2alpha.PerRouteConfig.auto_host_rewrite_header>` in the
    dynamic forward proxy.
- area: jwt_authn
  change: |
    added :ref:`allow_missing <envoy_api_field_config.filter.http.jwt_authn.v2alpha.JwtRequirement.allow_missing>` option
    that accepts request without token but rejects bad request with bad tokens.
- area: jwt_authn
  change: |
    added :ref:`bypass_cors_preflight
    <envoy_api_field_config.filter.http.jwt_authn.v2alpha.JwtAuthentication.bypass_cors_preflight>` to allow bypassing the
    CORS preflight request.
- area: lb_subset_config
  change: |
    new fallback policy for selectors: :ref:`KEYS_SUBSET
    <envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`.
- area: listeners
  change: |
    added :ref:`reuse_port <envoy_api_field_Listener.reuse_port>` option.
- area: logger
  change: |
    added :ref:`--log-format-escaped <operations_cli>` command line option to escape newline characters in application logs.
- area: ratelimit
  change: |
    added :ref:`local rate limit <config_network_filters_local_rate_limit>` network filter.
- area: rbac
  change: |
    added support for matching all subject alt names instead of first in :ref:`principal_name
    <envoy_api_field_config.rbac.v2.Principal.Authenticated.principal_name>`.
- area: redis
  change: |
    performance improvement for larger split commands by avoiding string copies.
- area: redis
  change: |
    correctly follow MOVE/ASK redirection for mirrored clusters.
- area: redis
  change: |
    add :ref:`host_degraded_refresh_threshold
    <envoy_api_field_config.cluster.redis.RedisClusterConfig.host_degraded_refresh_threshold>` and
    :ref:`failure_refresh_threshold <envoy_api_field_config.cluster.redis.RedisClusterConfig.failure_refresh_threshold>` to
    refresh topology when nodes are degraded or when requests fails.
- area: router
  change: |
    added histograms to show timeout budget usage to the :ref:`cluster stats <config_cluster_manager_cluster_stats>`.
- area: router check tool
  change: |
    added support for testing and marking coverage for routes of runtime fraction 0.
- area: router
  change: |
    added :ref:`request_mirror_policies <envoy_api_field_route.RouteAction.request_mirror_policies>` to support sending
    multiple mirrored requests in one route.
- area: router
  change: |
    added support for ``REQ(header-name)`` :ref:`header formatter <config_http_conn_man_headers_custom_request_headers>`.
- area: router
  change: |
    added support for percentage-based :ref:`retry budgets
    <envoy_api_field_cluster.CircuitBreakers.Thresholds.retry_budget>`.
- area: router
  change: |
    allow using a :ref:`query parameter <envoy_api_field_route.RouteAction.HashPolicy.query_parameter>` for HTTP consistent
    hashing.
- area: router
  change: |
    exposed ``DOWNSTREAM_REMOTE_ADDRESS`` as custom HTTP request/response headers.
- area: router
  change: |
    added support for :ref:`max_internal_redirects <envoy_api_field_route.RouteAction.max_internal_redirects>` for
    configurable maximum internal redirect hops.
- area: router
  change: |
    skip the Location header when the response code is not a 201 or a 3xx.
- area: router
  change: |
    added :ref:`auto_sni <envoy_api_field_core.UpstreamHttpProtocolOptions.auto_sni>` to support setting SNI to transport
    socket for new upstream connections based on the downstream HTTP host/authority header.
- area: router
  change: |
    added support for ``HOSTNAME`` :ref:`header formatter <config_http_conn_man_headers_custom_request_headers>`.
- area: server
  change: |
    added the :option:`--disable-extensions` CLI option, to disable extensions at startup.
- area: server
  change: |
    fixed a bug in config validation for configs with runtime layers.
- area: server
  change: |
    added :ref:`workers_started <config_listener_manager_stats>` that indicates whether listeners have been fully
    initialized on workers.
- area: tcp_proxy
  change: |
    added :ref:`ClusterWeight.metadata_match
    <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.WeightedCluster.ClusterWeight.metadata_match>`.
- area: tcp_proxy
  change: |
    added :ref:`hash_policy <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.hash_policy>`.
- area: thrift_proxy
  change: |
    added support for cluster header based routing.
- area: thrift_proxy
  change: |
    added stats to the router filter.
- area: tls
  change: |
    remove TLS 1.0 and 1.1 from client defaults.
- area: tls
  change: |
    added support for :ref:`generic string matcher
    <envoy_api_field_auth.CertificateValidationContext.match_subject_alt_names>` for subject alternative names.
- area: tracing
  change: |
    added the ability to set custom tags on both the :ref:`HTTP connection manager
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.tracing>` and the :ref:`HTTP
    route <envoy_api_field_route.Route.tracing>`.
- area: tracing
  change: |
    added upstream_address tag.
- area: tracing
  change: |
    added initial support for AWS X-Ray (local sampling rules only) :ref:`X-Ray Tracing
    <envoy_api_msg_config.trace.v2alpha.XRayConfig>`.
- area: tracing
  change: |
    added tags for gRPC request path, authority, content-type and timeout.
- area: udp
  change: |
    added initial support for :ref:`UDP proxy <config_udp_listener_filters_udp_proxy>`.

deprecated:
- area: tracing
  change: |
    The ``request_headers_for_tags`` field in :ref:`HTTP connection manager
    <envoy_api_msg_config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing>` has been deprecated in
    favor of the :ref:`custom_tags
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.tracing.custom_tags>` field.
- area: certificates
  change: |
    The ``verify_subject_alt_name`` field in :ref:`Certificate Validation Context
    <envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name>` has been deprecated in favor of the
    :ref:`match_subject_alt_names <envoy_api_field_auth.CertificateValidationContext.match_subject_alt_names>` field.
- area: router
  change: |
    The ``request_mirror_policy`` field in :ref:`RouteMatch <envoy_api_msg_route.RouteAction>` has been deprecated in favor
    of the ``request_mirror_policies`` field.
- area: health_checker
  change: |
    The ``service_name`` field in :ref:`HTTP health checker <envoy_api_msg_core.HealthCheck.HttpHealthCheck>` has been
    deprecated in favor of the ``service_name_matcher`` field.
- area: xds
  change: |
    The v2 xDS API is deprecated. It will be supported by Envoy until EOY 2020. See :ref:`api_supported_versions`.
date: October 10, 2023

behavior_changes:
- area: http
  change: |
    Close HTTP/2 and HTTP/3 connections that prematurely reset streams. The runtime key
    ``overload.premature_reset_min_stream_lifetime_seconds`` determines the interval where received stream
    reset is considered premature (with 1 second default). The runtime key ``overload.premature_reset_total_stream_count``,
    with the default value of 500, determines the number of requests received from a connection before the check for premature
    resets is applied. The connection is disconnected if more than 50% of resets are premature.
    Setting the runtime key ``envoy.restart_features.send_goaway_for_premature_rst_streams`` to ``false`` completely disables
    this check.
- area: http
  change: |
    Add runtime flag ``http.max_requests_per_io_cycle`` for setting the limit on the number of HTTP requests processed
    from a single connection in a single I/O cycle. Requests over this limit are processed in subsequent I/O cycles. This
    mitigates CPU starvation by connections that simultaneously send high number of requests by allowing requests from other
    connections to make progress. This runtime value can be set to 1 in the presence of abusive HTTP/2 or HTTP/3 connections.
    By default this limit is disabled.

bug_fixes:
- area: tls
  change: |
    fixed a bug where handshake may fail when both private key provider and cert validation are set.
date: July 25, 2023

minor_behavior_changes:
- area: http
  change: |
    Envoy will now lower case scheme values by default. This behaviorial change can be temporarily reverted
    by setting runtime guard ``envoy.reloadable_features.lowercase_scheme`` to ``false``.

bug_fixes:
- area: cors
  change: |
    Fix a use-after-free bug that occurs in the CORS filter if the ``origin`` header is removed between
    request header decoding and response header encoding.

    Fix `CVE-2023-35943 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-mc6h-6j9x-v3gq>`_.
- area: opentelemetry/grpc/access log
  change: |
    Fixed a bug in the open telemetry access logger. This logger now uses the
    server scope for stats instead of the listener's global scope. This fixes a
    use-after-free that can occur if the listener is drained but the cached
    gRPC access logger uses the listener's global scope for stats.

    Fix `CVE-2023-35942 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-69vr-g55c-v2v4>`_.
- area: oauth2
  change: |
    Fixed a cookie validator bug that meant the HMAC calculation could be the same for different payloads.

    This prevents malicious clients from constructing credentials with permanent validity in some specific scenarios.

    Fix `CVE-2023-35941 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-7mhv-gr67-hq55>`_.
- area: http
  change: |
    Switched Envoy internal scheme checks from case sensitive to case insensitive. This behaviorial change can be temporarily
    reverted by setting runtime guard ``envoy.reloadable_features.handle_uppercase_scheme`` to ``false``.

    Fix `CVE-2023-35944 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-pvgm-7jpg-pw5g>`_.
date: April 15, 2021

bug_fixes:
- area: aggregate cluster
  change: |
    fixed a crash due to a TLS initialization issue.
- area: http
  change: |
    fixed a crash upon receiving empty HTTP/2 metadata frames. Received empty metadata frames are now counted in the HTTP/2
    codec stat :ref:`metadata_empty_frames <config_http_conn_man_stats_per_codec>`.
- area: http
  change: |
    fixed a remotely exploitable integer overflow via a very large grpc-timeout value causes undefined behavior.
- area: http
  change: |
    reverting a behavioral change where upstream connect timeouts were temporarily treated differently from other connection
    failures. The change back to the original behavior can be temporarily reverted by setting
    ``envoy.reloadable_features.treat_upstream_connect_timeout_as_connect_failure`` to false.
- area: lua
  change: |
    fixed crash when Lua script contains ``streamInfo():downstreamSslConnection()``.
- area: overload
  change: |
    fix a bug that can cause use-after-free when one scaled timer disables another one with the same duration.
- area: tls
  change: |
    fix a crash when peer sends a TLS Alert with an unknown code.
- area: tls
  change: |
    fix detection of the upstream connection close event.
date: March 23, 2023

bug_fixes:
- area: dependency
  change: |
    update Wasmtime -> 6.0.1 to resolve CVE-2023-26489, CVE-2023-27477.
date: June 8, 2020

changes:
- area: http
  change: |
    added :ref:`headers_with_underscores_action setting
    <envoy_api_field_core.HttpProtocolOptions.headers_with_underscores_action>` to control how client requests with header
    names containing underscore characters are handled. The options are to allow such headers, reject request or drop
    headers. The default is to allow headers, preserving existing behavior.
- area: http
  change: |
    fixed CVE-2020-11080 by rejecting HTTP/2 SETTINGS frames with too many parameters.
date: October 11, 2023

behavior_changes:
- area: http
  change: |
    Close HTTP/2 and HTTP/3 connections that prematurely reset streams. The runtime key
    ``overload.premature_reset_min_stream_lifetime_seconds`` determines the interval where received stream
    reset is considered premature (with 1 second default). The runtime key ``overload.premature_reset_total_stream_count``,
    with the default value of 500, determines the number of requests received from a connection before the check for premature
    resets is applied. The connection is disconnected if more than 50% of resets are premature.
    Setting the runtime key ``envoy.restart_features.send_goaway_for_premature_rst_streams`` to ``false`` completely disables
    this check.
- area: http
  change: |
    Add runtime flag ``http.max_requests_per_io_cycle`` for setting the limit on the number of HTTP requests processed
    from a single connection in a single I/O cycle. Requests over this limit are processed in subsequent I/O cycles. This
    mitigates CPU starvation by connections that simultaneously send high number of requests by allowing requests from other
    connections to make progress. This runtime value can be set to 1 in the presence of abusive HTTP/2 or HTTP/3 connections.
    By default this limit is disabled.

bug_fixes:
- area: connection limit
  change: |
    fixed a use-after-free bug in the connection limit filter.
- area: tls
  change: |
    fixed a bug where handshake may fail when both private key provider and cert validation are set.
- area: docker/publishing
  change: |
    Update base images to resolve various glibc vulnerabilities.
date: April 26, 2022

minor_behavior_changes:
- area: perf
  change: |
    ssl contexts are now tracked without scan based garbage collection and greatly improved the performance on secret
    update.

bug_fixes:
- area: docker
  change: |
    update Docker images to resolve CVE issues in container packages (#20760).
date: January 16, 2024

behavior_changes:
- area: http
  change: |
    Remove the hop by hop TE header from downstream request headers. This change can be temporarily reverted
    by setting ``envoy.reloadable_features.sanitize_te`` to ``false``.
- area: http
  change: |
    Flip runtime flag ``envoy.reloadable_features.no_downgrade_to_canonical_name`` to ``true``. Name downgrading in the
    per filter config searching will be disabled by default. This behavior can be temporarily reverted by setting
    the flag to ``false`` explicitly.
    See doc :ref:`Http filter route specific config <arch_overview_http_filters_per_filter_config>` or
    issue https://github.com/envoyproxy/envoy/issues/29461 for more specific detail and examples.
- area: listener
  change: |
    Undeprecated runtime key ``overload.global_downstream_max_connections`` until :ref:`downstream connections monitor
    <envoy_v3_api_msg_extensions.resource_monitors.downstream_connections.v3.DownstreamConnectionsConfig>` extension becomes stable.
- area: stats dns_filter
  change: |
    Fixed tag extraction so that :ref:`stat_prefix <envoy_v3_api_msg_extensions.filters.udp.dns_filter.v3.DnsFilterConfig>`
    is properly extracted. This changes the Prometheus name from
    ``dns_filter_myprefix_local_a_record_answers{}`` to ``dns_filter_local_a_record_answers{envoy.dns_filter_prefix="myprefix"}``.
- area: stats connection_limit
  change: |
    Fixed tag extraction so that :ref:`stat_prefix <envoy_v3_api_msg_extensions.filters.network.connection_limit.v3.ConnectionLimit>`
    is properly extracted. This changes the Prometheus name from ``envoy_connection_limit_myprefix_limited_connections{}`` to
    ``envoy_connection_limit_limited_connections{envoy_connection_limit_prefix="myprefix"}``.
- area: stats rbac
  change: |
    Fixed tag extraction so that :ref:`stat_prefix <envoy_v3_api_msg_extensions.filters.network.rbac.v3.RBAC>`
    is properly extracted. This changes the Prometheus name from ``envoy_myprefixrbac_allowed{}`` to
    ``envoy_rbac_allowed{envoy_rbac_prefix="myprefix"}``.
- area: http2
  change: |
    Changes the default value of ``envoy.reloadable_features.http2_use_oghttp2`` to ``true``. This changes the codec used for HTTP/2
    requests and responses. This behavior can be reverted by setting the feature to ``false``.
- area: http2
  change: |
    Discard the ``Host`` header if the ``:authority`` header was received to bring Envoy into compliance with
    https://www.rfc-editor.org/rfc/rfc9113#section-8.3.1 This behavioral change can be reverted by setting runtime flag
    ``envoy.reloadable_features.http2_discard_host_header`` to ``false``.
- area: grpc reverse bridge
  change: |
    Handle empty response bodies in ``grpc_http1_reverse_bridge``. This may cause problems for clients expecting the filter to crash
    for empty responses.  This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.grpc_http1_reverse_bridge_handle_empty_response`` to ``false``.
- area: access_log
  change: |
    Added issuer in certificate_properties to the gRPC access log service(AlS).

minor_behavior_changes:
- area: golang
  change: |
    Remove ``Protocol`` method from ``RequestHeaderMap``.
    To get the protocol, please use ``GetProperty("request.protocol")`` instead.
- area: aws
  change: |
    Added support to use HTTP async client to fetch the credentials from EC2 instance metadata and ECS task metadata providers
    instead of libcurl which is deprecated. By default this behavior is disabled. To enable set
    ``envoy.reloadable_features.use_http_client_to_fetch_aws_credentials`` to ``true``.
- area: local_rate_limit
  change: |
    Added new configuration field :ref:`rate_limited_as_resource_exhausted
    <envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.rate_limited_as_resource_exhausted>`
    to allow for setting if rate limit gRPC response should be ``RESOURCE_EXHAUSTED`` instead of the default ``UNAVAILABLE``.
- area: config parsing, http cache filter
  change: |
    Replaces Protobuf hashing by human-readable string with a dedicated deterministic hashing algorithm.
    The performance of the hash operation is improved by ``2-10x`` depending on the structure of the message,
    which is expected to reduce config update time or startup time by 10-25%. The new algorithm is also
    used for ``http_cache_filter`` hashing, which will effectively cause a one-time cache flush on update
    for users with a persistent cache. To enable this behavior set ``envoy.restart_features.use_fast_protobuf_hash`` to ``true``.
- area: http2
  change: |
    Flip the runtime guard ``envoy.reloadable_features.defer_processing_backedup_streams`` to be on by default.
    This feature improves flow control within the proxy by deferring work on the receiving end if the other
    end is backed up.
- area: admin
  change: |
    Switch no admin ``warning`` -> ``info``.
- area: generic_proxy
  change: |
    Update the stats prefix of generic proxy from ``<stats_prefix>`` to ``generic_proxy.<stats_prefix>``.
- area: header_mutation
  change: |
    If per route configuration is configured at multiple levels (route, virtual host, and route table), all specified
    levels' mutations are applied. Default order is from least to most specific level (i.e. most specific level wins).

bug_fixes:
- area: upstream
  change: |
    Fixed a bug with upstream auto-config with HTTP/3 where certain network configurations would result in zombie
    streams left in the grid. Guarded by ``envoy.reloadable_features.avoid_zombie_streams``.
- area: buffer
  change: |
    Fixed a bug (https://github.com/envoyproxy/envoy/issues/28760) that the internal listener causes an undefined
    behavior due to the unintended release of the buffer memory.
- area: xds
  change: |
    Fixed a bug (https://github.com/envoyproxy/envoy/issues/27702) that caused ADS initialization
    to fail on the first attempt and set a back-off retry interval of up to 1 second, if ADS is
    using an Envoy Cluster for the backend. The issue was fixed to ensure that ADS initialization
    happens after the Envoy Cluster it depends upon has been properly initialized. ADS that does
    not depend on an Envoy Cluster (i.e. GoogleGrpc) is not affected by this change.
- area: grpc
  change: |
    Fixed a bug in gRPC async client cache which intermittently causes CPU spikes due to busy loop in timer expiration.
- area: tracing
  change: |
    Fixed a bug that caused the Datadog tracing extension to drop traces that
    should be kept on account of an extracted sampling decision.
- area: quic
  change: |
    Fixed a bug in QUIC and HCM interaction which could cause ``use-after-free`` during asynchronous certificates retrieval.
    The fix is guarded by runtime ``envoy.reloadable_features.quic_fix_filter_manager_uaf``.
- area: quic
  change: |
    Fixed a bug in QUIC upstream port migration which could cause use-after-free upon STATELESS_RESET packets.
- area: redis
  change: |
    Fixed a bug causing crash if incoming redis key does not match against a ``prefix_route`` and ``catch_all_route`` is not defined.
- area: access log
  change: |
    Fixed a bug where the omit_empty_values field was not honored for access logs specifying formats via text_format_source.
- area: ext_proc
  change: |
    Fixed ``content_length`` related issues when body mutation by external processor is enabled. The ``ext_proc`` filter removes
    the content length header in 1)``STREAMED BodySendMode`` 2) ``BUFFERED_PARTIAL BodySendMode`` and
    3) ``BUFFERED BodySendMode + SKIP HeaderSendMode``. This will enable chunked-encoding whenever feasible in HTTP1.1. Besides,
    ``ext_proc`` filter keep content length header in ``BUFFERED BodySendMode + SEND HeaderSendMode``. It is now external
    processor's responsibility to set the content length correctly matched to the mutated body. if those two doesn't match,
    the mutation will be rejected and local reply with error status will be returned.
- area: dynamic_forward_proxy
  change: |
    Fixed a bug where the preresolved hostnames specified in the Dynamic Forward Proxy cluster
    config would not use the normalized hostname as the DNS cache key, which is the same key
    used for retrieval. This caused cache misses on initial use, even though the host DNS entry
    was pre-resolved. The fix is guarded by runtime guard ``envoy.reloadable_features.normalize_host_for_preresolve_dfp_dns``,
    which defaults to ``true``.
- area: otlp_stat_sink
  change: |
    Fixed a bug where histogram bucket counts were wrong. Additionally, the number of buckets is fixed and is now
    one element larger than the explicit bounds elements, as required by the specification.
- area: tracing
  change: |
    Fixed a bug where child spans produced by the Datadog tracer would have an incorrect operation name.
- area: tracing
  change: |
    Fixed a bug where Datadog spans tagged as errors would not have the appropriate error property set.
- area: DNS
  change: |
    Fixed a race condition that when multiple requests with the same authority header are sent to Envoy, sometimes some requests
    may receive ``503`` response with ``no_healthy_upstream`` from Envoy. The fix is guarded by runtime guard
    ``envoy.reloadable_features.dns_cache_set_first_resolve_complete``, which defaults to ``true``.
- area: upstream
  change: |
    Fixed a bug that the subset load balancer will always be used even if the subset load balancer config does not
    contain any subset selector.
- area: docker
  change: |
    Updated base image to ``ubuntu:22.04`` to fix Redis memory issue (https://github.com/envoyproxy/envoy/issues/31248).
- area: aws
  change: |
    Default credentials file location was relying on incorrect ``~`` expansion. This fix now resolves to the correct path
    by using ``HOME`` environment variable, if the credentials file location is not explicitly specified.
- area: ext_authz
  change: |
    Fixed a bug to ensure the proper functioning of the ``with_request_body`` feature within the per-route ExtAuthZ filter.
- area: oauth
  change: |
    Add :ref:`default_expires_in <envoy_v3_api_field_extensions.filters.http.oauth2.v3.OAuth2Config.default_expires_in>` configuration
    setting. The OAuth spec does not dictate that an authorization server must respond with an expiry. Envoy currently
    fails any OAuth flow if the expiry is not set. This setting allows you to provide a default in this case to ensure
    the OAuth flow can succeed.

removed_config_or_runtime:
- area: http
  change: |
    Removed ``envoy.reloadable_features.expand_agnostic_stream_lifetime`` and legacy code paths.
- area: http
  change: |
    Removed ``envoy.reloadable_features.sanitize_original_path`` and legacy code paths.
- area: maglev
  change: |
    Removed ``envoy.reloadable_features.allow_compact_maglev`` and legacy code paths.
- area: router
  change: |
    Removed the deprecated ``envoy.reloadable_features.prohibit_route_refresh_after_response_headers_sent``
    runtime flag and legacy code path.
- area: upstream
  change: |
    Removed the deprecated ``envoy.reloadable_features.validate_detailed_override_host_statuses``
    runtime flag and legacy code path.
- area: grpc
  change: |
    Removed the deprecated ``envoy.reloadable_features.service_sanitize_non_utf8_strings``
    runtime flag and legacy code path.
- area: access log
  change: |
    Removed the deprecated ``envoy.reloadable_features.format_ports_as_numbers``
    runtime flag and legacy code path.
- area: router
  change: |
    Removed the deprecated ``envoy.reloadable_features.ignore_optional_option_from_hcm_for_route_config``
    runtime flag and legacy code path.

new_features:
- area: composite filter
  change: |
    Added :ref:`ExtensionConfiguration discovery service<envoy_v3_api_file_envoy/service/extension/v3/config_discovery.proto>` support for
    :ref:`composite filter <config_http_filters_composite>`.
- area: filter state
  change: |
    Added config name of filter sending a local reply in filter state with key
    ``envoy.filters.network.http_connection_manager.local_reply_owner``.
    See :ref:`the well-known filter state keys <well_known_filter_state>` for more detail.
- area: composite filter
  change: |
    Added composite filter's matched action name to filter state with key
    ``envoy.extensions.filters.http.composite.matched_actions``.
- area: aws
  change: |
    Added support for AWS common utility to fetch metadata credentials from AWS STS by using ``WebIdentityToken``. To enable
    you need to set ``envoy.reloadable_features.use_http_client_to_fetch_aws_credentials`` to ``true`` so that web identity
    credentials provider can use http async client to fetch credentials. Web identity credentials provider cannot use current
    default libcurl credentials fetcher which is under deprecation and will soon be removed. Web identity credentials provider
    is not compatible with :ref:`Grpc Credentials AWS IAM <envoy_v3_api_file_envoy/config/grpc_credential/v3/aws_iam.proto>`
    plugin which can only support deprecated libcurl credentials fetcher, see https://github.com/envoyproxy/envoy/pull/30626.
- area: filters
  change: |
    Added :ref:`the Basic Auth filter <envoy_v3_api_msg_extensions.filters.http.basic_auth.v3.BasicAuth>`, which can be used to
    authenticate user credentials in the HTTP Authentication heaer defined in `RFC7617 <https://tools.ietf.org/html/rfc7617>`_.
- area: upstream
  change: |
    Implmented API :ref:`drop_overloads<envoy_v3_api_field_config.endpoint.v3.ClusterLoadAssignment.Policy.drop_overloads>`
    which can be used to drop certain percentage of traffic from Envoy.
- area: stats
  change: |
    Added :ref:`per_endpoint_stats <envoy_v3_api_field_config.cluster.v3.TrackClusterStats.per_endpoint_stats>` to get some metrics
    for each endpoint in a cluster.
- area: jwt
  change: |
    The JWT filter can now serialize non-primitive custom claims when maping claims to headers.
    These claims will be serialized as JSON and encoded as Base64.
- area: jwt
  change: |
    The JWT authentication filter supports changing the routes when either the headers or the
    dynamic metadata are modified.
- area: tcp_proxy
  change: |
    Added support to TCP Proxy for recording the latency in ``UpstreamTiming`` from when the first
    initial connection to the upstream cluster was attempted to when either the
    connection was successfully established or the filiter failed to initialize
    any connection to the upstream.
- area: ratelimit
  change: |
    Ratelimit supports setting the HTTP status that is returned to the client when the ratelimit server
    returns an error or cannot be reached with :ref:`status_on_error
    <envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimit.status_on_error>`
    configuration flag.
- area: tracing
  change: |
    Added support for configuring resource detectors on the OpenTelemetry tracer.
- area: tracing
  change: |
    Added support to configure a sampler for the OpenTelemetry tracer.
- area: CEL-attributes
  change: |
    Added :ref:`attribute <arch_overview_attributes>` ``connection.transport_failure_reason``
    for looking up connection transport failure reason.
- area: ext_authz
  change: |
    New config parameter :ref:`charge_cluster_response_stats
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.charge_cluster_response_stats>`
    for not incrementing cluster statistics on ext_authz response. Default ``true``, no behavior change.
- area: ext_authz
  change: |
    Forward :ref:`filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.filter_metadata>` selected by
    :ref:`route_metadata_context_namespaces
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.route_metadata_context_namespaces>`
    and :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>` selected by
    :ref:`route_typed_metadata_context_namespaces
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.route_typed_metadata_context_namespaces>`
    from the metadata of the selected route to external auth service.
    This metadata propagation is independent from the dynamic metadata from connection and request.
- area: ext_authz_filter
  change: |
    Added :ref:`with_request_body
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.CheckSettings.with_request_body>` to optionally override
    the default behavior of sending the request body to the authorization server from the per-route filter.
- area: grpc async client
  change: |
    Added :ref:`max_cached_entry_idle_duration
    <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.GrpcAsyncClientManagerConfig.max_cached_entry_idle_duration>`
    to control the cached gRPC client eviction time in the cache.
- area: ratelimit
  change: |
    Ratelimit supports optional additional prefix to use when emitting statistics with :ref:`stat_prefix
    <envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimit.stat_prefix>`
    configuration flag.
- area: udp_proxy
  change: |
    Added support for propagating the response headers in :ref:`UdpTunnelingConfig
    <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.propagate_response_headers>` and
    response trailers in :ref:`UdpTunnelingConfig
    <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.UdpTunnelingConfig.propagate_response_trailers>` to
    the downstream info filter state.
- area: tracing
  change: |
    Provide initial span attributes to a sampler used in the OpenTelemetry tracer.
- area: tracing
  change: |
    Added support to configure a Dynatrace resource detector for the OpenTelemetry tracer.
- area: compression
  change: |
    Added qatzip :ref:`compressor <envoy_v3_api_msg_extensions.compression.qatzip.compressor.v3alpha.Qatzip>`.
- area: udp_proxy
  change: |
    Add :ref:`access log options
    <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.access_log_options>`
    to allow recording an access log entry periodically for the UDP session, and allow recording an access
    log entry on the connection tunnel created successfully to upstream when UDP tunneling is configured.
- area: internal_redirects
  change: |
    Added support to copy headers from the redirect response to the
    triggered request. See
    :ref:`response_headers_to_copy<envoy_v3_api_field_config.route.v3.InternalRedirectPolicy.response_headers_to_copy>`.
- area: stateful_session
  change: |
    Added :ref:`strict mode <envoy_v3_api_field_extensions.filters.http.stateful_session.v3.StatefulSession.strict>`
    to cookie and header based stateful session. If a destination encoded in :ref:`cookie
    <envoy_v3_api_msg_extensions.http.stateful_session.cookie.v3.CookieBasedSessionState>`
    or in :ref:`specified header
    <envoy_v3_api_field_extensions.http.stateful_session.header.v3.HeaderBasedSessionState.name>` respectively
    is not available, Envoy will return ``503`` instead of selecting another destination from the cluster.
- area: stream info
  change: |
    Added time spent reading request headers to ``DownstreamTiming``.
- area: redis
  change: |
    Added support for the watch command (aborts multi transactions if watched keys change).
- area: grpc_http_bridge
  change: |
    Added :ref:`ignore_query_parameters
    <envoy_v3_api_field_extensions.filters.http.grpc_http1_bridge.v3.Config.ignore_query_parameters>` option for
    automatically stripping query parameters in request URL path.
- area: access_log
  change: |
    Added new access log command operator ``%EMIT_TIME%`` to get the time when the log entry is emitted.
- area: aws_request_signing
  change: |
    Added support for specifying the aws signing algorithm, either ``AWS_SIGV4`` or ``AWS_SIGV4A`` via
    :ref:`signing_algorithm <envoy_v3_api_field_extensions.filters.http.aws_request_signing.v3.AwsRequestSigning.signing_algorithm>`
    config API.
- area: access_log
  change: |
    Added support for listener metadata in ``%METADATA%`` formatter.
- area: attributes
  change: |
    Added support for listener metadata and listener direction in xDS attributes.
- area: attributes
  change: |
    Added support for node data in ``%CEL%`` formatter.
- area: set_metadata
  change: |
    Added support for injecting typed and untyped dynamic metadata with this filter, also adds the ability
    to add multiple namespaces with one filter and config to overwrite existing metadata is opt-in.
    :ref:`untyped_metadata <envoy_v3_api_field_extensions.filters.http.set_metadata.v3.Config.metadata>`
    may now be used to configure the ``set_metadata`` filter.
- area: lua
  change: |
    Added Lua extension of router cluster specifier plugin to support selecting cluster dynamically by Lua code.
- area: redis
  change: |
    Added support for the ``getdel`` command.
- area: access_log
  change: |
    Added support for ``%CONNECTION_ID%`` command operator for UDP session access log.
- area: zookeeper
  change: |
    Added support for emitting per opcode decoder error metrics via :ref:`enable_per_opcode_decoder_error_metrics
    <envoy_v3_api_field_extensions.filters.network.zookeeper_proxy.v3.ZooKeeperProxy.enable_per_opcode_decoder_error_metrics>`.
- area: rbac filter
  change: |
    allow listed ``HttpAttributesCelMatchInput`` to be used with the xDS matcher in the RBAC filter.

deprecated:
- area: wasm
  change: |
    Wasm-specific configuration attributes are deprecated in favor of ``xds`` attributes.
- area: set_metadata
  change: |
    :ref:`metadata_namespace <envoy_v3_api_field_extensions.filters.http.set_metadata.v3.Config.metadata_namespace>`
    and :ref:`value <envoy_v3_api_field_extensions.filters.http.set_metadata.v3.Config.value>`
    are deprecated. Please use the new field
    :ref:`untyped_metadata <envoy_v3_api_field_extensions.filters.http.set_metadata.v3.Config.metadata>`
    to configure static metadata to inject.
date: March 23, 2023

bug_fixes:
- area: dependency
  change: |
    update Wasmtime -> 6.0.1, to resolve CVE-2023-26489, CVE-2023-27477.
date: August 13, 2019

changes:
- area: http
  change: |
    added mitigation of client initiated attacks that result in flooding of the downstream HTTP/2 connections. Those attacks
    can be logged at the "warning" level when the runtime feature ``http.connection_manager.log_flood_exception`` is
    enabled. The runtime setting defaults to disabled to avoid log spam when under attack.
- area: http
  change: |
    added :ref:`inbound_empty_frames_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats,
    for tracking number of connections terminated for exceeding the limit on consecutive inbound frames with an empty
    payload and no end stream flag. The limit is configured by setting the
    :ref:`max_consecutive_inbound_frames_with_empty_payload config setting
    <envoy_api_field_core.Http2ProtocolOptions.max_consecutive_inbound_frames_with_empty_payload>`. Runtime feature
    ``envoy.reloadable_features.http2_protocol_options.max_consecutive_inbound_frames_with_empty_payload`` overrides
    :ref:`max_consecutive_inbound_frames_with_empty_payload setting
    <envoy_api_field_core.Http2ProtocolOptions.max_consecutive_inbound_frames_with_empty_payload>`. Large override value
    (i.e. 2147483647) effectively disables mitigation of inbound frames with empty payload.
- area: http
  change: |
    added :ref:`inbound_priority_frames_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec
    stats, for tracking number of connections terminated for exceeding the limit on inbound PRIORITY frames. The limit is
    configured by setting the :ref:`max_inbound_priority_frames_per_stream config setting
    <envoy_api_field_core.Http2ProtocolOptions.max_inbound_priority_frames_per_stream>`. Runtime feature
    ``envoy.reloadable_features.http2_protocol_options.max_inbound_priority_frames_per_stream`` overrides
    :ref:`max_inbound_priority_frames_per_stream setting
    <envoy_api_field_core.Http2ProtocolOptions.max_inbound_priority_frames_per_stream>`. Large override value effectively
    disables flood mitigation of inbound PRIORITY frames.
- area: http
  change: |
    added :ref:`inbound_window_update_frames_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec
    stats, for tracking number of connections terminated for exceeding the limit on inbound WINDOW_UPDATE frames. The limit
    is configured by setting the :ref:`max_inbound_window_update_frames_per_data_frame_sent config setting
    <envoy_api_field_core.Http2ProtocolOptions.max_inbound_window_update_frames_per_data_frame_sent>`. Runtime feature
    ``envoy.reloadable_features.http2_protocol_options.max_inbound_window_update_frames_per_data_frame_sent`` overrides
    :ref:`max_inbound_window_update_frames_per_data_frame_sent setting
    <envoy_api_field_core.Http2ProtocolOptions.max_inbound_window_update_frames_per_data_frame_sent>`. Large override value
    effectively disables flood mitigation of inbound WINDOW_UPDATE frames.
- area: http
  change: |
    added :ref:`outbound_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for tracking
    number of connections terminated for exceeding the outbound queue limit. The limit is configured by setting the
    :ref:`max_outbound_frames config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_frames>` Runtime
    feature ``envoy.reloadable_features.http2_protocol_options.max_outbound_frames`` overrides :ref:`max_outbound_frames
    config setting <envoy_api_field_core.Http2ProtocolOptions.max_outbound_frames>`. Large override value effectively
    disables flood mitigation of outbound frames of all types.
- area: http
  change: |
    added :ref:`outbound_control_flood <config_http_conn_man_stats_per_codec>` counter stat to the HTTP/2 codec stats, for
    tracking number of connections terminated for exceeding the outbound queue limit for ``PING``, ``SETTINGS`` and
    ``RST_STREAM`` frames. The limit is configured by setting the :ref:`max_outbound_control_frames config setting
    <envoy_api_field_core.Http2ProtocolOptions.max_outbound_control_frames>`. Runtime feature
    ``envoy.reloadable_features.http2_protocol_options.max_outbound_control_frames`` overrides
    :ref:`max_outbound_control_frames config setting
    <envoy_api_field_core.Http2ProtocolOptions.max_outbound_control_frames>`. Large override value effectively disables
    flood mitigation of outbound frames of types ``PING``, ``SETTINGS`` and ``RST_STREAM``.
- area: http
  change: |
    enabled strict validation of HTTP/2 messaging. Previous behavior can be restored using
    :ref:`stream_error_on_invalid_http_messaging config setting
    <envoy_api_field_core.Http2ProtocolOptions.stream_error_on_invalid_http_messaging>`. Runtime feature
    ``envoy.reloadable_features.http2_protocol_options.stream_error_on_invalid_http_messaging`` overrides
    :ref:`stream_error_on_invalid_http_messaging config setting
    <envoy_api_field_core.Http2ProtocolOptions.stream_error_on_invalid_http_messaging>`.
date: April 15, 2021

bug_fixes:
- area: code
  change: |
    fixed more build issues on our path to a glorious release.
date: June 8, 2020

changes:
- area: http
  change: |
    fixed CVE-2020-11080 by rejecting HTTP/2 SETTINGS frames with too many parameters.
- area: http
  change: |
    the :ref:`stream_idle_timeout
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>` now also
    defends against an HTTP/2 peer that does not open stream window once an entire response has been buffered to be sent to
    a downstream client.
- area: listener
  change: |
    Add runtime support for :ref:`per-listener limits <config_listeners>` on active/accepted connections.
- area: overload management
  change: |
    Add runtime support for :ref:`global limits <config_overload_manager>` on active/accepted connections.
date: January 18, 2023

behavior_changes:
- area: listener
  change: |
    Previously a listener update with different :ref:`transparent
    <envoy_v3_api_field_config.listener.v3.Listener.transparent>`, :ref:`freebind
    <envoy_v3_api_field_config.listener.v3.Listener.freebind>`, :ref:`tcp_fast_open_queue_length
    <envoy_v3_api_field_config.listener.v3.Listener.tcp_fast_open_queue_length>` or :ref:`socket_options
    <envoy_v3_api_field_config.listener.v3.Listener.socket_options>` was ignored. Now, when those fields are updated, a new
    socket will be created for the listener and the updated values of those fields will be applied to it. This only happens
    when :ref:`enable_reuse_port <envoy_v3_api_field_config.listener.v3.Listener.enable_reuse_port>` is true. Otherwise if
    those fields change the update is rejected. The runtime flag
    ``envoy.reloadable_features.enable_update_listener_socket_options`` can be used to revert this behavior.
- area: build
  change: |
    removed the c-ares and apple resolvers as required extensions. Envoy now only creates DNS resolvers when necessary (e.g.
    for logical DNS cluster); as such, it does not require these resolvers to always be included. If your Envoys do DNS
    resolution and override ``extensions_build_config.bzl`` you will need to include c-ares / apple resolver explicitly.
- area: build
  change: |
    moved the ``strict_dns``, ``original_dst``, ``logical_dns``, ``static``, and ``eds`` clusters to extensions. If you use
    these clusters and override ``extensions_build_config.bzl`` you will now need to include it explicitly.
- area: stats http ext_authz
  change: |
    Fixed ``ext_authz`` metric tag extraction so that :ref:`stat_prefix
    <envoy_v3_api_msg_extensions.filters.http.ext_authz.v3.ExtAuthz>` is properly extracted. This changes the Prometheus
    name from ``envoy_http_ext_authz_prefixval_denied{}`` to
    ``envoy_http_ext_authz_denied{envoy_ext_authz_prefix="prefixval"}``. ``envoy_cluster_X_ext_authz_Y_denied`` follows the
    same pattern.
- area: loadbalancing
  change: |
    When active health checking is enabled per cluster, slow start calculations will now start after first passing health
    check. The cluster membership duration condition is dropped from the slow start calculation. Endpoints can now re-enter
    slow start if active health checking is configured per cluster, on each ``unhealthy`` -> ``healthy`` state transition.

minor_behavior_changes:
- area: tls
  change: |
    added support for intermediate CA as trusted CA. The peer certificate issued by an intermediate CA will be trusted by
    building valid partial chain. Before, it could not be verified without trusting its ancestor root CA and building a full
    chain. :ref:`trust_ca <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`.
    This change can be reverted via the runtime flag ``envoy.reloadable_features.enable_intermediate_ca``.
- area: cache_filter
  change: |
    add a completion callback to ``updateHeaders`` interface. Any external cache implementations should be updated to match
    this new interface. See changes to simple_http_cache in `PR \#23666 <https://github.com/envoyproxy/envoy/pull/23666>`_
    for example.
- area: cache_filter
  change: |
    api path of work-in-progress extension changed from ``api/extensions/cache/simple_http_cache`` to
    ``api/extensions/http/cache/simple_http_cache``, and source code moved to match extension category.
- area: http filter
  change: |
    Avoid re-entrant filter invocations if we do a local reply via the filter chain when executing decoder filters. This
    behavioral change can be temporarily reverted by setting runtime flag
    ``envoy_reloadable_features_http_filter_avoid_reentrant_local_reply`` to false.
- area: http filters
  change: |
    change ``StreamEncoderFilter::encode1xxHeaders`` to use its own enum class ``Http::Filter1xxHeadersStatus``. Previously
    we shared the same enum class for general headers, but the implementation did not support most of them. We also fixed
    ``StreamEncoderFilter::encode1xxHeaders`` to send local replies without trailing 1xx headers afterward.
- area: oauth2
  change: |
    Requests which match the passthrough header now have their own metric ``oauth_passthrough`` and aren't included in
    ``oauth_success`` anymore.
- area: oauth2
  change: |
    query parameters in the :ref:`authorization_endpoint
    <envoy_v3_api_field_extensions.filters.http.oauth2.v3.OAuth2Config.authorization_endpoint>` are now preserved.
- area: upstream
  change: |
    detailed health status is used for override host selection. This behavior can be reverted by setting runtime flag
    ``envoy.reloadable_features.validate_detailed_override_host_statuses`` to false.
- area: rate_limit
  change: |
    add ``MONTH`` and ``YEAR`` to the unit of time for rate limit.
- area: router
  change: |
    Virtual cluster statistics are no longer created for routes without any ``virtual_clusters``. Previously statistics for
    a ``catch all`` virtual cluster were created, but never updated.
- area: jwt_authn
  change: |
    adjust the refetch time for ``remote_jwks`` ``async_fetch`` feature. For a good fetch, refetch 5 seconds before jwks
    cache duration. For a failed fetch, refetch time can be specified by :ref:`failed_refetch_duration
    <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwksAsyncFetch.failed_refetch_duration>` with default 1 second.
- area: config
  change: |
    add support for thrift connection draining. This can be disabled by setting the runtime guard
    ``envoy.reloadable_features.thrift_connection_draining`` to false.
- area: http
  change: |
    reverted the behavioral change to have ``CONNECT`` and upgrade requests over HTTP/1.1 not delay close.  One can
    reinstate delay close for upgrades by setting ``envoy.reloadable_features.no_delay_close_for_upgrades`` to ``true``.
- area: tcp
  change: |
    added :ref:`idle_timeout <envoy_v3_api_field_extensions.upstreams.tcp.v3.TcpProtocolOptions.idle_timeout>` to support
    per client idle timeout for tcp connection pool. The timeout is guarded by
    ``envoy.reloadable_features.tcp_pool_idle_timeout`` and timeout defaults to 10 minutes if runtime flag is enabled.

bug_fixes:
- area: aws_lambda
  change: |
    fix a bug when :ref:`PerRouteConfig <envoy_v3_api_msg_extensions.filters.http.aws_lambda.v3.PerRouteConfig>` is defined
    and was routing to a target cluster's AWS Lambda endpoint in a region that is different from the region obtained in
    :ref:`arn <envoy_v3_api_field_extensions.filters.http.aws_lambda.v3.Config.arn>` of ``aws_lambda`` ``http_filter``
    configuration then the authorization header included in the request towards AWS Lambda was not signed with the region
    specified in ``PerRouteConfig``.
- area: grpc_json_transcoder
  change: |
    fix a bug when using http2, request body has ``google.api.HttpBody`` and the size is < 16KB, it will cause EOF from the
    backend grpc server.
- area: router
  change: |
    fixed a bug that incorrectly rewrote the path when using ``regex_rewrite`` for redirects matched on prefix.
- area: oauth2
  change: |
    fixed a bug when passthrough header was matched, envoy would always remove the authorization header. This behavioral
    change can be temporarily reverted by setting runtime guard ``envoy.reloadable_features.oauth_header_passthrough_fix``
    to false.
- area: generic_proxy
  change: |
    fixed a bug that encoder filters and decoder filters of generic proxy will be executed in the same order. The encoder
    filters' execuate order should be the reverse of decoder filters' in the generic proxy.
- area: quic
  change: |
    reject configs that specify require_client_certificate with QUIC since clients certificates are currently unsupported in
    QUIC. This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.reject_require_client_certificate_with_quic`` to false.
- area: http
  change: |
    fixed a bug where ``Utility::PercentEncoding::encode()`` encodes some characters incorrectly because it was treating the
    value as negative.
- area: upstream
  change: |
    fixed a bug that only coarse health status is used for override host selection.
- area: validation
  change: |
    fixed a crash that could happen when optional ``engine_type`` is not provided in regex.
- area: upstream
  change: |
    fixed a bug when specify both a single address in bootstrap and cluster upstream binding config but with a different IP
    version. It should be allowed but it is rejected.
- area: upstream
  change: |
    fixed a bug for tcp upstream where we did not count the header and data to/from the upstream.
- area: jwt_authn
  change: |
    fix a bug that ``jwt_cache`` breaks the :ref:`provider_and_audiences
    <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtRequirement.provider_and_audiences>` JWT requirement.
- area: skywalking
  change: |
    fixed a crash that could happen when skywalking tracer is enabled and illegal ``sw8`` header is received.
- area: health_checker
  change: |
    prevent writing pending data for health checkers by introducing ``ConnectionCloseType::Abort`` to avoid cascading
    handshake overhead from health checker's requests on timeout. This fix is related to `issue \#23718
    <https://github.com/envoyproxy/envoy/issues/23718>`_.
- area: router
  change: |
    fixed a bug that truncated query parameters from paths rewritten with a ``path_rewrite_policy``, query parameters are
    now appended. ``envoy_reloadable_features_append_query_parameters_path_rewriter`` can be used to revert to truncation.
- area: grpc_http_bridge
  change: |
    fixed a bug where response data could be lost for requests that were upgraded from Protobuf.
- area: tcp_proxy
  change: |
    When tunneling TCP over HTTP, mark the upstream connection as done reading when upstream trailers are read. This
    behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.finish_reading_on_decode_trailers`` to false.

removed_config_or_runtime:
- area: eds
  change: |
    removed ``envoy.reloadable_features.support_locality_update_on_eds_cluster_endpoints`` and legacy code paths.
- area: listener
  change: |
    removed ``envoy.reloadable_features.strict_check_on_ipv4_compat`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.deprecate_global_ints`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.allow_adding_content_type_in_local_replies`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.allow_upstream_inline_write`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.append_or_truncate`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.use_new_codec_wrapper`` and legacy code paths. removed
    ``envoy.reloadable_features.append_to_accept_content_encoding_only_once`` and legacy code paths. removed
    ``envoy.reloadable_features.http1_lazy_read_disable`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.http_100_continue_case_insensitive`` and legacy code paths. removed
    ``envoy.reloadable_features.override_request_timeout_by_gateway_timeout`` and legacy code paths.
- area: ecds
  change: |
    removed ``envoy.reloadable_features.top_level_ecds_stats`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.skip_delay_close`` and legacy code paths.
- area: router
  change: |
    removed ``envoy.reloadable_features.do_not_await_headers_on_upstream_timeout_to_emit_stats`` and legacy code paths.

new_features:
- area: aws
  change: |
    added support to prefer fetching AWS instance role credentials securely (`IMDSv2
    <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html>`_) from EC2 instance
    metadata by getting the token first or falling back to insecure way (IMDSv1) if token fetch fails.
- area: grpc_json_transcoder
  change: |
    added ``max_request_body_size`` and ``max_response_body_size`` fields, which can either increase or decrease the size of
    messages that can be processed. It can increase (but does not decrease) the stream buffer size, and can reject messages
    even if they're smaller than the stream buffer size if configured smaller.
- area: tls
  change: |
    added support for SNI-based cert selection in tls downstream transport socket. Detailed documentation is available
    :ref:`cert selection<arch_overview_ssl_cert_select>`. New config option :ref:`full_scan_certs_on_sni_mismatch
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.full_scan_certs_on_sni_mismatch>` is
    introduced to disable or enable full scan when no cert matches to SNI, defaults to false. New runtime flag
    ``envoy.reloadable_features.no_full_scan_certs_on_sni_mismatch`` can be used for override the default value.
- area: build
  change: |
    added an option ``--define=library_autolink=disabled`` to disable autolinking libraries.
- area: compression
  change: |
    added :ref:`CompressorPerRoute proto <envoy_v3_api_msg_extensions.filters.http.compressor.v3.CompressorPerRoute>` for
    per-route configuration.
- area: generic_proxy
  change: |
    added :ref:`dubbo codec support
    <envoy_v3_api_msg_extensions.filters.network.generic_proxy.codecs.dubbo.v3.DubboCodecConfig>` to the :ref:`generic_proxy
    filter <envoy_v3_api_msg_extensions.filters.network.generic_proxy.v3.GenericProxy>`.
- area: golang
  change: |
    added new :ref:`HTTP golang extension filter <config_http_filters_golang>`.
- area: custom response http filter
  change: |
    added :ref:`custom response http filter <config_http_filters_custom_response>` which adds the ability to customize
    responses sent to downstreams using local or remote sources.
- area: upstream
  change: |
    added a new field :ref:`socket_options <envoy_v3_api_field_config.core.v3.ExtraSourceAddress.socket_options>` to the
    ``ExtraSourceAddress``, allowing specifying discrete socket options for each source address.
- area: access_log
  change: |
    added a new field :ref:`intermediate_log_entry
    <envoy_v3_api_field_data.accesslog.v3.AccessLogCommon.intermediate_log_entry>` to detect if the gRPC log entry is an
    intermediate log entry or not and added support to flush TCP log entries periodly according to the configured
    :ref:`inteval <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.access_log_flush_interval>`.
- area: access_log
  change: |
    added support for :ref:`%STREAM_ID% <config_access_log_format_stream_id>` for stream unique identifier.
- area: thrift
  change: |
    added payload to metadata filter which matches a given payload field's value would be extracted and attached to the
    request as dynamic metadata.
- area: http
  change: |
    enhanced dynamic forward proxy cluster to :ref:`allow_coalesced_connections
    <envoy_v3_api_field_extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig.allow_coalesced_connections>` for HTTP/2
    and HTTP/3 connections.
- area: upstream
  change: |
    added :ref:`least request extension <envoy_v3_api_msg_extensions.load_balancing_policies.least_request.v3.LeastRequest>`
    to suppport the :ref:`load balancer policy <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>`.
- area: upstream
  change: |
    added :ref:`random extension <envoy_v3_api_msg_extensions.load_balancing_policies.random.v3.Random>` to suppport the
    :ref:`load balancer policy <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>`.
- area: upstream
  change: |
    added :ref:`round robin extension <envoy_v3_api_msg_extensions.load_balancing_policies.round_robin.v3.RoundRobin>` to
    suppport the :ref:`load balancer policy <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>`.
- area: generic_proxy
  change: |
    added :ref:`generic rds support
    <envoy_v3_api_field_extensions.filters.network.generic_proxy.v3.GenericProxy.generic_rds>`.
- area: listener
  change: |
    added a new field :ref:`socket_options <envoy_v3_api_field_config.listener.v3.AdditionalAddress.socket_options>` to the
    ``AdditionalAddress``, allowing specifying discrete socket options for each listener address.
- area: listener
  change: |
    added ``continueFilterChain()`` and ``dispatcher()`` methods to the ``ListenerFilterCallback``. This allows listener
    filters to continue listener filter iteration after stopping iteration e.g. if the listener filter depends on an async
    process.
- area: thrift_proxy
  change: |
    added ``envoy.reloadable_features.thrift_allow_negative_field_ids`` to support negative field ids for legacy thrift
    service.
- area: bandwidth_limit
  change: |
    added two new response trailers ``bandwidth-request-filter-delay-ms`` and ``bandwidth-response-filter-delay-ms`` to
    measure the delays added by this filter.
- area: udp_proxy
  change: |
    added support for :ref:`proxy_access_log
    <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.proxy_access_log>`.
- area: tcp_proxy
  change: |
    added new config :ref:`post_path field
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.post_path>` to specifiy a custom
    path for HTTP tunneling with POST method.
- area: health_check
  change: |
    added an optional bool flag :ref:`disable_active_health_check
    <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.disable_active_health_check>` to disable the active
    health check for the endpoint.
- area: mobile
  change: |
    merged the Envoy mobile library into the main Envoy repo.
- area: matching
  change: |
    support filter chain selection based on the dynamic metadata and the filter state using :ref:`formatter actions
    <extension_envoy.matching.actions.format_string>`.
- area: postgres
  change: |
    added support for upstream SSL.
- area: redis
  change: |
    extended :ref:`cluster support <arch_overview_redis_cluster_support>` by adding a :ref:`dns_cache_config
    <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings.dns_cache_config>` option that
    can be used to resolve hostnames returned by ``MOVED``/``ASK`` responses.
- area: gcp_authn
  change: |
    added support for configuring header that holds token fetched from GCE metadata server in new field :ref:`token_header
    <envoy_v3_api_field_extensions.filters.http.gcp_authn.v3.GcpAuthnFilterConfig.token_header>`.
- area: tracing
  change: |
    added support for setting the hostname used when sending spans to a Datadog collector using the :ref:`collector_hostname
    <envoy_v3_api_field_config.trace.v3.DatadogConfig.collector_hostname>` field.
- area: stats
  change: |
    added ``includeHistogram()`` method to ``Stats::SinkPredicates`` to filter histograms to be flushed to stat sinks. Use
    ``envoy.reloadable_features.enable_include_histograms`` to enable this feature, which is disabled by default.
- area: http
  change: |
    added support of :ref:`header mutation
    <envoy_v3_api_msg_extensions.http.early_header_mutation.header_mutation.v3.HeaderMutation>` to the HTTP connection
    manager via :ref:`early header mutation
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.early_header_mutation_extensions>`
    field.
- area: jwt_authn
  change: |
    added support for copying jwt claims to http headers.
- area: generic_proxy
  change: |
    added drain support to generic proxy to doing graceful closes on connections when possible.
- area: http
  change: |
    added :ref:`append_x_forwarded_port
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.append_x_forwarded_port>`
    to append the ``x-forwarded-port`` header to HTTP upstream requests.
- area: tcp
  change: |
    added :ref:`idle_timeout <envoy_v3_api_field_extensions.upstreams.tcp.v3.TcpProtocolOptions.idle_timeout>` to support
    per client idle timeout for tcp connection pool. See also `minor behaviour changes <#minor-behavior-changes>`__.
- area: ext_authz
  change: |
    added support to allowlist headers included in the check request to gRPC authorization server (previously only available
    for HTTP authorization server). Pre-existing field :ref:`allowed_headers
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationRequest.allowed_headers>` is deprecated in favour
    of the new field :ref:`allowed_headers
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.allowed_headers>`.
- area: attributes
  change: |
    added :ref:`attributes <arch_overview_attributes>` for looking up xDS configuration information.
- area: router
  change: |
    added :ref:`RouteList <envoy_v3_api_msg_config.route.v3.RouteList>` to support route list in :ref:`VirtualHost.matcher
    <envoy_v3_api_field_config.route.v3.VirtualHost.matcher>`.
- area: router
  change: |
    added a :ref:`x-envoy-is-timeout-retry <config_http_filters_router_x-envoy-is-timeout-retry>` request header on retries
    initiated by request timeouts; enabled by setting :ref:`include_is_timeout_retry_header
    <envoy_v3_api_field_config.route.v3.VirtualHost.include_is_timeout_retry_header>` to ``true``.
- area: upstream
  change: |
    allow configuring :ref:`cluster bind config <envoy_v3_api_field_config.cluster.v3.Cluster.upstream_bind_config>` and
    :ref:`cluster manager bind config <envoy_v3_api_field_config.bootstrap.v3.ClusterManager.upstream_bind_config>` without
    specifying a :ref:`source_address <envoy_v3_api_field_config.core.v3.BindConfig.source_address>`. This allows setting
    :ref:`socket options <envoy_v3_api_field_config.core.v3.BindConfig.socket_options>` when using the default unspecified
    bind address is desired.
- area: xds
  change: |
    added an api configuration :ref:`xds_config_tracker_extension
    <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.xds_config_tracker_extension>` in the bootstrap to allow tracking xDS
    responses in external components, and provided the extension interface.
- area: build
  change: |
    added compile-time option ``--define=static_extension_registration=disabled`` to disable the automatic static
    registration of extension factories.
date: June 2, 2023

bug_fixes:
- area: boringssl
  change: |
    Fixed the crash that occurs when contrib is compiled with ``boringssl=fips`` defined.
- area: dependency
  change: |
    update Wasmtime and related deps -> 9.0.3 to resolve
    `CVE-2023-30624 <https://nvd.nist.gov/vuln/detail/CVE-2023-30624>`_.
- area: dependency
  change: |
    update C-ares -> 1.91.1 to resolve:

    - `CVE-2023-31130 <https://nvd.nist.gov/vuln/detail/CVE-2023-31130>`_.
    - `CVE-2023-31147 <https://nvd.nist.gov/vuln/detail/CVE-2023-31147>`_.
    - `CVE-2023-31124 <https://nvd.nist.gov/vuln/detail/CVE-2023-31124>`_.
    - `CVE-2023-32067 <https://nvd.nist.gov/vuln/detail/CVE-2023-32067>`_.
date: October 4, 2018

changes:
- area: access log
  change: |
    added :ref:`response flag filter <envoy_api_msg_config.filter.accesslog.v2.ResponseFlagFilter>` to filter based on the
    presence of Envoy response flags.
- area: access log
  change: |
    added ``RESPONSE_DURATION`` and ``RESPONSE_TX_DURATION``.
- area: access log
  change: |
    added ``REQUESTED_SERVER_NAME`` for SNI to tcp_proxy and http.
- area: admin
  change: |
    added :http:get:`/hystrix_event_stream` as an endpoint for monitoring envoy's statistics through `Hystrix dashboard
    <https://github.com/Netflix-Skunkworks/hystrix-dashboard/wiki>`_.
- area: cli
  change: |
    added support for :ref:`component log level <operations_cli>` command line option for configuring log levels of
    individual components.
- area: cluster
  change: |
    added :ref:`option <envoy_api_field_Cluster.CommonLbConfig.update_merge_window>` to merge health check/weight/metadata
    updates within the given duration.
- area: config
  change: |
    regex validation added to limit to a maximum of 1024 characters.
- area: config
  change: |
    v1 disabled by default. v1 support remains available until October via flipping ``--v2-config-only=false``.
- area: config
  change: |
    v1 disabled by default. v1 support remains available until October via deprecated flag ``--allow-deprecated-v1-api``.
- area: config
  change: |
    fixed stat inconsistency between xDS and ADS implementation. :ref:`update_failure <config_cluster_manager_cds>` stat is
    incremented in case of network failure and :ref:`update_rejected <config_cluster_manager_cds>` stat is incremented in
    case of schema/validation error.
- area: config
  change: |
    added a stat :ref:`connected_state <management_server_stats>` that indicates current connected state of Envoy with
    management server.
- area: ext_authz
  change: |
    added support for configuring additional :ref:`authorization headers
    <envoy_api_field_config.filter.http.ext_authz.v2alpha.httpservice.authorization_headers_to_add>` to be sent from Envoy
    to the authorization service.
- area: fault
  change: |
    added support for fractional percentages in :ref:`FaultDelay
    <envoy_api_field_config.filter.fault.v2.FaultDelay.percentage>` and in :ref:`FaultAbort
    <envoy_api_field_config.filter.http.fault.v2.FaultAbort.percentage>`.
- area: grpc-json
  change: |
    added support for building HTTP response from `google.api.HttpBody
    <https://github.com/googleapis/googleapis/blob/master/google/api/httpbody.proto>`_.
- area: health check
  change: |
    added support for :ref:`custom health check <envoy_api_field_core.HealthCheck.custom_health_check>`.
- area: health check
  change: |
    added support for :ref:`specifying jitter as a percentage <envoy_api_field_core.HealthCheck.interval_jitter_percent>`.
- area: health_check
  change: |
    added support for :ref:`health check event logging <arch_overview_health_check_logging>`.
- area: health_check
  change: |
    added :ref:`timestamp <envoy_api_field_data.core.v2alpha.HealthCheckEvent.timestamp>` to the :ref:`health check event
    <envoy_api_msg_data.core.v2alpha.HealthCheckEvent>` definition.
- area: health_check
  change: |
    added support for specifying :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>` to HTTP
    health checker requests.
- area: http
  change: |
    added support for a :ref:`per-stream idle timeout <envoy_api_field_route.RouteAction.idle_timeout>`. This applies at
    both :ref:`connection manager
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>` and
    :ref:`per-route granularity <envoy_api_field_route.RouteAction.idle_timeout>`. The timeout defaults to 5 minutes; if you
    have other timeouts (e.g. connection idle timeout, upstream response per-retry) that are longer than this in duration,
    you may want to consider setting a non-default per-stream idle timeout.
- area: http
  change: |
    added upstream_rq_completed counter for :ref:`total requests completed
    <config_cluster_manager_cluster_stats_dynamic_http>` to dynamic HTTP counters.
- area: http
  change: |
    added downstream_rq_completed counter for :ref:`total requests completed <config_http_conn_man_stats>`, including on a
    :ref:`per-listener basis <config_http_conn_man_stats_per_listener>`.
- area: http
  change: |
    added generic :ref:`Upgrade support
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.upgrade_configs>`.
- area: http
  change: |
    better handling of HEAD requests. Now sending transfer-encoding: chunked rather than content-length: 0.
- area: http
  change: |
    fixed missing support for appending to predefined inline headers, e.g. ``authorization``, in features that interact with
    request and response headers, e.g. :ref:`request_headers_to_add <envoy_api_field_route.Route.request_headers_to_add>`.
    For example, a request header ``authorization: token1`` will appear as ``authorization: token1,token2``, after having
    :ref:`request_headers_to_add <envoy_api_field_route.Route.request_headers_to_add>` with ``authorization: token2``
    applied.
- area: http
  change: |
    response filters not applied to early error paths such as http_parser generated 400s.
- area: http
  change: |
    restrictions added to reject ``:``-prefixed pseudo-headers in :ref:`custom request headers
    <config_http_conn_man_headers_custom_request_headers>`.
- area: http
  change: |
    :ref:`hpack_table_size <envoy_api_field_core.Http2ProtocolOptions.hpack_table_size>` now controls dynamic table size of
    both: encoder and decoder.
- area: http
  change: |
    added support for removing request headers using :ref:`request_headers_to_remove
    <envoy_api_field_route.Route.request_headers_to_remove>`.
- area: http
  change: |
    added support for a :ref:`delayed close timeout
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.delayed_close_timeout>` to
    mitigate race conditions when closing connections to downstream HTTP clients. The timeout defaults to 1 second.
- area: jwt-authn filter
  change: |
    add support for per route JWT requirements.
- area: listeners
  change: |
    added the ability to match :ref:`FilterChain <envoy_api_msg_listener.FilterChain>` using :ref:`destination_port
    <envoy_api_field_listener.FilterChainMatch.destination_port>` and :ref:`prefix_ranges
    <envoy_api_field_listener.FilterChainMatch.prefix_ranges>`.
- area: lua
  change: |
    added :ref:`connection() <config_http_filters_lua_connection_wrapper>` wrapper and ``ssl()`` API.
- area: lua
  change: |
    added :ref:`streamInfo() <config_http_filters_lua_request_info_wrapper>` wrapper and ``protocol()-`` API.
- area: lua
  change: |
    added :ref:`streamInfo():dynamicMetadata() <config_http_filters_lua_request_info_dynamic_metadata_wrapper>` API.
- area: network
  change: |
    introduced :ref:`sni_cluster <config_network_filters_sni_cluster>` network filter that forwards connections to the
    upstream cluster specified by the SNI value presented by the client during a TLS handshake.
- area: proxy_protocol
  change: |
    added support for HAProxy Proxy Protocol v2 (AF_INET/AF_INET6 only).
- area: ratelimit
  change: |
    added support for :repo:`api/envoy/service/ratelimit/v2/rls.proto`. Lyft's reference implementation of the `ratelimit
    <https://github.com/envoyproxy/ratelimit>`_ service also supports the data-plane-api proto as of v1.1.0. Envoy can use
    either proto to send client requests to a ratelimit server with the use of the ``use_data_plane_proto`` boolean flag in
    the ratelimit configuration. Support for the legacy proto ``source/common/ratelimit/ratelimit.proto`` is deprecated and
    will be removed at the start of the 1.9.0 release cycle.
- area: ratelimit
  change: |
    added :ref:`failure_mode_deny <envoy_api_msg_config.filter.http.rate_limit.v2.RateLimit>` option to control traffic flow
    in case of rate limit service error.
- area: rbac config
  change: |
    added a :ref:`principal_name <envoy_api_field_config.rbac.v2alpha.principal.authenticated.principal_name>` field and
    removed the old ``name`` field to give more flexibility for matching certificate identity.
- area: rbac network filter
  change: |
    a :ref:`role-based access control network filter <config_network_filters_rbac>` has been added.
- area: rest-api
  change: |
    added ability to set the :ref:`request timeout <envoy_api_field_core.ApiConfigSource.request_timeout>` for REST API
    requests.
- area: route checker
  change: |
    added v2 config support and removed support for v1 configs.
- area: router
  change: |
    added ability to set request/response headers at the :ref:`v1.8:envoy_api_msg_route.Route` level.
- area: stats
  change: |
    added :ref:`option to configure the DogStatsD metric name prefix
    <envoy_api_field_config.metrics.v2.DogStatsdSink.prefix>` to DogStatsdSink.
- area: tcp_proxy
  change: |
    added support for :ref:`weighted clusters
    <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.weighted_clusters>`.
- area: thrift_proxy
  change: |
    introduced thrift routing, moved configuration to correct location.
- area: thrift_proxy
  change: |
    introduced thrift configurable decoder filters.
- area: tls
  change: |
    implemented :ref:`Secret Discovery Service <config_secret_discovery_service>`.
- area: tracing
  change: |
    added support for configuration of :ref:`tracing sampling
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.tracing>`.
- area: upstream
  change: |
    added configuration option to the subset load balancer to take locality weights into account when selecting a host from
    a subset.
- area: upstream
  change: |
    require opt-in to use the :ref:`x-envoy-original-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>`
    header for overriding destination address when using the :ref:`Original Destination
    <arch_overview_load_balancing_types_original_destination>` load balancing policy.

deprecated:
- area: api
  change: |
    Use of the v1 API (including ``*.deprecated_v1`` fields in the v2 API) is deprecated. See envoy-announce `email
    <https://groups.google.com/forum/#!topic/envoy-announce/oPnYMZw8H4U>`_.
- area: rate_limiting
  change: |
    Use of the legacy `ratelimit.proto
    <https://github.com/envoyproxy/envoy/blob/b0a518d064c8255e0e20557a8f909b6ff457558f/source/common/ratelimit/ratelimit.proto>`_
    is deprecated, in favor of the proto defined in `date-plane-api
    <https://github.com/envoyproxy/envoy/blob/main/api/envoy/service/ratelimit/v2/rls.proto>`_ Prior to 1.8.0, Envoy can use
    either proto to send client requests to a ratelimit server with the use of the ``use_data_plane_proto`` boolean flag in
    the `ratelimit configuration <https://github.com/envoyproxy/envoy/blob/main/api/envoy/config/ratelimit/v2/rls.proto>`_.
    However, when using the deprecated client a warning is logged.
- area: options
  change: |
    Use of the ``--v2-config-only`` flag.
- area: websockets
  change: |
    Use of both ``use_websocket`` and ``websocket_config`` in `route.proto
    <https://github.com/envoyproxy/envoy/blob/main/api/envoy/api/v2/route/route.proto>`_ is deprecated. Please use the new
    ``upgrade_configs`` in the `HttpConnectionManager
    <https://github.com/envoyproxy/envoy/blob/main/api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto>`_
    instead.
- area: fault_delay
  change: |
    Use of the integer ``percent`` field in `FaultDelay
    <https://github.com/envoyproxy/envoy/blob/main/api/envoy/config/filter/fault/v2/fault.proto>`_ and in `FaultAbort
    <https://github.com/envoyproxy/envoy/blob/main/api/envoy/config/filter/http/fault/v2/fault.proto>`_ is deprecated in
    favor of the new ``FractionalPercent`` based ``percentage`` field.
- area: clusters
  change: |
    Setting hosts via ``hosts`` field in ``Cluster`` is deprecated. Use ``load_assignment`` instead.
- area: routing
  change: |
    Use of ``response_headers_to_*`` and ``request_headers_to_add`` are deprecated at the ``RouteAction`` level. Please use
    the configuration options at the ``Route`` level.
- area: routing
  change: |
    Use of ``runtime`` in ``RouteMatch``, found in `route.proto
    <https://github.com/envoyproxy/envoy/blob/main/api/envoy/api/v2/route/route.proto>`_. Set the ``runtime_fraction`` field
    instead.
- area: rbac
  change: |
    Use of the string ``user`` field in ``Authenticated`` in `rbac.proto
    <https://github.com/envoyproxy/envoy/blob/release/v1.8/api/envoy/config/rbac/v2alpha/rbac.proto>`_ is deprecated in
    favor of the new ``StringMatcher`` based ``principal_name`` field.
date: August 24, 2017

changes:
- area: mac
  change: |
    macOS is :repo:`now supported <v1.5:/bazel#quick-start-bazel-build-for-developers>`. (A few features are missing such as
    hot restart and original destination routing).
- area: config
  change: |
    YAML is now directly supported for config files.
- area: admin
  change: |
    Added /routes admin endpoint.
- area: flow_control
  change: |
    End-to-end flow control is now supported for TCP proxy, HTTP/1, and HTTP/2. HTTP flow control that includes filter
    buffering is incomplete and will be implemented in 1.5.0.
- area: logging
  change: |
    Log verbosity :repo:`compile time flag <v1.5:/bazel#log-verbosity>` added.
- area: hot_restart
  change: |
    Hot restart :repo:`compile time flag <v1.5:/bazel#hot-restart>` added.
- area: load_balancing
  change: |
    Original destination :ref:`cluster <v1.5:arch_overview_service_discovery_types_original_destination>` and :ref:`load
    balancer <v1.5:arch_overview_load_balancing_types_original_destination>` added.
- area: websockets
  change: |
    :ref:`WebSocket <v1.5:arch_overview_websocket>` is now supported.
- area: clusters
  change: |
    Virtual cluster priorities have been hard removed without deprecation as we are reasonably sure no one is using this
    feature.
- area: clusters
  change: |
    Route ``validate_clusters`` option added.
- area: headers
  change: |
    :ref:`x-envoy-downstream-service-node <v1.5:config_http_conn_man_headers_downstream-service-node>` header added.
- area: headers
  change: |
    :ref:`x-forwarded-client-cert <v1.5:config_http_conn_man_headers_x-forwarded-client-cert>` header added.
- area: http1
  change: |
    Initial HTTP/1 forward proxy support for absolute URLs has been added.
- area: http2
  change: |
    HTTP/2 codec settings are now configurable.
- area: grpc
  change: |
    gRPC/JSON transcoder :ref:`filter <v1.5:config_http_filters_grpc_json_transcoder>` added.
- area: grpc
  change: |
    gRPC web :ref:`filter <v1.5:config_http_filters_grpc_web>` added.
- area: rate_limting
  change: |
    Configurable timeout for the rate limit service call in the :ref:`network <v1.5:config_network_filters_rate_limit>` and
    :ref:`HTTP <v1.5:config_http_filters_rate_limit>` rate limit filters.
- area: headers
  change: |
    :ref:`x-envoy-retry-grpc-on <v1.5:config_http_filters_router_x-envoy-retry-grpc-on>` header added.
- area: lds
  change: |
    :ref:`LDS API <v1.5:arch_overview_dynamic_config_lds>` added.
- area: tls
  change: |
    TLS :``require_client_certificate`` option added.
- area: configs
  change: |
    :ref:`Configuration check tool <v1.5:install_tools_config_load_check_tool>` added.
- area: schema
  change: |
    :ref:`JSON schema check tool <v1.5:install_tools_schema_validator_check_tool>` added.
- area: options
  change: |
    Config validation mode added via the :option:`--mode` option.
- area: options
  change: |
    :option:`--local-address-ip-version` option added.
- area: networking
  change: |
    IPv6 support is now complete.
- area: dns
  change: |
    UDP ``statsd_ip_address`` option added.
- area: dns
  change: |
    Per-cluster DNS resolvers added.
- area: fault_injection
  change: |
    :ref:`Fault filter <v1.5:config_http_filters_fault_injection>` enhancements and fixes.
- area: deprecation
  change: |
    Several features are `deprecated as of the 1.4.0 release
    <https://github.com/envoyproxy/envoy/blob/v1.4.0/DEPRECATED.md>`_. They will be removed at the beginning of the 1.5.0
    release cycle. We explicitly call out that the ``HttpFilterConfigFactory`` filter API has been deprecated in favor of
    ``NamedHttpFilterConfigFactory``.
- area: envoy
  change: |
    Many small bug fixes and performance improvements not listed.

deprecated:
- area: options
  change: |
    Config option ``statsd_local_udp_port`` has been deprecated and has been replaced with ``statsd_udp_ip_address``.
- area: http_filters
  change: |
    ``HttpFilterConfigFactory`` filter API has been deprecated in favor of ``NamedHttpFilterConfigFactory``.
- area: config
  change: |
    Config option ``http_codec_options`` has been deprecated and has been replaced with ``http2_settings``.
- area: logging
  change: |
    The following log macros have been deprecated: ``log_trace``, ``log_debug``, ``conn_log``, ``conn_log_info``,
    ``conn_log_debug``, ``conn_log_trace``, ``stream_log``, ``stream_log_info``, ``stream_log_debug``, ``stream_log_trace``.
    For replacements, please see `logger.h <https://github.com/envoyproxy/envoy/blob/main/source/common/common/logger.h>`_.
- area: streaming
  change: |
    The connectionId() and ssl() callbacks of StreamFilterCallbacks have been deprecated and replaced with a more general
    connection() callback, which, when not returning a nullptr, can be used to get the connection id and SSL connection from
    the returned Connection object pointer.
- area: grpc
  change: |
    The protobuf stub gRPC support via ``Grpc::RpcChannelImpl`` is now replaced with ``Grpc::AsyncClientImpl``. This no
    longer uses ``protoc`` generated stubs but instead utilizes C++ template generation of the RPC stubs.
    ``Grpc::AsyncClientImpl`` supports streaming, in addition to the previous unary, RPCs.
- area: filters
  change: |
    The direction of network and HTTP filters in the configuration will be ignored from 1.4.0 and later removed from the
    configuration in the v2 APIs. Filter direction is now implied at the C++ type level. The ``type()`` methods on the
    ``NamedNetworkFilterConfigFactory`` and ``NamedHttpFilterConfigFactory`` interfaces have been removed to reflect this.
date: August 24, 2021

minor_behavior_changes:
- area: http
  change: |
    reject requests with \#fragment in the URI path. The fragment is not allowed to be part of request URI according to
    RFC3986 (3.5), RFC7230 (5.1) and RFC 7540 (8.1.2.3). Rejection of requests can be changed to stripping the \#fragment
    instead by setting the runtime guard ``envoy.reloadable_features.http_reject_path_with_fragment`` to false. This
    behavior can further be changed to the deprecated behavior of keeping the fragment by setting the runtime guard
    ``envoy.reloadable_features.http_strip_fragment_from_path_unsafe_if_disabled``. This runtime guard must only be set to
    false when existing non-compliant traffic relies on \#fragment in URI. When this option is enabled, Envoy request
    authorization extensions may be bypassed. This override and its associated behavior will be decommissioned after the
    standard deprecation period.
- area: http
  change: |
    stop processing pending H/2 frames if connection transitioned to the closed state. This behavior can be temporarily
    reverted by setting the ``envoy.reloadable_features.skip_dispatching_frames_for_closed_connection`` to false.

bug_fixes:
- area: ext_authz
  change: |
    fix the ext_authz filter to correctly merge multiple same headers using the ``,`` as separator in the check request to
    the external authorization service.
- area: http
  change: |
    limit use of deferred resets in the http2 codec to server-side connections. Use of deferred reset for client connections
    can result in incorrect behavior and performance problems.
date: June 2, 2023

bug_fixes:
- area: boringssl
  change: |
    Fixed the crash that occurs when contrib is compiled with ``boringssl=fips`` defined.
- area: dependency
  change: |
    update Wasmtime and related deps -> 9.0.3 to resolve
    `CVE-2023-30624 <https://nvd.nist.gov/vuln/detail/CVE-2023-30624>`_.
- area: dependency
  change: |
    update C-ares -> 1.91.1 to resolve:

    - `CVE-2023-31130 <https://nvd.nist.gov/vuln/detail/CVE-2023-31130>`_.
    - `CVE-2023-31147 <https://nvd.nist.gov/vuln/detail/CVE-2023-31147>`_.
    - `CVE-2023-31124 <https://nvd.nist.gov/vuln/detail/CVE-2023-31124>`_.
    - `CVE-2023-32067 <https://nvd.nist.gov/vuln/detail/CVE-2023-32067>`_.
date: September 29, 2020

changes:
- area: http
  change: |
    fixed CVE-2020-25017. Previously header matching did not match on all headers for non-inline headers.
    This patch changes the default behavior to always logically match on all headers. Multiple individual
    headers will be logically concatenated with ``,`` similar to what is done with inline headers. This
    makes the behavior effectively consistent. This behavior can be temporary reverted by setting
    the runtime value ``envoy.reloadable_features.http_match_on_all_headers`` to ``false``.

    Targeted fixes have been additionally performed on the following extensions which make them
    consider all duplicate headers by default as a comma concatenated list:

      1. Any extension using CEL matching on headers.
      2. The header to metadata filter.
      3. The JWT filter.
      4. The Lua filter.

    Like primary header matching used in routing, RBAC, etc. this behavior can be disabled by setting
    the runtime value ``envoy.reloadable_features.http_match_on_all_headers`` to ``false``.
- area: http
  change: |
    fixed CVE-2020-25017. The ``setCopy()`` header map API previously only set the first header in the case of duplicate
    non-inline headers. ``setCopy()`` now behaves similarly to the other ``set*()`` APIs and replaces all found
    headers with a single value. This may have had security implications in the extauth filter which
    uses this API. This behavior can be disabled by setting the runtime value
    ``envoy.reloadable_features.http_set_copy_replace_all_headers`` to ``false``.
date: January 12, 2022

behavior_changes:
- area: auto_config
  change: |
    :ref:`auto_config <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.auto_config>` now verifies that
    any transport sockets configured via :ref:`transport_socket_matches
    <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>` support ALPN. This behavioral change can be
    temporarily reverted by setting runtime guard ``envoy.reloadable_features.correctly_validate_alpn`` to false.
- area: xds
  change: |
    ``*`` became a reserved name for a wildcard resource that can be subscribed to and unsubscribed from at any time. This
    is a requirement for implementing the on-demand xDSes (like on-demand CDS) that can subscribe to specific resources next
    to their wildcard subscription. If such xDS is subscribed to both wildcard resource and to other specific resource, then
    in stream reconnection scenario, the xDS will not send an empty initial request, but a request containing ``*`` for
    wildcard subscription and the rest of the resources the xDS is subscribed to. If the xDS is only subscribed to wildcard
    resource, it will try to send a legacy wildcard request. This behavior implements the recent changes in :ref:`xDS
    protocol <xds_protocol>` and can be temporarily reverted by setting the
    ``envoy.restart_features.explicit_wildcard_resource`` runtime guard to false.

minor_behavior_changes:
- area: bandwidth_limit
  change: |
    added :ref:`response trailers
    <envoy_v3_api_field_extensions.filters.http.bandwidth_limit.v3.BandwidthLimit.enable_response_trailers>` when request or
    response delay are enforced.
- area: bandwidth_limit
  change: |
    added :ref:`bandwidth limit stats <config_http_filters_bandwidth_limit>` ``request_enforced`` and ``response_enforced``.
- area: dns
  change: |
    now respecting the returned DNS TTL for resolved hosts, rather than always relying on the hard-coded
    :ref:`dns_refresh_rate. <envoy_v3_api_field_config.cluster.v3.Cluster.dns_refresh_rate>`. This behavior can be
    temporarily reverted by setting the runtime guard ``envoy.reloadable_features.use_dns_ttl`` to false.
- area: ext_authz
  change: |
    the ext_authz span was always getting sampled, even if the parent span was not; now the ext_authz span follows the
    parent's sampling status.
- area: http
  change: |
    directly responding with only a 1xx http status code isn't valid, and is now refused as invalid :ref:`direct_response
    <envoy_v3_api_field_config.route.v3.Route.direct_response>` config.
- area: http
  change: |
    envoy will now proxy 102 and 103 headers from upstream, though as with 100s only the first 1xx response headers will be
    sent. This behavioral change by can temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.proxy_102_103`` to false.
- area: http
  change: |
    usage of the experimental matching API is no longer guarded behind a feature flag, as the corresponding protobuf fields
    have been marked as WIP.
- area: http
  change: |
    when a downstream connection hits a configured ``max_requests_per_connection``, it will send an HTTP/2 "shutdown
    notification" (GOAWAY frame with max stream ID) and go to a default grace period of 5000 milliseconds (5 seconds) if
    :ref:`drain_timeout
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout>` is not
    specified. During this grace period, envoy will continue to accept new streams. After the grace period, a final GOAWAY
    is sent and envoy will start refusing new streams. However before the bugfix, during the grace period, every time a new
    stream is received, envoy would restart the drain which caused the grace period to be extended and so making it longer
    than the configured drain timeout.
- area: json
  change: |
    switching from rapidjson to nlohmann/json. This behavioral change can be temporarily reverted by setting runtime guard
    ``envoy.reloadable_features.remove_legacy_json`` to false.
- area: listener
  change: |
    destroy per network filter chain stats when a network filter chain is removed during the listener in place update.
- area: router
  change: |
    take elapsed time into account when setting the ``x-envoy-expected-rq-timeout-ms header`` for retries, and never send a
    value that's longer than the request timeout. This behavioral change can be temporarily reverted by setting runtime
    guard ``envoy.reloadable_features.update_expected_rq_timeout_on_retry`` to false.
- area: stream_info
  change: |
    response code details with empty space characters (' ', '\\t', '\\f', '\\v', '\\n', '\\r') is not accepted by the
    ``setResponseCodeDetails()`` API.
- area: upstream
  change: |
    fixed a bug where auto_config didn't work for wrapped TLS sockets (e.g. if proxy proto were configured for TLS).

bug_fixes:
- area: ext_authz
  change: |
    fix the ext_authz http filter to correctly set response flags to ``UAEX`` when a connection is denied.
- area: ext_authz
  change: |
    fix the ext_authz network filter to correctly set response flag and code details to ``UAEX`` when a connection is
    denied.
- area: hcm
  change: |
    stop processing the response if encoding it has caused downstream reset. The fix is guarded by
    ``envoy.reloadable_features.handle_stream_reset_during_hcm_encoding``.
- area: listener
  change: |
    fixed issue where more than one listener could listen on the same port if using reuse port, thus randomly accepting
    connections on different listeners. This configuration is now rejected.
- area: tcp
  change: |
    fixing a log error where errors both from the kernel and the transport were not handled gracefully.
- area: thrift_proxy
  change: |
    do not close downstream connections when an upstream connection overflow happens.
- area: thrift_proxy
  change: |
    fix the thrift_proxy connection manager to correctly report success/error response metrics when performing :ref:`payload
    passthrough <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.ThriftProxy.payload_passthrough>`.

removed_config_or_runtime:
- area: compression
  change: |
    removed ``envoy.reloadable_features.enable_compression_without_content_length_header`` runtime guard and legacy code
    paths.
- area: grpc-web
  change: |
    removed ``envoy.reloadable_features.grpc_web_fix_non_proto_encoded_response_handling`` and legacy code paths.
- area: header map
  change: |
    removed ``envoy.reloadable_features.header_map_correctly_coalesce_cookies`` and legacy code paths.
- area: health check
  change: |
    removed ``envoy.reloadable_features.health_check.immediate_failure_exclude_from_cluster`` runtime guard and legacy code
    paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.add_and_validate_scheme_header`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.check_unsupported_typed_per_filter_config``, Envoy will always check unsupported
    typed per filter config if the filter isn't optional.
- area: http
  change: |
    removed ``envoy.reloadable_features.dont_add_content_length_for_bodiless_requests`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.grpc_json_transcoder_adhere_to_buffer_limits`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.http2_skip_encoding_empty_trailers`` and legacy code paths. Envoy will always encode
    empty trailers by sending empty data with ``end_stream`` true (instead of sending empty trailers) for HTTP/2.
- area: http
  change: |
    removed ``envoy.reloadable_features.improved_stream_limit_handling`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.remove_forked_chromium_url`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.return_502_for_upstream_protocol_errors``. Envoy will always return 502 code upon
    encountering upstream protocol error.
- area: http
  change: |
    removed ``envoy.reloadable_features.treat_host_like_authority`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.treat_upstream_connect_timeout_as_connect_failure`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.upstream_http2_flood_checks`` and legacy code paths.
- area: upstream
  change: |
    removed ``envoy.reloadable_features.upstream_host_weight_change_causes_rebuild`` and legacy code paths.

new_features:
- area: access log
  change: |
    added :ref:`custom_tags <envoy_v3_api_field_extensions.access_loggers.grpc.v3.CommonGrpcAccessLogConfig.custom_tags>` to
    annotate log entries with custom tags.
- area: access log
  change: |
    added :ref:`grpc_stream_retry_policy
    <envoy_v3_api_field_extensions.access_loggers.grpc.v3.CommonGrpcAccessLogConfig.grpc_stream_retry_policy>` to the gRPC
    logger to reconnect when a connection fails to be established.
- area: access_log
  change: |
    added :ref:`METADATA <envoy_v3_api_msg_extensions.formatter.metadata.v3.Metadata>` token to handle all types of metadata
    (DYNAMIC, CLUSTER, ROUTE).
- area: access_log
  change: |
    added a CEL extension filter to enable filtering of access logs based on Envoy attribute expressions.
- area: access_log
  change: |
    added new access_log command operator ``%UPSTREAM_REQUEST_ATTEMPT_COUNT%`` to retrieve the number of times given request
    got attempted upstream.
- area: access_log
  change: |
    added new access_log command operator ``%VIRTUAL_CLUSTER_NAME%`` to retrieve the matched Virtual Cluster name.
- area: api
  change: |
    added support for ``xds.type.v3.TypedStruct`` in addition to the now-deprecated ``udpa.type.v1.TypedStruct`` proto
    message, which is a wrapper proto used to encode typed JSON data in a ``google.protobuf.Any`` field.
- area: aws_request_signing_filter
  change: |
    added :ref:`match_excluded_headers
    <envoy_v3_api_field_extensions.filters.http.aws_request_signing.v3.AwsRequestSigning.match_excluded_headers>` to the
    signing filter to optionally exclude request headers from signing.
- area: bootstrap
  change: |
    added :ref:`typed_dns_resolver_config <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.typed_dns_resolver_config>` in
    the bootstrap to support DNS resolver as an extension.
- area: cluster
  change: |
    added :ref:`typed_dns_resolver_config <envoy_v3_api_field_config.cluster.v3.Cluster.typed_dns_resolver_config>` in the
    cluster to support DNS resolver as an extension.
- area: config
  change: |
    added :ref:`environment_variable <envoy_v3_api_field_config.core.v3.datasource.environment_variable>` to the
    :ref:`DataSource <envoy_v3_api_msg_config.core.v3.datasource>`.
- area: decompressor
  change: |
    added :ref:`ignore_no_transform_header
    <envoy_v3_api_field_extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig.ignore_no_transform_header>`
    to run decompression regardless of the value of the ``no-transform`` cache control header.
- area: dns
  change: |
    added :ref:`ALL <envoy_v3_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.ALL>` option to return both IPv4 and
    IPv6 addresses.
- area: dns_cache
  change: |
    added :ref:`typed_dns_resolver_config
    <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.typed_dns_resolver_config>` in the
    dns_cache to support DNS resolver as an extension.
- area: dns_filter
  change: |
    added :ref:`typed_dns_resolver_config
    <envoy_v3_api_field_extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig.typed_dns_resolver_config>`
    in the dns_filter to support DNS resolver as an extension.
- area: dns_resolver
  change: |
    added :ref:`CaresDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
    to support c-ares DNS resolver as an extension.
- area: dns_resolver
  change: |
    added :ref:`use_resolvers_as_fallback
    <envoy_v3_api_field_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.use_resolvers_as_fallback>` to the
    c-ares DNS resolver.
- area: dns_resolver
  change: |
    added :ref:`filter_unroutable_families
    <envoy_v3_api_field_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.filter_unroutable_families>` to the
    c-ares DNS resolver.
- area: dns_resolver
  change: |
    added :ref:`AppleDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.apple.v3.AppleDnsResolverConfig>`
    to support apple DNS resolver as an extension.
- area: ext_authz
  change: |
    added :ref:`query_parameters_to_set <envoy_v3_api_field_service.auth.v3.OkHttpResponse.query_parameters_to_set>` and
    :ref:`query_parameters_to_remove <envoy_v3_api_field_service.auth.v3.OkHttpResponse.query_parameters_to_remove>` for
    adding and removing query string parameters when using a gRPC authorization server.
- area: grpc_http_bridge
  change: |
    added :ref:`upgrade_protobuf_to_grpc
    <envoy_v3_api_field_extensions.filters.http.grpc_http1_bridge.v3.Config.upgrade_protobuf_to_grpc>` option for
    automatically framing protobuf payloads as gRPC requests.
- area: grpc_json_transcoder
  change: |
    added support for matching unregistered custom verb :ref:`match_unregistered_custom_verb
    <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.match_unregistered_custom_verb>`.
- area: http
  change: |
    added support for ``%REQUESTED_SERVER_NAME%`` to extract SNI as a custom header.
- area: http
  change: |
    added support for ``%VIRTUAL_CLUSTER_NAME%`` to extract the matched Virtual Cluster name as a custom header.
- area: http
  change: |
    added support for :ref:`retriable health check status codes
    <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses>`.
- area: http
  change: |
    added timing information about upstream connection and encryption establishment to stream info. These can currently be
    accessed via custom access loggers.
- area: http
  change: |
    added support for :ref:`forwarding HTTP1 reason phrase
    <envoy_v3_api_field_extensions.http.header_formatters.preserve_case.v3.PreserveCaseFormatterConfig.forward_reason_phrase>`.
- area: listener
  change: |
    added API for extensions to access :ref:`typed_filter_metadata
    <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>` configured in the listener's :ref:`metadata
    <envoy_v3_api_field_config.listener.v3.Listener.metadata>` field.
- area: listener
  change: |
    added support for :ref:`MPTCP <envoy_v3_api_field_config.listener.v3.Listener.enable_mptcp>` (multipath TCP).
- area: listener
  change: |
    added support for opting out listeners from the globally set downstream connection limit via
    :ref:`ignore_global_conn_limit <envoy_v3_api_field_config.listener.v3.Listener.ignore_global_conn_limit>`.
- area: matcher
  change: |
    added support for ``xds.type.matcher.v3.IPMatcher`` IP trie matching.
- area: oauth filter
  change: |
    added :ref:`cookie_names <envoy_v3_api_field_extensions.filters.http.oauth2.v3.OAuth2Credentials.cookie_names>` to allow
    overriding (default) cookie names (``BearerToken``, ``OauthHMAC``, and ``OauthExpires``) set by the filter.
- area: oauth filter
  change: |
    setting ``IdToken`` and ``RefreshToken`` cookies if they are provided by Identity provider along with ``AccessToken``.
- area: perf
  change: |
    added support for `Perfetto <https://perfetto.dev>`_ performance tracing.
- area: router
  change: |
    added support for the :ref:`v1.21:config_http_conn_man_headers_x-forwarded-host` header.
- area: stateful session http filter
  change: |
    added :ref:`stateful session http filter <config_http_filters_stateful_session>`.
- area: stats
  change: |
    added text_readouts query parameter to prometheus stats to return gauges made from text readouts.
- area: tcp
  change: |
    added a :ref:`FilterState <envoy_v3_api_msg_type.v3.HashPolicy.FilterState>` :ref:`hash policy
    <envoy_v3_api_msg_type.v3.HashPolicy>`, used by :ref:`TCP proxy
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.hash_policy>` to allow hashing load balancer
    algorithms to hash on objects in filter state.
- area: tcp_proxy
  change: |
    added support to populate upstream http connect header values from stream info.
- area: thrift_proxy
  change: |
    add header to metadata filter for turning headers into dynamic metadata.
- area: thrift_proxy
  change: |
    add upstream response zone metrics in the form
    ``cluster.cluster_name.zone.local_zone.upstream_zone.thrift.upstream_resp_success``.
- area: thrift_proxy
  change: |
    add upstream metrics to show decoding errors and whether exception is from local or remote, e.g.
    ``cluster.cluster_name.thrift.upstream_resp_exception_remote``.
- area: thrift_proxy
  change: |
    add host level success/error metrics where success is a reply of type success and error is any other response to a call.
- area: thrift_proxy
  change: |
    support header flags.
- area: thrift_proxy
  change: |
    support subset lb when using request or route metadata.
- area: tls
  change: |
    added support for :ref:`match_typed_subject_alt_names
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>` for
    subject alternative names to enforce specifying the subject alternative name type for the matcher to prevent matching
    against an unintended type in the certificate.
- area: tls
  change: |
    added support for only verifying the leaf CRL in the certificate chain with :ref:`only_verify_leaf_cert_crl
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.only_verify_leaf_cert_crl>`.
- area: tls
  change: |
    support loading certificate chain and private key via :ref:`pkcs12
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.pkcs12>`.
- area: tls_inspector filter
  change: |
    added :ref:`enable_ja3_fingerprinting
    <envoy_v3_api_field_extensions.filters.listener.tls_inspector.v3.TlsInspector.enable_ja3_fingerprinting>` to create JA3
    fingerprint hash from Client Hello message.
- area: transport_socket
  change: |
    added :ref:`envoy.transport_sockets.tcp_stats <envoy_v3_api_msg_extensions.transport_sockets.tcp_stats.v3.Config>` which
    generates additional statistics gathered from the OS TCP stack.
- area: udp
  change: |
    add support for multiple listener filters.
- area: udp_proxy
  change: |
    added :ref:`use_per_packet_load_balancing
    <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.use_per_packet_load_balancing>` option to enable
    per packet load balancing (selection of upstream host on each data chunk).
- area: upstream
  change: |
    added the ability to :ref:`configure max connection duration
    <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_connection_duration>` for upstream clusters.
- area: vcl_socket_interface
  change: |
    added VCL socket interface extension for fd.io VPP integration to :ref:`contrib images <install_contrib>`. This can be
    enabled via :ref:`VCL <envoy_v3_api_msg_extensions.vcl.v3alpha.VclSocketInterface>` configuration.
- area: xds
  change: |
    re-introduced unified delta and sotw xDS multiplexers that share most of the implementation. Added a new runtime config
    ``envoy.reloadable_features.unified_mux`` (disabled by default) that when enabled, switches xDS to use unified
    multiplexers.

deprecated:
- area: bootstrap
  change: |
    :ref:`dns_resolution_config <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.dns_resolution_config>` is deprecated in
    favor of :ref:`typed_dns_resolver_config <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.typed_dns_resolver_config>`.
- area: cluster
  change: |
    :ref:`dns_resolution_config <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>` is deprecated in favor
    of :ref:`typed_dns_resolver_config <envoy_v3_api_field_config.cluster.v3.Cluster.typed_dns_resolver_config>`.
- area: dns_cache
  change: |
    :ref:`dns_resolution_config
    <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_resolution_config>` is deprecated in
    favor of :ref:`typed_dns_resolver_config
    <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.typed_dns_resolver_config>`.
- area: tls
  change: |
    :ref:`match_subject_alt_names
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_subject_alt_names>` has been
    deprecated in favor of the :ref:`match_typed_subject_alt_names
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`.
- area: dns_filter
  change: |
    :ref:`dns_resolution_config
    <envoy_v3_api_field_extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig.dns_resolution_config>` is
    deprecated in favor of :ref:`typed_dns_resolver_config
    <envoy_v3_api_field_extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig.typed_dns_resolver_config>`.
date: February 28, 2023

bug_fixes:
- area: dependency
  change: |
    update Kafka to resolve CVE-2023-25194.

new_features:
- area: docker
  change: |
    unify published images as tag variants. For example, ``envoyproxy/envoy-dev`` is now available
    as ``envoyproxy/envoy:dev``.
date: October 10, 2023

behavior_changes:
- area: http
  change: |
    Close HTTP/2 and HTTP/3 connections that prematurely reset streams. The runtime key
    ``overload.premature_reset_min_stream_lifetime_seconds`` determines the interval where received stream
    reset is considered premature (with 1 second default). The runtime key ``overload.premature_reset_total_stream_count``,
    with the default value of 500, determines the number of requests received from a connection before the check for premature
    resets is applied. The connection is disconnected if more than 50% of resets are premature.
    Setting the runtime key ``envoy.restart_features.send_goaway_for_premature_rst_streams`` to ``false`` completely disables
    this check.
- area: http
  change: |
    Add runtime flag ``http.max_requests_per_io_cycle`` for setting the limit on the number of HTTP requests processed
    from a single connection in a single I/O cycle. Requests over this limit are processed in subsequent I/O cycles. This
    mitigates CPU starvation by connections that simultaneously send high number of requests by allowing requests from other
    connections to make progress. This runtime value can be set to 1 in the presence of abusive HTTP/2 or HTTP/3 connections.
    By default this limit is disabled.
- area: http
  change: |
    Add runtime flag ``http.max_requests_per_io_cycle`` for setting the limit on the number of HTTP requests processed
    from a single connection in a single I/O cycle. Requests over this limit are processed in subsequent I/O cycles. This
    mitigates CPU starvation by connections that simultaneously send high number of requests by allowing requests from other
    connections to make progress. This runtime value can be set to 1 in the presence of abusive HTTP/2 or HTTP/3 connections.
    By default this limit is disabled.

bug_fixes:
- area: tls
  change: |
    fixed a bug where handshake may fail when both private key provider and cert validation are set.
- area: docker/publishing
  change: |
    Update base images to resolve various glibc vulnerabilities.
date: September 29, 2020

changes:
- area: http
  change: |
    fixed CVE-2020-25017. Previously header matching did not match on all headers for non-inline
    headers. This patch changes the default behavior to always logically match on all headers.
    Multiple individual headers will be logically concatenated with ``,`` similar to what is done with
    inline headers. This makes the behavior effectively consistent. This behavior can be temporary
    reverted by setting the runtime value ``envoy.reloadable_features.http_match_on_all_headers`` to
    ``false``.

    Targeted fixes have been additionally performed on the following extensions which make them
    consider all duplicate headers by default as a comma concatenated list:

      1. Any extension using CEL matching on headers.
      2. The header to metadata filter.
      3. The JWT filter.
      4. The Lua filter.

    Like primary header matching used in routing, RBAC, etc. this behavior can be disabled by setting
    the runtime value ``envoy.reloadable_features.http_match_on_all_headers`` to false.
- area: http
  change: |
    The ``setCopy()`` header map API previously only set the first header in the case of duplicate
    non-inline headers. ``setCopy()`` now behaves similarly to the other ``set*()`` APIs and replaces all found
    headers with a single value. This may have had security implications in the extauth filter which
    uses this API. This behavior can be disabled by setting the runtime value
    ``envoy.reloadable_features.http_set_copy_replace_all_headers`` to ``false``.
date: June 9, 2022

minor_behavior_changes:
- area: cryptomb
  change: |
    remove RSA PKCS1 v1.5 padding support.

bug_fixes:
- area: decompression
  change: |
    fixed CVE-2022-29225 due to which decompressors can be zip bombed. Previously decompressors were susceptible to memory
    inflation in takes in which specially crafted payloads could cause a large amount of memory usage by Envoy. The max
    inflation payload size is now limited.  This change can be reverted via the
    ``envoy.reloadable_features.enable_compression_bomb_protection`` runtime flag.
- area: health_check
  change: |
    fixed CVE-2022-29224 which caused a segfault in GrpcHealthCheckerImpl. An attacker-controlled upstream server that is
    health checked using gRPC health checking can crash Envoy via a null pointer dereference in certain circumstances.
- area: oauth
  change: |
    fixed CVE-2022-29226 due to which oauth filter allows trivial bypass. The OAuth filter implementation does not include a
    mechanism for validating access tokens, so by design when the HMAC signed cookie is missing a full authentication flow
    should be triggered. However, the current implementation assumes that access tokens are always validated thus allowing
    access in the presence of any access token attached to the request.
- area: oauth
  change: |
    fixed CVE-2022-29228 due to which oauth filter calls continueDecoding() from within decodeHeaders(). The OAuth filter
    would try to invoke the remaining filters in the chain after emitting a local response, which triggers an ASSERT() in
    newer versions and corrupts memory on earlier versions.
- area: router
  change: |
    fixed CVE-2022-29227 which caused an internal redirect crash for requests with body/trailers. Envoy would previously
    crash in some cases when processing internal redirects for requests with bodies or trailers if the redirect prompts an
    Envoy-generated local reply.
date: October 10, 2023

behavior_changes:
- area: http
  change: |
    Close HTTP/2 and HTTP/3 connections that prematurely reset streams. The runtime key
    ``overload.premature_reset_min_stream_lifetime_seconds`` determines the interval where received stream
    reset is considered premature (with 1 second default). The runtime key ``overload.premature_reset_total_stream_count``,
    with the default value of 500, determines the number of requests received from a connection before the check for premature
    resets is applied. The connection is disconnected if more than 50% of resets are premature.
    Setting the runtime key ``envoy.restart_features.send_goaway_for_premature_rst_streams`` to ``false`` completely disables
    this check.
- area: http
  change: |
    Add runtime flag ``http.max_requests_per_io_cycle`` for setting the limit on the number of HTTP requests processed
    from a single connection in a single I/O cycle. Requests over this limit are processed in subsequent I/O cycles. This
    mitigates CPU starvation by connections that simultaneously send high number of requests by allowing requests from other
    connections to make progress. This runtime value can be set to 1 in the presence of abusive HTTP/2 or HTTP/3 connections.
    By default this limit is disabled.
date: March 3, 2020

changes:
- area: buffer
  change: |
    force copy when appending small slices to OwnedImpl buffer to avoid fragmentation.
- area: http
  change: |
    added HTTP/1.1 flood protection. Can be temporarily disabled using the runtime feature
    ``envoy.reloadable_features.http1_flood_protection``.
- area: listeners
  change: |
    fixed issue where :ref:`TLS inspector listener filter <config_listener_filters_tls_inspector>` could have been bypassed
    by a client using only TLS 1.3.
- area: rbac
  change: |
    added :ref:`url_path <envoy_api_field_config.rbac.v2.Permission.url_path>` for matching URL path without the query and
    fragment string.
- area: sds
  change: |
    fixed the SDS vulnerability that TLS validation context (e.g., subject alt name or hash) cannot be effectively validated
    in some cases.
date: August 23, 2022

bug_fixes:
- area: listener
  change: |
    fixed a bug that doesn't handle of an update for a listener with IPv4-mapped address correctly and that will lead to a
    memory leak.
date: May 11, 2021

new_features:
- area: http
  change: |
    added the ability to :ref:`unescape slash sequences
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.path_with_escaped_slashes_action>`
    in the path. Requests with unescaped slashes can be proxied, rejected or redirected to the new unescaped path. By
    default this feature is disabled. The default behavior can be overridden through
    :ref:`http_connection_manager.path_with_escaped_slashes_action<config_http_conn_man_runtime_path_with_escaped_slashes_action>`
    runtime variable. This action can be selectively enabled for a portion of requests by setting the
    :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling<config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled>`
    runtime variable.
date: June 5, 2023

bug_fixes:
- area: boringssl
  change: |
    Fixed the crash that occurs when contrib is compiled with ``boringssl=fips`` defined.
- area: ext_authz
  change: |
    Fix a bug where the ext_authz filter will ignore the request body when the
    :ref:`pack_as_bytes <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.BufferSettings.pack_as_bytes>` is set to true and
    HTTP authorization service is configured.
- area: dependency
  change: |
    update Wasmtime and related deps -> 9.0.3 to resolve
    `CVE-2023-30624 <https://nvd.nist.gov/vuln/detail/CVE-2023-30624>`_.
- area: dependency
  change: |
    update C-ares -> 1.91.1 to resolve:

    - `CVE-2023-31130 <https://nvd.nist.gov/vuln/detail/CVE-2023-31130>`_.
    - `CVE-2023-31147 <https://nvd.nist.gov/vuln/detail/CVE-2023-31147>`_.
    - `CVE-2023-31124 <https://nvd.nist.gov/vuln/detail/CVE-2023-31124>`_.
    - `CVE-2023-32067 <https://nvd.nist.gov/vuln/detail/CVE-2023-32067>`_.
date: December 7, 2020

changes:
- area: tls
  change: |
    fix read resumption after triggering buffer high-watermark and all remaining request/response bytes are stored in the
    SSL connection's internal buffers.
- area: udp
  change: |
    fixed issue in which receiving truncated UDP datagrams would cause Envoy to crash.
load("//bazel:envoy_build_system.bzl", "envoy_package")

licenses(["notice"])  # Apache 2

envoy_package()

exports_files([
    "sections.yaml",
])

filegroup(
    name = "changelogs",
    srcs = glob(["*.*.*.yaml"]) + ["current.yaml"],
)

genrule(
    name = "summary",
    outs = ["summary.txt"],
    cmd = """
    cat $(location :summary.md) > $@
    """,
    tools = ["summary.md"],
    visibility = ["//visibility:public"],
)
date: August 12, 2022

bug_fixes:
- area: listener
  change: |
    fixed a bug that doesn't handle of an update for a listener with IPv4-mapped address correctly, and that will lead to a
    memory leak.
- area: repo
  change: |
    fix version to resolve release issue.
- area: transport_socket
  change: |
    fixed a bug that prevented the tcp stats to be retrieved when running on kernels different than the kernel where Envoy
    was built.
date: January 11, 2021

behavior_changes:
- area: config
  change: |
    v2 is now fatal-by-default. This may be overridden by setting ``--bootstrap-version 2`` on the CLI for a v2 bootstrap
    file and also enabling the runtime ``envoy.reloadable_features.enable_deprecated_v2_api`` feature.

minor_behavior_changes:
- area: build
  change: |
    the Alpine based debug images are no longer built in CI, use Ubuntu based images instead.
- area: decompressor
  change: |
    set the default value of window_bits of the decompressor to 15 to be able to decompress responses compressed by a
    compressor with any window size.
- area: expr filter
  change: |
    added ``connection.termination_details`` property support.
- area: formatter
  change: |
    the :ref:`text_format <envoy_v3_api_field_config.core.v3.SubstitutionFormatString.text_format>` field no longer requires
    at least one byte, and may now be the empty string. It has also become :ref:`deprecated <1_17_deprecated>`.
- area: grpc_web filter
  change: |
    if a ``grpc-accept-encoding`` header is present it's passed as-is to the upstream and if it isn't ``grpc-accept-
    encoding:identity`` is sent instead. The header was always overwriten with ``grpc-accept-
    encoding:identity,deflate,gzip`` before.
- area: http
  change: |
    upstream protocol will now only be logged if an upstream stream was established.
- area: jwt_authn filter
  change: |
    added support of JWT time constraint verification with a clock skew (default to 60 seconds) and added a filter config
    field :ref:`clock_skew_seconds <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.clock_skew_seconds>`
    to configure it.
- area: listener
  change: |
    injection of the :ref:`TLS inspector <config_listener_filters_tls_inspector>` has been disabled by default. This feature
    is controlled by the runtime guard ``envoy.reloadable_features.disable_tls_inspector_injection``.
- area: lua
  change: |
    added ``always_wrap_body`` argument to ``body()`` API to always return a :ref:`buffer object
    <config_http_filters_lua_buffer_wrapper>` even if the body is empty.
- area: memory
  change: |
    enabled new tcmalloc with restartable sequences for aarch64 builds.
- area: mongo proxy metrics
  change: |
    swapped network connection remote and local closed counters previously set reversed (``cx_destroy_local_with_active_rq``
    and ``cx_destroy_remote_with_active_rq``).
- area: outlier detection
  change: |
    added :ref:`max_ejection_time <envoy_v3_api_field_config.cluster.v3.OutlierDetection.max_ejection_time>` to limit
    ejection time growth when a node stays unhealthy for extended period of time. By default :ref:`max_ejection_time
    <envoy_v3_api_field_config.cluster.v3.OutlierDetection.max_ejection_time>` limits ejection time to 5 minutes.
    Additionally, when the node stays healthy, ejection time decreases. See :ref:`ejection algorithm
    <arch_overview_outlier_detection_algorithm>` for more info. Previously, ejection time could grow without limit and never
    decreased.
- area: performance
  change: |
    improved performance when handling large HTTP/1 bodies.
- area: tcp_proxy
  change: |
    now waits for HTTP tunnel to be established before start streaming the downstream data, the runtime guard
    ``envoy.reloadable_features.http_upstream_wait_connect_response`` can be set to "false" to disable this behavior.
- area: tls
  change: |
    removed RSA key transport and SHA-1 cipher suites from the client-side defaults.
- area: watchdog
  change: |
    the watchdog action :ref:`abort_action <envoy_v3_api_msg_watchdog.v3alpha.AbortActionConfig>` is now the default action
    to terminate the process if watchdog kill / multikill is enabled.
- area: xds
  change: |
    to support TTLs, heartbeating has been added to xDS. As a result, responses that contain empty resources without
    updating the version will no longer be propagated to the subscribers. To undo this for VHDS (which is the only
    subscriber that wants empty resources), the ``envoy.reloadable_features.vhds_heartbeats`` can be set to "false".

bug_fixes:
- area: config
  change: |
    validate that upgrade configs have a non-empty :ref:`upgrade_type
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig.upgrade_type>`,
    fixing a bug where an errant "-" could result in unexpected behavior.
- area: dns
  change: |
    fixed a bug where custom resolvers provided in configuration were not preserved after network issues.
- area: dns_filter
  change: |
    correctly associate DNS response IDs when multiple queries are received.
- area: grpc mux
  change: |
    fixed sending node again after stream is reset when :ref:`set_node_on_first_message_only
    <envoy_api_field_core.ApiConfigSource.set_node_on_first_message_only>` is set.
- area: http
  change: |
    fixed URL parsing for HTTP/1.1 fully qualified URLs and connect requests containing IPv6 addresses.
- area: http
  change: |
    reject requests with missing required headers after filter chain processing.
- area: http
  change: |
    sending CONNECT_ERROR for HTTP/2 where appropriate during CONNECT requests.
- area: proxy_proto
  change: |
    fixed a bug where the wrong downstream address got sent to upstream connections.
- area: proxy_proto
  change: |
    fixed a bug where network filters would not have the correct ``downstreamRemoteAddress()`` when accessed from the
    ``StreamInfo``. This could result in incorrect enforcement of RBAC rules in the RBAC network filter (but not in the RBAC
    HTTP filter), or incorrect access log addresses from tcp_proxy.
- area: sds
  change: |
    fixed a bug that clusters sharing same sds target are marked active immediately.
- area: tls
  change: |
    fixed detection of the upstream connection close event.
- area: tls
  change: |
    fixed read resumption after triggering buffer high-watermark and all remaining request/response bytes are stored in the
    SSL connection's internal buffers.
- area: udp
  change: |
    fixed issue in which receiving truncated UDP datagrams would cause Envoy to crash.
- area: watchdog
  change: |
    touch the watchdog before most event loop operations to avoid misses when handling bursts of callbacks.

removed_config_or_runtime:
- area: dispatcher
  change: |
    removed legacy socket read/write resumption code path and runtime guard
    ``envoy.reloadable_features.activate_fds_next_event_loop``.
- area: ext_authz
  change: |
    removed auto ignore case in HTTP-based ``ext_authz`` header matching and the runtime guard
    ``envoy.reloadable_features.ext_authz_http_service_enable_case_sensitive_string_matcher``. To ignore case, set the
    :ref:`ignore_case <envoy_api_field_type.matcher.StringMatcher.ignore_case>` field to true.
- area: ext_authz
  change: |
    the deprecated field ``use_alpha`` is no longer supported and cannot be set anymore.
- area: http
  change: |
    removed ``envoy.reloadable_features.http1_flood_protection`` and legacy code path for turning flood protection off.
- area: http
  change: |
    removed ``envoy.reloadable_features.new_codec_behavior`` and legacy codecs.

new_features:
- area: compression
  change: |
    the :ref:`compressor <envoy_v3_api_msg_extensions.filters.http.compressor.v3.Compressor>` filter added support for
    compressing request payloads. Its configuration is unified with the :ref:`decompressor
    <envoy_v3_api_msg_extensions.filters.http.decompressor.v3.Decompressor>` filter with two new fields for different
    directions - :ref:`requests
    <envoy_v3_api_field_extensions.filters.http.compressor.v3.Compressor.request_direction_config>` and :ref:`responses
    <envoy_v3_api_field_extensions.filters.http.compressor.v3.Compressor.response_direction_config>`. The latter deprecates
    the old response-specific fields and, if used, roots the response-specific stats in
    ``<stat_prefix>.compressor.<compressor_library.name>.<compressor_library_stat_prefix>.response.*`` instead of
    ``<stat_prefix>.compressor.<compressor_library.name>.<compressor_library_stat_prefix>.*``.
- area: config
  change: |
    added ability to flush stats when the admin's :ref:`/stats endpoint <operations_admin_interface_stats>` is hit instead
    of on a timer via :ref:`stats_flush_on_admin <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.stats_flush_on_admin>`.
- area: config
  change: |
    added new runtime feature ``envoy.features.enable_all_deprecated_features`` that allows the use of all deprecated
    features.
- area: crash support
  change: |
    added the ability to dump L4 connection data on crash.
- area: formatter
  change: |
    added new :ref:`text_format_source <envoy_v3_api_field_config.core.v3.SubstitutionFormatString.text_format_source>`
    field to support format strings both inline and from a file.
- area: formatter
  change: |
    added support for custom date formatting to :ref:`%DOWNSTREAM_PEER_CERT_V_START%
    <config_access_log_format_downstream_peer_cert_v_start>` and :ref:`%DOWNSTREAM_PEER_CERT_V_END%
    <config_access_log_format_downstream_peer_cert_v_end>`, similar to :ref:`%START_TIME%
    <config_access_log_format_start_time>`.
- area: grpc
  change: |
    implemented header value syntax support when defining :ref:`initial metadata
    <envoy_v3_api_field_config.core.v3.GrpcService.initial_metadata>` for gRPC-based ``ext_authz`` :ref:`HTTP
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.grpc_service>` and :ref:`network
    <envoy_v3_api_field_extensions.filters.network.ext_authz.v3.ExtAuthz.grpc_service>` filters, and :ref:`ratelimit
    <envoy_v3_api_field_config.ratelimit.v3.RateLimitServiceConfig.grpc_service>` filters.
- area: grpc-json
  change: |
    added support for configuring :ref:`unescaping behavior
    <envoy_v3_api_field_extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder.url_unescape_spec>` for path
    components.
- area: hds
  change: |
    added support for delta updates in the :ref:`HealthCheckSpecifier
    <envoy_v3_api_msg_service.health.v3.HealthCheckSpecifier>`, making only the Endpoints and Health Checkers that changed
    be reconstructed on receiving a new message, rather than the entire HDS.
- area: health_check
  change: |
    added option to use :ref:`no_traffic_healthy_interval
    <envoy_v3_api_field_config.core.v3.HealthCheck.no_traffic_healthy_interval>` which allows a different no traffic
    interval when the host is healthy.
- area: http
  change: |
    added HCM :ref:`request_headers_timeout config field
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.request_headers_timeout>`
    to control how long a downstream has to finish sending headers before the stream is cancelled.
- area: http
  change: |
    added frame flood and abuse checks to the upstream HTTP/2 codec. This check is off by default and can be enabled by
    setting the ``envoy.reloadable_features.upstream_http2_flood_checks`` runtime key to true.
- area: http
  change: |
    added :ref:`stripping any port from host header
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.strip_any_host_port>`
    support.
- area: http
  change: |
    clusters added support for selecting HTTP/1 or HTTP/2 based on ALPN, configurable via :ref:`alpn_config
    <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.auto_config>` in the :ref:`http_protocol_options
    <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
- area: jwt_authn
  change: |
    added support for :ref:`per-route config <envoy_v3_api_msg_extensions.filters.http.jwt_authn.v3.PerRouteConfig>`.
- area: jwt_authn
  change: |
    changed config field :ref:`issuer <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.issuer>` to be
    optional to comply with JWT `RFC <https://tools.ietf.org/html/rfc7519#section-4.1.1>`_ requirements.
- area: kill_request
  change: |
    added new :ref:`HTTP kill request filter <config_http_filters_kill_request>`.
- area: listener
  change: |
    added an optional :ref:`default filter chain <envoy_v3_api_field_config.listener.v3.Listener.default_filter_chain>`. If
    this field is supplied, and none of the :ref:`filter_chains
    <envoy_v3_api_field_config.listener.v3.Listener.filter_chains>` matches, this default filter chain is used to serve the
    connection.
- area: listener
  change: |
    added back the :ref:`use_original_dst field <envoy_v3_api_field_config.listener.v3.Listener.use_original_dst>`.
- area: listener
  change: |
    added the :ref:`Listener.bind_to_port field <envoy_v3_api_field_config.listener.v3.Listener.bind_to_port>`.
- area: log
  change: |
    added a new custom flag ``%_`` to the log pattern to print the actual message to log, but with escaped newlines.
- area: lua
  change: |
    added ``downstreamDirectRemoteAddress()`` and ``downstreamLocalAddress()`` APIs to :ref:`streamInfo()
    <config_http_filters_lua_stream_info_wrapper>`.
- area: mongo_proxy
  change: |
    the list of commands to produce metrics for is now :ref:`configurable
    <envoy_v3_api_field_extensions.filters.network.mongo_proxy.v3.MongoProxy.commands>`.
- area: network
  change: |
    added a :ref:`transport_socket_connect_timeout config field
    <envoy_v3_api_field_config.listener.v3.FilterChain.transport_socket_connect_timeout>` for incoming connections
    completing transport-level negotiation, including TLS and ALTS hanshakes.
- area: overload
  change: |
    added :ref:`envoy.overload_actions.reduce_timeouts <config_overload_manager_overload_actions>` overload action to enable
    scaling timeouts down with load. Scaling support :ref:`is limited
    <envoy_v3_api_enum_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType>` to the HTTP connection and stream idle
    timeouts.
- area: ratelimit
  change: |
    added support for use of various :ref:`metadata <envoy_v3_api_field_config.route.v3.RateLimit.Action.metadata>` as a
    ratelimit action.
- area: ratelimit
  change: |
    added :ref:`disable_x_envoy_ratelimited_header <envoy_v3_api_msg_extensions.filters.http.ratelimit.v3.RateLimit>` option
    to disable ``X-Envoy-RateLimited`` header.
- area: ratelimit
  change: |
    added :ref:`body <envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.raw_body>` field to support custom response
    bodies for non-OK responses from the external ratelimit service.
- area: ratelimit
  change: |
    added :ref:`descriptor extensions <envoy_v3_api_field_config.route.v3.RateLimit.Action.extension>`.
- area: ratelimit
  change: |
    added :ref:`computed descriptors <envoy_v3_api_msg_extensions.rate_limit_descriptors.expr.v3.Descriptor>`.
- area: ratelimit
  change: |
    added :ref:`dynamic_metadata <envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.dynamic_metadata>` field to
    support setting dynamic metadata from the ratelimit service.
- area: router
  change: |
    added support for regex rewrites during HTTP redirects using :ref:`regex_rewrite
    <envoy_v3_api_field_config.route.v3.RedirectAction.regex_rewrite>`.
- area: sds
  change: |
    improved support for atomic :ref:`key rotations <xds_certificate_rotation>` and added configurable rotation triggers for
    :ref:`TlsCertificate <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.watched_directory>` and
    :ref:`CertificateValidationContext
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.watched_directory>`.
- area: signal
  change: |
    added an extension point for custom actions to run on the thread that has encountered a fatal error. Actions are
    configurable via :ref:`fatal_actions <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.fatal_actions>`.
- area: start_tls
  change: |
    added new :ref:`transport socket <envoy_v3_api_msg_extensions.transport_sockets.starttls.v3.StartTlsConfig>` which
    starts in clear-text but may programatically be converted to use tls.
- area: tcp
  change: |
    added a new :ref:`envoy.overload_actions.reject_incoming_connections <config_overload_manager_overload_actions>` action
    to reject incoming TCP connections.
- area: thrift_proxy
  change: |
    added a new :ref:`payload_passthrough
    <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.ThriftProxy.payload_passthrough>` option to skip decoding
    body in the Thrift message.
- area: tls
  change: |
    added support for RSA certificates with 4096-bit keys in FIPS mode.
- area: tracing
  change: |
    added :ref:`SkyWalking tracer <envoy_v3_api_msg_config.trace.v3.SkyWalkingConfig>`.
- area: tracing
  change: |
    added support for setting the hostname used when sending spans to a Zipkin collector using the :ref:`collector_hostname
    <envoy_v3_api_field_config.trace.v3.ZipkinConfig.collector_hostname>` field.
- area: xds
  change: |
    added support for resource TTLs. A TTL is specified on the :ref:`Resource <envoy_api_msg_Resource>`. For SotW, a
    :ref:`Resource <envoy_api_msg_Resource>` can be embedded in the list of resources to specify the TTL.

deprecated:
- area: cluster
  change: |
    HTTP configuration for upstream clusters has been reworked. HTTP-specific configuration is now done in the new
    :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message, configured via
    the cluster's :ref:`extension_protocol_options
    <envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`. This replaces explicit HTTP
    configuration in cluster config, including :ref:`upstream_http_protocol_options
    <envoy_v3_api_field_config.cluster.v3.Cluster.upstream_http_protocol_options>` :ref:`common_http_protocol_options
    <envoy_v3_api_field_config.cluster.v3.Cluster.common_http_protocol_options>` :ref:`http_protocol_options
    <envoy_v3_api_field_config.cluster.v3.Cluster.http_protocol_options>` :ref:`http2_protocol_options
    <envoy_v3_api_field_config.cluster.v3.Cluster.http2_protocol_options>` and :ref:`protocol_selection
    <envoy_v3_api_field_config.cluster.v3.Cluster.protocol_selection>`. Examples of before-and-after configuration can be
    found in the :ref:`http_protocol_options docs <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` and
    all of Envoy's example configurations have been updated to the new style of config.
- area: compression
  change: |
    the fields :ref:`content_length <envoy_v3_api_field_extensions.filters.http.compressor.v3.Compressor.content_length>`,
    :ref:`content_type <envoy_v3_api_field_extensions.filters.http.compressor.v3.Compressor.content_type>`,
    :ref:`disable_on_etag_header
    <envoy_v3_api_field_extensions.filters.http.compressor.v3.Compressor.disable_on_etag_header>`,
    :ref:`remove_accept_encoding_header
    <envoy_v3_api_field_extensions.filters.http.compressor.v3.Compressor.remove_accept_encoding_header>` and
    :ref:`runtime_enabled <envoy_v3_api_field_extensions.filters.http.compressor.v3.Compressor.runtime_enabled>` of the
    :ref:`Compressor <envoy_v3_api_msg_extensions.filters.http.compressor.v3.Compressor>` message have been deprecated in
    favor of :ref:`response_direction_config
    <envoy_v3_api_field_extensions.filters.http.compressor.v3.Compressor.response_direction_config>`.
- area: formatter
  change: |
    :ref:`text_format <envoy_v3_api_field_config.core.v3.SubstitutionFormatString.text_format>` is now deprecated in favor
    of :ref:`text_format_source <envoy_v3_api_field_config.core.v3.SubstitutionFormatString.text_format_source>`. To migrate
    existing text format strings, use the :ref:`inline_string <envoy_v3_api_field_config.core.v3.DataSource.inline_string>`
    field.
- area: gzip
  change: |
    :ref:`HTTP Gzip filter <config_http_filters_gzip>` is rejected now unless explicitly allowed with :ref:`runtime override
    <config_runtime_deprecation>` ``envoy.deprecated_features.allow_deprecated_gzip_http_filter`` set to ``true``. Use the
    :ref:`compressor filter <config_http_filters_compressor>`.
- area: listener
  change: |
    :ref:`use_proxy_proto <envoy_v3_api_field_config.listener.v3.FilterChain.use_proxy_proto>` has been deprecated in favor
    of adding a :ref:`PROXY protocol listener filter <config_listener_filters_proxy_protocol>` explicitly.
- area: logging
  change: |
    the ``--log-format-prefix-with-location`` option is removed.
- area: ratelimit
  change: |
    the :ref:`dynamic metadata <envoy_v3_api_field_config.route.v3.RateLimit.Action.dynamic_metadata>` action is deprecated
    in favor of the more generic :ref:`metadata <envoy_v3_api_field_config.route.v3.RateLimit.Action.metadata>` action.
- area: stats
  change: |
    the ``--use-fake-symbol-table`` option is removed.
- area: tracing
  change: |
    OpenCensus :ref:`Zipkin configuration <envoy_api_field_config.trace.v2.OpenCensusConfig.zipkin_exporter_enabled>` is now
    deprecated, the preferred Zipkin export is via Envoy's :ref:`native Zipkin tracer
    <envoy_v3_api_msg_config.trace.v3.ZipkinConfig>`.
date: September 12, 2016

changes:
- area: envoy
  change: |
    initial open source release.
date: March 22, 2023

bug_fixes:
- area: dependency
  change: |
    update Wasmtime -> 6.0.1 to resolve CVE-2023-26489, CVE-2023-27477.
date: February 24, 2023

bug_fixes:
- area: dependency
  change: |
    update Kafka to resolve CVE-2023-25194.

new_features:
- area: docker
  change: |
    unify published images as tag variants. For example, ``envoyproxy/envoy-dev`` is now available
    as ``envoyproxy/envoy:dev``.
date: March 7, 2017

changes:
- area: cds
  change: |
    :ref:`Cluster discovery service (CDS) API <v1.5:config_cluster_manager_cds>`.
- area: outlier_detection
  change: |
    :ref:`Outlier detection <v1.5:arch_overview_outlier_detection>` (passive health checking).
- area: config
  change: |
    Envoy configuration is now checked against a JSON schema.
- area: routing
  change: |
    :ref:`Ring hash <v1.5:arch_overview_load_balancing_types>` consistent load balancer, as well as HTTP consistent hash
    routing based on a policy.
- area: rate_limiting
  change: |
    Vastly :ref:`enhanced global rate limit configuration <v1.5:arch_overview_rate_limit>` via the HTTP rate limiting
    filter.
- area: routing
  change: |
    HTTP routing to a cluster retrieved from a header.
- area: routing
  change: |
    Weighted cluster HTTP routing.
- area: routing
  change: |
    Auto host rewrite during HTTP routing.
- area: matching
  change: |
    Regex header matching during HTTP routing.
- area: logging
  change: |
    HTTP access log runtime filter.
- area: lightstep
  change: |
    LightStep tracer :ref:`parent/child span association <v1.5:arch_overview_tracing>`.
- area: routing
  change: |
    :ref:`Route discovery service (RDS) API <v1.5:config_http_conn_man_rds>`.
- area: routing
  change: |
    HTTP router :ref:`x-envoy-upstream-rq-timeout-alt-response header
    <v1.5:config_http_filters_router_x-envoy-upstream-rq-timeout-alt-response>` support.
- area: listener
  change: |
    ``use_original_dst`` and ``bind_to_port`` :ref:`listener options <v1.5:config_listeners>` (useful for iptables based
    transparent proxy support).
- area: routing
  change: |
    TCP proxy filter :ref:`route table support <v1.5:config_network_filters_tcp_proxy>`.
- area: stats
  change: |
    Configurable stats flush interval.
- area: ssl
  change: |
    Various :ref:`third party library upgrades <v1.5:install_requirements>`, including using BoringSSL as the default SSL
    provider.
- area: http2
  change: |
    No longer maintain closed HTTP/2 streams for priority calculations. Leads to substantial memory savings for large
    meshes.
- area: envoy
  change: |
    Numerous small changes and fixes not listed here.
date: February 25, 2021

bug_fixes:
- area: jwt_authn
  change: |
    reject requests with a proper error if JWT has the wrong issuer when allow_missing is used. Before this change, the
    requests are accepted.
- area: overload
  change: |
    fix a bug that can cause use-after-free when one scaled timer disables another one with the same duration.
date: July 27, 2022

bug_fixes:
- area: repo
  change: |
    fix version to resolve release issue.
date: September 29, 2020

changes:
- area: test
  change: |
    fix flaky test.
date: July 14, 2023

bug_fixes:
- area: original_dst
  change: |
    Fixes an issue with the ORIGINAL_DST cluster cleanup timer lifetime, which
    can occur if the cluster is removed while the timer is armed.
- area: http2
  change: |
    Fix memory leak in nghttp2 when scheduled requests are cancelled due to the ``GOAWAY`` frame being received from the
    upstream service. Fix `CVE-2023-35945 <https://nvd.nist.gov/vuln/detail/CVE-2023-35945>`_.
date: August 24, 2021

minor_behavior_changes:
- area: http
  change: |
    reject requests with \#fragment in the URI path. The fragment is not allowed to be part of request URI according to
    RFC3986 (3.5), RFC7230 (5.1) and RFC 7540 (8.1.2.3). Rejection of requests can be changed to stripping the \#fragment
    instead by setting the runtime guard ``envoy.reloadable_features.http_reject_path_with_fragment`` to false. This
    behavior can further be changed to the deprecated behavior of keeping the fragment by setting the runtime guard
    ``envoy.reloadable_features.http_strip_fragment_from_path_unsafe_if_disabled``. This runtime guard must only be set to
    false when existing non-compliant traffic relies on \#fragment in URI. When this option is enabled, Envoy request
    authorization extensions may be bypassed. This override and its associated behavior will be decommissioned after the
    standard deprecation period.

bug_fixes:
- area: ext_authz
  change: |
    fix the ext_authz filter to correctly merge multiple same headers using the ',' as separator in the check request to the
    external authorization service.
date: July 15, 2022

behavior_changes:
- area: tls-inspector
  change: |
    the listener filter tls inspector's stats ``connection_closed`` and ``read_error`` are removed. New stats are introduced
    for listener, ``downstream_peek_remote_close`` and ``read_error``, in :ref:`listener stats <config_listener_stats>`.
- area: config
  change: |
    multiple SDS resources of multiple clusters or listeners are sent in a single SDS requests, instead of multiple SDS
    requests. This behavioral change can be reverted by setting ``envoy.reloadable_features.combine_sds_requests`` to
    ``false``.
- area: stats listener
  change: |
    fixed metric tag extraction so that :ref:`stat_prefix <envoy_v3_api_field_config.listener.v3.Listener.stat_prefix>` is
    properly extracted. This changes the Prometheus name from ``envoy_listener_myprefix_downstream_cx_overflow{}`` to
    ``envoy_listener_downstream_cx_overflow{envoy_listener_address="myprefix"}``. This does not affect the Prometheus name
    if ``stat_prefix`` is not set.
- area: stats listener
  change: |
    fixed metric tag extraction so that ``worker_id`` is properly extracted from the listener stats. This changes the
    Prometheus name from ``envoy_listener_worker_1_downstream_cx_active{envoy_listener_address="0.0.0.0_10000"}`` to
    ``envoy_listener_downstream_cx_active{envoy_listener_address="0.0.0.0_10000", envoy_worker_id="1"}``.
- area: stats server
  change: |
    fixed metric tag extraction so that ``worker_id`` is properly extracted fromt the server stats. This changes the
    Prometheus name from ``envoy_server_worker_1_watchdog_miss{}`` to ``envoy_server_watchdog_miss{envoy_worker_id="1"}``.
- area: stats thrift_proxy
  change: |
    fixed metric tag extraction so that :ref:`stat_prefix
    <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.ThriftProxy.stat_prefix>` is properly extracted. This
    changes the Prometheus name from ``envoy_thrift_myprefix_request{}`` to
    ``envoy_thrift_request{envoy_thrift_prefix="myprefix"}``.
- area: stats redis_proxy
  change: |
    fixed metric tag extraction so that :ref:`stat_prefix
    <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.stat_prefix>` is properly extracted. This
    changes the Prometheus name from ``envoy_redis_myprefix_command_pttl_latency_sum{}`` to
    ``envoy_redis_command_pttl_latency_sum{envoy_redis_prefix="myprefix"}``.
- area: router
  change: |
    updated all HTTP filters to get per-filter config by the :ref:`HTTP filter config name
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`. If there is no entry
    referred by the filter config name, the canonical filter name (e.g., ``envoy.filters.http.buffer`` for the HTTP buffer
    filter) will be used for the backwards compatibility.
- area: router
  change: |
    weighted cluster's :ref:`total_weight <envoy_v3_api_field_config.route.v3.WeightedCluster.total_weight>` is now
    optional. If not set, Envoy will no longer validate that all weights add up to 100. The sum of :ref:`weights
    <envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.weight>` across all entries in the clusters array must
    add up to the :ref:`total_weight <envoy_v3_api_field_config.route.v3.WeightedCluster.total_weight>`, when it's greater
    than 0.

minor_behavior_changes:
- area: thrift
  change: |
    keep downstream connection if the response is completed without underflow.
- area: tls
  change: |
    if both :ref:`match_subject_alt_names
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_subject_alt_names>` and
    :ref:`match_typed_subject_alt_names
    <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>` are
    specified, the former (deprecated) field is ignored. Previously, setting both fields would result in an error.
- area: tls
  change: |
    removed SHA-1 and RSA key transport cipher suites from the server-side defaults.
- area: http
  change: |
    the behavior of the :ref:`timeout <envoy_v3_api_field_config.core.v3.KeepaliveSettings.timeout>` field has been modified
    to extend the timeout when *any* frame is received on the owning HTTP/2 connection. This negates the effect of head-of-
    line (HOL) blocking for slow connections. If any frame is received the assumption is that the connection is working.
    This behavior change can be reverted by setting ``envoy.reloadable_features.http2_delay_keepalive_timeout`` to
    ``false``.
- area: http
  change: |
    changing the behavior for ``CONNECT`` and upgrade requests over HTTP/1.1 to not delay close. This behavioral change can
    be reverted by setting ``envoy.reloadable_features.no_delay_close_for_upgrades`` to ``false``.
- area: http
  change: |
    the :ref:`dynamo filter <config_http_filters_dynamo>` has been moved to :ref:`contrib images <install_contrib>`.
- area: http-cache
  change: |
    HTTP cache filter ``getCache`` interface changed from returning a reference to returning a shared_ptr - any third-party
    implementations of this interface will need to be updated accordingly. See changes to ``simple_http_cache.cc`` and
    ``simple_http_cache.h`` in `PR21114 <https://github.com/envoyproxy/envoy/pull/21114>`_ for example.
- area: lua
  change: |
    export symbols of LuaJit by default on Linux. This is useful in cases where you have a lua script that loads shared
    object libraries, such as those installed via luarocks.
- area: admin
  change: |
    changed default regex engine for ``/stats?filter=`` from ``std::regex`` to RE2, improving filtering speed 20x.
- area: skywalking
  change: |
    use request path as operation name of ``ENTRY``/``EXIT`` spans.
- area: skywalking
  change: |
    use upstream host address as ``addressUsedAtClient`` in propagation header.
- area: dns
  change: |
    allow propagating DNS responses with no records back to callers like ``strict_dns`` cluster, guarded by
    ``envoy.reloadable_features.cares_accept_nodata``.
- area: local_ratelimit
  change: |
    ``local_ratelimit`` will consume tokens of all matched descriptors sorted by tokens per second. This behavioral change
    can be reverted by setting runtime guard ``envoy.reloadable_features.http_local_ratelimit_match_all_descriptors`` to
    ``false``.
- area: router
  change: |
    get route config factories by the configuration proto full names by default. This behavior change can be reverted by
    setting the ``envoy.reloadable_features.get_route_config_factory_by_type`` runtime flag to ``false``.
- area: lua
  change: |
    lua ``respond`` api will call ``sendLocalReply`` instead of ``encodeHeaders`` and ``encodeData``. This means that
    encoder filters will be correctly invoked, including adding configured response headers, etc. This behavioral change can
    be reverted by setting runtime guard ``envoy.reloadable_features.lua_respond_with_send_local_reply`` to ``false``.
- area: logging
  change: |
    changed flag ``--log-format-escaped`` to only log one trailing newline per log line.
- area: logging
  change: |
    changed category name for access log filter extensions to ``envoy.access_loggers.extension_filters``.
- area: filter state
  change: |
    revert to respecting the life time of the filter state objects to be bound to the original stream and make sharing
    filter state objects with the upstream info explicit via an extra flag in ``setData``.
- area: tracers
  change: |
    remove unnecessary ``spawnChild`` annotations in OpenCensus tracer.
- area: conn pool
  change: |
    changed HTTP/2 connection pooling and the :ref:`ALPN pool
    <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.auto_config>` to remember the number of streams
    allowed by the endpoint and cap multiplexed streams for subsequent connections based on that. With that working,
    defaulted the ALPN pool to assume HTTP/2 will work, as it will only incur a latency hit once until the TLS handshake is
    complete, and then will cache that the effective stream limit is ``1``. This behavioral change can be revered by setting
    ``envoy.reloadable_features.allow_concurrency_for_alpn_pool`` to ``false``.
- area: network
  change: |
    the :ref:`client ssl auth filter <config_network_filters_client_ssl_auth>` has been moved to :ref:`contrib images
    <install_contrib>`.
- area: tcp_proxy
  change: |
    added support for command operators in :ref:`TunnelingConfig hostname
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.hostname>` to dynamically set
    upstream hostname.

bug_fixes:
- area: grpc_json_transcoder
  change: |
    respond with a error messsage if a proto message is too deep (>64). Before the fix the response was an empty JSON.
- area: http
  change: |
    fixed HTTP/2 CONNECT to be RFC compliant, rather than following the abandoned extended connect draft. This behavioral
    change can be reverted by setting runtime guard ``envoy.reloadable_features.use_rfc_connect`` to ``false``.
- area: decompression
  change: |
    fixed CVE-2022-29225: Decompressors can be zip bombed. Previously decompressors were susceptible to memory inflation in
    takes in which specially crafted payloads could cause a large amount of memory usage by Envoy. The max inflation payload
    size is now limited. This change can be reverted via the
    ``envoy.reloadable_features.enable_compression_bomb_protection`` runtime flag.
- area: router
  change: |
    fixed CVE-2022-29227: Internal redirect crash for requests with body/trailers. Envoy would previously crash in some
    cases when processing internal redirects for requests with bodies or trailers if the redirect prompts an Envoy-generated
    local reply.
- area: oauth
  change: |
    fixed CVE-2022-29226: oauth filter allows trivial bypass. The OAuth filter implementation does not include a mechanism
    for validating access tokens, so by design when the HMAC signed cookie is missing a full authentication flow should be
    triggered. However, the current implementation assumes that access tokens are always validated thus allowing access in
    the presence of any access token attached to the request.
- area: oauth
  change: |
    fixed CVE-2022-29228: oauth filter calls ``continueDecoding()`` from within ``decodeHeaders()``. The OAuth filter would
    try to invoke the remaining filters in the chain after emitting a local response, which triggers an ``ASSERT()`` in
    newer versions and corrupts memory on earlier versions.
- area: health_check
  change: |
    fixed CVE-2022-29224: Segfault in ``GrpcHealthCheckerImpl``. An attacker-controlled upstream server that is health
    checked using gRPC health checking can crash Envoy via a null pointer dereference in certain circumstances.
- area: runtime
  change: |
    fixed a bug where ``envoy.restart_features.no_runtime_singleton`` was inverted. Runtime singleton status is now guarded
    by non-inverted ``envoy.restart_features.remove_runtime_singleton``.
- area: tcp_proxy
  change: |
    fixed an issue using the cluster wide ``CONNECT`` termination so it will successfully proxy payloads.
- area: upstream
  change: |
    fixed the ``LOGICAL_DNS`` and ``STRICT_DNS`` clusters to work for IPv6.
- area: aws_lambda
  change: |
    fixed the AWS cross account lambda function invocation issue.
- area: tls
  change: |
    fixed a bug where an expired certificate sets a big number for ``days_until_expiration``. After this fix, ``0`` is set.

removed_config_or_runtime:
- area: compressor
  change: |
    removed ``envoy.reloadable_features.fix_added_trailers`` and legacy code paths.
- area: dns
  change: |
    removed ``envoy.reloadable_features.use_dns_ttl`` and legacy code paths.
- area: ext_authz
  change: |
    removed ``envoy.reloadable_features.http_ext_authz_do_not_skip_direct_response_and_redirect`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.correct_scheme_and_xfp`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.validate_connect`` and legacy code paths.
- area: tcp_proxy
  change: |
    removed ``envoy.reloadable_features.new_tcp_connection_pool`` and legacy code paths.
- area: conn pool
  change: |
    removed ``envoy.reloadable_features.conn_pool_delete_when_idle`` and legacy code paths.
- area: runtime
  change: |
    removed ``envoy.restart_features.no_runtime_singleton`` and replaced with
    ``envoy.restart_features.remove_runtime_singleton``.
- area: udp listener
  change: |
    removed ``envoy.reloadable_features.udp_listener_updates_filter_chain_in_place`` and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.skip_dispatching_frames_for_closed_connection`` and legacy code paths.

new_features:
- area: lua
  change: |
    added new function :ref:`timestampString <config_http_filters_lua_stream_handle_api_timestamp_string>` returning the
    time since epoch as a string. Supported resolutions are millisecond and microsecond.
- area: access_log
  change: |
    added formatters for :ref:`UPSTREAM_METADATA<config_access_log_format_upstream_host_metadata>` and
    :ref:`METADATA(UPSTREAM_HOST)<envoy_v3_api_msg_extensions.formatter.metadata.v3.Metadata>`.
- area: access_log
  change: |
    added new ``access_log`` command operators to retrieve upstream connection information change: ``%UPSTREAM_PROTOCOL%``,
    ``%UPSTREAM_PEER_SUBJECT%``, ``%UPSTREAM_PEER_ISSUER%``, ``%UPSTREAM_TLS_SESSION_ID%``, ``%UPSTREAM_TLS_CIPHER%``,
    ``%UPSTREAM_TLS_VERSION%``, ``%UPSTREAM_PEER_CERT_V_START%``, ``%UPSTREAM_PEER_CERT_V_END%``, ``%UPSTREAM_PEER_CERT%``
    and ``%UPSTREAM_FILTER_STATE%``.
- area: open_telemetry
  change: |
    added :ref:`resource_attributes
    <envoy_v3_api_field_extensions.access_loggers.open_telemetry.v3.OpenTelemetryAccessLogConfig.resource_attributes>`
    configuration to OpenTelemetry.
- area: dns_resolver
  change: |
    added :ref:`include_unroutable_families
    <envoy_v3_api_field_extensions.network.dns_resolver.apple.v3.AppleDnsResolverConfig.include_unroutable_families>` to the
    Apple DNS resolver.
- area: dns_resolver
  change: |
    added support for multiple addresses. This is most valuable when used in conjunction with :ref:`ALL
    <envoy_v3_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.ALL>` enabling full happy eyeballs support for Envoy
    (see detailed documentation :ref:`here <arch_overview_conn_pool>` but will also result in trying multiple addresses for
    resolvers doing only IPv4 or IPv6. This behavioral change can be temporarily disabled by setting runtime guard
    ``envoy.restart_features.remove_runtime_singleton`` to ``false``.
- area: dns_resolver
  change: |
    added :ref:`GetAddrInfoDnsResolverConfig
    <envoy_v3_api_msg_extensions.network.dns_resolver.getaddrinfo.v3.GetAddrInfoDnsResolverConfig>`, a new DNS resolver that
    uses the system's ``getaddrinfo()`` function to resolve DNS. This was primarily added for use on Android but can also be
    used in other situations in which the system resolver is desired.
- area: dubbo_proxy
  change: |
    added :ref:`dynamic routes discovery <envoy_v3_api_field_extensions.filters.network.dubbo_proxy.v3.DubboProxy.drds>`
    support to dubbo proxy.
- area: ext_proc
  change: |
    added support for per-route :ref:`grpc_service
    <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExtProcOverrides.grpc_service>`.
- area: http
  change: |
    added new :ref:`file_system_buffer <config_http_filters_file_system_buffer>` HTTP filter.
- area: http
  change: |
    added a :ref:`send_fully_qualified_url
    <envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.send_fully_qualified_url>` configuration option to send absolute
    URLs for HTTP/1.1.
- area: http
  change: |
    preserve case header formatter support innner formatter on Envoy headers in :ref:`formatter_type_on_envoy_headers
    <envoy_v3_api_field_extensions.http.header_formatters.preserve_case.v3.PreserveCaseFormatterConfig.formatter_type_on_envoy_headers>`.
- area: http3
  change: |
    added :ref:`early_data_policy <envoy_v3_api_field_config.route.v3.RouteAction.early_data_policy>` extension to allow
    upstream HTTP/3 sending requests over early data. If no extension is configured, HTTP/3 pool will send safe requests as
    early data to the host if the pool already cached 0-RTT credentials of that host. If those requests fail and the
    underlying connection pool supports TCP fallback, the request may be retried automatically. If the :ref:`default
    extension <envoy_v3_api_msg_extensions.early_data.v3.DefaultEarlyDataPolicy>` is configured, no requests are allowed to
    be sent as early data. Note that if any customized extension configures non-safe requests to be allowed over early data,
    the Envoy will not automatically retry them. If desired, explicitly config their :ref:`retry_policy
    <envoy_v3_api_field_config.route.v3.RouteAction.retry_policy>`. Sending early data requires both
    ``envoy.reloadable_features.conn_pool_new_stream_with_early_data_and_http3`` and
    ``envoy.reloadable_features.http3_sends_early_data`` runtime flags to be set to ``true``.
- area: listener
  change: |
    added :ref:`dynamic listener filter configuration
    <envoy_v3_api_field_config.listener.v3.ListenerFilter.config_discovery>` for listener filters. This dynamic listener
    filter configuration is only supported by TCP listeners.
- area: redis
  change: |
    added support for multiple passwords to the redis proxy. See :ref:`downstream_auth_passwords
    <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.downstream_auth_passwords>`.
- area: thrift
  change: |
    added :ref:`close_downstream_on_upstream_error
    <envoy_v3_api_field_extensions.filters.network.thrift_proxy.router.v3.Router.close_downstream_on_upstream_error>` flag
    to router to control downstream local close.
- area: thrift
  change: |
    added support for access logging for :ref:`Thrift Proxy <config_network_filters_thrift_proxy>`.
- area: thrift
  change: |
    added support for preserving header keys. See :ref:`header_keys_preserve_case
    <envoy_v3_api_field_extensions.filters.network.thrift_proxy.v3.ThriftProxy.header_keys_preserve_case>`.
- area: thrift
  change: |
    added support for propogating connection draining if local replies try to end downstream. Can be enabled by setting the
    runtime flag ``envoy.reloadable_features.thrift_connection_draining`` to true.
- area: thrift
  change: |
    added ``onLocalReply`` support to inform filters of local replies.
- area: thrift
  change: |
    introduced thrift configurable encoder and bidirectional filters, which allows peeking and modifying the thrift response
    message.
- area: on_demand
  change: |
    :ref:`OnDemand <envoy_v3_api_msg_extensions.filters.http.on_demand.v3.OnDemand>` got extended to hold configuration for
    on-demand cluster discovery. A similar message for :ref:`per-route configuration
    <envoy_v3_api_msg_extensions.filters.http.on_demand.v3.PerRouteConfig>` is also added.
- area: proxy_protcol
  change: |
    added :ref:`allow_requests_without_proxy_protocol
    <envoy_v3_api_field_extensions.filters.listener.proxy_protocol.v3.ProxyProtocol.allow_requests_without_proxy_protocol>`
    to allow requests without proxy protocol on the listener from trusted downstreams as an opt-in flag.
- area: udp
  change: |
    added :ref:`udp_packet_packet_writer_config
    <envoy_v3_api_field_config.listener.v3.UdpListenerConfig.udp_packet_packet_writer_config>` config to specify the UDP
    packet writer factory.
- area: build
  change: |
    enabled building arm64 envoy-distroless and envoy-tools :ref:`docker images <install_binaries>`.
- area: ratelimit
  change: |
    added support for :ref:`masked_remote_address
    <envoy_v3_api_field_config.route.v3.RateLimit.Action.masked_remote_address>`.
- area: ratelimit
  change: |
    added support for :ref:`HTTP matching input functions <arch_overview_matching_api>` as descriptor producers.
- area: http
  change: |
    added :ref:`cluster_header <envoy_v3_api_field_config.route.v3.RouteAction.RequestMirrorPolicy.cluster_header>` in
    :ref:`request_mirror_policies <envoy_v3_api_field_config.route.v3.RouteAction.request_mirror_policies>` to allow routing
    shadow request to the cluster specified in the request_header.
- area: upstream
  change: |
    added :ref:`internal upstream transport
    <envoy_v3_api_msg_extensions.transport_sockets.internal_upstream.v3.InternalUpstreamTransport>` for passing metadata and
    filter state across the user space sockets and the internal listeners.
- area: router
  change: |
    added :ref:`keep_empty_value <envoy_v3_api_field_config.core.v3.HeaderValueOption.keep_empty_value>` to allow keeping
    empty values in custom headers.
- area: dubbo_proxy
  change: |
    added :ref:`metadata_match <envoy_v3_api_field_extensions.filters.network.dubbo_proxy.v3.RouteAction.metadata_match>`
    support to the dubbo proxy.
- area: network
  change: |
    extended conection balancer with :ref:`extend balance
    <envoy_v3_api_field_config.listener.v3.Listener.ConnectionBalanceConfig.extend_balance>`, and added :ref:`Dlb connection
    balancer <envoy_v3_api_msg_extensions.network.connection_balance.dlb.v3alpha.Dlb>` to use `DLB
    <https://www.intel.com/content/www/us/en/download/686372/intel-dynamic-load-balancer.html>`_ hardware to balance.
- area: router
  change: |
    added :ref:`stat_prefix <envoy_v3_api_field_config.route.v3.Route.stat_prefix>` support to generate route level
    statistics.
- area: router
  change: |
    added :ref:`INTERNAL_SERVER_ERROR option
    <envoy_v3_api_enum_value_config.route.v3.RouteAction.ClusterNotFoundResponseCode.INTERNAL_SERVER_ERROR>` to return
    status code 500 when the configured cluster is not found.
- area: matching
  change: |
    added support for matching authenticated inputs in network and HTTP matching data.
- area: rbac
  change: |
    added :ref:`matcher <arch_overview_rbac_matcher>` for selecting connections and requests to different actions.
- area: http
  change: |
    added :ref:`treat_missing_header_as_empty
    <envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>` to allow header match rule to treat
    the header value as empty and apply the match rule when the header is missing.
- area: thrift
  change: |
    added ``validate_clusters`` in :ref:`RouteConfiguration
    <envoy_v3_api_msg_extensions.filters.network.thrift_proxy.v3.RouteConfiguration>` to override the default behavior of
    cluster validation.
- area: admin
  change: |
    added compile-time option ``--define=admin_html=disabled`` to disable HTML home page.
- area: router
  change: |
    added :ref:`ignore_port_in_host_matching
    <envoy_v3_api_field_config.route.v3.RouteConfiguration.ignore_port_in_host_matching>`. When set to ``true``, port number
    (if any) in host header is ignored during host matching.
- area: router
  change: |
    added :ref:`ignore_path_parameters_in_path_matching
    <envoy_v3_api_field_config.route.v3.RouteConfiguration.ignore_path_parameters_in_path_matching>`. When set to ``true``,
    path-parameters(`rfc1808 <https://datatracker.ietf.org/doc/html/rfc1808>`_) is ignored during path matching. added
    :ref:`ignore_path_parameters_in_path_matching
    <envoy_v3_api_field_config.route.v3.RouteConfiguration.ignore_path_parameters_in_path_matching>`. When set to ``true``,
    path-parameters(rfc1808) is ignored during path matching.
- area: examples
  change: |
    fixed issues with documentation/compositions usage of ``docker-compose pull``.
- area: examples
  change: |
    updated many examples and added dependency checking.

deprecated:
- area: dubbo_proxy
  change: |
    deprecated :ref:`old dubbo route config
    <envoy_v3_api_field_extensions.filters.network.dubbo_proxy.v3.DubboProxy.route_config>`. Please use :ref:`multiple route
    config <envoy_v3_api_field_extensions.filters.network.dubbo_proxy.v3.DubboProxy.multiple_route_config>` or :ref:`DRDS
    <envoy_v3_api_field_extensions.filters.network.dubbo_proxy.v3.DubboProxy.drds>` first.
- area: http
  change: |
    deprecated the short name ``preserve_case`` for the header formatter extension in favor of the fully-qualified name
    ``envoy.http.stateful_header_formatters.preserve_case``.
- area: matching
  change: |
    :ref:`google_re2 <envoy_v3_api_field_type.matcher.v3.RegexMatcher.google_re2>` has been deprecated. A default regex
    engine can be set using :ref:`default_regex_engine
    <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.default_regex_engine>`.
- area: redis
  change: |
    deprecated :ref:`downstream_auth_password
    <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.downstream_auth_password>`. Please use
    :ref:`downstream_auth_passwords
    <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.downstream_auth_passwords>`.
- area: lua
  change: |
    deprecated :ref:`inline_code <envoy_v3_api_field_extensions.filters.http.lua.v3.Lua.inline_code>`. Please use
    :ref:`default_source_code <envoy_v3_api_field_extensions.filters.http.lua.v3.Lua.default_source_code>`.
date: December 10, 2019

changes:
- area: http
  change: |
    fixed CVE-2019-18801 by allocating sufficient memory for request headers.
- area: http
  change: |
    fixed CVE-2019-18802 by implementing stricter validation of HTTP/1 headers.
- area: http
  change: |
    trim LWS at the end of header keys, for correct HTTP/1.1 header parsing.
- area: http
  change: |
    added strict authority checking. This can be reversed temporarily by setting the runtime feature
    ``envoy.reloadable_features.strict_authority_validation`` to false.
- area: route config
  change: |
    fixed CVE-2019-18838 by checking for presence of host/path headers.
date: July 25, 2023

minor_behavior_changes:
- area: http
  change: |
    Envoy will now lower case scheme values by default. This behaviorial change can be temporarily reverted
    by setting runtime guard ``envoy.reloadable_features.lowercase_scheme`` to ``false``.

bug_fixes:
- area: cors
  change: |
    Fix a use-after-free bug that occurs in the CORS filter if the ``origin`` header is removed between
    request header decoding and response header encoding.

    Fix `CVE-2023-35943 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-mc6h-6j9x-v3gq>`_.
- area: http
  change: |
    Switched Envoy internal scheme checks from case sensitive to case insensitive. This behaviorial change can be temporarily
    reverted by setting runtime guard ``envoy.reloadable_features.handle_uppercase_scheme`` to ``false``.

    Fix `CVE-2023-35944 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-pvgm-7jpg-pw5g>`_.
- area: opentelemetry/grpc/access log
  change: |
    Fixed a bug in the open telemetry access logger. This logger now uses the
    server scope for stats instead of the listener's global scope. This fixes a
    use-after-free that can occur if the listener is drained but the cached
    gRPC access logger uses the listener's global scope for stats.

    Fix `CVE-2023-35942 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-69vr-g55c-v2v4>`_.
- area: oauth2
  change: |
    Fixed a cookie validator bug that HMAC caluation could be same for different payloads.

    This prevents malicious clients from constructing credentials with permanent validity in some specific scenarios.

    Fix `CVE-2023-35941 <https://github.com/envoyproxy/envoy/security/advisories/GHSA-7mhv-gr67-hq55>`_.

new_features:
- area: tls
  change: |
    Added FIPS compliant build for arm64.
date: June 16, 2022

bug_fixes:
- area: docker
  change: |
    update Docker images (``distroless`` -> ``d65ac1a``) to resolve CVE issues in container packages.
date: July 7, 2020

behavior_changes:
- area: build
  change: |
    official released binary is now built on Ubuntu 18.04, requires glibc >= 2.27.
- area: client_ssl_auth
  change: |
    the ``auth_ip_white_list`` stat has been renamed to :ref:`auth_ip_allowlist
    <config_network_filters_client_ssl_auth_stats>`.
- area: header to metadata
  change: |
    on_header_missing rules with empty values are now rejected (they were skipped before).
- area: router
  change: |
    path_redirect now keeps query string by default. This behavior may be reverted by setting runtime feature
    ``envoy.reloadable_features.preserve_query_string_in_path_redirects`` to false.
- area: tls
  change: |
    fixed a bug where wilcard matching for "\*.foo.com" also matched domains of the form "a.b.foo.com". This behavior can be
    temporarily reverted by setting runtime feature ``envoy.reloadable_features.fix_wildcard_matching`` to false.

minor_behavior_changes:
- area: access loggers
  change: |
    applied existing buffer limits to access logs, as well as :ref:`stats <config_access_log_stats>` for logged / dropped
    logs. This can be reverted temporarily by setting runtime feature
    ``envoy.reloadable_features.disallow_unbounded_access_logs`` to false.
- area: build
  change: |
    runs as non-root inside Docker containers. Existing behaviour can be restored by setting the environment variable
    ``ENVOY_UID`` to ``0``. ``ENVOY_UID`` and ``ENVOY_GID`` can be used to set the envoy user's ``uid`` and ``gid``
    respectively.
- area: health check
  change: |
    in the health check filter the :ref:`percentage of healthy servers in upstream clusters
    <envoy_api_field_config.filter.http.health_check.v2.HealthCheck.cluster_min_healthy_percentages>` is now interpreted as
    an integer.
- area: hot restart
  change: |
    added the option :option:`--use-dynamic-base-id` to select an unused base ID at startup and the option
    :option:`--base-id-path` to write the base id to a file (for reuse with later hot restarts).
- area: http
  change: |
    changed early error path for HTTP/1.1 so that responses consistently flow through the http connection manager, and the
    http filter chains. This behavior may be temporarily reverted by setting runtime feature
    ``envoy.reloadable_features.early_errors_via_hcm`` to false.
- area: http
  change: |
    fixed several bugs with applying correct connection close behavior across the http connection manager, health checker,
    and connection pool. This behavior may be temporarily reverted by setting runtime feature
    ``envoy.reloadable_features.fix_connection_close`` to false.
- area: http
  change: |
    fixed a bug where the upgrade header was not cleared on responses to non-upgrade requests. Can be reverted temporarily
    by setting runtime feature ``envoy.reloadable_features.fix_upgrade_response`` to false.
- area: http
  change: |
    stopped overwriting ``date`` response headers. Responses without a ``date`` header will still have the header properly
    set. This behavior can be temporarily reverted by setting ``envoy.reloadable_features.preserve_upstream_date`` to false.
- area: http
  change: |
    stopped adding a synthetic path to CONNECT requests, meaning unconfigured CONNECT requests will now return 404 instead
    of 403. This behavior can be temporarily reverted by setting ``envoy.reloadable_features.stop_faking_paths`` to false.
- area: http
  change: |
    stopped allowing upstream 1xx or 204 responses with Transfer-Encoding or non-zero Content-Length headers. Content-Length
    of 0 is allowed, but stripped. This behavior can be temporarily reverted by setting
    ``envoy.reloadable_features.strict_1xx_and_204_response_headers`` to false.
- area: http
  change: |
    upstream connections will now automatically set ALPN when this value is not explicitly set elsewhere (e.g. on the
    upstream TLS config). This behavior may be temporarily reverted by setting runtime feature
    ``envoy.reloadable_features.http_default_alpn`` to false.
- area: listener
  change: |
    fixed a bug where when a static listener fails to be added to a worker, the listener was not removed from the active
    listener list.
- area: router
  change: |
    extended to allow retries of streaming or incomplete requests. This removes stat
    ``rq_retry_skipped_request_not_complete``.
- area: router
  change: |
    extended to allow retries by default when upstream responds with :ref:`x-envoy-overloaded
    <config_http_filters_router_x-envoy-overloaded_set>`.

bug_fixes:
- area: adaptive concurrency
  change: |
    fixed a minRTT calculation bug where requests started before the concurrency limit was pinned to the minimum would skew
    the new minRTT value if the replies arrived after the start of the new minRTT window.
- area: buffer
  change: |
    fixed CVE-2020-12603 by avoiding fragmentation, and tracking of HTTP/2 data and control frames in the output buffer.
- area: grpc-json
  change: |
    fixed a bug when in trailers only gRPC response (e.g. error) HTTP status code is not being re-written.
- area: http
  change: |
    fixed a bug in the grpc_http1_reverse_bridge filter where header-only requests were forwarded with a non-zero content
    length.
- area: http
  change: |
    fixed a bug where in some cases slash was moved from path to query string when :ref:`merging of adjacent slashes
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.merge_slashes>` is enabled.
- area: http
  change: |
    fixed CVE-2020-12604 by changing :ref:`stream_idle_timeout
    <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>` to also
    defend against an HTTP/2 peer that does not open stream window once an entire response has been buffered to be sent to a
    downstream client.
- area: http
  change: |
    fixed CVE-2020-12605 by including request URL in request header size computation, and rejecting partial headers that
    exceed configured limits.
- area: http
  change: |
    fixed several bugs with applying correct connection close behavior across the http connection manager, health checker,
    and connection pool. This behavior may be temporarily reverted by setting runtime feature
    ``envoy.reloadable_features.fix_connection_close`` to false.
- area: listener
  change: |
    fixed CVE-2020-8663 by adding runtime support for :ref:`per-listener limits <config_listeners_runtime>` on
    active/accepted connections.
- area: overload management
  change: |
    fixed CVE-2020-8663 by adding runtime support for :ref:`global limits <config_overload_manager>` on active/accepted
    connections.
- area: prometheus stats
  change: |
    fixed the sort order of output lines to comply with the standard.
- area: udp
  change: |
    the :ref:`reuse_port <envoy_api_field_Listener.reuse_port>` listener option must now be specified for UDP listeners if
    concurrency is > 1. This previously crashed so is considered a bug fix.
- area: upstream
  change: |
    fixed a bug where Envoy would panic when receiving a GRPC SERVICE_UNKNOWN status on the health check.

removed_config_or_runtime:
- area: http
  change: |
    removed legacy connection pool code and their runtime features:
    ``envoy.reloadable_features.new_http1_connection_pool_behavior`` and
    ``envoy.reloadable_features.new_http2_connection_pool_behavior``.

new_features:
- area: access loggers
  change: |
    added file access logger config :ref:`log_format
    <envoy_v3_api_field_extensions.access_loggers.file.v3.FileAccessLog.log_format>`.
- area: access loggers
  change: |
    added GRPC_STATUS operator on logging format.
- area: access loggers
  change: |
    added gRPC access logger config added :ref:`API version
    <envoy_v3_api_field_extensions.access_loggers.grpc.v3.CommonGrpcAccessLogConfig.transport_api_version>` to explicitly
    set the version of gRPC service endpoint and message to be used.
- area: access loggers
  change: |
    extended specifier for FilterStateFormatter to output :ref:`unstructured log string
    <config_access_log_format_filter_state>`.
- area: admin
  change: |
    added support for dumping EDS config at :ref:`/config_dump?include_eds
    <operations_admin_interface_config_dump_include_eds>`.
- area: aggregate cluster
  change: |
    made route :ref:`retry_priority <envoy_v3_api_field_config.route.v3.RetryPolicy.retry_priority>` predicates work with
    :ref:`this cluster type <envoy_v3_api_msg_extensions.clusters.aggregate.v3.ClusterConfig>`.
- area: build
  change: |
    official released binary is now built on Ubuntu 18.04, requires glibc >= 2.27.
- area: build
  change: |
    official released binary is now built with Clang 10.0.0.
- area: cluster
  change: |
    added an extension point for configurable :ref:`upstreams
    <envoy_v3_api_field_config.cluster.v3.Cluster.upstream_config>`.
- area: compressor
  change: |
    exposed generic :ref:`compressor <config_http_filters_compressor>` filter to users.
- area: config
  change: |
    added :ref:`identifier <config_cluster_manager_cds>` stat that reflects control plane identifier.
- area: config
  change: |
    added :ref:`version_text <config_cluster_manager_cds>` stat that reflects xDS version.
- area: decompressor
  change: |
    exposed generic :ref:`decompressor <config_http_filters_decompressor>` filter to users.
- area: dynamic forward proxy
  change: |
    added :ref:`SNI based dynamic forward proxy <config_network_filters_sni_dynamic_forward_proxy>` support.
- area: dynamic forward proxy
  change: |
    added configurable :ref:`circuit breakers <dns_cache_circuit_breakers>` for resolver on DNS cache. This behavior can be
    temporarily disabled by the runtime feature ``envoy.reloadable_features.enable_dns_cache_circuit_breakers``. If this
    runtime feature is disabled, the upstream circuit breakers for the cluster will be used even if the :ref:`DNS Cache
    circuit breakers <dns_cache_circuit_breakers>` are configured.
- area: dynamic forward proxy
  change: |
    added :ref:`allow_insecure_cluster_options
    <envoy_v3_api_field_extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig.allow_insecure_cluster_options>` to allow
    disabling of auto_san_validation and auto_sni.
- area: ext_authz filter
  change: |
    added :ref:`v2 deny_at_disable <envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.deny_at_disable>`, :ref:`v3
    deny_at_disable <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.deny_at_disable>`. This allows force
    denying protected paths while filter gets disabled, by setting this key to true.
- area: ext_authz filter
  change: |
    added API version field for both :ref:`HTTP
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.transport_api_version>` and :ref:`Network
    <envoy_v3_api_field_extensions.filters.network.ext_authz.v3.ExtAuthz.transport_api_version>` filters to explicitly set
    the version of gRPC service endpoint and message to be used.
- area: ext_authz filter
  change: |
    added :ref:`v3 allowed_upstream_headers_to_append
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_upstream_headers_to_append>` to
    allow appending multiple header entries (returned by the authorization server) with the same key to the original request
    headers.
- area: fault
  change: |
    added support for controlling the percentage of requests that abort, delay and response rate limits faults are applied
    to using :ref:`HTTP headers <config_http_filters_fault_injection_http_header>` to the HTTP fault filter.
- area: fault
  change: |
    added support for specifying grpc_status code in abort faults using :ref:`HTTP header
    <config_http_filters_fault_injection_http_header>` or abort fault configuration in HTTP fault filter.
- area: filter
  change: |
    added ``upstream_rq_time`` stats to the GPRC stats filter. Disabled by default and can be enabled via
    :ref:`enable_upstream_stats
    <envoy_v3_api_field_extensions.filters.http.grpc_stats.v3.FilterConfig.enable_upstream_stats>`.
- area: grpc
  change: |
    added support for Google gRPC :ref:`custom channel arguments
    <envoy_v3_api_field_config.core.v3.GrpcService.GoogleGrpc.channel_args>`.
- area: grpc-json
  change: |
    added support for streaming response using `google.api.HttpBody
    <https://github.com/googleapis/googleapis/blob/master/google/api/httpbody.proto>`_.
- area: grpc-json
  change: |
    send a ``x-envoy-original-method`` header to grpc services.
- area: gzip filter
  change: |
    added option to set zlib's next output buffer size.
- area: hds
  change: |
    updated to allow to explicitly set the API version of gRPC service endpoint and message to be used.
- area: header to metadata
  change: |
    added support for regex substitutions on header values.
- area: health checks
  change: |
    allowed configuring health check transport sockets by specifying :ref:`transport socket match criteria
    <envoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>`.
- area: http
  change: |
    added :ref:`local_reply config
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.local_reply_config>` to
    http_connection_manager to customize :ref:`local reply <config_http_conn_man_local_reply>`.
- area: http
  change: |
    added :ref:`stripping port from host header
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.strip_matching_host_port>`
    support.
- area: http
  change: |
    added support for proxying CONNECT requests, terminating CONNECT requests, and converting raw TCP streams into HTTP/2
    CONNECT requests. See :ref:`upgrade documentation <arch_overview_upgrades>` for details.
- area: listener
  change: |
    added in place filter chain update flow for tcp listener update which doesn't close connections if the corresponding
    network filter chain is equivalent during the listener update. Can be disabled by setting runtime feature
    ``envoy.reloadable_features.listener_in_place_filterchain_update`` to false. Also added additional draining filter chain
    stat for :ref:`listener manager <config_listener_manager_stats>` to track the number of draining filter chains and the
    number of in place update attempts.
- area: logger
  change: |
    added ``--log-format-prefix-with-location`` command line option to prefix '%v' with file path and line number.
- area: lrs
  change: |
    added new ``envoy_api_field_service.load_stats.v2.LoadStatsResponse.send_all_clusters`` field in LRS response, which
    allows management servers to avoid explicitly listing all clusters it is interested in; behavior is allowed based on new
    ``envoy.lrs.supports_send_all_clusters`` capability in :ref:`client_features
    <envoy_v3_api_field_config.core.v3.Node.client_features>` field.
- area: lrs
  change: |
    updated to allow to explicitly set the API version of gRPC service endpoint and message to be used.
- area: lua
  change: |
    added :ref:`per route config <envoy_v3_api_msg_extensions.filters.http.lua.v3.LuaPerRoute>` for Lua filter.
- area: lua
  change: |
    added tracing to the ``httpCall()`` API.
- area: metrics service
  change: |
    added :ref:`API version <envoy_v3_api_field_config.metrics.v3.MetricsServiceConfig.transport_api_version>` to explicitly
    set the version of gRPC service endpoint and message to be used.
- area: network filters
  change: |
    added a :ref:`postgres proxy filter <config_network_filters_postgres_proxy>`.
- area: network filters
  change: |
    added a :ref:`rocketmq proxy filter <config_network_filters_rocketmq_proxy>`.
- area: performance
  change: |
    enabled stats symbol table implementation by default. To disable it, add ``--use-fake-symbol-table 1`` to the command-
    line arguments when starting Envoy.
- area: ratelimit
  change: |
    added support for use of dynamic metadata :ref:`dynamic_metadata
    <envoy_v3_api_field_config.route.v3.RateLimit.Action.dynamic_metadata>` as a ratelimit action.
- area: ratelimit
  change: |
    added :ref:`API version <envoy_v3_api_field_config.ratelimit.v3.RateLimitServiceConfig.transport_api_version>` to
    explicitly set the version of gRPC service endpoint and message to be used.
- area: ratelimit
  change: |
    support specifying dynamic overrides in rate limit descriptors using :ref:`limit override
    <envoy_v3_api_field_config.route.v3.RateLimit.limit>` config.
- area: redis
  change: |
    added acl support :ref:`downstream_auth_username
    <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.downstream_auth_username>` for downstream
    client ACL authentication, and :ref:`auth_username
    <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProtocolOptions.auth_username>` to configure
    authentication usernames for upstream Redis 6+ server clusters with ACL enabled.
- area: regex
  change: |
    added support for enforcing max program size via runtime and stats to monitor program size for :ref:`Google RE2
    <envoy_v3_api_field_type.matcher.v3.RegexMatcher.GoogleRE2.max_program_size>`.
- area: request_id
  change: |
    added to :ref:`always_set_request_id_in_response setting
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.always_set_request_id_in_response>`
    to set :ref:`x-request-id <config_http_conn_man_headers_x-request-id>` header in response even if tracing is not forced.
- area: router
  change: |
    added more fine grained internal redirect configs to the :ref:`internal_redirect_policy
    <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_policy>` field.
- area: router
  change: |
    added regex substitution support for header based hashing.
- area: router
  change: |
    added support for RESPONSE_FLAGS and RESPONSE_CODE_DETAILS :ref:`header formatters
    <config_http_conn_man_headers_custom_request_headers>`.
- area: router
  change: |
    allow Rate Limiting Service to be called in case of missing request header for a descriptor if the :ref:`skip_if_absent
    <envoy_v3_api_field_config.route.v3.RateLimit.Action.RequestHeaders.skip_if_absent>` field is set to true.
- area: runtime
  change: |
    added new gauge :ref:`deprecated_feature_seen_since_process_start <runtime_stats>` that gets reset across hot restarts.
- area: server
  change: |
    added the option :option:`--drain-strategy` to enable different drain strategies for DrainManager::drainClose().
- area: server
  change: |
    added :ref:`server.envoy_bug_failures <server_statistics>` statistic to count ENVOY_BUG failures.
- area: stats
  change: |
    added the option to :ref:`report counters as deltas
    <envoy_v3_api_field_config.metrics.v3.MetricsServiceConfig.report_counters_as_deltas>` to the metrics service stats
    sink.
- area: tracing
  change: |
    made tracing configuration fully dynamic and every HTTP connection manager can now have a separate :ref:`tracing
    provider
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.provider>`.
- area: udp
  change: |
    upgraded :ref:`udp_proxy <config_udp_listener_filters_udp_proxy>` filter to v3 and promoted it out of alpha.

deprecated:
- area: tracing
  change: |
    Tracing provider configuration as part of :ref:`bootstrap config
    <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.tracing>` has been deprecated in favor of configuration as part of
    :ref:`HTTP connection manager
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.provider>`.
- area: compression
  change: |
    The :ref:`HTTP Gzip filter <config_http_filters_gzip>` has been deprecated in favor of :ref:`Compressor
    <config_http_filters_compressor>`.
- area: matching
  change: |
    The - change: |   :ref:`GoogleRE2.max_program_size
    <envoy_v3_api_field_type.matcher.v3.RegexMatcher.GoogleRE2.max_program_size>`   field is now deprecated. Management
    servers are expected to validate regexp program sizes   instead of expecting the client to do it. Alternatively, the max
    program size can be enforced by Envoy via runtime.
- area: routing
  change: |
    The :ref:`internal_redirect_action <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_action>` field and
    :ref:`max_internal_redirects <envoy_v3_api_field_config.route.v3.RouteAction.max_internal_redirects>` field are now
    deprecated. This changes the implemented default cross scheme redirect behavior. All cross scheme redirects are
    disallowed by default. To restore the previous behavior, set allow_cross_scheme_redirect=true and use
    :ref:`safe_cross_scheme <envoy_v3_api_msg_extensions.internal_redirect.safe_cross_scheme.v3.SafeCrossSchemeConfig>`, in
    :ref:`predicates <envoy_v3_api_field_config.route.v3.InternalRedirectPolicy.predicates>`.
- area: logging
  change: |
    File access logger fields :ref:`format <envoy_v3_api_field_extensions.access_loggers.file.v3.FileAccessLog.format>`,
    :ref:`json_format <envoy_v3_api_field_extensions.access_loggers.file.v3.FileAccessLog.json_format>` and
    :ref:`typed_json_format <envoy_v3_api_field_extensions.access_loggers.file.v3.FileAccessLog.typed_json_format>` are
    deprecated in favor of :ref:`log_format
    <envoy_v3_api_field_extensions.access_loggers.file.v3.FileAccessLog.log_format>`.
- area: xds
  change: |
    A warning is now logged when v2 xDS api is used. This behavior can be temporarily disabled by setting
    ``envoy.reloadable_features.enable_deprecated_v2_api_warning`` to ``false``.
- area: dns
  change: |
    Using cluster circuit breakers for DNS Cache is now deprecated in favor of :ref:`DNS cache circuit breakers
    <dns_cache_circuit_breakers>`. This behavior can be temporarily disabled by setting
    ``envoy.reloadable_features.enable_dns_cache_circuit_breakers`` to ``false``.
date: February 7, 2023

bug_fixes:
- area: validation
  change: |
    fixed a crash which could happen when optional ``engine_type`` is not provided in regex.
- area: dependency
  change: |
    Add boringssl patch to resolve CVE-2023-0286. Note that the FIPS build is not patched/fixed.

new_features:
- area: attributes
  change: |
    added :ref:`attributes <arch_overview_attributes>` for looking up xDS configuration information.
- area: docker
  change: |
    use new ``nossl`` images for ``distroless`` Docker build.
- area: bazel
  change: |
    updated to version 6.0.0.
date: October 16, 2023

bug_fixes:
- area: http
  change: |
    Fixed a bug where processing of deferred streams with the value of ``http.max_requests_per_io_cycle`` more than 1,
    can cause a crash.
date: August 24, 2021

minor_behavior_changes:
- area: http
  change: |
    disable the integration between :ref:`ExtensionWithMatcher
    <envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcher>` and HTTP filters by default to reflects its
    experimental status. This feature can be enabled by seting ``envoy.reloadable_features.experimental_matching_api`` to
    true.
- area: http
  change: |
    reject requests with \#fragment in the URI path. The fragment is not allowed to be part of request URI according to
    RFC3986 (3.5), RFC7230 (5.1) and RFC 7540 (8.1.2.3). Rejection of requests can be changed to stripping the \#fragment
    instead by setting the runtime guard ``envoy.reloadable_features.http_reject_path_with_fragment`` to false. This
    behavior can further be changed to the deprecated behavior of keeping the fragment by setting the runtime guard
    ``envoy.reloadable_features.http_strip_fragment_from_path_unsafe_if_disabled``. This runtime guard must only be set to
    false when existing non-compliant traffic relies on \#fragment in URI. When this option is enabled, Envoy request
    authorization extensions may be bypassed. This override and its associated behavior will be decommissioned after the
    standard deprecation period.
- area: http
  change: |
    stop processing pending H/2 frames if connection transitioned to a closed state. This behavior can be temporarily
    reverted by setting the ``envoy.reloadable_features.skip_dispatching_frames_for_closed_connection`` to false.

bug_fixes:
- area: ext_authz
  change: |
    fix the ext_authz filter to correctly merge multiple same headers using the ``,`` as separator in the check request to
    the external authorization service.
- area: http
  change: |
    limit use of deferred resets in the http2 codec to server-side connections. Use of deferred reset for client connections
    can result in incorrect behavior and performance problems.
- area: jwt_authn
  change: |
    unauthorized responses now correctly include a ``www-authenticate`` header.

new_features:
- area: listener
  change: |
    added an option when balancing across active listeners and wildcard matching is used to return the listener that matches
    the IP family type associated with the listener's socket address. It is off by default, but is turned on by default in
    v1.19. To set change the runtime guard ``envoy.reloadable_features.listener_wildcard_match_ip_family`` to true.
date: February 22, 2022

bug_fixes:
- area: data plane
  change: |
    fix crash when internal redirect selects a route configured with direct response or redirect actions.
- area: jwt_authn
  change: |
    fixed the crash when a CONNECT request is sent to JWT filter configured with regex match on the Host header.
- area: tcp_proxy
  change: |
    fix a crash that occurs when configured for :ref:`upstream tunneling
    <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.tunneling_config>` and the downstream connection
    disconnects while the the upstream connection or http/2 stream is still being established.
- area: upstream
  change: |
    fix stack overflow when a cluster with large number of idle connections is removed.
date: July 7, 2020

changes:
- area: tls
  change: |
    fixed a bug where wilcard matching for "\*.foo.com" also matched domains of the form "a.b.foo.com". This behavior can be
    temporarily reverted by setting runtime feature ``envoy.reloadable_features.fix_wildcard_matching`` to false.
date: April 27, 2023

bug_fixes:
- area: tls
  change: |
    Fix build FIPS compliance when using both FIPS mode and Wasm extensions (``--define boringssl=fips`` and ``--define wasm=v8``).
date: July 13, 2021

behavior_changes:
- area: grpc_bridge_filter
  change: |
    the filter no longer collects grpc stats in favor of the existing grpc stats filter. The behavior can be reverted by
    changing runtime key ``envoy.reloadable_features.grpc_bridge_stats_disabled``.
- area: tracing
  change: |
    update Apache SkyWalking tracer version to be compatible with 8.4.0 data collect protocol. This change will introduce
    incompatibility with SkyWalking 8.3.0.

minor_behavior_changes:
- area: access_log
  change: |
    added new access_log command operator ``%REQUEST_TX_DURATION%``.
- area: access_log
  change: |
    removed extra quotes on metadata string values. This behavior can be temporarily reverted by setting
    ``envoy.reloadable_features.unquote_log_string_values`` to false.
- area: admission control
  change: |
    added :ref:`max_rejection_probability
    <envoy_v3_api_field_extensions.filters.http.admission_control.v3alpha.AdmissionControl.max_rejection_probability>` which
    defaults to 80%, which means that the upper limit of the default rejection probability of the filter is changed from
    100% to 80%.
- area: aws_request_signing
  change: |
    requests are now buffered by default to compute signatures which include the payload hash, making the filter compatible
    with most AWS services. Previously, requests were never buffered, which only produced correct signatures for requests
    without a body, or for requests to S3, ES or Glacier, which used the literal string ``UNSIGNED-PAYLOAD``. Buffering can
    be now be disabled in favor of using unsigned payloads with compatible services via the new ``use_unsigned_payload``
    filter option (default false).
- area: cache filter
  change: |
    serve HEAD requests from cache.
- area: cluster
  change: |
    added default value of 5 seconds for :ref:`connect_timeout
    <envoy_v3_api_field_config.cluster.v3.Cluster.connect_timeout>`.
- area: dns
  change: |
    changed apple resolver implementation to not reuse the UDS to the local DNS daemon.
- area: dns cache
  change: |
    the new :ref:`dns_query_timeout
    <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_query_timeout>` option has a default
    of 5s. See below for more information.
- area: http
  change: |
    disable the integration between :ref:`ExtensionWithMatcher
    <envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcher>` and HTTP filters by default to reflect its
    experimental status. This feature can be enabled by setting ``envoy.reloadable_features.experimental_matching_api`` to
    true.
- area: http
  change: |
    replaced setting ``envoy.reloadable_features.strict_1xx_and_204_response_headers`` with settings
    ``envoy.reloadable_features.require_strict_1xx_and_204_response_headers`` (require upstream 1xx or 204 responses to not
    have Transfer-Encoding or non-zero Content-Length headers) and
    ``envoy.reloadable_features.send_strict_1xx_and_204_response_headers`` (do not send 1xx or 204 responses with these
    headers). Both are true by default.
- area: http
  change: |
    stop sending the transfer-encoding header for 304. This behavior can be temporarily reverted by setting
    ``envoy.reloadable_features.no_chunked_encoding_header_for_304`` to false.
- area: http
  change: |
    the behavior of the ``present_match`` in route header matcher changed. The value of ``present_match`` was ignored in the
    past. The new behavior is ``present_match`` is performed when the value is true. An absent match performed when the
    value is false. Please reference :ref:`present_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.present_match>`.
- area: listener
  change: |
    respect the :ref:`connection balance config <envoy_v3_api_field_config.listener.v3.Listener.connection_balance_config>`
    defined within the listener where the sockets are redirected to. Clear that field to restore the previous behavior.
- area: listener
  change: |
    when balancing across active listeners and wildcard matching is used, the behavior has been changed to return the
    listener that matches the IP family type associated with the listener's socket address. Any unexpected behavioral
    changes can be reverted by setting runtime guard ``envoy.reloadable_features.listener_wildcard_match_ip_family`` to
    false.
- area: tcp
  change: |
    switched to the new connection pool by default. Any unexpected behavioral changes can be reverted by setting runtime
    guard ``envoy.reloadable_features.new_tcp_connection_pool`` to false.
- area: udp
  change: |
    limit each UDP listener to read maximum 6000 packets per event loop. This behavior can be temporarily reverted by
    setting ``envoy.reloadable_features.udp_per_event_loop_read_limit`` to false.

bug_fixes:
- area: aws_lambda
  change: |
    if ``payload_passthrough`` is set to ``false``, the downstream response content-type header will now be set from the
    content-type entry in the JSON response's headers map, if present.
- area: cluster
  change: |
    fixed the :ref:`cluster stats <config_cluster_manager_cluster_stats_request_response_sizes>` histograms by moving the
    accounting into the router filter. This means that we now properly compute the number of bytes sent as well as handling
    retries which were previously ignored.
- area: hot_restart
  change: |
    fix double counting of ``server.seconds_until_first_ocsp_response_expiring`` and
    ``server.days_until_first_cert_expiring`` during hot-restart. This stat was only incorrect until the parent process
    terminated.
- area: http
  change: |
    fix erroneous handling of invalid nghttp2 frames with the ``NGHTTP2_ERR_REFUSED_STREAM`` error. Prior to the fix, Envoy
    would close the entire connection when nghttp2 triggered the invalid frame callback for the said error. The fix will
    cause Envoy to terminate just the refused stream and retain the connection. This behavior can be temporarily reverted by
    setting the ``envoy.reloadable_features.http2_consume_stream_refused_errors`` runtime guard to false.
- area: http
  change: |
    port stripping now works for CONNECT requests, though the port will be restored if the CONNECT request is sent upstream.
    This behavior can be temporarily reverted by setting ``envoy.reloadable_features.strip_port_from_connect`` to false.
- area: jwt_authn
  change: |
    unauthorized responses now correctly include a ``www-authenticate`` header.
- area: listener
  change: |
    fix a crash which could happen when a filter chain only listener update is followed by listener removal or a full
    listener update.
- area: validation
  change: |
    fix an issue that causes TAP sockets to panic during config validation mode.
- area: xray
  change: |
    fix the default sampling rate for AWS X-Ray tracer extension to be 5% as opposed to 50%.
- area: zipkin
  change: |
    fix timestamp serialization in annotations. A prior bug fix exposed an issue with timestamps being serialized as
    strings.

removed_config_or_runtime:
- area: event
  change: |
    removed ``envoy.reloadable_features.activate_timers_next_event_loop`` runtime guard and legacy code path.
- area: gzip
  change: |
    removed legacy HTTP Gzip filter and runtime guard ``envoy.deprecated_features.allow_deprecated_gzip_http_filter``.
- area: http
  change: |
    removed ``envoy.reloadable_features.allow_500_after_100`` runtime guard and the legacy code path.
- area: http
  change: |
    removed ``envoy.reloadable_features.always_apply_route_header_rules`` runtime guard and legacy code path.
- area: http
  change: |
    removed ``envoy.reloadable_features.hcm_stream_error_on_invalid_message`` for disabling closing HTTP/1.1 connections on
    error. Connection-closing can still be disabled by setting the HTTP/1 configuration
    :ref:`override_stream_error_on_invalid_http_message
    <envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message>`.
- area: http
  change: |
    removed ``envoy.reloadable_features.http_set_copy_replace_all_headers`` runtime guard and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.overload_manager_disable_keepalive_drain_http2``; Envoy will now always send GOAWAY
    to HTTP2 downstreams when the :ref:`disable_keepalive <config_overload_manager_overload_actions>` overload action is
    active.
- area: http
  change: |
    removed ``envoy.reloadable_features.http_match_on_all_headers`` runtime guard and legacy code paths.
- area: http
  change: |
    removed ``envoy.reloadable_features.unify_grpc_handling`` runtime guard and legacy code paths.
- area: tls
  change: |
    removed ``envoy.reloadable_features.tls_use_io_handle_bio`` runtime guard and legacy code path.

new_features:
- area: access_log
  change: |
    added the new response flag for :ref:`overload manager termination
    <envoy_v3_api_field_data.accesslog.v3.ResponseFlags.overload_manager>`. The response flag will be set when the http
    stream is terminated by overload manager.
- area: admission control
  change: |
    added :ref:`rps_threshold
    <envoy_v3_api_field_extensions.filters.http.admission_control.v3alpha.AdmissionControl.rps_threshold>` option that when
    average RPS of the sampling window is below this threshold, the filter will not throttle requests. Added
    :ref:`max_rejection_probability
    <envoy_v3_api_field_extensions.filters.http.admission_control.v3alpha.AdmissionControl.max_rejection_probability>`
    option to set an upper limit on the probability of rejection.
- area: bandwidth_limit
  change: |
    added new :ref:`HTTP bandwidth limit filter <config_http_filters_bandwidth_limit>`.
- area: bootstrap
  change: |
    added :ref:`dns_resolution_config <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.dns_resolution_config>` to aggregate
    all of the DNS resolver configuration in a single message. By setting ``no_default_search_domain`` to true the DNS
    resolver will not use the default search domains. By setting the ``resolvers`` the external DNS servers to be used for
    external DNS queries can be specified.
- area: cluster
  change: |
    added :ref:`dns_resolution_config <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>` to aggregate all
    of the DNS resolver configuration in a single message. By setting ``no_default_search_domain`` to true the DNS resolver
    will not use the default search domains.
- area: cluster
  change: |
    added :ref:`host_rewrite_literal
    <envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.host_rewrite_literal>` to WeightedCluster.
- area: cluster
  change: |
    added :ref:`wait_for_warm_on_init <envoy_v3_api_field_config.cluster.v3.Cluster.wait_for_warm_on_init>`, which allows
    cluster readiness to not block on cluster warm-up. It is true by default, which preserves existing behavior. Currently,
    only applicable for DNS-based clusters.
- area: composite filter
  change: |
    can now be used with filters that also add an access logger, such as the WASM filter.
- area: config
  change: |
    added stat :ref:`config_reload_time_ms <subscription_statistics>`.
- area: connection_limit
  change: |
    added new :ref:`Network connection limit filter <config_network_filters_connection_limit>`.
- area: crash support
  change: |
    restore crash context when continuing to processing requests or responses as a result of an asynchronous callback that
    invokes a filter directly. This is unlike the call stacks that go through the various network layers, to eventually
    reach the filter. For a concrete example see: ``Envoy::Extensions::HttpFilters::Cache::CacheFilter::getHeaders`` which
    posts a callback on the dispatcher that will invoke the filter directly.
- area: dns cache
  change: |
    added :ref:`preresolve_hostnames
    <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.preresolve_hostnames>` option to the DNS
    cache config. This option allows hostnames to be preresolved into the cache upon cache creation. This might provide
    performance improvement, in the form of cache hits, for hostnames that are going to be resolved during steady state and
    are known at config load time.
- area: dns cache
  change: |
    added :ref:`dns_query_timeout
    <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_query_timeout>` option to the DNS
    cache config. This option allows explicitly controlling the timeout of underlying queries independently of the
    underlying DNS platform implementation. Coupled with success and failure retry policies the use of this timeout will
    lead to more deterministic DNS resolution times.
- area: dns resolver
  change: |
    added ``DnsResolverOptions`` protobuf message to reconcile all of the DNS lookup option flags. By setting the
    configuration option :ref:`use_tcp_for_dns_lookups
    <envoy_v3_api_field_config.core.v3.DnsResolverOptions.use_tcp_for_dns_lookups>` as true we can make the underlying dns
    resolver library to make only TCP queries to the DNS servers and by setting the configuration option
    :ref:`no_default_search_domain <envoy_v3_api_field_config.core.v3.DnsResolverOptions.no_default_search_domain>` as true
    the DNS resolver library will not use the default search domains.
- area: dns resolver
  change: |
    added ``DnsResolutionConfig`` to combine :ref:`dns_resolver_options
    <envoy_v3_api_field_config.core.v3.DnsResolutionConfig.dns_resolver_options>` and :ref:`resolvers
    <envoy_v3_api_field_config.core.v3.DnsResolutionConfig.resolvers>` in a single protobuf message. The field ``resolvers``
    can be specified with a list of DNS resolver addresses. If specified, DNS client library will perform resolution via the
    underlying DNS resolvers. Otherwise, the default system resolvers (e.g., /etc/resolv.conf) will be used.
- area: dns_filter
  change: |
    added :ref:`dns_resolution_config
    <envoy_v3_api_field_extensions.filters.udp.dns_filter.v3alpha.DnsFilterConfig.ClientContextConfig.dns_resolution_config>`
    to aggregate all of the DNS resolver configuration in a single message. By setting the configuration option
    ``use_tcp_for_dns_lookups`` to true we can make dns filter's external resolvers to answer queries using TCP only, by
    setting the configuration option ``no_default_search_domain`` as true the DNS resolver will not use the default search
    domains. And by setting the configuration ``resolvers`` we can specify the external DNS servers to be used for external
    DNS query which replaces the pre-existing alpha api field ``upstream_resolvers``.
- area: dynamic_forward_proxy
  change: |
    added :ref:`dns_resolution_config
    <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_resolution_config>` option to the DNS
    cache config in order to aggregate all of the DNS resolver configuration in a single message. By setting one such
    configuration option ``no_default_search_domain`` as true the DNS resolver will not use the default search domains. And
    by setting the configuration ``resolvers`` we can specify the external DNS servers to be used for external DNS query
    instead of the system default resolvers.
- area: ext_authz_filter
  change: |
    added :ref:`bootstrap_metadata_labels_key
    <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.bootstrap_metadata_labels_key>` option to configure
    labels of destination service.
- area: http
  change: |
    added new field ``is_optional`` to ``extensions.filters.network.http_connection_manager.v3.HttpFilter``. When set to
    ``true``, unsupported http filters will be ignored by envoy. This is also same with unsupported http filter in the typed
    per filter config. For more information, please reference :ref:`HttpFilter
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.is_optional>`.
- area: http
  change: |
    added :ref:`scheme options
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.scheme_header_transformation>`
    for adding or overwriting scheme.
- area: http
  change: |
    added :ref:`stripping trailing host dot from host header
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.strip_trailing_host_dot>`
    support.
- area: http
  change: |
    added support for :ref:`original IP detection extensions
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.original_ip_detection_extensions>`.
    Two initial extensions were added, the :ref:`custom header
    <envoy_v3_api_msg_extensions.http.original_ip_detection.custom_header.v3.CustomHeaderConfig>` extension and the
    :ref:`xff <envoy_v3_api_msg_extensions.http.original_ip_detection.xff.v3.XffConfig>` extension.
- area: http
  change: |
    added a new option to upstream HTTP/2 :ref:`keepalive
    <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.connection_keepalive>` to send a PING ahead of a new stream if
    the connection has been idle for a sufficient duration.
- area: http
  change: |
    added the ability to :ref:`unescape slash sequences
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.path_with_escaped_slashes_action>`
    in the path. Requests with unescaped slashes can be proxied, rejected or redirected to the new unescaped path. By
    default this feature is disabled. The default behavior can be overridden through
    :ref:`http_connection_manager.path_with_escaped_slashes_action<config_http_conn_man_runtime_path_with_escaped_slashes_action>`
    runtime variable. This action can be selectively enabled for a portion of requests by setting the
    :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling<config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled>`
    runtime variable.
- area: http
  change: |
    added upstream and downstream alpha HTTP/3 support! See :ref:`quic_options
    <envoy_v3_api_field_config.listener.v3.UdpListenerConfig.quic_options>` for downstream and the new
    http3_protocol_options in :ref:`http_protocol_options
    <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` for upstream HTTP/3.
- area: http
  change: |
    raise max configurable max_request_headers_kb limit to 8192 KiB (8MiB) from 96 KiB in http connection manager.
- area: input matcher
  change: |
    added a new input matcher that :ref:`matches an IP address against a list of CIDR ranges
    <envoy_v3_api_file_envoy/extensions/matching/input_matchers/ip/v3/ip.proto>`.
- area: jwt_authn
  change: |
    added support to fetch remote jwks asynchronously specified by :ref:`async_fetch
    <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.RemoteJwks.async_fetch>`.
- area: jwt_authn
  change: |
    added support to add padding in the forwarded JWT payload specified by :ref:`pad_forward_payload_header
    <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.pad_forward_payload_header>`.
- area: listener
  change: |
    added ability to change an existing listener's address.
- area: listener
  change: |
    added filter chain match support for :ref:`direct source address
    <envoy_v3_api_field_config.listener.v3.FilterChainMatch.direct_source_prefix_ranges>`.
- area: local_rate_limit_filter
  change: |
    added support for locally rate limiting http requests on a per connection basis. This can be enabled by setting the
    :ref:`local_rate_limit_per_downstream_connection
    <envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.local_rate_limit_per_downstream_connection>`
    field to true.
- area: metric service
  change: |
    added support for sending metric tags as labels. This can be enabled by setting the :ref:`emit_tags_as_labels
    <envoy_v3_api_field_config.metrics.v3.MetricsServiceConfig.emit_tags_as_labels>` field to true.
- area: proxy protocol
  change: |
    added support for generating the header while using the :ref:`HTTP connection manager <config_http_conn_man>`. This is
    done using the :ref:`Proxy Protocol Transport Socket <extension_envoy.transport_sockets.upstream_proxy_protocol>` on
    upstream clusters. This feature is currently affected by a memory leak `issue
    <https://github.com/envoyproxy/envoy/issues/16682>`_.
- area: req_without_query
  change: |
    added access log formatter extension implementing command operator :ref:`REQ_WITHOUT_QUERY
    <envoy_v3_api_msg_extensions.formatter.req_without_query.v3.ReqWithoutQuery>` to log the request path, while excluding
    the query string.
- area: router
  change: |
    added option ``suppress_grpc_request_failure_code_stats`` to :ref:`the router
    <envoy_v3_api_msg_extensions.filters.http.router.v3.Router>` to allow users to exclude incrementing HTTP status code
    stats on gRPC requests.
- area: stats
  change: |
    added native :ref:`Graphite-formatted tag
    <envoy_v3_api_msg_extensions.stat_sinks.graphite_statsd.v3.GraphiteStatsdSink>` support.
- area: tcp
  change: |
    added support for :ref:`preconnecting <envoy_v3_api_msg_config.cluster.v3.Cluster.PreconnectPolicy>`. Preconnecting is
    off by default, but recommended for clusters serving latency-sensitive traffic.
- area: thrift_proxy
  change: |
    added per upstream metrics within the :ref:`thrift router
    <envoy_v3_api_msg_extensions.filters.network.thrift_proxy.router.v3.Router>` for request and response size histograms.
- area: thrift_proxy
  change: |
    added support for :ref:`outlier detection <arch_overview_outlier_detection>`.
- area: tls
  change: |
    allow dual ECDSA/RSA certs via SDS. Previously, SDS only supported a single certificate per context, and dual cert was
    only supported via non-SDS.
- area: tracing
  change: |
    add option :ref:`use_request_id_for_trace_sampling
    <envoy_v3_api_field_extensions.request_id.uuid.v3.UuidRequestIdConfig.use_request_id_for_trace_sampling>` which allows
    configuring whether to perform sampling based on :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` or not.
- area: udp_proxy
  change: |
    added :ref:`key <envoy_v3_api_msg_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy>` as another hash policy
    to support hash based routing on any given key.
- area: windows container image
  change: |
    added user, EnvoyUser which is part of the Network Configuration Operators group to the container image.

deprecated:
- area: bootstrap
  change: |
    the field :ref:`use_tcp_for_dns_lookups <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.use_tcp_for_dns_lookups>` is
    deprecated in favor of :ref:`dns_resolution_config
    <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.dns_resolution_config>` which aggregates all of the DNS resolver
    configuration in a single message.
- area: cluster
  change: |
    the fields :ref:`use_tcp_for_dns_lookups <envoy_v3_api_field_config.cluster.v3.Cluster.use_tcp_for_dns_lookups>` and
    :ref:`dns_resolvers <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolvers>` are deprecated in favor of
    :ref:`dns_resolution_config <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>` which aggregates all
    of the DNS resolver configuration in a single message.
- area: dns_filter
  change: |
    the field :ref:`known_suffixes <envoy_v3_api_field_data.dns.v3.DnsTable.known_suffixes>` is deprecated. The internal
    data management of the filter has changed and the filter no longer uses the known_suffixes field.
- area: dynamic_forward_proxy
  change: |
    the field :ref:`use_tcp_for_dns_lookups
    <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.use_tcp_for_dns_lookups>` is deprecated in
    favor of :ref:`dns_resolution_config
    <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_resolution_config>` which aggregates
    all of the DNS resolver configuration in a single message.
- area: http
  change: |
    :ref:`xff_num_trusted_hops
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops>`
    is deprecated in favor of :ref:`original IP detection extensions
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.original_ip_detection_extensions>`.
![Envoy Logo](https://github.com/envoyproxy/artwork/blob/main/PNG/Envoy_Logo_Final_PANTONE.png)

[Cloud-native high-performance edge/middle/service proxy](https://www.envoyproxy.io/)

Envoy is hosted by the [Cloud Native Computing Foundation](https://cncf.io) (CNCF). If you are a
company that wants to help shape the evolution of technologies that are container-packaged,
dynamically-scheduled and microservices-oriented, consider joining the CNCF. For details about who's
involved and how Envoy plays a role, read the CNCF
[announcement](https://www.cncf.io/blog/2017/09/13/cncf-hosts-envoy/).

[![CII Best Practices](https://bestpractices.coreinfrastructure.org/projects/1266/badge)](https://bestpractices.coreinfrastructure.org/projects/1266)
[![OpenSSF Scorecard](https://api.securityscorecards.dev/projects/github.com/envoyproxy/envoy/badge)](https://securityscorecards.dev/viewer/?uri=github.com/envoyproxy/envoy)
[![CLOMonitor](https://img.shields.io/endpoint?url=https://clomonitor.io/api/projects/cncf/envoy/badge)](https://clomonitor.io/projects/cncf/envoy)
[![Azure Pipelines](https://dev.azure.com/cncf/envoy/_apis/build/status/11?branchName=main)](https://dev.azure.com/cncf/envoy/_build/latest?definitionId=11&branchName=main)
[![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/envoy.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:envoy)
[![Jenkins](https://powerci.osuosl.org/buildStatus/icon?job=build-envoy-static-master&subject=ppc64le%20build)](https://powerci.osuosl.org/job/build-envoy-static-master/)

## Documentation

* [Official documentation](https://www.envoyproxy.io/)
* [FAQ](https://www.envoyproxy.io/docs/envoy/latest/faq/overview)
* [Unofficial Chinese documentation](https://cloudnative.to/envoy/)
* Watch [a video overview of Envoy](https://www.youtube.com/watch?v=RVZX4CwKhGE)
([transcript](https://www.microservices.com/talks/lyfts-envoy-monolith-service-mesh-matt-klein/))
to find out more about the origin story and design philosophy of Envoy
* [Blog](https://medium.com/@mattklein123/envoy-threading-model-a8d44b922310) about the threading model
* [Blog](https://medium.com/@mattklein123/envoy-hot-restart-1d16b14555b5) about hot restart
* [Blog](https://medium.com/@mattklein123/envoy-stats-b65c7f363342) about stats architecture
* [Blog](https://medium.com/@mattklein123/the-universal-data-plane-api-d15cec7a) about universal data plane API
* [Blog](https://medium.com/@mattklein123/lyfts-envoy-dashboards-5c91738816b1) on Lyft's Envoy dashboards

## Related

* [data-plane-api](https://github.com/envoyproxy/data-plane-api): v2 API definitions as a standalone
  repository. This is a read-only mirror of [api](api/).
* [envoy-perf](https://github.com/envoyproxy/envoy-perf): Performance testing framework.
* [envoy-filter-example](https://github.com/envoyproxy/envoy-filter-example): Example of how to add new filters
  and link to the main repository.

## Contact

* [envoy-announce](https://groups.google.com/forum/#!forum/envoy-announce): Low frequency mailing
  list where we will email announcements only.
* [envoy-security-announce](https://groups.google.com/forum/#!forum/envoy-security-announce): Low frequency mailing
  list where we will email security related announcements only.
* [envoy-users](https://groups.google.com/forum/#!forum/envoy-users): General user discussion.
* [envoy-dev](https://groups.google.com/forum/#!forum/envoy-dev): Envoy developer discussion (APIs,
  feature design, etc.).
* [envoy-maintainers](https://groups.google.com/forum/#!forum/envoy-maintainers): Use this list
  to reach all core Envoy maintainers.
* [Twitter](https://twitter.com/EnvoyProxy/): Follow along on Twitter!
* [Slack](https://envoyproxy.slack.com/): Slack, to get invited go [here](https://communityinviter.com/apps/envoyproxy/envoy).
  * NOTE: Response to user questions is best effort on Slack. For a "guaranteed" response please email
    envoy-users@ per the guidance in the following linked thread.

Please see [this](https://groups.google.com/forum/#!topic/envoy-announce/l9zjYsnS3TY) email thread
for information on email list usage.

## Contributing

Contributing to Envoy is fun and modern C++ is a lot less scary than you might think if you don't
have prior experience. To get started:

* [Contributing guide](CONTRIBUTING.md)
* [Beginner issues](https://github.com/envoyproxy/envoy/issues?q=is%3Aopen+is%3Aissue+label%3Abeginner)
* [Build/test quick start using docker](ci#building-and-running-tests-as-a-developer)
* [Developer guide](DEVELOPER.md)
* Consider installing the Envoy [development support toolchain](https://github.com/envoyproxy/envoy/blob/main/support/README.md), which helps automate parts of the development process, particularly those involving code review.
* Please make sure that you let us know if you are working on an issue so we don't duplicate work!

## Community Meeting

The Envoy team meets twice per month on Tuesday at 9am PT. The public
Google calendar is here: https://goo.gl/PkDijT

* Meeting minutes are [here](https://goo.gl/5Cergb)
* Recorded videos are posted [here](https://www.youtube.com/channel/UC5z5mvPgqMs1xo5VuIWzYTA)

## Security

### Security Audit

There has been several third party engagements focused on Envoy security:
* In 2018 Cure53 performed a security audit, [full report](docs/security/audit_cure53_2018.pdf).
* In 2021 Ada Logics performed an audit on our fuzzing infrastructure with recommendations for improvements, [full report](docs/security/audit_fuzzer_adalogics_2021.pdf).

### Reporting security vulnerabilities

If you've found a vulnerability or a potential vulnerability in Envoy please let us know at
[envoy-security](mailto:envoy-security@googlegroups.com). We'll send a confirmation
email to acknowledge your report, and we'll send an additional email when we've identified the issue
positively or negatively.

For further details please see our complete [security release process](SECURITY.md).
pin("github.com/repokitteh/modules", "4ee2ed0c3622aad7fcddc04cb5dc866e44a541e6")

use("github.com/repokitteh/modules/assign.star")
use("github.com/repokitteh/modules/review.star")
use("github.com/repokitteh/modules/wait.star")
use("github.com/envoyproxy/envoy/ci/repokitteh/modules/azure_pipelines.star", secret_token=get_secret('azp_token'))
use("github.com/envoyproxy/envoy/ci/repokitteh/modules/coverage.star")
use("github.com/envoyproxy/envoy/ci/repokitteh/modules/docs.star")
use("github.com/envoyproxy/envoy/ci/repokitteh/modules/newpr.star")
use(
  "github.com/envoyproxy/envoy/ci/repokitteh/modules/ownerscheck.star",
  paths=[
    {
      "owner": "envoyproxy/api-shepherds!",
      "path":
      "(api/envoy[\w/]*/(v1alpha\d?|v1|v2alpha\d?|v2))|(api/envoy/type/(matcher/)?\w+.proto)",
      "label": "v2-freeze",
      "allow_global_approval": False,
      "github_status_label": "v2 freeze violations",
    },
    {
       "owner": "envoyproxy/coverage-shephards",
       "path": "(test/per_file_coverage.sh)",
       "github_status_label": "changes to Envoy coverage scripts",
       "auto_assign": True,
    },
    {
       "owner": "envoyproxy/runtime-guard-changes",
       "path": "(source/common/runtime/runtime_features.cc)",
       "github_status_label": "changes to Envoy runtime guards",
    },
    {
      "owner": "envoyproxy/api-shepherds!",
      "path": "(api/envoy/|docs/root/api-docs/)",
      "label": "api",
      "github_status_label": "any API change",
      "auto_assign": True,
    },
    {
      "owner": "envoyproxy/api-watchers",
      "path": "(api/envoy/|docs/root/api-docs/)",
    },
    {
      "owner": "envoyproxy/dependency-shepherds!",
      "path":
      "(bazel/.*repos.*\.bzl)|(bazel/dependency_imports\.bzl)|(api/bazel/.*\.bzl)|(.*/requirements\.txt)|(.*\.patch)",
      "label": "deps",
      "github_status_label": "any dependency change",
      "auto_assign": True,
    },
  ],
)
use("github.com/envoyproxy/envoy/ci/repokitteh/modules/versionchange.star")

def _backport():
  github.issue_label('backport/review')

handlers.command(name='backport', func=_backport)

def _milestone():
  github.issue_label('milestone/review')

handlers.command(name='milestone', func=_milestone)
/*
!/VERSION.txt
!/build_envoy
!/ci
!/configs/google-vrp
!/configs/*yaml
!/linux/amd64/release.tar.zst
!/linux/amd64/schema_validator_tool
!/linux/arm64/release.tar.zst
!/linux/arm64/schema_validator_tool
!/local
!/test/config/integration/certs
!/windows
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SCOPED_FD_H_included
#define SCOPED_FD_H_included

#include <unistd.h>

// A smart pointer that closes the given fd on going out of scope.
// Use this when the fd is incidental to the purpose of your function,
// but needs to be cleaned up on exit.
class ScopedFd {
public:
    explicit ScopedFd(int fd) : fd(fd) {
    }

    ~ScopedFd() {
        close(fd);
    }

    int get() const {
        return fd;
    }

private:
    int fd;

    // Disallow copy and assignment.
    ScopedFd(const ScopedFd&);
    void operator=(const ScopedFd&);
};

#endif  // SCOPED_FD_H_included
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef LOCAL_ARRAY_H_included
#define LOCAL_ARRAY_H_included

#include <cstddef>
#include <new>

/**
 * A fixed-size array with a size hint. That number of bytes will be allocated
 * on the stack, and used if possible, but if more bytes are requested at
 * construction time, a buffer will be allocated on the heap (and deallocated
 * by the destructor).
 *
 * The API is intended to be a compatible subset of C++0x's std::array.
 */
template <size_t STACK_BYTE_COUNT>
class LocalArray {
public:
    /**
     * Allocates a new fixed-size array of the given size. If this size is
     * less than or equal to the template parameter STACK_BYTE_COUNT, an
     * internal on-stack buffer will be used. Otherwise a heap buffer will
     * be allocated.
     */
    LocalArray(size_t desiredByteCount) : mSize(desiredByteCount) {
        if (desiredByteCount > STACK_BYTE_COUNT) {
            mPtr = new char[mSize];
        } else {
            mPtr = &mOnStackBuffer[0];
        }
    }

    /**
     * Frees the heap-allocated buffer, if there was one.
     */
    ~LocalArray() {
        if (mPtr != &mOnStackBuffer[0]) {
            delete[] mPtr;
        }
    }

    // Capacity.
    size_t size() { return mSize; }
    bool empty() { return mSize == 0; }

    // Element access.
    char& operator[](size_t n) { return mPtr[n]; }
    const char& operator[](size_t n) const { return mPtr[n]; }

private:
    char mOnStackBuffer[STACK_BYTE_COUNT];
    char* mPtr;
    size_t mSize;

    // Disallow copy and assignment.
    LocalArray(const LocalArray&);
    void operator=(const LocalArray&);
};

#endif // LOCAL_ARRAY_H_included
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef IFADDRS_ANDROID_H_included
#define IFADDRS_ANDROID_H_included

#include <arpa/inet.h>
#include <cstring>
#include <errno.h>
#include <net/if.h>
#include <netinet/in.h>
#include <new>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <stdio.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>

#include "LocalArray.h"
#include "ScopedFd.h"

// Android (bionic) doesn't have getifaddrs(3)/freeifaddrs(3).
// We fake it here, so java_net_NetworkInterface.cpp can use that API
// with all the non-portable code being in this file.

// Source-compatible subset of the BSD struct.
struct ifaddrs {
    // Pointer to next struct in list, or NULL at end.
    ifaddrs* ifa_next;

    // Interface name.
    char* ifa_name;

    // Interface flags.
    unsigned int ifa_flags;

    // Interface network address.
    sockaddr* ifa_addr;

    // Interface netmask.
    sockaddr* ifa_netmask;

    ifaddrs(ifaddrs* next)
    : ifa_next(next), ifa_name(NULL), ifa_flags(0), ifa_addr(NULL), ifa_netmask(NULL)
    {
    }

    ~ifaddrs() {
        delete ifa_next;
        delete[] ifa_name;
        delete ifa_addr;
        delete ifa_netmask;
    }

    // Sadly, we can't keep the interface index for portability with BSD.
    // We'll have to keep the name instead, and re-query the index when
    // we need it later.
    bool setNameAndFlagsByIndex(int interfaceIndex) {
        // Get the name.
        char buf[IFNAMSIZ];
        char* name = if_indextoname(interfaceIndex, buf);
        if (name == NULL) {
            return false;
        }
        ifa_name = new char[strlen(name) + 1];
        strcpy(ifa_name, name);

        // Get the flags.
        ScopedFd fd(socket(AF_INET, SOCK_DGRAM, 0));
        if (fd.get() == -1) {
            return false;
        }
        ifreq ifr;
        memset(&ifr, 0, sizeof(ifr));
        strcpy(ifr.ifr_name, name);
        int rc = ioctl(fd.get(), SIOCGIFFLAGS, &ifr);
        if (rc == -1) {
            return false;
        }
        ifa_flags = ifr.ifr_flags;
        return true;
    }

    // Netlink gives us the address family in the header, and the
    // sockaddr_in or sockaddr_in6 bytes as the payload. We need to
    // stitch the two bits together into the sockaddr that's part of
    // our portable interface.
    void setAddress(int family, void* data, size_t byteCount) {
        // Set the address proper...
        sockaddr_storage* ss = new sockaddr_storage;
        memset(ss, 0, sizeof(*ss));
        ifa_addr = reinterpret_cast<sockaddr*>(ss);
        ss->ss_family = family;
        uint8_t* dst = sockaddrBytes(family, ss);
        memcpy(dst, data, byteCount);
    }

    // Netlink gives us the prefix length as a bit count. We need to turn
    // that into a BSD-compatible netmask represented by a sockaddr*.
    void setNetmask(int family, size_t prefixLength) {
        // ...and work out the netmask from the prefix length.
        sockaddr_storage* ss = new sockaddr_storage;
        memset(ss, 0, sizeof(*ss));
        ifa_netmask = reinterpret_cast<sockaddr*>(ss);
        ss->ss_family = family;
        uint8_t* dst = sockaddrBytes(family, ss);
        memset(dst, 0xff, prefixLength / 8);
        if ((prefixLength % 8) != 0) {
            dst[prefixLength/8] = (0xff << (8 - (prefixLength % 8)));
        }
    }

    // Returns a pointer to the first byte in the address data (which is
    // stored in network byte order).
    uint8_t* sockaddrBytes(int family, sockaddr_storage* ss) {
        if (family == AF_INET) {
            sockaddr_in* ss4 = reinterpret_cast<sockaddr_in*>(ss);
            return reinterpret_cast<uint8_t*>(&ss4->sin_addr);
        } else if (family == AF_INET6) {
            sockaddr_in6* ss6 = reinterpret_cast<sockaddr_in6*>(ss);
            return reinterpret_cast<uint8_t*>(&ss6->sin6_addr);
        }
        return NULL;
    }

private:
    // Disallow copy and assignment.
    ifaddrs(const ifaddrs&);
    void operator=(const ifaddrs&);
};

// FIXME: use iovec instead.
struct addrReq_struct {
    nlmsghdr netlinkHeader;
    ifaddrmsg msg;
};

inline bool sendNetlinkMessage(int fd, const void* data, size_t byteCount) {
    ssize_t sentByteCount = TEMP_FAILURE_RETRY(send(fd, data, byteCount, 0));
    return (sentByteCount == static_cast<ssize_t>(byteCount));
}

inline ssize_t recvNetlinkMessage(int fd, char* buf, size_t byteCount) {
    return TEMP_FAILURE_RETRY(recv(fd, buf, byteCount, 0));
}

// Source-compatible with the BSD function.
inline int getifaddrs(ifaddrs** result) {
    // Simplify cleanup for callers.
    *result = NULL;

    // Create a netlink socket.
    ScopedFd fd(socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE));
    if (fd.get() < 0) {
        return -1;
    }

    // Ask for the address information.
    addrReq_struct addrRequest;
    memset(&addrRequest, 0, sizeof(addrRequest));
    addrRequest.netlinkHeader.nlmsg_flags = NLM_F_REQUEST | NLM_F_MATCH;
    addrRequest.netlinkHeader.nlmsg_type = RTM_GETADDR;
    addrRequest.netlinkHeader.nlmsg_len = NLMSG_ALIGN(NLMSG_LENGTH(sizeof(ifaddrmsg)));
    addrRequest.msg.ifa_family = AF_UNSPEC; // All families.
    addrRequest.msg.ifa_index = 0; // All interfaces.
    if (!sendNetlinkMessage(fd.get(), &addrRequest, addrRequest.netlinkHeader.nlmsg_len)) {
        return -1;
    }

    // Read the responses.
    LocalArray<0> buf(65536); // We don't necessarily have std::vector.
    ssize_t bytesRead;
    while ((bytesRead  = recvNetlinkMessage(fd.get(), &buf[0], buf.size())) > 0) {
        nlmsghdr* hdr = reinterpret_cast<nlmsghdr*>(&buf[0]);
        for (; NLMSG_OK(hdr, (size_t)bytesRead); hdr = NLMSG_NEXT(hdr, bytesRead)) {
            switch (hdr->nlmsg_type) {
            case NLMSG_DONE:
                return 0;
            case NLMSG_ERROR:
                return -1;
            case RTM_NEWADDR:
                {
                    ifaddrmsg* address = reinterpret_cast<ifaddrmsg*>(NLMSG_DATA(hdr));
                    rtattr* rta = IFA_RTA(address);
                    size_t ifaPayloadLength = IFA_PAYLOAD(hdr);
                    while (RTA_OK(rta, ifaPayloadLength)) {
                        if (rta->rta_type == IFA_ADDRESS) {
                            int family = address->ifa_family;
                            if (family == AF_INET || family == AF_INET6) {
                                *result = new ifaddrs(*result);
                                if (!(*result)->setNameAndFlagsByIndex(address->ifa_index)) {
                                    return -1;
                                }
                                (*result)->setAddress(family, RTA_DATA(rta), RTA_PAYLOAD(rta));
                                (*result)->setNetmask(family, address->ifa_prefixlen);
                            }
                        }
                        rta = RTA_NEXT(rta, ifaPayloadLength);
                    }
                }
                break;
            }
        }
    }
    // We only get here if recv fails before we see a NLMSG_DONE.
    return -1;
}

// Source-compatible with the BSD function.
inline void freeifaddrs(ifaddrs* addresses) {
    delete addresses;
}

#endif  // IFADDRS_ANDROID_H_included
load(
    "//bazel:envoy_build_system.bzl",
    "envoy_package",
    "envoy_cc_library",
)

licenses(["notice"])  # Apache 2

envoy_package()

envoy_cc_library(
    name = "android_lib",
    hdrs =  select({
        "//bazel:android": [
            "ifaddrs-android.h",
            "LocalArray.h",
            "ScopedFd.h",
        ],
        "//conditions:default": [],
    })
)
# Envoy External Dependency Policy

Envoy has an evolving policy on external dependencies, tracked at
https://github.com/envoyproxy/envoy/issues/10471. This will become stricter over time, below we
detail the policy as it currently applies.

## External dependencies dashboard

The list of external dependencies in Envoy with their current version is available at
https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/security/external_deps

## Declaring external dependencies

In general, all external dependencies for the Envoy proxy binary build and test should be declared
in either [bazel/repository_locations.bzl](bazel/repository_locations.bzl) or
[api/bazel/repository_locations.bzl](api/bazel/repository_locations.bzl), unless listed under
[policy exceptions](#policy-exceptions).

An example entry for the `nghttp2` dependency is:

```python
com_github_nghttp2_nghttp2 = dict(
    project_name = "Nghttp2",
    project_desc = "Implementation of HTTP/2 and its header compression ...",
    project_url = "https://nghttp2.org",
    version = "1.41.0",
    sha256 = "eacc6f0f8543583ecd659faf0a3f906ed03826f1d4157b536b4b385fe47c5bb8",
    strip_prefix = "nghttp2-{version}",
    urls = ["https://github.com/nghttp2/nghttp2/releases/download/v{version}/nghttp2-{version}.tar.gz"],
    use_category = ["dataplane"],
    last_updated = "2020-06-02",
    cpe = "cpe:2.3:a:nghttp2:nghttp2:*",
),
```

Dependency declarations must:

* Provide a meaningful project name and URL.
* State the version in the `version` field. String interpolation should be used in `strip_prefix`
  and `urls` to reference the version. If you need to reference version `X.Y.Z` as `X_Y_Z`, this
  may appear in a string as `{underscore_version}`, similarly for `X-Y-Z` you can use
  `{dash_version}`.
* Versions should prefer release versions over main branch GitHub SHA tarballs. A comment is
  necessary if the latter is used. This comment should contain the reason that a non-release
  version is being used.
* Provide accurate entries for `use_category`. Please think carefully about whether there are data
  or control plane implications of the dependency.
* Reflect the UTC date (YYYY-MM-DD format) for the dependency release. This is when
  the dependency was updated in its repository. For dependencies that have
  releases, this is the date of the release. For dependencies without releases
  or for scenarios where we temporarily need to use a commit, this date should
  be the date of the commit in UTC.
* CPEs are compulsory for all dependencies that are not purely build/test.
  [CPEs](https://en.wikipedia.org/wiki/Common_Platform_Enumeration) provide metadata that allow us
  to correlate with related CVEs in dashboards and other tooling, and also provide a machine
  consumable join key. You can consult [CPE
  search](https://nvd.nist.gov/products/cpe/search) to find a CPE for a dependency.`"N/A"` should only
  be used if no CPE for the project is available in the CPE database. CPEs should be _versionless_
  with a `:*` suffix, since the version can be computed from `version`.

When build or test code references Python modules, they should be specified via `pip_install` in
[bazel/repositories_extra.bzl](bazel/repositories_extra.bzl). Python modules should not be listed in
`repository_locations.bzl` entries. `requirements.txt` files for Python dependencies must pin to
exact versions, e.g. `PyYAML==5.4.1` and ideally also include a [SHA256
checksum](https://davidwalsh.name/hashin).

Pure developer tooling and documentation builds may reference Python via standalone
`requirements.txt`, following the above policy.

## New external dependencies

Any new dependency on the Envoy data or control plane that impacts Envoy core (i.e. is not
specific to a single non-core extension) must be cleared with the Envoy dependency shepherds and
security team, please file an issue and tag both [dependency
shepherds](https://github.com/orgs/envoyproxy/teams/dependency-shepherds) and
the [@envoyproxy/security-team](https://github.com/orgs/envoyproxy/teams/security-team).

The criteria below are used to evaluate new dependencies on the data, control
and observability plane. They apply to all core dependencies and any extension
that is robust to untrusted downstream or upstream traffic. The criteria are
guidelines, exceptions may be granted with solid rationale. Precedent from
existing extensions does not apply; there are extant extensions in violation of
this policy which we will be addressing over time, they do not provide grounds
to ignore policy criteria below.

|Criteria|Requirement|Mnemonic|Weight|Rationale|
|--------|-----------|--------|------|---------|
|Cloud Native Computing Foundation (CNCF) [approved license](https://github.com/cncf/foundation/blob/master/allowed-third-party-license-policy.md#approved-licenses-for-allowlist)|MUST|License|High||
|Dependencies must not substantially increase the binary size unless they are optional (i.e. confined to specific extensions)|MUST|BinarySize|High|Envoy Mobile is sensitive to binary size. We should pick dependencies that are used in core with this criteria in mind.|
|No duplication of existing dependencies|MUST|NoDuplication|High|Avoid maintenance cost of multiple JSON parsers etc|
|Hosted on a git repository and the archive fetch must directly reference this repository. We will NOT support intermediate artifacts built by-hand located on GCS, S3, etc.|MUST|Source|High|Flows based on manual updates are fragile (they are not tested until needed), often suffer from missing documentation and shared exercise, may fail during emergency zero day updates and have no audit trail (i.e. it's unclear how the artifact we depend upon came to be at a later date).|
|CVE history appears reasonable, no pathological CVE arcs|MUST|SoundCVEs|High|Avoid dependencies that are CVE heavy in the same area (e.g. buffer overflow)
|Code review (ideally PRs) before merge|MUST|Code-Review|Normal|Consistent code reviews|
|Security vulnerability process exists, with contact details and reporting/disclosure process|MUST|SecPolicy|High|Lack of a policy implies security bugs are open zero days|
|> 1 contributor responsible for a non-trivial number of commits|MUST|Contributors|Normal|Avoid bus factor of 1|
|Tests run in CI|MUST|CI-Tests|Normal|Changes gated on tests|
|High test coverage (also static/dynamic analysis, fuzzing)|SHOULD|Test-Coverage|Normal|Key dependencies must meet the same quality bar as Envoy|
|Envoy can obtain advanced notification of vulnerabilities or of security releases|SHOULD|SecPolicy-Compat|High|Coordinated security releases possible, but most dependencies do not feature this.|
|Do other significant projects have shared fate by using this dependency?|SHOULD|SharedFate|High|Increased likelihood of security community interest, many eyes.|
|Releases (with release notes)|SHOULD|Releases|Normal|Discrete upgrade points, clear understanding of security implications. We have many counterexamples today (e.g. CEL, re2).|
|Commits/releases in last 90 days|SHOULD|Active|Normal|Avoid unmaintained deps, not compulsory since some code bases are done|

The rationale behind this policy is tracked
[here](https://docs.google.com/document/d/1HbREo7pv7rgeIIjQn6mNpySzQE5rx2Yv9dXm5NqR2N8/edit#).

## Maintaining existing dependencies

We rely on community volunteers to help track the latest versions of dependencies. On a best effort
basis:

* Core Envoy dependencies will be updated by the Envoy maintainers/security team.

* Extension [CODEOWNERS](CODEOWNERS) should update extension specific dependencies.

Where possible, we prefer the latest release version for external dependencies, rather than main
branch GitHub SHA tarballs.

Available updates for most of our dependencies can be tracked on the Github issue tracker here:

https://github.com/envoyproxy/envoy/issues?q=is%3Aissue+is%3Aopen+newer+release+available

If you intend to update a dependency, please assign the relevant ticket to yourself and/or associate
any Pull Request (eg by adding `Fix #1234`) with the issue.

## Dependency shepherds

Sign-off from the [dependency
shepherds](https://github.com/orgs/envoyproxy/teams/dependency-shepherds) is
required for every PR that modifies external dependencies. The shepherds will
look to see that the policy in this document is enforced and that metadata is
kept up-to-date.

## Dependency patches

Occasionally it is necessary to introduce an Envoy-side patch to a dependency in a `.patch` file.
These are typically applied in [bazel/repositories.bzl](bazel/repositories.bzl). Our policy on this
is as follows:

* Patch files impede dependency updates. They are expedient at creation time but are a maintenance
  penalty. They reduce the velocity and increase the effort of upgrades in response to security
  vulnerabilities in external dependencies.

* No patch will be accepted without a sincere and sustained effort to upstream the patch to the
  dependency's canonical repository.

* There should exist a plan-of-record, filed as an issue in Envoy or the upstream GitHub tracking
  elimination of the patch.

* Every patch must have comments at its point-of-use in [bazel/repositories.bzl](bazel/repositories.bzl)
  providing a rationale and detailing the tracking issue.

## Policy exceptions

The following dependencies are exempt from the policy:

* Any developer-only facing tooling or the documentation build.

* Transitive build time dependencies, e.g. Go projects vendored into
  [protoc-gen-validate](https://github.com/bufbuild/protoc-gen-validate).
# Dot files, disallow by default, and enable explicitly
\.*
!\.azure-pipelines
!\.bazelci
!\.bazelignore
!\.bazelrc
!\.bazelproject
!\.bazelversion
!\.circleci
!\.clang-format
!\.clang-tidy
!\.coveragerc
!\.devcontainer
!\.dockerignore
!\.eslintrc.yml
!\.flake8
!\.gitattributes
!\.github
!\.gitignore
!\.python-version
!\.style.yapf
!\.yamllint
!\.yapfignore
!\.zuul
!\.zuul.yaml

/bazel-*
/mobile/bazel-*
BROWSE
/build
/build_*
*.bzlc
/ci/bazel-*
compile_commands.json
cscope.*
/docs/landing_source/.bundle
/generated
*.pyc
**/pyformat
SOURCE_VERSION
*.swap*
tags
TAGS
/test/coverage/BUILD
/tools/spelling/.aspell.en.pws
clang-tidy-fixes.yaml
clang.bazelrc
user.bazelrc
CMakeLists.txt
cmake-build-debug
/linux
bazel.output.txt
*~
**/.DS_Store
**/*.iml
tools/dev/src
distribution/custom
examples/websocket/certs
/contrib/golang/**/test_data/go.sum
/contrib/golang/**/test_data/*/go.sum

examples/single-page-app/xds/lds.yml
!examples/single-page-app/ui/.env
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*
node_modules
dist
*.bak
#!/usr/bin/env bash
#
# Bootstraps the developer tools and development environment. This includes
# copying project-standard git commit hooks that do things like ensure DCO
# signoff is present during commit.

# Best-effort check that we're in the envoy root directory.
#
# TODO(hausdorff): If compatibility becomes an issue here, come back and do this
# "the right way". This is hard to do in general, since `realpath` is not
# standard.
if [ ! "$(pwd -P)" == "$(git rev-parse --show-toplevel)" ]; then
    cat >&2 <<__EOF__
ERROR: this script must be run at the root of the envoy source tree
__EOF__
    exit 1
fi

# Helper functions that calculate `abspath` and `relpath`. Taken from Mesos
# commit 82b040a60561cf94dec3197ea88ae15e57bcaa97, which also carries the Apache
# V2 license, and has deployed this code successfully for some time.
abspath() {
    cd "$(dirname "${1}")" || return 1
    echo "${PWD}"/"$(basename "${1}")"
    cd "${OLDPWD}" || return 1
}
relpath() {
  local FROM TO UP
  FROM="$(abspath "${1%/}")" TO="$(abspath "${2%/}"/)"
  while test "${TO}"  = "${TO#"${FROM}"/}" \
          -a "${TO}" != "${FROM}"; do
    FROM="${FROM%/*}" UP="../${UP}"
  done
  TO="${UP%/}${TO#"${FROM}"}"
  echo "${TO:-.}"
}

# Try to find the `.git` directory, even if it's not in Envoy project root (as
# it wouldn't be if, say, this were in a submodule). The "blessed" but fairly
# new way to do this is to use `--git-common-dir`.
DOT_GIT_DIR=$(git rev-parse --git-common-dir)
if test ! -d "${DOT_GIT_DIR}"; then
  # If `--git-common-dir` is not available, fall back to older way of doing it.
  DOT_GIT_DIR=$(git rev-parse --git-dir)
fi

HOOKS_DIR="${DOT_GIT_DIR}/hooks"
HOOKS_DIR_RELPATH=$(relpath "${HOOKS_DIR}" "$(dirname "$0")")

if [[ -n "$REINSTALL_HOOKS" ]] || [[ ! -e "${HOOKS_DIR}/prepare-commit-msg" ]]; then
  echo "Installing hook 'prepare-commit-msg'"
  ln -sf "${HOOKS_DIR_RELPATH}/hooks/prepare-commit-msg" "${HOOKS_DIR}/prepare-commit-msg"
fi

if [[ -n "$REINSTALL_HOOKS" ]] || [[ ! -e "${HOOKS_DIR}/pre-push" ]]; then
  echo "Installing hook 'pre-push'"
  ln -sf "${HOOKS_DIR_RELPATH}/hooks/pre-push" "${HOOKS_DIR}/pre-push"
fi
# Support tools

A collection of CLI tools meant to support and automate various aspects of
developing Envoy, particularly those related to code review. For example,
automatic DCO signoff and pre-commit format checking.

## Usage

To get started, you need only navigate to the Envoy project root and run:

```bash
./support/bootstrap
```

This will set up the development support toolchain automatically. The toolchain
uses git hooks extensively, copying them from `support/hooks` to the `.git`
folder.

The commit hook checks can be skipped using the `--no-verify` flags, as
so:

```bash
git commit --no-verify
```

You can also do this by adding `NO_VERIFY` to `.env`, for example:

```console
$ echo NO_VERIFY=1 >> .env
```

Or settting it in your environment:

```console
$ export NO_VERIFY=1
```

## Functionality

Currently the development support toolchain exposes two main pieces of
functionality:

* Automatically appending DCO signoff to the end of a commit message if it
  doesn't exist yet. Correctly covers edge cases like `commit --amend` and
  `rebase`.
* Automatically running DCO and format checks on all files in the diff, before
  push.

[filter]: https://github.com/envoyproxy/envoy-filter-example

## Fixing Format Problems

If the pre-push format checks detect any problems, you can either fix the
affected files manually or run the provided formatting script.

To run the format fix script directly:

```console
bazel run //tools/code_format:check_format -- fix && bazel run //tools/code:check -- fix -s main -v warn
```

To run the format fix script under Docker:

```console
./ci/run_envoy_docker.sh './ci/do_ci.sh format'
```

To run clang-tidy under Docker, run the following (this creates a full
compilation db and takes a long time):

```console
./ci/run_envoy_docker.sh ci/do_ci.sh clang_tidy
```
#!/usr/bin/env bash
#
# A git commit hook that will automatically append a DCO signoff to the bottom
# of any commit message that doesn't have one. This append happens after the git
# default message is generated, but before the user is dropped into the commit
# message editor.
#
# To enable this hook, run `bootstrap`, or run the following from the root of
# the repo. (Note that `bootstrap` will correctly install this even if this code
# is located in a submodule, while the following won't.)
#
# $ ln -s ../../support/hooks/prepare-commit-msg .git/hooks/prepare-commit-msg

COMMIT_MESSAGE_FILE="$1"
AUTHOR=$(git var GIT_AUTHOR_IDENT)
SIGNOFF=$(echo "$AUTHOR" | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')

# Check for DCO signoff message. If one doesn't exist, append one and then warn
# the user that you did so.
if ! grep -qs "^$SIGNOFF" "$COMMIT_MESSAGE_FILE"; then
  echo -e "\n$SIGNOFF" >> "$COMMIT_MESSAGE_FILE"
  echo -e "Appended the following signoff to the end of the commit message:\n  $SIGNOFF\n"
fi
#!/usr/bin/env bash
#
# A git commit hook that will automatically run format checking and DCO signoff
# checking before the push is successful.
#
# To enable this hook, run `bootstrap`, or run the following from the root of
# the repo. (Note that `bootstrap` will correctly install this even if this code
# is located in a submodule, while the following won't.)
#
# $ ln -s ../../support/hooks/pre-push .git/hooks/pre-push

if [[ -e .env ]]; then
    # shellcheck disable=SC1091
    . .env
fi

if [[ -n "$NO_VERIFY" ]]; then
    exit 0
fi

DUMMY_SHA=0000000000000000000000000000000000000000

# shellcheck disable=SC2016
echo 'Running pre-push check; to skip this step use `push --no-verify` or add `NO_VERIFY=1` to `.env`'
echo
AUTHOR=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/\1/p')

# shellcheck disable=SC2034
while read -r LOCAL_REF LOCAL_SHA REMOTE_REF REMOTE_SHA
do
  if [ "$LOCAL_SHA" = $DUMMY_SHA ]
  then
    # Branch deleted. Do nothing.
    exit 0
  else
    if [ "$REMOTE_SHA" = $DUMMY_SHA ]
    then
      # New branch. Verify the last commit, since this is very likely where the new code is
      # (though there is no way to know for sure). In the extremely uncommon case in which someone
      # pushes more than 1 new commit to a branch, CI will enforce full checking.
      RANGE="$LOCAL_SHA~1..$LOCAL_SHA"
    else
      # Updating branch. Verify new commits.
      RANGE="$REMOTE_SHA..$LOCAL_SHA"
    fi

    # Verify DCO signoff. We do this before the format checker, since it has
    # some probability of failing spuriously, while this check never should.
    #
    # In general, we can't assume that the commits are signed off by author
    # pushing, so we settle for just checking that there is a signoff at all.
    SIGNED_OFF=$(git rev-list --no-merges --author "$AUTHOR" --grep "^Signed-off-by: " "$RANGE")
    NOT_SIGNED_OFF=$(git rev-list --no-merges --author "$AUTHOR" "$RANGE" | grep -Fxv "$SIGNED_OFF")
    if [ -n "$NOT_SIGNED_OFF" ]
    then
      echo >&2 "ERROR: The following commits do not have DCO signoff:"
      while read -r commit; do
        echo "  $(git log --pretty=oneline --abbrev-commit -n 1 "$commit")"
      done <<< "$NOT_SIGNED_OFF"
      exit 1
    fi

    # NOTE: The `tools` directory will be the same relative to the support
    # directory, independent of whether we're in a submodule, so no need to use
    # our `relpath` helper.
    SCRIPT_DIR="$(dirname "$(realpath "$0")")/../../tools"

    _CHANGES=$(git diff --name-only "$RANGE" --diff-filter=ACMR --ignore-submodules=all 2>&1 | tr '\n' ' ')
    IFS=' ' read -ra CHANGES <<< "$_CHANGES"

    echo -ne "  Checking format for ${CHANGES[*]} - "
    bazel run //tools/code_format:check_format -- check "${CHANGES[@]}" || exit 1
    # TODO(phlax): It seems this is not running in CI anymore and is now finding issues
    # in merged PRs. Unify this hook and format checks in CI when the new format tool is rolled
    # out.
    # echo "  Checking spelling for $i"
    # "$SCRIPT_DIR"/spelling/check_spelling_pedantic.py check "${CHANGES[@]}" || exit 1

    # TODO(mattklein123): Optimally we would be able to do this on a per-file basis.
    "$SCRIPT_DIR"/proto_format/proto_format.sh check || exit 1

    bazel run //tools/code:check -- \
          -s main \
          -v warn || exit 1

    # Check correctness of repositories definitions.
    echo "  Checking repositories definitions"
    "$SCRIPT_DIR"/check_repositories.sh || exit 1
  fi
done

exit 0
# C++ coding style

* The Envoy source code is formatted using clang-format. Thus all white spaces, etc.
  issues are taken care of automatically. The Azure Pipelines will automatically check
  the code format and fail. There are make targets that can both check the format
  (check_format) as well as fix the code format for you (fix_format). Errors in
  .clang-tidy are enforced while other warnings are suggestions. Note that code and
  comment blocks designated `clang-format off` must be closed with `clang-format on`.
  To run these checks locally, see [Support Tools](support/README.md).
* Beyond code formatting, for the most part Envoy uses the
  [Google C++ style guidelines](https://google.github.io/styleguide/cppguide.html).
  The following section covers the major areas where we deviate from the Google
  guidelines.

# Repository file layout

* Please see [REPO_LAYOUT.md](REPO_LAYOUT.md).

# Documentation

* If you are modifying the data plane structurally, please keep the [Life of a
  Request](https://www.envoyproxy.io/docs/envoy/latest/intro/life_of_a_request) documentation up-to-date.

# Deviations from Google C++ style guidelines

* Exceptions are allowed on the control plane, though now discouraged in new code. Adding exceptions is disallowed on the data plane.
* References are always preferred over pointers when the reference cannot be null. This
  includes both const and non-const references.
* Function names should all use camel case starting with a lower case letter (e.g., `doFoo()`).
* Struct/Class member variables have a `_` postfix (e.g., `int foo_;`).
* Enum values using PascalCase (e.g., `RoundRobin`).
* 100 columns is the line limit.
* Use your GitHub name in TODO comments, e.g. `TODO(foobar): blah`.
* Smart pointers are type aliased:
  * `using FooPtr = std::unique_ptr<Foo>;`
  * `using BarSharedPtr = std::shared_ptr<Bar>;`
  * `using BlahConstSharedPtr = std::shared_ptr<const Blah>;`
  * Regular pointers (e.g. `int* foo`) should not be type aliased.
* `absl::optional<std::reference_wrapper<T>>` has a helper class in `envoy/common/optref.h`, and is type aliased:
  * `using FooOptRef = OptRef<T>;`
  * `using FooOptConstRef = OptRef<const T>;`
* If move semantics are intended, prefer specifying function arguments with `&&`.
  E.g., `void onHeaders(Http::HeaderMapPtr&& headers, ...)`. The rationale for this is that it
  forces the caller to specify `std::move(...)` or pass a temporary and makes the intention at
  the callsite clear. Otherwise, it's difficult to tell if a const reference is actually being
  passed to the called function. This is true even for `std::unique_ptr`.
* Prefer `unique_ptr` over `shared_ptr` wherever possible. `unique_ptr` makes ownership in
  production code easier to reason about. Note that this creates some test oddities where
  production code requires a `unique_ptr` but the test must still have access to the memory
  the production code is using (mock or otherwise). In these cases it is acceptable to allocate
  raw memory in a test and return it to the production code with the expectation that the
  production code will hold it in a `unique_ptr` and free it. Envoy uses the factory pattern
  quite a bit for these cases. (Search the code for "factory").
* Prefer explicitly sized integer types, such as uint64_t rather than size_t. In particular, use
  explicitly sized integers for data that is written to disk or involved in math that might overflow.
* The Google C++ style guide points out that [non-PoD static and global variables are forbidden](https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables).
  This _includes_ types such as `std::string`. We encourage the use of the
  advice in the [C++ FAQ on the static initialization
  fiasco](https://isocpp.org/wiki/faq/ctors#static-init-order-on-first-use) for
  how to best handle this.
* The Google C++ style guide points out that [constant vars should be named `kConstantVar`](https://google.github.io/styleguide/cppguide.html#Constant_Names).
  In the Envoy codebase we use `ConstantVar` or `CONSTANT_VAR`. If you pick `CONSTANT_VAR`,
  please be certain the name is globally significant to avoid potential conflicts with #defines,
  which are not namespace-scoped, and may appear in externally controlled header files.
* API-level comments should follow normal Doxygen conventions. Use `@param` to describe
  parameters and `@return <return-type>` for return values. Internal comments for
  methods and member variables may be regular C++ `//` comments or Doxygen at
  developer discretion. Where possible, methods should have meaningful
  documentation on expected input and state preconditions.
* Header guards should use `#pragma once`.
* All code should be inside a top-level Envoy namespace. There are some
  exceptions such as `main()` functions. When code cannot be placed inside the
  Envoy namespace there should be a comment of the form `// NOLINT(namespace-envoy)` at
  the top of the file.
* If a method that must be defined outside the `test` directory is intended to be called only
  from test code then it should have a name that ends in `ForTest()` such as `aMethodForTest()`.
  In most cases tests can and should be structured so this is not necessary.
* Tests default to StrictMock so will fail if hitting unexpected warnings. Feel free to use
  NiceMock for mocks whose behavior is not the focus of a test.
* [Thread
  annotations](https://github.com/abseil/abseil-cpp/blob/master/absl/base/thread_annotations.h),
  such as `ABSL_GUARDED_BY`, should be used for shared state guarded by
  locks/mutexes.
* Functions intended to be local to a cc file should be declared in an anonymous namespace,
  rather than using the 'static' keyword. Note that the
  [Google C++ style guide](https://google.github.io/styleguide/cppguide.html#Unnamed_Namespaces_and_Static_Variables)
   allows either, but in Envoy we prefer anonymous namespaces.
* Braces are required for all control statements include single line if, while, etc. statements.
* Don't use [mangled Protobuf enum
  names](https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#enum).

# Error handling

A few general notes on our error handling philosophy:

* All error code returns should be checked.
* At a very high level, our philosophy is that errors should be handled gracefully when caused by:
  - Untrusted network traffic (from downstream, upstream, or extensions like filters)
  - Raised by the Envoy process environment and are *likely* to happen
  - Third party dependency return codes
* Examples of likely environnmental errors include any type of network error, disk IO error, bad
  data returned by an API call, bad data read from runtime files, etc. This includes loading
  configuration at runtime.
* Third party dependency return codes should be checked and gracefully handled. Examples include
  HTTP/2 or JSON parsers. Some return codes may be handled by continuing, for example, in case of an
  out of process RPC failure.
* Testing should cover any serious cases that may result in infinite loops, crashes, or serious
  errors. Non-trivial invariants are also encouraged to have testing. Internal, localized invariants
  may not need testing.
* Errors in the Envoy environment that are *unlikely* to happen after process initialization, should
  lead to process death, under the assumption that the additional burden of defensive coding and
  testing is not an effective use of time for an error that should not happen given proper system
  setup. Examples of these types of errors include not being able to open the shared memory region,
  system calls that should not fail assuming correct parameters (which should be validated via
  tests), etc. Examples of system calls that should not fail when passed valid parameters include
  the kernel returning a valid `sockaddr` after a successful call to `accept()`, `pthread_create()`,
  `pthread_join()`, etc. However, system calls that require permissions may cause likely errors in
  some deployments and need graceful error handling.
* OOM events (both memory and FDs) or ENOMEM errors are considered fatal crashing errors. An OOM
  error should never silently be ignored and should crash the process either via the C++ allocation
  error exception, an explicit `RELEASE_ASSERT` following a third party library call, or an obvious
  crash on a subsequent line via null pointer dereference. This rule is again based on the
  philosophy that the engineering costs of properly handling these cases are not worth it. Time is
  better spent designing proper system controls that shed load if resource usage becomes too high,
  etc.
* The "less is more" error handling philosophy described in the previous points is primarily
  based on the fact that restarts are designed to be fast, reliable and cheap.
* Although we strongly recommend that any type of startup error leads to a fatal error, since this
  is almost always a result of faulty configuration which should be caught during a canary process,
  there may be cases in which we want some classes of startup errors to be non-fatal. For example,
  if a misconfigured option is not necessary for server operation. Although this is discouraged, we
  will discuss these on a case by case basis during code review (an example of this
  is the `--admin-address-path` option). **If degraded mode error handling is implemented, we require
  that there is complete test coverage for the degraded case.** Additionally, the user should be
  aware of the degraded state minimally via an error log of level warn or greater and via the
  increment of a stat.
* If you do need to log a non-fatal warning or error, you can unit-test it with EXPECT_LOG_CONTAINS
  or EXPECT_NO_LOGS from [logging.h](test/test_common/logging.h). It's generally bad practice to
  test by depending on log messages unless the actual behavior being validated is logging.
  It's preferable to export statistics to enable consumption by external monitoring for any
  behavior that should be externally consumed or to introduce appropriate internal interfaces
  such as mocks for internal behavior.
* The error handling philosophy described herein is based on the assumption that Envoy is deployed
  using industry best practices (primarily canary). Major and obvious errors should always be
  caught in canary. If a low rate error leads to periodic crash cycling when deployed to
  production, the error rate should allow for rollback without large customer impact.
* Tip: If the thought of adding the extra test coverage, logging, and stats to handle an error and
  continue seems ridiculous because *"this should never happen"*, it's a very good indication that
  the appropriate behavior is to terminate the process and not handle the error. When in doubt,
  please discuss.

# Macro Usage

* The following macros are available:
  - `RELEASE_ASSERT`: fatal check.
  - `ASSERT`: fatal check in debug-only builds. These should be used to document (and check in
    debug-only builds) program invariants.
  - `ENVOY_BUG`: logs and increments a stat in release mode, fatal check in debug builds. These
    should be used where it may be useful to detect if an efficient condition is violated in
    production (and fatal check in debug-only builds). This will also log a stack trace
    of the previous calls leading up to `ENVOY_BUG`.

* Sub-macros alias the macros above and can be used to annotate specific situations:
  - `ENVOY_BUG_ALPHA` (alias `ENVOY_BUG`): Used for alpha or rapidly changing protocols that need
  detectability on probable conditions or invariants.

* Per above it's acceptable to turn failures into crash semantics via `RELEASE_ASSERT(condition)` or
  `PANIC(message)` if there is no other sensible behavior, e.g. in OOM (memory/FD) scenarios.
* Do not `ASSERT` on conditions imposed by the external environment. Either add error handling
  (potentially with an `ENVOY_BUG` for detectability) or `RELEASE_ASSERT` if the condition indicates
  that the process is unrecoverable.
* Use `ASSERT` and `ENVOY_BUG` liberally, but do not use them for things that will crash in an obvious
  way in a subsequent line. E.g., do not do `ASSERT(foo != nullptr); foo->doSomething();`.
* Use `ASSERT`s for true invariants and well-defined conditions that are useful for tests,
  debug-only checks and documentation. They may be `ENVOY_BUG`s if performance allows, see point
  below.
* `ENVOY_BUG`s provide detectability and more confidence than an `ASSERT`. They are useful for
  non-trivial conditions, those with complex control flow, and rapidly changing protocols. Testing
  should be added to ensure that Envoy can continue to operate even if an `ENVOY_BUG` condition is
  violated.
* Annotate conditions with comments on belief or reasoning, for example `Condition is guaranteed by
  caller foo` or `Condition is likely to hold after processing through external library foo`.
* Macro usage should be understandable to a reader. Add comments if not. They should be robust to
  future changes.
* Note that there is a gray line between external environment failures and program invariant
  violations. For example, memory corruption due to a security issue (a bug, deliberate buffer
  overflow etc.) might manifest as a violation of program invariants or as a detectable condition in
  the external environment (e.g. some library returning a highly unexpected error code or buffer
  contents). Unfortunately no rule can cleanly cover when to use `RELEASE_ASSERT` vs. `ASSERT`. In
  general we view `ASSERT` as the common case and `RELEASE_ASSERT` as the uncommon case, but
  experience and judgment may dictate a particular approach depending on the situation. The risk of
  process death from `RELEASE_ASSERT` should be justified with the severity and possibility of the
  condition to avoid unintentional crashes. You may use the following guide:
    * If a violation is high risk (will cause a crash in subsequent data processing or indicates a
      failure state beyond recovery), use `RELEASE_ASSERT`.
    * If a violation is medium or low risk (Envoy can continue safely) and is not expensive,
      consider `ENVOY_BUG`.
    * Otherwise (if a condition is expensive or test-only), use `ASSERT`.

Below is a guideline for macro usage. The left side of the table has invariants and the right side
has error conditions that can be triggered and should be gracefully handled. `ENVOY_BUG` represents
a middle ground that can be used for uncertain conditions that need detectability. `ENVOY_BUG`s can
also be added for errors if they warrant detection.

| `ASSERT`/`RELEASE_ASSERT` | `ENVOY_BUG` | Error handling and Testing |
| --- | --- | --- |
| Low level invariants in data structures | | |
| Simple, provable internal class invariants | Complex, uncertain internal class invariants (e.g. need detectability if violated) | |
| Provable (pre/post)-conditions | Complicated but likely (pre-/post-) conditions that are low-risk (Envoy can continue safely) | Triggerable or uncertain conditions, may be based on untrusted data plane traffic or an extensions contract. |
|                                                                                     | Conditions in alpha or changing extensions that need detectability. (`ENVOY_BUG_ALPHA`) | |
| Unlikely environment errors after process initialization that would otherwise crash | | Likely environment errors, e.g. return codes from untrusted extensions, dependencies or system calls, network error, bad data read, permission based errors, etc. |
| Fatal crashing events. e.g. OOMs, deadlocks, no process recovery possible | | |

# Hermetic and deterministic tests

Tests should be hermetic, i.e. have all dependencies explicitly captured and not depend on the local
environment. In general, there should be no non-local network access. In addition:

* Port numbers should not be hardcoded. Tests should bind to port zero and then discover the bound
  port when needed. This avoids flakes due to conflicting ports and allows tests to be executed
  concurrently by Bazel. See
  [`test/integration/integration_test.h`](test/integration/integration_test.h) and
  [`test/common/network/listener_impl_test.cc`](test/common/network/listener_impl_test.cc)
  for examples of tests that do this.

* Paths should be constructed using:
  * The methods in [`TestEnvironment`](test/test_common/environment.h) for C++ tests.
  * With `${TEST_TMPDIR}` (for writable temporary space) or `${TEST_SRCDIR}` for read-only access to
    test inputs in shell tests.
  * With `{{ test_tmpdir }}`, `{{ test_rundir }}` and `{{ test_udsdir }}` respectively for JSON templates.
    `{{ test_udsdir }}` is provided for pathname based Unix Domain Sockets, which must fit within a
    108 character limit on Linux, a property that might not hold for `{{ test_tmpdir }}`.

Tests should be deterministic. They should not rely on randomness or details
such as the current time. Instead, mocks such as
[`MockRandomGenerator`](test/mocks/runtime/mocks.h) and
[`Mock*TimeSource`](test/mocks/common.h) should be used.

# Google style guides for other languages

* [Python](https://google.github.io/styleguide/pyguide.html)
* [Bash](https://google.github.io/styleguide/shell.xml)
* [Bazel](https://bazel.build/versions/master/docs/skylark/build-style.html)
# Uncomment the examples you'd like to use!
import examples/kotlin/hello_world/.bazelproject
import examples/java/hello_world/.bazelproject
import test/kotlin/apps/baseline/.bazelproject
import test/kotlin/apps/experimental/.bazelproject

android_sdk_platform: android-31
import Envoy
import EnvoyEngine
import Foundation
import XCTest

final class QUICStreamTests: XCTestCase {
  func testQUICStream() throws {
    // swiftlint:disable:next line_length
    let hcmType = "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager"
    // swiftlint:disable:next line_length
    let quicDownstreamType = "type.googleapis.com/envoy.extensions.transport_sockets.quic.v3.QuicDownstreamTransport"
    // swiftlint:disable:next line_length
    let quicUpstreamType = "type.googleapis.com/envoy.extensions.transport_sockets.quic.v3.QuicUpstreamTransport"
    let config =
    """
    static_resources:
      listeners:
      - name: h3_remote_listener
        address:
          socket_address: { protocol: UDP, address: 127.0.0.1, port_value: 10101 }
        reuse_port: true
        udp_listener_config:
          quic_options: {}
          downstream_socket_config:
            prefer_gro: true
        filter_chains:
          transport_socket:
            name: envoy.transport_sockets.quic
            typed_config:
              "@type": \(quicDownstreamType)
              downstream_tls_context:
                common_tls_context:
                  alpn_protocols: h3
                  tls_certificates:
                    certificate_chain:
                      inline_string: |
                        -----BEGIN CERTIFICATE-----
                        MIIEbDCCA1SgAwIBAgIUJuVBh0FKfFgIcO++ljWm7D47eYUwDQYJKoZIhvcNAQEL
                        BQAwdjELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcM
                        DVNhbiBGcmFuY2lzY28xDTALBgNVBAoMBEx5ZnQxGTAXBgNVBAsMEEx5ZnQgRW5n
                        aW5lZXJpbmcxEDAOBgNVBAMMB1Rlc3QgQ0EwHhcNMjAwODA1MTkxNjAxWhcNMjIw
                        ODA1MTkxNjAxWjCBpjELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWEx
                        FjAUBgNVBAcMDVNhbiBGcmFuY2lzY28xDTALBgNVBAoMBEx5ZnQxGTAXBgNVBAsM
                        EEx5ZnQgRW5naW5lZXJpbmcxGjAYBgNVBAMMEVRlc3QgQmFja2VuZCBUZWFtMSQw
                        IgYJKoZIhvcNAQkBFhViYWNrZW5kLXRlYW1AbHlmdC5jb20wggEiMA0GCSqGSIb3
                        DQEBAQUAA4IBDwAwggEKAoIBAQC9JgaI7hxjPM0tsUna/QmivBdKbCrLnLW9Teak
                        RH/Ebg68ovyvrRIlybDT6XhKi+iVpzVY9kqxhGHgrFDgGLBakVMiYJ5EjIgHfoo4
                        UUAHwIYbunJluYCgANzpprBsvTC/yFYDVMqUrjvwHsoYYVm36io994k9+t813b70
                        o0l7/PraBsKkz8NcY2V2mrd/yHn/0HAhv3hl6iiJme9yURuDYQrae2ACSrQtsbel
                        KwdZ/Re71Z1awz0OQmAjMa2HuCop+Q/1QLnqBekT5+DH1qKUzJ3Jkq6NRkERXOpi
                        87j04rtCBteCogrO67qnuBZ2lH3jYEMb+lQdLkyNMLltBSdLAgMBAAGjgcAwgb0w
                        DAYDVR0TAQH/BAIwADALBgNVHQ8EBAMCBeAwHQYDVR0lBBYwFAYIKwYBBQUHAwIG
                        CCsGAQUFBwMBMEEGA1UdEQQ6MDiGHnNwaWZmZTovL2x5ZnQuY29tL2JhY2tlbmQt
                        dGVhbYIIbHlmdC5jb22CDHd3dy5seWZ0LmNvbTAdBgNVHQ4EFgQU2XcTZbc0xKZf
                        gNVKSvAbMZJCBoYwHwYDVR0jBBgwFoAUlkvaLFO0vpXGk3Pip6SfLg1yGIcwDQYJ
                        KoZIhvcNAQELBQADggEBAFW05aca3hSiEz/g593GAV3XP4lI5kYUjGjbPSy/HmLr
                        rdv/u3bGfacywAPo7yld+arMzd35tIYEqnhoq0+/OxPeyhwZXVVUatg5Oknut5Zv
                        2+8l+mVW+8oFCXRqr2gwc8Xt4ByYN+HaNUYfoucnjDplOPukkfSuRhbxqnkhA14v
                        Lri2EbISX14sXf2VQ9I0dkm1hXUxiO0LlA1Z7tvJac9zPSoa6Oljke4D1iH2jzwF
                        Yn7S/gGvVQgkTmWrs3S3TGyBDi4GTDhCF1R+ESvXz8z4UW1MrCSdYUXbRtsT7sbE
                        CjlFYuUyxCi1oe3IHCeXVDo/bmzwGQPDuF3WaDNSYWU=
                        -----END CERTIFICATE-----
                    private_key:
                      inline_string: |
                        -----BEGIN RSA PRIVATE KEY-----
                        MIIEpAIBAAKCAQEAvSYGiO4cYzzNLbFJ2v0JorwXSmwqy5y1vU3mpER/xG4OvKL8
                        r60SJcmw0+l4Sovolac1WPZKsYRh4KxQ4BiwWpFTImCeRIyIB36KOFFAB8CGG7py
                        ZbmAoADc6aawbL0wv8hWA1TKlK478B7KGGFZt+oqPfeJPfrfNd2+9KNJe/z62gbC
                        pM/DXGNldpq3f8h5/9BwIb94ZeooiZnvclEbg2EK2ntgAkq0LbG3pSsHWf0Xu9Wd
                        WsM9DkJgIzGth7gqKfkP9UC56gXpE+fgx9ailMydyZKujUZBEVzqYvO49OK7QgbX
                        gqIKzuu6p7gWdpR942BDG/pUHS5MjTC5bQUnSwIDAQABAoIBADEMwlcSAFSPuNln
                        hzJ9udj0k8md4T8p5Usw/2WLyeJDdBjg30wjQniAJBXgDmyueWMNmFz4iYgdP1CG
                        /vYOEPV7iCZ7Da/TDZd77hYKo+MevuhD4lSU1VEoyCDjNA8OxKyHJB77BwmlYS+0
                        nE3UOPLji47EOVfUTbvnRBSmn3DCSHkQiRIUP1xMivoiZgKJn+D+FxSMwwiq2pQR
                        5tdo7nh2A8RxlYUbaD6i4poUB26HVm8vthXahNEkLpXQOz8MWRzs6xOdDHRzi9kT
                        ItRLa4A/3LIATqviQ2EpwcALHXcULcNUMTHORC1EHPvheWR5nLuRllYzN4ReoeHC
                        3+A5KEkCgYEA52rlh/22/rLckCWugjyJic17vkg46feSOGhjuP2LelrIxNlg491y
                        o28n8lQPSVnEp3/sT7Y3quVvdboq4DC9LTzq52f6/mCYh9UQRpljuSmFqC2MPG46
                        Zl5KLEVLzhjC8aTWkhVINSpz9vauXderOpFYlPW32lnRTjJWE276kj8CgYEA0T2t
                        ULnn7TBvRSpmeWzEBA5FFo2QYkYvwrcVe0pfUltV6pf05xUmMXYFjpezSTEmPhh6
                        +dZdhwxDk+6j8Oo61rTWucDsIqMj5ZT1hPNph8yQtb5LRlRbLGVrirU9Tp7xTgMq
                        3uRA2Eka1d98dDBsEbMIVFSZ2MX3iezSGRL6j/UCgYEAxZQ82HjEDn2DVwb1EXjC
                        LQdliTZ8cTXQf5yQ19aRiSuNkpPN536ga+1xe7JNQuEDx8auafg3Ww98tFT4WmUC
                        f2ctX9klMJ4kXISK2twHioVq+gW5X7b04YXLajTX3eTCPDHyiNLmzY2raMWAZdrG
                        9MA3kyafjCt3Sn4rg3gTM10CgYEAtJ8WRpJEd8aQttcUIItYZdvfnclUMtE9l0su
                        GwCnalN3xguol/X0w0uLHn0rgeoQhhfhyFtY3yQiDcg58tRvODphBXZZIMlNSnic
                        vEjW9ygKXyjGmA5nqdpezB0JsB2aVep8Dm5g35Ozu52xNCc8ksbGUO265Jp3xbMN
                        5iEw9CUCgYBmfoPnJwzA5S1zMIqESUdVH6p3UwHU/+XTY6JHAnEVsE+BuLe3ioi7
                        6dU4rFd845MCkunBlASLV8MmMbod9xU0vTVHPtmANaUCPxwUIxXQket09t19Dzg7
                        A23sE+5myXtcfz6YrPhbLkijV4Nd7fmecodwDckvpBaWTMrv52/Www==
                        -----END RSA PRIVATE KEY-----
          filters:
          - name: envoy.filters.network.http_connection_manager
            typed_config:
              "@type": \(hcmType)
              codec_type: HTTP3
              stat_prefix: remote_hcm
              route_config:
                name: remote_route
                virtual_hosts:
                - name: remote_service
                  domains: ["*"]
                  routes:
                  - match: { prefix: "/" }
                    direct_response: { status: 200 }
              http3_protocol_options:
              http_filters:
              - name: envoy.router
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
      - name: base_api_listener
        address:
          socket_address: { protocol: TCP, address: 0.0.0.0, port_value: 10000 }
        api_listener:
          api_listener:
            "@type": \(hcmType)
            stat_prefix: api_hcm
            route_config:
              name: api_router
              virtual_hosts:
              - name: api
                domains: ["*"]
                routes:
                - match: { prefix: "/" }
                  route: { host_rewrite_literal: lyft.com, cluster: h3_remote }
            http_filters:
            - name: envoy.router
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
      clusters:
      - name: h3_remote
        connect_timeout: 10s
        type: STATIC
        dns_lookup_family: V4_ONLY
        lb_policy: ROUND_ROBIN
        load_assignment:
          cluster_name: h3_remote
          endpoints:
          - lb_endpoints:
            - endpoint:
                address:
                  socket_address: { address: 127.0.0.1, port_value: 10101 }
        typed_extension_protocol_options:
          envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
            "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
            explicit_http_config:
              http3_protocol_options: {}
            common_http_protocol_options:
              idle_timeout: 1s
        transport_socket:
          name: envoy.transport_sockets.quic
          typed_config:
            "@type": \(quicUpstreamType)
            upstream_tls_context:
              sni: lyft.com
    """
    let expectation = self.expectation(description: "Complete response received.")

    let client = EngineBuilder(yaml: config)
      .addLogLevel(.trace)
      .build()
      .streamClient()

    let requestHeaders = RequestHeadersBuilder(method: .get, scheme: "https",
                                               authority: "lyft.com", path: "/test")
      .build()

    client
      .newStreamPrototype()
      .setOnResponseHeaders { responseHeaders, endStream, _ in
        XCTAssertEqual(200, responseHeaders.httpStatus)
        if endStream {
          expectation.fulfill()
        }
      }
      .setOnResponseData { _, endStream, _ in
        if endStream {
          expectation.fulfill()
        }
      }
      .setOnError { _, _ in
        XCTFail("Unexpected error")
      }
      .start()
      .sendHeaders(requestHeaders, endStream: true)

    XCTAssertEqual(XCTWaiter.wait(for: [expectation], timeout: 1), .completed)
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:apple.bzl", "envoy_mobile_swift_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_swift_test(
    name = "quic_stream_test",
    srcs = [
        "QUICStreamTest.swift",
    ],
    data = [
        "@envoy//test/config/integration/certs",
    ],
    visibility = ["//visibility:public"],
    deps = [
        "//library/objective-c:envoy_engine_objc_lib",
    ],
)
#!/usr/bin/env bash

# Generates a compile_commands.json file for use with the VS Code clangd plugin.
# This is a modification of evnoy/tools/vscode/refresh_compdb.sh which hits
# the correct envoy-mobile Bazel targets.

# Setting TEST_TMPDIR here so the compdb headers won't be overwritten by another bazel run
CC=clang TEST_TMPDIR=${BUILD_DIR:-/tmp}/envoy-mobile-compdb ../tools/gen_compilation_database.py --vscode --bazel ./bazelw //library/cc/... //library/common/... //test/cc/... //test/common/...

# Kill clangd to reload the compilation database
pkill clangd || :
#!/bin/bash

set -euo pipefail

ktfmt_version="0.46"
readonly ktfmt_version

ktfmt_url="https://repo1.maven.org/maven2/com/facebook/ktfmt/${ktfmt_version}/ktfmt-${ktfmt_version}-jar-with-dependencies.jar"
readonly ktfmt_url

ktfmt_sha256="97fc7fbd194d01a9fa45d8147c0552403003d55bac4ab89d84d7bb4d5e3f48de"
readonly ktfmt_sha256

jdk_url="https://cdn.azul.com/zulu/bin/zulu11.68.17-ca-jdk11.0.21-linux_x64.tar.gz"
readonly jdk_url

jdk_sha256="725aba257da4bca14959060fea3faf59005eafdc2d5ccc3cb745403c5b60fb27"
readonly jdk_sha256

script_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
readonly script_root

ktfmt_jar="$script_root/tmp/ktfmt/versions/ktfmt-0.46.jar"
readonly ktfmt_jar

jdk="$script_root/tmp/jdk/versions/jdk11"
readonly jdk

java="${jdk}"/bin/java
readonly java

check_sha256sum() {
  sha256="$1"
  binary="$2"
  sha_check=$(echo "${sha256}" "${binary}" | sha256sum --quiet --check || true)
  echo "${sha_check}"
  if [[ -n "${sha_check}" ]]; then
    echo "Deleting ${binary}" >&2
    rm -f "$binary"
    exit 1
  fi
}

download_jdk() {
  mkdir -p "${jdk}"

  download_temp_dir=$(mktemp -d)
  jdk_tar_gz="${download_temp_dir}/jdk.tar.gz"
  curl --fail -L --retry 5 --retry-connrefused --silent --progress-bar \
    --output "${jdk_tar_gz}" "$jdk_url"

  check_sha256sum "${jdk_sha256}" "${jdk_tar_gz}"

  tar -C "${jdk}" -xf "${jdk_tar_gz}" --strip-components=1
}

download_ktfmt() {
  mkdir -p "$(dirname "${ktfmt_jar}")"

  curl --fail -L --retry 5 --retry-connrefused --silent --progress-bar \
    --output "$ktfmt_jar" "$ktfmt_url"

  check_sha256sum "${ktfmt_sha256}" "${ktfmt_jar}"
}

# TODO(fredyw): Use CI's JDK when available.
if [[ ! -f "${java}" ]]; then
  download_jdk
fi

if [[ ! -f "${ktfmt_jar}" ]]; then
  download_ktfmt
fi

"${java}" -jar "${ktfmt_jar}" --google-style "$@"
#!/usr/bin/env bash

set -euo pipefail

symbolgraph_dir="${1:-}"
if [[ -z "$symbolgraph_dir" ]]; then
  ./bazelw build //library/swift:ios_lib --config=release-ios --output_groups=+swift_symbol_graph
  symbolgraph_dir="bazel-bin/library/swift/ios_lib.symbolgraph"
fi

"$(xcrun --find docc)" convert \
  --index \
  --fallback-display-name Envoy \
  --fallback-bundle-identifier io.envoyproxy.EnvoyMobile \
  --fallback-bundle-version "$(cat VERSION)" \
  --output-dir Envoy.doccarchive \
  --additional-symbol-graph-dir "$symbolgraph_dir"
#!/usr/bin/env bash

set -e

ENVOY_FORMAT_ACTION="$1"
if [ -z "$ENVOY_FORMAT_ACTION" ]; then
  echo "No action specified, defaulting to check"
  ENVOY_FORMAT_ACTION="check"
fi

if [[ $(uname) == "Darwin" ]]; then
  if [[ "${ENVOY_FORMAT_ACTION}" == "fix" ]]; then
    ./bazelw run @SwiftLint//:swiftlint -- --fix --quiet 2>/dev/null
    ./bazelw run @DrString//:drstring format 2>/dev/null
  else
    ./bazelw run @SwiftLint//:swiftlint -- --strict --quiet 2>/dev/null
    ./bazelw run @DrString//:drstring check 2>/dev/null
  fi
fi

TARGET_PATH="$2"

# TODO(mattklein123): WORKSPACE is excluded due to warning about @bazel_tools reference. Fix here
#                     or in the upstream checker.

FORMAT_ARGS=(
    --config_path ../tools/code_format/config.yaml
    --add-excluded-prefixes
    ./envoy/ ./envoy_build_config/extensions_build_config.bzl ./WORKSPACE
    ./Envoy.xcodeproj/ ./dist/
    ./bazel/envoy_mobile_swift_bazel_support.bzl
    ./bazel/envoy_mobile_repositories.bzl
    ./examples/swift/swiftpm/Packages/Envoy.xcframework ./tmp
    --skip_envoy_build_rule_check)
if [[ -n "$TARGET_PATH" ]]; then
    FORMAT_ARGS+=("$TARGET_PATH")
fi
FORMAT_ARGS+=(
    --namespace_check_excluded_paths
    ./envoy ./examples/ ./library/java/ ./library/kotlin
    ./library/objective-c ./test/java ./test/java
    ./test/objective-c ./test/swift ./experimental/swift
    --build_fixer_check_excluded_paths
    ./envoy ./BUILD ./dist)

export ENVOY_BAZEL_PREFIX="@envoy" && ./bazelw run @envoy//tools/code_format:check_format -- "${ENVOY_FORMAT_ACTION}" --path "$PWD" "${FORMAT_ARGS[@]}"

KTFMT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"/ktfmt.sh
KOTLIN_DIRS=(
  "library/kotlin"
  "test/kotlin"
  "examples/kotlin"
)
if [[ "${ENVOY_FORMAT_ACTION}" == "fix" ]]; then
  "${KTFMT}" "${KOTLIN_DIRS[@]}"
else
  NEEDS_FORMAT=$("${KTFMT}" --dry-run "${KOTLIN_DIRS[@]}")
  if [[ -n "${NEEDS_FORMAT}" ]]; then
    echo "ERROR: Run 'tools/check_format.sh fix' to fix"
    echo "${NEEDS_FORMAT}"
    exit 1
  fi
fi
#!/usr/bin/env bash

set -euo pipefail

##################################################################
# post_to_slack.sh
#
# Posts a message to the #envoy-mobile-collaboration Slack channel
#
# Usage: `SLACK_BOT_TOKEN=x post_to_slack.sh "markdown message"`
##################################################################

curl -H "Content-type: application/json; charset=utf-8" \
  --data "{\"channel\":\"C02F93EEJCE\",\"blocks\":[{\"type\":\"section\",\"text\":{\"type\":\"mrkdwn\",\"text\":\"$1\"}}]}" \
  -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
  -X POST \
  https://slack.com/api/chat.postMessage
#include "source/extensions/network/dns_resolver/apple/apple_dns_impl.h"

#include "extension_registry_platform_additions.h"

namespace Envoy {

void ExtensionRegistryPlatformAdditions::registerFactories() {
  Envoy::Network::forceRegisterAppleDnsResolverFactory();
}

} // namespace Envoy
#pragma once

namespace Envoy {
class ExtensionRegistryPlatformAdditions {
public:
  // As a server, Envoy's static factory registration happens when main is run. However, when
  // compiled as a library, there is no guarantee that such registration will happen before the
  // names are needed. The following calls ensure that registration happens before the entities are
  // needed. Note that as more registrations are needed, explicit initialization calls will need to
  // be added here.
  static void registerFactories();
};
} // namespace Envoy
CONTRIB_EXTENSION_PACKAGE_VISIBILITY = ["@envoy//:contrib_library"]
MOBILE_PACKAGE_VISIBILITY = ["@envoy//:mobile_library"]
EXTENSION_CONFIG_VISIBILITY = ["//visibility:public"]
EXTENSION_PACKAGE_VISIBILITY = ["//visibility:public"]
EXTENSIONS = {
    "envoy.clusters.dynamic_forward_proxy":                "//source/extensions/clusters/dynamic_forward_proxy:cluster",
    "envoy.clusters.static":                               "//source/extensions/clusters/static:static_cluster_lib",
    "envoy.filters.connection_pools.http.generic":         "//source/extensions/upstreams/http/generic:config",
    "envoy.filters.http.alternate_protocols_cache":        "//source/extensions/filters/http/alternate_protocols_cache:config",
    "envoy.filters.http.assertion":                        "@envoy_mobile//library/common/extensions/filters/http/assertion:config",
    "envoy.filters.http.buffer":                           "//source/extensions/filters/http/buffer:config",
    "envoy.filters.http.decompressor":                     "//source/extensions/filters/http/decompressor:config",
    "envoy.filters.http.dynamic_forward_proxy":            "//source/extensions/filters/http/dynamic_forward_proxy:config",
    "envoy.filters.http.local_error":                      "@envoy_mobile//library/common/extensions/filters/http/local_error:config",
    "envoy.filters.http.platform_bridge":                  "@envoy_mobile//library/common/extensions/filters/http/platform_bridge:config",
    "envoy.filters.http.network_configuration":            "@envoy_mobile//library/common/extensions/filters/http/network_configuration:config",
    "envoy.filters.http.route_cache_reset":                "@envoy_mobile//library/common/extensions/filters/http/route_cache_reset:config",
    "envoy.filters.http.router":                           "//source/extensions/filters/http/router:config",
    "envoy.filters.network.http_connection_manager":       "//source/extensions/filters/network/http_connection_manager:config",
    "envoy.http.original_ip_detection.xff":                "//source/extensions/http/original_ip_detection/xff:config",
    "envoy.key_value.platform":                            "@envoy_mobile//library/common/extensions/key_value/platform:config",
    "envoy.network.dns_resolver.apple":                    "//source/extensions/network/dns_resolver/apple:config",
    "envoy.network.dns_resolver.getaddrinfo":              "//source/extensions/network/dns_resolver/getaddrinfo:config",
    "envoy.retry.options.network_configuration":           "@envoy_mobile//library/common/extensions/retry/options/network_configuration:config",
    "envoy.transport_sockets.http_11_proxy":               "//source/extensions/transport_sockets/http_11_proxy:upstream_config",
    "envoy.transport_sockets.raw_buffer":                  "//source/extensions/transport_sockets/raw_buffer:config",
    "envoy.transport_sockets.tls":                         "//source/extensions/transport_sockets/tls:config",
    "envoy.http.stateful_header_formatters.preserve_case": "//source/extensions/http/header_formatters/preserve_case:config",
    "envoy_mobile.cert_validator.platform_bridge_cert_validator": "@envoy_mobile//library/common/extensions/cert_validator/platform_bridge:config",
    "envoy.listener_manager_impl.api":                     "@envoy_mobile//library/common/extensions/listener_managers/api_listener_manager:api_listener_manager_lib",
    "envoy.connection_handler.default":                    "//source/extensions/listener_managers/listener_manager:connection_handler_lib",
    "envoy.load_balancing_policies.round_robin":           "//source/extensions/load_balancing_policies/round_robin:config",
    "envoy.load_balancing_policies.cluster_provided":      "//source/extensions/load_balancing_policies/cluster_provided:config",
}
WINDOWS_EXTENSIONS = {}
LEGACY_ALWAYSLINK = 1
#pragma once

// NOLINT(namespace-envoy)

#ifdef __cplusplus
extern "C" { // functions
#endif

void register_test_extensions();

#ifdef __cplusplus
} // functions
#endif
#include "source/common/common/assert.h"

#include "test_extensions.h"

namespace Envoy {

class Autoregister {
public:
  Autoregister() { register_test_extensions(); }
};

} // namespace Envoy

static Envoy::Autoregister auto_;
#include "extension_registry_platform_additions.h"

namespace Envoy {

void ExtensionRegistryPlatformAdditions::registerFactories() {}

} // namespace Envoy
#include "source/extensions/clusters/static/static_cluster.h"
#include "source/extensions/filters/http/buffer/config.h"
#include "source/extensions/load_balancing_policies/round_robin/config.h"

#include "test/common/http/filters/assertion/config.h"
#include "test/common/http/filters/route_cache_reset/config.h"
#include "test/common/http/filters/test_accessor/config.h"
#include "test/common/http/filters/test_event_tracker/config.h"
#include "test/common/http/filters/test_kv_store/config.h"
#include "test/common/http/filters/test_logger/config.h"
#include "test/common/http/filters/test_read/config.h"
#include "test/common/http/filters/test_remote_response/config.h"

#include "external/envoy_build_config/test_extensions.h"

#if !defined(ENVOY_ENABLE_FULL_PROTOS)
#include "source/common/protobuf/protobuf.h"
#include "bazel/cc_proto_descriptor_library/file_descriptor_info.h"

#include "test/common/http/filters/test_event_tracker/filter_descriptor.pb.h"
#include "test/common/http/filters/test_read/filter_descriptor.pb.h"
#include "test/common/http/filters/assertion/filter_descriptor.pb.h"
#include "test/common/http/filters/test_remote_response/filter_descriptor.pb.h"
#include "test/common/http/filters/test_accessor/filter_descriptor.pb.h"
#include "test/common/http/filters/route_cache_reset/filter_descriptor.pb.h"
#include "test/common/http/filters/test_kv_store/filter_descriptor.pb.h"
#include "test/common/http/filters/test_logger/filter_descriptor.pb.h"
#endif

void register_test_extensions() {
  Envoy::Extensions::HttpFilters::Assertion::forceRegisterAssertionFilterFactory();
  Envoy::Extensions::HttpFilters::BufferFilter::forceRegisterBufferFilterFactory();
  Envoy::Extensions::HttpFilters::RouteCacheReset::forceRegisterRouteCacheResetFilterFactory();
  Envoy::Extensions::HttpFilters::TestAccessor::forceRegisterTestAccessorFilterFactory();
  Envoy::Extensions::HttpFilters::TestEventTracker::forceRegisterTestEventTrackerFilterFactory();
  Envoy::Extensions::HttpFilters::TestKeyValueStore::forceRegisterTestKeyValueStoreFilterFactory();
  Envoy::Extensions::HttpFilters::TestLogger::forceRegisterFactory();
  Envoy::Extensions::HttpFilters::TestRemoteResponse::
      forceRegisterTestRemoteResponseFilterFactory();
  Envoy::Extensions::LoadBalancingPolices::RoundRobin::forceRegisterFactory();
  Envoy::HttpFilters::TestRead::forceRegisterTestReadFilterFactory();
  Envoy::Upstream::forceRegisterStaticClusterFactory();

#if !defined(ENVOY_ENABLE_FULL_PROTOS)
  std::vector<Envoy::FileDescriptorInfo> file_descriptors = {
      protobuf::reflection::test_common_http_filters_test_event_tracker_filter::kFileDescriptorInfo,
      protobuf::reflection::test_common_http_filters_test_read_filter::kFileDescriptorInfo,
      protobuf::reflection::test_common_http_filters_assertion_filter::kFileDescriptorInfo,
      protobuf::reflection::test_common_http_filters_test_remote_response_filter::
          kFileDescriptorInfo,
      protobuf::reflection::test_common_http_filters_test_accessor_filter::kFileDescriptorInfo,
      protobuf::reflection::test_common_http_filters_route_cache_reset_filter::kFileDescriptorInfo,
      protobuf::reflection::test_common_http_filters_test_kv_store_filter::kFileDescriptorInfo,
      protobuf::reflection::test_common_http_filters_test_logger_filter::kFileDescriptorInfo,
  };
  for (const Envoy::FileDescriptorInfo& descriptor : file_descriptors) {
    Envoy::loadFileDescriptors(descriptor);
  }
#endif
}
#pragma once

namespace Envoy {
class ExtensionRegistry {
public:
  // As a server, Envoy's static factory registration happens when main is run. However, when
  // compiled as a library, there is no guarantee that such registration will happen before the
  // names are needed. The following calls ensure that registration happens before the entities are
  // needed. Note that as more registrations are needed, explicit initialization calls will need to
  // be added here.
  static void registerFactories();
};
} // namespace Envoy
load(
    "@envoy//bazel:envoy_build_system.bzl",
    "envoy_cc_library",
    "envoy_mobile_package",
    "envoy_select_enable_http3",
    "envoy_select_envoy_mobile_listener",
    "envoy_select_envoy_mobile_xds",
)

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_cc_library(
    name = "extension_registry",
    srcs = [
        "extension_registry.cc",
    ],
    hdrs = ["extension_registry.h"],
    repository = "@envoy",
    deps = [
        "extension_registry_platform_additions",
        "@envoy//source/common/http/matching:inputs_lib",
        "@envoy//source/common/network:socket_lib",
        "@envoy//source/common/router:upstream_codec_filter_lib",
        "@envoy//source/common/upstream:default_local_address_selector_factory",
        "@envoy//source/common/watchdog:abort_action_config",
        "@envoy//source/extensions/clusters/dynamic_forward_proxy:cluster",
        "@envoy//source/extensions/compression/brotli/decompressor:config",
        "@envoy//source/extensions/compression/gzip/decompressor:config",
        "@envoy//source/extensions/filters/http/alternate_protocols_cache:config",
        "@envoy//source/extensions/filters/http/buffer:config",
        "@envoy//source/extensions/filters/http/decompressor:config",
        "@envoy//source/extensions/filters/http/dynamic_forward_proxy:config",
        "@envoy//source/extensions/filters/http/router:config",
        "@envoy//source/extensions/filters/network/http_connection_manager:config",
        "@envoy//source/extensions/http/header_formatters/preserve_case:config",
        "@envoy//source/extensions/load_balancing_policies/cluster_provided:config",
        "@envoy//source/extensions/network/dns_resolver/getaddrinfo:config",
        "@envoy//source/extensions/path/match/uri_template:config",
        "@envoy//source/extensions/path/rewrite/uri_template:config",
        "@envoy//source/extensions/request_id/uuid:config",
        "@envoy//source/extensions/transport_sockets/http_11_proxy:upstream_config",
        "@envoy//source/extensions/transport_sockets/raw_buffer:config",
        "@envoy//source/extensions/transport_sockets/tls:config",
        "@envoy//source/extensions/transport_sockets/tls/cert_validator:cert_validator_lib",
        "@envoy//source/extensions/upstreams/http/generic:config",
        "@envoy_mobile//library/common/extensions/cert_validator/platform_bridge:config",
        "@envoy_mobile//library/common/extensions/filters/http/local_error:config",
        "@envoy_mobile//library/common/extensions/filters/http/network_configuration:config",
        "@envoy_mobile//library/common/extensions/filters/http/platform_bridge:config",
        "@envoy_mobile//library/common/extensions/filters/http/socket_tag:config",
        "@envoy_mobile//library/common/extensions/key_value/platform:config",
        "@envoy_mobile//library/common/extensions/listener_managers/api_listener_manager:api_listener_manager_lib",
        "@envoy_mobile//library/common/extensions/retry/options/network_configuration:config",
    ] + envoy_select_enable_http3(
        [
            "@envoy//source/common/quic:quic_transport_socket_factory_lib",
        ],
        "@envoy",
    ) + envoy_select_envoy_mobile_listener(
        [
            "@envoy//source/extensions/udp_packet_writer/default:config",
            "@envoy//source/common/listener_manager:listener_manager_lib",
            "@envoy//source/common/listener_manager:connection_handler_lib",
        ],
        "@envoy",
    ) + envoy_select_envoy_mobile_xds(
        [
            "@envoy//source/extensions/config_subscription/grpc:grpc_collection_subscription_lib",
            "@envoy//source/extensions/config_subscription/grpc:grpc_mux_lib",
            "@envoy//source/extensions/config_subscription/grpc:grpc_subscription_lib",
        ],
        "@envoy",
    ),
)

envoy_cc_library(
    name = "extension_registry_platform_additions",
    srcs = select({
        "@envoy//bazel:apple": ["extension_registry_apple.cc"],
        "//conditions:default": ["extension_registry_noop.cc"],
    }),
    hdrs = ["extension_registry_platform_additions.h"],
    repository = "@envoy",
    deps = select({
        "@envoy//bazel:apple": ["@envoy//source/extensions/network/dns_resolver/apple:config"],
        "//conditions:default": [],
    }),
)

# for java and C++ auto-register the test libraries.
envoy_cc_library(
    name = "test_extensions",
    srcs = [
        "test_extensions_autoregister.cc",
    ],
    repository = "@envoy",
    deps = [":test_extensions_no_autoregister"],
    alwayslink = 1,
)

# swift may compile out autoregistry functions, so registration will be performed manually.
envoy_cc_library(
    name = "test_extensions_no_autoregister",
    srcs = [
        "test_extensions.cc",
    ],
    hdrs = [
        "test_extensions.h",
    ],
    repository = "@envoy",
    # List of modules to compile into the test files. For JVM we always compile these into the .so all
    # the time, while for iOS we have to force register the extensions, so test files must pull in
    # the TestExtensions module and call register_test_extensions().
    deps = [
        "@envoy//source/extensions/clusters/static:static_cluster_lib",
        "@envoy//source/extensions/filters/http/buffer:config",
        "@envoy//source/extensions/load_balancing_policies/round_robin:config",
        "@envoy_mobile//test/common/http/filters/assertion:config",
        "@envoy_mobile//test/common/http/filters/assertion:filter_cc_proto_descriptor",
        "@envoy_mobile//test/common/http/filters/route_cache_reset:config",
        "@envoy_mobile//test/common/http/filters/route_cache_reset:filter_cc_proto_descriptor",
        "@envoy_mobile//test/common/http/filters/test_accessor:config",
        "@envoy_mobile//test/common/http/filters/test_accessor:filter_cc_proto_descriptor",
        "@envoy_mobile//test/common/http/filters/test_event_tracker:config",
        "@envoy_mobile//test/common/http/filters/test_event_tracker:filter_cc_proto_descriptor",
        "@envoy_mobile//test/common/http/filters/test_kv_store:config",
        "@envoy_mobile//test/common/http/filters/test_kv_store:filter_cc_proto_descriptor",
        "@envoy_mobile//test/common/http/filters/test_logger:config",
        "@envoy_mobile//test/common/http/filters/test_logger:filter_cc_proto_descriptor",
        "@envoy_mobile//test/common/http/filters/test_read:config",
        "@envoy_mobile//test/common/http/filters/test_read:filter_cc_proto_descriptor",
        "@envoy_mobile//test/common/http/filters/test_remote_response:config",
        "@envoy_mobile//test/common/http/filters/test_remote_response:filter_cc_proto_descriptor",
    ],
    alwayslink = 1,
)
#include "extension_registry.h"

#include "source/common/http/match_delegate/config.h"
#include "source/common/http/matching/inputs.h"
#include "source/common/network/default_client_connection_factory.h"
#include "source/common/network/resolver_impl.h"
#include "source/common/network/socket_interface_impl.h"
#include "source/common/router/upstream_codec_filter.h"
#include "source/common/upstream/default_local_address_selector_factory.h"
#include "source/common/watchdog/abort_action_config.h"
#include "source/extensions/clusters/dynamic_forward_proxy/cluster.h"
#include "source/extensions/compression/brotli/decompressor/config.h"
#include "source/extensions/compression/gzip/decompressor/config.h"
#include "source/extensions/early_data/default_early_data_policy.h"
#include "source/extensions/filters/http/alternate_protocols_cache/config.h"
#include "source/extensions/filters/http/buffer/config.h"
#include "source/extensions/filters/http/decompressor/config.h"
#include "source/extensions/filters/http/dynamic_forward_proxy/config.h"
#include "source/extensions/filters/http/router/config.h"
#include "source/extensions/filters/network/http_connection_manager/config.h"
#include "source/extensions/http/header_formatters/preserve_case/config.h"
#include "source/extensions/http/header_validators/envoy_default/config.h"
#include "source/extensions/http/original_ip_detection/xff/config.h"
#include "source/extensions/load_balancing_policies/cluster_provided/config.h"
#include "source/extensions/network/dns_resolver/getaddrinfo/getaddrinfo.h"
#include "source/extensions/path/match/uri_template/config.h"
#include "source/extensions/path/rewrite/uri_template/config.h"
#include "source/extensions/request_id/uuid/config.h"
#include "source/extensions/transport_sockets/http_11_proxy/config.h"
#include "source/extensions/transport_sockets/raw_buffer/config.h"
#include "source/extensions/transport_sockets/tls/cert_validator/default_validator.h"
#include "source/extensions/transport_sockets/tls/config.h"
#include "source/extensions/upstreams/http/generic/config.h"

#ifdef ENVOY_MOBILE_ENABLE_LISTENER
#include "source/common/listener_manager/listener_manager_impl.h"
#include "source/common/listener_manager/connection_handler_impl.h"
#endif

#ifdef ENVOY_ENABLE_QUIC
#ifdef ENVOY_MOBILE_ENABLE_LISTENER
#include "source/common/quic/server_codec_impl.h"
#include "source/extensions/quic/connection_id_generator/envoy_deterministic_connection_id_generator_config.h"
#include "source/extensions/quic/crypto_stream/envoy_quic_crypto_server_stream.h"
#include "source/extensions/quic/proof_source/envoy_quic_proof_source_factory_impl.h"
#include "source/extensions/udp_packet_writer/default/config.h"
#endif
#include "source/common/quic/quic_client_transport_socket_factory.h"
#endif

#include "extension_registry_platform_additions.h"
#include "library/common/extensions/cert_validator/platform_bridge/config.h"
#include "library/common/extensions/filters/http/local_error/config.h"
#include "library/common/extensions/filters/http/network_configuration/config.h"
#include "library/common/extensions/filters/http/platform_bridge/config.h"
#include "library/common/extensions/filters/http/socket_tag/config.h"
#include "library/common/extensions/key_value/platform/config.h"
#include "library/common/extensions/listener_managers/api_listener_manager/api_listener_manager.h"
#include "library/common/extensions/retry/options/network_configuration/config.h"

#ifdef ENVOY_MOBILE_XDS
#include "source/extensions/config_subscription/grpc/grpc_collection_subscription_factory.h"
#include "source/extensions/config_subscription/grpc/grpc_mux_impl.h"
#include "source/extensions/config_subscription/grpc/grpc_subscription_factory.h"
#include "source/extensions/config_subscription/grpc/new_grpc_mux_impl.h"
#include "source/extensions/transport_sockets/tls/cert_validator/default_validator.h"
#endif

namespace Envoy {

void ExtensionRegistry::registerFactories() {
  Common::Http::MatchDelegate::Factory::forceRegisterSkipActionFactory();
  Common::Http::MatchDelegate::forceRegisterMatchDelegateConfig();

  ExtensionRegistryPlatformAdditions::registerFactories();

  // The uuid extension is required for E-M for server mode. Ideally E-M could skip it.
  Extensions::RequestId::forceRegisterUUIDRequestIDExtensionFactory();
  // This is the original IP detection code which ideally E-M could skip.
  Extensions::Http::OriginalIPDetection::Xff::forceRegisterXffIPDetectionFactory();

  // TODO(alyssar) verify with Lyft that we can move this to be a test-only and
  // figure out how to build into test apps.
  Extensions::HttpFilters::BufferFilter::forceRegisterBufferFilterFactory();

  // This is the default cluster used by Envoy mobile to establish connections upstream.
  Extensions::Clusters::DynamicForwardProxy::forceRegisterClusterFactory();
  // This allows decompression of brotli-compresssed responses.
  Extensions::Compression::Brotli::Decompressor::forceRegisterBrotliDecompressorLibraryFactory();
  // This allows decompression of gzip-decompressed responses.
  Extensions::Compression::Gzip::Decompressor::forceRegisterGzipDecompressorLibraryFactory();
  // This is the base decompressor filter used for both gzip and brotli.
  Extensions::HttpFilters::Decompressor::forceRegisterDecompressorFilterFactory();
  // This allows HTTP/1.1 requests to preserve their case, as many servers for example do not
  // correctly content-length headers and instead expect Content-Length.
  Extensions::Http::HeaderFormatters::PreserveCase::
      forceRegisterPreserveCaseFormatterFactoryConfig();
  // This is for UHV-based header validation.
  Extensions::Http::HeaderValidators::EnvoyDefault::forceRegisterHeaderValidatorFactoryConfig();

  // This caches upstream protocol capabilities to maximize latency for H2 and H3 endpoints.
  Extensions::HttpFilters::AlternateProtocolsCache::
      forceRegisterAlternateProtocolsCacheFilterFactory();
  // This handles DNS lookup for all upstream requests.
  Extensions::HttpFilters::DynamicForwardProxy::forceRegisterDynamicForwardProxyFilterFactory();
  // This converts Envoy "local reply" errors to not look like remote replies to the app.
  Extensions::HttpFilters::LocalError::forceRegisterLocalErrorFilterFactory();
  // This filter handles mobile-specific network config like interface binding and system proxies.
  Extensions::HttpFilters::NetworkConfiguration::forceRegisterNetworkConfigurationFilterFactory();
  // This filter, if configured, allows platform-specific filters e.g. swift or kotlin.
  Extensions::HttpFilters::PlatformBridge::forceRegisterPlatformBridgeFilterFactory();
  // This is Envoy's router filter, required for a functional L7 data plane.
  Extensions::HttpFilters::RouterFilter::forceRegisterRouterFilterConfig();
  // This is Envoy's codec filter, required for a functional L7 data plane.
  Router::forceRegisterUpstreamCodecFilterFactory();

  // This filter applies socket tagging based on the x-envoy-mobile-socket-tag header.
  Extensions::HttpFilters::SocketTag::forceRegisterSocketTagFilterFactory();
  // The k-v store allows caching things like DNS and prefered protocol across application restarts.
  Extensions::KeyValue::forceRegisterPlatformKeyValueStoreFactory();
  // This is Envoy's HCM filter, currently required for a functional L7 data plane.
  Extensions::NetworkFilters::HttpConnectionManager::
      forceRegisterHttpConnectionManagerFilterConfigFactory();
  // This works with the connectivity manager to allow retries across network interfaces.
  Extensions::Retry::Options::forceRegisterNetworkConfigurationRetryOptionsPredicateFactory();
  // This is the default certificate validator, still compiled by default but hopefully soon to be
  // deprecated in production by iOS and Android platform validators.
  Extensions::TransportSockets::Tls::forceRegisterDefaultCertValidatorFactory();
  // This is the base for the still-being-validated platform validators.
  Extensions::TransportSockets::Tls::forceRegisterPlatformBridgeCertValidatorFactory();

  // This transport socket handles upstream TLS connections.
  Extensions::TransportSockets::Tls::forceRegisterUpstreamSslSocketFactory();
  // This transport socket handles doing CONNECT requests to any configured system proxies.
  Extensions::TransportSockets::Http11Connect::
      forceRegisterUpstreamHttp11ConnectSocketConfigFactory();
  Extensions::Upstreams::Http::forceRegisterProtocolOptionsConfigFactory();
  // This transport socket handles plaintext (http) traffic.
  Extensions::TransportSockets::RawBuffer::forceRegisterUpstreamRawBufferSocketFactory();

  // This is the default HTTP connection pool factory required for L7 upstream traffic.
  Extensions::Upstreams::Http::Generic::forceRegisterGenericGenericConnPoolFactory();
  // This is the default TCP client connection factory required for L7 upstream traffic.
  Network::forceRegisterDefaultClientConnectionFactory();
  // This is the default socket factory required for L7 traffic.
  Network::forceRegisterSocketInterfaceImpl();
  // This is the RE factory, required at least if any config uses regex, which stats do.
  Regex::forceRegisterGoogleReEngineFactory();

  // These are required to support specific route configs, if they are on.
  // It's likely no current users of E-M require them so we could optionally compile out by default.
  Router::forceRegisterDefaultEarlyDataPolicyFactory();
  Router::forceRegisterRouteListMatchActionFactory();
  Router::forceRegisterRouteMatchActionFactory();
  Extensions::UriTemplate::Match::forceRegisterUriTemplateMatcherFactory();
  Extensions::UriTemplate::Rewrite::forceRegisterUriTemplateRewriterFactory();
  Http::Matching::forceRegisterHttpRequestHeadersDataInputFactory();
  Http::Matching::forceRegisterHttpRequestTrailersDataInputFactory();
  Http::Matching::forceRegisterHttpResponseHeadersDataInputFactory();
  Http::Matching::forceRegisterHttpResponseTrailersDataInputFactory();

  // Envoy Mobile uses the GetAddrInfo resolver for DNS lookups on android by default.
  // This could be compiled out for iOS.
  Network::forceRegisterGetAddrInfoDnsResolverFactory();

  Network::Address::forceRegisterIpResolver();

  // This is Envoy's lightweight listener manager which lets E-M avoid the 1M
  // hit of compiling in downstream code.
  Server::forceRegisterApiListenerManagerFactoryImpl();

  // This is required code for certain watchdog config, required until Envoy
  // Mobile compiles out watchdog support.
  Watchdog::forceRegisterAbortActionFactory();

  // This is required for the default upstream local address selector.
  Upstream::forceRegisterDefaultUpstreamLocalAddressSelectorFactory();

  // This is required for load balancers of upstream clusters `base` and `base_clear`.
  Envoy::Extensions::LoadBalancingPolices::ClusterProvided::forceRegisterFactory();

#ifdef ENVOY_MOBILE_ENABLE_LISTENER
  // These are downstream factories required if Envoy Mobile is compiled with
  // proxy functionality.
  Extensions::TransportSockets::RawBuffer::forceRegisterDownstreamRawBufferSocketFactory();
  Server::forceRegisterConnectionHandlerFactoryImpl();
  Server::forceRegisterDefaultListenerManagerFactoryImpl();
  Server::FilterChain::forceRegisterFilterChainNameActionFactory();
#endif

#ifdef ENVOY_ENABLE_QUIC

#ifdef ENVOY_MOBILE_ENABLE_LISTENER
  // These are QUIC downstream factories required if Envoy Mobile is compiled with
  // proxy functionality and QUIC support.
  Network::forceRegisterUdpDefaultWriterFactoryFactory();
  Server::forceRegisterConnectionHandlerFactoryImpl();
  Quic::forceRegisterQuicHttpServerConnectionFactoryImpl();
  Quic::forceRegisterEnvoyQuicCryptoServerStreamFactoryImpl();
  Quic::forceRegisterQuicServerTransportSocketConfigFactory();
  Quic::forceRegisterEnvoyQuicProofSourceFactoryImpl();
  Quic::forceRegisterEnvoyDeterministicConnectionIdGeneratorConfigFactory();
#endif
  Quic::forceRegisterQuicClientTransportSocketConfigFactory();
#endif

#ifdef ENVOY_MOBILE_XDS
  // These extensions are required for xDS over gRPC using ADS, which is what Envoy Mobile
  // supports for xDS.
  Config::forceRegisterAdsConfigSubscriptionFactory();
  Config::forceRegisterGrpcConfigSubscriptionFactory();
  Config::forceRegisterAggregatedGrpcCollectionConfigSubscriptionFactory();
  Config::forceRegisterAdsCollectionConfigSubscriptionFactory();
  Config::forceRegisterGrpcMuxFactory();
  Config::forceRegisterNewGrpcMuxFactory();
  Extensions::TransportSockets::Tls::forceRegisterDefaultCertValidatorFactory();
#endif
}

} // namespace Envoy
   Bud1            %                       b a z e ldsclbool                   ldsclbool                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            @                                              @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E   %                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       DSDB                             `                                                     @                                                @                                                @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              package org.chromium.net;

import static org.chromium.net.testing.CronetTestRule.assertContains;
import static org.chromium.net.testing.CronetTestRule.getContext;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import android.os.ConditionVariable;
import android.os.ParcelFileDescriptor;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.CronetTestRule.CronetTestFramework;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.NativeTestServer;
import org.chromium.net.testing.TestUrlRequestCallback;
import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

/** Test the default provided implementations of {@link UploadDataProvider} */
@RunWith(AndroidJUnit4.class)
public class UploadDataProvidersTest {
  private static final String LOREM =
      "Lorem ipsum dolor sit amet, consectetur adipiscing elit. "
      + "Proin elementum, libero laoreet fringilla faucibus, metus tortor vehicula ante, "
      + "lacinia lorem eros vel sapien.";
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();
  private CronetTestFramework mTestFramework;
  private File mFile;

  @Before
  public void setUp() throws Exception {
    mTestFramework = mTestRule.startCronetTestFramework();
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
    // Add url interceptors after native application context is initialized.
    mFile = new File(getContext().getCacheDir().getPath() + "/tmpfile");
    FileOutputStream fileOutputStream = new FileOutputStream(mFile);
    try {
      fileOutputStream.write(LOREM.getBytes("UTF-8"));
    } finally {
      fileOutputStream.close();
    }
  }

  @After
  public void tearDown() {
    NativeTestServer.shutdownNativeTestServer();
    assertTrue(mFile.delete());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testFileProvider() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mTestFramework.mCronetEngine.newUrlRequestBuilder(
        NativeTestServer.getRedirectToEchoBody(), callback, callback.getExecutor());
    UploadDataProvider dataProvider = UploadDataProviders.create(mFile);
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("Content-Type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(LOREM, callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testFileDescriptorProvider() throws Exception {
    ParcelFileDescriptor descriptor =
        ParcelFileDescriptor.open(mFile, ParcelFileDescriptor.MODE_READ_ONLY);
    assertTrue(descriptor.getFileDescriptor().valid());
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mTestFramework.mCronetEngine.newUrlRequestBuilder(
        NativeTestServer.getRedirectToEchoBody(), callback, callback.getExecutor());
    UploadDataProvider dataProvider = UploadDataProviders.create(descriptor);
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("Content-Type", "useless/string");
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(LOREM, callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Needs more investigation")
  public void testBadFileDescriptorProvider() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mTestFramework.mCronetEngine.newUrlRequestBuilder(
        NativeTestServer.getRedirectToEchoBody(), callback, callback.getExecutor());
    ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe();
    try {
      // see uploadDataProvidersL38: fd.getStatSize() does not return same response as in cronet
      UploadDataProvider dataProvider = UploadDataProviders.create(pipe[0]);
      builder.setUploadDataProvider(dataProvider, callback.getExecutor());
      builder.addHeader("Content-Type", "useless/string");
      builder.build().start();
      callback.blockForDone();

      assertTrue(callback.mError.getCause() instanceof IllegalArgumentException);
    } finally {
      pipe[1].close();
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBufferProvider() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mTestFramework.mCronetEngine.newUrlRequestBuilder(
        NativeTestServer.getRedirectToEchoBody(), callback, callback.getExecutor());
    UploadDataProvider dataProvider = UploadDataProviders.create(LOREM.getBytes("UTF-8"));
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    builder.addHeader("Content-Type", "useless/string");
    builder.build().start();
    callback.blockForDone();

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(LOREM, callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Tests that ByteBuffer's limit cannot be changed by the caller.
  @Ignore("Blocked by envoy-mobile flow control impl. ByteBuffer impl for cronvoy is different")
  public void testUploadChangeBufferLimit() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mTestFramework.mCronetEngine.newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());
    builder.addHeader("Content-Type", "useless/string");
    builder.setUploadDataProvider(new UploadDataProvider() {
      private static final String CONTENT = "hello";
      @Override
      public long getLength() throws IOException {
        return CONTENT.length();
      }

      @Override
      public void read(UploadDataSink uploadDataSink, ByteBuffer byteBuffer) throws IOException {
        int oldPos = byteBuffer.position();
        int oldLimit = byteBuffer.limit();
        byteBuffer.put(CONTENT.getBytes());
        assertEquals(oldPos + CONTENT.length(), byteBuffer.position());
        assertEquals(oldLimit, byteBuffer.limit());
        // Now change the limit to something else. This should give an error.
        byteBuffer.limit(oldLimit - 1);
        uploadDataSink.onReadSucceeded(false);
      }

      @Override
      public void rewind(UploadDataSink uploadDataSink) throws IOException {}
    }, callback.getExecutor());
    UrlRequest urlRequest = builder.build();
    urlRequest.start();
    callback.blockForDone();
    assertTrue(callback.mOnErrorCalled);
    assertContains("Exception received from UploadDataProvider", callback.mError.getMessage());
    assertContains("ByteBuffer limit changed", callback.mError.getCause().getMessage());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testNoErrorWhenCanceledDuringStart() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mTestFramework.mCronetEngine.newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());
    final ConditionVariable first = new ConditionVariable();
    final ConditionVariable second = new ConditionVariable();
    builder.addHeader("Content-Type", "useless/string");
    builder.setUploadDataProvider(new UploadDataProvider() {
      @Override
      public long getLength() throws IOException {
        first.open();
        second.block();
        return 0;
      }

      @Override
      public void read(UploadDataSink uploadDataSink, ByteBuffer byteBuffer) throws IOException {}

      @Override
      public void rewind(UploadDataSink uploadDataSink) throws IOException {}
    }, callback.getExecutor());
    UrlRequest urlRequest = builder.build();
    urlRequest.start();
    first.block();
    urlRequest.cancel();
    second.open();
    callback.blockForDone();
    assertTrue(callback.mOnCanceledCalled);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testNoErrorWhenExceptionDuringStart() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder builder = mTestFramework.mCronetEngine.newUrlRequestBuilder(
        NativeTestServer.getEchoBodyURL(), callback, callback.getExecutor());
    final ConditionVariable first = new ConditionVariable();
    final String exceptionMessage = "Bad Length";
    builder.addHeader("Content-Type", "useless/string");
    builder.setUploadDataProvider(new UploadDataProvider() {
      @Override
      public long getLength() throws IOException {
        first.open();
        throw new IOException(exceptionMessage);
      }

      @Override
      public void read(UploadDataSink uploadDataSink, ByteBuffer byteBuffer) throws IOException {}
      @Override
      public void rewind(UploadDataSink uploadDataSink) throws IOException {}
    }, callback.getExecutor());
    UrlRequest urlRequest = builder.build();
    urlRequest.start();
    first.block();
    callback.blockForDone();
    assertFalse(callback.mOnCanceledCalled);
    assertTrue(callback.mError instanceof CallbackException);
    assertContains("Exception received from UploadDataProvider", callback.mError.getMessage());
    assertContains(exceptionMessage, callback.mError.getCause().getMessage());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Tests that creating a ByteBufferUploadProvider using a byte array with an
  // offset gives a ByteBuffer with position 0. crbug.com/603124.
  public void testCreateByteBufferUploadWithArrayOffset() throws Exception {
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    // This URL will trigger a rewind().
    UrlRequest.Builder builder = mTestFramework.mCronetEngine.newUrlRequestBuilder(
        NativeTestServer.getRedirectToEchoBody(), callback, callback.getExecutor());
    builder.addHeader("Content-Type", "useless/string");
    byte[] uploadData = LOREM.getBytes("UTF-8");
    int offset = 5;
    byte[] uploadDataWithPadding = new byte[uploadData.length + offset];
    System.arraycopy(uploadData, 0, uploadDataWithPadding, offset, uploadData.length);
    UploadDataProvider dataProvider =
        UploadDataProviders.create(uploadDataWithPadding, offset, uploadData.length);
    assertEquals(uploadData.length, dataProvider.getLength());
    builder.setUploadDataProvider(dataProvider, callback.getExecutor());
    UrlRequest urlRequest = builder.build();
    urlRequest.start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(LOREM, callback.mResponseAsString);
  }
}
package org.chromium.net.impl;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import androidx.test.ext.junit.runners.AndroidJUnit4;

import org.chromium.net.impl.CronvoyBidirectionalState.NextAction;
import org.chromium.net.impl.CronvoyBidirectionalState.Event;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * These tests have little intrinsic value in regards with code maintenance and fighting regression
 * bugs. BidirectionalStreamTest is what matters most. Still, these constitute a form of
 * documentation, hopefully useful enough.
 *
 * <p>The Event sequence in each of these tests is deemed a plausible one. In some cases, a given
 * Event might not be strictly necessary to make the tests pass, but would be realistic.
 */
@RunWith(AndroidJUnit4.class)
public class CronetBidirectionalStateTest {

  private final CronvoyBidirectionalState mCronetBidirectionalState =
      new CronvoyBidirectionalState();

  // ================= USER_START.* =================

  @Test
  public void userStart() {
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_START))
        .isEqualTo(NextAction.NOTIFY_USER_STREAM_READY);
  }

  @Test
  public void userStartWithHeaders() {
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS))
        .isEqualTo(NextAction.NOTIFY_USER_STREAM_READY);
  }

  @Test
  public void userStartReadOnly() {
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_START_READ_ONLY))
        .isEqualTo(NextAction.NOTIFY_USER_STREAM_READY);
  }

  @Test
  public void userStartWithHeadersReadOnly() {
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY))
        .isEqualTo(NextAction.NOTIFY_USER_STREAM_READY);
  }

  @Test
  public void userStart_twice() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    assertThatThrownBy(() -> mCronetBidirectionalState.nextAction(Event.USER_START))
        .isExactlyInstanceOf(IllegalStateException.class)
        .hasMessageContaining("already started");
  }

  // ================= STREAM_READY_CALLBACK_DONE =================

  @Test
  public void streamReadyCallbackDone() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    assertThat(mCronetBidirectionalState.nextAction(Event.STREAM_READY_CALLBACK_DONE))
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void streamReadyCallbackDone_afterOnHeaders() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS);
    assertThat(mCronetBidirectionalState.nextAction(Event.STREAM_READY_CALLBACK_DONE))
        .isEqualTo(NextAction.NOTIFY_USER_HEADERS_RECEIVED);
  }

  @Test
  public void streamReadyCallbackDone_afterOnHeaderEndStream() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    assertThat(mCronetBidirectionalState.nextAction(Event.STREAM_READY_CALLBACK_DONE))
        .isEqualTo(NextAction.NOTIFY_USER_HEADERS_RECEIVED);
  }

  // ================= USER_WRITE =================

  @Test
  public void userWrite() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_WRITE)).isEqualTo(NextAction.WRITE);
  }

  @Test
  public void userWrite_beforeStart() {
    // Cronet accepts that too...
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_WRITE)).isEqualTo(NextAction.WRITE);
  }

  @Test
  public void userWrite_afterStartReadOnly() {
    mCronetBidirectionalState.nextAction(Event.USER_START_READ_ONLY);
    assertThatThrownBy(() -> mCronetBidirectionalState.nextAction(Event.USER_WRITE))
        .isExactlyInstanceOf(IllegalArgumentException.class)
        .hasMessageContaining("Write after writing end of stream");
  }

  @Test
  public void userWrite_afterStartWithHeadersReadOnly() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    assertThatThrownBy(() -> mCronetBidirectionalState.nextAction(Event.USER_WRITE))
        .isExactlyInstanceOf(IllegalArgumentException.class)
        .hasMessageContaining("Write after writing end of stream");
  }

  @Test
  public void userWrite_afterLastWrite() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE);
    assertThatThrownBy(() -> mCronetBidirectionalState.nextAction(Event.USER_WRITE))
        .isExactlyInstanceOf(IllegalArgumentException.class)
        .hasMessageContaining("Write after writing end of stream");
  }

  @Test
  public void userWrite_afterStreamDone() {
    mCronetBidirectionalState.nextAction(Event.ERROR);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_WRITE))
        .isEqualTo(NextAction.TAKE_NO_MORE_ACTIONS);
  }

  @Test
  public void userWrite_completeCycle() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH);
    mCronetBidirectionalState.nextAction(Event.ON_SEND_WINDOW_AVAILABLE);
    mCronetBidirectionalState.nextAction(Event.WRITE_COMPLETED);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_WRITE)).isEqualTo(NextAction.WRITE);
  }

  // ================= USER_LAST_WRITE =================

  @Test
  public void userLastWrite() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE))
        .isEqualTo(NextAction.WRITE);
  }

  @Test
  public void userLastWrite_beforeStart() {
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE))
        .isEqualTo(NextAction.WRITE);
  }

  @Test
  public void userLastWrite_afterStartReadOnly() {
    mCronetBidirectionalState.nextAction(Event.USER_START_READ_ONLY);
    assertThatThrownBy(() -> mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE))
        .isExactlyInstanceOf(IllegalArgumentException.class)
        .hasMessageContaining("Write after writing end of stream");
  }

  @Test
  public void userLastWrite_afterStartWithHeadersReadOnly() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    assertThatThrownBy(() -> mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE))
        .isExactlyInstanceOf(IllegalArgumentException.class)
        .hasMessageContaining("Write after writing end of stream");
  }

  @Test
  public void userLastWrite_afterStreamDone() {
    mCronetBidirectionalState.nextAction(Event.ERROR);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE))
        .isEqualTo(NextAction.TAKE_NO_MORE_ACTIONS);
  }

  @Test
  public void userLastWrite_afterLastWrite() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE);
    assertThatThrownBy(() -> mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE))
        .isExactlyInstanceOf(IllegalArgumentException.class)
        .hasMessageContaining("Write after writing end of stream");
  }

  @Test
  public void userLastWrite_completeCycle() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH);
    mCronetBidirectionalState.nextAction(Event.ON_SEND_WINDOW_AVAILABLE);
    mCronetBidirectionalState.nextAction(Event.WRITE_COMPLETED);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE))
        .isEqualTo(NextAction.WRITE);
  }

  // ================= USER_FLUSH_DATA =================

  @Test
  public void userFlushData_afterStart() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_FLUSH))
        .isEqualTo(NextAction.FLUSH_HEADERS);
  }

  @Test
  public void userFlushData_afterStartReadOnly() {
    mCronetBidirectionalState.nextAction(Event.USER_START_READ_ONLY);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_FLUSH))
        .isEqualTo(NextAction.FLUSH_HEADERS);
  }

  @Test
  public void userFlushData_afterUserStartWithHeaders() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_FLUSH))
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void userFlushData_afterStartWithHeadersReadOnly() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_FLUSH))
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void userFlushData_beforeStart() {
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_FLUSH))
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void userFlushData_afterAnotherUserFlushData() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_FLUSH))
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void userFlushData_afterDone() {
    mCronetBidirectionalState.nextAction(Event.ERROR);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_FLUSH))
        .isEqualTo(NextAction.TAKE_NO_MORE_ACTIONS);
  }

  // ================= USER_READ =================

  @Test
  public void userRead_beforeOnHeaders() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    // Response headers not received yet - the read is postponed until then.
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_READ))
        .isEqualTo(NextAction.POSTPONE_READ);
  }

  @Test
  public void userRead_beforeOnHeaders_afterAnotherRead() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    assertThatThrownBy(() -> mCronetBidirectionalState.nextAction(Event.USER_READ))
        .isExactlyInstanceOf(IllegalStateException.class)
        .hasMessageContaining("Unexpected read");
  }

  @Test
  public void userRead_afterOnHeaders() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_READ)).isEqualTo(NextAction.READ);
  }

  @Test
  public void userRead_afterOnHeaders_afterAnotherRead() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    assertThatThrownBy(() -> mCronetBidirectionalState.nextAction(Event.USER_READ))
        .isExactlyInstanceOf(IllegalStateException.class)
        .hasMessageContaining("Unexpected read");
  }

  @Test
  public void userRead_afterOnComplete() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.ON_COMPLETE);
    // The read occurred after the stream completed - must be attended immediately by simulating
    // the reception of zero bytes. Obviously, EM won't do the callback here.
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_READ))
        .isEqualTo(NextAction.INVOKE_ON_READ_COMPLETED);
  }

  @Test
  public void userRead_afterOnComplete_afterAnotherRead() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.ON_COMPLETE);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    assertThatThrownBy(() -> mCronetBidirectionalState.nextAction(Event.USER_READ))
        .isExactlyInstanceOf(IllegalStateException.class)
        .hasMessageContaining("Unexpected read");
  }

  @Test
  public void userRead_beforeUserStart() {
    assertThatThrownBy(() -> mCronetBidirectionalState.nextAction(Event.USER_READ))
        .isExactlyInstanceOf(IllegalStateException.class)
        .hasMessageContaining("Unexpected read");
  }

  @Test
  public void userRead_completeCycle() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.ON_DATA);
    mCronetBidirectionalState.nextAction(Event.READ_COMPLETED);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_READ)).isEqualTo(NextAction.READ);
  }

  @Test
  public void userRead_afterCompletedCycle() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.ON_DATA_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.LAST_READ_COMPLETED);
    assertThatThrownBy(() -> mCronetBidirectionalState.nextAction(Event.USER_READ))
        .isExactlyInstanceOf(IllegalStateException.class)
        .hasMessageContaining("Unexpected read");
  }

  // ================= USER_CANCEL =================

  @Test
  public void userCancel_beforeUserStart() {
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_CANCEL))
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void cancel_beforeUserStart_afterUserLastWrite() {
    mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_CANCEL))
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void userCancel_afterUserStart() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_CANCEL))
        .isEqualTo(NextAction.CANCEL);
  }

  @Test
  public void userCancel_afterOnComplete() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.ON_COMPLETE);
    // The cancel occurred after the stream completed - Obviously, EM won't do the callback here.
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_CANCEL))
        .isEqualTo(NextAction.NOTIFY_USER_CANCELED);
  }

  @Test
  public void userCancel_afterSuccessfulReadyToFinish() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.ON_COMPLETE);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.LAST_READ_COMPLETED);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FINISH);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_CANCEL))
        .isEqualTo(NextAction.TAKE_NO_MORE_ACTIONS);
  }

  @Test
  public void userCancel_afterOnError() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.ON_ERROR);
    assertThat(mCronetBidirectionalState.nextAction(Event.USER_CANCEL))
        .isEqualTo(NextAction.TAKE_NO_MORE_ACTIONS);
  }

  // ================= ERROR =================

  @Test
  public void error_beforeUserStart() {
    // The error occurred before the stream creation - Obviously, EM won't do the callback here.
    assertThat(mCronetBidirectionalState.nextAction(Event.ERROR))
        .isEqualTo(NextAction.NOTIFY_USER_FAILED);
  }

  @Test
  public void error_beforeUserStart_afterUserLastWrite() {
    mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE);
    // The error occurred before the stream creation - Obviously, EM won't do the callback here.
    assertThat(mCronetBidirectionalState.nextAction(Event.ERROR))
        .isEqualTo(NextAction.NOTIFY_USER_FAILED);
  }

  @Test
  public void error_afterUserStart() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    // EM must be stopped first, hence the "cancel". By contract
    assertThat(mCronetBidirectionalState.nextAction(Event.ERROR)).isEqualTo(NextAction.CANCEL);
  }

  @Test
  public void error_afterOnComplete() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.ON_COMPLETE);
    // The error occurred after the stream completed - Obviously, EM won't do the callback here.
    assertThat(mCronetBidirectionalState.nextAction(Event.ERROR))
        .isEqualTo(NextAction.NOTIFY_USER_FAILED);
  }

  @Test
  public void error_afterSuccessfulReadyToFinish() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.ON_COMPLETE);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.LAST_READ_COMPLETED);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FINISH);
    assertThat(mCronetBidirectionalState.nextAction(Event.ERROR))
        .isEqualTo(NextAction.TAKE_NO_MORE_ACTIONS);
  }

  @Test
  public void error_afterAnotherError() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.ERROR);
    assertThat(mCronetBidirectionalState.nextAction(Event.ERROR))
        .isEqualTo(NextAction.TAKE_NO_MORE_ACTIONS);
  }

  @Test
  public void error_afterOnError() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.ON_ERROR);
    assertThat(mCronetBidirectionalState.nextAction(Event.ERROR))
        .isEqualTo(NextAction.TAKE_NO_MORE_ACTIONS);
  }

  // ================= READY_TO_FLUSH[_LAST] =================
  //
  // This event won't be triggered before the first USER_FLUSH. Also, it will never be triggered if
  // it is a "read only" HTTP Method (where the request body is forbidden, like GET).
  //

  @Test
  public void readyToFlush_afterUserFlush() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    assertThat(mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH))
        .isEqualTo(NextAction.SEND_DATA);
  }

  @Test
  public void readyToFlush_afterAnotherReadyToFlush() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH);            // First WRITE consumed.
    assertThat(mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH)) // Too soon - pass.
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void readyToFlush_completeCycle() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH); // Consumes first WRITE.
    mCronetBidirectionalState.nextAction(Event.ON_SEND_WINDOW_AVAILABLE);
    assertThat(mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH)) // Consumes second WRITE.
        .isEqualTo(NextAction.SEND_DATA);
  }

  @Test
  public void readyToFlushLast_afterUserFlush() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    assertThat(mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH_LAST))
        .isEqualTo(NextAction.SEND_DATA);
  }

  @Test
  public void readyToFlushLast_afterReadyToFlush() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH_LAST); // First WRITE consumed.
    assertThat(mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH_LAST)) // Too soon - pass.
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void readyToFlushLast_completeCycle() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH); // Consumes first WRITE.
    mCronetBidirectionalState.nextAction(Event.ON_SEND_WINDOW_AVAILABLE);
    assertThat(mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH_LAST)) // Last WRITE.
        .isEqualTo(NextAction.SEND_DATA);
  }

  // ================= READY_TO_START_POSTPONED_READ_IF_ANY =================
  //
  // This event won't be triggered before the ON_HEADERS[_END_STREAM] event.
  //

  @Test
  public void readyToStartPostponedReadIfAny_afterOnHeaders() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.USER_READ); // This postpones the "readData".
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS);
    assertThat(mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY))
        .isEqualTo(NextAction.READ);
  }

  @Test
  public void readyToStartPostponedReadIfAny_afterOnHeadersEndStream() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.USER_READ); // This postpones the "readData".
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    assertThat(mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY))
        .isEqualTo(NextAction.INVOKE_ON_READ_COMPLETED);
  }

  @Test
  public void readyToStartPostponedReadIfAny_afterHeaders_noPostponeRead() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    assertThat(mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY))
        .isEqualTo(NextAction.CARRY_ON);
  }

  // ================= [LAST_]WRITE_COMPLETED =================
  //
  // These events won't be triggered before the first [LAST_]FLUSH_DATA_COMPLETED.
  //

  @Test
  public void writeCompleted() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH);
    mCronetBidirectionalState.nextAction(Event.ON_SEND_WINDOW_AVAILABLE);
    assertThat(mCronetBidirectionalState.nextAction(Event.WRITE_COMPLETED))
        .isEqualTo(NextAction.NOTIFY_USER_WRITE_COMPLETED);
  }

  @Test
  public void lastWriteCompleted() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH_LAST);
    assertThat(mCronetBidirectionalState.nextAction(Event.LAST_WRITE_COMPLETED))
        .isEqualTo(NextAction.NOTIFY_USER_WRITE_COMPLETED);
  }

  // ================= [LAST_]READ_COMPLETED =================
  //
  // This event won't be triggered before the first occurrence of any of these events:
  // ON_HEADERS_END_STREAM, ON_DATA_END_STREAM, ON_DATA.
  //

  @Test
  public void readCompleted() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.ON_DATA);
    assertThat(mCronetBidirectionalState.nextAction(Event.READ_COMPLETED))
        .isEqualTo(NextAction.NOTIFY_USER_READ_COMPLETED);
  }

  @Test
  public void lastReadCompleted_afterOnHeadersEndStream() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    assertThat(mCronetBidirectionalState.nextAction(Event.LAST_READ_COMPLETED))
        .isEqualTo(NextAction.NOTIFY_USER_READ_COMPLETED);
  }

  @Test
  public void lastReadCompleted_afterOnDataEndStream() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.ON_DATA_END_STREAM);
    assertThat(mCronetBidirectionalState.nextAction(Event.LAST_READ_COMPLETED))
        .isEqualTo(NextAction.NOTIFY_USER_READ_COMPLETED);
  }

  // ================= READY_TO_FINISH =================
  //
  // This event won't be triggered before the first occurrence of any of these events: ON_COMPLETE,
  // LAST_READ_COMPLETED and LAST_WRITE_COMPLETED.
  //

  @Test
  public void readyToFinish_afterLastReadCompleted() {
    mCronetBidirectionalState.nextAction(Event.USER_START_READ_ONLY); // WRITE_DONE = true
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.ON_COMPLETE); // ON_COMPLETE_RECEIVED = true
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.LAST_READ_COMPLETED); // READ_DONE = true
    assertThat(mCronetBidirectionalState.nextAction(Event.READY_TO_FINISH))
        .isEqualTo(NextAction.NOTIFY_USER_SUCCEEDED);
  }

  @Test
  public void readyToFinish_beforeOnComplete_afterLastReadCompleted() {
    mCronetBidirectionalState.nextAction(Event.USER_START_READ_ONLY); // WRITE_DONE = true
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.LAST_READ_COMPLETED);        // READ_DONE = true
    assertThat(mCronetBidirectionalState.nextAction(Event.READY_TO_FINISH)) // Not ready yet - no-op
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void readyToFinish_afterLastWriteCompleted() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH);
    mCronetBidirectionalState.nextAction(Event.ON_SEND_WINDOW_AVAILABLE);
    mCronetBidirectionalState.nextAction(Event.WRITE_COMPLETED);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.LAST_READ_COMPLETED); // READ_DONE = true
    mCronetBidirectionalState.nextAction(Event.READY_TO_FINISH);     // Not ready yet - no-op
    mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH_LAST);
    mCronetBidirectionalState.nextAction(Event.ON_COMPLETE);          // ON_COMPLETE_RECEIVED = true
    mCronetBidirectionalState.nextAction(Event.LAST_WRITE_COMPLETED); // WRITE_DONE = true
    assertThat(mCronetBidirectionalState.nextAction(Event.READY_TO_FINISH))
        .isEqualTo(NextAction.NOTIFY_USER_SUCCEEDED);
  }

  @Test
  public void readyToFinish_beforeOnComplete_afterLastWriteCompleted() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH);
    mCronetBidirectionalState.nextAction(Event.ON_SEND_WINDOW_AVAILABLE);
    mCronetBidirectionalState.nextAction(Event.WRITE_COMPLETED);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.LAST_READ_COMPLETED); // READ_DONE = true
    mCronetBidirectionalState.nextAction(Event.READY_TO_FINISH);     // Not ready yet - no-op
    mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH_LAST);
    mCronetBidirectionalState.nextAction(Event.LAST_WRITE_COMPLETED);       // WRITE_DONE = true
    assertThat(mCronetBidirectionalState.nextAction(Event.READY_TO_FINISH)) // Not ready yet - no-op
        .isEqualTo(NextAction.CARRY_ON);
  }

  // ================= ON_SEND_WINDOW_AVAILABLE =================
  //
  // This events won't be triggered before the first READY_TO_FLUSH.
  //
  // Note: ON_SEND_WINDOW_AVAILABLE can not happen after READY_TO_FLUSH_LAST
  //

  @Test
  public void onSendWindowAvailable() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);     // Flushed Request Headers.
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH); // Flushes one non-last ByteBuffer.
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_SEND_WINDOW_AVAILABLE))
        .isEqualTo(NextAction.CHAIN_NEXT_WRITE);
  }

  // ================= ON_HEADERS[_END_STREAM] =================

  @Test
  public void onHeaders() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_HEADERS))
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void onHeadersEndStream() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM))
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void onHeader_afterStreamReadyCallbackDone() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.STREAM_READY_CALLBACK_DONE);
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_HEADERS))
        .isEqualTo(NextAction.NOTIFY_USER_HEADERS_RECEIVED);
  }

  @Test
  public void onHeaderEndSteam_afterStreamReadyCallbackDone() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.STREAM_READY_CALLBACK_DONE);
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM))
        .isEqualTo(NextAction.NOTIFY_USER_HEADERS_RECEIVED);
  }

  // ================= ON_DATA[_END_STREAM] =================

  @Test
  public void onData() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_DATA))
        .isEqualTo(NextAction.INVOKE_ON_READ_COMPLETED);
  }

  @Test
  public void onDataEndStream() {
    mCronetBidirectionalState.nextAction(Event.USER_START_WITH_HEADERS_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_DATA_END_STREAM))
        .isEqualTo(NextAction.INVOKE_ON_READ_COMPLETED);
  }

  // ================= ON_COMPLETE =================

  @Test
  public void onComplete_beforeLastWriteCompleted() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH);
    mCronetBidirectionalState.nextAction(Event.ON_SEND_WINDOW_AVAILABLE);
    mCronetBidirectionalState.nextAction(Event.WRITE_COMPLETED);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.LAST_READ_COMPLETED); // READ_DONE = true
    mCronetBidirectionalState.nextAction(Event.READY_TO_FINISH);     // Not ready yet - no-op
    mCronetBidirectionalState.nextAction(Event.USER_LAST_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH_LAST);
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_COMPLETE)) // WRITE_DONE = false
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void onComplete_beforeLastReadCompleted() {
    mCronetBidirectionalState.nextAction(Event.USER_START_READ_ONLY); // WRITE_DONE = true
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_COMPLETE)) // READ_DONE = false
        .isEqualTo(NextAction.CARRY_ON);
  }

  @Test
  public void onComplete_afterLastWriteCompleted_afterLastReadCompleted() {
    mCronetBidirectionalState.nextAction(Event.USER_START);
    mCronetBidirectionalState.nextAction(Event.USER_WRITE);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.READY_TO_FLUSH);
    mCronetBidirectionalState.nextAction(Event.ON_SEND_WINDOW_AVAILABLE);
    mCronetBidirectionalState.nextAction(Event.LAST_WRITE_COMPLETED); // WRITE_DONE = true
    mCronetBidirectionalState.nextAction(Event.READY_TO_FINISH);      // Not ready yet - no-op
    mCronetBidirectionalState.nextAction(Event.USER_READ);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.READY_TO_START_POSTPONED_READ_IF_ANY);
    mCronetBidirectionalState.nextAction(Event.LAST_READ_COMPLETED); // READ_DONE = true
    mCronetBidirectionalState.nextAction(Event.READY_TO_FINISH);     // Not ready yet - no-op
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_COMPLETE))
        .isEqualTo(NextAction.NOTIFY_USER_SUCCEEDED);
  }

  @Test
  public void onComplete_justAfterCancel() {
    mCronetBidirectionalState.nextAction(Event.USER_START_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.USER_CANCEL);
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_COMPLETE))
        .isEqualTo(NextAction.NOTIFY_USER_CANCELED);
  }

  @Test
  public void onComplete_justAfterError() {
    mCronetBidirectionalState.nextAction(Event.USER_START_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.USER_FLUSH);
    mCronetBidirectionalState.nextAction(Event.ON_HEADERS_END_STREAM);
    mCronetBidirectionalState.nextAction(Event.ERROR);
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_COMPLETE))
        .isEqualTo(NextAction.NOTIFY_USER_FAILED);
  }

  // ================= ON_ERROR =================

  @Test
  public void onError() {
    mCronetBidirectionalState.nextAction(Event.USER_START_READ_ONLY);
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_ERROR))
        .isEqualTo(NextAction.NOTIFY_USER_NETWORK_ERROR);
  }

  @Test
  public void onError_afterError() {
    mCronetBidirectionalState.nextAction(Event.USER_START_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.ERROR);
    // There was already a recorded error - that one has precedence.
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_ERROR))
        .isEqualTo(NextAction.NOTIFY_USER_FAILED);
  }

  // ================= ON_CANCEL =================

  @Test
  public void onCancel_afterUserCancel() {
    mCronetBidirectionalState.nextAction(Event.USER_START_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.USER_CANCEL);
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_CANCEL))
        .isEqualTo(NextAction.NOTIFY_USER_CANCELED);
  }

  @Test
  public void onCancel_afterError() {
    mCronetBidirectionalState.nextAction(Event.USER_START_READ_ONLY);
    mCronetBidirectionalState.nextAction(Event.ERROR);
    assertThat(mCronetBidirectionalState.nextAction(Event.ON_CANCEL))
        .isEqualTo(NextAction.NOTIFY_USER_FAILED);
  }
}
package org.chromium.net.impl;

import java.nio.ByteBuffer;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicReference;
import org.chromium.net.CronetException;
import org.chromium.net.UrlRequest;
import org.chromium.net.UrlResponseInfo;

/**
 * Tester for running the full Cronet flow. The base of the logic is similar to a
 * com.google.common.util.concurrent.SettableFuture. The {@link #waitForResponse} method blocks
 * until the flow completes. It throws back any exception caught in a Callback invocation.
 *
 * @param <R> Response type.
 */
final class UrlRequestCallbackTester<R> {

  private final AtomicReference<Throwable> throwable = new AtomicReference<>();
  private final AtomicReference<R> response = new AtomicReference<>();
  private final CountDownLatch countDownLatch = new CountDownLatch(1);

  /**
   * Wraps the provided Callback in such a way that all its methods are run inside a try/catch.
   */
  UrlRequest.Callback getWrappedUrlRequestCallback(UrlRequest.Callback wrappedCallback) {
    return new TestUrlRequestCallback(wrappedCallback);
  }

  /**
   * Ends the flow. Called within the execution of a UrlRequest.Callback method.
   */
  void setResponse(R response) {
    this.response.compareAndSet(null, response);
    countDownLatch.countDown();
  }

  /**
   * Waits for the flow to end, may throw Exception caught while executing a UrlRequest.Callback
   * method.
   */
  R waitForResponse(UrlRequest urlRequest) {
    urlRequest.start();
    try {
      countDownLatch.await();
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
    if (throwable.get() != null) {
      if (throwable.get() instanceof Error) {
        throw(Error) throwable.get();
      }
      if (throwable.get() instanceof RuntimeException) {
        throw(RuntimeException) throwable.get();
      }
      throw new RuntimeException(throwable.get());
    }
    return response.get();
  }

  private void setThrowable(Throwable throwable) {
    this.throwable.compareAndSet(null, throwable);
    countDownLatch.countDown();
  }

  private class TestUrlRequestCallback extends UrlRequest.Callback {

    private final UrlRequest.Callback wrappedCallback;

    private TestUrlRequestCallback(UrlRequest.Callback wrappedCallback) {
      this.wrappedCallback = wrappedCallback;
    }

    @Override
    public void onRedirectReceived(UrlRequest request, UrlResponseInfo info,
                                   String newLocationUrl) {
      try {
        wrappedCallback.onRedirectReceived(request, info, newLocationUrl);
      } catch (Throwable t) {
        setThrowable(t);
      }
    }

    @Override
    public void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
      try {
        wrappedCallback.onResponseStarted(request, info);
      } catch (Throwable t) {
        setThrowable(t);
      }
    }

    @Override
    public void onReadCompleted(UrlRequest request, UrlResponseInfo info, ByteBuffer byteBuffer) {
      try {
        wrappedCallback.onReadCompleted(request, info, byteBuffer);
      } catch (Throwable t) {
        setThrowable(t);
      }
    }

    @Override
    public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
      try {
        wrappedCallback.onSucceeded(request, info);
      } catch (Throwable t) {
        setThrowable(t);
      }
    }

    @Override
    public void onFailed(UrlRequest request, UrlResponseInfo info, CronetException error) {
      try {
        wrappedCallback.onFailed(request, info, error);
      } catch (Throwable t) {
        setThrowable(t);
      }
    }

    @Override
    public void onCanceled(UrlRequest request, UrlResponseInfo info) {
      try {
        wrappedCallback.onCanceled(request, info);
      } catch (Throwable t) {
        setThrowable(t);
      }
    }
  }
}
package org.chromium.net.impl;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assert.assertEquals;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import org.junit.rules.ExpectedException;
import org.chromium.net.testing.Feature;
import org.junit.runner.RunWith;
import org.junit.Rule;
import org.junit.Test;
import org.chromium.net.impl.CronvoyLogger;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

/**
 * Tests that ConvoyLogger works as expected.
 */
@RunWith(AndroidJUnit4.class)
public class CronvoyLoggerTest {

  @Rule public final ExpectedException thrown = ExpectedException.none();

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void logWithLoggerUnconfigured() throws Exception {
    CronvoyLogger logger = new CronvoyLogger();
    // Should be a no-op.
    logger.log("hello");
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBasicLogToFile() throws Exception {
    File file = File.createTempFile("some-prefix", "file-ext");
    file.deleteOnExit();
    String filename = file.getAbsolutePath() + "foo"; // Pick a path that doesn't exist.
    CronvoyLogger logger = new CronvoyLogger();
    logger.setNetLogToFile(filename);
    logger.log("hello");
    logger.stopLogging();
    char[] buffer = new char[5000];
    byte[] bytes = Files.readAllBytes(Paths.get(filename));
    String fileContent = new String(bytes);
    assertEquals(fileContent, "hello");
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBasicLogToDisk() throws Exception {
    File file = File.createTempFile("some-prefix", "basic-ext");
    file.deleteOnExit();
    String filename = file.getAbsolutePath() + "bar/foo"; // Pick a directory that doesn't exist.
    CronvoyLogger logger = new CronvoyLogger();
    logger.setNetLogToDisk(filename, 5000);
    logger.log("hello");
    logger.stopLogging();
    char[] buffer = new char[5000];
    byte[] bytes = Files.readAllBytes(Paths.get(filename + "/netlog.json"));
    String fileContent = new String(bytes);
    assertEquals(fileContent, "hello");
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testLogToDiskWithLimits() throws Exception {
    File file = File.createTempFile("some-prefix", "limits-ext");
    file.deleteOnExit();
    String filename = file.getAbsolutePath() + "bar";
    CronvoyLogger logger = new CronvoyLogger();
    logger.setNetLogToDisk(filename, 5);
    logger.log("hello!");
    logger.log("goodbye");
    logger.stopLogging();
    char[] buffer = new char[5000];
    byte[] bytes = Files.readAllBytes(Paths.get(filename + "/netlog.json"));
    String fileContent = new String(bytes);
    assertEquals("goodbye", fileContent);
  }
}
package org.chromium.net.impl;

import static java.net.HttpURLConnection.HTTP_BAD_REQUEST;
import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
import static java.net.HttpURLConnection.HTTP_OK;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import android.content.Context;
import androidx.test.core.app.ApplicationProvider;
import io.envoyproxy.envoymobile.RequestMethod;
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary;
import io.envoyproxy.envoymobile.utilities.StatsUtils;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.ByteBuffer;
import java.util.AbstractMap.SimpleImmutableEntry;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import okhttp3.mockwebserver.Dispatcher;
import okhttp3.mockwebserver.MockResponse;
import okhttp3.mockwebserver.MockWebServer;
import okhttp3.mockwebserver.RecordedRequest;
import org.chromium.net.CronetException;
import org.chromium.net.ExperimentalUrlRequest;
import org.chromium.net.UploadDataProviders;
import org.chromium.net.UrlRequest;
import org.chromium.net.UrlResponseInfo;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;

@RunWith(RobolectricTestRunner.class)
public class CronvoyEngineTest {

  private static final String TEST_URL_PATH = "get/flowers";

  private static org.chromium.net.impl.CronvoyUrlRequestContext cronvoyEngine;

  private final MockWebServer mockWebServer = new MockWebServer();

  @BeforeClass
  public static void loadJniLibrary() {
    AndroidJniLibrary.loadTestLibrary();
  }

  @AfterClass
  public static void shutdown() {
    if (cronvoyEngine != null) {
      cronvoyEngine.shutdown();
    }
  }

  @Before
  public void setUp() {
    if (cronvoyEngine == null) {
      NativeCronvoyEngineBuilderImpl nativeCronetEngineBuilder =
          new NativeCronvoyEngineBuilderImpl(ApplicationProvider.getApplicationContext());
      nativeCronetEngineBuilder.setUserAgent("Cronvoy");
      cronvoyEngine = new CronvoyUrlRequestContext(nativeCronetEngineBuilder);
    }
  }

  @After
  public void shutdownMockWebServer() throws IOException {
    mockWebServer.shutdown();
  }

  @Test
  public void get_simple() throws Exception {
    mockWebServer.enqueue(new MockResponse().setBody("hello, world"));
    mockWebServer.start();
    // HttpMethod is not set on purpose - should default to "GET" because there is no request body.
    RequestScenario requestScenario = new RequestScenario().addResponseBuffers(13);

    Response response = sendRequest(requestScenario);

    assertThat(response.getResponseCode()).isEqualTo(HTTP_OK);
    assertThat(response.getBodyAsString()).isEqualTo("hello, world");
    assertThat(response.getCronetException()).withFailMessage(response.getErrorMessage()).isNull();

    // Do some basic stats accounting.
    String stats = cronvoyEngine.getEnvoyEngine().dumpStats();
    Map<String, String> statsMap = StatsUtils.statsToList(stats);
    assertThat(statsMap.containsKey("http.hcm.downstream_rq_2xx"));
    assertThat(statsMap.containsKey("http.hcm.downstream_total"));
    assertThat(statsMap.containsKey("runtime.load_success"));
    assertThat(statsMap.get("runtime.load_success")).isEqualTo("1");
  }

  @Test
  public void get_noBody() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(HTTP_OK));
    mockWebServer.start();
    RequestScenario requestScenario =
        new RequestScenario().addResponseBuffers(1); // At least one byte must be available.

    Response response = sendRequest(requestScenario);

    assertThat(response.getResponseCode()).isEqualTo(HTTP_OK);
    assertThat(response.getBodyAsString()).isEmpty();
    assertThat(response.getCronetException()).withFailMessage(response.getErrorMessage()).isNull();
  }

  @Test
  public void get_withSmallBuffers() throws Exception {
    mockWebServer.enqueue(new MockResponse().setBody("hello, world"));
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario().addResponseBuffers(4, 3, 5, 1);

    Response response = sendRequest(requestScenario);

    assertThat(response.getBodyAsString()).isEqualTo("hello, world");
  }

  @Test
  public void get_withNotEnoughBuffer() throws Exception {
    mockWebServer.enqueue(new MockResponse().setBody("hello, world"));
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario().addResponseBuffers(11);

    // Message comes from Preconditions.checkHasRemaining()
    assertThatThrownBy(() -> sendRequest(requestScenario)).hasMessageContaining("already full");
  }

  @Test
  public void get_withThrottledBodyResponse() throws Exception {
    // Note: throttle must be long enough to trickle the chunking.
    mockWebServer.enqueue(
        new MockResponse().throttleBody(5, 1, TimeUnit.SECONDS).setBody("hello, world"));
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario().addResponseBuffers(13);

    UrlRequestCallbackTester<Response> urlRequestCallbackTester = new UrlRequestCallbackTester<>();
    UrlRequestCallback testCallback = new UrlRequestCallback(
        requestScenario.responseBody, urlRequestCallbackTester, requestScenario);
    ExperimentalUrlRequest.Builder builder = cronvoyEngine.newUrlRequestBuilder(
        mockWebServer.url(requestScenario.urlPath).toString(),
        urlRequestCallbackTester.getWrappedUrlRequestCallback(testCallback),
        Executors.newSingleThreadExecutor());

    Response response = urlRequestCallbackTester.waitForResponse(builder.build());

    // The response will come in 3 chunks. The 4th read is the final read and shouldn't trigger
    // OnReadComplete() as no data is read.
    assertThat(testCallback.getNumOnReadCompleteCalled()).isEqualTo(3);
    assertThat(response.getCronetException()).withFailMessage(response.getErrorMessage()).isNull();
    assertThat(response.getBodyAsString()).isEqualTo("hello, world");
    assertThat(response.getNbResponseChunks()).isEqualTo(3); // 5 bytes, 5 bytes, and 2 bytes
  }

  @Test
  public void get_cancelOnResponseStarted() throws Exception {
    mockWebServer.enqueue(new MockResponse().setBody("hello, world"));
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario().cancelOnResponseStarted();

    Response response = sendRequest(requestScenario);

    assertThat(response.isCancelled()).isTrue();
    assertThat(response.getCronetException()).withFailMessage(response.getErrorMessage()).isNull();
    assertThat(response.getBodyAsString()).isEmpty();
  }

  @Test
  public void post_simple() throws Exception {
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        assertThat(recordedRequest.getMethod()).isEqualTo(RequestMethod.POST.name());
        assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("This is the request Body");
        return new MockResponse().setBody("This is the response Body");
      }
    });
    mockWebServer.start();
    // HttpMethod is not set on purpose - should default to "POST" because there is a request body.
    RequestScenario requestScenario = new RequestScenario()
                                          .addResponseBuffers(30)
                                          .addHeader("content-type", "text/html")
                                          .setRequestBody("This is the request Body");

    Response response = sendRequest(requestScenario);

    assertThat(response.getResponseCode()).isEqualTo(HTTP_OK);
    assertThat(response.getBodyAsString()).isEqualTo("This is the response Body");
    assertThat(response.getCronetException()).withFailMessage(response.getErrorMessage()).isNull();
  }

  @Test
  public void post_chunked() throws Exception {
    // This is getting chunked every 8192 bytes.
    byte[] requestBody = new byte[20_000];
    Arrays.fill(requestBody, (byte)'A');
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        assertThat(recordedRequest.getMethod()).isEqualTo(RequestMethod.POST.name());
        assertThat(recordedRequest.getBody().readByteArray()).isEqualTo(requestBody);
        return new MockResponse().setBody("This is the response Body");
      }
    });
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .addResponseBuffers(30)
                                          .setHttpMethod(RequestMethod.POST)
                                          .addHeader("content-type", "text/html")
                                          .setRequestBody(requestBody);

    Response response = sendRequest(requestScenario);

    assertThat(response.getResponseCode()).isEqualTo(HTTP_OK);
    assertThat(response.getBodyAsString()).isEqualTo("This is the response Body");
    assertThat(response.getCronetException()).withFailMessage(response.getErrorMessage()).isNull();
  }

  @Test
  public void get_redirect() throws Exception {
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        switch (recordedRequest.getRequestUrl().encodedPath()) {
        case "/get/flowers":
          return new MockResponse()
              .setResponseCode(HTTP_MOVED_TEMP)
              .setHeader("Location", "/get/chocolates");

        case "/get/chocolates":
          return new MockResponse().setBody("Everything is awesome").setResponseCode(HTTP_OK);
        }
        return new MockResponse().setResponseCode(HTTP_BAD_REQUEST);
      }
    });
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .addResponseBuffers(30)
                                          .setHttpMethod(RequestMethod.GET)
                                          .setUrlPath("/get/flowers")
                                          .addHeader("content-type", "text/html");

    Response response = sendRequest(requestScenario);

    assertThat(response.getResponseCode()).isEqualTo(HTTP_OK);
    assertThat(response.getBodyAsString()).isEqualTo("Everything is awesome");
    assertThat(response.getCronetException()).withFailMessage(response.getErrorMessage()).isNull();
    assertThat(response.getUrlResponseInfo().getUrlChain())
        .contains(mockWebServer.url("/get/flowers").toString(),
                  mockWebServer.url("/get/chocolates").toString());
  }

  @Test
  public void get_redirect_withUnwantedBody() throws Exception {
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        switch (recordedRequest.getRequestUrl().encodedPath()) {
        case "/get/flowers":
          return new MockResponse()
              .setResponseCode(HTTP_MOVED_TEMP)
              .setHeader("Location", "/get/chocolates")
              .addHeader("content-type", "text/html")
              .setBody("Unwanted response body that must be ignored - by API Contract");

        case "/get/chocolates":
          return new MockResponse().setBody("Everything is awesome").setResponseCode(HTTP_OK);
        }
        return new MockResponse().setResponseCode(HTTP_BAD_REQUEST);
      }
    });
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .addResponseBuffers(30)
                                          .setHttpMethod(RequestMethod.GET)
                                          .setUrlPath("/get/flowers")
                                          .addHeader("content-type", "text/html");

    Response response = sendRequest(requestScenario);

    assertThat(response.getResponseCode()).isEqualTo(HTTP_OK);
    assertThat(response.getBodyAsString()).isEqualTo("Everything is awesome");
    assertThat(response.getCronetException()).withFailMessage(response.getErrorMessage()).isNull();
    assertThat(response.getUrlResponseInfo().getUrlChain())
        .contains(mockWebServer.url("/get/flowers").toString(),
                  mockWebServer.url("/get/chocolates").toString());
  }

  @Test
  public void post_redirect() throws Exception {
    // This is getting chunked every 8192 bytes.
    byte[] requestBody = new byte[20_000];
    Arrays.fill(requestBody, (byte)'A');
    mockWebServer.setDispatcher(new Dispatcher() {
      @Override
      public MockResponse dispatch(RecordedRequest recordedRequest) {
        // The request POST body is being sent twice, as it should in a redirect case.
        assertThat(recordedRequest.getBody().readByteArray()).isEqualTo(requestBody);

        switch (recordedRequest.getRequestUrl().encodedPath()) {
        case "/get/flowers":
          return new MockResponse()
              .setResponseCode(HTTP_MOVED_TEMP)
              .setHeader("Location", "/get/chocolates");

        case "/get/chocolates":
          return new MockResponse().setBody("Everything is awesome").setResponseCode(HTTP_OK);
        }
        return new MockResponse().setResponseCode(HTTP_BAD_REQUEST);
      }
    });
    mockWebServer.start();
    RequestScenario requestScenario = new RequestScenario()
                                          .addResponseBuffers(30)
                                          .setHttpMethod(RequestMethod.POST)
                                          .setUrlPath("/get/flowers")
                                          .addHeader("content-type", "text/html")
                                          .setRequestBody(requestBody);

    Response response = sendRequest(requestScenario);

    assertThat(response.getResponseCode()).isEqualTo(HTTP_OK);
    assertThat(response.getBodyAsString()).isEqualTo("Everything is awesome");
    assertThat(response.getCronetException()).withFailMessage(response.getErrorMessage()).isNull();
    assertThat(response.getUrlResponseInfo().getUrlChain())
        .contains(mockWebServer.url("/get/flowers").toString(),
                  mockWebServer.url("/get/chocolates").toString());
  }

  private Response sendRequest(RequestScenario requestScenario) {
    UrlRequestCallbackTester<Response> urlRequestCallbackTester = new UrlRequestCallbackTester<>();
    UrlRequestCallback testCallback = new UrlRequestCallback(
        requestScenario.responseBody, urlRequestCallbackTester, requestScenario);
    ExperimentalUrlRequest.Builder builder = cronvoyEngine.newUrlRequestBuilder(
        mockWebServer.url(requestScenario.urlPath).toString(),
        urlRequestCallbackTester.getWrappedUrlRequestCallback(testCallback),
        Executors.newSingleThreadExecutor());

    if (requestScenario.requestBody != null) {
      builder.setUploadDataProvider(UploadDataProviders.create(requestScenario.requestBody),
                                    Executors.newSingleThreadExecutor());
    }

    for (Map.Entry<String, String> entry : requestScenario.header) {
      builder.addHeader(entry.getKey(), entry.getValue());
    }
    if (requestScenario.httpMethod != null) {
      builder.setHttpMethod(requestScenario.httpMethod);
    }

    return urlRequestCallbackTester.waitForResponse(builder.build());
  }

  private static class UrlRequestCallback extends UrlRequest.Callback {
    private final UrlRequestCallbackTester<Response> urlRequestCallbackTester;
    private final List<ByteBuffer> responseBodyBuffers;
    private final ConcurrentLinkedQueue<ByteBuffer> buffers;
    private final AtomicInteger nbChunks = new AtomicInteger(0);
    private final AtomicInteger bufferLastRemaining = new AtomicInteger();
    private final RequestScenario requestScenario;
    private int numOnReadCompleteCalled = 0;

    private UrlRequestCallback(List<ByteBuffer> responseBodyBuffers,
                               UrlRequestCallbackTester<Response> urlRequestCallbackTester,
                               RequestScenario requestScenario) {
      this.responseBodyBuffers = responseBodyBuffers;
      this.urlRequestCallbackTester = urlRequestCallbackTester;
      this.requestScenario = requestScenario;
      buffers = new ConcurrentLinkedQueue<>(responseBodyBuffers);
    }

    public int getNumOnReadCompleteCalled() { return numOnReadCompleteCalled; }

    @Override
    public void onRedirectReceived(UrlRequest urlRequest, UrlResponseInfo info,
                                   String newLocationUrl) {
      urlRequest.followRedirect();
    }

    @Override
    public void onResponseStarted(UrlRequest urlRequest, UrlResponseInfo info) {
      if (requestScenario.cancelOnResponseStarted) {
        urlRequest.cancel();
        return;
      }
      ByteBuffer buffer = buffers.peek();
      if (buffer == null) {
        throw new IllegalStateException("No response buffer provided.");
      }
      bufferLastRemaining.set(buffer.remaining());
      urlRequest.read(buffer);
    }

    @Override
    public void onReadCompleted(UrlRequest urlRequest, UrlResponseInfo info,
                                ByteBuffer byteBuffer) {
      numOnReadCompleteCalled++;
      ByteBuffer buffer = buffers.peek();
      if (byteBuffer != buffer) {
        throw new AssertionError("Can't happen...");
      }
      if (buffer.remaining() < bufferLastRemaining.get()) {
        nbChunks.incrementAndGet();
      }
      if (!buffer.hasRemaining()) {
        buffers.poll();
        buffer = buffers.peek();
        if (buffer == null) {
          buffer = ByteBuffer.allocateDirect(0); // This should crash urlRequest.read(buffer)
        }
      }
      bufferLastRemaining.set(buffer.remaining());
      urlRequest.read(buffer);
    }

    @Override
    public void onSucceeded(UrlRequest urlRequest, UrlResponseInfo info) {
      ByteBuffer buffer = buffers.peek();
      if (buffer != null && buffer.remaining() < bufferLastRemaining.get()) {
        nbChunks.incrementAndGet();
      }
      urlRequestCallbackTester.setResponse(
          new Response(info).setBody(responseBodyBuffers).setNbResponseChunks(nbChunks.get()));
    }

    @Override
    public void onFailed(UrlRequest urlRequest, UrlResponseInfo info, CronetException error) {
      urlRequestCallbackTester.setResponse(
          new Response(info).setCronetException(error).setBody(responseBodyBuffers));
    }

    @Override
    public void onCanceled(UrlRequest urlRequest, UrlResponseInfo info) {
      urlRequestCallbackTester.setResponse(
          new Response(info).setBody(responseBodyBuffers).setCancelled());
    }
  }

  private static class RequestScenario {
    String httpMethod = null; // Cronet has defaults - it is optional
    String urlPath = TEST_URL_PATH;
    byte[] requestBody = null;
    final List<Map.Entry<String, String>> header = new ArrayList<>();
    final List<ByteBuffer> responseBody = new ArrayList<>();
    boolean cancelOnResponseStarted = false;

    RequestScenario setHttpMethod(RequestMethod httpMethod) {
      this.httpMethod = httpMethod.name();
      return this;
    }

    RequestScenario setUrlPath(String urlPath) {
      this.urlPath = urlPath;
      return this;
    }

    RequestScenario setRequestBody(byte[] requestBody) {
      this.requestBody = requestBody;
      return this;
    }

    RequestScenario setRequestBody(String requestBody) {
      return setRequestBody(requestBody.getBytes());
    }

    RequestScenario addHeader(String key, String value) {
      header.add(new SimpleImmutableEntry<>(key, value));
      return this;
    }

    RequestScenario addResponseBuffers(int... sizes) {
      for (int size : sizes) {
        responseBody.add(ByteBuffer.allocateDirect(size));
      }
      return this;
    }

    RequestScenario cancelOnResponseStarted() {
      cancelOnResponseStarted = true;
      return this;
    }
  }

  private static class Response {
    private final UrlResponseInfo urlResponseInfo;
    private CronetException cronetException;
    private byte[] body;
    private boolean cancelled = false;
    private int nbResponseChunks = 0;

    Response(UrlResponseInfo urlResponseInfo) { this.urlResponseInfo = urlResponseInfo; }

    Response setCronetException(CronetException cronetException) {
      this.cronetException = cronetException;
      return this;
    }

    Response setBody(List<ByteBuffer> responseBody) {
      int totalSize = responseBody.stream().mapToInt(ByteBuffer::position).sum();
      body = new byte[totalSize];
      int pos = 0;
      for (ByteBuffer buffer : responseBody) {
        int bytesToRead = buffer.position();
        buffer.rewind();
        buffer.get(body, pos, bytesToRead);
        pos += bytesToRead;
      }
      return this;
    }

    Response setCancelled() {
      cancelled = true;
      return this;
    }

    Response setNbResponseChunks(int nbResponseChunks) {
      this.nbResponseChunks = nbResponseChunks;
      return this;
    }

    CronetException getCronetException() { return cronetException; }

    UrlResponseInfo getUrlResponseInfo() { return urlResponseInfo; }

    boolean isCancelled() { return cancelled; }

    int getResponseCode() { return urlResponseInfo.getHttpStatusCode(); }

    String getBodyAsString() { return new String(body); }

    int getNbResponseChunks() { return nbResponseChunks; }

    String getErrorMessage() {
      if (cronetException == null) {
        return "";
      }
      String causeStackTrace = "null";
      if (cronetException.getCause() != null) {
        ByteArrayOutputStream stackTraceBuffer = new ByteArrayOutputStream(100_000);
        PrintStream stackTracePrintStream = new PrintStream(stackTraceBuffer);
        cronetException.getCause().printStackTrace(stackTracePrintStream);
        causeStackTrace = stackTraceBuffer.toString();
      }
      return String.format("Exception: [%s], cause: %s", cronetException, causeStackTrace);
    }
  }
}
package org.chromium.net.impl;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import androidx.test.ext.junit.runners.AndroidJUnit4;

import org.chromium.net.testing.ConditionVariable;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;

import io.envoyproxy.envoymobile.engine.EnvoyHTTPStream;

@RunWith(AndroidJUnit4.class)
public class CancelProofEnvoyStreamTest {

  private static final ByteBuffer BYTE_BUFFER = ByteBuffer.allocateDirect(1);
  private static final HashMap<String, List<String>> HEADERS = new HashMap<>();

  // This mocked version of the EnvoyHTTPStream allows to block while executing of some of its
  // methods. This is used to easily simulate concurrent invocations of those methods.
  private final MockedStream mMockedStream = new MockedStream();

  // When "closed", these the condition variables are blocking the execution of the corresponding
  // method being overridden in MockedStream. A "multi-thread" test can then open the ones it wants.
  private final ConditionVariable mSendHeadersBlock = new ConditionVariable();
  private final ConditionVariable mSendDataBlock = new ConditionVariable();
  private final ConditionVariable mReadDataBlock = new ConditionVariable();

  private final AtomicInteger mSendHeadersInvocationCount = new AtomicInteger();
  private final AtomicInteger mSendDataInvocationCount = new AtomicInteger();
  private final AtomicInteger mReadDataInvocationCount = new AtomicInteger();
  private final AtomicInteger mCancelInvocationCount = new AtomicInteger();

  // This is used to guarantee that many Threads have reach a blocking point. Example, if 10
  // Threads are to be blocked while executing some of the MockedStream methods, then this latch
  // will unblock only when those 10 Threads have reached that blocking point. So to avoid race
  // conditions, a "multi-thread" test must wait for this CountDownLatch to unlock.
  private CountDownLatch mStartLatch = new CountDownLatch(0); // By default no latch.

  private final CancelProofEnvoyStream cancelProofEnvoyStream = new CancelProofEnvoyStream();

  @Before
  public void setUp() {
    // By default MockStream's methods are not blocking.
    mSendHeadersBlock.open();
    mSendDataBlock.open();
    mReadDataBlock.open();
  }

  @After
  public void tearDown() {
    // For the cases where a Thread is being blocked.
    mSendHeadersBlock.open();
    mSendDataBlock.open();
    mReadDataBlock.open();
  }

  @Test
  public void setStream() {
    cancelProofEnvoyStream.setStream(mMockedStream);

    assertThat(mCancelInvocationCount.get()).isZero();
  }

  @Test
  public void setStream_afterCancel() {
    cancelProofEnvoyStream.cancel();

    cancelProofEnvoyStream.setStream(mMockedStream);

    assertThat(mCancelInvocationCount.get()).isOne();
  }

  @Test
  public void setStream_twice() {
    cancelProofEnvoyStream.setStream(mMockedStream);

    assertThatThrownBy(() -> cancelProofEnvoyStream.setStream(mMockedStream))
        .isInstanceOf(AssertionError.class);
  }

  @Test
  public void sendHeaders() {
    cancelProofEnvoyStream.setStream(mMockedStream);

    cancelProofEnvoyStream.sendHeaders(HEADERS, false);

    assertThat(mSendHeadersInvocationCount.get()).isOne();
    assertThat(mCancelInvocationCount.get()).isZero();
  }

  @Test
  public void sendHeaders_withoutStreamSet() {
    assertThatThrownBy(() -> cancelProofEnvoyStream.sendHeaders(HEADERS, false))
        .isInstanceOf(NullPointerException.class);
  }

  @Test
  public void sendHeaders_afterCancel() {
    cancelProofEnvoyStream.setStream(mMockedStream);
    cancelProofEnvoyStream.cancel();

    cancelProofEnvoyStream.sendHeaders(HEADERS, false);

    assertThat(mSendHeadersInvocationCount.get()).isZero();
    assertThat(mCancelInvocationCount.get()).isOne();
  }

  @Test
  public void sendHeaders_postponedCancelGetsExecutedToo() throws Exception {
    cancelProofEnvoyStream.setStream(mMockedStream);
    mSendHeadersBlock.close();           // Following Thread will block on executing sendHeaders
    mStartLatch = new CountDownLatch(1); // Only one method to wait for.
    Thread thread = new Thread(() -> cancelProofEnvoyStream.sendHeaders(HEADERS, false));
    thread.start();
    mStartLatch.await(); // Wait for the above Thread to enter the sendHeaders method.
    cancelProofEnvoyStream.cancel();
    mSendHeadersBlock.open();
    thread.join(); // Wait for the Thread to die.

    assertThat(mSendHeadersInvocationCount.get()).isOne();
    assertThat(mCancelInvocationCount.get()).isOne();
  }

  @Test
  public void sendData() {
    cancelProofEnvoyStream.setStream(mMockedStream);

    cancelProofEnvoyStream.sendData(BYTE_BUFFER, false);

    assertThat(mSendDataInvocationCount.get()).isOne();
    assertThat(mCancelInvocationCount.get()).isZero();
  }

  @Test
  public void sendData_withoutStreamSet() {
    assertThatThrownBy(() -> cancelProofEnvoyStream.sendData(BYTE_BUFFER, false))
        .isInstanceOf(NullPointerException.class);
  }

  @Test
  public void sendData_afterCancel() {
    cancelProofEnvoyStream.setStream(mMockedStream);
    cancelProofEnvoyStream.cancel();

    cancelProofEnvoyStream.sendData(BYTE_BUFFER, false);

    assertThat(mSendDataInvocationCount.get()).isZero();
    assertThat(mCancelInvocationCount.get()).isOne();
  }

  @Test
  public void sendData_postponedCancelGetsExecutedToo() throws Exception {
    cancelProofEnvoyStream.setStream(mMockedStream);
    mSendDataBlock.close();              // Following Thread will block on executing sendData
    mStartLatch = new CountDownLatch(1); // Only one method to wait for.
    Thread thread = new Thread(() -> cancelProofEnvoyStream.sendData(BYTE_BUFFER, false));
    thread.start();
    mStartLatch.await(); // Wait for the above Thread to enter the sendData method.
    cancelProofEnvoyStream.cancel();
    mSendDataBlock.open();
    thread.join(); // Wait for the Thread to die.

    assertThat(mSendDataInvocationCount.get()).isOne();
    assertThat(mCancelInvocationCount.get()).isOne();
  }

  @Test
  public void readData() {
    cancelProofEnvoyStream.setStream(mMockedStream);

    cancelProofEnvoyStream.readData(1);

    assertThat(mReadDataInvocationCount.get()).isOne();
    assertThat(mCancelInvocationCount.get()).isZero();
  }

  @Test
  public void readData_withoutStreamSet() {
    assertThatThrownBy(() -> cancelProofEnvoyStream.readData(1))
        .isInstanceOf(NullPointerException.class);
  }

  @Test
  public void readData_afterCancel() {
    cancelProofEnvoyStream.setStream(mMockedStream);
    cancelProofEnvoyStream.cancel();

    cancelProofEnvoyStream.readData(1);

    assertThat(mReadDataInvocationCount.get()).isZero();
    assertThat(mCancelInvocationCount.get()).isOne();
  }

  @Test
  public void readData_postponedCancelGetsExecutedToo() throws Exception {
    cancelProofEnvoyStream.setStream(mMockedStream);
    mReadDataBlock.close();              // Following Thread will block on executing readData
    mStartLatch = new CountDownLatch(1); // Only one method to wait for.
    Thread thread = new Thread(() -> cancelProofEnvoyStream.readData(1));
    thread.start();
    mStartLatch.await(); // Wait for the above Thread to enter the readData method.
    cancelProofEnvoyStream.cancel();
    mReadDataBlock.open();
    thread.join(); // Wait for the Thread to die.

    assertThat(mReadDataInvocationCount.get()).isOne();
    assertThat(mCancelInvocationCount.get()).isOne();
  }

  @Test
  public void cancel() {
    cancelProofEnvoyStream.setStream(mMockedStream);

    cancelProofEnvoyStream.cancel();

    assertThat(mCancelInvocationCount.get()).isOne();
  }

  @Test
  public void cancel_twice_executedOnlyOnce() {
    cancelProofEnvoyStream.setStream(mMockedStream);

    cancelProofEnvoyStream.cancel();
    cancelProofEnvoyStream.cancel();

    assertThat(mCancelInvocationCount.get()).isOne();
  }

  @Test
  public void cancel_manyConcurrentThreads_executedOnlyOnce() throws Exception {
    cancelProofEnvoyStream.setStream(mMockedStream);
    Thread[] threads = new Thread[100];
    for (int i = 0; i < threads.length; i++) {
      threads[i] = new Thread(cancelProofEnvoyStream::cancel);
    }
    for (Thread thread : threads) {
      thread.start();
    }
    // Wait for all the Threads to die.
    for (Thread thread : threads) {
      thread.join();
    }

    assertThat(mCancelInvocationCount.get()).isOne();
  }

  @Test
  public void cancel_withoutStreamSet() {
    // Does nothing because the "Concurrently Running Stream Operations Count" starts with "1".
    // This is the desired outcome - the cancel is postponed. Once the stream is set, the next
    // Stream Operation will invoke "cancel".
    cancelProofEnvoyStream.cancel();
    // Note: asserting that mCancelInvocationCount is zero is pointless here. It is the MockedStream
    // that can increment the cancel invocation count, and this test does not invoke setStream.
  }

  @Test
  public void cancel_whileSendHeadersIsExecuting_cancelGetsPostponed() throws Exception {
    cancelProofEnvoyStream.setStream(mMockedStream);
    mSendHeadersBlock.close();           // Following Thread will block on executing sendHeaders
    mStartLatch = new CountDownLatch(1); // Only one method to wait for.
    new Thread(() -> cancelProofEnvoyStream.sendHeaders(HEADERS, false)).start();
    mStartLatch.await(); // Wait for the above Thread to enter the sendHeaders method.

    cancelProofEnvoyStream.cancel();

    assertThat(mSendHeadersInvocationCount.get()).isOne();
    assertThat(mCancelInvocationCount.get()).isZero();
  }

  @Test
  public void cancel_whileSendDataIsExecuting_cancelGetsPostponed() throws Exception {
    cancelProofEnvoyStream.setStream(mMockedStream);
    mSendDataBlock.close();              // Following Thread will block on executing sendData
    mStartLatch = new CountDownLatch(1); // Only one method to wait for.
    new Thread(() -> cancelProofEnvoyStream.sendData(BYTE_BUFFER, false)).start();
    mStartLatch.await(); // Wait for the above Thread to enter the sendData method.

    cancelProofEnvoyStream.cancel();

    assertThat(mSendDataInvocationCount.get()).isOne();
    assertThat(mCancelInvocationCount.get()).isZero();
  }

  @Test
  public void cancel_whileReadDataIsExecuting_cancelGetsPostponed() throws Exception {
    cancelProofEnvoyStream.setStream(mMockedStream);
    mReadDataBlock.close();              // Following Thread will block on executing readData
    mStartLatch = new CountDownLatch(1); // Only one method to wait for.
    new Thread(() -> cancelProofEnvoyStream.readData(1)).start();
    mStartLatch.await(); // Wait for the above Thread to enter the readData method.

    cancelProofEnvoyStream.cancel();

    assertThat(mReadDataInvocationCount.get()).isOne();
    assertThat(mCancelInvocationCount.get()).isZero();
  }

  @Test
  public void cancel_manyConcurrentStreamOperationsInFlight() throws Exception {
    cancelProofEnvoyStream.setStream(mMockedStream);
    Thread[] threads = new Thread[300];
    AtomicInteger count = new AtomicInteger();
    for (int i = 0; i < threads.length; i++) {
      threads[i] = new Thread(() -> {
        switch (count.getAndIncrement() % 3) {
        case 0:
          cancelProofEnvoyStream.sendHeaders(HEADERS, false);
          break;
        case 1:
          cancelProofEnvoyStream.sendData(BYTE_BUFFER, false);
          break;
        case 2:
          cancelProofEnvoyStream.readData(1);
          break;
        }
      });
    }
    // Every Thread will be blocked while executing one of the cancelProofEnvoyStream's method.
    mSendHeadersBlock.close();
    mSendDataBlock.close();
    mReadDataBlock.close();
    mStartLatch = new CountDownLatch(threads.length);
    for (Thread thread : threads) {
      thread.start();
    }
    mStartLatch.await(); // Wait for all Thread to reach the blocking point.
    // Sanity check
    assertThat(mSendHeadersInvocationCount.get()).isEqualTo(threads.length / 3);
    assertThat(mSendDataInvocationCount.get()).isEqualTo(threads.length / 3);
    assertThat(mReadDataInvocationCount.get()).isEqualTo(threads.length / 3);

    cancelProofEnvoyStream.cancel();
    assertThat(mCancelInvocationCount.get()).isZero();

    // Let all the Threads to finish executing the cancelProofEnvoyStream's methods.
    mSendHeadersBlock.open();
    mSendDataBlock.open();
    mReadDataBlock.open();
    // Wait for all the Threads to die.
    for (Thread thread : threads) {
      thread.join();
    }
    assertThat(mCancelInvocationCount.get()).isOne();
  }

  private class MockedStream extends EnvoyHTTPStream {

    private MockedStream() { super(0, 0, null, false); }

    @Override
    public void sendHeaders(Map<String, List<String>> headers, boolean endStream) {
      mSendHeadersInvocationCount.incrementAndGet();
      mStartLatch.countDown();
      mSendHeadersBlock.block();
    }

    @Override
    public void sendData(ByteBuffer data, int length, boolean endStream) {
      mSendDataInvocationCount.incrementAndGet();
      mStartLatch.countDown();
      mSendDataBlock.block();
    }

    @Override
    public void readData(long byteCount) {
      mReadDataInvocationCount.incrementAndGet();
      mStartLatch.countDown();
      mReadDataBlock.block();
    }

    @Override
    public int cancel() {
      mCancelInvocationCount.incrementAndGet();
      return 0;
    }
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:kotlin_test.bzl", "envoy_mobile_android_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_android_test(
    name = "cronvoy_test",
    srcs = [
        "AtomicCombinatoryStateTest.java",
        "CancelProofEnvoyStreamTest.java",
        "CronetBidirectionalStateTest.java",
        "CronvoyEngineTest.java",
        "CronvoyLoggerTest.java",
        "UrlRequestCallbackTester.java",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/utilities",
        "//library/java/org/chromium/net",
        "//library/java/org/chromium/net/impl:cronvoy",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/org/chromium/net/testing",
    ],
)
package org.chromium.net.impl;

import static org.assertj.core.api.Assertions.assertThat;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import java.util.concurrent.atomic.AtomicInteger;
import org.chromium.net.testing.ConditionVariable;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
public class AtomicCombinatoryStateTest {

  @Test
  public void trivialCase_false() {
    assertThat(new AtomicCombinatoryState(1).hasReachedFinalState(0)).isFalse();
  }

  @Test
  public void trivialCase_true() {
    assertThat(new AtomicCombinatoryState(1).hasReachedFinalState(1)).isTrue();
  }

  @Test
  public void partialState() {
    assertThat(new AtomicCombinatoryState(3).hasReachedFinalState(1)).isFalse();
  }

  @Test
  public void finalState() {
    AtomicCombinatoryState atomicCombinatoryState = new AtomicCombinatoryState(3);
    atomicCombinatoryState.hasReachedFinalState(2);
    assertThat(atomicCombinatoryState.hasReachedFinalState(1)).isTrue();
  }

  @Test
  public void finalState_twice() {
    AtomicCombinatoryState atomicCombinatoryState = new AtomicCombinatoryState(3);
    atomicCombinatoryState.hasReachedFinalState(2);
    atomicCombinatoryState.hasReachedFinalState(1);
    assertThat(atomicCombinatoryState.hasReachedFinalState(1)).isFalse();
  }

  @Test
  public void finalState_multiThread() throws Exception {
    ConditionVariable startBlock = new ConditionVariable();
    ConditionVariable allThreadsReady = new ConditionVariable();
    AtomicInteger sequence = new AtomicInteger(0);
    AtomicCombinatoryState atomicCombinatoryState = new AtomicCombinatoryState(3);
    AtomicInteger trueCount = new AtomicInteger(0);
    Thread[] threads = new Thread[10];
    for (int i = 0; i < threads.length; i++) {
      threads[i] = new Thread() {
        @Override
        public void run() {
          int sequenceId = sequence.incrementAndGet();
          if (sequenceId == threads.length) {
            allThreadsReady.open();
          }
          startBlock.block();
          if (atomicCombinatoryState.hasReachedFinalState((sequenceId & 1) + 1)) { // 1 and 2 only.
            trueCount.incrementAndGet(); // Should be executed only once.
          }
        }
      };
      threads[i].start();
    }
    allThreadsReady.block(); // This unblocks when all 10 Thread are blocking on "startBlock"
    startBlock.open();       // Most threads will unblock simultaneously on a "multi-threading" CPU.
    for (Thread thread : threads) {
      thread.join(); // Wait for each Thread to die.
    }
    assertThat(trueCount.get()).isEqualTo(1);
  }
}
package org.chromium.net;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.chromium.net.impl.CronvoyUrlResponseInfoImpl;
import org.chromium.net.testing.Feature;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests for {@link UrlResponseInfo}.
 */
@RunWith(AndroidJUnit4.class)
public class UrlResponseInfoTest {
  /**
   * Test for public API of {@link UrlResponseInfo}.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testPublicAPI() throws Exception {
    final List<String> urlChain = new ArrayList<>();
    urlChain.add("chromium.org");
    final int httpStatusCode = 200;
    final String httpStatusText = "OK";
    final List<Map.Entry<String, String>> allHeadersList = new ArrayList<>();
    allHeadersList.add(
        new AbstractMap.SimpleImmutableEntry<>("Date", "Fri, 30 Oct 2015 14:26:41 GMT"));
    final boolean wasCached = true;
    final String negotiatedProtocol = "quic/1+spdy/3";
    final String proxyServer = "example.com";
    final long receivedByteCount = 42;

    final UrlResponseInfo info = new CronvoyUrlResponseInfoImpl(
        urlChain, httpStatusCode, httpStatusText, allHeadersList, wasCached, negotiatedProtocol,
        proxyServer, receivedByteCount);
    assertEquals(info.getUrlChain(), urlChain);
    try {
      info.getUrlChain().add("example.com");
      fail("getUrlChain() returned modifiable list.");
    } catch (UnsupportedOperationException e) {
      // Expected.
    }
    assertEquals(info.getHttpStatusCode(), httpStatusCode);
    assertEquals(info.getHttpStatusText(), httpStatusText);
    assertEquals(info.getAllHeadersAsList(), allHeadersList);
    try {
      info.getAllHeadersAsList().add(new AbstractMap.SimpleImmutableEntry<>("X", "Y"));
      fail("getAllHeadersAsList() returned modifiable list.");
    } catch (UnsupportedOperationException e) {
      // Expected.
    }
    assertEquals(info.getAllHeaders().size(), allHeadersList.size());
    assertEquals(info.getAllHeaders().get(allHeadersList.get(0).getKey()).size(), 1);
    assertEquals(info.getAllHeaders().get(allHeadersList.get(0).getKey()).get(0),
                 allHeadersList.get(0).getValue());
    assertEquals(info.wasCached(), wasCached);
    assertEquals(info.getNegotiatedProtocol(), negotiatedProtocol);
    assertEquals(info.getProxyServer(), proxyServer);
    assertEquals(info.getReceivedByteCount(), receivedByteCount);
  }
}
package org.chromium.net.urlconnection;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.SocketTimeoutException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadFactory;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.Feature;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests the MessageLoop implementation.
 */
@RunWith(AndroidJUnit4.class)
public class MessageLoopTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  private Thread mTestThread;
  private final ExecutorService mExecutorService =
      Executors.newSingleThreadExecutor(new ExecutorThreadFactory());
  private class ExecutorThreadFactory implements ThreadFactory {
    @Override
    public Thread newThread(Runnable r) {
      mTestThread = new Thread(r);
      return mTestThread;
    }
  }
  private boolean mFailed;

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testInterrupt() throws Exception {
    final CronvoyMessageLoop loop = new CronvoyMessageLoop();
    assertFalse(loop.isRunning());
    Future future = mExecutorService.submit(new Runnable() {
      @Override
      public void run() {
        try {
          loop.loop();
          mFailed = true;
        } catch (IOException e) {
          // Expected interrupt.
        }
      }
    });
    Thread.sleep(1000);
    assertTrue(loop.isRunning());
    assertFalse(loop.hasLoopFailed());
    mTestThread.interrupt();
    future.get();
    assertFalse(loop.isRunning());
    assertTrue(loop.hasLoopFailed());
    assertFalse(mFailed);
    // Re-spinning the message loop is not allowed after interrupt.
    mExecutorService
        .submit(new Runnable() {
          @Override
          public void run() {
            try {
              loop.loop();
              fail();
            } catch (Exception e) {
              if (!(e instanceof InterruptedIOException)) {
                fail();
              }
            }
          }
        })
        .get();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testTaskFailed() throws Exception {
    final CronvoyMessageLoop loop = new CronvoyMessageLoop();
    assertFalse(loop.isRunning());
    Future future = mExecutorService.submit(new Runnable() {
      @Override
      public void run() {
        try {
          loop.loop();
          mFailed = true;
        } catch (Exception e) {
          if (!(e instanceof NullPointerException)) {
            mFailed = true;
          }
        }
      }
    });
    Runnable failedTask = new Runnable() {
      @Override
      public void run() {
        throw new NullPointerException();
      }
    };
    Thread.sleep(1000);
    assertTrue(loop.isRunning());
    assertFalse(loop.hasLoopFailed());
    loop.execute(failedTask);
    future.get();
    assertFalse(loop.isRunning());
    assertTrue(loop.hasLoopFailed());
    assertFalse(mFailed);
    // Re-spinning the message loop is not allowed after exception.
    mExecutorService
        .submit(new Runnable() {
          @Override
          public void run() {
            try {
              loop.loop();
              fail();
            } catch (Exception e) {
              if (!(e instanceof NullPointerException)) {
                fail();
              }
            }
          }
        })
        .get();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testLoopWithTimeout() throws Exception {
    final CronvoyMessageLoop loop = new CronvoyMessageLoop();
    assertFalse(loop.isRunning());
    // The MessageLoop queue is empty. Use a timeout of 100ms to check that
    // it doesn't block forever.
    try {
      loop.loop(100);
      fail();
    } catch (SocketTimeoutException e) {
      // Expected.
    }
    assertFalse(loop.isRunning());
  }
}
package org.chromium.net.urlconnection;

import static org.chromium.net.testing.CronetTestRule.getContext;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import java.io.IOException;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.ProtocolException;
import java.net.URL;
import org.chromium.net.CronetEngine;
import org.chromium.net.NetworkException;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.CronetTestRule.CompareDefaultWithCronet;
import org.chromium.net.testing.CronetTestRule.OnlyRunCronetHttpURLConnection;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.NativeTestServer;
import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests {@code getOutputStream} when {@code setChunkedStreamingMode} is enabled.
 * Tests annotated with {@code CompareDefaultWithCronet} will run once with the
 * default HttpURLConnection implementation and then with Cronet's
 * HttpURLConnection implementation. Tests annotated with
 * {@code OnlyRunCronetHttpURLConnection} only run Cronet's implementation.
 * See {@link CronetTestRule#runBase()} ()} for details.
 */
@RunWith(AndroidJUnit4.class)
public class CronetChunkedOutputStreamTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  @Before
  public void setUp() throws Exception {
    mTestRule.setStreamHandlerFactory(new CronetEngine.Builder(getContext()).build());
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
  }

  @After
  public void tearDown() throws Exception {
    NativeTestServer.shutdownNativeTestServer();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testGetOutputStreamAfterConnectionMade() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setChunkedStreamingMode(0);
    assertEquals(200, connection.getResponseCode());
    try {
      connection.getOutputStream();
      fail();
    } catch (ProtocolException e) {
      // Expected.
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testWriteAfterReadingResponse() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setChunkedStreamingMode(0);
    OutputStream out = connection.getOutputStream();
    assertEquals(200, connection.getResponseCode());
    try {
      out.write(TestUtil.UPLOAD_DATA);
      fail();
    } catch (IOException e) {
      // Expected.
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1550")
  public void testWriteAfterRequestFailed() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setChunkedStreamingMode(0);
    OutputStream out = connection.getOutputStream();
    out.write(TestUtil.UPLOAD_DATA);
    NativeTestServer.shutdownNativeTestServer();
    try {
      out.write(TestUtil.getLargeData());
      connection.getResponseCode();
      fail();
    } catch (IOException e) {
      if (!mTestRule.testingSystemHttpURLConnection()) {
        NetworkException requestException = (NetworkException)e;
        assertEquals(NetworkException.ERROR_CONNECTION_REFUSED, requestException.getErrorCode());
      }
    }
    connection.disconnect();
    // Restarting server to run the test for a second time.
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1550")
  public void testGetResponseAfterWriteFailed() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    NativeTestServer.shutdownNativeTestServer();
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    // Set 1 byte as chunk size so internally Cronet will try upload when
    // 1 byte is filled.
    connection.setChunkedStreamingMode(1);
    try {
      OutputStream out = connection.getOutputStream();
      out.write(1);
      out.write(1);
      // Forces OutputStream implementation to flush. crbug.com/653072
      out.flush();
      // System's implementation is flaky see crbug.com/653072.
      if (!mTestRule.testingSystemHttpURLConnection()) {
        fail();
      }
    } catch (IOException e) {
      if (!mTestRule.testingSystemHttpURLConnection()) {
        NetworkException requestException = (NetworkException)e;
        assertEquals(NetworkException.ERROR_CONNECTION_REFUSED, requestException.getErrorCode());
      }
    }
    // Make sure IOException is reported again when trying to read response
    // from the connection.
    try {
      connection.getResponseCode();
      fail();
    } catch (IOException e) {
      // Expected.
      if (!mTestRule.testingSystemHttpURLConnection()) {
        NetworkException requestException = (NetworkException)e;
        assertEquals(NetworkException.ERROR_CONNECTION_REFUSED, requestException.getErrorCode());
      }
    }
    // Restarting server to run the test for a second time.
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPost() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setChunkedStreamingMode(0);
    OutputStream out = connection.getOutputStream();
    out.write(TestUtil.UPLOAD_DATA);
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    assertEquals(TestUtil.UPLOAD_DATA_STRING, TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testTransferEncodingHeaderSet() throws Exception {
    URL url = new URL(NativeTestServer.getEchoHeaderURL("Transfer-Encoding"));
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setChunkedStreamingMode(0);
    OutputStream out = connection.getOutputStream();
    out.write(TestUtil.UPLOAD_DATA);
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    assertEquals("chunked", TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPostOneMassiveWrite() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setChunkedStreamingMode(0);
    OutputStream out = connection.getOutputStream();
    byte[] largeData = TestUtil.getLargeData();
    out.write(largeData);
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    TestUtil.checkLargeData(TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPostWriteOneByte() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setChunkedStreamingMode(0);
    OutputStream out = connection.getOutputStream();
    for (int i = 0; i < TestUtil.UPLOAD_DATA.length; i++) {
      out.write(TestUtil.UPLOAD_DATA[i]);
    }
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    assertEquals(TestUtil.UPLOAD_DATA_STRING, TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPostOneMassiveWriteWriteOneByte() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setChunkedStreamingMode(0);
    OutputStream out = connection.getOutputStream();
    byte[] largeData = TestUtil.getLargeData();
    for (int i = 0; i < largeData.length; i++) {
      out.write(largeData[i]);
    }
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    TestUtil.checkLargeData(TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPostWholeNumberOfChunks() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    int totalSize = TestUtil.UPLOAD_DATA.length * TestUtil.REPEAT_COUNT;
    int chunkSize = 18000;
    // Ensure total data size is a multiple of chunk size, so no partial
    // chunks will be used.
    assertEquals(0, totalSize % chunkSize);
    connection.setChunkedStreamingMode(chunkSize);
    OutputStream out = connection.getOutputStream();
    byte[] largeData = TestUtil.getLargeData();
    out.write(largeData);
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    TestUtil.checkLargeData(TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @OnlyRunCronetHttpURLConnection
  // Regression testing for crbug.com/618872.
  public void testOneMassiveWriteLargerThanInternalBuffer() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    // Use a super big chunk size so that it exceeds the UploadDataProvider
    // read buffer size.
    byte[] largeData = TestUtil.getLargeData();
    connection.setChunkedStreamingMode(largeData.length);
    OutputStream out = connection.getOutputStream();
    out.write(largeData);
    assertEquals(200, connection.getResponseCode());
    TestUtil.checkLargeData(TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }
}
package org.chromium.net.urlconnection;

import static com.google.common.truth.Truth.assertThat;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.concurrent.Callable;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.StrictModeContext;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentMatchers;
import org.mockito.Mockito;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

/**
 * Test for {@link CronetInputStream}.
 */
@RunWith(AndroidJUnit4.class)
public class CronetInputStreamTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  private CronvoyHttpURLConnection mMockConnection;

  @Before
  public void setUp() throws Exception {
    // Disable StrictMode constraints for mock initialization.
    try (StrictModeContext ignored = StrictModeContext.allowAllVmPolicies()) {
      mMockConnection = Mockito.mock(CronvoyHttpURLConnection.class);
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testAvailable_closed_withoutException() throws Exception {
    runTestCase(underTest -> {
      underTest.setResponseDataCompleted(null);

      assertThat(underTest.available()).isEqualTo(0);
    });
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testAvailable_closed_withException() throws Exception {
    runTestCase(underTest -> {
      IOException expected = new IOException();
      underTest.setResponseDataCompleted(expected);

      IOException actual = assertThrowsIoException(() -> underTest.available());

      assertThat(actual).isSameInstanceAs(expected);
    });
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testAvailable_noReads() throws Exception {
    runTestCase(underTest -> { assertThat(underTest.available()).isEqualTo(0); });
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testAvailable_everythingRead() throws Exception {
    runTestCase(underTest -> {
      int bytesInBuffer = 10;

      Mockito.doAnswer(addZerosToBuffer(bytesInBuffer))
          .when(mMockConnection)
          .getMoreData(ArgumentMatchers.any());

      for (int i = 0; i < bytesInBuffer; i++) {
        underTest.read();
      }

      assertThat(underTest.available()).isEqualTo(0);
    });
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testAvailable_partiallyRead() throws Exception {
    runTestCase(underTest -> {
      int bytesInBuffer = 10;
      int consumed = 3;

      Mockito.doAnswer(addZerosToBuffer(bytesInBuffer))
          .when(mMockConnection)
          .getMoreData(ArgumentMatchers.any());

      for (int i = 0; i < consumed; i++) {
        underTest.read();
      }

      assertThat(underTest.available()).isEqualTo(bytesInBuffer - consumed);
    });
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testRead_afterDataCompleted() throws Exception {
    runTestCase(underTest -> {
      int bytesInBuffer = 10;
      int consumed = 3;

      Mockito.doAnswer(addZerosToBuffer(bytesInBuffer))
          .when(mMockConnection)
          .getMoreData(ArgumentMatchers.any());

      for (int i = 0; i < consumed; i++) {
        underTest.read();
      }

      IOException expected = new IOException();
      underTest.setResponseDataCompleted(expected);

      IOException actual = assertThrowsIoException(() -> underTest.read());

      assertThat(actual).isSameInstanceAs(expected);
    });
  }

  private void runTestCase(CronetInputStreamTestCase testCase) throws Exception {
    try (CronvoyInputStream underTest = new CronvoyInputStream(mMockConnection)) {
      testCase.runTestCase(underTest);
    }
  }

  private static Answer<Void> addZerosToBuffer(int count) {
    return new Answer<Void>() {
      @Override
      public Void answer(InvocationOnMock invocation) {
        ByteBuffer arg = (ByteBuffer)invocation.getArguments()[0];
        for (int i = 0; i < count; i++) {
          arg.put((byte)0);
        }
        return null;
      }
    };
  }

  private static IOException assertThrowsIoException(Callable<?> callable) throws Exception {
    try {
      callable.call();
    } catch (IOException e) {
      return e;
    } catch (Exception e) {
      throw e;
    }
    throw new AssertionError("No exception was thrown!");
  }

  private static interface CronetInputStreamTestCase {
    void runTestCase(CronvoyInputStream underTest) throws Exception;
  }
}
package org.chromium.net.urlconnection;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.Feature;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Test for CronetURLStreamHandlerFactory.
 */
@RunWith(AndroidJUnit4.class)
@SuppressWarnings("deprecation")
public class CronetURLStreamHandlerFactoryTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testRequireConfig() throws Exception {
    mTestRule.startCronetTestFramework();
    try {
      new CronvoyURLStreamHandlerFactory(null);
      fail();
    } catch (NullPointerException e) {
      assertEquals("CronetEngine is null.", e.getMessage());
    }
  }
}
package org.chromium.net.urlconnection;

import static org.chromium.net.testing.CronetTestRule.getContext;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import java.io.IOException;
import java.io.OutputStream;
import java.net.HttpRetryException;
import java.net.HttpURLConnection;
import java.net.URL;
import org.chromium.net.CronetEngine;
import org.chromium.net.NetworkException;
import org.chromium.net.impl.CronvoyCallbackExceptionImpl;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.CronetTestRule.CompareDefaultWithCronet;
import org.chromium.net.testing.CronetTestRule.OnlyRunCronetHttpURLConnection;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.NativeTestServer;
import org.hamcrest.Description;
import org.hamcrest.TypeSafeMatcher;
import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;

/**
 * Tests {@code getOutputStream} when {@code setFixedLengthStreamingMode} is
 * enabled.
 * Tests annotated with {@code CompareDefaultWithCronet} will run once with the
 * default HttpURLConnection implementation and then with Cronet's
 * HttpURLConnection implementation. Tests annotated with
 * {@code OnlyRunCronetHttpURLConnection} only run Cronet's implementation.
 * See {@link CronetTestRule#runBase()} ()} for details.
 */
@RunWith(AndroidJUnit4.class)
public class CronetFixedModeOutputStreamTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  @Rule public ExpectedException thrown = ExpectedException.none();

  @Before
  public void setUp() throws Exception {
    mTestRule.setStreamHandlerFactory(new CronetEngine.Builder(getContext()).build());
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
  }

  @After
  public void tearDown() throws Exception {
    NativeTestServer.shutdownNativeTestServer();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testConnectBeforeWrite() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setFixedLengthStreamingMode(TestUtil.UPLOAD_DATA.length);
    OutputStream out = connection.getOutputStream();
    connection.connect();
    out.write(TestUtil.UPLOAD_DATA);
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    assertEquals(TestUtil.UPLOAD_DATA_STRING, TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  // Regression test for crbug.com/687600.
  public void testZeroLengthWriteWithNoResponseBody() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setFixedLengthStreamingMode(0);
    OutputStream out = connection.getOutputStream();
    out.write(new byte[] {});
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1550")
  public void testWriteAfterRequestFailed() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    byte[] largeData = TestUtil.getLargeData();
    connection.setFixedLengthStreamingMode(largeData.length);
    OutputStream out = connection.getOutputStream();
    out.write(largeData, 0, 10);
    NativeTestServer.shutdownNativeTestServer();
    try {
      out.write(largeData, 10, largeData.length - 10);
      connection.getResponseCode();
      fail();
    } catch (IOException e) {
      // Expected.
      if (!mTestRule.testingSystemHttpURLConnection()) {
        NetworkException requestException = (NetworkException)e;
        assertEquals(NetworkException.ERROR_CONNECTION_REFUSED, requestException.getErrorCode());
      }
    }
    connection.disconnect();
    // Restarting server to run the test for a second time.
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1550")
  public void testGetResponseAfterWriteFailed() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    NativeTestServer.shutdownNativeTestServer();
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    // Set content-length as 1 byte, so Cronet will upload once that 1 byte
    // is passed to it.
    connection.setFixedLengthStreamingMode(1);
    try {
      OutputStream out = connection.getOutputStream();
      out.write(1);
      out.write(1);
      // Forces OutputStream implementation to flush. crbug.com/653072
      out.flush();
      // System's implementation is flaky see crbug.com/653072.
      if (!mTestRule.testingSystemHttpURLConnection()) {
        fail();
      }
    } catch (IOException e) {
      if (!mTestRule.testingSystemHttpURLConnection()) {
        NetworkException requestException = (NetworkException)e;
        assertEquals(NetworkException.ERROR_CONNECTION_REFUSED, requestException.getErrorCode());
      }
    }
    // Make sure IOException is reported again when trying to read response
    // from the connection.
    try {
      connection.getResponseCode();
      fail();
    } catch (IOException e) {
      // Expected.
      if (!mTestRule.testingSystemHttpURLConnection()) {
        NetworkException requestException = (NetworkException)e;
        assertEquals(NetworkException.ERROR_CONNECTION_REFUSED, requestException.getErrorCode());
      }
    }
    // Restarting server to run the test for a second time.
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testFixedLengthStreamingModeZeroContentLength() throws Exception {
    // Check content length is set.
    URL echoLength = new URL(NativeTestServer.getEchoHeaderURL("Content-Length"));
    HttpURLConnection connection1 = (HttpURLConnection)echoLength.openConnection();
    connection1.setDoOutput(true);
    connection1.setRequestMethod("POST");
    connection1.setFixedLengthStreamingMode(0);
    assertEquals(200, connection1.getResponseCode());
    assertEquals("OK", connection1.getResponseMessage());
    assertEquals("0", TestUtil.getResponseAsString(connection1));
    connection1.disconnect();

    // Check body is empty.
    URL echoBody = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection2 = (HttpURLConnection)echoBody.openConnection();
    connection2.setDoOutput(true);
    connection2.setRequestMethod("POST");
    connection2.setFixedLengthStreamingMode(0);
    assertEquals(200, connection2.getResponseCode());
    assertEquals("OK", connection2.getResponseMessage());
    assertEquals("", TestUtil.getResponseAsString(connection2));
    connection2.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testWriteLessThanContentLength() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    // Set a content length that's 1 byte more.
    connection.setFixedLengthStreamingMode(TestUtil.UPLOAD_DATA.length + 1);
    OutputStream out = connection.getOutputStream();
    out.write(TestUtil.UPLOAD_DATA);
    try {
      connection.getResponseCode();
      fail();
    } catch (IOException e) {
      // Expected.
    }
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testWriteMoreThanContentLength() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    // Set a content length that's 1 byte short.
    connection.setFixedLengthStreamingMode(TestUtil.UPLOAD_DATA.length - 1);
    OutputStream out = connection.getOutputStream();
    try {
      out.write(TestUtil.UPLOAD_DATA);
      // On Lollipop, default implementation only triggers the error when reading response.
      connection.getInputStream();
      fail();
    } catch (IOException e) {
      // Expected.
      // TODO (colibie) run by cleborgne@
      String expectedVariant = "expected " + (TestUtil.UPLOAD_DATA.length - 1) +
                               " bytes but received " + TestUtil.UPLOAD_DATA.length;
      String expectedVariantOnAndroid10 = "too many bytes written";
      assertTrue(expectedVariant.equals(e.getMessage()) ||
                 expectedVariantOnAndroid10.equals(e.getMessage()));
    }
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1553")
  public void testWriteMoreThanContentLengthWriteOneByte() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    // Set a content length that's 1 byte short.
    connection.setFixedLengthStreamingMode(TestUtil.UPLOAD_DATA.length - 1);
    OutputStream out = connection.getOutputStream();
    for (int i = 0; i < TestUtil.UPLOAD_DATA.length - 1; i++) {
      out.write(TestUtil.UPLOAD_DATA[i]);
    }
    try {
      // Try upload an extra byte.
      out.write(TestUtil.UPLOAD_DATA[TestUtil.UPLOAD_DATA.length - 1]);
      // On Lollipop, default implementation only triggers the error when reading response.
      connection.getInputStream();
      fail();
    } catch (IOException e) {
      // Expected.
      String expectedVariant = "expected 0 bytes but received 1";
      String expectedVariantOnLollipop = "expected " + (TestUtil.UPLOAD_DATA.length - 1) +
                                         " bytes but received " + TestUtil.UPLOAD_DATA.length;
      assertTrue(expectedVariant.equals(e.getMessage()) ||
                 expectedVariantOnLollipop.equals(e.getMessage()));
    }
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testFixedLengthStreamingMode() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setFixedLengthStreamingMode(TestUtil.UPLOAD_DATA.length);
    OutputStream out = connection.getOutputStream();
    out.write(TestUtil.UPLOAD_DATA);
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    assertEquals(TestUtil.UPLOAD_DATA_STRING, TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testFixedLengthStreamingModeWriteOneByte() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setFixedLengthStreamingMode(TestUtil.UPLOAD_DATA.length);
    OutputStream out = connection.getOutputStream();
    for (int i = 0; i < TestUtil.UPLOAD_DATA.length; i++) {
      // Write one byte at a time.
      out.write(TestUtil.UPLOAD_DATA[i]);
    }
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    assertEquals(TestUtil.UPLOAD_DATA_STRING, TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testFixedLengthStreamingModeLargeData() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    // largeData is 1.8 MB.
    byte[] largeData = TestUtil.getLargeData();
    connection.setFixedLengthStreamingMode(largeData.length);
    OutputStream out = connection.getOutputStream();
    int totalBytesWritten = 0;
    // Number of bytes to write each time. It is doubled each time
    // to make sure that the implementation can handle large writes.
    int bytesToWrite = 683;
    while (totalBytesWritten < largeData.length) {
      if (bytesToWrite > largeData.length - totalBytesWritten) {
        // Do not write out of bound.
        bytesToWrite = largeData.length - totalBytesWritten;
      }
      out.write(largeData, totalBytesWritten, bytesToWrite);
      totalBytesWritten += bytesToWrite;
      // About 5th iteration of this loop, bytesToWrite will be bigger than 16384.
      bytesToWrite *= 2;
    }
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    TestUtil.checkLargeData(TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testFixedLengthStreamingModeLargeDataWriteOneByte() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    byte[] largeData = TestUtil.getLargeData();
    connection.setFixedLengthStreamingMode(largeData.length);
    OutputStream out = connection.getOutputStream();
    for (int i = 0; i < largeData.length; i++) {
      // Write one byte at a time.
      out.write(largeData[i]);
    }
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    TestUtil.checkLargeData(TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @OnlyRunCronetHttpURLConnection
  public void testJavaBufferSizeLargerThanNativeBufferSize() throws Exception {
    // Set an internal buffer of size larger than the buffer size used
    // in network stack internally.
    // Normal stream uses 16384, QUIC uses 14520, and SPDY uses 16384.
    // Try two different buffer lengths. 17384 will make the last write
    // smaller than the native buffer length; 18384 will make the last write
    // bigger than the native buffer length
    // (largeData.length % 17384 = 9448, largeData.length % 18384 = 16752).
    int[] bufferLengths = new int[] {17384, 18384};
    for (int length : bufferLengths) {
      CronvoyFixedModeOutputStream.setDefaultBufferLengthForTesting(length);
      // Run the following three tests with this custom buffer size.
      testFixedLengthStreamingModeLargeDataWriteOneByte();
      testFixedLengthStreamingModeLargeData();
      testOneMassiveWrite();
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testOneMassiveWrite() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    byte[] largeData = TestUtil.getLargeData();
    connection.setFixedLengthStreamingMode(largeData.length);
    OutputStream out = connection.getOutputStream();
    // Write everything at one go, so the data is larger than the buffer
    // used in CronetFixedModeOutputStream.
    out.write(largeData);
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    TestUtil.checkLargeData(TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  private static class CauseMatcher extends TypeSafeMatcher<Throwable> {
    private final Class<? extends Throwable> mType;
    private final String mExpectedMessage;

    public CauseMatcher(Class<? extends Throwable> type, String expectedMessage) {
      this.mType = type;
      this.mExpectedMessage = expectedMessage;
    }

    @Override
    protected boolean matchesSafely(Throwable item) {
      return item.getClass().isAssignableFrom(mType) && item.getMessage().equals(mExpectedMessage);
    }
    @Override
    public void describeTo(Description description) {}
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @OnlyRunCronetHttpURLConnection
  public void testRewindWithCronet() throws Exception {
    assertFalse(mTestRule.testingSystemHttpURLConnection());
    // Post preserving redirect should fail.
    URL url = new URL(NativeTestServer.getRedirectToEchoBody());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setFixedLengthStreamingMode(TestUtil.UPLOAD_DATA.length);
    thrown.expect(instanceOf(CronvoyCallbackExceptionImpl.class));
    thrown.expectMessage("Exception received from UploadDataProvider");
    thrown.expectCause(
        new CauseMatcher(HttpRetryException.class, "Cannot retry streamed Http body"));
    OutputStream out = connection.getOutputStream();
    out.write(TestUtil.UPLOAD_DATA);
    connection.getResponseCode();
    connection.disconnect();
  }
}
package org.chromium.net.urlconnection;

import static org.chromium.net.testing.CronetTestRule.getContext;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import java.net.HttpURLConnection;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.URL;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.CronetTestRule.CronetTestFramework;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.NativeTestServer;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests for CronetHttpURLStreamHandler class.
 */
@RunWith(AndroidJUnit4.class)
public class CronetHttpURLStreamHandlerTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  private CronetTestFramework mTestFramework;

  @Before
  public void setUp() throws Exception {
    mTestFramework = mTestRule.startCronetTestFramework();
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
  }

  @After
  public void tearDown() throws Exception {
    NativeTestServer.shutdownNativeTestServer();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testOpenConnectionHttp() throws Exception {
    URL url = new URL(NativeTestServer.getEchoMethodURL());
    CronvoyHttpURLStreamHandler streamHandler =
        new CronvoyHttpURLStreamHandler(mTestFramework.mCronetEngine);
    HttpURLConnection connection = (HttpURLConnection)streamHandler.openConnection(url);
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    assertEquals("GET", TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testOpenConnectionHttps() throws Exception {
    URL url = new URL("https://example.com");
    CronvoyHttpURLStreamHandler streamHandler =
        new CronvoyHttpURLStreamHandler(mTestFramework.mCronetEngine);
    HttpURLConnection connection = (HttpURLConnection)streamHandler.openConnection(url);
    assertNotNull(connection);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testOpenConnectionProtocolNotSupported() throws Exception {
    URL url = new URL("ftp://example.com");
    CronvoyHttpURLStreamHandler streamHandler =
        new CronvoyHttpURLStreamHandler(mTestFramework.mCronetEngine);
    try {
      streamHandler.openConnection(url);
      fail();
    } catch (UnsupportedOperationException e) {
      assertEquals("Unexpected protocol:ftp", e.getMessage());
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testOpenConnectionWithProxy() throws Exception {
    URL url = new URL(NativeTestServer.getEchoMethodURL());
    CronvoyHttpURLStreamHandler streamHandler =
        new CronvoyHttpURLStreamHandler(mTestFramework.mCronetEngine);
    Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress("127.0.0.1", 8080));
    try {
      streamHandler.openConnection(url, proxy);
      fail();
    } catch (UnsupportedOperationException e) {
      // Expected.
    }
  }
}
package org.chromium.net.urlconnection;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.net.HttpURLConnection;
import org.junit.Assert;

/**
 * Helper functions and fields used in Cronet's HttpURLConnection tests.
 */
final class TestUtil {
  static final String UPLOAD_DATA_STRING = "Nifty upload data!";
  static final byte[] UPLOAD_DATA = UPLOAD_DATA_STRING.getBytes();
  static final int REPEAT_COUNT = 100000;

  private TestUtil() {}
  /**
   * Helper method to extract response body as a string for testing.
   */
  static String getResponseAsString(HttpURLConnection connection) throws Exception {
    InputStream in = connection.getInputStream();
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    int b;
    while ((b = in.read()) != -1) {
      out.write(b);
    }
    return out.toString();
  }

  /**
   * Produces a byte array that contains {@code REPEAT_COUNT} of
   * {@code UPLOAD_DATA_STRING}.
   */
  static byte[] getLargeData() {
    byte[] largeData = new byte[REPEAT_COUNT * UPLOAD_DATA.length];
    for (int i = 0; i < REPEAT_COUNT; i++) {
      System.arraycopy(UPLOAD_DATA, 0, largeData, i * UPLOAD_DATA.length, UPLOAD_DATA.length);
    }
    return largeData;
  }

  /**
   * Helper function to check whether {@code data} is a concatenation of
   * {@code REPEAT_COUNT} {@code UPLOAD_DATA_STRING} strings.
   */
  static void checkLargeData(String data) {
    for (int i = 0; i < REPEAT_COUNT; i++) {
      Assert.assertEquals(
          UPLOAD_DATA_STRING,
          data.substring(UPLOAD_DATA_STRING.length() * i, UPLOAD_DATA_STRING.length() * (i + 1)));
    }
  }
}
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:kotlin_test.bzl", "envoy_mobile_android_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

envoy_mobile_android_test(
    name = "urlconnection_test",
    srcs = [
        "CronetBufferedOutputStreamTest.java",
        "CronetChunkedOutputStreamTest.java",
        "CronetFixedModeOutputStreamTest.java",
        "CronetHttpURLStreamHandlerTest.java",
        "CronetInputStreamTest.java",
        "CronetURLStreamHandlerFactoryTest.java",
        "MessageLoopTest.java",
        "TestUtil.java",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/utilities",
        "//library/java/org/chromium/net",
        "//library/java/org/chromium/net/impl:cronvoy",
        "//library/java/org/chromium/net/urlconnection",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "//test/java/org/chromium/net/testing",
    ],
)
package org.chromium.net.urlconnection;

import static org.chromium.net.testing.CronetTestRule.getContext;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import java.io.IOException;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import org.chromium.net.CronetEngine;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.CronetTestRule.CompareDefaultWithCronet;
import org.chromium.net.testing.CronetTestRule.OnlyRunCronetHttpURLConnection;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.NativeTestServer;
import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests the CronetBufferedOutputStream implementation.
 */
@RunWith(AndroidJUnit4.class)
public class CronetBufferedOutputStreamTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  @Before
  public void setUp() throws Exception {
    mTestRule.setStreamHandlerFactory(new CronetEngine.Builder(getContext()).build());
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
  }

  @After
  public void tearDown() throws Exception {
    NativeTestServer.shutdownNativeTestServer();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testGetOutputStreamAfterConnectionMade() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    assertEquals(200, connection.getResponseCode());
    try {
      connection.getOutputStream();
      fail();
    } catch (java.net.ProtocolException e) {
      // Expected.
    }
  }

  /**
   * Tests write after connect. Strangely, the default implementation allows
   * writing after being connected, so this test only runs against Cronet 's
   * implementation.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  @OnlyRunCronetHttpURLConnection
  public void testWriteAfterConnect() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    OutputStream out = connection.getOutputStream();
    out.write(TestUtil.UPLOAD_DATA);
    connection.connect();
    try {
      // Attempt to write some more.
      out.write(TestUtil.UPLOAD_DATA);
      fail();
    } catch (IllegalStateException e) {
      assertEquals("Use setFixedLengthStreamingMode() or "
                       + "setChunkedStreamingMode() for writing after connect",
                   e.getMessage());
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1553")
  public void testWriteAfterReadingResponse() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    OutputStream out = connection.getOutputStream();
    assertEquals(200, connection.getResponseCode());
    try {
      out.write(TestUtil.UPLOAD_DATA);
      fail();
    } catch (Exception e) {
      // Default implementation gives an IOException and says that the
      // stream is closed. Cronet gives an IllegalStateException and
      // complains about write after connected.
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPostWithContentLength() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    byte[] largeData = TestUtil.getLargeData();
    connection.setRequestProperty("Content-Length", Integer.toString(largeData.length));
    OutputStream out = connection.getOutputStream();
    int totalBytesWritten = 0;
    // Number of bytes to write each time. It is doubled each time
    // to make sure that the buffer grows.
    int bytesToWrite = 683;
    while (totalBytesWritten < largeData.length) {
      if (bytesToWrite > largeData.length - totalBytesWritten) {
        // Do not write out of bound.
        bytesToWrite = largeData.length - totalBytesWritten;
      }
      out.write(largeData, totalBytesWritten, bytesToWrite);
      totalBytesWritten += bytesToWrite;
      bytesToWrite *= 2;
    }
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    TestUtil.checkLargeData(TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPostWithContentLengthOneMassiveWrite() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    byte[] largeData = TestUtil.getLargeData();
    connection.setRequestProperty("Content-Length", Integer.toString(largeData.length));
    OutputStream out = connection.getOutputStream();
    out.write(largeData);
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    TestUtil.checkLargeData(TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPostWithContentLengthWriteOneByte() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    byte[] largeData = TestUtil.getLargeData();
    connection.setRequestProperty("Content-Length", Integer.toString(largeData.length));
    OutputStream out = connection.getOutputStream();
    for (int i = 0; i < largeData.length; i++) {
      out.write(largeData[i]);
    }
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    TestUtil.checkLargeData(TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPostWithZeroContentLength() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setRequestProperty("Content-Length", "0");
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    assertEquals("", TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPostZeroByteWithoutContentLength() throws Exception {
    // Make sure both implementation sets the Content-Length header to 0.
    // TODO(colibie) added the if-statement because sdk 29 impl does not set content-Length to zero
    if (!mTestRule.testingSystemHttpURLConnection()) {
      URL url = new URL(NativeTestServer.getEchoHeaderURL("Content-Length"));
      HttpURLConnection connection = (HttpURLConnection)url.openConnection();
      connection.setDoOutput(true);
      connection.setRequestMethod("POST");
      assertEquals(200, connection.getResponseCode());
      assertEquals("OK", connection.getResponseMessage());
      assertEquals("0", TestUtil.getResponseAsString(connection));
      connection.disconnect();
    }

    // Make sure the server echoes back empty body for both implementation.
    URL echoBody = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection2 = (HttpURLConnection)echoBody.openConnection();
    connection2.setDoOutput(true);
    connection2.setRequestMethod("POST");
    assertEquals(200, connection2.getResponseCode());
    assertEquals("OK", connection2.getResponseMessage());
    assertEquals("", TestUtil.getResponseAsString(connection2));
    connection2.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPostWithoutContentLengthSmall() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    OutputStream out = connection.getOutputStream();
    out.write(TestUtil.UPLOAD_DATA);
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    assertEquals(TestUtil.UPLOAD_DATA_STRING, TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPostWithoutContentLength() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    byte[] largeData = TestUtil.getLargeData();
    OutputStream out = connection.getOutputStream();
    int totalBytesWritten = 0;
    // Number of bytes to write each time. It is doubled each time
    // to make sure that the buffer grows.
    int bytesToWrite = 683;
    while (totalBytesWritten < largeData.length) {
      if (bytesToWrite > largeData.length - totalBytesWritten) {
        // Do not write out of bound.
        bytesToWrite = largeData.length - totalBytesWritten;
      }
      out.write(largeData, totalBytesWritten, bytesToWrite);
      totalBytesWritten += bytesToWrite;
      bytesToWrite *= 2;
    }
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    TestUtil.checkLargeData(TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPostWithoutContentLengthOneMassiveWrite() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    OutputStream out = connection.getOutputStream();
    byte[] largeData = TestUtil.getLargeData();
    out.write(largeData);
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    TestUtil.checkLargeData(TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  public void testPostWithoutContentLengthWriteOneByte() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    OutputStream out = connection.getOutputStream();
    byte[] largeData = TestUtil.getLargeData();
    for (int i = 0; i < largeData.length; i++) {
      out.write(largeData[i]);
    }
    assertEquals(200, connection.getResponseCode());
    assertEquals("OK", connection.getResponseMessage());
    TestUtil.checkLargeData(TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1553")
  public void testWriteLessThanContentLength() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    // Set a content length that's 1 byte more.
    connection.setRequestProperty("Content-Length",
                                  Integer.toString(TestUtil.UPLOAD_DATA.length + 1));
    OutputStream out = connection.getOutputStream();
    out.write(TestUtil.UPLOAD_DATA);
    try {
      connection.getResponseCode();
      fail();
    } catch (IOException e) {
      // Expected.
    }
    connection.disconnect();
  }

  /**
   * Tests that if caller writes more than the content length provided,
   * an exception should occur.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1553")
  public void testWriteMoreThanContentLength() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    // Use a content length that is 1 byte shorter than actual data.
    connection.setRequestProperty("Content-Length",
                                  Integer.toString(TestUtil.UPLOAD_DATA.length - 1));
    OutputStream out = connection.getOutputStream();
    // Write a few bytes first.
    out.write(TestUtil.UPLOAD_DATA, 0, 3);
    try {
      // Write remaining bytes.
      out.write(TestUtil.UPLOAD_DATA, 3, TestUtil.UPLOAD_DATA.length - 3);
      // On Lollipop, default implementation only triggers the error when reading response.
      connection.getInputStream();
      fail();
    } catch (IOException e) {
      assertEquals("exceeded content-length limit of " + (TestUtil.UPLOAD_DATA.length - 1) +
                       " bytes",
                   e.getMessage());
    }
    connection.disconnect();
  }

  /**
   * Same as {@code testWriteMoreThanContentLength()}, but it only writes one byte
   * at a time.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  @CompareDefaultWithCronet
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1553")
  public void testWriteMoreThanContentLengthWriteOneByte() throws Exception {
    URL url = new URL(NativeTestServer.getEchoBodyURL());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    // Use a content length that is 1 byte shorter than actual data.
    connection.setRequestProperty("Content-Length",
                                  Integer.toString(TestUtil.UPLOAD_DATA.length - 1));
    OutputStream out = connection.getOutputStream();
    try {
      for (int i = 0; i < TestUtil.UPLOAD_DATA.length; i++) {
        out.write(TestUtil.UPLOAD_DATA[i]);
      }
      // On Lollipop, default implementation only triggers the error when reading response.
      connection.getInputStream();
      fail();
    } catch (IOException e) {
      assertEquals("exceeded content-length limit of " + (TestUtil.UPLOAD_DATA.length - 1) +
                       " bytes",
                   e.getMessage());
    }
    connection.disconnect();
  }

  /**
   * Tests that {@link CronetBufferedOutputStream} supports rewind in a
   * POST preserving redirect.
   * Use {@code OnlyRunCronetHttpURLConnection} as the default implementation
   * does not pass this test.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  @OnlyRunCronetHttpURLConnection
  public void testRewind() throws Exception {
    URL url = new URL(NativeTestServer.getRedirectToEchoBody());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    connection.setRequestProperty("Content-Length", Integer.toString(TestUtil.UPLOAD_DATA.length));
    OutputStream out = connection.getOutputStream();
    out.write(TestUtil.UPLOAD_DATA);
    assertEquals(TestUtil.UPLOAD_DATA_STRING, TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }

  /**
   * Like {@link #testRewind} but does not set Content-Length header.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  @OnlyRunCronetHttpURLConnection
  public void testRewindWithoutContentLength() throws Exception {
    URL url = new URL(NativeTestServer.getRedirectToEchoBody());
    HttpURLConnection connection = (HttpURLConnection)url.openConnection();
    connection.setDoOutput(true);
    connection.setRequestMethod("POST");
    OutputStream out = connection.getOutputStream();
    out.write(TestUtil.UPLOAD_DATA);
    assertEquals(TestUtil.UPLOAD_DATA_STRING, TestUtil.getResponseAsString(connection));
    connection.disconnect();
  }
}
package org.chromium.net;

import static org.chromium.net.testing.CronetTestRule.getContext;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.CronetTestRule.CronetTestFramework;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.NativeTestServer;
import org.chromium.net.testing.TestUrlRequestCallback;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests that making a large number of requests do not lead to crashes.
 */
@RunWith(AndroidJUnit4.class)
public class CronetStressTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  private CronetTestFramework mTestFramework;

  @Before
  public void setUp() throws Exception {
    mTestFramework = mTestRule.startCronetTestFramework();
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
  }

  @After
  public void tearDown() throws Exception {
    NativeTestServer.shutdownNativeTestServer();
  }

  @Test
  @LargeTest
  @Feature({"Cronet"})
  public void testLargeNumberOfUploads() throws Exception {
    final int kNumRequest = 1000;
    final int kNumRequestHeaders = 100;
    final int kNumUploadBytes = 1000;
    final byte[] b = new byte[kNumUploadBytes];
    for (int i = 0; i < kNumRequest; i++) {
      TestUrlRequestCallback callback = new TestUrlRequestCallback();
      UrlRequest.Builder builder = mTestFramework.mCronetEngine.newUrlRequestBuilder(
          NativeTestServer.getEchoAllHeadersURL(), callback, callback.getExecutor());
      for (int j = 0; j < kNumRequestHeaders; j++) {
        builder.addHeader("header" + j, Integer.toString(j));
      }
      builder.addHeader("content-type", "useless/string");
      builder.setUploadDataProvider(UploadDataProviders.create(b, 0, kNumUploadBytes),
                                    callback.getExecutor());
      UrlRequest request = builder.build();
      request.start();
      callback.blockForDone();
      callback.shutdownExecutor();
      assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    }
  }
}
package org.chromium.net;

import static org.chromium.net.testing.CronetTestRule.getContext;
import static org.chromium.net.testing.CronetTestRule.getTestStorage;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.util.Arrays;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.FileUtils;
import org.chromium.net.testing.NativeTestServer;
import org.chromium.net.testing.PathUtils;
import org.chromium.net.testing.TestUrlRequestCallback;
import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Test CronetEngine disk storage.
 */
@Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1578")
@RunWith(AndroidJUnit4.class)
public class DiskStorageTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  private String mReadOnlyStoragePath;

  @Before
  public void setUp() throws Exception {
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
  }

  @After
  public void tearDown() throws Exception {
    if (mReadOnlyStoragePath != null) {
      FileUtils.recursivelyDeleteFile(new File(mReadOnlyStoragePath), FileUtils.DELETE_ALL);
    }
    NativeTestServer.shutdownNativeTestServer();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Crashing on Android Cronet Builder, see crbug.com/601409.
  public void testReadOnlyStorageDirectory() throws Exception {
    mReadOnlyStoragePath = PathUtils.getDataDirectory() + "/read_only";
    File readOnlyStorage = new File(mReadOnlyStoragePath);
    assertTrue(readOnlyStorage.mkdir());
    // Setting the storage directory as readonly has no effect.
    assertTrue(readOnlyStorage.setReadOnly());
    ExperimentalCronetEngine.Builder builder = new ExperimentalCronetEngine.Builder(getContext());
    builder.setStoragePath(mReadOnlyStoragePath);
    builder.enableHttpCache(CronetEngine.Builder.HTTP_CACHE_DISK, 1024 * 1024);

    CronetEngine cronetEngine = builder.build();
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    String url = NativeTestServer.getFileURL("/cacheable.txt");
    UrlRequest.Builder requestBuilder =
        cronetEngine.newUrlRequestBuilder(url, callback, callback.getExecutor());
    UrlRequest urlRequest = requestBuilder.build();
    urlRequest.start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    cronetEngine.shutdown();
    FileInputStream newVersionFile = null;
    // Make sure that version file is in readOnlyStoragePath.
    File versionFile = new File(mReadOnlyStoragePath + "/version");
    try {
      newVersionFile = new FileInputStream(versionFile);
      byte[] buffer = new byte[] {0, 0, 0, 0};
      int bytesRead = newVersionFile.read(buffer, 0, 4);
      assertEquals(4, bytesRead);
      assertTrue(Arrays.equals(new byte[] {1, 0, 0, 0}, buffer));
    } finally {
      if (newVersionFile != null) {
        newVersionFile.close();
      }
    }
    File diskCacheDir = new File(mReadOnlyStoragePath + "/disk_cache");
    assertTrue(diskCacheDir.exists());
    File prefsDir = new File(mReadOnlyStoragePath + "/prefs");
    assertTrue(prefsDir.exists());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Crashing on Android Cronet Builder, see crbug.com/601409.
  public void testPurgeOldVersion() throws Exception {
    String testStorage = getTestStorage();
    File versionFile = new File(testStorage + "/version");
    FileOutputStream versionOut = null;
    try {
      versionOut = new FileOutputStream(versionFile);
      versionOut.write(new byte[] {0, 0, 0, 0}, 0, 4);
    } finally {
      if (versionOut != null) {
        versionOut.close();
      }
    }
    File oldPrefsFile = new File(testStorage + "/local_prefs.json");
    FileOutputStream oldPrefsOut = null;
    try {
      oldPrefsOut = new FileOutputStream(oldPrefsFile);
      String dummy = "dummy content";
      oldPrefsOut.write(dummy.getBytes(), 0, dummy.length());
    } finally {
      if (oldPrefsOut != null) {
        oldPrefsOut.close();
      }
    }

    ExperimentalCronetEngine.Builder builder = new ExperimentalCronetEngine.Builder(getContext());
    builder.setStoragePath(getTestStorage());
    builder.enableHttpCache(CronetEngine.Builder.HTTP_CACHE_DISK, 1024 * 1024);

    CronetEngine cronetEngine = builder.build();
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    String url = NativeTestServer.getFileURL("/cacheable.txt");
    UrlRequest.Builder requestBuilder =
        cronetEngine.newUrlRequestBuilder(url, callback, callback.getExecutor());
    UrlRequest urlRequest = requestBuilder.build();
    urlRequest.start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    cronetEngine.shutdown();
    FileInputStream newVersionFile = null;
    try {
      newVersionFile = new FileInputStream(versionFile);
      byte[] buffer = new byte[] {0, 0, 0, 0};
      int bytesRead = newVersionFile.read(buffer, 0, 4);
      assertEquals(4, bytesRead);
      assertTrue(Arrays.equals(new byte[] {1, 0, 0, 0}, buffer));
    } finally {
      if (newVersionFile != null) {
        newVersionFile.close();
      }
    }
    oldPrefsFile = new File(testStorage + "/local_prefs.json");
    assertTrue(!oldPrefsFile.exists());
    File diskCacheDir = new File(testStorage + "/disk_cache");
    assertTrue(diskCacheDir.exists());
    File prefsDir = new File(testStorage + "/prefs");
    assertTrue(prefsDir.exists());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Tests that if cache version is current, Cronet does not purge the directory.
  public void testCacheVersionCurrent() throws Exception {
    // Initialize a CronetEngine and shut it down.
    ExperimentalCronetEngine.Builder builder = new ExperimentalCronetEngine.Builder(getContext());
    builder.setStoragePath(getTestStorage());
    builder.enableHttpCache(CronetEngine.Builder.HTTP_CACHE_DISK, 1024 * 1024);

    CronetEngine cronetEngine = builder.build();
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    String url = NativeTestServer.getFileURL("/cacheable.txt");
    UrlRequest.Builder requestBuilder =
        cronetEngine.newUrlRequestBuilder(url, callback, callback.getExecutor());
    UrlRequest urlRequest = requestBuilder.build();
    urlRequest.start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    cronetEngine.shutdown();

    // Create a dummy file in storage directory.
    String testStorage = getTestStorage();
    File dummyFile = new File(testStorage + "/dummy.json");
    FileOutputStream dummyFileOut = null;
    String dummyContent = "dummy content";
    try {
      dummyFileOut = new FileOutputStream(dummyFile);
      dummyFileOut.write(dummyContent.getBytes(), 0, dummyContent.length());
    } finally {
      if (dummyFileOut != null) {
        dummyFileOut.close();
      }
    }

    // Creates a new CronetEngine and make a request.
    CronetEngine engine = builder.build();
    TestUrlRequestCallback callback2 = new TestUrlRequestCallback();
    String url2 = NativeTestServer.getFileURL("/cacheable.txt");
    UrlRequest.Builder requestBuilder2 =
        engine.newUrlRequestBuilder(url2, callback2, callback2.getExecutor());
    UrlRequest urlRequest2 = requestBuilder2.build();
    urlRequest2.start();
    callback2.blockForDone();
    assertEquals(200, callback2.mResponseInfo.getHttpStatusCode());
    engine.shutdown();
    // Dummy file still exists.
    BufferedReader reader = new BufferedReader(new FileReader(dummyFile));
    StringBuilder stringBuilder = new StringBuilder();
    String line;
    while ((line = reader.readLine()) != null) {
      stringBuilder.append(line);
    }
    reader.close();
    assertEquals(dummyContent, stringBuilder.toString());
    File diskCacheDir = new File(testStorage + "/disk_cache");
    assertTrue(diskCacheDir.exists());
    File prefsDir = new File(testStorage + "/prefs");
    assertTrue(prefsDir.exists());
  }
}
package org.chromium.net;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import static org.chromium.net.testing.CronetTestRule.SERVER_CERT_PEM;
import static org.chromium.net.testing.CronetTestRule.SERVER_KEY_PKCS8_PEM;
import static org.chromium.net.testing.CronetTestRule.assertContains;
import static org.chromium.net.testing.CronetTestRule.getContext;

import android.os.ConditionVariable;
import android.os.Process;
import android.util.Log;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;

import org.chromium.net.impl.CronvoyBidirectionalStreamNetworkException;
import org.chromium.net.impl.CronvoyBidirectionalStream;
import org.chromium.net.impl.Errors.NetError;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.CronetTestUtil;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.Http2TestServer;
import org.chromium.net.testing.MetricsTestUtil;
import org.chromium.net.testing.TestBidirectionalStreamCallback;
import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import org.chromium.net.testing.CronetTestRule.RequiresMinApi;
import org.chromium.net.testing.MetricsTestUtil.TestRequestFinishedListener;
import org.chromium.net.testing.TestBidirectionalStreamCallback.FailureType;
import org.chromium.net.testing.TestBidirectionalStreamCallback.ResponseStep;
import org.chromium.net.impl.CronvoyUrlResponseInfoImpl;

import java.nio.ByteBuffer;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Test functionality of BidirectionalStream interface.
 */
@RunWith(AndroidJUnit4.class)
public class BidirectionalStreamTest {

  private static final String TAG = BidirectionalStreamTest.class.getSimpleName();

  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  private ExperimentalCronetEngine mCronetEngine;

  @Before
  public void setUp() throws Exception {
    ExperimentalCronetEngine.Builder builder = new ExperimentalCronetEngine.Builder(getContext());
    CronetTestUtil.setMockCertVerifierForTesting(builder);

    mCronetEngine = builder.build();
    assertTrue(
        Http2TestServer.startHttp2TestServer(getContext(), SERVER_CERT_PEM, SERVER_KEY_PKCS8_PEM));
  }

  @After
  public void tearDown() throws Exception {
    assertTrue(Http2TestServer.shutdownHttp2TestServer());
    if (mCronetEngine != null) {
      mCronetEngine.shutdown();
    }
  }

  private static void checkResponseInfo(UrlResponseInfo responseInfo, String expectedUrl,
                                        int expectedHttpStatusCode, String expectedHttpStatusText) {
    assertEquals(expectedUrl, responseInfo.getUrl());
    assertEquals(expectedUrl,
                 responseInfo.getUrlChain().get(responseInfo.getUrlChain().size() - 1));
    assertEquals(expectedHttpStatusCode, responseInfo.getHttpStatusCode());
    assertEquals(expectedHttpStatusText, responseInfo.getHttpStatusText());
    assertFalse(responseInfo.wasCached());
    assertTrue(responseInfo.toString().length() > 0);
  }

  private static String createLongString(String base, int repetition) {
    StringBuilder builder = new StringBuilder(base.length() * repetition);
    for (int i = 0; i < repetition; ++i) {
      builder.append(i);
      builder.append(base);
    }
    return builder.toString();
  }

  private static UrlResponseInfo createUrlResponseInfo(String[] urls, String message,
                                                       int statusCode, int receivedBytes,
                                                       String... headers) {
    ArrayList<Map.Entry<String, String>> headersList = new ArrayList<>();
    for (int i = 0; i < headers.length; i += 2) {
      headersList.add(
          new AbstractMap.SimpleImmutableEntry<String, String>(headers[i], headers[i + 1]));
    }
    CronvoyUrlResponseInfoImpl urlResponseInfo = new CronvoyUrlResponseInfoImpl(
        Arrays.asList(urls), statusCode, message, headersList, false, "h2", null, receivedBytes);
    return urlResponseInfo;
  }

  private void runSimpleGetWithExpectedReceivedByteCount(int expectedReceivedBytes)
      throws Exception {
    String url = Http2TestServer.getEchoMethodUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    TestRequestFinishedListener requestFinishedListener = new TestRequestFinishedListener();
    mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    // Create stream.
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
            .setHttpMethod("GET")
            .build();
    stream.start();
    callback.blockForDone();
    assertTrue(stream.isDone());
    requestFinishedListener.blockUntilDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    // Default method is 'GET'.
    assertEquals("GET", callback.mResponseAsString);
    UrlResponseInfo urlResponseInfo =
        createUrlResponseInfo(new String[] {url}, "", 200, expectedReceivedBytes, ":status", "200");
    mTestRule.assertResponseEquals(urlResponseInfo, callback.mResponseInfo);
    checkResponseInfo(callback.mResponseInfo, Http2TestServer.getEchoMethodUrl(), 200, "");
    RequestFinishedInfo finishedInfo = requestFinishedListener.getRequestInfo();
    assertTrue(finishedInfo.getAnnotations().isEmpty());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBuilderCheck() throws Exception {
    runBuilderCheckNativeImpl();
  }

  private void runBuilderCheckNativeImpl() throws Exception {
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    try {
      mCronetEngine.newBidirectionalStreamBuilder(null, callback, callback.getExecutor());
      fail("URL not null-checked");
    } catch (NullPointerException e) {
      assertEquals("URL is required.", e.getMessage());
    }
    try {
      mCronetEngine.newBidirectionalStreamBuilder(Http2TestServer.getServerUrl(), null,
                                                  callback.getExecutor());
      fail("Callback not null-checked");
    } catch (NullPointerException e) {
      assertEquals("Callback is required.", e.getMessage());
    }
    try {
      mCronetEngine.newBidirectionalStreamBuilder(Http2TestServer.getServerUrl(), callback, null);
      fail("Executor not null-checked");
    } catch (NullPointerException e) {
      assertEquals("Executor is required.", e.getMessage());
    }
    // Verify successful creation doesn't throw.
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getServerUrl(), callback, callback.getExecutor());
    try {
      builder.addHeader(null, "value");
      fail("Header name is not null-checked");
    } catch (NullPointerException e) {
      assertEquals("Invalid header name.", e.getMessage());
    }
    try {
      builder.addHeader("name", null);
      fail("Header value is not null-checked");
    } catch (NullPointerException e) {
      assertEquals("Invalid header value.", e.getMessage());
    }
    try {
      builder.setHttpMethod(null);
      fail("Method name is not null-checked");
    } catch (NullPointerException e) {
      assertEquals("Method is required.", e.getMessage());
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testFailPlainHttp() throws Exception {
    String url = "http://example.com";
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    // Create stream.
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor()).build();
    stream.start();
    callback.blockForDone();
    assertTrue(stream.isDone());
    assertContains("Exception in BidirectionalStream: net::ERR_DISALLOWED_URL_SCHEME",
                   callback.mError.getMessage());
    assertEquals(-301, ((NetworkException)callback.mError).getCronetInternalErrorCode());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("fix expected ReceivedByteCount - quite unpredictable")
  public void testSimpleGet() throws Exception {
    // Since this is the first request on the connection, the expected received bytes count
    // must account for an HPACK dynamic table size update.
    runSimpleGetWithExpectedReceivedByteCount(27);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("To be investigated - head does not work")
  public void testSimpleHead() throws Exception {
    String url = Http2TestServer.getEchoMethodUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    // Create stream.
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
            .setHttpMethod("HEAD")
            .build();
    stream.start();
    callback.blockForDone();
    assertTrue(stream.isDone());
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("HEAD", callback.mResponseAsString);
    UrlResponseInfo urlResponseInfo =
        createUrlResponseInfo(new String[] {url}, "", 200, 32, ":status", "200");
    mTestRule.assertResponseEquals(urlResponseInfo, callback.mResponseInfo);
    checkResponseInfo(callback.mResponseInfo, Http2TestServer.getEchoMethodUrl(), 200, "");
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testSimplePost() throws Exception {
    String url = Http2TestServer.getEchoStreamUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    callback.addWriteData("Test String".getBytes());
    callback.addWriteData("1234567890".getBytes());
    callback.addWriteData("woot!".getBytes());
    TestRequestFinishedListener requestFinishedListener = new TestRequestFinishedListener();
    mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    // Create stream.
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
            .addHeader("foo", "bar")
            .addHeader("empty", "")
            .addHeader("Content-Type", "zebra")
            .addRequestAnnotation(this)
            .addRequestAnnotation("request annotation")
            .build();
    Date startTime = new Date();
    stream.start();
    callback.blockForDone();
    assertTrue(stream.isDone());
    requestFinishedListener.blockUntilDone();
    Date endTime = new Date();
    RequestFinishedInfo finishedInfo = requestFinishedListener.getRequestInfo();
    MetricsTestUtil.checkRequestFinishedInfo(finishedInfo, url, startTime, endTime);
    assertEquals(RequestFinishedInfo.SUCCEEDED, finishedInfo.getFinishedReason());
    MetricsTestUtil.checkHasConnectTiming(finishedInfo.getMetrics(), startTime, endTime, true);
    assertThat(finishedInfo.getAnnotations()).containsExactly("request annotation", this);
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("Test String1234567890woot!", callback.mResponseAsString);
    assertEquals("bar", callback.mResponseInfo.getAllHeaders().get("echo-foo").get(0));
    assertEquals("", callback.mResponseInfo.getAllHeaders().get("echo-empty").get(0));
    assertEquals("zebra", callback.mResponseInfo.getAllHeaders().get("echo-content-type").get(0));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testSimpleGetWithCombinedHeader() throws Exception {
    String url = Http2TestServer.getCombinedHeadersUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    TestRequestFinishedListener requestFinishedListener = new TestRequestFinishedListener();
    mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    // Create stream.
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
            .setHttpMethod("GET")
            .build();
    stream.start();
    callback.blockForDone();
    assertTrue(stream.isDone());
    requestFinishedListener.blockUntilDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    // Default method is 'GET'.
    assertEquals("GET", callback.mResponseAsString);
    assertEquals("bar", callback.mResponseInfo.getAllHeaders().get("foo").get(0));
    assertEquals("bar2", callback.mResponseInfo.getAllHeaders().get("foo").get(1));
    RequestFinishedInfo finishedInfo = requestFinishedListener.getRequestInfo();
    assertTrue(finishedInfo.getAnnotations().isEmpty());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testSimplePostWithFlush() throws Exception {
    String url = Http2TestServer.getEchoStreamUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    callback.addWriteData("Test String".getBytes(), false);
    callback.addWriteData("1234567890".getBytes(), false);
    callback.addWriteData("woot!".getBytes(), true);
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
            .addHeader("foo", "bar")
            .addHeader("empty", "")
            .addHeader("Content-Type", "zebra")
            .build();
    // Flush before stream is started should not crash.
    stream.flush();

    stream.start();
    callback.blockForDone();
    assertTrue(stream.isDone());

    // Flush after stream is completed is no-op. It shouldn't call into the destroyed adapter.
    stream.flush();

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("Test String1234567890woot!", callback.mResponseAsString);
    assertEquals("bar", callback.mResponseInfo.getAllHeaders().get("echo-foo").get(0));
    assertEquals("", callback.mResponseInfo.getAllHeaders().get("echo-empty").get(0));
    assertEquals("zebra", callback.mResponseInfo.getAllHeaders().get("echo-content-type").get(0));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Tests that a delayed flush() only sends buffers that have been written
  // before it is called, and it doesn't flush buffers in mPendingQueue.
  public void testFlushData() throws Exception {
    String url = Http2TestServer.getEchoStreamUrl();
    final ConditionVariable waitOnStreamReady = new ConditionVariable();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback() {
      // Number of onWriteCompleted callbacks that have been invoked.
      private int mNumWriteCompleted;

      @Override
      public void onStreamReady(BidirectionalStream stream) {
        mResponseStep = ResponseStep.ON_STREAM_READY;
        waitOnStreamReady.open();
      }

      @Override
      public void onWriteCompleted(BidirectionalStream stream, UrlResponseInfo info,
                                   ByteBuffer buffer, boolean endOfStream) {
        super.onWriteCompleted(stream, info, buffer, endOfStream);
        mNumWriteCompleted++;
        if (mNumWriteCompleted <= 3) {
          // "6" is in pending queue.
          List<ByteBuffer> pendingData =
              ((CronvoyBidirectionalStream)stream).getPendingDataForTesting();
          assertEquals(1, pendingData.size());
          ByteBuffer pendingBuffer = pendingData.get(0);
          byte[] content = new byte[pendingBuffer.remaining()];
          pendingBuffer.get(content);
          assertTrue(Arrays.equals("6".getBytes(), content));

          // "4" and "5" have been flushed.
          assertEquals(0, ((CronvoyBidirectionalStream)stream).getFlushDataForTesting().size());
        } else if (mNumWriteCompleted == 5) {
          // Now flush "6", which is still in pending queue.
          List<ByteBuffer> pendingData =
              ((CronvoyBidirectionalStream)stream).getPendingDataForTesting();
          assertEquals(1, pendingData.size());
          ByteBuffer pendingBuffer = pendingData.get(0);
          byte[] content = new byte[pendingBuffer.remaining()];
          pendingBuffer.get(content);
          assertTrue(Arrays.equals("6".getBytes(), content));

          stream.flush();

          assertEquals(0, ((CronvoyBidirectionalStream)stream).getPendingDataForTesting().size());
          assertEquals(0, ((CronvoyBidirectionalStream)stream).getFlushDataForTesting().size());
        }
      }
    };
    callback.addWriteData("1".getBytes(), false);
    callback.addWriteData("2".getBytes(), false);
    callback.addWriteData("3".getBytes(), true);
    callback.addWriteData("4".getBytes(), false);
    callback.addWriteData("5".getBytes(), true);
    callback.addWriteData("6".getBytes(), false);
    CronvoyBidirectionalStream stream =
        (CronvoyBidirectionalStream)mCronetEngine
            .newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
            .addHeader("foo", "bar")
            .addHeader("empty", "")
            .addHeader("Content-Type", "zebra")
            .build();
    stream.start();
    waitOnStreamReady.block();

    assertEquals(0, stream.getPendingDataForTesting().size());
    assertEquals(0, stream.getFlushDataForTesting().size());

    // Write 1, 2, 3 and flush() - subsequent flush are performed by the onWriteCompleted callback.
    callback.startNextWrite(stream);

    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("123456", callback.mResponseAsString);
    assertEquals("bar", callback.mResponseInfo.getAllHeaders().get("echo-foo").get(0));
    assertEquals("", callback.mResponseInfo.getAllHeaders().get("echo-empty").get(0));
    assertEquals("zebra", callback.mResponseInfo.getAllHeaders().get("echo-content-type").get(0));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Regression test for crbug.com/692168.
  public void testCancelWhileWriteDataPending() throws Exception {
    String url = Http2TestServer.getEchoStreamUrl();
    // Use a direct executor to avoid race.
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback(
        /*useDirectExecutor*/ false) {
      @Override
      public void onStreamReady(BidirectionalStream stream) {
        // Start the first write.
        stream.write(getDummyData(), false);
        stream.flush();
      }

      @Override
      public void onReadCompleted(BidirectionalStream stream, UrlResponseInfo info,
                                  ByteBuffer byteBuffer, boolean endOfStream) {
        super.onReadCompleted(stream, info, byteBuffer, endOfStream);
        // Cancel now when the write side is busy.
        stream.cancel();
      }

      @Override
      public void onWriteCompleted(BidirectionalStream stream, UrlResponseInfo info,
                                   ByteBuffer buffer, boolean endOfStream) {
        // Flush twice to keep the flush queue non-empty.
        stream.write(getDummyData(), false);
        stream.flush();
        stream.write(getDummyData(), false);
        stream.flush();
      }

      // Returns a piece of dummy data to send to the server.
      private ByteBuffer getDummyData() {
        byte[] data = new byte[100];
        for (int i = 0; i < data.length; i++) {
          data[i] = 'x';
        }
        ByteBuffer dummyData = ByteBuffer.allocateDirect(data.length);
        dummyData.put(data);
        dummyData.flip();
        return dummyData;
      }
    };
    CronvoyBidirectionalStream stream =
        (CronvoyBidirectionalStream)mCronetEngine
            .newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
            .build();
    stream.start();
    callback.blockForDone();
    assertTrue(callback.mOnCanceledCalled);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testSimpleGetWithFlush() throws Exception {
    for (int i = 0; i < 2; i++) {
      String url = Http2TestServer.getEchoStreamUrl();
      TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback() {
        @Override
        public void onStreamReady(BidirectionalStream stream) {
          try {
            // Attempt to write data for GET request.
            stream.write(ByteBuffer.wrap("dummy".getBytes()), true);
          } catch (IllegalArgumentException e) {
            // Expected.
          }
          // If there are delayed headers, this flush should try to send them.
          // If nothing to flush, it should not crash.
          stream.flush();
          super.onStreamReady(stream);
          try {
            // Attempt to write data for GET request.
            stream.write(ByteBuffer.wrap("dummy".getBytes()), true);
          } catch (IllegalArgumentException e) {
            // Expected.
          }
        }
      };
      BidirectionalStream stream =
          mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
              .setHttpMethod("GET")
              .delayRequestHeadersUntilFirstFlush(i == 0)
              .addHeader("foo", "bar")
              .addHeader("empty", "")
              .build();
      // Flush before stream is started should not crash.
      stream.flush();

      stream.start();
      callback.blockForDone();
      assertTrue(stream.isDone());

      // Flush after stream is completed is no-op. It shouldn't call into the destroyed
      // adapter.
      stream.flush();

      assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
      assertEquals("", callback.mResponseAsString);
      assertEquals("bar", callback.mResponseInfo.getAllHeaders().get("echo-foo").get(0));
      assertEquals("", callback.mResponseInfo.getAllHeaders().get("echo-empty").get(0));
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testSimplePostWithFlushAfterOneWrite() throws Exception {
    for (int i = 0; i < 2; i++) {
      String url = Http2TestServer.getEchoStreamUrl();
      TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
      callback.addWriteData("Test String".getBytes(), true);
      BidirectionalStream stream =
          mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
              .delayRequestHeadersUntilFirstFlush(i == 0)
              .addHeader("foo", "bar")
              .addHeader("empty", "")
              .addHeader("Content-Type", "zebra")
              .build();
      stream.start();
      callback.blockForDone();
      assertTrue(stream.isDone());

      assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
      assertEquals("Test String", callback.mResponseAsString);
      assertEquals("bar", callback.mResponseInfo.getAllHeaders().get("echo-foo").get(0));
      assertEquals("", callback.mResponseInfo.getAllHeaders().get("echo-empty").get(0));
      assertEquals("zebra", callback.mResponseInfo.getAllHeaders().get("echo-content-type").get(0));
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testSimplePostWithFlushTwice() throws Exception {
    for (int i = 0; i < 2; i++) {
      String url = Http2TestServer.getEchoStreamUrl();
      TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
      callback.addWriteData("Test String".getBytes(), false);
      callback.addWriteData("1234567890".getBytes(), false);
      callback.addWriteData("woot!".getBytes(), true);
      callback.addWriteData("Test String".getBytes(), false);
      callback.addWriteData("1234567890".getBytes(), false);
      callback.addWriteData("woot!".getBytes(), true);
      BidirectionalStream stream =
          mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
              .delayRequestHeadersUntilFirstFlush(i == 0)
              .addHeader("foo", "bar")
              .addHeader("empty", "")
              .addHeader("Content-Type", "zebra")
              .build();
      stream.start();
      callback.blockForDone();
      assertTrue(stream.isDone());
      assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
      assertEquals("Test String1234567890woot!Test String1234567890woot!",
                   callback.mResponseAsString);
      assertEquals("bar", callback.mResponseInfo.getAllHeaders().get("echo-foo").get(0));
      assertEquals("", callback.mResponseInfo.getAllHeaders().get("echo-empty").get(0));
      assertEquals("zebra", callback.mResponseInfo.getAllHeaders().get("echo-content-type").get(0));
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Tests that it is legal to call read() in onStreamReady().
  public void testReadDuringOnStreamReady() throws Exception {
    String url = Http2TestServer.getEchoStreamUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback() {
      @Override
      public void onStreamReady(BidirectionalStream stream) {
        super.onStreamReady(stream);
        startNextRead(stream);
      }

      @Override
      public void onResponseHeadersReceived(BidirectionalStream stream, UrlResponseInfo info) {
        // Do nothing. Skip readng.
      }
    };
    callback.addWriteData("Test String".getBytes());
    callback.addWriteData("1234567890".getBytes());
    callback.addWriteData("woot!".getBytes());
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
            .addHeader("foo", "bar")
            .addHeader("empty", "")
            .addHeader("Content-Type", "zebra")
            .build();
    stream.start();
    callback.blockForDone();
    assertTrue(stream.isDone());
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("Test String1234567890woot!", callback.mResponseAsString);
    assertEquals("bar", callback.mResponseInfo.getAllHeaders().get("echo-foo").get(0));
    assertEquals("", callback.mResponseInfo.getAllHeaders().get("echo-empty").get(0));
    assertEquals("zebra", callback.mResponseInfo.getAllHeaders().get("echo-content-type").get(0));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Tests that it is legal to call flush() when previous nativeWritevData has
  // yet to complete.
  public void testSimplePostWithFlushBeforePreviousWriteCompleted() throws Exception {
    String url = Http2TestServer.getEchoStreamUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback() {
      @Override
      public void onStreamReady(BidirectionalStream stream) {
        super.onStreamReady(stream);
        // Write a second time before the previous nativeWritevData has completed.
        startNextWrite(stream);
        assertEquals(0, numPendingWrites());
      }
    };
    callback.addWriteData("Test String".getBytes(), false);
    callback.addWriteData("1234567890".getBytes(), false);
    callback.addWriteData("woot!".getBytes(), true);
    callback.addWriteData("Test String".getBytes(), false);
    callback.addWriteData("1234567890".getBytes(), false);
    callback.addWriteData("woot!".getBytes(), true);
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
            .addHeader("foo", "bar")
            .addHeader("empty", "")
            .addHeader("Content-Type", "zebra")
            .build();
    stream.start();
    callback.blockForDone();
    assertTrue(stream.isDone());
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("Test String1234567890woot!Test String1234567890woot!",
                 callback.mResponseAsString);
    assertEquals("bar", callback.mResponseInfo.getAllHeaders().get("echo-foo").get(0));
    assertEquals("", callback.mResponseInfo.getAllHeaders().get("echo-empty").get(0));
    assertEquals("zebra", callback.mResponseInfo.getAllHeaders().get("echo-content-type").get(0));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testSimplePut() throws Exception {
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    callback.addWriteData("Put This Data!".getBytes());
    String methodName = "PUT";
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getServerUrl(), callback, callback.getExecutor());
    builder.setHttpMethod(methodName);
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("Put This Data!", callback.mResponseAsString);
    assertEquals(methodName, callback.mResponseInfo.getAllHeaders().get("echo-method").get(0));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBadMethod() throws Exception {
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getServerUrl(), callback, callback.getExecutor());
    try {
      builder.setHttpMethod("bad:method!");
      builder.build().start();
      fail("IllegalArgumentException not thrown.");
    } catch (IllegalArgumentException e) {
      assertEquals("Invalid http method bad:method!", e.getMessage());
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBadHeaderName() throws Exception {
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getServerUrl(), callback, callback.getExecutor());
    try {
      builder.addHeader("goodheader1", "headervalue");
      builder.addHeader("header:name", "headervalue");
      builder.addHeader("goodheader2", "headervalue");
      builder.build().start();
      fail("IllegalArgumentException not thrown.");
    } catch (IllegalArgumentException e) {
      assertEquals("Invalid header header:name=headervalue", e.getMessage());
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBadHeaderValue() throws Exception {
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getServerUrl(), callback, callback.getExecutor());
    try {
      builder.addHeader("headername", "bad header\r\nvalue");
      builder.build().start();
      fail("IllegalArgumentException not thrown.");
    } catch (IllegalArgumentException e) {
      assertEquals("Invalid header headername=bad header\r\nvalue", e.getMessage());
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testAddHeader() throws Exception {
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    String headerName = "header-name";
    String headerValue = "header-value";
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoHeaderUrl(headerName), callback, callback.getExecutor());
    builder.addHeader(headerName, headerValue);
    builder.setHttpMethod("GET");
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(headerValue, callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Cronet does not support multi-headers - EM does")
  public void testMultiRequestHeaders() throws Exception {
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    String headerName = "header-name";
    String headerValue1 = "header-value1";
    String headerValue2 = "header-value2";
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoAllHeadersUrl(), callback, callback.getExecutor());
    builder.addHeader(headerName, headerValue1);
    builder.addHeader(headerName, headerValue2);
    builder.setHttpMethod("GET");
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    String headers = callback.mResponseAsString;
    Pattern pattern = Pattern.compile(headerName + ":\\s(.*)\\r\\n");
    Matcher matcher = pattern.matcher(headers);
    List<String> actualValues = new ArrayList<String>();
    while (matcher.find()) {
      actualValues.add(matcher.group(1));
    }
    assertEquals(1, actualValues.size());
    assertEquals("header-value2", actualValues.get(0));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("okhttp returns :status as a header")
  public void testEchoTrailers() throws Exception {
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    String headerName = "header-name";
    String headerValue = "header-value";
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoTrailersUrl(), callback, callback.getExecutor());
    builder.addHeader(headerName, headerValue);
    builder.setHttpMethod("GET");
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertNotNull(callback.mTrailers);
    // Verify that header value is properly echoed in trailers.
    assertEquals(headerValue, callback.mTrailers.getAsMap().get("echo-" + headerName).get(0));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testCustomUserAgent() throws Exception {
    String userAgentName = "User-Agent";
    String userAgentValue = "User-Agent-Value";
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoHeaderUrl(userAgentName), callback, callback.getExecutor());
    builder.setHttpMethod("GET");
    builder.addHeader(userAgentName, userAgentValue);
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(userAgentValue, callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testCustomCronetEngineUserAgent() throws Exception {
    String userAgentName = "User-Agent";
    String userAgentValue = "User-Agent-Value";
    ExperimentalCronetEngine.Builder engineBuilder =
        new ExperimentalCronetEngine.Builder(getContext());
    engineBuilder.setUserAgent(userAgentValue);
    CronetTestUtil.setMockCertVerifierForTesting(engineBuilder);
    ExperimentalCronetEngine engine = engineBuilder.build();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    BidirectionalStream.Builder builder = engine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoHeaderUrl(userAgentName), callback, callback.getExecutor());
    builder.setHttpMethod("GET");
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(userAgentValue, callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testDefaultUserAgent() throws Exception {
    String userAgentName = "User-Agent";
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoHeaderUrl(userAgentName), callback, callback.getExecutor());
    builder.setHttpMethod("GET");
    builder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(new CronetEngine.Builder(getContext()).getDefaultUserAgent(),
                 callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testEchoStream() throws Exception {
    String url = Http2TestServer.getEchoStreamUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    String[] testData = {"Test String", createLongString("1234567890", 50000), "woot!"};
    StringBuilder stringData = new StringBuilder();
    for (String writeData : testData) {
      callback.addWriteData(writeData.getBytes());
      stringData.append(writeData);
    }
    // Create stream.
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
            .addHeader("foo", "Value with Spaces")
            .addHeader("Content-Type", "zebra")
            .build();
    stream.start();
    callback.blockForDone();
    assertTrue(stream.isDone());
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(stringData.toString(), callback.mResponseAsString);
    assertEquals("Value with Spaces",
                 callback.mResponseInfo.getAllHeaders().get("echo-foo").get(0));
    assertEquals("zebra", callback.mResponseInfo.getAllHeaders().get("echo-content-type").get(0));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testEchoStreamEmptyWrite() throws Exception {
    String url = Http2TestServer.getEchoStreamUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    callback.addWriteData(new byte[0]);
    // Create stream.
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor()).build();
    stream.start();
    callback.blockForDone();
    assertTrue(stream.isDone());
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testDoubleWrite() throws Exception {
    String url = Http2TestServer.getEchoStreamUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback() {
      @Override
      public void onStreamReady(BidirectionalStream stream) {
        // super class will call Write() once.
        super.onStreamReady(stream);
        // Call Write() again.
        startNextWrite(stream);
        // Make sure there is no pending write.
        assertEquals(0, numPendingWrites());
      }
    };
    callback.addWriteData("1".getBytes());
    callback.addWriteData("2".getBytes());
    // Create stream.
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor()).build();
    stream.start();
    callback.blockForDone();
    assertTrue(stream.isDone());
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("12", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testDoubleRead() throws Exception {
    String url = Http2TestServer.getEchoStreamUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback() {
      @Override
      public void onResponseHeadersReceived(BidirectionalStream stream, UrlResponseInfo info) {
        startNextRead(stream);
        try {
          // Second read from callback invoked on single-threaded executor throws
          // an exception because previous read is still pending until its completion
          // is handled on executor.
          stream.read(ByteBuffer.allocateDirect(5));
          fail("Exception is not thrown.");
        } catch (Exception e) {
          assertEquals("Unexpected read attempt.", e.getMessage());
        }
      }
    };
    callback.addWriteData("1".getBytes());
    callback.addWriteData("2".getBytes());
    // Create stream.
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor()).build();
    stream.start();
    callback.blockForDone();
    assertTrue(stream.isDone());
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("12", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Disabled due to timeout. See crbug.com/591112")
  public void testReadAndWrite() throws Exception {
    String url = Http2TestServer.getEchoStreamUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback() {
      @Override
      public void onResponseHeadersReceived(BidirectionalStream stream, UrlResponseInfo info) {
        // Start the write, that will not complete until callback completion.
        startNextWrite(stream);
        // Start the read. It is allowed with write in flight.
        super.onResponseHeadersReceived(stream, info);
      }
    };
    callback.setAutoAdvance(false);
    callback.addWriteData("1".getBytes());
    callback.addWriteData("2".getBytes());
    // Create stream.
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor()).build();
    stream.start();
    callback.waitForNextWriteStep();
    callback.waitForNextReadStep();
    callback.startNextRead(stream);
    callback.setAutoAdvance(true);
    callback.blockForDone();
    assertTrue(stream.isDone());
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("12", callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testEchoStreamWriteFirst() throws Exception {
    String url = Http2TestServer.getEchoStreamUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    callback.setAutoAdvance(false);
    String[] testData = {"a", "bb", "ccc", "Test String", "1234567890", "woot!"};
    StringBuilder stringData = new StringBuilder();
    for (String writeData : testData) {
      callback.addWriteData(writeData.getBytes());
      stringData.append(writeData);
    }
    // Create stream.
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor()).build();
    stream.start();
    // Write first.
    callback.waitForNextWriteStep(); // onStreamReady
    for (String expected : testData) {
      // Write next chunk of test data.
      callback.startNextWrite(stream);
      callback.waitForNextWriteStep(); // onWriteCompleted
    }

    // Wait for read step, but don't read yet.
    callback.waitForNextReadStep(); // onResponseHeadersReceived
    assertEquals("", callback.mResponseAsString);
    // Read back.
    callback.startNextRead(stream);
    callback.waitForNextReadStep(); // onReadCompleted
    // Verify that some part of proper response is read.
    assertTrue(callback.mResponseAsString.startsWith(testData[0]));
    assertTrue(stringData.toString().startsWith(callback.mResponseAsString));
    // Read the rest of the response.
    callback.setAutoAdvance(true);
    callback.startNextRead(stream);
    callback.blockForDone();
    assertTrue(stream.isDone());
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(stringData.toString(), callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testEchoStreamStepByStep() throws Exception {
    String url = Http2TestServer.getEchoStreamUrl();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    callback.setAutoAdvance(false);
    String[] testData = {"a", "bb", "ccc", "Test String", "1234567890", "woot!"};
    StringBuilder stringData = new StringBuilder();
    for (String writeData : testData) {
      callback.addWriteData(writeData.getBytes());
      stringData.append(writeData);
    }
    // Create stream.
    BidirectionalStream stream =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor()).build();
    stream.start();
    callback.waitForNextWriteStep();
    callback.waitForNextReadStep();

    for (String expected : testData) {
      // Write next chunk of test data.
      callback.startNextWrite(stream);
      callback.waitForNextWriteStep();

      // Read next chunk of test data.
      ByteBuffer readBuffer = ByteBuffer.allocateDirect(100);
      callback.startNextRead(stream, readBuffer);
      callback.waitForNextReadStep();
      assertEquals(expected.length(), readBuffer.position());
      assertFalse(stream.isDone());
    }

    callback.setAutoAdvance(true);
    callback.startNextRead(stream);
    callback.blockForDone();
    assertTrue(stream.isDone());
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals(stringData.toString(), callback.mResponseAsString);
  }

  /**
   * Checks that the buffer is updated correctly, when starting at an offset.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testSimpleGetBufferUpdates() throws Exception {
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    callback.setAutoAdvance(false);
    // Since the method is "GET", the expected response body is also "GET".
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoMethodUrl(), callback, callback.getExecutor());
    BidirectionalStream stream = builder.setHttpMethod("GET").build();
    stream.start();
    callback.waitForNextReadStep();

    assertEquals(null, callback.mError);
    assertFalse(callback.isDone());
    assertEquals(TestBidirectionalStreamCallback.ResponseStep.ON_RESPONSE_STARTED,
                 callback.mResponseStep);

    ByteBuffer readBuffer = ByteBuffer.allocateDirect(5);
    readBuffer.put("FOR".getBytes());
    assertEquals(3, readBuffer.position());

    // Read first two characters of the response ("GE"). It's theoretically
    // possible to need one read per character, though in practice,
    // shouldn't happen.
    while (callback.mResponseAsString.length() < 2) {
      assertFalse(callback.isDone());
      callback.startNextRead(stream, readBuffer);
      callback.waitForNextReadStep();
    }

    // Make sure the two characters were read.
    assertEquals("GE", callback.mResponseAsString);

    // Check the contents of the entire buffer. The first 3 characters
    // should not have been changed, and the last two should be the first
    // two characters from the response.
    assertEquals("FORGE", bufferContentsToString(readBuffer, 0, 5));
    // The limit and position should be 5.
    assertEquals(5, readBuffer.limit());
    assertEquals(5, readBuffer.position());

    assertEquals(ResponseStep.ON_READ_COMPLETED, callback.mResponseStep);

    // Start reading from position 3. Since the only remaining character
    // from the response is a "T", when the read completes, the buffer
    // should contain "FORTE", with a position() of 4 and a limit() of 5.
    readBuffer.position(3);
    callback.startNextRead(stream, readBuffer);
    callback.waitForNextReadStep();

    // Make sure all three characters of the response have now been read.
    assertEquals("GET", callback.mResponseAsString);

    // Check the entire contents of the buffer. Only the third character
    // should have been modified.
    assertEquals("FORTE", bufferContentsToString(readBuffer, 0, 5));

    // Make sure position and limit were updated correctly.
    assertEquals(4, readBuffer.position());
    assertEquals(5, readBuffer.limit());

    assertEquals(ResponseStep.ON_READ_COMPLETED, callback.mResponseStep);

    // One more read attempt. The request should complete.
    readBuffer.position(1);
    readBuffer.limit(5);
    callback.setAutoAdvance(true);
    callback.startNextRead(stream, readBuffer);
    callback.blockForDone();

    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("GET", callback.mResponseAsString);
    checkResponseInfo(callback.mResponseInfo, Http2TestServer.getEchoMethodUrl(), 200, "");

    // Check that buffer contents were not modified.
    assertEquals("FORTE", bufferContentsToString(readBuffer, 0, 5));

    // Position should not have been modified, since nothing was read.
    assertEquals(1, readBuffer.position());
    // Limit should be unchanged as always.
    assertEquals(5, readBuffer.limit());

    assertEquals(ResponseStep.ON_SUCCEEDED, callback.mResponseStep);

    // Make sure there are no other pending messages, which would trigger
    // asserts in TestBidirectionalCallback.
    // The expected received bytes count is lower than it would be for the first request on the
    // connection, because the server includes an HPACK dynamic table size update only in the
    // first response HEADERS frame.
    // TODO(https://github.com/envoyproxy/envoy-mobile/issues/2265): fix expected ReceivedByteCount
    // runSimpleGetWithExpectedReceivedByteCount(27);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBadBuffers() throws Exception {
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    callback.setAutoAdvance(false);
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoMethodUrl(), callback, callback.getExecutor());
    BidirectionalStream stream = builder.setHttpMethod("GET").build();
    stream.start();
    callback.waitForNextReadStep();

    assertEquals(null, callback.mError);
    assertFalse(callback.isDone());
    assertEquals(TestBidirectionalStreamCallback.ResponseStep.ON_RESPONSE_STARTED,
                 callback.mResponseStep);

    // Try to read using a full buffer.
    try {
      ByteBuffer readBuffer = ByteBuffer.allocateDirect(4);
      readBuffer.put("full".getBytes());
      stream.read(readBuffer);
      fail("Exception not thrown");
    } catch (IllegalArgumentException e) {
      assertEquals("ByteBuffer is already full.", e.getMessage());
    }

    // Try to read using a non-direct buffer.
    try {
      ByteBuffer readBuffer = ByteBuffer.allocate(5);
      stream.read(readBuffer);
      fail("Exception not thrown");
    } catch (Exception e) {
      assertEquals("byteBuffer must be a direct ByteBuffer.", e.getMessage());
    }

    // Finish the stream with a direct ByteBuffer.
    callback.setAutoAdvance(true);
    ByteBuffer readBuffer = ByteBuffer.allocateDirect(5);
    stream.read(readBuffer);
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertEquals("GET", callback.mResponseAsString);
  }

  private void throwOrCancel(FailureType failureType, ResponseStep failureStep,
                             boolean expectError) {
    // Use a fresh CronetEngine each time so Http2 session is not reused.
    ExperimentalCronetEngine.Builder builder = new ExperimentalCronetEngine.Builder(getContext());
    CronetTestUtil.setMockCertVerifierForTesting(builder);
    mCronetEngine = builder.build();
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    callback.setFailure(failureType, failureStep);
    TestRequestFinishedListener requestFinishedListener = new TestRequestFinishedListener();
    mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    BidirectionalStream.Builder streamBuilder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoMethodUrl(), callback, callback.getExecutor());
    BidirectionalStream stream = streamBuilder.setHttpMethod("GET").build();
    Date startTime = new Date();
    stream.start();
    callback.blockForDone();
    assertTrue(stream.isDone());
    requestFinishedListener.blockUntilDone();
    Date endTime = new Date();
    RequestFinishedInfo finishedInfo = requestFinishedListener.getRequestInfo();
    RequestFinishedInfo.Metrics metrics = finishedInfo.getMetrics();
    assertNotNull(metrics);
    // Cancellation when stream is ready does not guarantee that
    // mResponseInfo is null because there might be a
    // onResponseHeadersReceived already queued in the executor.
    // See crbug.com/594432.
    if (failureStep != ResponseStep.ON_STREAM_READY) {
      assertNotNull(callback.mResponseInfo);
    }
    // Check metrics information.
    if (failureStep == ResponseStep.ON_RESPONSE_STARTED ||
        failureStep == ResponseStep.ON_READ_COMPLETED || failureStep == ResponseStep.ON_TRAILERS) {
      // For steps after response headers are received, there will be
      // connect timing metrics.
      // TODO(https://github.com/envoyproxy/envoy-mobile/issues/2192): flaky.
      MetricsTestUtil.checkTimingMetrics(metrics, startTime, endTime);
      // TODO(https://github.com/envoyproxy/envoy-mobile/issues/2192): flaky.
      MetricsTestUtil.checkHasConnectTiming(metrics, startTime, endTime, true);
      assertTrue(metrics.getSentByteCount() > 0);
      assertTrue(metrics.getReceivedByteCount() > 0);
    } else if (failureStep == ResponseStep.ON_STREAM_READY) {
      assertNotNull(metrics.getRequestStart());
      MetricsTestUtil.assertAfter(metrics.getRequestStart(), startTime);
      assertNotNull(metrics.getRequestEnd());
      MetricsTestUtil.assertAfter(endTime, metrics.getRequestEnd());
      MetricsTestUtil.assertAfter(metrics.getRequestEnd(), metrics.getRequestStart());
    }
    assertEquals(expectError, callback.mError != null);
    assertEquals(expectError, callback.mOnErrorCalled);
    if (expectError) {
      assertNotNull(finishedInfo.getException());
      assertEquals(RequestFinishedInfo.FAILED, finishedInfo.getFinishedReason());
    } else {
      assertNull(finishedInfo.getException());
      assertEquals(RequestFinishedInfo.CANCELED, finishedInfo.getFinishedReason());
    }
    assertEquals(failureType == FailureType.CANCEL_SYNC ||
                     failureType == FailureType.CANCEL_ASYNC ||
                     failureType == FailureType.CANCEL_ASYNC_WITHOUT_PAUSE,
                 callback.mOnCanceledCalled);
    mCronetEngine.removeRequestFinishedListener(requestFinishedListener);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Flaky: crashes EM")
  public void testFailures() throws Exception {
    // TODO(https://github.com/envoyproxy/envoy-mobile/issues/2192): start/end time are not set.
    //  throwOrCancel(FailureType.CANCEL_SYNC, ResponseStep.ON_STREAM_READY, false);
    //  throwOrCancel(FailureType.CANCEL_ASYNC, ResponseStep.ON_STREAM_READY, false);
    //  throwOrCancel(FailureType.CANCEL_ASYNC_WITHOUT_PAUSE, ResponseStep.ON_STREAM_READY, false);
    //  throwOrCancel(FailureType.THROW_SYNC, ResponseStep.ON_STREAM_READY, true);

    // TODO(https://github.com/envoyproxy/envoy-mobile/issues/2192): start/end time are flaky.
    throwOrCancel(FailureType.CANCEL_SYNC, ResponseStep.ON_RESPONSE_STARTED, false);
    throwOrCancel(FailureType.CANCEL_ASYNC, ResponseStep.ON_RESPONSE_STARTED, false);
    throwOrCancel(FailureType.CANCEL_ASYNC_WITHOUT_PAUSE, ResponseStep.ON_RESPONSE_STARTED, false);
    throwOrCancel(FailureType.THROW_SYNC, ResponseStep.ON_RESPONSE_STARTED, true);

    throwOrCancel(FailureType.CANCEL_SYNC, ResponseStep.ON_READ_COMPLETED, false);
    throwOrCancel(FailureType.CANCEL_ASYNC, ResponseStep.ON_READ_COMPLETED, false);
    throwOrCancel(FailureType.CANCEL_ASYNC_WITHOUT_PAUSE, ResponseStep.ON_READ_COMPLETED, false);
    throwOrCancel(FailureType.THROW_SYNC, ResponseStep.ON_READ_COMPLETED, true);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testThrowOnSucceeded() {
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    callback.setFailure(FailureType.THROW_SYNC, ResponseStep.ON_SUCCEEDED);
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoMethodUrl(), callback, callback.getExecutor());
    BidirectionalStream stream = builder.setHttpMethod("GET").build();
    stream.start();
    callback.blockForDone();
    assertEquals(callback.mResponseStep, ResponseStep.ON_SUCCEEDED);
    assertTrue(stream.isDone());
    assertNotNull(callback.mResponseInfo);
    // Check that error thrown from 'onSucceeded' callback is not reported.
    assertNull(callback.mError);
    assertFalse(callback.mOnErrorCalled);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testExecutorShutdownBeforeStreamIsDone() {
    // Test that stream is destroyed even if executor is shut down and rejects posting tasks.
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    callback.setAutoAdvance(false);
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoMethodUrl(), callback, callback.getExecutor());
    CronvoyBidirectionalStream stream =
        (CronvoyBidirectionalStream)builder.setHttpMethod("GET").build();
    stream.start();
    callback.waitForNextReadStep();
    assertFalse(callback.isDone());
    assertFalse(stream.isDone());

    final ConditionVariable streamDestroyed = new ConditionVariable(false);
    stream.setOnDestroyedCallbackForTesting(new Runnable() {
      @Override
      public void run() {
        streamDestroyed.open();
      }
    });

    // Shut down the executor, so posting the task will throw an exception.
    callback.shutdownExecutor();
    ByteBuffer readBuffer = ByteBuffer.allocateDirect(5);
    stream.read(readBuffer);
    // Callback will never be called again because executor is shut down,
    // but stream will be destroyed from network thread.
    streamDestroyed.block();

    assertFalse(callback.isDone());
    assertTrue(stream.isDone());
  }

  /**
   * Callback that shuts down the engine when the stream has succeeded
   * or failed.
   */
  private class ShutdownTestBidirectionalStreamCallback extends TestBidirectionalStreamCallback {
    @Override
    public void onSucceeded(BidirectionalStream stream, UrlResponseInfo info) {
      mCronetEngine.shutdown();
      // Clear mCronetEngine so it doesn't get shut down second time in tearDown().
      mCronetEngine = null;
      super.onSucceeded(stream, info);
    }

    @Override
    public void onFailed(BidirectionalStream stream, UrlResponseInfo info, CronetException error) {
      mCronetEngine.shutdown();
      // Clear mCronetEngine so it doesn't get shut down second time in tearDown().
      mCronetEngine = null;
      super.onFailed(stream, info, error);
    }

    @Override
    public void onCanceled(BidirectionalStream stream, UrlResponseInfo info) {
      mCronetEngine.shutdown();
      // Clear mCronetEngine so it doesn't get shut down second time in tearDown().
      mCronetEngine = null;
      super.onCanceled(stream, info);
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testCronetEngineShutdown() throws Exception {
    // Test that CronetEngine cannot be shut down if there are any active streams.
    TestBidirectionalStreamCallback callback = new ShutdownTestBidirectionalStreamCallback();
    // Block callback when response starts to verify that shutdown fails
    // if there are active streams.
    callback.setAutoAdvance(false);
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoMethodUrl(), callback, callback.getExecutor());
    CronvoyBidirectionalStream stream =
        (CronvoyBidirectionalStream)builder.setHttpMethod("GET").build();
    stream.start();
    try {
      mCronetEngine.shutdown();
      fail("Should throw an exception");
    } catch (Exception e) {
      assertEquals("Cannot shutdown with active requests.", e.getMessage());
    }

    callback.waitForNextReadStep();
    assertEquals(ResponseStep.ON_RESPONSE_STARTED, callback.mResponseStep);
    try {
      mCronetEngine.shutdown();
      fail("Should throw an exception");
    } catch (Exception e) {
      assertEquals("Cannot shutdown with active requests.", e.getMessage());
    }
    callback.startNextRead(stream);

    callback.waitForNextReadStep();
    assertEquals(ResponseStep.ON_READ_COMPLETED, callback.mResponseStep);
    try {
      mCronetEngine.shutdown();
      fail("Should throw an exception");
    } catch (Exception e) {
      assertEquals("Cannot shutdown with active requests.", e.getMessage());
    }

    // May not have read all the data, in theory. Just enable auto-advance
    // and finish the request.
    callback.setAutoAdvance(true);
    callback.startNextRead(stream);
    callback.blockForDone();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testCronetEngineShutdownAfterStreamFailure() throws Exception {
    // Test that CronetEngine can be shut down after stream reports a failure.
    TestBidirectionalStreamCallback callback = new ShutdownTestBidirectionalStreamCallback();
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoMethodUrl(), callback, callback.getExecutor());
    CronvoyBidirectionalStream stream =
        (CronvoyBidirectionalStream)builder.setHttpMethod("GET").build();
    stream.start();
    callback.setFailure(FailureType.THROW_SYNC, ResponseStep.ON_READ_COMPLETED);
    callback.blockForDone();
    assertTrue(callback.mOnErrorCalled);
    assertNull(mCronetEngine);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testCronetEngineShutdownAfterStreamCancel() throws Exception {
    // Test that CronetEngine can be shut down after stream is canceled.
    TestBidirectionalStreamCallback callback = new ShutdownTestBidirectionalStreamCallback();
    BidirectionalStream.Builder builder = mCronetEngine.newBidirectionalStreamBuilder(
        Http2TestServer.getEchoMethodUrl(), callback, callback.getExecutor());
    CronvoyBidirectionalStream stream =
        (CronvoyBidirectionalStream)builder.setHttpMethod("GET").build();

    // Block callback when response starts to verify that shutdown fails
    // if there are active requests.
    callback.setAutoAdvance(false);
    stream.start();
    try {
      mCronetEngine.shutdown();
      fail("Should throw an exception");
    } catch (Exception e) {
      assertEquals("Cannot shutdown with active requests.", e.getMessage());
    }
    callback.waitForNextReadStep();
    assertEquals(ResponseStep.ON_RESPONSE_STARTED, callback.mResponseStep);
    stream.cancel();
    callback.blockForDone();
    assertTrue(callback.mOnCanceledCalled);
    assertNull(mCronetEngine);
  }

  /*
   * Verifies NetworkException constructed from specific error codes are retryable.
   */
  @SmallTest
  @Feature({"Cronet"})
  @Test
  public void testErrorCodes() throws Exception {
    // Non-BidirectionalStream specific error codes.
    checkSpecificErrorCode(NetError.ERR_NAME_NOT_RESOLVED,
                           NetworkException.ERROR_HOSTNAME_NOT_RESOLVED, false);
    checkSpecificErrorCode(NetError.ERR_INTERNET_DISCONNECTED,
                           NetworkException.ERROR_INTERNET_DISCONNECTED, false);
    checkSpecificErrorCode(NetError.ERR_NETWORK_CHANGED, NetworkException.ERROR_NETWORK_CHANGED,
                           true);
    checkSpecificErrorCode(NetError.ERR_CONNECTION_CLOSED, NetworkException.ERROR_CONNECTION_CLOSED,
                           true);
    checkSpecificErrorCode(NetError.ERR_CONNECTION_REFUSED,
                           NetworkException.ERROR_CONNECTION_REFUSED, false);
    checkSpecificErrorCode(NetError.ERR_CONNECTION_RESET, NetworkException.ERROR_CONNECTION_RESET,
                           true);
    checkSpecificErrorCode(NetError.ERR_CONNECTION_TIMED_OUT,
                           NetworkException.ERROR_CONNECTION_TIMED_OUT, true);
    checkSpecificErrorCode(NetError.ERR_TIMED_OUT, NetworkException.ERROR_TIMED_OUT, true);
    checkSpecificErrorCode(NetError.ERR_ADDRESS_UNREACHABLE,
                           NetworkException.ERROR_ADDRESS_UNREACHABLE, false);

    // BidirectionalStream specific retryable error codes.
    checkSpecificErrorCode(NetError.ERR_HTTP2_PING_FAILED, NetworkException.ERROR_OTHER, true);
    checkSpecificErrorCode(NetError.ERR_QUIC_HANDSHAKE_FAILED, NetworkException.ERROR_OTHER, true);
  }

  // Returns the contents of byteBuffer, from its position() to its limit(),
  // as a String. Does not modify byteBuffer's position().
  private static String bufferContentsToString(ByteBuffer byteBuffer, int start, int end) {
    // Use a duplicate to avoid modifying byteBuffer.
    ByteBuffer duplicate = byteBuffer.duplicate();
    duplicate.position(start);
    duplicate.limit(end);
    byte[] contents = new byte[duplicate.remaining()];
    duplicate.get(contents);
    return new String(contents);
  }

  private static void checkSpecificErrorCode(NetError netError, int errorCode,
                                             boolean immediatelyRetryable) throws Exception {
    NetworkException exception =
        new CronvoyBidirectionalStreamNetworkException("", errorCode, netError.getErrorCode());
    assertEquals(immediatelyRetryable, exception.immediatelyRetryable());
    assertEquals(netError.getErrorCode(), exception.getCronetInternalErrorCode());
    assertEquals(errorCode, exception.getErrorCode());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @RequiresMinApi(10) // Tagging support added in API level 10: crrev.com/c/chromium/src/+/937583
  @Ignore("https://github.com/envoyproxy/envoy-mobile/issues/1521")
  public void testTagging() throws Exception {
    if (!CronetTestUtil.nativeCanGetTaggedBytes()) {
      Log.i(TAG, "Skipping test - GetTaggedBytes unsupported.");
      return;
    }
    String url = Http2TestServer.getEchoStreamUrl();

    // Test untagged requests are given tag 0.
    int tag = 0;
    long priorBytes = CronetTestUtil.nativeGetTaggedBytes(tag);
    TestBidirectionalStreamCallback callback = new TestBidirectionalStreamCallback();
    callback.addWriteData(new byte[] {0});
    mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor())
        .build()
        .start();
    callback.blockForDone();
    assertTrue(CronetTestUtil.nativeGetTaggedBytes(tag) > priorBytes);

    // Test explicit tagging.
    tag = 0x12345678;
    priorBytes = CronetTestUtil.nativeGetTaggedBytes(tag);
    callback = new TestBidirectionalStreamCallback();
    callback.addWriteData(new byte[] {0});
    ExperimentalBidirectionalStream.Builder builder =
        mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor());
    assertEquals(builder.setTrafficStatsTag(tag), builder);
    builder.build().start();
    callback.blockForDone();
    assertTrue(CronetTestUtil.nativeGetTaggedBytes(tag) > priorBytes);

    // Test a different tag value to make sure reused connections are retagged.
    tag = 0x87654321;
    priorBytes = CronetTestUtil.nativeGetTaggedBytes(tag);
    callback = new TestBidirectionalStreamCallback();
    callback.addWriteData(new byte[] {0});
    builder = mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor());
    assertEquals(builder.setTrafficStatsTag(tag), builder);
    builder.build().start();
    callback.blockForDone();
    assertTrue(CronetTestUtil.nativeGetTaggedBytes(tag) > priorBytes);

    // Test tagging with our UID.
    tag = 0;
    priorBytes = CronetTestUtil.nativeGetTaggedBytes(tag);
    callback = new TestBidirectionalStreamCallback();
    callback.addWriteData(new byte[] {0});
    builder = mCronetEngine.newBidirectionalStreamBuilder(url, callback, callback.getExecutor());
    assertEquals(builder.setTrafficStatsUid(Process.myUid()), builder);
    builder.build().start();
    callback.blockForDone();
    assertTrue(CronetTestUtil.nativeGetTaggedBytes(tag) > priorBytes);
  }
}
package org.chromium.net;

import static org.chromium.net.testing.CronetTestRule.getContext;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.os.ConditionVariable;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import com.google.common.collect.Sets;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicBoolean;
import org.chromium.net.impl.CronvoyMetrics;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.CronetTestRule.CronetTestFramework;
import org.chromium.net.testing.CronetTestRule.RequiresMinApi;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.MetricsTestUtil;
import org.chromium.net.testing.MetricsTestUtil.TestExecutor;
import org.chromium.net.testing.MetricsTestUtil.TestRequestFinishedListener;
import org.chromium.net.testing.NativeTestServer;
import org.chromium.net.testing.TestUrlRequestCallback;
import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Test RequestFinishedInfo.Listener and the metrics information it provides.
 */
@RunWith(AndroidJUnit4.class)
public class RequestFinishedInfoTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  CronetTestFramework mTestFramework;
  private String mUrl;

  // A subclass of TestRequestFinishedListener to additionally assert that UrlRequest.Callback's
  // terminal callbacks have been invoked at the time of onRequestFinished().
  // See crbug.com/710877.
  private static class AssertCallbackDoneRequestFinishedListener
      extends TestRequestFinishedListener {
    private final TestUrlRequestCallback mCallback;
    public AssertCallbackDoneRequestFinishedListener(TestUrlRequestCallback callback) {
      // Use same executor as request callback to verify stable call order.
      super(callback.getExecutor());
      mCallback = callback;
    }

    @Override
    public void onRequestFinished(RequestFinishedInfo requestInfo) {
      assertTrue(mCallback.isDone());
      super.onRequestFinished(requestInfo);
    }
  };

  @Before
  public void setUp() throws Exception {
    NativeTestServer.startNativeTestServer(getContext());
    mUrl = NativeTestServer.getEchoBodyURL();
    mTestFramework = mTestRule.startCronetTestFramework();
  }

  @After
  public void tearDown() throws Exception {
    NativeTestServer.shutdownNativeTestServer();
  }

  static class DirectExecutor implements Executor {
    private ConditionVariable mBlock = new ConditionVariable();

    @Override
    public void execute(Runnable task) {
      task.run();
      mBlock.open();
    }

    public void blockUntilDone() { mBlock.block(); }
  }

  static class ThreadExecutor implements Executor {
    private List<Thread> mThreads = new ArrayList<Thread>();

    @Override
    public void execute(Runnable task) {
      Thread newThread = new Thread(task);
      mThreads.add(newThread);
      newThread.start();
    }

    public void joinAll() throws InterruptedException {
      for (Thread thread : mThreads) {
        thread.join();
      }
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @SuppressWarnings("deprecation")
  public void testRequestFinishedListener() throws Exception {
    TestRequestFinishedListener requestFinishedListener = new TestRequestFinishedListener();
    mTestFramework.mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    ExperimentalUrlRequest.Builder urlRequestBuilder =
        (ExperimentalUrlRequest.Builder)mTestFramework.mCronetEngine.newUrlRequestBuilder(
            mUrl, callback, callback.getExecutor());
    Date startTime = new Date();
    urlRequestBuilder.addRequestAnnotation("request annotation")
        .addRequestAnnotation(this)
        .build()
        .start();
    callback.blockForDone();
    requestFinishedListener.blockUntilDone();
    Date endTime = new Date();

    RequestFinishedInfo requestInfo = requestFinishedListener.getRequestInfo();
    MetricsTestUtil.checkRequestFinishedInfo(requestInfo, mUrl, startTime, endTime);
    assertEquals(RequestFinishedInfo.SUCCEEDED, requestInfo.getFinishedReason());
    MetricsTestUtil.checkHasConnectTiming(requestInfo.getMetrics(), startTime, endTime, false);
    assertEquals(Sets.newHashSet("request annotation", this), // Use sets for unordered comparison.
                 new HashSet<Object>(requestInfo.getAnnotations()));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @SuppressWarnings("deprecation")
  public void testRequestFinishedListenerDirectExecutor() throws Exception {
    DirectExecutor testExecutor = new DirectExecutor();
    TestRequestFinishedListener requestFinishedListener =
        new TestRequestFinishedListener(testExecutor);
    mTestFramework.mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    ExperimentalUrlRequest.Builder urlRequestBuilder =
        (ExperimentalUrlRequest.Builder)mTestFramework.mCronetEngine.newUrlRequestBuilder(
            mUrl, callback, callback.getExecutor());
    Date startTime = new Date();
    urlRequestBuilder.addRequestAnnotation("request annotation")
        .addRequestAnnotation(this)
        .build()
        .start();
    callback.blockForDone();
    // Block on the executor, not the listener, since blocking on the listener doesn't work when
    // it's created with a non-default executor.
    testExecutor.blockUntilDone();
    Date endTime = new Date();

    RequestFinishedInfo requestInfo = requestFinishedListener.getRequestInfo();
    MetricsTestUtil.checkRequestFinishedInfo(requestInfo, mUrl, startTime, endTime);
    assertEquals(RequestFinishedInfo.SUCCEEDED, requestInfo.getFinishedReason());
    MetricsTestUtil.checkHasConnectTiming(requestInfo.getMetrics(), startTime, endTime, false);
    assertEquals(Sets.newHashSet("request annotation", this), // Use sets for unordered comparison.
                 new HashSet<Object>(requestInfo.getAnnotations()));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @SuppressWarnings("deprecation")
  public void testRequestFinishedListenerDifferentThreads() throws Exception {
    TestRequestFinishedListener firstListener = new TestRequestFinishedListener();
    TestRequestFinishedListener secondListener = new TestRequestFinishedListener();
    mTestFramework.mCronetEngine.addRequestFinishedListener(firstListener);
    mTestFramework.mCronetEngine.addRequestFinishedListener(secondListener);
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    ExperimentalUrlRequest.Builder urlRequestBuilder =
        (ExperimentalUrlRequest.Builder)mTestFramework.mCronetEngine.newUrlRequestBuilder(
            mUrl, callback, callback.getExecutor());
    Date startTime = new Date();
    urlRequestBuilder.addRequestAnnotation("request annotation")
        .addRequestAnnotation(this)
        .build()
        .start();
    callback.blockForDone();
    firstListener.blockUntilDone();
    secondListener.blockUntilDone();
    Date endTime = new Date();

    RequestFinishedInfo firstRequestInfo = firstListener.getRequestInfo();
    RequestFinishedInfo secondRequestInfo = secondListener.getRequestInfo();

    MetricsTestUtil.checkRequestFinishedInfo(firstRequestInfo, mUrl, startTime, endTime);
    assertEquals(RequestFinishedInfo.SUCCEEDED, firstRequestInfo.getFinishedReason());
    MetricsTestUtil.checkHasConnectTiming(firstRequestInfo.getMetrics(), startTime, endTime, false);

    MetricsTestUtil.checkRequestFinishedInfo(secondRequestInfo, mUrl, startTime, endTime);
    assertEquals(RequestFinishedInfo.SUCCEEDED, secondRequestInfo.getFinishedReason());
    MetricsTestUtil.checkHasConnectTiming(secondRequestInfo.getMetrics(), startTime, endTime,
                                          false);

    assertEquals(Sets.newHashSet("request annotation", this), // Use sets for unordered comparison.
                 new HashSet<Object>(firstRequestInfo.getAnnotations()));
    assertEquals(Sets.newHashSet("request annotation", this),
                 new HashSet<Object>(secondRequestInfo.getAnnotations()));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Needs debugging")
  @SuppressWarnings("deprecation")
  public void testRequestFinishedListenerFailedRequest() throws Exception {
    String connectionRefusedUrl = "http://127.0.0.1:3";
    TestRequestFinishedListener requestFinishedListener = new TestRequestFinishedListener();
    mTestFramework.mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder = mTestFramework.mCronetEngine.newUrlRequestBuilder(
        connectionRefusedUrl, callback, callback.getExecutor());
    Date startTime = new Date();
    urlRequestBuilder.build().start();
    callback.blockForDone();
    assertTrue(callback.mOnErrorCalled);
    requestFinishedListener.blockUntilDone();
    Date endTime = new Date();

    RequestFinishedInfo requestInfo = requestFinishedListener.getRequestInfo();
    assertNotNull("RequestFinishedInfo.Listener must be called", requestInfo);
    assertEquals(connectionRefusedUrl, requestInfo.getUrl());
    assertTrue(requestInfo.getAnnotations().isEmpty());
    assertEquals(RequestFinishedInfo.FAILED, requestInfo.getFinishedReason());
    assertNotNull(requestInfo.getException());
    assertEquals(NetworkException.ERROR_CONNECTION_REFUSED,
                 ((NetworkException)requestInfo.getException()).getErrorCode());
    RequestFinishedInfo.Metrics metrics = requestInfo.getMetrics();
    assertNotNull("RequestFinishedInfo.getMetrics() must not be null", metrics);
    // The failure is occasionally fast enough that time reported is 0, so just check for null
    assertNotNull(metrics.getTotalTimeMs());
    assertNull(metrics.getTtfbMs());

    // Check the timing metrics
    assertNotNull(metrics.getRequestStart());
    MetricsTestUtil.assertAfter(metrics.getRequestStart(), startTime);
    MetricsTestUtil.checkNoConnectTiming(metrics);
    assertNull(metrics.getSendingStart());
    assertNull(metrics.getSendingEnd());
    assertNull(metrics.getResponseStart());
    assertNotNull(metrics.getRequestEnd());
    MetricsTestUtil.assertAfter(endTime, metrics.getRequestEnd());
    MetricsTestUtil.assertAfter(metrics.getRequestEnd(), metrics.getRequestStart());
    assertTrue(metrics.getSentByteCount() == 0);
    assertTrue(metrics.getReceivedByteCount() == 0);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @SuppressWarnings("deprecation")
  public void testRequestFinishedListenerRemoved() throws Exception {
    TestExecutor testExecutor = new TestExecutor();
    TestRequestFinishedListener requestFinishedListener =
        new TestRequestFinishedListener(testExecutor);
    mTestFramework.mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        mTestFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    UrlRequest request = urlRequestBuilder.build();
    mTestFramework.mCronetEngine.removeRequestFinishedListener(requestFinishedListener);
    request.start();
    callback.blockForDone();
    testExecutor.runAllTasks();

    assertNull("RequestFinishedInfo.Listener must not be called",
               requestFinishedListener.getRequestInfo());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testRequestFinishedListenerCanceledRequest() throws Exception {
    TestRequestFinishedListener requestFinishedListener = new TestRequestFinishedListener();
    mTestFramework.mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    TestUrlRequestCallback callback = new TestUrlRequestCallback() {
      @Override
      public void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
        super.onResponseStarted(request, info);
        request.cancel();
      }
    };
    ExperimentalUrlRequest.Builder urlRequestBuilder =
        mTestFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    Date startTime = new Date();
    urlRequestBuilder.addRequestAnnotation("request annotation")
        .addRequestAnnotation(this)
        .build()
        .start();
    callback.blockForDone();
    requestFinishedListener.blockUntilDone();
    Date endTime = new Date();

    RequestFinishedInfo requestInfo = requestFinishedListener.getRequestInfo();
    MetricsTestUtil.checkRequestFinishedInfo(requestInfo, mUrl, startTime, endTime);
    assertEquals(RequestFinishedInfo.CANCELED, requestInfo.getFinishedReason());
    MetricsTestUtil.checkHasConnectTiming(requestInfo.getMetrics(), startTime, endTime, false);

    assertEquals(Sets.newHashSet("request annotation", this), // Use sets for unordered comparison.
                 new HashSet<Object>(requestInfo.getAnnotations()));
  }

  private static class RejectAllTasksExecutor implements Executor {
    @Override
    public void execute(Runnable task) {
      throw new RejectedExecutionException();
    }
  }

  // Checks that CronetURLRequestAdapter::DestroyOnNetworkThread() doesn't crash when metrics
  // collection is enabled and the URLRequest hasn't been created. See http://crbug.com/675629.
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testExceptionInRequestStart() throws Exception {
    // The listener in this test shouldn't get any tasks.
    Executor executor = new RejectAllTasksExecutor();
    TestRequestFinishedListener requestFinishedListener = new TestRequestFinishedListener(executor);
    mTestFramework.mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    ExperimentalUrlRequest.Builder urlRequestBuilder =
        mTestFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    // Empty headers are invalid and will cause start() to throw an exception.
    UrlRequest request = urlRequestBuilder.addHeader("", "").build();
    try {
      request.start();
      fail("UrlRequest.start() should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
      assertEquals("Invalid header =", e.getMessage());
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testMetricsGetters() throws Exception {
    long requestStart = 1;
    long dnsStart = 2;
    long dnsEnd = -1;
    long connectStart = 4;
    long connectEnd = 5;
    long sslStart = 6;
    long sslEnd = 7;
    long sendingStart = 8;
    long sendingEnd = 9;
    long pushStart = 10;
    long pushEnd = 11;
    long responseStart = 12;
    long requestEnd = 13;
    boolean socketReused = true;
    long sentByteCount = 14;
    long receivedByteCount = 15;
    // Make sure nothing gets reordered inside the Metrics class
    RequestFinishedInfo.Metrics metrics =
        new CronvoyMetrics(requestStart, dnsStart, dnsEnd, connectStart, connectEnd, sslStart,
                           sslEnd, sendingStart, sendingEnd, pushStart, pushEnd, responseStart,
                           requestEnd, socketReused, sentByteCount, receivedByteCount);
    assertEquals(new Date(requestStart), metrics.getRequestStart());
    // -1 timestamp should translate to null
    assertNull(metrics.getDnsEnd());
    assertEquals(new Date(dnsStart), metrics.getDnsStart());
    assertEquals(new Date(connectStart), metrics.getConnectStart());
    assertEquals(new Date(connectEnd), metrics.getConnectEnd());
    assertEquals(new Date(sslStart), metrics.getSslStart());
    assertEquals(new Date(sslEnd), metrics.getSslEnd());
    assertEquals(new Date(pushStart), metrics.getPushStart());
    assertEquals(new Date(pushEnd), metrics.getPushEnd());
    assertEquals(new Date(responseStart), metrics.getResponseStart());
    assertEquals(new Date(requestEnd), metrics.getRequestEnd());
    assertEquals(socketReused, metrics.getSocketReused());
    assertEquals(sentByteCount, (long)metrics.getSentByteCount());
    assertEquals(receivedByteCount, (long)metrics.getReceivedByteCount());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @SuppressWarnings("deprecation")
  public void testOrderSuccessfulRequest() throws Exception {
    final TestUrlRequestCallback callback = new TestUrlRequestCallback();
    TestRequestFinishedListener requestFinishedListener =
        new AssertCallbackDoneRequestFinishedListener(callback);
    mTestFramework.mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    ExperimentalUrlRequest.Builder urlRequestBuilder =
        (ExperimentalUrlRequest.Builder)mTestFramework.mCronetEngine.newUrlRequestBuilder(
            mUrl, callback, callback.getExecutor());
    Date startTime = new Date();
    urlRequestBuilder.addRequestAnnotation("request annotation")
        .addRequestAnnotation(this)
        .build()
        .start();
    callback.blockForDone();
    requestFinishedListener.blockUntilDone();
    Date endTime = new Date();

    RequestFinishedInfo requestInfo = requestFinishedListener.getRequestInfo();
    MetricsTestUtil.checkRequestFinishedInfo(requestInfo, mUrl, startTime, endTime);
    assertEquals(RequestFinishedInfo.SUCCEEDED, requestInfo.getFinishedReason());
    MetricsTestUtil.checkHasConnectTiming(requestInfo.getMetrics(), startTime, endTime, false);
    assertEquals(Sets.newHashSet("request annotation", this), // Use sets for unordered comparison.
                 new HashSet<Object>(requestInfo.getAnnotations()));
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @RequiresMinApi(11)
  public void testUpdateAnnotationOnSucceeded() throws Exception {
    // The annotation that is updated in onSucceeded() callback.
    AtomicBoolean requestAnnotation = new AtomicBoolean(false);
    final TestUrlRequestCallback callback = new TestUrlRequestCallback() {
      @Override
      public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
        // Add processing information to request annotation.
        requestAnnotation.set(true);
        super.onSucceeded(request, info);
      }
    };
    TestRequestFinishedListener requestFinishedListener =
        new AssertCallbackDoneRequestFinishedListener(callback);
    ExperimentalUrlRequest.Builder urlRequestBuilder =
        (ExperimentalUrlRequest.Builder)mTestFramework.mCronetEngine.newUrlRequestBuilder(
            mUrl, callback, callback.getExecutor());
    Date startTime = new Date();
    urlRequestBuilder.addRequestAnnotation(requestAnnotation)
        .setRequestFinishedListener(requestFinishedListener)
        .build()
        .start();
    callback.blockForDone();
    requestFinishedListener.blockUntilDone();
    Date endTime = new Date();
    RequestFinishedInfo requestInfo = requestFinishedListener.getRequestInfo();
    MetricsTestUtil.checkRequestFinishedInfo(requestInfo, mUrl, startTime, endTime);
    assertEquals(RequestFinishedInfo.SUCCEEDED, requestInfo.getFinishedReason());
    MetricsTestUtil.checkHasConnectTiming(requestInfo.getMetrics(), startTime, endTime, false);
    // Check that annotation got updated in onSucceeded() callback.
    assertEquals(requestAnnotation, requestInfo.getAnnotations().iterator().next());
    assertTrue(requestAnnotation.get());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Tests a failed request where the error originates from Java.
  public void testOrderFailedRequestJava() throws Exception {
    final TestUrlRequestCallback callback = new TestUrlRequestCallback() {
      @Override
      public void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
        throw new RuntimeException("make this request fail");
      }
    };
    TestRequestFinishedListener requestFinishedListener =
        new AssertCallbackDoneRequestFinishedListener(callback);
    mTestFramework.mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    UrlRequest.Builder urlRequestBuilder =
        mTestFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    assertTrue(callback.mOnErrorCalled);
    requestFinishedListener.blockUntilDone();
    RequestFinishedInfo requestInfo = requestFinishedListener.getRequestInfo();
    assertNotNull("RequestFinishedInfo.Listener must be called", requestInfo);
    assertEquals(mUrl, requestInfo.getUrl());
    assertTrue(requestInfo.getAnnotations().isEmpty());
    assertEquals(RequestFinishedInfo.FAILED, requestInfo.getFinishedReason());
    assertNotNull(requestInfo.getException());
    assertEquals("Exception received from UrlRequest.Callback",
                 requestInfo.getException().getMessage());
    RequestFinishedInfo.Metrics metrics = requestInfo.getMetrics();
    assertNotNull("RequestFinishedInfo.getMetrics() must not be null", metrics);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Needs debugging")
  // Tests a failed request where the error originates from native code.
  public void testOrderFailedRequestNative() throws Exception {
    String connectionRefusedUrl = "http://127.0.0.1:3";
    final TestUrlRequestCallback callback = new TestUrlRequestCallback();
    TestRequestFinishedListener requestFinishedListener =
        new AssertCallbackDoneRequestFinishedListener(callback);
    mTestFramework.mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    UrlRequest.Builder urlRequestBuilder = mTestFramework.mCronetEngine.newUrlRequestBuilder(
        connectionRefusedUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    assertTrue(callback.mOnErrorCalled);
    requestFinishedListener.blockUntilDone();
    RequestFinishedInfo requestInfo = requestFinishedListener.getRequestInfo();
    assertNotNull("RequestFinishedInfo.Listener must be called", requestInfo);
    assertEquals(connectionRefusedUrl, requestInfo.getUrl());
    assertTrue(requestInfo.getAnnotations().isEmpty());
    assertEquals(RequestFinishedInfo.FAILED, requestInfo.getFinishedReason());
    assertNotNull(requestInfo.getException());
    assertEquals(NetworkException.ERROR_CONNECTION_REFUSED,
                 ((NetworkException)requestInfo.getException()).getErrorCode());
    RequestFinishedInfo.Metrics metrics = requestInfo.getMetrics();
    assertNotNull("RequestFinishedInfo.getMetrics() must not be null", metrics);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testOrderCanceledRequest() throws Exception {
    final TestUrlRequestCallback callback = new TestUrlRequestCallback() {
      @Override
      public void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
        super.onResponseStarted(request, info);
        request.cancel();
      }
    };

    TestRequestFinishedListener requestFinishedListener =
        new AssertCallbackDoneRequestFinishedListener(callback);
    mTestFramework.mCronetEngine.addRequestFinishedListener(requestFinishedListener);
    ExperimentalUrlRequest.Builder urlRequestBuilder =
        mTestFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    Date startTime = new Date();
    urlRequestBuilder.addRequestAnnotation("request annotation")
        .addRequestAnnotation(this)
        .build()
        .start();
    callback.blockForDone();
    requestFinishedListener.blockUntilDone();
    Date endTime = new Date();

    RequestFinishedInfo requestInfo = requestFinishedListener.getRequestInfo();
    MetricsTestUtil.checkRequestFinishedInfo(requestInfo, mUrl, startTime, endTime);
    assertEquals(RequestFinishedInfo.CANCELED, requestInfo.getFinishedReason());
    MetricsTestUtil.checkHasConnectTiming(requestInfo.getMetrics(), startTime, endTime, false);

    assertEquals(Sets.newHashSet("request annotation", this), // Use sets for unordered comparison.
                 new HashSet<Object>(requestInfo.getAnnotations()));
  }
}
package org.chromium.net;

import static org.chromium.net.CronvoyProvider.PROVIDER_NAME_APP_PACKAGED;
import static org.chromium.net.CronvoyProvider.PROVIDER_NAME_FALLBACK;
import static org.chromium.net.testing.CronetTestRule.getContext;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.Feature;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests {@link CronetEngine.Builder}.
 */
@RunWith(AndroidJUnit4.class)
public class CronetEngineBuilderTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  /**
   * Tests the comparison of two strings that contain versions.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testVersionComparison() {
    assertVersionIsHigher("22.44", "22.43.12");
    assertVersionIsLower("22.43.12", "022.124");
    assertVersionIsLower("22.99", "22.100");
    assertVersionIsHigher("22.100", "22.99");
    assertVersionIsEqual("11.2.33", "11.2.33");
    assertIllegalArgumentException(null, "1.2.3");
    assertIllegalArgumentException("1.2.3", null);
    assertIllegalArgumentException("1.2.3", "1.2.3x");
  }

  /**
   * Tests the correct ordering of the providers. The platform provider should be
   * the last in the list. Other providers should be ordered by placing providers
   * with the higher version first.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testProviderOrdering() {
    final CronvoyProvider[] availableProviders = new CronvoyProvider[] {
        createMockCronetProvider(PROVIDER_NAME_APP_PACKAGED, "99.77", true),
        createMockCronetProvider(PROVIDER_NAME_FALLBACK, "99.99", true),
        createMockCronetProvider("Some other provider", "99.88", true),
    };

    ArrayList<CronvoyProvider> providers = new ArrayList<>(Arrays.asList(availableProviders));
    List<CronvoyProvider> orderedProviders =
        CronetEngine.Builder.getEnabledCronvoyProviders(getContext(), providers);

    // Check the result
    assertEquals(availableProviders[2], orderedProviders.get(0));
    assertEquals(availableProviders[0], orderedProviders.get(1));
    assertEquals(availableProviders[1], orderedProviders.get(2));
  }

  /**
   * Tests that the providers that are disabled are not included in the list of available
   * providers when the provider is selected by the default selection logic.
   */
  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testThatDisabledProvidersAreExcluded() {
    final CronvoyProvider[] availableProviders = new CronvoyProvider[] {
        createMockCronetProvider(PROVIDER_NAME_FALLBACK, "99.99", true),
        createMockCronetProvider(PROVIDER_NAME_APP_PACKAGED, "99.77", true),
        createMockCronetProvider("Some other provider", "99.88", false),
    };

    ArrayList<CronvoyProvider> providers = new ArrayList<>(Arrays.asList(availableProviders));
    List<CronvoyProvider> orderedProviders =
        CronetEngine.Builder.getEnabledCronvoyProviders(getContext(), providers);

    assertEquals("Unexpected number of providers in the list", 2, orderedProviders.size());
    assertEquals(PROVIDER_NAME_APP_PACKAGED, orderedProviders.get(0).getName());
    assertEquals(PROVIDER_NAME_FALLBACK, orderedProviders.get(1).getName());
  }

  private void assertVersionIsHigher(String s1, String s2) {
    assertEquals(1, CronetEngine.Builder.compareVersions(s1, s2));
  }

  private void assertVersionIsLower(String s1, String s2) {
    assertEquals(-1, CronetEngine.Builder.compareVersions(s1, s2));
  }

  private void assertVersionIsEqual(String s1, String s2) {
    assertEquals(0, CronetEngine.Builder.compareVersions(s1, s2));
  }

  private void assertIllegalArgumentException(String s1, String s2) {
    try {
      CronetEngine.Builder.compareVersions(s1, s2);
    } catch (IllegalArgumentException e) {
      // Do nothing. It is expected.
      return;
    }
    fail("Expected IllegalArgumentException");
  }

  private static CronvoyProvider createMockCronetProvider(String mName, String mVersion,
                                                          boolean mEnabled) {
    CronvoyProvider mock = mock(CronvoyProvider.class);
    when(mock.getName()).thenReturn(mName);
    when(mock.getVersion()).thenReturn(mVersion);
    when(mock.isEnabled()).thenReturn(mEnabled);
    return mock;
  }
}
package org.chromium.net.testing;

import android.util.Base64;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;

/**
 * Certificate related utility methods.
 */
public final class CertTestUtil {
  /**
   * The location of the directory that contains certificates for testing.
   */
  public static final String CERTS_DIRECTORY =
      UrlUtils.getIsolatedTestFilePath("net/data/ssl/certificates/");

  private static final String BEGIN_MARKER = "-----BEGIN CERTIFICATE-----";
  private static final String END_MARKER = "-----END CERTIFICATE-----";

  /**
   * Converts a PEM formatted cert in a given file to the binary DER format.
   *
   * @param pemPathname the location of the certificate to convert.
   * @return array of bytes that represent the certificate in DER format.
   * @throws IOException if the file cannot be read.
   */
  public static byte[] pemToDer(String pemPathname) throws IOException {
    BufferedReader reader = new BufferedReader(new FileReader(pemPathname));
    StringBuilder builder = new StringBuilder();

    // Skip past leading junk lines, if any.
    String line = reader.readLine();
    while (line != null && !line.contains(BEGIN_MARKER))
      line = reader.readLine();

    // Then skip the BEGIN_MARKER itself, if present.
    while (line != null && line.contains(BEGIN_MARKER))
      line = reader.readLine();

    // Now gather the data lines into the builder.
    while (line != null && !line.contains(END_MARKER)) {
      builder.append(line.trim());
      line = reader.readLine();
    }

    reader.close();
    return Base64.decode(builder.toString(), Base64.DEFAULT);
  }

  /**
   * Returns SHA256 hash of the public key of a given certificate.
   *
   * @param cert the cert that should be used to retrieve the public key from.
   * @return SHA256 hash of the public key.
   */
  public static byte[] getPublicKeySha256(Certificate cert) {
    try {
      byte[] publicKey = cert.getPublicKey().getEncoded();
      MessageDigest digest = MessageDigest.getInstance("SHA-256");
      return digest.digest(publicKey);
    } catch (NoSuchAlgorithmException ex) {
      // This exception should never happen since SHA-256 is known algorithm
      throw new RuntimeException(ex);
    }
  }

  private CertTestUtil() {}
}
package org.chromium.net.testing;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.os.Build;
import android.os.StrictMode;
import android.util.Log;
import androidx.test.platform.app.InstrumentationRegistry;
import io.envoyproxy.envoymobile.LogLevel;
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary;
import java.io.File;
import java.lang.annotation.Annotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Field;
import java.net.URL;
import java.net.URLStreamHandlerFactory;
import org.chromium.net.ApiVersion;
import org.chromium.net.CronetEngine;
import org.chromium.net.ExperimentalCronetEngine;
import org.chromium.net.UrlResponseInfo;
import org.chromium.net.impl.CronvoyEngineBuilderImpl;
import org.chromium.net.impl.NativeCronvoyProvider;
import org.chromium.net.impl.CronvoyUserAgent;
import org.junit.Assert;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;
import io.envoyproxy.envoymobile.utilities.AndroidNetworkLibrary;

/**
 * Custom TestRule for Cronet instrumentation tests.
 */
public final class CronetTestRule implements TestRule {
  private static final String PRIVATE_DATA_DIRECTORY_SUFFIX = "cronet_test";

  private CronetTestFramework mCronetTestFramework;

  // {@code true} when test is being run against system HttpURLConnection implementation.
  private boolean mTestingSystemHttpURLConnection;
  private StrictMode.VmPolicy mOldVmPolicy;
  private CronetEngine mUrlConnectionCronetEngine;
  private static Context mContext;

  /**
   * Name of the file that contains the test server certificate in PEM format.
   */
  public static final String SERVER_CERT_PEM =
      "../envoy/test/config/integration/certs/upstreamcert.pem";

  /**
   * Name of the file that contains the test server private key in PKCS8 PEM format.
   */
  public static final String SERVER_KEY_PKCS8_PEM =
      "../envoy/test/config/integration/certs/upstreamkey.pem";

  private static final String TAG = CronetTestRule.class.getSimpleName();

  /**
   * Creates and holds pointer to CronetEngine.
   */
  public static class CronetTestFramework {
    public ExperimentalCronetEngine mCronetEngine;
    public ExperimentalCronetEngine.Builder mBuilder;

    private Context mContext;

    private CronetTestFramework(Context context) {
      mContext = context;
      mBuilder = createNativeEngineBuilder();
    }

    private static CronetTestFramework createUsingNativeImpl(Context context) {
      return new CronetTestFramework(context);
    }

    public ExperimentalCronetEngine startEngine() {
      assert mCronetEngine == null;

      mCronetEngine = mBuilder.build();

      // Start collecting metrics.
      mCronetEngine.getGlobalMetricsDeltas();

      return mCronetEngine;
    }

    public void shutdownEngine() {
      if (mCronetEngine == null)
        return;
      mCronetEngine.shutdown();
      mCronetEngine = null;
    }

    private ExperimentalCronetEngine.Builder createNativeEngineBuilder() {
      return CronetTestRule.createNativeEngineBuilder(mContext).enableQuic(true);
    }
  }

  int getMaximumAvailableApiLevel() {
    // Prior to M59 the ApiVersion.getMaximumAvailableApiLevel API didn't exist
    int cronetMajorVersion = Integer.parseInt(ApiVersion.getCronetVersion().split("\\.")[0]);
    if (cronetMajorVersion < 59) {
      return 3;
    }
    return ApiVersion.getMaximumAvailableApiLevel();
  }

  public static Context getContext() {
    if (mContext == null) {
      mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
    }
    return mContext;
  }

  @Override
  public Statement apply(final Statement base, final Description desc) {
    return new Statement() {
      @Override
      public void evaluate() throws Throwable {
        try {
          setUp();
          runBase(base, desc);
        } finally {
          tearDown();
        }
      }
    };
  }

  /**
   * Returns {@code true} when test is being run against system HttpURLConnection implementation.
   */
  public boolean testingSystemHttpURLConnection() { return mTestingSystemHttpURLConnection; }

  private void runBase(Statement base, Description desc) throws Throwable {
    setTestingSystemHttpURLConnection(false);
    String packageName = desc.getTestClass().getPackage().getName();

    // Find the API version required by the test.
    int requiredApiVersion = getMaximumAvailableApiLevel();
    int requiredAndroidApiVersion = Build.VERSION_CODES.KITKAT;
    for (Annotation a : desc.getTestClass().getAnnotations()) {
      if (a instanceof RequiresMinApi) {
        requiredApiVersion = ((RequiresMinApi)a).value();
      }
      if (a instanceof RequiresMinAndroidApi) {
        requiredAndroidApiVersion = ((RequiresMinAndroidApi)a).value();
      }
    }
    for (Annotation a : desc.getAnnotations()) {
      if (a instanceof RequiresMinApi) {
        // Method scoped requirements take precedence over class scoped
        // requirements.
        requiredApiVersion = ((RequiresMinApi)a).value();
      }
      if (a instanceof RequiresMinAndroidApi) {
        requiredAndroidApiVersion = ((RequiresMinAndroidApi)a).value();
      }
    }
    assumeTrue(desc.getMethodName() + " skipped because it requires API " + requiredApiVersion +
                   " but only API " + getMaximumAvailableApiLevel() + " is present.",
               getMaximumAvailableApiLevel() >= requiredApiVersion);
    assumeTrue(desc.getMethodName() + " skipped because it Android's API level " +
                   requiredAndroidApiVersion + " but test device supports only API " +
                   Build.VERSION.SDK_INT,
               Build.VERSION.SDK_INT >= requiredAndroidApiVersion);

    if (packageName.equals("org.chromium.net.urlconnection")) {
      if (desc.getAnnotation(CompareDefaultWithCronet.class) != null) {
        try {
          // Run with the default HttpURLConnection implementation first.
          setTestingSystemHttpURLConnection(true);
          base.evaluate();
          // Use Cronet's implementation, and run the same test.
          setTestingSystemHttpURLConnection(false);
          base.evaluate();
        } catch (Throwable e) {
          Log.e(TAG, String.format("CronetTestBase#runTest failed for %s implementation.",
                                   testingSystemHttpURLConnection() ? "System" : "Cronet"));
          throw e;
        }
      } else {
        // For all other tests.
        base.evaluate();
      }
    } else if (packageName.startsWith("org.chromium.net")) {
      try {
        Log.i(TAG, "Running test against Native implementation.");
        base.evaluate();
      } catch (Throwable e) {
        Log.e(TAG, "CronetTestBase#runTest failed for Native implementation.");
        throw e;
      }
    } else {
      base.evaluate();
    }
  }

  private void setUp() {
    AndroidJniLibrary.loadTestLibrary();
    ContextUtils.initApplicationContext(getContext().getApplicationContext());
    PathUtils.setPrivateDataDirectorySuffix(PRIVATE_DATA_DIRECTORY_SUFFIX);
    prepareTestStorage();
    mOldVmPolicy = StrictMode.getVmPolicy();
    // Only enable StrictMode testing after leaks were fixed in crrev.com/475945
    if (getMaximumAvailableApiLevel() >= 7) {
      StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
                                 .detectLeakedClosableObjects()
                                 .penaltyLog()
                                 .penaltyDeath()
                                 .build());
    }
    AndroidNetworkLibrary.setFakeCertificateVerificationForTesting(true);
  }

  private void tearDown() {
    if (mCronetTestFramework != null) {
      mCronetTestFramework.shutdownEngine();
      mCronetTestFramework = null;
    }

    if (mUrlConnectionCronetEngine != null) {
      mUrlConnectionCronetEngine.shutdown();
      mUrlConnectionCronetEngine = null;
    }

    resetURLStreamHandlerFactory();
    AndroidNetworkLibrary.setFakeCertificateVerificationForTesting(false);

    try {
      // Run GC and finalizers a few times to pick up leaked closeables
      for (int i = 0; i < 10; i++) {
        System.gc();
        System.runFinalization();
      }
      System.gc();
      System.runFinalization();
    } finally {
      StrictMode.setVmPolicy(mOldVmPolicy);
    }
  }

  private CronetTestFramework createCronetTestFramework() {
    mCronetTestFramework = CronetTestFramework.createUsingNativeImpl(getContext());
    return mCronetTestFramework;
  }

  /**
   * Builds and starts the CronetTest framework.
   */
  public CronetTestFramework startCronetTestFramework() {
    createCronetTestFramework();
    mCronetTestFramework.startEngine();
    return mCronetTestFramework;
  }

  /**
   * Builds the CronetTest framework.
   */
  public CronetTestFramework buildCronetTestFramework() { return createCronetTestFramework(); }

  /**
   * Creates and returns {@link ExperimentalCronetEngine.Builder} that creates
   * Chromium (native) based {@link CronetEngine.Builder}.
   *
   * @return the {@code CronetEngine.Builder} that builds Chromium-based {@code Cronet engine}.
   */
  public static ExperimentalCronetEngine.Builder createNativeEngineBuilder(Context context) {
    return (ExperimentalCronetEngine.Builder) new NativeCronvoyProvider(context).createBuilder();
  }

  public void assertResponseEquals(UrlResponseInfo expected, UrlResponseInfo actual) {
    assertEquals(expected.getAllHeaders(), actual.getAllHeaders());
    assertEquals(expected.getAllHeadersAsList(), actual.getAllHeadersAsList());
    assertEquals(expected.getHttpStatusCode(), actual.getHttpStatusCode());
    assertEquals(expected.getHttpStatusText(), actual.getHttpStatusText());
    assertEquals(expected.getUrlChain(), actual.getUrlChain());
    assertEquals(expected.getUrl(), actual.getUrl());
    assertEquals(expected.getReceivedByteCount(), actual.getReceivedByteCount());
    assertEquals(expected.getProxyServer(), actual.getProxyServer());
    assertEquals(expected.getNegotiatedProtocol(), actual.getNegotiatedProtocol());
  }

  public static void assertContains(String expectedSubstring, String actualString) {
    Assert.assertNotNull(actualString);
    if (!actualString.contains(expectedSubstring)) {
      fail("String [" + actualString + "] doesn't contain substring [" + expectedSubstring + "]");
    }
  }

  public CronetEngine.Builder enableDiskCache(CronetEngine.Builder cronetEngineBuilder) {
    cronetEngineBuilder.setStoragePath(getTestStorage());
    cronetEngineBuilder.enableHttpCache(CronetEngine.Builder.HTTP_CACHE_DISK, 1000 * 1024);
    return cronetEngineBuilder;
  }

  /**
   * Sets the {@link URLStreamHandlerFactory} from {@code cronetEngine}. This should be called
   * during setUp() and is installed by {@code runTest()} as the default when Cronet is tested.
   */
  public void setStreamHandlerFactory(CronetEngine cronetEngine) {
    mUrlConnectionCronetEngine = cronetEngine;
    if (testingSystemHttpURLConnection()) {
      URL.setURLStreamHandlerFactory(null);
    } else {
      URL.setURLStreamHandlerFactory(mUrlConnectionCronetEngine.createURLStreamHandlerFactory());
    }
  }

  /**
   * Clears the {@link URL}'s {@code factory} field. This is called
   * during teardown() so as to start each test with the system's URLStreamHandler.
   */
  private void resetURLStreamHandlerFactory() {
    try {
      Field factory = URL.class.getDeclaredField("factory");
      factory.setAccessible(true);
      factory.set(null, null);
    } catch (IllegalAccessException | NoSuchFieldException e) {
      throw new RuntimeException("CronetTestRule#shutdown: factory could not be reset", e);
    }
  }

  /**
   * Annotation for test methods in org.chromium.net.urlconnection pacakage that runs them
   * against both Cronet's HttpURLConnection implementation, and against the system's
   * HttpURLConnection implementation.
   */
  @Target(ElementType.METHOD)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface CompareDefaultWithCronet {}

  /**
   * Annotation for test methods in org.chromium.net.urlconnection pacakage that runs them
   * only against Cronet's HttpURLConnection implementation, and not against the system's
   * HttpURLConnection implementation.
   */
  @Target(ElementType.METHOD)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface OnlyRunCronetHttpURLConnection {}

  /**
   * Annotation allowing classes or individual tests to be skipped based on the version of the
   * Cronet API present. Takes the minimum API version upon which the test should be run.
   * For example if a test should only be run with API version 2 or greater:
   *   @RequiresMinApi(2)
   *   public void testFoo() {}
   */
  @Target({ElementType.TYPE, ElementType.METHOD})
  @Retention(RetentionPolicy.RUNTIME)
  public @interface RequiresMinApi {
    int value();
  }

  /**
   * Annotation allowing classes or individual tests to be skipped based on the Android OS version
   * installed in the deviced used for testing. Takes the minimum API version upon which the test
   * should be run. For example if a test should only be run with Android Oreo or greater:
   *   @RequiresMinApi(Build.VERSION_CODES.O)
   *   public void testFoo() {}
   */
  @Target({ElementType.TYPE, ElementType.METHOD})
  @Retention(RetentionPolicy.RUNTIME)
  public @interface RequiresMinAndroidApi {
    int value();
  }

  /**
   * Prepares the path for the test storage (http cache, QUIC server info).
   */
  public static void prepareTestStorage() {
    File storage = new File(getTestStorageDirectory());
    if (storage.exists()) {
      Assert.assertTrue(recursiveDelete(storage));
    }
    ensureTestStorageExists();
  }

  /**
   * Returns the path for the test storage (http cache, QUIC server info).
   * Also ensures it exists.
   */
  public static String getTestStorage() {
    ensureTestStorageExists();
    return getTestStorageDirectory();
  }

  /**
   * Returns the path for the test storage (http cache, QUIC server info).
   * NOTE: Does not ensure it exists; tests should use {@link #getTestStorage}.
   */
  private static String getTestStorageDirectory() {
    return PathUtils.getDataDirectory() + "/test_storage";
  }

  /**
   * Ensures test storage directory exists, i.e. creates one if it does not exist.
   */
  private static void ensureTestStorageExists() {
    File storage = new File(getTestStorageDirectory());
    if (!storage.exists()) {
      Assert.assertTrue(storage.mkdir());
    }
  }

  private static boolean recursiveDelete(File path) {
    if (path.isDirectory()) {
      for (File c : path.listFiles()) {
        if (!recursiveDelete(c)) {
          return false;
        }
      }
    }
    return path.delete();
  }

  private void setTestingSystemHttpURLConnection(boolean value) {
    mTestingSystemHttpURLConnection = value;
  }
}
package org.chromium.net.testing;

import android.content.Context;

/**
 * Helper class to install test files.
 */
public final class TestFilesInstaller {
  // Name of the asset directory in which test files are stored.
  private static final String TEST_FILE_ASSET_PATH = "test/java/org/chromium/net/testing/data";

  /**
   * Installs test files if files have not been installed.
   */
  public static void installIfNeeded(Context context) {
    // Do nothing.
    // NOTE(pauljensen): This hook is used (overridden) when tests are run in other
    // configurations, so it should not be removed.
  }

  /**
   * Returns the installed path of the test files.
   */
  public static String getInstalledPath(Context context) {
    return UrlUtils.getIsolatedTestRoot() + "/" + TEST_FILE_ASSET_PATH;
  }

  // prevent instantiation
  private TestFilesInstaller() {}
}
package org.chromium.net.testing;

import static io.envoyproxy.envoymobile.engine.EnvoyConfiguration.TrustChainVerification.ACCEPT_UNTRUSTED;
import static org.assertj.core.api.Assertions.assertThat;
import static org.chromium.net.testing.CronetTestRule.SERVER_CERT_PEM;
import static org.chromium.net.testing.CronetTestRule.SERVER_KEY_PKCS8_PEM;

import android.content.Context;
import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import io.envoyproxy.envoymobile.AndroidEngineBuilder;
import io.envoyproxy.envoymobile.Engine;
import io.envoyproxy.envoymobile.LogLevel;
import io.envoyproxy.envoymobile.RequestHeaders;
import io.envoyproxy.envoymobile.RequestHeadersBuilder;
import io.envoyproxy.envoymobile.RequestMethod;
import io.envoyproxy.envoymobile.Stream;
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
public class AndroidEnvoyExplicitH2FlowTest {

  private Engine engine;

  @BeforeClass
  public static void loadJniLibrary() {
    AndroidJniLibrary.loadTestLibrary();
  }

  @Before
  public void setUpEngine() throws Exception {
    CountDownLatch latch = new CountDownLatch(1);
    Context appContext = ApplicationProvider.getApplicationContext();
    engine = new AndroidEngineBuilder(appContext)
                 .setTrustChainVerification(ACCEPT_UNTRUSTED)
                 .addLogLevel(LogLevel.DEBUG)
                 .setOnEngineRunning(() -> {
                   latch.countDown();
                   return null;
                 })
                 .build();
    Http2TestServer.startHttp2TestServer(appContext, SERVER_CERT_PEM, SERVER_KEY_PKCS8_PEM);
    latch.await(); // Don't launch a request before initialization has completed.
  }

  @After
  public void shutdown() throws Exception {
    engine.terminate();
    Http2TestServer.shutdownHttp2TestServer();
  }

  @Test
  public void continuousWrite_withCancelOnResponseHeaders() throws Exception {
    URL url = new URL(Http2TestServer.getEchoAllHeadersUrl());
    RequestHeadersBuilder requestHeadersBuilder = new RequestHeadersBuilder(
        RequestMethod.POST, url.getProtocol(), url.getAuthority(), url.getPath());
    RequestHeaders requestHeaders = requestHeadersBuilder.build();

    final CountDownLatch latch = new CountDownLatch(1);
    final AtomicReference<Stream> stream = new AtomicReference<>();
    final AtomicInteger bufferSent = new AtomicInteger(0);

    // Loop 100,000 times which should be long enough to wait for the server's
    // response headers to arrive.
    final int numWrites = 100000;
    stream.set(
        engine.streamClient()
            .newStreamPrototype()
            .setExplicitFlowControl(true)
            .setOnSendWindowAvailable((streamIntel -> {
              ByteBuffer bf = ByteBuffer.allocateDirect(1);
              bf.put((byte)'a');
              if (bufferSent.incrementAndGet() == numWrites) {
                stream.get().close(bf);
              } else {
                stream.get().sendData(bf);
              }
              return null;
            }))
            .setOnResponseHeaders((responseHeaders, endStream, ignored) -> {
              // This was getting executed, even in the initial test, but only
              // after all the data was sent. With the fix, this should happen
              // before all the data is sent which is checked in the assert
              // below.
              stream.get().cancel();
              return null;
            })
            .setOnCancel((ignored) -> {
              latch.countDown();
              return null;
            })
            .start(Runnable::run) // direct executor - all the logic runs on the EM Network Thread.
            .sendHeaders(requestHeaders, false));
    ByteBuffer bf = ByteBuffer.allocateDirect(1);
    bf.put((byte)'a');
    stream.get().sendData(bf);

    latch.await();

    assertThat(bufferSent.get()).isNotEqualTo(numWrites);
  }
}
package org.chromium.net.testing;

import android.util.Log;
import java.io.File;
import java.util.function.Function;

/**
 * Helper methods for dealing with Files.
 */
public final class FileUtils {
  private static final String TAG = "FileUtils";

  public static Function<String, Boolean> DELETE_ALL = filepath -> true;

  /**
   * Delete the given File and (if it's a directory) everything within it.
   * @param currentFile The file or directory to delete. Does not need to exist.
   * @param canDelete the {@link Function} function used to check if the file can be deleted.
   * @return True if the files are deleted, or files reserved by |canDelete|, false if failed to
   *         delete files.
   * @note Caveat: Return values from recursive deletes are ignored.
   * @note Caveat: |canDelete| is not robust; see https://crbug.com/1066733.
   */
  public static boolean recursivelyDeleteFile(File currentFile,
                                              Function<String, Boolean> canDelete) {
    if (!currentFile.exists()) {
      // This file could be a broken symlink, so try to delete. If we don't delete a broken
      // symlink, the directory containing it cannot be deleted.
      currentFile.delete();
      return true;
    }
    if (canDelete != null && !canDelete.apply(currentFile.getPath())) {
      return true;
    }

    if (currentFile.isDirectory()) {
      File[] files = currentFile.listFiles();
      if (files != null) {
        for (File file : files) {
          recursivelyDeleteFile(file, canDelete);
        }
      }
    }

    boolean ret = currentFile.delete();
    if (!ret) {
      Log.e(TAG, "Failed to delete: " + currentFile);
    }
    return ret;
  }

  private FileUtils() {}
}
package org.chromium.net.testing;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * Stores Reporting API reports received by a test collector, providing helper methods for checking
 * whether expected reports were actually received.
 */
final class ReportingCollector {
  private ArrayList<JSONObject> mReceivedReports = new ArrayList<JSONObject>();
  private Semaphore mReceivedReportsSemaphore = new Semaphore(0);

  /**
   * Stores a batch of uploaded reports.
   * @param payload the POST payload from the upload
   * @return whether the payload was parsed successfully
   */
  public boolean addReports(String payload) {
    try {
      JSONArray reports = new JSONArray(payload);
      int elementCount = 0;
      synchronized (mReceivedReports) {
        for (int i = 0; i < reports.length(); i++) {
          JSONObject element = reports.optJSONObject(i);
          if (element != null) {
            mReceivedReports.add(element);
            elementCount++;
          }
        }
      }
      mReceivedReportsSemaphore.release(elementCount);
      return true;
    } catch (JSONException e) {
      return false;
    }
  }

  /**
   * Checks whether a report with the given payload exists or not.
   */
  public boolean containsReport(String expected) {
    try {
      JSONObject expectedReport = new JSONObject(expected);
      synchronized (mReceivedReports) {
        for (JSONObject received : mReceivedReports) {
          if (isJSONObjectSubset(expectedReport, received)) {
            return true;
          }
        }
      }
      return false;
    } catch (JSONException e) {
      return false;
    }
  }

  /**
   * Waits until the requested number of reports have been received, with a 5-second timeout.
   */
  public void waitForReports(int reportCount) {
    final int timeoutSeconds = 5;
    try {
      mReceivedReportsSemaphore.tryAcquire(reportCount, timeoutSeconds, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
    }
  }

  /**
   * Checks whether one {@link JSONObject} is a subset of another. Any fields that appear in
   * {@code lhs} must also appear in {@code rhs}, with the same value. There can be extra fields
   * in {@code rhs}; if so, they are ignored.
   */
  private boolean isJSONObjectSubset(JSONObject lhs, JSONObject rhs) {
    Iterator<String> keys = lhs.keys();
    while (keys.hasNext()) {
      String key = keys.next();
      Object lhsElement = lhs.opt(key);
      Object rhsElement = rhs.opt(key);

      if (rhsElement == null) {
        // lhs has an element that doesn't appear in rhs
        return false;
      }

      if (lhsElement instanceof JSONObject) {
        if (!(rhsElement instanceof JSONObject)) {
          return false;
        }
        return isJSONObjectSubset((JSONObject)lhsElement, (JSONObject)rhsElement);
      }

      if (!lhsElement.equals(rhsElement)) {
        return false;
      }
    }
    return true;
  }
};
package org.chromium.net.testing;

import android.os.ConditionVariable;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.concurrent.Executor;
import org.chromium.net.UploadDataProvider;
import org.chromium.net.UploadDataSink;

/**
 * An UploadDataProvider that allows tests to invoke {@code onReadSucceeded}
 * and {@code onRewindSucceeded} on the UploadDataSink directly.
 * Chunked mode is not supported here, since the main interest is to test
 * different order of init/read/rewind calls.
 */
public final class TestDrivenDataProvider extends UploadDataProvider {
  private final Executor mExecutor;
  private final List<byte[]> mReads;
  private final ConditionVariable mWaitForReadRequest = new ConditionVariable();
  private final ConditionVariable mWaitForRewindRequest = new ConditionVariable();
  // Lock used to synchronize access to mReadPending and mRewindPending.
  private final Object mLock = new Object();

  private int mNextRead;

  // Only accessible when holding mLock.

  private boolean mReadPending;
  private boolean mRewindPending;
  private int mNumRewindCalls;
  private int mNumReadCalls;

  /**
   * Constructor.
   * @param Executor executor. Executor to run callbacks of UploadDataSink.
   * @param List<byte[]> reads. Results to be returned by successful read
   *            requests. Returned bytes must all fit within the read buffer
   *            provided by Cronet. After a rewind, if there is one, all reads
   *            will be repeated.
   */
  public TestDrivenDataProvider(Executor executor, List<byte[]> reads) {
    mExecutor = executor;
    mReads = reads;
  }

  // Called by UploadDataSink on the main thread.
  @Override
  public long getLength() {
    long length = 0;
    for (byte[] read : mReads) {
      length += read.length;
    }
    return length;
  }

  // Called by UploadDataSink on the executor thread.
  @Override
  public void read(final UploadDataSink uploadDataSink, final ByteBuffer byteBuffer)
      throws IOException {
    synchronized (mLock) {
      ++mNumReadCalls;
      assertIdle();

      mReadPending = true;
      if (mNextRead != mReads.size()) {
        if ((byteBuffer.limit() - byteBuffer.position()) < mReads.get(mNextRead).length) {
          throw new IllegalStateException("Read buffer smaller than expected.");
        }
        byteBuffer.put(mReads.get(mNextRead));
        ++mNextRead;
      } else {
        throw new IllegalStateException("Too many reads: " + mNextRead);
      }
      mWaitForReadRequest.open();
    }
  }

  // Called by UploadDataSink on the executor thread.
  @Override
  public void rewind(final UploadDataSink uploadDataSink) throws IOException {
    synchronized (mLock) {
      ++mNumRewindCalls;
      assertIdle();

      if (mNextRead == 0) {
        // Should never try and rewind when rewinding does nothing.
        throw new IllegalStateException("Unexpected rewind when already at beginning");
      }
      mRewindPending = true;
      mNextRead = 0;
      mWaitForRewindRequest.open();
    }
  }

  // Called by test fixture on the main thread.
  public void onReadSucceeded(final UploadDataSink uploadDataSink) {
    Runnable completeRunnable = new Runnable() {
      @Override
      public void run() {
        synchronized (mLock) {
          if (!mReadPending) {
            throw new IllegalStateException("No read pending.");
          }
          mReadPending = false;
          uploadDataSink.onReadSucceeded(false);
        }
      }
    };
    mExecutor.execute(completeRunnable);
  }

  // Called by test fixture on the main thread.
  public void onRewindSucceeded(final UploadDataSink uploadDataSink) {
    Runnable completeRunnable = new Runnable() {
      @Override
      public void run() {
        synchronized (mLock) {
          if (!mRewindPending) {
            throw new IllegalStateException("No rewind pending.");
          }
          mRewindPending = false;
          uploadDataSink.onRewindSucceeded();
        }
      }
    };
    mExecutor.execute(completeRunnable);
  }

  // Called by test fixture on the main thread.
  public int getNumReadCalls() {
    synchronized (mLock) { return mNumReadCalls; }
  }

  // Called by test fixture on the main thread.
  public int getNumRewindCalls() {
    synchronized (mLock) { return mNumRewindCalls; }
  }

  // Called by test fixture on the main thread.
  public void waitForReadRequest() { mWaitForReadRequest.block(); }

  // Called by test fixture on the main thread.
  public void resetWaitForReadRequest() { mWaitForReadRequest.close(); }

  // Called by test fixture on the main thread.
  public void waitForRewindRequest() { mWaitForRewindRequest.block(); }

  // Called by test fixture on the main thread.
  public void assertReadNotPending() {
    synchronized (mLock) {
      if (mReadPending) {
        throw new IllegalStateException("Read is pending.");
      }
    }
  }

  // Called by test fixture on the main thread.
  public void assertRewindNotPending() {
    synchronized (mLock) {
      if (mRewindPending) {
        throw new IllegalStateException("Rewind is pending.");
      }
    }
  }

  /**
   * Helper method to ensure no read or rewind is in progress.
   */
  private void assertIdle() {
    assertReadNotPending();
    assertRewindNotPending();
  }
}
package org.chromium.net.testing;

import android.os.StrictMode;
import java.io.Closeable;

/**
 * Enables try-with-resources compatible StrictMode violation allowlisting.
 *
 * Prefer "ignored" as the variable name to appease Android Studio's "Unused symbol" inspection.
 *
 * Example:
 * <pre>
 *     try (StrictModeContext ignored = StrictModeContext.allowDiskWrites()) {
 *         return Example.doThingThatRequiresDiskWrites();
 *     }
 * </pre>
 *
 */
public final class StrictModeContext implements Closeable {
  private final StrictMode.ThreadPolicy mThreadPolicy;
  private final StrictMode.VmPolicy mVmPolicy;

  private StrictModeContext(StrictMode.ThreadPolicy threadPolicy, StrictMode.VmPolicy vmPolicy) {
    mThreadPolicy = threadPolicy;
    mVmPolicy = vmPolicy;
  }

  private StrictModeContext(StrictMode.ThreadPolicy threadPolicy) { this(threadPolicy, null); }

  private StrictModeContext(StrictMode.VmPolicy vmPolicy) { this(null, vmPolicy); }

  /**
   * Convenience method for disabling all VM-level StrictMode checks with try-with-resources.
   * Includes everything listed here:
   *     https://developer.android.com/reference/android/os/StrictMode.VmPolicy.Builder.html
   */
  public static StrictModeContext allowAllVmPolicies() {
    StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy();
    StrictMode.setVmPolicy(StrictMode.VmPolicy.LAX);
    return new StrictModeContext(oldPolicy);
  }

  /**
   * Convenience method for disabling all thread-level StrictMode checks with try-with-resources.
   * Includes everything listed here:
   *     https://developer.android.com/reference/android/os/StrictMode.ThreadPolicy.Builder.html
   */
  public static StrictModeContext allowAllThreadPolicies() {
    StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
    StrictMode.setThreadPolicy(StrictMode.ThreadPolicy.LAX);
    return new StrictModeContext(oldPolicy);
  }

  /**
   * Convenience method for disabling StrictMode for disk-writes with try-with-resources.
   */
  public static StrictModeContext allowDiskWrites() {
    StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();
    return new StrictModeContext(oldPolicy);
  }

  /**
   * Convenience method for disabling StrictMode for disk-reads with try-with-resources.
   */
  public static StrictModeContext allowDiskReads() {
    StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
    return new StrictModeContext(oldPolicy);
  }

  /**
   * Convenience method for disabling StrictMode for slow calls with try-with-resources.
   */
  public static StrictModeContext allowSlowCalls() {
    StrictMode.ThreadPolicy oldPolicy = StrictMode.getThreadPolicy();
    StrictMode.setThreadPolicy(
        new StrictMode.ThreadPolicy.Builder(oldPolicy).permitCustomSlowCalls().build());
    return new StrictModeContext(oldPolicy);
  }

  @Override
  public void close() {
    if (mThreadPolicy != null) {
      StrictMode.setThreadPolicy(mThreadPolicy);
    }
    if (mVmPolicy != null) {
      StrictMode.setVmPolicy(mVmPolicy);
    }
  }
}
package org.chromium.net.testing;

import org.junit.Assert;

/**
 * Collection of URL utilities.
 */
public final class UrlUtils {

  /**
   * Construct the full path of a test data file.
   * @param path Pathname relative to external/
   */
  public static String getIsolatedTestFilePath(String path) {
    return getIsolatedTestRoot() + "/" + path;
  }

  /**
   * Returns the root of the test data directory.
   */
  public static String getIsolatedTestRoot() {
    try (StrictModeContext ignored = StrictModeContext.allowDiskReads()) {
      return PathUtils.getExternalStorageDirectory() + "/chromium_tests_root";
    }
  }

  /**
   * Construct a data:text/html URI for loading from an inline HTML.
   * @param html An unencoded HTML
   * @return String An URI that contains the given HTML
   */
  public static String encodeHtmlDataUri(String html) {
    try {
      // URLEncoder encodes into application/x-www-form-encoded, so
      // ' '->'+' needs to be undone and replaced with ' '->'%20'
      // to match the Data URI requirements.
      String encoded = "data:text/html;utf-8," + java.net.URLEncoder.encode(html, "UTF-8");
      encoded = encoded.replace("+", "%20");
      return encoded;
    } catch (java.io.UnsupportedEncodingException e) {
      Assert.fail("Unsupported encoding: " + e.getMessage());
      return null;
    }
  }

  private UrlUtils() {}
}
package org.chromium.net.testing;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import android.os.ConditionVariable;
import java.util.Date;
import java.util.LinkedList;
import java.util.NoSuchElementException;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import org.chromium.net.RequestFinishedInfo;
import org.chromium.net.RequestFinishedInfo.Listener;

/**
 * Classes which are useful for testing Cronet's metrics implementation and are needed in more than
 * one test file.
 */
public final class MetricsTestUtil {
  /**
   * Executor which runs tasks only when told to with runAllTasks().
   */
  public static class TestExecutor implements Executor {
    private final LinkedList<Runnable> mTaskQueue = new LinkedList<Runnable>();

    @Override
    public void execute(Runnable task) {
      mTaskQueue.add(task);
    }

    public void runAllTasks() {
      try {
        while (mTaskQueue.size() > 0) {
          mTaskQueue.remove().run();
        }
      } catch (NoSuchElementException e) {
        throw new RuntimeException("Task was removed during iteration", e);
      }
    }
  }

  /**
   * RequestFinishedInfo.Listener for testing, which saves the RequestFinishedInfo
   */
  public static class TestRequestFinishedListener extends Listener {
    private final ConditionVariable mBlock;
    private RequestFinishedInfo mRequestInfo;

    // TODO(mgersh): it's weird that you can use either this constructor or blockUntilDone() but
    // not both. Either clean it up or document why it has to work this way.
    public TestRequestFinishedListener(Executor executor) {
      super(executor);
      mBlock = new ConditionVariable();
    }

    public TestRequestFinishedListener() {
      super(Executors.newSingleThreadExecutor());
      mBlock = new ConditionVariable();
    }

    public RequestFinishedInfo getRequestInfo() { return mRequestInfo; }

    @Override
    public void onRequestFinished(RequestFinishedInfo requestInfo) {
      assertNull("onRequestFinished called repeatedly", mRequestInfo);
      assertNotNull(requestInfo);
      mRequestInfo = requestInfo;
      mBlock.open();
    }

    public void blockUntilDone() { mBlock.block(); }

    public void reset() {
      mBlock.close();
      mRequestInfo = null;
    }
  }

  // Helper method to assert date1 is equals to or after date2.
  // Some implementation of java.util.Date broke the symmetric property, so
  // check both directions.
  public static void assertAfter(Date date1, Date date2) {
    assertTrue("date1: " + date1.getTime() + ", date2: " + date2.getTime(),
               date1.after(date2) || date1.equals(date2) || date2.equals(date1));
  }

  /**
   * Check existence of all the timing metrics that apply to most test requests,
   * except those that come from net::LoadTimingInfo::ConnectTiming.
   * Also check some timing differences, focusing on things we can't check with asserts in the
   * CronetMetrics constructor.
   * Don't check push times here.
   */
  public static void checkTimingMetrics(RequestFinishedInfo.Metrics metrics, Date startTime,
                                        Date endTime) {
    assertNotNull(metrics.getRequestStart());
    assertAfter(metrics.getRequestStart(), startTime);
    assertNotNull(metrics.getSendingStart());
    assertAfter(metrics.getSendingStart(), startTime);
    assertNotNull(metrics.getSendingEnd());
    assertAfter(endTime, metrics.getSendingEnd());
    assertNotNull(metrics.getResponseStart());
    assertAfter(metrics.getResponseStart(), startTime);
    assertNotNull(metrics.getRequestEnd());
    // TODO(carloseltuerto): this goes back in time - figure out why
    // assertAfter(endTime, metrics.getRequestEnd());
    assertAfter(metrics.getRequestEnd(), metrics.getRequestStart());
  }

  /**
   * Check that the timing metrics which come from net::LoadTimingInfo::ConnectTiming exist,
   * except SSL times in the case of non-https requests.
   */
  public static void checkHasConnectTiming(RequestFinishedInfo.Metrics metrics, Date startTime,
                                           Date endTime, boolean isSsl) {
    assertNotNull(metrics.getDnsStart());
    assertAfter(metrics.getDnsStart(), startTime);
    assertNotNull(metrics.getDnsEnd());
    assertAfter(endTime, metrics.getDnsEnd());
    assertNotNull(metrics.getConnectStart());
    assertAfter(metrics.getConnectStart(), startTime);
    assertNotNull(metrics.getConnectEnd());
    assertAfter(endTime, metrics.getConnectEnd());
    if (isSsl) {
      assertNotNull(metrics.getSslStart());
      assertAfter(metrics.getSslStart(), startTime);
      assertNotNull(metrics.getSslEnd());
      assertAfter(endTime, metrics.getSslEnd());
    } else {
      assertNull(metrics.getSslStart());
      assertNull(metrics.getSslEnd());
    }
  }

  /**
   * Check that the timing metrics from net::LoadTimingInfo::ConnectTiming don't exist.
   */
  public static void checkNoConnectTiming(RequestFinishedInfo.Metrics metrics) {
    assertNull(metrics.getDnsStart());
    assertNull(metrics.getDnsEnd());
    assertNull(metrics.getSslStart());
    assertNull(metrics.getSslEnd());
    assertNull(metrics.getConnectStart());
    assertNull(metrics.getConnectEnd());
  }

  /**
   * Check that RequestFinishedInfo looks the way it should look for a normal successful request.
   */
  public static void checkRequestFinishedInfo(RequestFinishedInfo info, String url, Date startTime,
                                              Date endTime) {
    assertNotNull("RequestFinishedInfo.Listener must be called", info);
    assertEquals(url, info.getUrl());
    assertNotNull(info.getResponseInfo());
    assertNull(info.getException());
    RequestFinishedInfo.Metrics metrics = info.getMetrics();
    assertNotNull("RequestFinishedInfo.getMetrics() must not be null", metrics);
    // Check old (deprecated) timing metrics
    assertTrue(metrics.getTotalTimeMs() >= 0);
    assertTrue(metrics.getTotalTimeMs() >= metrics.getTtfbMs());
    // Check new timing metrics
    checkTimingMetrics(metrics, startTime, endTime);
    assertNull(metrics.getPushStart());
    assertNull(metrics.getPushEnd());
    // Check data use metrics
    assertTrue(metrics.getSentByteCount() > 0);
    assertTrue(metrics.getReceivedByteCount() > 0);
  }

  private MetricsTestUtil() {}
}
package org.chromium.net.testing;

import android.os.ConditionVariable;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.ClosedChannelException;
import java.util.ArrayList;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;
import org.chromium.net.UploadDataProvider;
import org.chromium.net.UploadDataSink;

/**
 * An UploadDataProvider implementation used in tests.
 */
public class TestUploadDataProvider extends UploadDataProvider {
  // Indicates whether all success callbacks are synchronous or asynchronous.
  // Doesn't apply to errors.
  public enum SuccessCallbackMode { SYNC, ASYNC }

  // Indicates whether failures should throw exceptions, invoke callbacks
  // synchronously, or invoke callback asynchronously.
  public enum FailMode { NONE, THROWN, CALLBACK_SYNC, CALLBACK_ASYNC }

  private ArrayList<byte[]> mReads = new ArrayList<byte[]>();
  private final SuccessCallbackMode mSuccessCallbackMode;
  private final Executor mExecutor;

  private boolean mChunked;

  // Index of read to fail on.
  private int mReadFailIndex = -1;
  // Indicates how to fail on a read.
  private FailMode mReadFailMode = FailMode.NONE;

  private FailMode mRewindFailMode = FailMode.NONE;

  private FailMode mLengthFailMode = FailMode.NONE;

  private int mNumReadCalls;
  private int mNumRewindCalls;

  private int mNextRead;
  private boolean mStarted;
  private boolean mReadPending;
  private boolean mRewindPending;
  // Used to ensure there are no read/rewind requests after a failure.
  private boolean mFailed;

  private AtomicBoolean mClosed = new AtomicBoolean(false);
  private ConditionVariable mAwaitingClose = new ConditionVariable(false);

  public TestUploadDataProvider(SuccessCallbackMode successCallbackMode, final Executor executor) {
    mSuccessCallbackMode = successCallbackMode;
    mExecutor = executor;
  }

  // Adds the result to be returned by a successful read request. The
  // returned bytes must all fit within the read buffer provided by Cronet.
  // After a rewind, if there is one, all reads will be repeated.
  public void addRead(byte[] read) {
    if (mStarted) {
      throw new IllegalStateException("Adding bytes after read");
    }
    mReads.add(read);
  }

  public void setReadFailure(int readFailIndex, FailMode readFailMode) {
    mReadFailIndex = readFailIndex;
    mReadFailMode = readFailMode;
  }

  public void setLengthFailure() { mLengthFailMode = FailMode.THROWN; }

  public void setRewindFailure(FailMode rewindFailMode) { mRewindFailMode = rewindFailMode; }

  public void setChunked(boolean chunked) { mChunked = chunked; }

  public int getNumReadCalls() { return mNumReadCalls; }

  public int getNumRewindCalls() { return mNumRewindCalls; }

  /**
   * Returns the cumulative length of all data added by calls to addRead.
   */
  @Override
  public long getLength() throws IOException {
    if (mClosed.get()) {
      throw new ClosedChannelException();
    }
    if (mLengthFailMode == FailMode.THROWN) {
      throw new IllegalStateException("Sync length failure");
    }
    return getUploadedLength();
  }

  public long getUploadedLength() {
    if (mChunked) {
      return -1;
    }
    long length = 0;
    for (byte[] read : mReads) {
      length += read.length;
    }
    return length;
  }

  @Override
  public void read(final UploadDataSink uploadDataSink, final ByteBuffer byteBuffer)
      throws IOException {
    int currentReadCall = mNumReadCalls;
    ++mNumReadCalls;
    if (mClosed.get()) {
      throw new ClosedChannelException();
    }
    assertIdle();

    if (maybeFailRead(currentReadCall, uploadDataSink)) {
      mFailed = true;
      return;
    }

    mReadPending = true;
    mStarted = true;

    final boolean finalChunk = (mChunked && mNextRead == mReads.size() - 1);
    if (mNextRead < mReads.size()) {
      if ((byteBuffer.limit() - byteBuffer.position()) < mReads.get(mNextRead).length) {
        throw new IllegalStateException("Read buffer smaller than expected.");
      }
      byteBuffer.put(mReads.get(mNextRead));
      ++mNextRead;
    } else {
      throw new IllegalStateException("Too many reads: " + mNextRead);
    }

    Runnable completeRunnable = new Runnable() {
      @Override
      public void run() {
        mReadPending = false;
        uploadDataSink.onReadSucceeded(finalChunk);
      }
    };
    if (mSuccessCallbackMode == SuccessCallbackMode.SYNC) {
      completeRunnable.run();
    } else {
      mExecutor.execute(completeRunnable);
    }
  }

  @Override
  public void rewind(final UploadDataSink uploadDataSink) throws IOException {
    ++mNumRewindCalls;
    if (mClosed.get()) {
      throw new ClosedChannelException();
    }
    assertIdle();

    if (maybeFailRewind(uploadDataSink)) {
      mFailed = true;
      return;
    }

    if (mNextRead == 0) {
      // Should never try and rewind when rewinding does nothing.
      throw new IllegalStateException("Unexpected rewind when already at beginning");
    }

    mRewindPending = true;
    mNextRead = 0;

    Runnable completeRunnable = new Runnable() {
      @Override
      public void run() {
        mRewindPending = false;
        uploadDataSink.onRewindSucceeded();
      }
    };
    if (mSuccessCallbackMode == SuccessCallbackMode.SYNC) {
      completeRunnable.run();
    } else {
      mExecutor.execute(completeRunnable);
    }
  }

  private void assertIdle() {
    if (mReadPending) {
      throw new IllegalStateException("Unexpected operation during read");
    }
    if (mRewindPending) {
      throw new IllegalStateException("Unexpected operation during rewind");
    }
    if (mFailed) {
      throw new IllegalStateException("Unexpected operation after failure");
    }
  }

  private boolean maybeFailRead(int readIndex, final UploadDataSink uploadDataSink) {
    if (readIndex != mReadFailIndex)
      return false;

    switch (mReadFailMode) {
    case THROWN:
      throw new IllegalStateException("Thrown read failure");
    case CALLBACK_SYNC:
      uploadDataSink.onReadError(new IllegalStateException("Sync read failure"));
      return true;
    case CALLBACK_ASYNC:
      Runnable errorRunnable = new Runnable() {
        @Override
        public void run() {
          uploadDataSink.onReadError(new IllegalStateException("Async read failure"));
        }
      };
      mExecutor.execute(errorRunnable);
      return true;
    default:
      return false;
    }
  }

  private boolean maybeFailRewind(final UploadDataSink uploadDataSink) {
    switch (mRewindFailMode) {
    case THROWN:
      throw new IllegalStateException("Thrown rewind failure");
    case CALLBACK_SYNC:
      uploadDataSink.onRewindError(new IllegalStateException("Sync rewind failure"));
      return true;
    case CALLBACK_ASYNC:
      Runnable errorRunnable = new Runnable() {
        @Override
        public void run() {
          uploadDataSink.onRewindError(new IllegalStateException("Async rewind failure"));
        }
      };
      mExecutor.execute(errorRunnable);
      return true;
    default:
      return false;
    }
  }

  @Override
  public void close() throws IOException {
    if (!mClosed.compareAndSet(false, true)) {
      throw new AssertionError("Closed twice");
    }
    mAwaitingClose.open();
  }

  public void assertClosed() {
    mAwaitingClose.block(5000);
    if (!mClosed.get()) {
      throw new AssertionError("Was not closed");
    }
  }
}
package org.chromium.net.testing;

import static io.envoyproxy.envoymobile.engine.EnvoyConfiguration.TrustChainVerification;
import static org.assertj.core.api.Assertions.assertThat;
import static org.chromium.net.testing.CronetTestRule.SERVER_CERT_PEM;
import static org.chromium.net.testing.CronetTestRule.SERVER_KEY_PKCS8_PEM;

import static org.junit.Assert.assertNotNull;
import android.content.Context;
import androidx.test.core.app.ApplicationProvider;
import io.envoyproxy.envoymobile.utilities.AndroidNetworkLibrary;
import io.envoyproxy.envoymobile.AndroidEngineBuilder;
import io.envoyproxy.envoymobile.Engine;
import io.envoyproxy.envoymobile.EnvoyError;
import io.envoyproxy.envoymobile.RequestHeaders;
import io.envoyproxy.envoymobile.RequestHeadersBuilder;
import io.envoyproxy.envoymobile.RequestMethod;
import io.envoyproxy.envoymobile.ResponseHeaders;
import io.envoyproxy.envoymobile.ResponseTrailers;
import io.envoyproxy.envoymobile.engine.AndroidJniLibrary;
import io.envoyproxy.envoymobile.engine.JniLibrary;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import io.envoyproxy.envoymobile.utilities.FakeX509Util;

@RunWith(RobolectricTestRunner.class)
public class Http2TestServerTest {

  private Engine engine;
  private String serverCertPath = SERVER_CERT_PEM;
  private String serverKeyPath = SERVER_KEY_PKCS8_PEM;

  @BeforeClass
  public static void loadJniLibrary() {
    AndroidJniLibrary.loadTestLibrary();
    JniLibrary.load();
  }

  @Before
  public void setUp() throws Exception {
    AndroidNetworkLibrary.setFakeCertificateVerificationForTesting(true);
    FakeX509Util.setExpectedHost(Http2TestServer.getServerHost());
    AndroidNetworkLibrary.addTestRootCertificate(CertTestUtil.pemToDer(serverCertPath));
  }

  public void setUpEngine(boolean enablePlatformCertificatesValidation,
                          TrustChainVerification trustChainVerification) throws Exception {
    CountDownLatch latch = new CountDownLatch(1);
    Context appContext = ApplicationProvider.getApplicationContext();
    engine = new AndroidEngineBuilder(appContext)
                 .enablePlatformCertificatesValidation(enablePlatformCertificatesValidation)
                 .setTrustChainVerification(trustChainVerification)
                 .setOnEngineRunning(() -> {
                   latch.countDown();
                   return null;
                 })
                 .build();
    Http2TestServer.startHttp2TestServer(appContext, serverCertPath, serverKeyPath);
    latch.await(); // Don't launch a request before initialization has completed.
  }

  @After
  public void shutdown() throws Exception {
    engine.terminate();
    Http2TestServer.shutdownHttp2TestServer();
    AndroidNetworkLibrary.clearTestRootCertificates();
    AndroidNetworkLibrary.setFakeCertificateVerificationForTesting(false);
  }

  private void getSchemeIsHttps(boolean enablePlatformCertificatesValidation,
                                TrustChainVerification trustChainVerification) throws Exception {
    setUpEngine(enablePlatformCertificatesValidation, trustChainVerification);

    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.GET)
                                          .setUrl(Http2TestServer.getEchoAllHeadersUrl());

    Response response = sendRequest(requestScenario);

    assertThat(response.getEnvoyError()).isNull();
    assertThat(response.getHeaders().getHttpStatus()).isEqualTo(200);
    assertThat(response.getBodyAsString()).contains(":scheme: https");
    assertThat(response.getHeaders().value("x-envoy-upstream-alpn")).containsExactly("h2");
  }

  @Test
  public void testGetRequest() throws Exception {
    getSchemeIsHttps(false, TrustChainVerification.ACCEPT_UNTRUSTED);
  }

  @Ignore
  @Test
  public void testGetRequestWithPlatformCertValidatorSuccess() throws Exception {
    getSchemeIsHttps(true, TrustChainVerification.VERIFY_TRUST_CHAIN);
  }

  @Test
  public void testGetRequestWithPlatformCertValidatorFail() throws Exception {
    // Remove any pre-installed test certs, so that following verifications will fail.
    AndroidNetworkLibrary.clearTestRootCertificates();
    setUpEngine(true, TrustChainVerification.VERIFY_TRUST_CHAIN);
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.GET)
                                          .setUrl(Http2TestServer.getEchoAllHeadersUrl());
    final CountDownLatch latch = new CountDownLatch(1);
    final AtomicReference<Response> response = new AtomicReference<>(new Response());
    engine.streamClient()
        .newStreamPrototype()
        .setOnError((error, ignored) -> {
          response.get().setEnvoyError(error);
          latch.countDown();
          return null;
        })
        .setOnCancel((ignored) -> { throw new AssertionError("Unexpected OnCancel called."); })
        .start(Executors.newSingleThreadExecutor())
        .sendHeaders(requestScenario.getHeaders(), false);

    latch.await();
    assertNotNull(response.get().getEnvoyError());
    assertThat(response.get().getEnvoyError().getErrorCode()).isEqualTo(2);
    assertThat(response.get().getEnvoyError().getMessage()).contains("CERTIFICATE_VERIFY_FAILED");
    response.get().throwAssertionErrorIfAny();
  }

  @Test
  public void testAcceptUntrustedWithPlatformCertValidator() throws Exception {
    // Remove any pre-installed test certs, so that following verifications will fail.
    AndroidNetworkLibrary.clearTestRootCertificates();
    getSchemeIsHttps(true, TrustChainVerification.ACCEPT_UNTRUSTED);
  }

  @Test
  public void testSubjectAltNameErrorWithPlatformCertValidator() throws Exception {
    // Switch to a cert which doesn't have 127.0.0.1 in the SAN list.
    serverCertPath = "../envoy/test/config/integration/certs/servercert.pem";
    serverKeyPath = "../envoy/test/config/integration/certs/serverkey.pem";
    AndroidNetworkLibrary.addTestRootCertificate(CertTestUtil.pemToDer(serverCertPath));
    setUpEngine(true, TrustChainVerification.VERIFY_TRUST_CHAIN);
    RequestScenario requestScenario = new RequestScenario()
                                          .setHttpMethod(RequestMethod.GET)
                                          .setUrl(Http2TestServer.getEchoAllHeadersUrl());
    final CountDownLatch latch = new CountDownLatch(1);
    final AtomicReference<Response> response = new AtomicReference<>(new Response());
    engine.streamClient()
        .newStreamPrototype()
        .setOnError((error, ignored) -> {
          response.get().setEnvoyError(error);
          latch.countDown();
          return null;
        })
        .setOnCancel((ignored) -> { throw new AssertionError("Unexpected OnCancel called."); })
        .start(Executors.newSingleThreadExecutor())
        .sendHeaders(requestScenario.getHeaders(), false);

    latch.await();
    assertNotNull(response.get().getEnvoyError());
    assertThat(response.get().getEnvoyError().getErrorCode()).isEqualTo(2);
    assertThat(response.get().getEnvoyError().getMessage()).contains("CERTIFICATE_VERIFY_FAILED");
    response.get().throwAssertionErrorIfAny();
  }

  @Test
  public void testSubjectAltNameErrorAllowedWithPlatformCertValidator() throws Exception {
    // Switch to a cert which doesn't have 127.0.0.1 in the SAN list.
    serverCertPath = "../envoy/test/config/integration/certs/servercert.pem";
    serverKeyPath = "../envoy/test/config/integration/certs/serverkey.pem";
    AndroidNetworkLibrary.addTestRootCertificate(CertTestUtil.pemToDer(serverCertPath));
    getSchemeIsHttps(true, TrustChainVerification.ACCEPT_UNTRUSTED);
  }

  private Response sendRequest(RequestScenario requestScenario) throws Exception {
    final CountDownLatch latch = new CountDownLatch(1);
    final AtomicReference<Response> response = new AtomicReference<>(new Response());

    engine.streamClient()
        .newStreamPrototype()
        .setOnResponseHeaders((responseHeaders, endStream, ignored) -> {
          response.get().setHeaders(responseHeaders);
          return null;
        })
        .setOnResponseData((data, endStream, ignored) -> {
          response.get().addBody(data);
          return null;
        })
        .setOnResponseTrailers((trailers, ignored) -> {
          response.get().setTrailers(trailers);
          return null;
        })
        .setOnError((error, ignored) -> {
          response.get().setEnvoyError(error);
          latch.countDown();
          return null;
        })
        .setOnCancel((ignored) -> {
          response.get().setCancelled();
          latch.countDown();
          return null;
        })
        .setOnComplete((ignore) -> {
          latch.countDown();
          return null;
        })
        .start(Executors.newSingleThreadExecutor())
        .sendHeaders(requestScenario.getHeaders(), /* hasRequestBody= */ false);

    latch.await();
    response.get().throwAssertionErrorIfAny();
    return response.get();
  }

  private static class RequestScenario {

    private URL url;
    private RequestMethod method = null;

    RequestHeaders getHeaders() {
      RequestHeadersBuilder requestHeadersBuilder =
          new RequestHeadersBuilder(method, url.getProtocol(), url.getAuthority(), url.getPath());
      return requestHeadersBuilder.build();
    }

    RequestScenario setHttpMethod(RequestMethod requestMethod) {
      this.method = requestMethod;
      return this;
    }

    RequestScenario setUrl(String url) throws MalformedURLException {
      this.url = new URL(url);
      return this;
    }
  }

  private static class Response {
    private final AtomicReference<ResponseHeaders> headers = new AtomicReference<>();
    private final AtomicReference<ResponseTrailers> trailers = new AtomicReference<>();
    private final AtomicReference<EnvoyError> envoyError = new AtomicReference<>();
    private final List<ByteBuffer> bodies = new ArrayList<>();
    private final AtomicBoolean cancelled = new AtomicBoolean(false);
    private final AtomicReference<AssertionError> assertionError = new AtomicReference<>();

    void setHeaders(ResponseHeaders headers) {
      if (!this.headers.compareAndSet(null, headers)) {
        assertionError.compareAndSet(
            null, new AssertionError("setOnResponseHeaders called more than once."));
      }
    }

    void addBody(ByteBuffer body) { bodies.add(body); }

    void setTrailers(ResponseTrailers trailers) {
      if (!this.trailers.compareAndSet(null, trailers)) {
        assertionError.compareAndSet(
            null, new AssertionError("setOnResponseTrailers called more than once."));
      }
    }

    void setEnvoyError(EnvoyError envoyError) {
      if (!this.envoyError.compareAndSet(null, envoyError)) {
        assertionError.compareAndSet(null, new AssertionError("setOnError called more than once."));
      }
    }

    void setCancelled() {
      if (!cancelled.compareAndSet(false, true)) {
        assertionError.compareAndSet(null,
                                     new AssertionError("setOnCancel called more than once."));
      }
    }

    EnvoyError getEnvoyError() { return envoyError.get(); }

    ResponseHeaders getHeaders() { return headers.get(); }

    String getBodyAsString() {
      int totalSize = bodies.stream().mapToInt(ByteBuffer::limit).sum();
      byte[] body = new byte[totalSize];
      int pos = 0;
      for (ByteBuffer buffer : bodies) {
        int bytesToRead = buffer.limit();
        buffer.get(body, pos, bytesToRead);
        pos += bytesToRead;
      }
      return new String(body);
    }

    void throwAssertionErrorIfAny() {
      if (assertionError.get() != null) {
        throw assertionError.get();
      }
    }
  }
}
package org.chromium.net.testing;

import android.content.Context;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Environment;
import android.system.Os;
import android.text.TextUtils;
import android.util.Log;
import java.io.File;
import java.util.concurrent.FutureTask;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * This class provides the path related methods for the native library.
 */
public final class PathUtils {

  private static final String TAG = "PathUtils";
  private static final String THUMBNAIL_DIRECTORY_NAME = "textures";
  private static final int DATA_DIRECTORY = 0;
  private static final int THUMBNAIL_DIRECTORY = 1;
  private static final int CACHE_DIRECTORY = 2;
  private static final int NUM_DIRECTORIES = 3;
  private static final AtomicBoolean sInitializationStarted = new AtomicBoolean();
  private static FutureTask<String[]> sDirPathFetchTask;
  // If the FutureTask started in setPrivateDataDirectorySuffix() fails to complete by the time we
  // need the values, we will need the suffix so that we can restart the task synchronously on
  // the UI thread.
  private static String sDataDirectorySuffix;
  private static String sCacheSubDirectory;
  // Prevent instantiation.
  private PathUtils() {}

  // Resetting is useful in Robolectric tests, where each test is run with a different
  // data directory.
  public static void resetForTesting() {
    sInitializationStarted.set(false);
    sDirPathFetchTask = null;
    sDataDirectorySuffix = null;
    sCacheSubDirectory = null;
  }

  /**
   * Fetch the path of the directory where private data is to be stored by the application. This
   * is meant to be called in an FutureTask in setPrivateDataDirectorySuffix(), but if we need the
   * result before the FutureTask has had a chance to finish, then it's best to cancel the task
   * and run it on the UI thread instead, inside getOrComputeDirectoryPaths().
   *
   * @see Context#getDir(String, int)
   */
  private static String[] setPrivateDataDirectorySuffixInternal() {
    String[] paths = new String[NUM_DIRECTORIES];
    Context appContext = ContextUtils.getApplicationContext();
    paths[DATA_DIRECTORY] = appContext.getDir(sDataDirectorySuffix, Context.MODE_PRIVATE).getPath();
    // MODE_PRIVATE results in rwxrwx--x, but we want rwx------, as a defence-in-depth measure.
    chmod(paths[DATA_DIRECTORY], 0700);
    paths[THUMBNAIL_DIRECTORY] =
        appContext.getDir(THUMBNAIL_DIRECTORY_NAME, Context.MODE_PRIVATE).getPath();
    if (appContext.getCacheDir() != null) {
      if (sCacheSubDirectory == null) {
        paths[CACHE_DIRECTORY] = appContext.getCacheDir().getPath();
      } else {
        File cacheDir = new File(appContext.getCacheDir(), sCacheSubDirectory);
        cacheDir.mkdir();
        paths[CACHE_DIRECTORY] = cacheDir.getPath();
        // Set to rwx--S--- as the Android cache dir has a distinct gid and is setgid.
        chmod(paths[CACHE_DIRECTORY], 02700);
      }
    }
    return paths;
  }

  /**
   * Starts an asynchronous task to fetch the path of the directory where private data is to be
   * stored by the application.
   *
   * <p>This task can run long (or more likely be delayed in a large task queue), in which case we
   * want to cancel it and run on the UI thread instead. Unfortunately, this means keeping a bit
   * of extra static state - we need to store the suffix and the application context in case we
   * need to try to re-execute later.
   *
   * @param suffix The private data directory suffix.
   * @param cacheSubDir The subdirectory in the cache directory to use, if non-null.
   * @see Context#getDir(String, int)
   */
  public static void setPrivateDataDirectorySuffix(String suffix, String cacheSubDir) {
    // This method should only be called once, but many tests end up calling it multiple times,
    // so adding a guard here.
    if (!sInitializationStarted.getAndSet(true)) {
      assert ContextUtils.getApplicationContext() != null;
      sDataDirectorySuffix = suffix;
      sCacheSubDirectory = cacheSubDir;
      // We don't use an AsyncTask because this function is called in early Webview startup
      // and it won't always have a UI thread available. Thus, we can't use AsyncTask which
      // inherently posts to the UI thread for onPostExecute().
      sDirPathFetchTask = new FutureTask<>(PathUtils::setPrivateDataDirectorySuffixInternal);
      AsyncTask.THREAD_POOL_EXECUTOR.execute(sDirPathFetchTask);
    } else {
      assert TextUtils.equals(sDataDirectorySuffix, suffix)
          : String.format("%s != %s", suffix, sDataDirectorySuffix);
      assert TextUtils.equals(sCacheSubDirectory, cacheSubDir)
          : String.format("%s != %s", cacheSubDir, sCacheSubDirectory);
    }
  }

  public static void setPrivateDataDirectorySuffix(String suffix) {
    setPrivateDataDirectorySuffix(suffix, null);
  }

  /**
   * Get the directory paths from sDirPathFetchTask if available, or compute it synchronously
   * on the UI thread otherwise. This should only be called as part of Holder's initialization
   * above to guarantee thread-safety as part of the initialization-on-demand holder idiom.
   */
  private static String[] getOrComputeDirectoryPaths() {
    if (!sDirPathFetchTask.isDone()) {
      // No-op if already ran.
      sDirPathFetchTask.run();
    }
    try {
      return sDirPathFetchTask.get();
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  /**
   * @param index The index of the cached directory path.
   * @return The directory path requested.
   */
  private static String getDirectoryPath(int index) {
    String[] paths = getOrComputeDirectoryPaths();
    return paths[index];
  }

  /**
   * @return the private directory that is used to store application data.
   */
  public static String getDataDirectory() {
    assert sDirPathFetchTask != null : "setDataDirectorySuffix must be called first.";
    return getDirectoryPath(DATA_DIRECTORY);
  }

  private static void chmod(String path, int mode) {
    // Both Os.chmod and ErrnoException require SDK >= 21. But while Dalvik on < 21 tolerates
    // Os.chmod, it throws VerifyError for ErrnoException, so catch Exception instead.
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP)
      return;
    try {
      Os.chmod(path, mode);
    } catch (Exception e) {
      Log.e(TAG, "Failed to set permissions for path \"" + path + "\"");
    }
  }

  /**
   * @return the external storage directory.
   */
  public static String getExternalStorageDirectory() {
    return Environment.getExternalStorageDirectory().getAbsolutePath();
  }
}
package org.chromium.net.testing;

import android.content.Context;
import android.os.ConditionVariable;
import android.util.Log;

import java.io.File;
import java.util.concurrent.CountDownLatch;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.handler.logging.LoggingHandler;
import io.netty.handler.ssl.ApplicationProtocolConfig;
import io.netty.handler.ssl.ApplicationProtocolConfig.Protocol;
import io.netty.handler.ssl.ApplicationProtocolConfig.SelectedListenerFailureBehavior;
import io.netty.handler.ssl.ApplicationProtocolConfig.SelectorFailureBehavior;
import io.netty.handler.ssl.ApplicationProtocolNames;
import io.netty.handler.ssl.ApplicationProtocolNegotiationHandler;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.SslContext;

/**
 * Wrapper class to start a HTTP/2 test server.
 */
public final class Http2TestServer {
  private static Channel sServerChannel;
  private static int sPort = -1;
  private static final String TAG = Http2TestServer.class.getSimpleName();

  private static final String HOST = "127.0.0.1";

  private static ReportingCollector sReportingCollector;

  public static boolean shutdownHttp2TestServer() throws Exception {
    if (sServerChannel != null) {
      sServerChannel.close().sync();
      sServerChannel = null;
      sReportingCollector = null;
      sPort = -1;
      return true;
    }
    return false;
  }

  public static String getServerHost() { return HOST; }

  public static int getServerPort() { return sPort; }

  public static String getServerUrl() { return "https://" + HOST + ":" + sPort; }

  public static ReportingCollector getReportingCollector() { return sReportingCollector; }

  public static String getEchoAllHeadersUrl() {
    return getServerUrl() + Http2TestHandler.ECHO_ALL_HEADERS_PATH;
  }

  public static String getEchoHeaderUrl(String headerName) {
    return getServerUrl() + Http2TestHandler.ECHO_HEADER_PATH + "?" + headerName;
  }

  public static String getEchoMethodUrl() {
    return getServerUrl() + Http2TestHandler.ECHO_METHOD_PATH;
  }

  /**
   * When using this you must provide a CountDownLatch in the call to startHttp2TestServer.
   * The request handler will continue to hang until the provided CountDownLatch reaches 0.
   *
   * @return url of the server resource which will hang indefinitely.
   */
  public static String getHangingRequestUrl() {
    return getServerUrl() + Http2TestHandler.HANGING_REQUEST_PATH;
  }

  /**
   * @return url of the server resource which will echo every received stream data frame.
   */
  public static String getEchoStreamUrl() {
    return getServerUrl() + Http2TestHandler.ECHO_STREAM_PATH;
  }

  /**
   * @return url of the server resource which will echo request headers as response trailers.
   */
  public static String getEchoTrailersUrl() {
    return getServerUrl() + Http2TestHandler.ECHO_TRAILERS_PATH;
  }

  /**
   * @return url of a brotli-encoded server resource.
   */
  public static String getServeSimpleBrotliResponse() {
    return getServerUrl() + Http2TestHandler.SERVE_SIMPLE_BROTLI_RESPONSE;
  }

  /**
   * @return url of the reporting collector
   */
  public static String getReportingCollectorUrl() {
    return getServerUrl() + Http2TestHandler.REPORTING_COLLECTOR_PATH;
  }

  /**
   * @return url of a resource that includes Reporting and NEL policy headers in its response
   */
  public static String getSuccessWithNELHeadersUrl() {
    return getServerUrl() + Http2TestHandler.SUCCESS_WITH_NEL_HEADERS_PATH;
  }

  /**
   * @return url of a resource that sends response headers with the same key
   */
  public static String getCombinedHeadersUrl() {
    return getServerUrl() + Http2TestHandler.COMBINED_HEADERS_PATH;
  }

  public static boolean startHttp2TestServer(Context context, String certFileName,
                                             String keyFileName) throws Exception {
    return startHttp2TestServer(context, certFileName, keyFileName, null);
  }

  public static boolean startHttp2TestServer(Context context, String certFileName,
                                             String keyFileName, CountDownLatch hangingUrlLatch)
      throws Exception {
    sReportingCollector = new ReportingCollector();
    Http2TestServerRunnable http2TestServerRunnable =
        new Http2TestServerRunnable(new File(certFileName), new File(keyFileName), hangingUrlLatch);
    new Thread(http2TestServerRunnable).start();
    http2TestServerRunnable.blockUntilStarted();
    return true;
  }

  private Http2TestServer() {}

  private static class Http2TestServerRunnable implements Runnable {
    private final ConditionVariable mBlock = new ConditionVariable();
    private final SslContext mSslCtx;
    private final CountDownLatch mHangingUrlLatch;

    Http2TestServerRunnable(File certFile, File keyFile, CountDownLatch hangingUrlLatch)
        throws Exception {
      ApplicationProtocolConfig applicationProtocolConfig = new ApplicationProtocolConfig(
          Protocol.ALPN, SelectorFailureBehavior.NO_ADVERTISE,
          SelectedListenerFailureBehavior.ACCEPT, ApplicationProtocolNames.HTTP_2);

      // Don't make netty use java.security.KeyStore.getInstance("JKS") as it doesn't
      // exist. Just avoid a KeyManagerFactory as it's unnecessary for our testing.
      System.setProperty("io.netty.handler.ssl.openssl.useKeyManagerFactory", "false");

      mSslCtx = SslContextBuilder.forServer(certFile, keyFile)
                    .applicationProtocolConfig(applicationProtocolConfig)
                    .build();

      mHangingUrlLatch = hangingUrlLatch;
    }

    public void blockUntilStarted() { mBlock.block(); }

    @Override
    public void run() {
      boolean retry = false;
      do {
        try {
          // Configure the server.
          EventLoopGroup group = new NioEventLoopGroup();
          try {
            ServerBootstrap b = new ServerBootstrap();
            b.option(ChannelOption.SO_BACKLOG, 1024);
            b.group(group)
                .channel(NioServerSocketChannel.class)
                .handler(new LoggingHandler(LogLevel.INFO))
                .childHandler(new Http2ServerInitializer(mSslCtx, mHangingUrlLatch));

            sServerChannel = b.bind(0).sync().channel();
            String localAddress = sServerChannel.localAddress().toString();
            sPort = Integer.parseInt(localAddress.substring(localAddress.lastIndexOf(':') + 1));
            Log.i(TAG, "Netty HTTP/2 server started on " + getServerUrl());
            mBlock.open();
            sServerChannel.closeFuture().sync();
          } finally {
            group.shutdownGracefully();
          }
          Log.i(TAG, "Stopped Http2TestServerRunnable!");
          retry = false;
        } catch (Exception e) {
          Log.e(TAG, "Netty server failed to start", e);
          // Retry once if we hit https://github.com/netty/netty/issues/2616 before the
          // server starts.
          retry = !retry && sServerChannel == null &&
                  e.toString().contains("java.nio.channels.ClosedChannelException");
        }
      } while (retry);
    }
  }

  /**
   * Sets up the Netty pipeline for the test server.
   */
  private static class Http2ServerInitializer extends ChannelInitializer<SocketChannel> {
    private final SslContext mSslCtx;
    private final CountDownLatch mHangingUrlLatch;

    public Http2ServerInitializer(SslContext sslCtx, CountDownLatch hangingUrlLatch) {
      mSslCtx = sslCtx;
      mHangingUrlLatch = hangingUrlLatch;
    }

    @Override
    public void initChannel(SocketChannel ch) {
      ch.pipeline().addLast(mSslCtx.newHandler(ch.alloc()),
                            new Http2NegotiationHandler(mHangingUrlLatch));
    }
  }

  private static class Http2NegotiationHandler extends ApplicationProtocolNegotiationHandler {
    private final CountDownLatch mHangingUrlLatch;

    protected Http2NegotiationHandler(CountDownLatch hangingUrlLatch) {
      super(ApplicationProtocolNames.HTTP_1_1);
      mHangingUrlLatch = hangingUrlLatch;
    }

    @Override
    protected void configurePipeline(ChannelHandlerContext ctx, String protocol) throws Exception {
      if (ApplicationProtocolNames.HTTP_2.equals(protocol)) {
        ctx.pipeline().addLast(new Http2TestHandler.Builder()
                                   .setReportingCollector(sReportingCollector)
                                   .setServerUrl(getServerUrl())
                                   .setHangingUrlLatch(mHangingUrlLatch)
                                   .build());
        return;
      }

      throw new IllegalStateException("unknown protocol: " + protocol);
    }
  }
}
package org.chromium.net.testing;

import android.app.Application;
import android.content.Context;
import android.content.ContextWrapper;
import android.content.res.AssetManager;
import android.os.Process;

/**
 * This class provides Android application context related utility methods.
 */
public final class ContextUtils {

  private static final String TAG = "ContextUtils";
  private static Context mApplicationContext;

  /**
   * Get the Android application context.
   *
   * Under normal circumstances there is only one application context in a process, so it's safe
   * to treat this as a global. In WebView it's possible for more than one app using WebView to be
   * running in a single process, but this mechanism is rarely used and this is not the only
   * problem in that scenario, so we don't currently forbid using it as a global.
   *
   * Do not downcast the context returned by this method to Application (or any subclass). It may
   * not be an Application object; it may be wrapped in a ContextWrapper. The only assumption you
   * may make is that it is a Context whose lifetime is the same as the lifetime of the process.
   */
  public static Context getApplicationContext() { return mApplicationContext; }

  /**
   * Initializes the java application context.
   *
   * This should be called exactly once early on during startup, before native is loaded and
   * before any other clients make use of the application context through this class.
   *
   * @param appContext The application context.
   */
  public static void initApplicationContext(Context appContext) {
    // Conceding that occasionally in tests, native is loaded before the browser process is
    // started, in which case the browser process re-sets the application context.
    assert mApplicationContext == null || mApplicationContext == appContext ||
        ((ContextWrapper)mApplicationContext).getBaseContext() == appContext;
    initJavaSideApplicationContext(appContext);
  }

  private static void initJavaSideApplicationContext(Context appContext) {
    assert appContext != null;
    // Guard against anyone trying to downcast.
    // TODO(carloseltureto) is this needed? if (BuildConfig.ENABLE_ASSERTS && ...
    if (appContext instanceof Application) {
      appContext = new ContextWrapper(appContext);
    }
    mApplicationContext = appContext;
  }

  /**
   * In most cases, {@link Context#getAssets()} can be used directly. Modified resources are
   * used downstream and are set up on application startup, and this method provides access to
   * regular assets before that initialization is complete.
   *
   * This method should ONLY be used for accessing files within the assets folder.
   *
   * @return Application assets.
   */
  public static AssetManager getApplicationAssets() {
    Context context = getApplicationContext();
    while (context instanceof ContextWrapper) {
      context = ((ContextWrapper)context).getBaseContext();
    }
    return context.getAssets();
  }

  /**
   * @return Whether the process is isolated.
   */
  public static boolean isIsolatedProcess() {
    // Was not made visible until Android P, but the method has always been there.
    return Process.isIsolated();
  }
}
package org.chromium.net.testing;

public enum FailurePhase {
  START,
  READ_SYNC,
  READ_ASYNC;

  @Override
  public String toString() {
    return name().toLowerCase();
  }
}
package org.chromium.net.testing;

import static io.netty.buffer.Unpooled.copiedBuffer;
import static io.netty.buffer.Unpooled.unreleasableBuffer;
import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;
import static io.netty.handler.codec.http.HttpResponseStatus.OK;
import static io.netty.handler.logging.LogLevel.INFO;

import android.util.Log;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufUtil;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.http2.AbstractHttp2ConnectionHandlerBuilder;
import io.netty.handler.codec.http2.DefaultHttp2Headers;
import io.netty.handler.codec.http2.Http2ConnectionDecoder;
import io.netty.handler.codec.http2.Http2ConnectionEncoder;
import io.netty.handler.codec.http2.Http2ConnectionHandler;
import io.netty.handler.codec.http2.Http2Exception;
import io.netty.handler.codec.http2.Http2Flags;
import io.netty.handler.codec.http2.Http2FrameListener;
import io.netty.handler.codec.http2.Http2FrameLogger;
import io.netty.handler.codec.http2.Http2Headers;
import io.netty.handler.codec.http2.Http2Settings;
import io.netty.util.CharsetUtil;

/**
 * HTTP/2 test handler for Cronet BidirectionalStream tests.
 */
public final class Http2TestHandler extends Http2ConnectionHandler implements Http2FrameListener {
  // Some Url Paths that have special meaning.
  public static final String ECHO_ALL_HEADERS_PATH = "/echoallheaders";
  public static final String ECHO_HEADER_PATH = "/echoheader";
  public static final String ECHO_METHOD_PATH = "/echomethod";
  public static final String ECHO_STREAM_PATH = "/echostream";
  public static final String ECHO_TRAILERS_PATH = "/echotrailers";
  public static final String SERVE_SIMPLE_BROTLI_RESPONSE = "/simplebrotli";
  public static final String REPORTING_COLLECTOR_PATH = "/reporting-collector";
  public static final String SUCCESS_WITH_NEL_HEADERS_PATH = "/success-with-nel";
  public static final String COMBINED_HEADERS_PATH = "/combinedheaders";
  public static final String HANGING_REQUEST_PATH = "/hanging-request";

  private static final String TAG = Http2TestHandler.class.getSimpleName();
  private static final Http2FrameLogger sLogger =
      new Http2FrameLogger(INFO, Http2TestHandler.class);
  private static final ByteBuf RESPONSE_BYTES =
      unreleasableBuffer(copiedBuffer("HTTP/2 Test Server", CharsetUtil.UTF_8));

  private HashMap<Integer, RequestResponder> mResponderMap = new HashMap<>();

  private ReportingCollector mReportingCollector;
  private String mServerUrl;
  private CountDownLatch mHangingUrlLatch;

  /**
   * Builder for HTTP/2 test handler.
   */
  public static final class Builder
      extends AbstractHttp2ConnectionHandlerBuilder<Http2TestHandler, Builder> {
    public Builder() { frameLogger(sLogger); }

    public Builder setReportingCollector(ReportingCollector reportingCollector) {
      mReportingCollector = reportingCollector;
      return this;
    }

    public Builder setServerUrl(String serverUrl) {
      mServerUrl = serverUrl;
      return this;
    }

    public Builder setHangingUrlLatch(CountDownLatch hangingUrlLatch) {
      mHangingUrlLatch = hangingUrlLatch;
      return this;
    }

    @Override
    public Http2TestHandler build() {
      return super.build();
    }

    @Override
    protected Http2TestHandler build(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,
                                     Http2Settings initialSettings) {
      Http2TestHandler handler = new Http2TestHandler(
          decoder, encoder, initialSettings, mReportingCollector, mServerUrl, mHangingUrlLatch);
      frameListener(handler);
      return handler;
    }

    private ReportingCollector mReportingCollector;
    private String mServerUrl;
    private CountDownLatch mHangingUrlLatch;
  }

  private class RequestResponder {
    void onHeadersRead(ChannelHandlerContext ctx, int streamId, boolean endOfStream,
                       Http2Headers headers) {
      encoder().writeHeaders(ctx, streamId, createResponseHeadersFromRequestHeaders(headers), 0,
                             endOfStream, ctx.newPromise());
      ctx.flush();
    }

    int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,
                   boolean endOfStream) {
      int processed = data.readableBytes() + padding;
      encoder().writeData(ctx, streamId, data.retain(), 0, true, ctx.newPromise());
      ctx.flush();
      return processed;
    }

    void sendResponseString(ChannelHandlerContext ctx, int streamId, String responseString) {
      ByteBuf content = ctx.alloc().buffer();
      ByteBufUtil.writeAscii(content, responseString);
      encoder().writeHeaders(ctx, streamId, createDefaultResponseHeaders(), 0, false,
                             ctx.newPromise());
      encoder().writeData(ctx, streamId, content, 0, true, ctx.newPromise());
      ctx.flush();
    }
  }

  private class EchoStreamResponder extends RequestResponder {
    @Override
    void onHeadersRead(ChannelHandlerContext ctx, int streamId, boolean endOfStream,
                       Http2Headers headers) {
      // Send a frame for the response headers.
      encoder().writeHeaders(ctx, streamId, createResponseHeadersFromRequestHeaders(headers), 0,
                             endOfStream, ctx.newPromise());
      ctx.flush();
    }

    @Override
    int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,
                   boolean endOfStream) {
      int processed = data.readableBytes() + padding;
      encoder().writeData(ctx, streamId, data.retain(), 0, endOfStream, ctx.newPromise());
      ctx.flush();
      return processed;
    }
  }

  private class CombinedHeadersResponder extends RequestResponder {
    @Override
    void onHeadersRead(ChannelHandlerContext ctx, int streamId, boolean endOfStream,
                       Http2Headers headers) {
      ByteBuf content = ctx.alloc().buffer();
      ByteBufUtil.writeAscii(content, "GET");
      Http2Headers responseHeaders = new DefaultHttp2Headers().status(OK.codeAsText());
      // Upon receiving, the following two headers will be jointed by '\0'.
      responseHeaders.add("foo", "bar");
      responseHeaders.add("foo", "bar2");
      encoder().writeHeaders(ctx, streamId, responseHeaders, 0, false, ctx.newPromise());
      encoder().writeData(ctx, streamId, content, 0, true, ctx.newPromise());
      ctx.flush();
    }
  }

  private class HangingRequestResponder extends RequestResponder {
    @Override
    void onHeadersRead(ChannelHandlerContext ctx, int streamId, boolean endOfStream,
                       Http2Headers headers) {
      try {
        mHangingUrlLatch.await();
      } catch (InterruptedException e) {
      }
    }
  }

  private class EchoHeaderResponder extends RequestResponder {
    @Override
    void onHeadersRead(ChannelHandlerContext ctx, int streamId, boolean endOfStream,
                       Http2Headers headers) {
      String[] splitPath = headers.path().toString().split("\\?");
      if (splitPath.length <= 1) {
        sendResponseString(ctx, streamId, "Header name not found.");
        return;
      }

      String headerName = splitPath[1].toLowerCase(Locale.US);
      if (headers.get(headerName) == null) {
        sendResponseString(ctx, streamId, "Header not found:" + headerName);
        return;
      }

      sendResponseString(ctx, streamId, headers.get(headerName).toString());
    }
  }

  private class EchoAllHeadersResponder extends RequestResponder {
    @Override
    void onHeadersRead(ChannelHandlerContext ctx, int streamId, boolean endOfStream,
                       Http2Headers headers) {
      StringBuilder response = new StringBuilder();
      for (Map.Entry<CharSequence, CharSequence> header : headers) {
        response.append(header.getKey() + ": " + header.getValue() + "\r\n");
      }
      sendResponseString(ctx, streamId, response.toString());
    }
  }

  private class EchoMethodResponder extends RequestResponder {
    @Override
    void onHeadersRead(ChannelHandlerContext ctx, int streamId, boolean endOfStream,
                       Http2Headers headers) {
      sendResponseString(ctx, streamId, headers.method().toString());
    }
  }

  private class EchoTrailersResponder extends RequestResponder {
    @Override
    void onHeadersRead(ChannelHandlerContext ctx, int streamId, boolean endOfStream,
                       Http2Headers headers) {
      encoder().writeHeaders(ctx, streamId, createDefaultResponseHeaders(), 0, false,
                             ctx.newPromise());
      encoder().writeData(ctx, streamId, RESPONSE_BYTES.duplicate(), 0, false, ctx.newPromise());
      Http2Headers responseTrailers =
          createResponseHeadersFromRequestHeaders(headers).add("trailer", "value1", "Value2");
      encoder().writeHeaders(ctx, streamId, responseTrailers, 0, true, ctx.newPromise());
      ctx.flush();
    }
  }

  // A RequestResponder that serves a simple Brotli-encoded response.
  private class ServeSimpleBrotliResponder extends RequestResponder {
    @Override
    void onHeadersRead(ChannelHandlerContext ctx, int streamId, boolean endOfStream,
                       Http2Headers headers) {
      Http2Headers responseHeaders = new DefaultHttp2Headers().status(OK.codeAsText());
      byte[] quickfoxCompressed = {0x0b, 0x15, -0x80, 0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69,
                                   0x63, 0x6b, 0x20,  0x62, 0x72, 0x6f, 0x77, 0x6e, 0x20, 0x66,
                                   0x6f, 0x78, 0x20,  0x6a, 0x75, 0x6d, 0x70, 0x73, 0x20, 0x6f,
                                   0x76, 0x65, 0x72,  0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x61,
                                   0x7a, 0x79, 0x20,  0x64, 0x6f, 0x67, 0x03};
      ByteBuf content = copiedBuffer(quickfoxCompressed);
      responseHeaders.add("content-encoding", "br");
      encoder().writeHeaders(ctx, streamId, responseHeaders, 0, false, ctx.newPromise());
      encoder().writeData(ctx, streamId, content, 0, true, ctx.newPromise());
      ctx.flush();
    }
  }

  // A RequestResponder that implements a Reporting collector.
  private class ReportingCollectorResponder extends RequestResponder {
    private ByteArrayOutputStream mPartialPayload = new ByteArrayOutputStream();

    @Override
    void onHeadersRead(ChannelHandlerContext ctx, int streamId, boolean endOfStream,
                       Http2Headers headers) {}

    @Override
    int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,
                   boolean endOfStream) {
      int processed = data.readableBytes() + padding;
      try {
        data.readBytes(mPartialPayload, data.readableBytes());
      } catch (IOException e) {
      }
      if (endOfStream) {
        processPayload(ctx, streamId);
      }
      return processed;
    }

    private void processPayload(ChannelHandlerContext ctx, int streamId) {
      boolean succeeded = false;
      try {
        String payload = mPartialPayload.toString(CharsetUtil.UTF_8.name());
        succeeded = mReportingCollector.addReports(payload);
      } catch (UnsupportedEncodingException e) {
      }
      Http2Headers responseHeaders;
      if (succeeded) {
        responseHeaders = new DefaultHttp2Headers().status(OK.codeAsText());
      } else {
        responseHeaders = new DefaultHttp2Headers().status(BAD_REQUEST.codeAsText());
      }
      encoder().writeHeaders(ctx, streamId, responseHeaders, 0, true, ctx.newPromise());
      ctx.flush();
    }
  }

  // A RequestResponder that serves a successful response with Reporting and NEL headers
  private class SuccessWithNELHeadersResponder extends RequestResponder {
    @Override
    void onHeadersRead(ChannelHandlerContext ctx, int streamId, boolean endOfStream,
                       Http2Headers headers) {
      Http2Headers responseHeaders = new DefaultHttp2Headers().status(OK.codeAsText());
      responseHeaders.add("report-to", getReportToHeader());
      responseHeaders.add("nel", getNELHeader());
      encoder().writeHeaders(ctx, streamId, responseHeaders, 0, true, ctx.newPromise());
      ctx.flush();
    }

    @Override
    int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,
                   boolean endOfStream) {
      int processed = data.readableBytes() + padding;
      return processed;
    }

    private String getReportToHeader() {
      return String.format("{\"group\": \"nel\", \"max_age\": 86400, "
                               + "\"endpoints\": [{\"url\": \"%s%s\"}]}",
                           mServerUrl, REPORTING_COLLECTOR_PATH);
    }

    private String getNELHeader() {
      return "{\"report_to\": \"nel\", \"max_age\": 86400, \"success_fraction\": 1.0}";
    }
  }

  private static Http2Headers createDefaultResponseHeaders() {
    return new DefaultHttp2Headers().status(OK.codeAsText());
  }

  private static Http2Headers createResponseHeadersFromRequestHeaders(Http2Headers requestHeaders) {
    // Create response headers by echoing request headers.
    Http2Headers responseHeaders = new DefaultHttp2Headers().status(OK.codeAsText());
    for (Map.Entry<CharSequence, CharSequence> header : requestHeaders) {
      if (!header.getKey().toString().startsWith(":")) {
        responseHeaders.add("echo-" + header.getKey(), header.getValue());
      }
    }

    responseHeaders.add("echo-method", requestHeaders.get(":method").toString());
    return responseHeaders;
  }

  private Http2TestHandler(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,
                           Http2Settings initialSettings, ReportingCollector reportingCollector,
                           String serverUrl, CountDownLatch hangingUrlLatch) {
    super(decoder, encoder, initialSettings);
    mReportingCollector = reportingCollector;
    mServerUrl = serverUrl;
    mHangingUrlLatch = hangingUrlLatch;
  }

  @Override
  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
    super.exceptionCaught(ctx, cause);
    Log.e(TAG, "An exception was caught", cause);
    ctx.close();
    throw new Exception("Exception Caught", cause);
  }

  @Override
  public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,
                        boolean endOfStream) throws Http2Exception {
    RequestResponder responder = mResponderMap.get(streamId);
    if (endOfStream) {
      mResponderMap.remove(streamId);
    }
    return responder.onDataRead(ctx, streamId, data, padding, endOfStream);
  }

  @Override
  public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers,
                            int padding, boolean endOfStream) throws Http2Exception {
    String path = headers.path().toString();
    RequestResponder responder;
    if (path.startsWith(ECHO_STREAM_PATH)) {
      responder = new EchoStreamResponder();
    } else if (path.startsWith(ECHO_TRAILERS_PATH)) {
      responder = new EchoTrailersResponder();
    } else if (path.startsWith(ECHO_ALL_HEADERS_PATH)) {
      responder = new EchoAllHeadersResponder();
    } else if (path.startsWith(ECHO_HEADER_PATH)) {
      responder = new EchoHeaderResponder();
    } else if (path.startsWith(ECHO_METHOD_PATH)) {
      responder = new EchoMethodResponder();
    } else if (path.startsWith(SERVE_SIMPLE_BROTLI_RESPONSE)) {
      responder = new ServeSimpleBrotliResponder();
    } else if (path.startsWith(REPORTING_COLLECTOR_PATH)) {
      responder = new ReportingCollectorResponder();
    } else if (path.startsWith(SUCCESS_WITH_NEL_HEADERS_PATH)) {
      responder = new SuccessWithNELHeadersResponder();
    } else if (path.startsWith(COMBINED_HEADERS_PATH)) {
      responder = new CombinedHeadersResponder();
    } else if (path.startsWith(HANGING_REQUEST_PATH)) {
      responder = new HangingRequestResponder();
    } else {
      responder = new RequestResponder();
    }

    responder.onHeadersRead(ctx, streamId, endOfStream, headers);

    if (!endOfStream) {
      mResponderMap.put(streamId, responder);
    }
  }

  @Override
  public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers,
                            int streamDependency, short weight, boolean exclusive, int padding,
                            boolean endOfStream) throws Http2Exception {
    onHeadersRead(ctx, streamId, headers, padding, endOfStream);
  }

  @Override
  public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDependency,
                             short weight, boolean exclusive) throws Http2Exception {}

  @Override
  public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode)
      throws Http2Exception {}

  @Override
  public void onSettingsAckRead(ChannelHandlerContext ctx) throws Http2Exception {}

  @Override
  public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings)
      throws Http2Exception {}

  @Override
  public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {}

  @Override
  public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {}

  @Override
  public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId,
                                Http2Headers headers, int padding) throws Http2Exception {}

  @Override
  public void onGoAwayRead(ChannelHandlerContext ctx, int lastStreamId, long errorCode,
                           ByteBuf debugData) throws Http2Exception {}

  @Override
  public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int windowSizeIncrement)
      throws Http2Exception {}

  @Override
  public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId,
                             Http2Flags flags, ByteBuf payload) throws Http2Exception {}
}
package org.chromium.net.testing;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicReference;

/**
 * Class that implements the condition variable locking paradigm.
 *
 * <p>
 * This differs from the built-in java.lang.Object wait() and notify()
 * in that this class contains the condition to wait on itself. That means
 * open(), close() and block() are sticky. If open() is called before block(),
 * block() will not block, and instead return immediately.
 *
 * <p>
 * This class uses itself as the object to wait on, so if you wait()
 * or notify() on a ConditionVariable, the results are undefined.
 *
 * <p>
 * This offers a similar API to android.os.ConditionVariable, but more suitable for test purposes.
 */
public final class ConditionVariable {

  private final AtomicReference<CountDownLatch> mCountDownLatch = new AtomicReference<>();

  public ConditionVariable() { close(); }

  public void open() {
    CountDownLatch latch = mCountDownLatch.getAndSet(null);
    if (latch != null) {
      latch.countDown();
    }
  }

  public void close() { mCountDownLatch.compareAndSet(null, new CountDownLatch(1)); }

  public void block() {
    CountDownLatch latch = mCountDownLatch.get();
    if (latch == null) {
      return;
    }
    while (true) {
      try {
        latch.await();
        return;
      } catch (InterruptedException e) {
        // Ignore
      }
    }
  }

  public boolean isBlocked() { return mCountDownLatch.get() != null; }
}
package org.chromium.net.testing;

import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
import static java.net.HttpURLConnection.HTTP_NOT_FOUND;
import static java.net.HttpURLConnection.HTTP_OK;

import android.content.Context;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import okhttp3.mockwebserver.Dispatcher;
import okhttp3.mockwebserver.MockResponse;
import okhttp3.mockwebserver.MockWebServer;
import okhttp3.mockwebserver.RecordedRequest;
import okio.Buffer;

/**
 * Wrapper class to start an in-process native test server, and get URLs needed to talk to it.
 */
public final class NativeTestServer {

  // This variable contains the response body of a request to getSuccessURL().
  public static final String SUCCESS_BODY = "this is a text file\n";

  private static final String TEST_DATA_DIRECTORY = "test/java/org/chromium/net/testing/data";

  private static final String ECHO_HEADER_PATH = "/echo_header";
  private static final String ECHO_METHOD_PATH = "/echo_method";
  private static final String ECHO_ALL_HEADERS_PATH = "/echo_all_headers";
  private static final String REDIRECT_TO_ECHO_BODY_PATH = "/redirect_to_echo_body";
  private static final String ECHO_BODY_PATH = "/echo_body";

  private static final AtomicReference<MockWebServer> mockWebServerRef = new AtomicReference<>();

  public static boolean startNativeTestServer(Context context) {
    MockWebServer mockWebServer = new MockWebServer();
    try {
      mockWebServer.start();
      if (!mockWebServerRef.compareAndSet(null, mockWebServer)) {
        mockWebServer.shutdown(); // There is one already running - this new one is not needed.
        return false;
      }
    } catch (IOException e) {
      throw new IllegalStateException(e);
    }
    mockWebServer.setDispatcher(new MockWebServerDispatcher());
    return true;
  }

  public static void shutdownNativeTestServer() {
    MockWebServer mockWebServer = mockWebServerRef.getAndSet(null);
    if (mockWebServer != null) {
      try {
        mockWebServer.shutdown();
      } catch (IOException e) {
        throw new IllegalStateException(e);
      }
    }
  }

  public static String getEchoBodyURL() { return getUrl(ECHO_BODY_PATH); }

  public static String getEchoHeaderURL(String header) {
    return getUrl(ECHO_HEADER_PATH + "?" + header);
  }

  public static String getEchoAllHeadersURL() { return getUrl(ECHO_ALL_HEADERS_PATH); }

  public static String getEchoMethodURL() { return getUrl(ECHO_METHOD_PATH); }

  public static String getRedirectToEchoBody() { return getUrl(REDIRECT_TO_ECHO_BODY_PATH); }

  public static String getFileURL(String filePath) { return getUrl(filePath); }

  // The following URLs will make NativeTestServer serve a response based on
  // the contents of the corresponding file and its mock-http-headers file.

  public static String getSuccessURL() { return getUrl("/success.txt"); }

  public static String getInternalErrorPath() { return "/internalerror.txt"; }

  public static String getInternalErrorURL() { return getUrl(getInternalErrorPath()); }

  public static String getRedirectURL() { return getUrl("/redirect.html"); }

  public static String getMultiRedirectURL() { return getUrl("/multiredirect.html"); }

  public static String getNotFoundPath() { return "/notfound.html"; }

  public static String getNotFoundURL() { return getUrl(getNotFoundPath()); }

  public static int getPort() { return mockWebServerRef.get().getPort(); }

  public static String getHostPort() { return mockWebServerRef.get().getHostName(); }

  private static String getUrl(String path) { return mockWebServerRef.get().url(path).toString(); }

  private NativeTestServer() {}

  private static class MockWebServerDispatcher extends Dispatcher {

    @Override
    public MockResponse dispatch(RecordedRequest recordedRequest) {
      String path = recordedRequest.getRequestUrl().uri().getPath();
      switch (path) {
      case ECHO_HEADER_PATH:
        String headerValue = recordedRequest.getHeader(recordedRequest.getRequestUrl().query());
        return okTextResponse(headerValue != null ? headerValue : "Header not found. :(");

      case ECHO_METHOD_PATH:
        return okTextResponse(recordedRequest.getMethod());

      case ECHO_ALL_HEADERS_PATH:
        return okTextResponse(recordedRequest.getHeaders().toString());

      case REDIRECT_TO_ECHO_BODY_PATH:
        return new MockResponse()
            .addHeader("Location", ECHO_BODY_PATH)
            .setResponseCode(HTTP_MOVED_TEMP);

      case ECHO_BODY_PATH:
        return okTextResponse("POST".equals(recordedRequest.getMethod()) ||
                                      "PUT".equals(recordedRequest.getMethod())
                                  ? recordedRequest.getBody().readUtf8()
                                  : "Request has no body. :(");

      default:
        File bodyFile = new File(TEST_DATA_DIRECTORY + path);
        if (!bodyFile.exists()) {
          return new MockResponse().setResponseCode(HTTP_NOT_FOUND);
        }
        try {
          File headerFile = new File(TEST_DATA_DIRECTORY + path + ".mock-http-headers");
          List<String> lines = readLines(headerFile);
          MockResponse mockResponse = new MockResponse().setBody(readBuffer(bodyFile));
          for (String headerLine : lines.subList(1, lines.size())) {
            mockResponse.addHeader(headerLine);
          }
          return mockResponse.setStatus(lines.get(0));
        } catch (Exception e) {
          e.printStackTrace();
          return new MockResponse().setResponseCode(HTTP_NOT_FOUND);
        }
      }
    }

    private static List<String> readLines(File file) {
      List<String> lines = new ArrayList<>();
      try (BufferedReader br = new BufferedReader(new FileReader(file))) {
        String line;
        while ((line = br.readLine()) != null) {
          lines.add(line);
        }
      } catch (IOException e) {
        throw new IllegalStateException(e);
      }
      return lines;
    }

    private static Buffer readBuffer(File file) {
      try {
        return new Buffer().readFrom(new FileInputStream(file));
      } catch (IOException e) {
        throw new IllegalStateException(e);
      }
    }

    private static MockResponse okTextResponse(String text) {
      return new MockResponse()
          .addHeader("Connection", "close")
          .setBody(text)
          .setHeader("Content-Type", "text/plain")
          .setResponseCode(HTTP_OK);
    }
  }
}
load("@build_bazel_rules_android//android:rules.bzl", "android_library")
load("@envoy//bazel:envoy_build_system.bzl", "envoy_mobile_package")
load("@envoy_mobile//bazel:kotlin_test.bzl", "envoy_mobile_android_test")

licenses(["notice"])  # Apache 2

envoy_mobile_package()

android_library(
    name = "testing",
    srcs = [
        "CertTestUtil.java",
        "ConditionVariable.java",
        "ContextUtils.java",
        "CronetTestRule.java",
        "CronetTestUtil.java",
        "FailurePhase.java",
        "Feature.java",
        "FileUtils.java",
        "Http2TestHandler.java",
        "Http2TestServer.java",
        "MetricsTestUtil.java",
        "MockUrlRequestJobFactory.java",
        "NativeTestServer.java",
        "PathUtils.java",
        "ReportingCollector.java",
        "StrictModeContext.java",
        "TestBidirectionalStreamCallback.java",
        "TestFilesInstaller.java",
        "TestUploadDataProvider.java",
        "TestUrlRequestCallback.java",
        "UrlUtils.java",
    ],
    data = glob(["data/*"]) + ["@envoy//test/config/integration/certs"],
    visibility = ["//test:__subpackages__"],
    deps = [
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/utilities",
        "//library/java/org/chromium/net",
        "//library/java/org/chromium/net/impl:cronvoy",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
        "@maven//:androidx_annotation_annotation",
        "@maven//:androidx_test_monitor",
        "@maven//:com_squareup_okhttp3_mockwebserver",
        "@maven//:com_squareup_okio_okio_jvm",
        "@maven//:io_netty_netty_buffer",
        "@maven//:io_netty_netty_codec_http",
        "@maven//:io_netty_netty_codec_http2",
        "@maven//:io_netty_netty_common",
        "@maven//:io_netty_netty_handler",
        "@maven//:io_netty_netty_transport",
        "@maven//:junit_junit",
    ],
)

envoy_mobile_android_test(
    name = "cronet_test_rule_test",
    srcs = [
        "CronetTestRuleTest.java",
    ],
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        ":testing",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_base_engine_lib",
        "//library/java/io/envoyproxy/envoymobile/engine:envoy_engine_lib",
        "//library/java/org/chromium/net/impl:cronvoy",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_interfaces_lib",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
    ],
)

envoy_mobile_android_test(
    name = "http2_test_server_test",
    srcs = [
        "Http2TestServerTest.java",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        ":testing",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
    ],
)

envoy_mobile_android_test(
    name = "temporary_test",
    srcs = [
        "AndroidEnvoyExplicitH2FlowTest.java",
    ],
    exec_properties = {
        # TODO(lfpino): Remove this once the sandboxNetwork=off works for ipv4 localhost addresses.
        "sandboxNetwork": "standard",
    },
    native_deps = [
        "//test/common/jni:libenvoy_jni_with_test_extensions.so",
    ] + select({
        "@platforms//os:macos": [
            "//test/common/jni:libenvoy_jni_with_test_extensions_jnilib",
        ],
        "//conditions:default": [],
    }),
    native_lib_name = "envoy_jni_with_test_extensions",
    deps = [
        ":testing",
        "//library/kotlin/io/envoyproxy/envoymobile:envoy_lib",
    ],
)
package org.chromium.net.testing;

import org.chromium.net.ExperimentalCronetEngine;
import org.chromium.net.impl.NativeCronvoyEngineBuilderImpl;

/**
 * Utilities for Cronet testing
 */
public final class CronetTestUtil {

  public static void setMockCertVerifierForTesting(ExperimentalCronetEngine.Builder builder) {
    getCronetEngineBuilderImpl(builder).setMockCertVerifierForTesting();
  }

  public static NativeCronvoyEngineBuilderImpl
  getCronetEngineBuilderImpl(ExperimentalCronetEngine.Builder builder) {
    return (NativeCronvoyEngineBuilderImpl)builder.getBuilderDelegate();
  }

  public static boolean nativeCanGetTaggedBytes() {
    return false; // TODO(carloseltuerto) implement
  }

  public static long nativeGetTaggedBytes(int tag) {
    return 0; // TODO(carloseltuerto) implement
  }

  private CronetTestUtil() {}
}
HTTP/1.1 200 OK
Content-Type: text/plain
HTTP/1.1 200 OK
Content-Encoding: gzip
foo: bar
<!DOCTYPE html>
<html>
<head>
<title>Redirect</title>
<p>Redirecting...</p>
</head>
</html>
<!DOCTYPE html>
<html>
<head>
<title>Redirect</title>
<p>Redirecting...</p>
</head>
</html>
HTTP/1.1 302 Found
Location: /success.txt
redirect-header: header-value
<!DOCTYPE html>
<html>
<head>
<title>Not found</title>
<p>Test page loaded.</p>
</head>
</html>
HTTP/1.1 404 Not Found
HTTP/1.1 200 OK
Set-Cookie: A=B
<!DOCTYPE html>
<html>
<head>
<title>Redirect</title>
<p>Redirecting...</p>
</head>
</html>
HTTP/1.1 500 Internal Server Error
 rV HQ/IQ J   HTTP/1.1 302 Found
Location: https://127.0.0.1:8000/success.txt
redirect-header: header-value
Something went wrong
HTTP/1.1 200 OK
Content-Type: text/plain
Access-Control-Allow-Origin: *
header-name: header-value
multi-header-name: header-value1
multi-header-name: header-value2
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1000000
HTTP/1.1 302 Found
Location: /redirect.html
redirect-header0: header-value
<!DOCTYPE html>
<html>
<head>
<title>Redirect</title>
<p>Redirecting...</p>
</head>
</html>
hello!
HTTP/1.1 200 OK
Content-Type: text/plain
Cache-Control: max-age=300
Response that lies about content length.

this is a cacheable file
this is a text file
OK
HTTP/1.1 302 Found
package org.chromium.net.testing;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import org.chromium.net.impl.CronvoyUrlRequestContext;
import org.chromium.net.testing.CronetTestRule.CronetTestFramework;
import org.chromium.net.testing.CronetTestRule.RequiresMinApi;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;
import org.junit.runner.RunWith;

/**
 * Tests features of CronetTestRule.
 */
@RunWith(AndroidJUnit4.class)
public class CronetTestRuleTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();
  @Rule public final TestName mTestName = new TestName();

  private CronetTestFramework mTestFramework;
  /**
   * For any test whose name contains "MustRun", it's enforced that the test must run and set
   * {@code mTestWasRun} to {@code true}.
   */
  private boolean mTestWasRun;

  @Before
  public void setUp() {
    mTestWasRun = false;
    mTestFramework = mTestRule.startCronetTestFramework();
  }

  @After
  public void tearDown() throws Exception {
    if (mTestName.getMethodName().contains("MustRun") && !mTestWasRun) {
      fail(mTestName.getMethodName() + " should have run but didn't.");
    }
  }

  @Test
  @SmallTest
  @RequiresMinApi(999999999)
  @Feature({"Cronet"})
  public void testRequiresMinApiDisable() {
    fail("RequiresMinApi failed to disable.");
  }

  @Test
  @SmallTest
  @RequiresMinApi(-999999999)
  @Feature({"Cronet"})
  public void testRequiresMinApiMustRun() {
    mTestWasRun = true;
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testRunOnlyNativeMustRun() {
    assertFalse(mTestWasRun);
    mTestWasRun = true;
    assertEquals(mTestFramework.mCronetEngine.getClass(), CronvoyUrlRequestContext.class);
  }
}
package org.chromium.net.testing;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * The java instrumentation tests are normally fairly large (in terms of
 * dependencies), and the test suite ends up containing a large amount of
 * tests that are not trivial to filter / group just by their names.
 * Instead, we use this annotation: each test should be annotated as:
 *     @Feature({"Foo", "Bar"})
 * in order for the test runner scripts to be able to filter and group
 * them accordingly (for instance, this enable us to run all tests that exercise
 * feature Foo).
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Feature {
  /**
   * @return A list of feature names.
   */
  String[] value();
}
package org.chromium.net.testing;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertFalse;
import static junit.framework.Assert.assertNotSame;
import static junit.framework.Assert.assertNull;
import static junit.framework.Assert.assertTrue;

import org.chromium.net.BidirectionalStream;
import org.chromium.net.CronetException;
import org.chromium.net.UrlResponseInfo;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;

/**
 * Callback that tracks information from different callbacks and and has a
 * method to block thread until the stream completes on another thread.
 * Allows to cancel, block stream or throw an exception from an arbitrary step.
 */
public class TestBidirectionalStreamCallback extends BidirectionalStream.Callback {
  public UrlResponseInfo mResponseInfo;
  public CronetException mError;

  public ResponseStep mResponseStep = ResponseStep.NOTHING;

  public boolean mOnErrorCalled;
  public boolean mOnCanceledCalled;

  public int mHttpResponseDataLength;
  public String mResponseAsString = "";

  public UrlResponseInfo.HeaderBlock mTrailers;

  private static final int READ_BUFFER_SIZE = 32 * 1024;

  // When false, the consumer is responsible for all calls into the stream
  // that advance it.
  private boolean mAutoAdvance = true;

  // Conditionally fail on certain steps.
  private FailureType mFailureType = FailureType.NONE;
  private ResponseStep mFailureStep = ResponseStep.NOTHING;

  // Signals when the stream is done either successfully or not.
  private final ConditionVariable mDone = new ConditionVariable();

  // Signaled on each step when mAutoAdvance is false.
  private final ConditionVariable mReadStepBlock = new ConditionVariable();
  private final ConditionVariable mWriteStepBlock = new ConditionVariable();

  // Executor Service for Cronet callbacks.
  private final ExecutorService mExecutorService =
      Executors.newSingleThreadExecutor(new ExecutorThreadFactory());
  private Thread mExecutorThread;

  // position() of ByteBuffer prior to read() call.
  private int mBufferPositionBeforeRead;

  // Data to write.
  private final ArrayList<WriteBuffer> mWriteBuffers = new ArrayList<>();

  // Buffers that we yet to receive the corresponding onWriteCompleted callback.
  private final ArrayList<WriteBuffer> mWriteBuffersToBeAcked = new ArrayList<>();

  // Whether to use a direct executor.
  private final boolean mUseDirectExecutor;
  private final DirectExecutor mDirectExecutor;

  private class ExecutorThreadFactory implements ThreadFactory {
    @Override
    public Thread newThread(Runnable r) {
      mExecutorThread = new Thread(r);
      return mExecutorThread;
    }
  }

  private static class WriteBuffer {
    final ByteBuffer mBuffer;
    final boolean mFlush;
    public WriteBuffer(ByteBuffer buffer, boolean flush) {
      mBuffer = buffer;
      mFlush = flush;
    }
  }

  private static class DirectExecutor implements Executor {
    @Override
    public void execute(Runnable task) {
      task.run();
    }
  }

  public enum ResponseStep {
    NOTHING,
    ON_STREAM_READY,
    ON_RESPONSE_STARTED,
    ON_READ_COMPLETED,
    ON_WRITE_COMPLETED,
    ON_TRAILERS,
    ON_CANCELED,
    ON_FAILED,
    ON_SUCCEEDED,
  }

  public enum FailureType {
    NONE,
    CANCEL_SYNC,
    CANCEL_ASYNC,
    // Same as above, but continues to advance the stream after posting
    // the cancellation task.
    CANCEL_ASYNC_WITHOUT_PAUSE,
    THROW_SYNC
  }

  public TestBidirectionalStreamCallback() {
    mUseDirectExecutor = false;
    mDirectExecutor = null;
  }

  public TestBidirectionalStreamCallback(boolean useDirectExecutor) {
    mUseDirectExecutor = useDirectExecutor;
    mDirectExecutor = new DirectExecutor();
  }

  public void setAutoAdvance(boolean autoAdvance) { mAutoAdvance = autoAdvance; }

  public void setFailure(FailureType failureType, ResponseStep failureStep) {
    mFailureStep = failureStep;
    mFailureType = failureType;
  }

  public void blockForDone() { mDone.block(); }

  public void waitForNextReadStep() {
    mReadStepBlock.block();
    mReadStepBlock.close();
  }

  public void waitForNextWriteStep() {
    mWriteStepBlock.block();
    mWriteStepBlock.close();
  }

  public Executor getExecutor() {
    if (mUseDirectExecutor) {
      return mDirectExecutor;
    }
    return mExecutorService;
  }

  public void shutdownExecutor() {
    if (mUseDirectExecutor) {
      throw new UnsupportedOperationException("DirectExecutor doesn't support shutdown");
    }
    mExecutorService.shutdown();
  }

  public void addWriteData(byte[] data) { addWriteData(data, true); }

  public void addWriteData(byte[] data, boolean flush) {
    ByteBuffer writeBuffer = ByteBuffer.allocateDirect(data.length);
    writeBuffer.put(data);
    writeBuffer.flip();
    mWriteBuffers.add(new WriteBuffer(writeBuffer, flush));
    mWriteBuffersToBeAcked.add(new WriteBuffer(writeBuffer, flush));
  }

  @Override
  public void onStreamReady(BidirectionalStream stream) {
    checkOnValidThread();
    assertFalse(stream.isDone());
    assertEquals(ResponseStep.NOTHING, mResponseStep);
    assertNull(mError);
    mResponseStep = ResponseStep.ON_STREAM_READY;
    if (maybeThrowCancelOrPause(stream, mWriteStepBlock)) {
      return;
    }
    startNextWrite(stream);
  }

  @Override
  public void onResponseHeadersReceived(BidirectionalStream stream, UrlResponseInfo info) {
    checkOnValidThread();
    assertFalse(stream.isDone());
    assertTrue(mResponseStep == ResponseStep.NOTHING ||
               mResponseStep == ResponseStep.ON_STREAM_READY ||
               mResponseStep == ResponseStep.ON_WRITE_COMPLETED);
    assertNull(mError);

    mResponseStep = ResponseStep.ON_RESPONSE_STARTED;
    mResponseInfo = info;
    if (maybeThrowCancelOrPause(stream, mReadStepBlock)) {
      return;
    }
    startNextRead(stream);
  }

  @Override
  public void onReadCompleted(BidirectionalStream stream, UrlResponseInfo info,
                              ByteBuffer byteBuffer, boolean endOfStream) {
    checkOnValidThread();
    assertFalse(stream.isDone());
    assertTrue(mResponseStep == ResponseStep.ON_RESPONSE_STARTED ||
               mResponseStep == ResponseStep.ON_READ_COMPLETED ||
               mResponseStep == ResponseStep.ON_WRITE_COMPLETED ||
               mResponseStep == ResponseStep.ON_TRAILERS);
    assertNull(mError);

    mResponseStep = ResponseStep.ON_READ_COMPLETED;
    mResponseInfo = info;

    final int bytesRead = byteBuffer.position() - mBufferPositionBeforeRead;
    mHttpResponseDataLength += bytesRead;
    final byte[] lastDataReceivedAsBytes = new byte[bytesRead];
    // Rewind byteBuffer.position() to pre-read() position.
    byteBuffer.position(mBufferPositionBeforeRead);
    // This restores byteBuffer.position() to its value on entrance to
    // this function.
    byteBuffer.get(lastDataReceivedAsBytes);

    mResponseAsString += new String(lastDataReceivedAsBytes);

    if (maybeThrowCancelOrPause(stream, mReadStepBlock)) {
      return;
    }
    // Do not read if EOF has been reached.
    if (!endOfStream) {
      startNextRead(stream);
    }
  }

  @Override
  public void onWriteCompleted(BidirectionalStream stream, UrlResponseInfo info, ByteBuffer buffer,
                               boolean endOfStream) {
    checkOnValidThread();
    assertFalse(stream.isDone());
    assertNull(mError);
    mResponseStep = ResponseStep.ON_WRITE_COMPLETED;
    mResponseInfo = info;
    if (!mWriteBuffersToBeAcked.isEmpty()) {
      assertEquals(buffer, mWriteBuffersToBeAcked.get(0).mBuffer);
      mWriteBuffersToBeAcked.remove(0);
    }
    if (maybeThrowCancelOrPause(stream, mWriteStepBlock)) {
      return;
    }
    startNextWrite(stream);
  }

  @Override
  public void onResponseTrailersReceived(BidirectionalStream stream, UrlResponseInfo info,
                                         UrlResponseInfo.HeaderBlock trailers) {
    checkOnValidThread();
    assertFalse(stream.isDone());
    assertNull(mError);
    mResponseStep = ResponseStep.ON_TRAILERS;
    mResponseInfo = info;
    mTrailers = trailers;
    maybeThrowCancelOrPause(stream, mReadStepBlock);
  }

  @Override
  public void onSucceeded(BidirectionalStream stream, UrlResponseInfo info) {
    checkOnValidThread();
    assertTrue(stream.isDone());
    assertTrue(mResponseStep == ResponseStep.ON_RESPONSE_STARTED ||
               mResponseStep == ResponseStep.ON_READ_COMPLETED ||
               mResponseStep == ResponseStep.ON_WRITE_COMPLETED ||
               mResponseStep == ResponseStep.ON_TRAILERS);
    assertFalse(mOnErrorCalled);
    assertFalse(mOnCanceledCalled);
    assertNull(mError);
    assertEquals(0, mWriteBuffers.size());
    assertEquals(0, mWriteBuffersToBeAcked.size());

    mResponseStep = ResponseStep.ON_SUCCEEDED;
    mResponseInfo = info;
    openDone();
    maybeThrowCancelOrPause(stream, mReadStepBlock);
  }

  @Override
  public void onFailed(BidirectionalStream stream, UrlResponseInfo info, CronetException error) {
    checkOnValidThread();
    assertTrue(stream.isDone());
    // Shouldn't happen after success.
    assertNotSame(mResponseStep, ResponseStep.ON_SUCCEEDED);
    // Should happen at most once for a single stream.
    assertFalse(mOnErrorCalled);
    assertFalse(mOnCanceledCalled);
    assertNull(mError);
    mResponseStep = ResponseStep.ON_FAILED;
    mResponseInfo = info;

    mOnErrorCalled = true;
    mError = error;
    openDone();
    maybeThrowCancelOrPause(stream, mReadStepBlock);
  }

  @Override
  public void onCanceled(BidirectionalStream stream, UrlResponseInfo info) {
    checkOnValidThread();
    assertTrue(stream.isDone());
    // Should happen at most once for a single stream.
    assertFalse(mOnCanceledCalled);
    assertFalse(mOnErrorCalled);
    assertNull(mError);
    mResponseStep = ResponseStep.ON_CANCELED;
    mResponseInfo = info;

    mOnCanceledCalled = true;
    openDone();
    maybeThrowCancelOrPause(stream, mReadStepBlock);
  }

  public void startNextRead(BidirectionalStream stream) {
    startNextRead(stream, ByteBuffer.allocateDirect(READ_BUFFER_SIZE));
  }

  public void startNextRead(BidirectionalStream stream, ByteBuffer buffer) {
    mBufferPositionBeforeRead = buffer.position();
    stream.read(buffer);
  }

  public void startNextWrite(BidirectionalStream stream) {
    if (!mWriteBuffers.isEmpty()) {
      Iterator<WriteBuffer> iterator = mWriteBuffers.iterator();
      while (iterator.hasNext()) {
        WriteBuffer b = iterator.next();
        stream.write(b.mBuffer, !iterator.hasNext());
        iterator.remove();
        if (b.mFlush) {
          stream.flush();
          break;
        }
      }
    }
  }

  public boolean isDone() { return !mDone.isBlocked(); }

  /**
   * Returns the number of pending Writes.
   */
  public int numPendingWrites() { return mWriteBuffers.size(); }

  protected void openDone() { mDone.open(); }

  /**
   * Returns {@code false} if the callback should continue to advance the
   * stream.
   */
  private boolean maybeThrowCancelOrPause(final BidirectionalStream stream,
                                          ConditionVariable stepBlock) {
    if (mResponseStep != mFailureStep || mFailureType == FailureType.NONE) {
      if (!mAutoAdvance) {
        stepBlock.open();
        return true;
      }
      return false;
    }

    if (mFailureType == FailureType.THROW_SYNC) {
      throw new IllegalStateException("Callback Exception.");
    }
    Runnable task = new Runnable() {
      @Override
      public void run() {
        stream.cancel();
      }
    };
    if (mFailureType == FailureType.CANCEL_ASYNC ||
        mFailureType == FailureType.CANCEL_ASYNC_WITHOUT_PAUSE) {
      getExecutor().execute(task);
    } else {
      task.run();
    }
    return mFailureType != FailureType.CANCEL_ASYNC_WITHOUT_PAUSE;
  }

  /**
   * Checks whether callback methods are invoked on the correct thread.
   */
  private void checkOnValidThread() {
    if (!mUseDirectExecutor) {
      assertEquals(mExecutorThread, Thread.currentThread());
    }
  }
}
package org.chromium.net.testing;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertFalse;
import static junit.framework.Assert.assertNotNull;
import static junit.framework.Assert.assertNull;
import static junit.framework.Assert.assertTrue;
import static org.chromium.net.testing.CronetTestRule.assertContains;

import android.os.StrictMode;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import org.chromium.net.CallbackException;
import org.chromium.net.CronetException;
import org.chromium.net.InlineExecutionProhibitedException;
import org.chromium.net.UrlRequest;
import org.chromium.net.UrlResponseInfo;

/**
 * Callback that tracks information from different callbacks and and has a method to block thread
 * until the request completes on another thread. Allows to cancel, block request or throw an
 * exception from an arbitrary step.
 */
public class TestUrlRequestCallback extends UrlRequest.Callback {

  public ArrayList<UrlResponseInfo> mRedirectResponseInfoList = new ArrayList<UrlResponseInfo>();
  public ArrayList<String> mRedirectUrlList = new ArrayList<String>();
  public UrlResponseInfo mResponseInfo;
  public CronetException mError;

  public ResponseStep mResponseStep = ResponseStep.NOTHING;

  public int mRedirectCount;
  public boolean mOnErrorCalled;
  public boolean mOnCanceledCalled;

  public int mHttpResponseDataLength;
  public String mResponseAsString = "";

  public int mReadBufferSize = 32 * 1024;

  // When false, the consumer is responsible for all calls into the request
  // that advance it.
  private boolean mAutoAdvance = true;
  // Whether an exception is thrown by maybeThrowCancelOrPause().
  private boolean mCallbackExceptionThrown;

  // Whether to permit calls on the network thread.
  private boolean mAllowDirectExecutor;

  // Conditionally fail on certain steps.
  private FailureType mFailureType = FailureType.NONE;
  private ResponseStep mFailureStep = ResponseStep.NOTHING;

  // Signals when request is done either successfully or not.
  private final ConditionVariable mDone;

  // Signaled on each step when mAutoAdvance is false.
  private final ConditionVariable mStepBlock = new ConditionVariable();

  // Executor Service for Cronet callbacks.
  private final ExecutorService mExecutorService;
  private Thread mExecutorThread;

  // position() of ByteBuffer prior to read() call.
  private int mBufferPositionBeforeRead;

  private final AtomicReference<Throwable> mThrowableRef;

  private static class ExecutorThreadFactory implements ThreadFactory {

    private final ConditionVariable mDone;
    private final AtomicReference<Throwable> mThrowableRef;

    ExecutorThreadFactory(ConditionVariable mDone, AtomicReference<Throwable> mThrowableRef) {
      this.mDone = mDone;
      this.mThrowableRef = mThrowableRef;
    }

    @Override
    public Thread newThread(final Runnable r) {
      Thread thread = new Thread(() -> {
        StrictMode.ThreadPolicy threadPolicy = StrictMode.getThreadPolicy();
        try {
          StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
                                         .detectNetwork()
                                         .penaltyLog()
                                         .penaltyDeath()
                                         .build());
          r.run();
        } finally {
          StrictMode.setThreadPolicy(threadPolicy);
        }
      });
      thread.setUncaughtExceptionHandler((unused, throwable) -> {
        mThrowableRef.set(throwable);
        mDone.open();
      });
      return thread;
    }
  }

  public enum ResponseStep {
    NOTHING,
    ON_RECEIVED_REDIRECT,
    ON_RESPONSE_STARTED,
    ON_READ_COMPLETED,
    ON_SUCCEEDED,
    ON_FAILED,
    ON_CANCELED,
  }

  public enum FailureType {
    NONE,
    CANCEL_SYNC,
    CANCEL_ASYNC,
    // Same as above, but continues to advance the request after posting
    // the cancellation task.
    CANCEL_ASYNC_WITHOUT_PAUSE,
    THROW_SYNC
  }

  /**
   * Set {@code mExecutorThread}.
   */
  private void fillInExecutorThread() {
    mExecutorService.execute(new Runnable() {
      @Override
      public void run() {
        mExecutorThread = Thread.currentThread();
      }
    });
  }

  private TestUrlRequestCallback(ExecutorService executorService, ConditionVariable done,
                                 AtomicReference<Throwable> throwableRef) {
    this.mExecutorService = executorService;
    this.mDone = done;
    this.mThrowableRef = throwableRef;
    fillInExecutorThread();
  }

  private TestUrlRequestCallback(ConditionVariable done, AtomicReference<Throwable> throwableRef) {
    this(Executors.newSingleThreadExecutor(new ExecutorThreadFactory(done, throwableRef)), done,
         throwableRef);
  }

  /**
   * Create a {@link TestUrlRequestCallback} with a new single-threaded executor.
   */
  public TestUrlRequestCallback() { this(new ConditionVariable(), new AtomicReference<>()); }

  /**
   * Create a {@link TestUrlRequestCallback} using a custom single-threaded executor.
   * NOTE(pauljensen): {@code executorService} should be a new single-threaded executor.
   */
  public TestUrlRequestCallback(ExecutorService executorService) {
    this(executorService, new ConditionVariable(), new AtomicReference<>());
  }

  public void setAutoAdvance(boolean autoAdvance) { mAutoAdvance = autoAdvance; }

  public void setAllowDirectExecutor(boolean allowed) { mAllowDirectExecutor = allowed; }

  public void setFailure(FailureType failureType, ResponseStep failureStep) {
    mFailureStep = failureStep;
    mFailureType = failureType;
  }

  public void blockForDone() {
    mDone.block();
    if (mThrowableRef.get() != null) {
      if (mThrowableRef.get() instanceof Error) {
        throw(Error) mThrowableRef.get();
      }
      if (mThrowableRef.get() instanceof RuntimeException) {
        throw(RuntimeException) mThrowableRef.get();
      }
      throw new RuntimeException(mThrowableRef.get());
    }
  }

  public void waitForNextStep() {
    mStepBlock.block();
    mStepBlock.close();
  }

  public ExecutorService getExecutor() { return mExecutorService; }

  public void shutdownExecutor() { mExecutorService.shutdown(); }

  /**
   * Shuts down the ExecutorService and waits until it executes all posted tasks.
   */
  public void shutdownExecutorAndWait() {
    mExecutorService.shutdown();
    try {
      // Termination shouldn't take long. Use 1 min which should be more than enough.
      mExecutorService.awaitTermination(1, TimeUnit.MINUTES);
    } catch (InterruptedException e) {
      assertTrue("ExecutorService is interrupted while waiting for termination", false);
    }
    assertTrue(mExecutorService.isTerminated());
  }

  @Override
  public void onRedirectReceived(UrlRequest request, UrlResponseInfo info, String newLocationUrl) {
    checkExecutorThread();
    assertFalse(request.isDone());
    assertTrue(mResponseStep == ResponseStep.NOTHING ||
               mResponseStep == ResponseStep.ON_RECEIVED_REDIRECT);
    assertNull(mError);

    mResponseStep = ResponseStep.ON_RECEIVED_REDIRECT;
    mRedirectUrlList.add(newLocationUrl);
    mRedirectResponseInfoList.add(info);
    ++mRedirectCount;
    if (maybeThrowCancelOrPause(request)) {
      return;
    }
    request.followRedirect();
  }

  @Override
  public void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
    checkExecutorThread();
    assertFalse(request.isDone());
    assertTrue(mResponseStep == ResponseStep.NOTHING ||
               mResponseStep == ResponseStep.ON_RECEIVED_REDIRECT);
    assertNull(mError);

    mResponseStep = ResponseStep.ON_RESPONSE_STARTED;
    mResponseInfo = info;
    if (maybeThrowCancelOrPause(request)) {
      return;
    }
    startNextRead(request);
  }

  @Override
  public void onReadCompleted(UrlRequest request, UrlResponseInfo info, ByteBuffer byteBuffer) {
    checkExecutorThread();
    assertFalse(request.isDone());
    assertTrue(mResponseStep == ResponseStep.ON_RESPONSE_STARTED ||
               mResponseStep == ResponseStep.ON_READ_COMPLETED);
    assertNull(mError);

    mResponseStep = ResponseStep.ON_READ_COMPLETED;

    final byte[] lastDataReceivedAsBytes;
    final int bytesRead = byteBuffer.position() - mBufferPositionBeforeRead;
    mHttpResponseDataLength += bytesRead;
    lastDataReceivedAsBytes = new byte[bytesRead];
    // Rewind |byteBuffer.position()| to pre-read() position.
    byteBuffer.position(mBufferPositionBeforeRead);
    // This restores |byteBuffer.position()| to its value on entrance to
    // this function.
    byteBuffer.get(lastDataReceivedAsBytes);
    mResponseAsString += new String(lastDataReceivedAsBytes);

    if (maybeThrowCancelOrPause(request)) {
      return;
    }
    startNextRead(request);
  }

  @Override
  public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
    checkExecutorThread();
    assertTrue(request.isDone());
    assertTrue(mResponseStep == ResponseStep.ON_RESPONSE_STARTED ||
               mResponseStep == ResponseStep.ON_READ_COMPLETED);
    assertFalse(mOnErrorCalled);
    assertFalse(mOnCanceledCalled);
    assertNull(mError);

    mResponseStep = ResponseStep.ON_SUCCEEDED;
    mResponseInfo = info;
    openDone();
    maybeThrowCancelOrPause(request);
  }

  @Override
  public void onFailed(UrlRequest request, UrlResponseInfo info, CronetException error) {
    // If the failure is because of prohibited direct execution, the test shouldn't fail
    // since the request already did.
    if (error.getCause() instanceof InlineExecutionProhibitedException) {
      mAllowDirectExecutor = true;
    }
    checkExecutorThread();
    assertTrue(request.isDone());
    // Shouldn't happen after success.
    assertTrue(mResponseStep != ResponseStep.ON_SUCCEEDED);
    // Should happen at most once for a single request.
    assertFalse(mOnErrorCalled);
    assertFalse(mOnCanceledCalled);
    assertNull(mError);
    if (mCallbackExceptionThrown) {
      assertTrue(error instanceof CallbackException);
      assertContains("Exception received from UrlRequest.Callback", error.getMessage());
      assertNotNull(error.getCause());
      assertTrue(error.getCause() instanceof IllegalStateException);
      assertContains("Listener Exception.", error.getCause().getMessage());
    }

    mResponseStep = ResponseStep.ON_FAILED;
    mOnErrorCalled = true;
    mError = error;
    openDone();
    maybeThrowCancelOrPause(request);
  }

  @Override
  public void onCanceled(UrlRequest request, UrlResponseInfo info) {
    checkExecutorThread();
    assertTrue(request.isDone());
    // Should happen at most once for a single request.
    assertFalse(mOnCanceledCalled);
    assertFalse(mOnErrorCalled);
    assertNull(mError);

    mResponseStep = ResponseStep.ON_CANCELED;
    mOnCanceledCalled = true;
    openDone();
    maybeThrowCancelOrPause(request);
  }

  public void startNextRead(UrlRequest request) {
    startNextRead(request, ByteBuffer.allocateDirect(mReadBufferSize));
  }

  public void startNextRead(UrlRequest request, ByteBuffer buffer) {
    mBufferPositionBeforeRead = buffer.position();
    request.read(buffer);
  }

  public boolean isDone() { return !mDone.isBlocked(); }

  protected void openDone() { mDone.open(); }

  private void checkExecutorThread() {
    if (!mAllowDirectExecutor) {
      assertEquals(mExecutorThread, Thread.currentThread());
    }
  }

  /**
   * Returns {@code false} if the listener should continue to advance the request.
   */
  private boolean maybeThrowCancelOrPause(final UrlRequest request) {
    checkExecutorThread();
    if (mResponseStep != mFailureStep || mFailureType == FailureType.NONE) {
      if (!mAutoAdvance) {
        mStepBlock.open();
        return true;
      }
      return false;
    }

    if (mFailureType == FailureType.THROW_SYNC) {
      assertFalse(mCallbackExceptionThrown);
      mCallbackExceptionThrown = true;
      throw new IllegalStateException("Listener Exception.");
    }
    Runnable task = new Runnable() {
      @Override
      public void run() {
        request.cancel();
      }
    };
    if (mFailureType == FailureType.CANCEL_ASYNC ||
        mFailureType == FailureType.CANCEL_ASYNC_WITHOUT_PAUSE) {
      getExecutor().execute(task);
    } else {
      task.run();
    }
    return mFailureType != FailureType.CANCEL_ASYNC_WITHOUT_PAUSE;
  }
}
package org.chromium.net.testing;

import static junit.framework.Assert.assertTrue;

import org.chromium.net.CronetEngine;
import org.chromium.net.ExperimentalCronetEngine;

/**
 * Helper class to set up request filters for testing purposes.
 * TODO("https://github.com/envoyproxy/envoy-mobile/issues/1549")
 */
public final class MockUrlRequestJobFactory {

  private static final String TEST_URL = "http://0.0.0.0:10000";

  private final CronetEngine mCronetEngine;

  /**
   * Sets up URL interceptors.
   */
  public MockUrlRequestJobFactory(CronetEngine cronetEngine) { mCronetEngine = cronetEngine; }

  /**
   * Sets up request filters.
   * This adds a request filter to the cronetEngine before building.
   */
  public MockUrlRequestJobFactory(ExperimentalCronetEngine.Builder builder) {
    // Add a filter to immediately return a response
    mCronetEngine =
        CronetTestUtil.getCronetEngineBuilderImpl(builder).addUrlInterceptorsForTesting().build();
  }

  /**
   * Remove URL Interceptors.
   */
  public void shutdown() {
    // Remove the filter;
    mCronetEngine.shutdown();
  }

  public ExperimentalCronetEngine getCronetEngine() {
    return (ExperimentalCronetEngine)mCronetEngine;
  }

  /**
   * Constructs a mock URL that hangs or fails at certain phase.
   *
   * @param phase at which request fails. It should be a value in
   *              org.chromium.net.test.FailurePhase.
   * @param @param envoyMobileError reported by the engine.
   */
  public static String getMockUrlWithFailure(long envoyMobileError) {
    return TEST_URL + "/failed?error=" + envoyMobileError;
  }

  public static String getMockQuicUrlWithFailure(long envoyMobileError) {
    return TEST_URL + "/failed?quic=1&error=" + envoyMobileError;
  }

  public static String getMockUrlWithFailure(FailurePhase phase, int netError) {
    throw new UnsupportedOperationException("To be implemented or deleted");
  }

  /**
   * Constructs a mock URL that synchronously responds with data repeated many
   * times.
   *
   * @param data to return in response.
   * @param dataRepeatCount number of times to repeat the data.
   */
  public static String getMockUrlForData(String data, int dataRepeatCount) {
    return "To be implemented";
  }

  /**
   * Constructs a mock URL that will request client certificate and return
   * the string "data" as the response.
   */
  public static String getMockUrlForClientCertificateRequest() { return "To be implemented"; }

  /**
   * Constructs a mock URL that will fail with an SSL certificate error.
   */
  public static String getMockUrlForSSLCertificateError() { return "To be implemented"; }

  /**
   * Constructs a mock URL that will hang when try to read response body from the remote.
   */
  public static String getMockUrlForHangingRead() { return "To be implemented"; }
}
package org.chromium.net;

import static org.chromium.net.CronetEngine.Builder.HTTP_CACHE_IN_MEMORY;
import static org.chromium.net.testing.CronetTestRule.assertContains;
import static org.chromium.net.testing.CronetTestRule.getContext;
import static org.chromium.net.testing.CronetTestRule.getTestStorage;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.content.Context;
import android.content.ContextWrapper;
import android.os.ConditionVariable;
import android.os.Handler;
import android.os.Looper;
import android.os.Process;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.net.URL;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.concurrent.Callable;
import java.util.concurrent.Executor;
import java.util.concurrent.FutureTask;
import java.util.concurrent.atomic.AtomicReference;
import org.chromium.net.impl.CronvoyUrlRequestContext;
import org.chromium.net.impl.NativeCronvoyEngineBuilderImpl;
import org.chromium.net.testing.CronetTestRule;
import org.chromium.net.testing.CronetTestRule.CronetTestFramework;
import org.chromium.net.testing.CronetTestRule.RequiresMinApi;
import org.chromium.net.testing.Feature;
import org.chromium.net.testing.FileUtils;
import org.chromium.net.testing.NativeTestServer;
import org.chromium.net.testing.PathUtils;
import org.chromium.net.testing.TestUrlRequestCallback;
import org.chromium.net.testing.TestUrlRequestCallback.ResponseStep;
import org.json.JSONObject;
import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Test CronetEngine.
 */
@RunWith(AndroidJUnit4.class)
public class CronetUrlRequestContextTest {
  @Rule public final CronetTestRule mTestRule = new CronetTestRule();

  private static final String TAG = CronetUrlRequestContextTest.class.getSimpleName();

  // URLs used for tests.
  private static final String MOCK_CRONET_TEST_FAILED_URL = "http://mock.failed.request/-2";
  private static final String MOCK_CRONET_TEST_SUCCESS_URL = "http://mock.http/success.txt";
  private static final int MAX_FILE_SIZE = 1000000000;
  private static final int NUM_EVENT_FILES = 10;

  private String mUrl;
  private String mUrl404;
  private String mUrl500;

  @Before
  public void setUp() {
    NativeTestServer.startNativeTestServer(getContext());
    mUrl = NativeTestServer.getSuccessURL();
    mUrl404 = NativeTestServer.getNotFoundURL();
    mUrl500 = NativeTestServer.getInternalErrorURL();
  }

  @After
  public void tearDown() {
    NativeTestServer.shutdownNativeTestServer();
  }

  static class RequestThread extends Thread {
    public TestUrlRequestCallback mCallback;

    final String mUrl;
    final ConditionVariable mRunBlocker;

    public RequestThread(String url, ConditionVariable runBlocker) {
      mUrl = url;
      mRunBlocker = runBlocker;
    }

    @Override
    public void run() {
      mRunBlocker.block();
      CronetEngine cronetEngine = new CronetEngine.Builder(getContext()).build();
      mCallback = new TestUrlRequestCallback();
      UrlRequest.Builder urlRequestBuilder =
          cronetEngine.newUrlRequestBuilder(mUrl, mCallback, mCallback.getExecutor());
      urlRequestBuilder.build().start();
      mCallback.blockForDone();
      cronetEngine.shutdown();
    }
  }

  /**
   * Callback that shutdowns the request context when request has succeeded
   * or failed.
   */
  static class ShutdownTestUrlRequestCallback extends TestUrlRequestCallback {
    private final CronetEngine mCronetEngine;
    private final ConditionVariable mCallbackCompletionBlock = new ConditionVariable();

    ShutdownTestUrlRequestCallback(CronetEngine cronetEngine) { mCronetEngine = cronetEngine; }

    @Override
    public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
      super.onSucceeded(request, info);
      mCronetEngine.shutdown();
      mCallbackCompletionBlock.open();
    }

    @Override
    public void onFailed(UrlRequest request, UrlResponseInfo info, CronetException error) {
      super.onFailed(request, info, error);
      mCronetEngine.shutdown();
      mCallbackCompletionBlock.open();
    }

    // Wait for request completion callback.
    void blockForCallbackToComplete() { mCallbackCompletionBlock.block(); }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testConfigUserAgent() throws Exception {
    String userAgentName = "User-Agent";
    String userAgentValue = "User-Agent-Value";
    ExperimentalCronetEngine.Builder cronetEngineBuilder =
        new ExperimentalCronetEngine.Builder(getContext());
    cronetEngineBuilder.setUserAgent(userAgentValue);
    final CronetEngine cronetEngine = cronetEngineBuilder.build();
    NativeTestServer.shutdownNativeTestServer(); // startNativeTestServer returns false if it's
    // already running
    assertTrue(NativeTestServer.startNativeTestServer(getContext()));
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder = cronetEngine.newUrlRequestBuilder(
        NativeTestServer.getEchoHeaderURL(userAgentName), callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    assertEquals(userAgentValue, callback.mResponseAsString);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // TODO: Remove the annotation after fixing http://crbug.com/637979 & http://crbug.com/637972
  @Ignore("Properly implement shutdown sequence")
  public void testShutdown() throws Exception {
    final CronetTestFramework testFramework = mTestRule.startCronetTestFramework();
    ShutdownTestUrlRequestCallback callback =
        new ShutdownTestUrlRequestCallback(testFramework.mCronetEngine);
    // Block callback when response starts to verify that shutdown fails
    // if there are active requests.
    callback.setAutoAdvance(false);
    UrlRequest.Builder urlRequestBuilder =
        testFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    UrlRequest urlRequest = urlRequestBuilder.build();
    urlRequest.start();
    try {
      testFramework.mCronetEngine.shutdown();
      fail("Should throw an exception");
    } catch (Exception e) {
      assertEquals("Cannot shutdown with active requests.", e.getMessage());
    }

    callback.waitForNextStep();
    assertEquals(ResponseStep.ON_RESPONSE_STARTED, callback.mResponseStep);
    try {
      testFramework.mCronetEngine.shutdown();
      fail("Should throw an exception");
    } catch (Exception e) {
      assertEquals("Cannot shutdown with active requests.", e.getMessage());
    }
    callback.startNextRead(urlRequest);

    callback.waitForNextStep();
    assertEquals(ResponseStep.ON_READ_COMPLETED, callback.mResponseStep);
    try {
      testFramework.mCronetEngine.shutdown();
      fail("Should throw an exception");
    } catch (Exception e) {
      assertEquals("Cannot shutdown with active requests.", e.getMessage());
    }

    // May not have read all the data, in theory. Just enable auto-advance
    // and finish the request.
    callback.setAutoAdvance(true);
    callback.startNextRead(urlRequest);
    callback.blockForDone();
    callback.blockForCallbackToComplete();
    callback.shutdownExecutor();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Test is running on main thread")
  public void testShutdownDuringInit() throws Exception {
    final ConditionVariable block = new ConditionVariable(false);

    // Post a task to main thread to block until shutdown is called to test
    // scenario when shutdown is called right after construction before
    // context is fully initialized on the main thread.
    Runnable blockingTask = new Runnable() {
      @Override
      public void run() {
        try {
          block.block();
        } catch (Exception e) {
          fail("Caught " + e.getMessage());
        }
      }
    };
    // Ensure that test is not running on the main thread.
    assertTrue(Looper.getMainLooper() != Looper.myLooper());
    new Handler(Looper.getMainLooper()).post(blockingTask);

    // Create new request context, but its initialization on the main thread
    // will be stuck behind blockingTask.
    final CronvoyUrlRequestContext cronetEngine =
        (CronvoyUrlRequestContext) new CronetEngine.Builder(getContext()).build();
    // Unblock the main thread, so context gets initialized and shutdown on
    // it.
    block.open();
    // Shutdown will wait for init to complete on main thread.
    cronetEngine.shutdown();
    // Verify that context is shutdown.
    assertTrue("Engine is shutdown", cronetEngine.hasShutdown());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Properly implement shutdown sequence")
  public void testInitAndShutdownOnMainThread() throws Exception {
    final ConditionVariable block = new ConditionVariable(false);

    // Post a task to main thread to init and shutdown on the main thread.
    Runnable blockingTask = new Runnable() {
      @Override
      public void run() {
        // Create new request context, loading the library.
        final CronvoyUrlRequestContext cronetEngine =
            (CronvoyUrlRequestContext) new CronetEngine.Builder(getContext()).build();
        // Shutdown right after init.
        cronetEngine.shutdown();
        // Verify that context is shutdown.
        assertTrue("Engine is shutdown", cronetEngine.hasShutdown());
        block.open();
      }
    };
    new Handler(Looper.getMainLooper()).post(blockingTask);
    // Wait for shutdown to complete on main thread.
    block.block();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Properly implement shutdown sequence")
  public void testMultipleShutdown() throws Exception {
    final CronetTestFramework testFramework = mTestRule.startCronetTestFramework();
    try {
      testFramework.mCronetEngine.shutdown();
      testFramework.mCronetEngine.shutdown();
      fail("Should throw an exception");
    } catch (Exception e) {
      assertEquals("Engine is shut down.", e.getMessage());
    }
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // TODO: Remove the annotation after fixing http://crbug.com/637972
  @Ignore("Properly implement shutdown sequence")
  public void testShutdownAfterError() throws Exception {
    final CronetTestFramework testFramework = mTestRule.startCronetTestFramework();
    ShutdownTestUrlRequestCallback callback =
        new ShutdownTestUrlRequestCallback(testFramework.mCronetEngine);
    UrlRequest.Builder urlRequestBuilder = testFramework.mCronetEngine.newUrlRequestBuilder(
        MOCK_CRONET_TEST_FAILED_URL, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    assertTrue(callback.mOnErrorCalled);
    callback.blockForCallbackToComplete();
    callback.shutdownExecutor();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Shutdown not properly implemented")
  public void testShutdownAfterCancel() throws Exception {
    final CronetTestFramework testFramework = mTestRule.startCronetTestFramework();
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    // Block callback when response starts to verify that shutdown fails
    // if there are active requests.
    callback.setAutoAdvance(false);
    UrlRequest.Builder urlRequestBuilder =
        testFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    UrlRequest urlRequest = urlRequestBuilder.build();
    urlRequest.start();
    try {
      testFramework.mCronetEngine.shutdown();
      fail("Should throw an exception");
    } catch (Exception e) {
      assertEquals("Cannot shutdown with active requests.", e.getMessage());
    }
    callback.waitForNextStep();
    assertEquals(ResponseStep.ON_RESPONSE_STARTED, callback.mResponseStep);
    urlRequest.cancel();
    testFramework.mCronetEngine.shutdown();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testNetLog() throws Exception {
    Context context = getContext();
    File directory = new File(PathUtils.getDataDirectory());
    File file = File.createTempFile("cronet", "json", directory);
    CronetEngine cronetEngine = new CronetEngine.Builder(context).build();
    // Start NetLog immediately after the request context is created to make
    // sure that the call won't crash the app even when the native request
    // context is not fully initialized. See crbug.com/470196.
    cronetEngine.startNetLogToFile(file.getPath(), false);

    // Start a request.
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        cronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    cronetEngine.stopNetLog();
    assertTrue(file.exists());
    assertTrue(file.length() != 0);
    assertTrue(hasDebugInNetLog(file));
    assertFalse(hasTraceInNetLog(file));
    assertTrue(file.delete());
    assertTrue(!file.exists());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBoundedFileNetLog() throws Exception {
    Context context = getContext();
    File directory = new File(PathUtils.getDataDirectory());
    File netLogDir = new File(directory, "NetLog");
    assertFalse(netLogDir.exists());
    assertTrue(netLogDir.mkdir());
    File logFile = new File(netLogDir, "netlog.json");
    ExperimentalCronetEngine cronetEngine = new ExperimentalCronetEngine.Builder(context).build();
    // Start NetLog immediately after the request context is created to make
    // sure that the call won't crash the app even when the native request
    // context is not fully initialized. See crbug.com/470196.
    cronetEngine.startNetLogToDisk(netLogDir.getPath(), false, MAX_FILE_SIZE);

    // Start a request.
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        cronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    cronetEngine.stopNetLog();
    assertTrue(logFile.exists());
    assertTrue(logFile.length() != 0);
    assertFalse(hasTraceInNetLog(logFile));
    FileUtils.recursivelyDeleteFile(netLogDir, FileUtils.DELETE_ALL);
    assertFalse(netLogDir.exists());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Tests that if stopNetLog is not explicitly called, CronetEngine.shutdown()
  // will take care of it. crbug.com/623701.
  public void testNoStopNetLog() throws Exception {
    Context context = getContext();
    File directory = new File(PathUtils.getDataDirectory());
    File file = File.createTempFile("cronet", "json", directory);
    CronetEngine cronetEngine = new CronetEngine.Builder(context).build();
    cronetEngine.startNetLogToFile(file.getPath(), false);

    // Start a request.
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        cronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    // Shut down the engine without calling stopNetLog.
    cronetEngine.shutdown();
    assertTrue(file.exists());
    assertTrue(hasDebugInNetLog(file));
    assertFalse(hasTraceInNetLog(file));
    assertTrue(file.delete());
    assertTrue(!file.exists());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Tests that if stopNetLog is not explicitly called, CronetEngine.shutdown()
  // will take care of it. crbug.com/623701.
  public void testNoStopBoundedFileNetLog() throws Exception {
    Context context = getContext();
    File directory = new File(PathUtils.getDataDirectory());
    File netLogDir = new File(directory, "NetLog");
    assertFalse(netLogDir.exists());
    assertTrue(netLogDir.mkdir());
    File logFile = new File(netLogDir, "netlog.json");
    ExperimentalCronetEngine cronetEngine = new ExperimentalCronetEngine.Builder(context).build();
    cronetEngine.startNetLogToDisk(netLogDir.getPath(), false, MAX_FILE_SIZE);

    // Start a request.
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        cronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    // Shut down the engine without calling stopNetLog.
    cronetEngine.shutdown();
    assertTrue(logFile.exists());
    assertTrue(logFile.length() != 0);

    FileUtils.recursivelyDeleteFile(netLogDir, FileUtils.DELETE_ALL);
    assertFalse(netLogDir.exists());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Unlike Cronet, Cronvoy will log all events emitted to the last log file requested.
  public void testNetLogContainEventsFromAllLiveEngines() throws Exception {
    Context context = getContext();
    File directory = new File(PathUtils.getDataDirectory());
    File file1 = File.createTempFile("cronet1", "json", directory);
    File file2 = File.createTempFile("cronet2", "json", directory);
    CronetEngine cronetEngine1 = new CronetEngine.Builder(context).build();
    CronetEngine cronetEngine2 = new CronetEngine.Builder(context).build();

    cronetEngine1.startNetLogToFile(file1.getPath(), false);
    cronetEngine2.startNetLogToFile(file2.getPath(), false);

    // Warm CronetEngine and make sure both CronetUrlRequestContexts are
    // initialized before testing the logs.
    makeRequestAndCheckStatus(cronetEngine1, mUrl, 200);
    makeRequestAndCheckStatus(cronetEngine2, mUrl, 200);

    // Use cronetEngine1 to make a request to mUrl404.
    makeRequestAndCheckStatus(cronetEngine1, mUrl404, 404);

    // Use cronetEngine2 to make a request to mUrl500.
    makeRequestAndCheckStatus(cronetEngine2, mUrl500, 500);

    cronetEngine1.stopNetLog();
    cronetEngine2.stopNetLog();
    assertTrue(file1.exists());
    assertTrue(file2.exists());
    assertTrue(containsStringInNetLog(file2, NativeTestServer.getNotFoundPath()));
    assertTrue(containsStringInNetLog(file2, NativeTestServer.getInternalErrorPath()));
    assertTrue(file1.delete());
    assertTrue(file2.delete());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  // Unlike Cronet, Cronvoy will log all events emitted to the last log file requested.
  public void testBoundedFileNetLogContainEventsFromAllLiveEngines() throws Exception {
    Context context = getContext();
    File directory = new File(PathUtils.getDataDirectory());
    File netLogDir1 = new File(directory, "NetLog1");
    assertFalse(netLogDir1.exists());
    assertTrue(netLogDir1.mkdir());
    File netLogDir2 = new File(directory, "NetLog2");
    assertFalse(netLogDir2.exists());
    assertTrue(netLogDir2.mkdir());
    File logFile1 = new File(netLogDir1, "netlog.json");
    File logFile2 = new File(netLogDir2, "netlog.json");

    ExperimentalCronetEngine cronetEngine1 = new ExperimentalCronetEngine.Builder(context).build();
    ExperimentalCronetEngine cronetEngine2 = new ExperimentalCronetEngine.Builder(context).build();

    cronetEngine1.startNetLogToDisk(netLogDir1.getPath(), false, MAX_FILE_SIZE);
    cronetEngine2.startNetLogToDisk(netLogDir2.getPath(), false, MAX_FILE_SIZE);

    // Warm CronetEngine and make sure both CronetUrlRequestContexts are
    // initialized before testing the logs.
    makeRequestAndCheckStatus(cronetEngine1, mUrl, 200);
    makeRequestAndCheckStatus(cronetEngine2, mUrl, 200);

    // Use cronetEngine1 to make a request to mUrl404.
    makeRequestAndCheckStatus(cronetEngine1, mUrl404, 404);

    // Use cronetEngine2 to make a request to mUrl500.
    makeRequestAndCheckStatus(cronetEngine2, mUrl500, 500);

    cronetEngine1.stopNetLog();
    cronetEngine2.stopNetLog();

    assertTrue(logFile1.exists());
    assertTrue(logFile2.exists());

    BufferedReader logReader = new BufferedReader(new FileReader(logFile2));
    String logLine;
    logReader.close();

    assertTrue(logFile2.length() != 0);

    assertTrue(containsStringInNetLog(logFile2, NativeTestServer.getNotFoundPath()));
    assertTrue(containsStringInNetLog(logFile2, NativeTestServer.getInternalErrorPath()));

    FileUtils.recursivelyDeleteFile(netLogDir1, FileUtils.DELETE_ALL);
    assertFalse(netLogDir1.exists());
    FileUtils.recursivelyDeleteFile(netLogDir2, FileUtils.DELETE_ALL);
    assertFalse(netLogDir2.exists());
  }

  private CronetEngine createCronetEngineWithCache(int cacheType) {
    CronetEngine.Builder builder = new CronetEngine.Builder(getContext());
    if (cacheType == CronetEngine.Builder.HTTP_CACHE_DISK ||
        cacheType == CronetEngine.Builder.HTTP_CACHE_DISK_NO_HTTP) {
      builder.setStoragePath(getTestStorage());
    }
    builder.enableHttpCache(cacheType, 100 * 1024);
    // Don't check the return value here, because startNativeTestServer() returns false when the
    // NativeTestServer is already running and this method needs to be called twice without
    // shutting down the NativeTestServer in between.
    NativeTestServer.startNativeTestServer(getContext());
    return builder.build();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Caching not implemented yet: https://github.com/envoyproxy/envoy-mobile/issues/1578")
  // Tests that if CronetEngine is shut down on the network thread, an appropriate exception
  // is thrown.
  public void testShutDownEngineOnNetworkThread() throws Exception {
    final CronetEngine cronetEngine =
        createCronetEngineWithCache(CronetEngine.Builder.HTTP_CACHE_DISK);
    String url = NativeTestServer.getFileURL("/cacheable.txt");
    // Make a request to a cacheable resource.
    checkRequestCaching(cronetEngine, url, false);

    final AtomicReference<Throwable> thrown = new AtomicReference<>();
    // Shut down the server.
    NativeTestServer.shutdownNativeTestServer();
    class CancelUrlRequestCallback extends TestUrlRequestCallback {
      @Override
      public void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
        super.onResponseStarted(request, info);
        request.cancel();
        // Shut down CronetEngine immediately after request is destroyed.
        try {
          cronetEngine.shutdown();
        } catch (Exception e) {
          thrown.set(e);
        }
      }

      @Override
      public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
        // onSucceeded will not happen, because the request is canceled
        // after sending first read and the executor is single threaded.
        throw new RuntimeException("Unexpected");
      }

      @Override
      public void onFailed(UrlRequest request, UrlResponseInfo info, CronetException error) {
        throw new RuntimeException("Unexpected");
      }
    }
    Executor directExecutor = new Executor() {
      @Override
      public void execute(Runnable command) {
        command.run();
      }
    };
    CancelUrlRequestCallback callback = new CancelUrlRequestCallback();
    callback.setAllowDirectExecutor(true);
    UrlRequest.Builder urlRequestBuilder =
        cronetEngine.newUrlRequestBuilder(url, callback, directExecutor);
    urlRequestBuilder.allowDirectExecutor();
    urlRequestBuilder.build().start();
    callback.blockForDone();
    assertTrue(thrown.get() instanceof RuntimeException);
    cronetEngine.shutdown();
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  @Ignore("Caching not implemented yet: https://github.com/envoyproxy/envoy-mobile/issues/1578")
  // Tests that if CronetEngine is shut down when reading from disk cache,
  // there isn't a crash. See crbug.com/486120.
  public void testShutDownEngineWhenReadingFromDiskCache() throws Exception {
    final CronetEngine cronetEngine =
        createCronetEngineWithCache(CronetEngine.Builder.HTTP_CACHE_DISK);
    String url = NativeTestServer.getFileURL("/cacheable.txt");
    // Make a request to a cacheable resource.
    checkRequestCaching(cronetEngine, url, false);

    // Shut down the server.
    NativeTestServer.shutdownNativeTestServer();
    class CancelUrlRequestCallback extends TestUrlRequestCallback {
      @Override
      public void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
        super.onResponseStarted(request, info);
        request.cancel();
        // Shut down CronetEngine immediately after request is destroyed.
        cronetEngine.shutdown();
      }

      @Override
      public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
        // onSucceeded will not happen, because the request is canceled
        // after sending first read and the executor is single threaded.
        throw new RuntimeException("Unexpected");
      }

      @Override
      public void onFailed(UrlRequest request, UrlResponseInfo info, CronetException error) {
        throw new RuntimeException("Unexpected");
      }
    }
    CancelUrlRequestCallback callback = new CancelUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        cronetEngine.newUrlRequestBuilder(url, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    assertEquals(200, callback.mResponseInfo.getHttpStatusCode());
    assertTrue(callback.mResponseInfo.wasCached());
    assertTrue(callback.mOnCanceledCalled);
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testNetLogAfterShutdown() throws Exception {
    final CronetTestFramework testFramework = mTestRule.startCronetTestFramework();
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        testFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    testFramework.mCronetEngine.shutdown();

    File directory = new File(PathUtils.getDataDirectory());
    File file = File.createTempFile("cronet", "json", directory);
    try {
      testFramework.mCronetEngine.startNetLogToFile(file.getPath(), false);
      fail("Should throw an exception.");
    } catch (Exception e) {
      assertEquals("Engine is shut down.", e.getMessage());
    }
    assertFalse(hasTraceInNetLog(file));
    assertTrue(file.delete());
    assertFalse(file.exists());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testBoundedFileNetLogAfterShutdown() throws Exception {
    final CronetTestFramework testFramework = mTestRule.startCronetTestFramework();
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        testFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
    callback.blockForDone();
    testFramework.mCronetEngine.shutdown();

    File directory = new File(PathUtils.getDataDirectory());
    File netLogDir = new File(directory, "NetLog");
    assertFalse(netLogDir.exists());
    assertTrue(netLogDir.mkdir());
    File logFile = new File(netLogDir, "netlog.json");
    try {
      testFramework.mCronetEngine.startNetLogToDisk(netLogDir.getPath(), false, MAX_FILE_SIZE);
      fail("Should throw an exception.");
    } catch (Exception e) {
      assertEquals("Engine is shut down.", e.getMessage());
    }
    assertFalse(logFile.exists());
    FileUtils.recursivelyDeleteFile(netLogDir, FileUtils.DELETE_ALL);
    assertFalse(netLogDir.exists());
  }

  @Test
  @SmallTest
  @Feature({"Cronet"})
  public void testNetLogStartMultipleTimes() throws Exception {
    final CronetTestFramework testFramework = mTestRule.startCronetTestFramework();
    File directory = new File(PathUtils.getDataDirectory());
    File file = File.createTempFile("cronet", "json", directory);
    // Start NetLog multiple times.
    testFramework.mCronetEngine.startNetLogToFile(file.getPath(), false);
    testFramework.mCronetEngine.startNetLogToFile(file.getPath(), false);
    testFramework.mCronetEngine.startNetLogToFile(file.getPath(), false);
    testFramework.mCronetEngine.startNetLogToFile(file.getPath(), false);
    // Start a request.
    TestUrlRequestCallback callback = new TestUrlRequestCallback();
    UrlRequest.Builder urlRequestBuilder =
        testFramework.mCronetEngine.newUrlRequestBuilder(mUrl, callback, callback.getExecutor());
    urlRequestBuilder.build().start();
   